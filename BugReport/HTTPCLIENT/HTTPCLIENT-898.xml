<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:22:02 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-898/HTTPCLIENT-898.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-898] Improve multihome support</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-898</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>MultihomePlainSocketFactory is basically broken and should be deprecated. Multihome logic needs to be moved to the DefaultClientConnectionOperator</description>
                <environment></environment>
            <key id="12442972">HTTPCLIENT-898</key>
            <summary>Improve multihome support</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="olegk">Oleg Kalnichevski</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Dec 2009 10:45:52 +0000</created>
                <updated>Tue, 25 Jan 2011 10:59:26 +0000</updated>
                    <resolved>Thu, 8 Apr 2010 18:28:53 +0100</resolved>
                            <version>4.0 Final</version>
                <version>4.0.1</version>
                <version>4.1 Alpha1</version>
                                <fixVersion>4.1 Alpha2</fixVersion>
                                <component>HttpConn</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12788684" author="glynd" created="Thu, 10 Dec 2009 11:35:58 +0000"  >Hi Oleg,&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t know if this is of use, but is the logic I am using at the moment, which is an extension of the existing DefaultMultihomePlainSocketFactory&lt;br/&gt;
&lt;br/&gt;
Essentially, this shares the set timeout between the available &amp;#39;A&amp;#39; records, and allows iteration through those.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
List&amp;lt;InetAddress&amp;gt; addresses = new ArrayList&amp;lt;InetAddress&amp;gt;(inetadrs.length);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;addresses.addAll(Arrays.asList(inetadrs));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Collections.shuffle(addresses);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IOException lastEx = null;        &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int individualTimeout = timeout / addresses.size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i=0;i&amp;lt;addresses.size();i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InetAddress remoteAddress =  addresses.get(i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try { &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wireLog.debug(&amp;quot;Attempting to connect to &amp;quot;+remoteAddress+&amp;quot;:&amp;quot;+port+&amp;quot; with timeout value of &amp;quot;+individualTimeout);                &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sock.connect(new InetSocketAddress(remoteAddress, port), individualTimeout);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wireLog.debug(&amp;quot;RETURNING SOCKET - &amp;quot;+sock.toString());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return sock;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (SocketTimeoutException ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// If the last socket on the list, then throw a timeout exception&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (i == addresses.size()-1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wireLog.warn(&amp;quot;Connect to &amp;quot; + remoteAddress + &amp;quot; timed out.  Throwing timeout exception.&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new ConnectTimeoutException(&amp;quot;Connect to &amp;quot; + remoteAddress + &amp;quot; timed out&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wireLog.warn(&amp;quot;Connect to &amp;quot; + remoteAddress + &amp;quot; timed out.  Trying next in the list.&amp;quot;);        &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// should we close the old socket?!&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sock = new Socket();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// create new socket&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// should we close the old socket?!&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sock = new Socket();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wireLog.warn(&amp;quot;Connect to &amp;quot; + remoteAddress + &amp;quot; caused exception.  Trying next in the list.&amp;quot;, ex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// keep the last exception and retry&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lastEx = ex;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12835739" author="sesse" created="Fri, 19 Feb 2010 13:06:19 +0000"  >Two comments:&lt;br/&gt;
&lt;br/&gt;
- Please don&amp;#39;t use Collections.shuffle() on the address list. The list comes from the resolver in a given order for good reasons (see RFC 3484), and randomizing it will do Very Bad Things in some situations.&lt;br/&gt;
- The address list can potentially be very long (20+ addresses). Trying to divide the timeout evenly between these addresses might not be the best thing to do. Most other libraries simply specify that timeout is done once per host tried, which would probably not be unreasonable here either.</comment>
                    <comment id="12843197" author="sesse" created="Tue, 9 Mar 2010 16:59:12 +0000"  >FWIW, the following code fragment was newly checked into Android&amp;#39;s repository. Note that you need to deal with LayeredSocketFactory specifically, or you will break SSL, since SSLSocketFactory uses the given (textual) hostname both to figure out where to connect and for SSL hostname verification (so if you just give it an IP, it breaks verification).&lt;br/&gt;
&lt;br/&gt;
diff --git a/src/org/apache/http/conn/scheme/PlainSocketFactory.java b/src/org/apache/http/conn/scheme/PlainSocketFactory.java&lt;br/&gt;
index acc13f7..b15df44 100644&lt;br/&gt;
--- a/src/org/apache/http/conn/scheme/PlainSocketFactory.java&lt;br/&gt;
+++ b/src/org/apache/http/conn/scheme/PlainSocketFactory.java&lt;br/&gt;
@@ -35,7 +35,9 @@ import java.io.IOException;&lt;br/&gt;
&amp;nbsp;import java.net.InetAddress;&lt;br/&gt;
&amp;nbsp;import java.net.InetSocketAddress;&lt;br/&gt;
&amp;nbsp;import java.net.Socket;&lt;br/&gt;
+import java.net.SocketTimeoutException;&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
+import org.apache.http.conn.ConnectTimeoutException;&lt;br/&gt;
&amp;nbsp;import org.apache.http.params.HttpConnectionParams;&lt;br/&gt;
&amp;nbsp;import org.apache.http.params.HttpParams;&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
@@ -113,9 +115,11 @@ public final class PlainSocketFactory implements SocketFactory {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;remoteAddress = new InetSocketAddress(host, port);            &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
-        &lt;br/&gt;
-        sock.connect(remoteAddress, timeout);&lt;br/&gt;
-&lt;br/&gt;
+        try {&lt;br/&gt;
+            sock.connect(remoteAddress, timeout);&lt;br/&gt;
+        } catch (SocketTimeoutException ex) {&lt;br/&gt;
+            throw new ConnectTimeoutException(&amp;quot;Connect to &amp;quot; + remoteAddress + &amp;quot; timed out&amp;quot;);&lt;br/&gt;
+        }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return sock;&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} // connectSocket&lt;br/&gt;
diff --git a/src/org/apache/http/impl/conn/DefaultClientConnectionOperator.java b/src/org/apache/http/impl/conn/DefaultClientConnectionOperator.java&lt;br/&gt;
index 41488e1..854b2b0 100644&lt;br/&gt;
--- a/src/org/apache/http/impl/conn/DefaultClientConnectionOperator.java&lt;br/&gt;
+++ b/src/org/apache/http/impl/conn/DefaultClientConnectionOperator.java&lt;br/&gt;
@@ -44,7 +44,9 @@ import org.apache.http.protocol.HttpContext;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.HttpHostConnectException;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.OperatedClientConnection;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.ClientConnectionOperator;&lt;br/&gt;
+import org.apache.http.conn.ConnectTimeoutException;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.scheme.LayeredSocketFactory;&lt;br/&gt;
+import org.apache.http.conn.scheme.PlainSocketFactory;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.scheme.Scheme;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.scheme.SchemeRegistry;&lt;br/&gt;
&amp;nbsp;import org.apache.http.conn.scheme.SocketFactory;&lt;br/&gt;
@@ -67,6 +69,7 @@ import org.apache.http.conn.scheme.SocketFactory;&lt;br/&gt;
&amp;nbsp;public class DefaultClientConnectionOperator&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;implements ClientConnectionOperator {&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
+    private static final PlainSocketFactory staticPlainSocketFactory = new PlainSocketFactory();&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/** The scheme registry for looking up socket factories. */&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;protected SchemeRegistry schemeRegistry;&lt;br/&gt;
@@ -121,19 +124,55 @@ public class DefaultClientConnectionOperator&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Scheme schm = schemeRegistry.getScheme(target.getSchemeName());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final SocketFactory sf = schm.getSocketFactory();&lt;br/&gt;
+        final SocketFactory plain_sf;&lt;br/&gt;
+        final LayeredSocketFactory layered_sf;&lt;br/&gt;
+        if (sf instanceof LayeredSocketFactory) {&lt;br/&gt;
+            plain_sf = staticPlainSocketFactory;&lt;br/&gt;
+            layered_sf = (LayeredSocketFactory)sf;&lt;br/&gt;
+        } else {&lt;br/&gt;
+            plain_sf = sf;&lt;br/&gt;
+            layered_sf = null;&lt;br/&gt;
+        }&lt;br/&gt;
+        InetAddress[] addresses = InetAddress.getAllByName(target.getHostName());&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-        Socket sock = sf.createSocket();&lt;br/&gt;
-        conn.opening(sock, target);&lt;br/&gt;
+        for (int i = 0; i &amp;lt; addresses.length; ++i) {&lt;br/&gt;
+            Socket sock = plain_sf.createSocket();&lt;br/&gt;
+            conn.opening(sock, target);&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-        try {&lt;br/&gt;
-            sock = sf.connectSocket(sock, target.getHostName(),&lt;br/&gt;
+            try {&lt;br/&gt;
+                Socket connsock = plain_sf.connectSocket(sock,&lt;br/&gt;
+                    addresses[i].getHostAddress(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;schm.resolvePort(target.getPort()),&lt;br/&gt;
+                        true);&lt;br/&gt;
+                    if (layeredsock != sock) {&lt;br/&gt;
+                        conn.opening(layeredsock, target);&lt;br/&gt;
+                    }&lt;br/&gt;
+                    prepareSocket(layeredsock, context, params);&lt;br/&gt;
+                    conn.openCompleted(sf.isSecure(layeredsock), params);&lt;br/&gt;
+                } else {&lt;br/&gt;
+                    prepareSocket(sock, context, params);&lt;br/&gt;
+                    conn.openCompleted(sf.isSecure(sock), params);&lt;br/&gt;
+                }&lt;br/&gt;
+                break;&lt;br/&gt;
+            } catch (ConnectException ex) {&lt;br/&gt;
+                if (i == addresses.length - 1) {&lt;br/&gt;
+                    throw new HttpHostConnectException(target, ex);&lt;br/&gt;
+                }&lt;br/&gt;
+            } catch (ConnectTimeoutException ex) {&lt;br/&gt;
+                if (i == addresses.length - 1) {&lt;br/&gt;
+                    throw ex;&lt;br/&gt;
+                }&lt;br/&gt;
+            }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
-        prepareSocket(sock, context, params);&lt;br/&gt;
-        conn.openCompleted(sf.isSecure(sock), params);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} // openConnection&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
</comment>
                    <comment id="12843323" author="olegk" created="Tue, 9 Mar 2010 22:10:09 +0000"  >I cannot find these changes in the master branch&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://android.git.kernel.org/?p=platform/external/apache-http.git;a=summary&quot;&gt;http://android.git.kernel.org/?p=platform/external/apache-http.git;a=summary&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I would be a shame if Google patched their own version of HttpClient, which is a very old pre-BETA snapshot, effectively creating a fork, instead of submitting them upstream.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12844078" author="sesse" created="Thu, 11 Mar 2010 14:29:35 +0000"  >It&amp;#39;s not in the public git tree yet, but it will be. I&amp;#39;m not entirely sure what you mean by &amp;quot;instead of submitting them upstream&amp;quot; -- the patch is right there in my comment?</comment>
                    <comment id="12844089" author="olegk" created="Thu, 11 Mar 2010 15:09:06 +0000"  >I did not realize you were with Google. My bad. I should have looked at your profile.&lt;br/&gt;
&lt;br/&gt;
(1) Do you happen to know if Andoid project has any plans of syncing their code line to the official HttpClient 4.0.x branch at some point of time? &lt;br/&gt;
&lt;br/&gt;
(2) As far your patch is concerned it does solve the problem. However I would prefer a more radical but somewhat cleaner approach. I am thinking about deprecating the actual SocketFactory and LayeredSocketFactory interfaces and all implementing classes and replacing them with similar interfaces that are multihome capable&lt;br/&gt;
&lt;br/&gt;
---&lt;br/&gt;
public interface SocketFactory {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Socket createSocket() throws IOException;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Socket connectSocket(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Socket sock,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String hostname, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InetAddress removeAddress, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int port, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InetAddress localAddress, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int localPort,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HttpParams params&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;) throws IOException, UnknownHostException, ConnectTimeoutException;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean isSecure(Socket sock) throws IllegalArgumentException;&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
---&lt;br/&gt;
&lt;br/&gt;
Alternatively we could introduce a optional interface for multihome support, which would be slightly uglier but would allow us to continue using all old interfaces and classes.&lt;br/&gt;
&lt;br/&gt;
What would be your preference?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12844792" author="sesse" created="Sat, 13 Mar 2010 01:28:19 +0000"  >In general I don&amp;#39;t work on Android (I&amp;#39;m working on IPv6, and this patch is mainly to improve the IPv6 support), so I can&amp;#39;t really speak for the Android team on that side. As far as I&amp;#39;ve understood, though, breaking API compatibility will be problematic (userspace applications depend on these APIs). I&amp;#39;d assume you already have contacts within the Android team with which you can discuss these issues? If not, I can try digging up some addresses if you want.</comment>
                    <comment id="12844841" author="olegk" created="Sat, 13 Mar 2010 09:51:08 +0000"  >This change will not result in API breakage. All deprecated code will still be in place. &lt;br/&gt;
&lt;br/&gt;
And yes, it would be great to have a contact person on the Google side. I used to stay in contact with Bob Lee for such matters but he stopped answering my emails some time ago.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12845715" author="jessewilson" created="Tue, 16 Mar 2010 05:20:25 +0000"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m Bob&amp;#39;s successor on the Android team. If you&amp;#39;ve got questions about our use of the HTTP client code, I&amp;#39;ll do my best to answer &amp;#39;em. I regret that we haven&amp;#39;t given this code much attention lately; that said I&amp;#39;m happy that it hasn&amp;#39;t really needed it.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12852758" author="olegk" created="Fri, 2 Apr 2010 10:12:48 +0100"  >Steinar,&lt;br/&gt;
&lt;br/&gt;
I committed your patch to the 4.0.x branch in case Google decided to sync up its version with the ASF code line. Please review:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?rev=930190&amp;view=rev&quot;&gt;http://svn.apache.org/viewvc?rev=930190&amp;amp;view=rev&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I will be working on a somewhat less hacky fix for the 4.1 release.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12854610" author="olegk" created="Wed, 7 Apr 2010 18:31:19 +0100"  >I refactored socket factory API in the SVN trunk. Old socket factory interfaces are now deprecated in favour of new ones that are better suited for dealing with multihome hosts. HttpClient remains API / binary compatible with 4.0. &lt;br/&gt;
&lt;br/&gt;
Feel free to review and give feedback. &lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?rev=931624&amp;view=rev&quot;&gt;http://svn.apache.org/viewvc?rev=931624&amp;amp;view=rev&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12855033" author="olegk" created="Thu, 8 Apr 2010 18:28:53 +0100"  >Fixed in SVN trunk and 4.0.x branch.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 10 Dec 2009 11:35:58 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133906</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47376</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>