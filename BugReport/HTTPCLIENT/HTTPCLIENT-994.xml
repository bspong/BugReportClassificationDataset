<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:23:02 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-994/HTTPCLIENT-994.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-994] cache does not allow client to override origin-specified freshness using max-stale</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-994</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>According to the RFC, the default freshness lifetime is supposed to be the LEAST restrictive of that specified by the origin, the client, and the cache. Right now, a client can&amp;#39;t use &amp;#39;max-stale&amp;#39; to relax the freshness constraints to get a cache hit without validation occuring first.&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12473916">HTTPCLIENT-994</key>
            <summary>cache does not allow client to override origin-specified freshness using max-stale</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="cimjmoore">Jonathan Moore</reporter>
                        <labels>
                    </labels>
                <created>Sat, 11 Sep 2010 22:19:31 +0100</created>
                <updated>Tue, 25 Jan 2011 11:00:24 +0000</updated>
                    <resolved>Wed, 15 Sep 2010 21:01:32 +0100</resolved>
                            <version>4.1 Alpha2</version>
                                <fixVersion>4.1 Beta1</fixVersion>
                                <component>HttpCache</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12908369" author="cimjmoore" created="Sat, 11 Sep 2010 22:24:01 +0100"  >The attached patch addresses this issue, as well as a simplifying refactoring. I even fixed another bug while I was at it.&lt;br/&gt;
&lt;br/&gt;
The refactoring includes:&lt;br/&gt;
* Removal of the CacheValidityPolicy and associated unit test; almost all of this functionality was moved to the HttpCacheEntry; created a new TestHttpCacheEntry unit test.&lt;br/&gt;
* Removal of the CacheEntry test class; instead added some convenience methods to HttpTestUtils to allow for easily manufacturing proper HttpCacheEntry instances instead.&lt;br/&gt;
&lt;br/&gt;
The bug fix was a minor one related to the requirement that a cache cannot respond with a cache entry to a request with multiple conditional headers where not all of them match; it turned out the test case for this was incorrect (it was using If-Unmodified-Since instead of If-Modified-Since in the test) and hence the bug wasn&amp;#39;t immediately obvious.&lt;br/&gt;
&lt;br/&gt;
This patch is contributed to the ASF with the permission of my employer.</comment>
                    <comment id="12908421" author="olegk" created="Sun, 12 Sep 2010 09:08:53 +0100"  >Jon&lt;br/&gt;
&lt;br/&gt;
What is the benefit of moving protocol specific logic back to the HttpCacheEntry? Presently HttpCacheEntry is just a simple bean class that carries state information about a cache entry. One can apply different strategies to determine whether or not the entry is fresh. What do we have to gain by mixing state and protocol logic in one class?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12908446" author="cimjmoore" created="Sun, 12 Sep 2010 12:43:49 +0100"  >Hi Oleg,&lt;br/&gt;
&lt;br/&gt;
Good question. Currently the CachedResponseSuitabilityChecker is where we decide whether a specific cache entry can be used to satisfy a given request. This is the class that could be replaced or extended to provide alternative (but allowed) caching policies, like heuristic caching, for example.  &lt;br/&gt;
&lt;br/&gt;
Please take a look, but I am pretty certain that all the methods on HttpCacheEntry now are either calculations whose definitions are given in the RFC (apparent age, freshness lifetime, whether it can be revalidated, etc.) or related to MUST-level requirements (treating malformed Expires headers as &amp;#39;already stale&amp;#39;). &lt;br/&gt;
&lt;br/&gt;
Also, CacheValidityPolicy, where all these methods used to live, had almost no interesting state, and all it&amp;#39;s methods took an HttpCacheEntry as an argument; it seemed pretty clear these two classes &amp;quot;wanted&amp;quot; to be merged. :)&lt;br/&gt;
&lt;br/&gt;
Jon</comment>
                    <comment id="12908449" author="olegk" created="Sun, 12 Sep 2010 13:10:44 +0100"  >I am a strong believer in keeping state and behaviour / protocol processing decoupled, even if they seem to be closely related. I will not insist, though. The question still stands whether or not there is anything to be gained from merging those classes.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12908482" author="cimjmoore" created="Sun, 12 Sep 2010 16:35:45 +0100"  >I can understand keeping state and protocol processing decoupled, which is why we have a CachedResponseSuitabilityChecker instead of just saying HttpCacheEntry#canYouBeUsedToSatisfy(HttpRequest req). In this case, the methods that got moved to HttpCacheEntry are all essentially properties of a cache entry; just as a Header can find its HeaderElements for you, now an HttpCacheEntry can tell you its apparent age (a *defined* property in the RFC). Whether the caching module actually decides to use the cache entry to satisfy a request is outside of the scope of the HttpCacheEntry.&lt;br/&gt;
&lt;br/&gt;
Generally, I think the main advantage here is a simplification of the implementation: one fewer class to maintain or understand. In particular, an HttpCacheEntry is a domain object, whereas a CacheValidityPolicy is a construct of the implementation. In this case, there is little future flexibility lost here, since all the calculations are explicitly defined by the RFC, and we still have a place to make implementation-specific behavioral changes (CachedResponseSuitabilityChecker); we don&amp;#39;t need two such places.&lt;br/&gt;
&lt;br/&gt;
Finally, I think the CacheValidityPolicy and HttpCacheEntry as they exist in trunk now exhibit a few OO &amp;quot;code smells&amp;quot;, namely that they are two separate classes that are tightly coupled; there isn&amp;#39;t anything you can do with a CacheValidityPolicy without also having an HttpCacheEntry instance. Also, the CacheValidityPolicy&amp;#39;s state is pretty much just a single boolean; there&amp;#39;s not much state there, just code, which suggests that the code probably wants to be moved towards the state it operates on (HttpCacheEntry).&lt;br/&gt;
&lt;br/&gt;
But generally speaking, I think this is as simple as &amp;quot;why have two classes when one will do&amp;quot;?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12908671" author="olegk" created="Mon, 13 Sep 2010 10:00:09 +0100"  >&amp;gt; In this case, the methods that got moved to HttpCacheEntry are all essentially properties of a cache entry; &lt;br/&gt;
&amp;gt; just as a Header can find its HeaderElements for you, now an HttpCacheEntry can tell you its apparent age &lt;br/&gt;
&amp;gt; (a *defined* property in the RFC)&lt;br/&gt;
&lt;br/&gt;
There would be too way much protocol logic beyond simple parsing operations in the HttpCacheEntry to my personal liking. RFCs do get superseded with updated versions. You never know what might happen in the future. If HttpCacheEntry API proves inflexible to meet new requirements, pretty much the entire caching API will have to be deprecated. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Finally, I think the CacheValidityPolicy and HttpCacheEntry as they exist in trunk now exhibit a few OO &amp;quot;code smells&amp;quot;, &lt;br/&gt;
&amp;gt; namely that they are two separate classes that are tightly coupled.&lt;br/&gt;
&lt;br/&gt;
I am not sure I agree. HttpCacheEntry has no dependency on CacheValidityPolicy of what so ever.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; But generally speaking, I think this is as simple as &amp;quot;why have two classes when one will do&amp;quot;? &lt;br/&gt;
&lt;br/&gt;
Because you never know what might happen in the future. I have been maintaining HttpClient for looooong 7 years and I have had numerous moments when I wished some bits of code had never been made a part of public API.&lt;br/&gt;
&lt;br/&gt;
If you remain unconvinced I&amp;#39;ll commit the patch within a few days.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12908738" author="cimjmoore" created="Mon, 13 Sep 2010 13:11:12 +0100"  >I would definitely weigh your opinion and experience highly here.&lt;br/&gt;
&lt;br/&gt;
Let me roll another patch that just introduces the max-stale fix without the refactoring, and then I&amp;#39;ll propose that we start a dev list discussion about future evolution of the module in general. </comment>
                    <comment id="12909758" author="cimjmoore" created="Wed, 15 Sep 2010 16:02:21 +0100"  >I have attached another patch that addresses the issue without the major refactoring of HttpCacheEntry. I did, however, go ahead and remove the CacheEntry test class here, and several of the unit tests I touched while fixing the bug are now no longer mock tests, which makes them a lot less brittle.&lt;br/&gt;
&lt;br/&gt;
This patch also fixes a bug in the processing of min-fresh (semantics were not being applied correctly).&lt;br/&gt;
&lt;br/&gt;
This patch is contributed to the ASF with the permission of my employer.&lt;br/&gt;
</comment>
                    <comment id="12909862" author="olegk" created="Wed, 15 Sep 2010 21:01:32 +0100"  >Patch checked in. Many thanks, Jon&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12454661" name="max-stale-no-refactor.patch" size="105321" author="cimjmoore" created="Wed, 15 Sep 2010 16:02:20 +0100" />
                    <attachment id="12454385" name="max-stale.patch" size="226112" author="cimjmoore" created="Sat, 11 Sep 2010 22:24:01 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 12 Sep 2010 08:08:53 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133995</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47322</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>