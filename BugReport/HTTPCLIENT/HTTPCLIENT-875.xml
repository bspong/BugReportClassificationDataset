<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:21:51 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-875/HTTPCLIENT-875.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-875] DefaultClientConnectionOperator doesn&apos;t update socket after call to connectSocket(...)</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-875</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>In the DefaultClientConnectionOperator function openConnection(...) it calls SocketFactory.connectSocket(...). The documentation for connectSocket(...) says that it returns:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;the connected socket. The returned object may be different from&lt;br/&gt;
the sock argument if this factory supports a layered protocol. &amp;quot;&lt;br/&gt;
&lt;br/&gt;
A quick peek at the source showed:&lt;br/&gt;
In org.apache.http.impl.conn.DefaultClientConnectionOperator:&lt;br/&gt;
&lt;br/&gt;
117         final SocketFactory sf = schm.getSocketFactory();&lt;br/&gt;
118&lt;br/&gt;
119         Socket sock = sf.createSocket();&lt;br/&gt;
120         conn.opening(sock, target);&lt;br/&gt;
121&lt;br/&gt;
122         try {&lt;br/&gt;
123             sock = sf.connectSocket(sock, target.getHostName(),&lt;br/&gt;
124                     schm.resolvePort(target.getPort()),&lt;br/&gt;
125                     local, 0, params);&lt;br/&gt;
126         } catch (ConnectException ex) {&lt;br/&gt;
127             throw new HttpHostConnectException(target, ex);&lt;br/&gt;
128         }&lt;br/&gt;
129         prepareSocket(sock, context, params);&lt;br/&gt;
130         conn.openCompleted(sf.isSecure(sock), params);&lt;br/&gt;
&lt;br/&gt;
So DefaultClientConnectionOperator never updates conn with the new version of sock that may have been returned from connectSocket(...).&lt;br/&gt;
&lt;br/&gt;
adding:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;130         conn.openCompleted(sf.isSecure(sock), params);&lt;br/&gt;
+++ 131         conn.update(sock, target, sf.isSecure(sock), params);&lt;br/&gt;
appears to fix the issue.&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12435211">HTTPCLIENT-875</key>
            <summary>DefaultClientConnectionOperator doesn&apos;t update socket after call to connectSocket(...)</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="cgauld">Connell Gauld</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Sep 2009 14:50:57 +0100</created>
                <updated>Tue, 25 Jan 2011 10:59:22 +0000</updated>
                    <resolved>Wed, 9 Sep 2009 21:33:16 +0100</resolved>
                            <version>4.0 Beta 2</version>
                <version>4.0 Final</version>
                                <fixVersion>4.1 Alpha1</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12753094" author="cgauld" created="Wed, 9 Sep 2009 14:56:11 +0100"  >A patch that appears to solve the issue.</comment>
                    <comment id="12753104" author="olegk" created="Wed, 9 Sep 2009 15:22:15 +0100"  >How about a slightly different take? Please review / test&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12753116" author="cgauld" created="Wed, 9 Sep 2009 16:04:45 +0100"  >Yup, this appears to work for me.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
C</comment>
                    <comment id="12753248" author="olegk" created="Wed, 9 Sep 2009 21:33:16 +0100"  >Fixed in SVN trunk. Please note because it is possible to work the problem around by replacing DefaultClientConnectionOperator with a custom impl this fix will have to wait until 4.1&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12787749" author="glynd" created="Tue, 8 Dec 2009 21:24:13 +0000"  >&lt;br/&gt;
This doesn&amp;#39;t fix all cases as the call to conn.update() checks that the previous socket is still open, by calling assertOpen()&lt;br/&gt;
&lt;br/&gt;
If the original socket is screwed up (likely given the use case) this throws an &amp;#39;IllegalStateEXception: Connection is not open&amp;#39;</comment>
                    <comment id="12787787" author="olegk" created="Tue, 8 Dec 2009 22:35:26 +0000"  >This is actually the expected behaviour of the method, see javadocs. Why it is a problem?   &lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://hc.apache.org/httpcomponents-client/httpclient/apidocs/org/apache/http/conn/OperatedClientConnection.html#update%28java.net.Socket,%20org.apache.http.HttpHost,%20boolean,%20org.apache.http.params.HttpParams%29&quot;&gt;http://hc.apache.org/httpcomponents-client/httpclient/apidocs/org/apache/http/conn/OperatedClientConnection.html#update%28java.net.Socket,%20org.apache.http.HttpHost,%20boolean,%20org.apache.http.params.HttpParams%29&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12787818" author="glynd" created="Wed, 9 Dec 2009 00:06:03 +0000"  >&lt;br/&gt;
I&amp;#39;m looking at MultihomePlainSocketFactory which creates a new client socket object under exception situations.&lt;br/&gt;
&lt;br/&gt;
This new socket is returned, and replaces the initial socket that was created.&lt;br/&gt;
&lt;br/&gt;
This would be fine if the update() replaced the existing socket straight away, but this fails because the initial socket is not open.&lt;br/&gt;
</comment>
                    <comment id="12788003" author="glynd" created="Wed, 9 Dec 2009 09:56:15 +0000"  >&lt;br/&gt;
I&amp;#39;ve found the following works:&lt;br/&gt;
&lt;br/&gt;
{code}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;conn.opening(sock, target);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;conn.openCompleted(sf.isSecure(sock), params);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prepareSocket(sock, context, params);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;conn.update(sock, target, sf.isSecure(sock), params); &lt;br/&gt;
{code}&lt;br/&gt;
&lt;br/&gt;
1. openCompleted() requires the socket to be in a CLOSED state&lt;br/&gt;
2. prepareSocket() calls conn.bind() which marks the socket as OPEN&lt;br/&gt;
3. update() requires the socket in OPEN state&lt;br/&gt;
&lt;br/&gt;
I do not think this is a viable true fix though, as I am sure it breaks a number of expectations.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
(If Id not move opening() down, I see:&lt;br/&gt;
&lt;br/&gt;
Caused by: java.net.SocketException: Socket is not connected&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.net.Socket.getInputStream(Socket.java:770)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.http.impl.io.SocketInputBuffer.&amp;lt;init&amp;gt;(SocketInputBuffer.java:123)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.http.impl.SocketHttpClientConnection.createSessionInputBuffer(SocketHttpClientConnection.java:99)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.http.impl.conn.DefaultClientConnection.createSessionInputBuffer(DefaultClientConnection.java:165)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.http.impl.SocketHttpClientConnection.bind(SocketHttpClientConnection.java:162)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.http.impl.conn.DefaultClientConnection.openCompleted(DefaultClientConnection.java:123)&lt;br/&gt;
</comment>
                    <comment id="12788033" author="olegk" created="Wed, 9 Dec 2009 11:07:57 +0000"  >Glyn&lt;br/&gt;
&lt;br/&gt;
I do not quite understand this has to do with MultihomePlainSocketFactory. MultihomePlainSocketFactory is for creating plain connections that do not need a socket upgrade.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12788078" author="glynd" created="Wed, 9 Dec 2009 13:02:43 +0000"  >&lt;br/&gt;
&lt;br/&gt;
When DefaultMultihomePlainSocketFactory receives an IOException on connect, it &lt;br/&gt;
&lt;br/&gt;
1. Creates a new socket&lt;br/&gt;
2. Attempts to connect to the next IP address that exists for that DNS hostname&lt;br/&gt;
&lt;br/&gt;
So, in a situation where the first IP address returned in the DNS fails to connect (connection refused, say) the DefaultMultihomePlainSocketFactory will create a new socket, and attempt to connect to the server with this new socket.&lt;br/&gt;
&lt;br/&gt;
This new socket is returned from the connectSocket() method call, and is intended to replace the existing socket - which is a dead / failed connection.&lt;br/&gt;
&lt;br/&gt;
4.0 of httpclient doesn&amp;#39;t update this socket, and ignores the returned socket.&lt;br/&gt;
&lt;br/&gt;
The &amp;#39;4.1&amp;#39; declared fix fails for me, because of the assertOpen() - as the initial socket is dead.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12788105" author="olegk" created="Wed, 9 Dec 2009 14:23:47 +0000"  >#assertOpen() executed by DefaultClientConnection#update method is perfectly reasonable, as the #update method is intended for updating TLS/SSL connections after the original plain Socket has been wrapped with SSLSocket. The use of DefaultMultihomePlainSocketFactory should never result in a call to DefaultClientConnection#update&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12788661" author="olegk" created="Thu, 10 Dec 2009 10:47:21 +0000"  >Glyn&lt;br/&gt;
&lt;br/&gt;
Support for multihome addresses is basically broken at the moment. I am planning to have it fixed in the next release. You can track the progress by  watching &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPCLIENT-898&quot; title=&quot;Improve multihome support&quot;&gt;&lt;strike&gt;HTTPCLIENT-898&lt;/strike&gt;&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12419060" name="HTTPCLIENT-875-2.patch" size="2927" author="olegk" created="Wed, 9 Sep 2009 15:22:15 +0100" />
                    <attachment id="12419056" name="HTTPCLIENT-875.diff" size="624" author="cgauld" created="Wed, 9 Sep 2009 14:56:11 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 9 Sep 2009 14:22:15 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133889</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47381</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>