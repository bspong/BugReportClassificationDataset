<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:15:59 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-309/HTTPCLIENT-309.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-309] [RFE] Allow streaming of POST methods via chunked transfer encoding.</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-309</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>This is an RFE with a possible implementation attached. The implementation does&lt;br/&gt;
not modify any existing code.&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;re using HTTP POST to send a large amount of data with an unknown size. We&lt;br/&gt;
don&amp;#39;t want to buffer the entire request, so we implemented a streaming POST&lt;br/&gt;
method. The implementation has 3 classes: StreamedPostMethod,&lt;br/&gt;
BufferedChunkedOutputStream and OutputStreamWriter. The bulk of the code is in&lt;br/&gt;
the BufferedChunkedOutputStream, which may be a good target for replacing&lt;br/&gt;
ChunkedOutputStream from the main distribution.&lt;br/&gt;
&lt;br/&gt;
BufferedChunkedOutputStream has the following charactersitics:&lt;br/&gt;
1) It has an internal 2K buffer. Without the buffer, chunk sizes would be too&lt;br/&gt;
small in many cases (e.g. ObjectOutputStream likes to call write(byte[]) with 4&lt;br/&gt;
byte long arguments). 2K was chosen to minimize the chunk overhead to less than 1%.&lt;br/&gt;
2) If the entire entity body fits within the 2K buffer, it does not use&lt;br/&gt;
chunking. This implies that the headers are only sent out when the first chunk&lt;br/&gt;
(or the entire body) has to be written, but no sooner.&lt;br/&gt;
3) The chunk size is not limited to 2K: if write(byte[]) is called with a large&lt;br/&gt;
argument, the internal buffer and the new request are sent out as a single chunk.&lt;br/&gt;
4) Because of (2) it&amp;#39;s tightly coupled to StreamedPostMethod.reallyWriteHeaders.&lt;br/&gt;
5) StreamedPostMethod calls BufferedChunkedOutputStream.finish() to write the&lt;br/&gt;
last buffer and ending chunk.&lt;br/&gt;
&lt;br/&gt;
Because of 4 and 5, we didn&amp;#39;t want to touch ChunkedOutputStream. Interestingly,&lt;br/&gt;
EntityEnclosingMethod is already tightly coupled to ChunkedOutputStream because&lt;br/&gt;
it has to call writeClosingChunk. There is probably some room for refactoring here.&lt;br/&gt;
&lt;br/&gt;
The package is just a suggestion; feel free to move the files as appropirate.&lt;br/&gt;
This code was written against 2.0rc2. We&amp;#39;re hoping it will get included in time&lt;br/&gt;
for the 2.1 release.&lt;br/&gt;
&lt;br/&gt;
To use the code, you must implement OutputStreamWriter and pass it to&lt;br/&gt;
StreamedPostMethod&amp;#39;s constructor. Execute the method as usual.&lt;br/&gt;
&lt;br/&gt;
Caveats: StreamedPostMethod does not implement Expect/continue logic. We had no&lt;br/&gt;
way to test this. It is also strictly for POST. In general, the same methodology&lt;br/&gt;
is applicable to PUT, etc. It should be fairly simple to generalize.&lt;br/&gt;
&lt;br/&gt;
Legal: Goldman, Sachs &amp;amp; Co. is making this code available under the Apache License.</description>
                <environment>Operating System: All&lt;br/&gt;
Platform: All</environment>
            <key id="12333868">HTTPCLIENT-309</key>
            <summary>[RFE] Allow streaming of POST methods via chunked transfer encoding.</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="mohammad.rezaei@gs.com">Mohammad Rezaei</reporter>
                        <labels>
                    </labels>
                <created>Tue, 13 Jan 2004 03:26:21 +0000</created>
                <updated>Wed, 16 Feb 2011 20:45:18 +0000</updated>
                    <resolved>Mon, 15 May 2006 22:44:59 +0100</resolved>
                            <version>2.0 Beta 2</version>
                                                <component>HttpClient</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12381391" author="mohammad.rezaei@gs.com" created="Tue, 13 Jan 2004 03:28:24 +0000"  >Created an attachment (id=9912)&lt;br/&gt;
possible implementation&lt;br/&gt;
</comment>
                    <comment id="12381392" author="oglueck" created="Fri, 16 Jan 2004 16:56:37 +0000"  >IMHO any entity enclosing method (including POST) already is capable of sending&lt;br/&gt;
chunked transfer encoded requests. This can be enabled by calling:&lt;br/&gt;
&lt;br/&gt;
EntityEnclosingMethod::setRequestContentLength(CONTENT_LENGTH_CHUNKED)&lt;br/&gt;
&lt;br/&gt;
The feature is documented on the above mentioned method.&lt;br/&gt;
&lt;br/&gt;
But I like the optimization with your 2K buffer!&lt;br/&gt;
&lt;br/&gt;
Odi</comment>
                    <comment id="12381393" author="mohammad.rezaei@gs.com" created="Fri, 16 Jan 2004 22:35:02 +0000"  >The point isn&amp;#39;t just chunking. The real point is *streaming*. (of course, you&lt;br/&gt;
can&amp;#39;t have streaming without chunking). We send 100&amp;#39;s of MB of data. We simply&lt;br/&gt;
can&amp;#39;t afford to buffer everything upfront. Even if we could afford the memory,&lt;br/&gt;
in terms of raw performance, a full buffered solution is about half the speed of&lt;br/&gt;
a streaming solution, because generating 10MB of data is a CPU intensive task.&lt;br/&gt;
While the buffer is being created, the network and tbe other side are totally&lt;br/&gt;
idle. With streaming, the client CPU (encoding), the server CPU (decoding) and&lt;br/&gt;
the network all work simultaneously.&lt;br/&gt;
&lt;br/&gt;
The above solution was inspired by a thread in the mailing list:&lt;br/&gt;
&lt;a href=&quot;http://nagoya.apache.org/eyebrowse/ReadMsg?listName=commons-httpclient-dev@jakarta.apache.org&amp;msgId=712986&quot;&gt;http://nagoya.apache.org/eyebrowse/ReadMsg?listName=commons-httpclient-dev@jakarta.apache.org&amp;amp;msgId=712986&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
It just so happens that the solution for streaming is pretty easy, but not very&lt;br/&gt;
useful without a good chunking implementation.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh</comment>
                    <comment id="12381394" author="oglueck" created="Fri, 16 Jan 2004 22:40:15 +0000"  >Moh,&lt;br/&gt;
&lt;br/&gt;
excuse me if I am wrong, but the when using chunked transfer encoding with the&lt;br/&gt;
current implementation, the request is *not* buffered. So I still don&amp;#39;t&lt;br/&gt;
understand why you have a problem with the current behaviour of HttpClient.&lt;br/&gt;
Please explain that.&lt;br/&gt;
&lt;br/&gt;
Odi</comment>
                    <comment id="12381395" author="mohammad.rezaei@gs.com" created="Fri, 16 Jan 2004 22:44:49 +0000"  >The problem is I need an OutputStream and HttpClient doesn&amp;#39;t provide one.&lt;br/&gt;
(HttpUrlConnection does, for example). Simply put, I&amp;#39;m serializing a large&lt;br/&gt;
object graph and I&amp;#39;m using ObjectOutputStream. There are 3 solutions (as pointed&lt;br/&gt;
out in the mailing list thread):&lt;br/&gt;
1) Buffer everything. As explained above, this is not a viable solution.&lt;br/&gt;
2) Use a PipedInputStream. That requires 2 threads for each send and frankly, is&lt;br/&gt;
not all that intuitive.&lt;br/&gt;
3) Provide access to the OutputStream; this is the implementation we went with.&lt;br/&gt;
&lt;br/&gt;
Sorry if I wasn&amp;#39;t clear.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh&lt;br/&gt;
</comment>
                    <comment id="12381396" author="olegk" created="Fri, 16 Jan 2004 22:50:49 +0000"  >Mohammad,&lt;br/&gt;
I have to say I find the solution you have presented far from being elegant. I&lt;br/&gt;
really do not see why BufferedChunkedOutputStream class must be tightly coupled&lt;br/&gt;
with HttpConnection &amp;amp; HttpState. I personally find this a bit too much of a&lt;br/&gt;
price to pay for not using chunk-encoding when the entire entity body fits&lt;br/&gt;
within the 2K buffer. Is there anything I have missed as well?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381397" author="mohammad.rezaei@gs.com" created="Fri, 16 Jan 2004 23:37:55 +0000"  >The optimization for small buffers is just that, an optimization. Chunking can&lt;br/&gt;
be quite wasteful for small payloads, both in terms of total transfered bytes&lt;br/&gt;
and the logic to encode/decode the chunk. As for the coupling to HttpConnection&lt;br/&gt;
and HttpState, I was just trying to be consistent with the current api.&lt;br/&gt;
Practically all write methods in HttpMethodBase take HttpConnection and&lt;br/&gt;
HttpState as parameters.  That&amp;#39;s not strictly necessary. In this particular&lt;br/&gt;
case, we could store those values in StreamedPostMethod and then&lt;br/&gt;
BufferedChunkedOutputStream wouldn&amp;#39;t ever get to see those.&lt;br/&gt;
&lt;br/&gt;
I think the real architectural issue here may be that HttpClient assumes all&lt;br/&gt;
headers must be available before at least some processing is performed on the&lt;br/&gt;
body. That assumption is not true in this case. There are other cases where that&lt;br/&gt;
assumption makes using HttpClient difficult. For example consider a case where&lt;br/&gt;
you conditionally compress the payload or not based on size. The content type&lt;br/&gt;
can&amp;#39;t be set until you&amp;#39;ve decided to go one way or another and that will depend&lt;br/&gt;
on processing the body.&lt;br/&gt;
&lt;br/&gt;
I tried to point out the coupling in the initial comment because I agree with&lt;br/&gt;
you: it is not elegant. I&amp;#39;m not sure there is an elegant solution here.&lt;br/&gt;
Honestly, I dislike the reverse coupling (StreamedPostMethod knowing about&lt;br/&gt;
BufferedChunkedOutputStream) even more. In good servlet implementations (e.g.&lt;br/&gt;
Tomcat 5.x, Weblogic) the stream layer is totally transparent. What a servlet&lt;br/&gt;
does is not all that different than what HttpClient needs to do. Maybe the&lt;br/&gt;
Tomcat architecture would be a good starting point for the 3.0, or at least&lt;br/&gt;
something to keep in mind.&lt;br/&gt;
&lt;br/&gt;
BTW, going back to the optimization: some servlet containers do the same.&lt;br/&gt;
Weblogic does. Tomcat does not.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh&lt;br/&gt;
</comment>
                    <comment id="12381398" author="olegk" created="Sat, 17 Jan 2004 00:01:24 +0000"  >&amp;gt; The optimization for small buffers is just that, an optimization. Chunking can&lt;br/&gt;
&amp;gt; be quite wasteful for small payloads, both in terms of total transfered bytes&lt;br/&gt;
&amp;gt; and the logic to encode/decode the chunk.&lt;br/&gt;
&lt;br/&gt;
Right, but not in this particular case, when all the available content (&amp;lt; 2K) is&lt;br/&gt;
sent as one chunk. One does incur an overhead of two headers (for a payload&lt;br/&gt;
chunk and a closing chunk), but IMHO such overhead is negligible.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I think the real architectural issue here may be that HttpClient assumes all&lt;br/&gt;
&amp;gt; headers must be available before at least some processing is performed on the&lt;br/&gt;
&amp;gt; body.&lt;br/&gt;
&lt;br/&gt;
The current architecture of HttpClient is simply broken. Period. It is in a dire&lt;br/&gt;
need of a complete overhaul. But we do try to make things better, not worse,&lt;br/&gt;
until we finally get a change to fix the HttpClient fundamentals. The attempt to&lt;br/&gt;
implement deferred header writing on top of the existing architecture does not&lt;br/&gt;
seem to make things better (at least IMHO)&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381399" author="olegk" created="Fri, 23 Jan 2004 02:13:32 +0000"  >Mohammad,&lt;br/&gt;
My previous comment was not intended to discourage you and was not meant to &lt;br/&gt;
make you think that your contribution was not welcome. Quite the opposite is &lt;br/&gt;
the case. We certainly want to have the existing ChunkedOutputStream class &lt;br/&gt;
replaced with your code. If just felt that output optimization based on the &lt;br/&gt;
existing deficient architecture was not worth the trouble. This problem can be &lt;br/&gt;
revisited in the course of 4.0 api overhaul. For the 3.0 release I would rather &lt;br/&gt;
prefer a less intrusive approach. Would you be willing to continue working on &lt;br/&gt;
this patch?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381400" author="mohammad.rezaei@gs.com" created="Fri, 23 Jan 2004 02:27:32 +0000"  >hah! It takes more than words to discourage me :-&amp;gt;&lt;br/&gt;
I&amp;#39;ve actually been a little busy, but kept this in the back of my mind. The way&lt;br/&gt;
I see it, there are 3 ways to proceed (in order of difficulty, reverse order of&lt;br/&gt;
&amp;quot;goodness&amp;quot;):&lt;br/&gt;
1) Forget about refactoring the BufferedChunkedOutputStream and make it an inner&lt;br/&gt;
class of StreamedPostMethod. This is actually how I wrote the code originally.&lt;br/&gt;
2) Take out the first chunk optimization. This makes BufferedChunkedOutputStream&lt;br/&gt;
a simple replacement for the current implementation. See below.&lt;br/&gt;
3) Teach HttpMethodBase how to deal with delaying headers. This may not be too&lt;br/&gt;
bad in time for 2.1 (are we calling that 3.0 now?). I haven&amp;#39;t had time to take a&lt;br/&gt;
close look.&lt;br/&gt;
&lt;br/&gt;
The reason I&amp;#39;m hesitant about 2 is that HttpClient is used by a wide range of&lt;br/&gt;
people, most of whom don&amp;#39;t care about large POST payloads. The nice thing about&lt;br/&gt;
first chunk optimization is that it transparently uses a more widely available&lt;br/&gt;
Content-Length header. There are alot of broken proxies/load&lt;br/&gt;
balancers/firewalls/webservers out there. It would be nice for a general purpose&lt;br/&gt;
library to use the more common form when it can. There is nothing preventing&lt;br/&gt;
people from doing their own buffering; this is just a convenience. FYI, for my&lt;br/&gt;
purposes, option 2 will be just fine.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh</comment>
                    <comment id="12381401" author="olegk" created="Sat, 24 Jan 2004 00:14:30 +0000"  >Mohammad,&lt;br/&gt;
can we settle for option 2 for the 3.0 (former 2.1) release? The first chunk&lt;br/&gt;
optimization will be revisited in the course of 4.0 massive API redesign.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381402" author="mchaffie@rogers.com" created="Fri, 5 Mar 2004 00:47:29 +0000"  >Architectural discussion aside, I tried out Moh&amp;#39;s classes and found them very &lt;br/&gt;
useful. I have existing classes that are designed to read from an input stream &lt;br/&gt;
and write to an output stream and Moh&amp;#39;s code made it simpler to hook that into &lt;br/&gt;
httpclient.&lt;br/&gt;
&lt;br/&gt;
So basically, for my purposes, the following:&lt;br/&gt;
inputstream -&amp;gt; mycode -&amp;gt; httpclient (as an outputstream)&lt;br/&gt;
&lt;br/&gt;
is better than:&lt;br/&gt;
&lt;br/&gt;
inputstream -&amp;gt; mycode -&amp;gt; outputstream -&amp;gt; inputstream -&amp;gt; httpclient&lt;br/&gt;
&lt;br/&gt;
Bruce.</comment>
                    <comment id="12381403" author="dcowan@apc.com" created="Sat, 6 Mar 2004 05:34:53 +0000"  >This patch made life much easier for streaming requests.  I am using JDOM to &lt;br/&gt;
output xml and tried to use Piped Streams without much success to stream &lt;br/&gt;
requests.  This patch made it much easier to output JDOM to a stream using &lt;br/&gt;
HttpClient</comment>
                    <comment id="12381404" author="becke@u.washington.edu" created="Sun, 7 Mar 2004 02:03:53 +0000"  >Created an attachment (id=10684)&lt;br/&gt;
A different take&lt;br/&gt;
</comment>
                    <comment id="12381405" author="becke@u.washington.edu" created="Sun, 7 Mar 2004 02:10:59 +0000"  >The attached patch is another take on this solution.  It is an attempt to combine this request along with &lt;br/&gt;
Odi&amp;#39;s suggestion in &amp;lt;&lt;a href=&quot;http://nagoya.apache.org/eyebrowse/BrowseList?listName=commons-httpclient-&quot;&gt;http://nagoya.apache.org/eyebrowse/BrowseList?listName=commons-httpclient-&lt;/a&gt;&lt;br/&gt;
&lt;a href=&apos;mailto:dev@jakarta.apache.org&apos;&gt;dev@jakarta.apache.org&lt;/a&gt;&amp;amp;by=thread&amp;amp;from=654699&amp;gt;.  &lt;br/&gt;
&lt;br/&gt;
This patch is mostly just a proof of concept and still needs quite a bit of work. There are a few areas &lt;br/&gt;
that I am a little unhappy with.  In particular:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- EntityEnclosingMethod.getRequestBody() and getRequestBodyAsString() are not so nice.&lt;br/&gt;
&amp;nbsp;- Now that content length is moved to the RequestEntity the various content length methods on &lt;br/&gt;
EntityEnclosingMethod are a little questionable.&lt;br/&gt;
&lt;br/&gt;
Please let me know what you think.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381406" author="mohammad.rezaei@gs.com" created="Mon, 8 Mar 2004 23:18:27 +0000"  >Mike&amp;#39;s patch looks good to me. I&amp;#39;ve attached a direct replacement for&lt;br/&gt;
ChunkedOutputStream that buffers writes to avoid tiny chunks.</comment>
                    <comment id="12381407" author="mohammad.rezaei@gs.com" created="Mon, 8 Mar 2004 23:19:20 +0000"  >Created an attachment (id=10705)&lt;br/&gt;
Buffered ChunkedOutputStream&lt;br/&gt;
</comment>
                    <comment id="12381408" author="mohammad.rezaei@gs.com" created="Mon, 8 Mar 2004 23:27:39 +0000"  >To use the buffered ChunkedOutputStream, one change is required: In&lt;br/&gt;
EntityEnclodingMethod, the code:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (outstream instanceof ChunkedOutputStream) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;((ChunkedOutputStream) outstream).writeClosingChunk();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
has to be changed to&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (outstream instanceof ChunkedOutputStream) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;((ChunkedOutputStream) outstream).finish();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
finish() flushes the cache as well writes the final chunk. &lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh&lt;br/&gt;
</comment>
                    <comment id="12381409" author="olegk" created="Tue, 9 Mar 2004 01:01:56 +0000"  >Mohammad,&lt;br/&gt;
The patch looks good to me. However, I&amp;#39;d like to see a few more things done&lt;br/&gt;
before the new implementation of the ChunkedOutputStream class can be committed. &lt;br/&gt;
&lt;br/&gt;
* Remove references to deprecated HttpConstants methods. Use corresponding&lt;br/&gt;
methods of the EncodingUtil class instead&lt;br/&gt;
* Provide at least rudimentary Javadocs.&lt;br/&gt;
* Parameterizable buffer size. Simple&lt;br/&gt;
ChunkedOutputStream#ChunkedOutputStream(OutputStream, int) constructor would do fine&lt;br/&gt;
* A SimpleHttpServer based test case would be just great. You may use&lt;br/&gt;
TestBadContentLength test unit as a reference implementation&lt;br/&gt;
* Use unified diff output format (diff -u) against CVS HEAD to produce the patch&lt;br/&gt;
if possible&lt;br/&gt;
&lt;br/&gt;
If you are constrained in time, I can take over from here. However, I really&lt;br/&gt;
would like you to see this patch to its logical conclusion&lt;br/&gt;
&lt;br/&gt;
Cheers,&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381410" author="mohammad.rezaei@gs.com" created="Tue, 9 Mar 2004 02:57:13 +0000"  >Created an attachment (id=10706)&lt;br/&gt;
patch that includes Oleg&amp;#39;s suggestions without the test case&lt;br/&gt;
</comment>
                    <comment id="12381411" author="olegk" created="Tue, 9 Mar 2004 04:40:59 +0000"  >Mohammad,&lt;br/&gt;
Cool. But test cases still need to be provided, as the ChunkedOutputStream class&lt;br/&gt;
has virtually no test case coverage at all. It&amp;#39;s not fun, but it needs to be done. &lt;br/&gt;
&lt;br/&gt;
Again, I can take it from here, but if you contibuted a few test cases, it would&lt;br/&gt;
be very welcome.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381412" author="oglueck" created="Tue, 9 Mar 2004 17:11:40 +0000"  >Here is my 2 cts. &lt;br/&gt;
I don&amp;#39;t see why buffering needs to be coupled with the chunking logic. I think&lt;br/&gt;
the same effect can be achieved by just wrapping the stream into a&lt;br/&gt;
BufferedOutputStream, no? (That ugly instanceof problem should be solved anyway).&lt;br/&gt;
&lt;br/&gt;
Two more things about the patch:&lt;br/&gt;
&amp;nbsp;* please follow the original coding conventions (braces and linebreaks)&lt;br/&gt;
&amp;nbsp;* license terms must be accoring to the ASF - no third-party copyrights please,&lt;br/&gt;
use @author tag, we will mention &amp;quot;Goldman Sachs&amp;quot; in the Obtained-From field in&lt;br/&gt;
the CVS comment when committing.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12381413" author="mohammad.rezaei@gs.com" created="Tue, 9 Mar 2004 22:49:45 +0000"  >Ortwin,&lt;br/&gt;
The whole point of buffering is to avoid tiny chunks. Here is Sun&amp;#39;s code from&lt;br/&gt;
BufferedOutputStream:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public synchronized void write(byte b[], int off, int len) throws IOException {&lt;br/&gt;
	if (len &amp;gt;= buf.length) {&lt;br/&gt;
	    /* If the request length exceeds the size of the output buffer,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	       flush the output buffer and then write the data directly.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;	       In this way buffered streams will cascade harmlessly. */&lt;br/&gt;
	    flushBuffer();&lt;br/&gt;
	    out.write(b, off, len);&lt;br/&gt;
	    return;&lt;br/&gt;
	}&lt;br/&gt;
	if (len &amp;gt; buf.length - count) {&lt;br/&gt;
	    flushBuffer();&lt;br/&gt;
	}&lt;br/&gt;
	System.arraycopy(b, off, buf, count, len);&lt;br/&gt;
	count += len;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Here are two conditions under which the patch behaves better (let&amp;#39;s assume 2048&lt;br/&gt;
byte buffer):&lt;br/&gt;
1) Buffer has 5 bytes in it, and a request to write 2048 bytes is received.&lt;br/&gt;
BufferedOutputStream would cause 2 chunks to be written, one of length 5, one&lt;br/&gt;
2048. The new ChunkedOutputStream would write a single chunk of size 2053.&lt;br/&gt;
2) Buffer has 5 bytes in it, and a request to write 2047 bytes is received.&lt;br/&gt;
BufferedOutputStream would cause a 5 byte chunk and buffer the rest for later&lt;br/&gt;
(which incurs an unnecessary System.arrayCopy). The new ChunkedOutputStream&lt;br/&gt;
writes a 2052 byte chunk.&lt;br/&gt;
Essentially, what you get from BufferedOutputStream is a crapshoot. It&amp;#39;s&lt;br/&gt;
anywhere from 1 to buf.length (or the size of the passed in request). A chunk of&lt;br/&gt;
length 1 has 500% overhead. ChunkedOutputStream guarantees a minimum chunk size&lt;br/&gt;
(except for the last chunk).&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll fix up the copyright and resubmit.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Moh</comment>
                    <comment id="12381414" author="oglueck" created="Tue, 9 Mar 2004 23:18:52 +0000"  >Okay, now I see. Thanks for explaining this to me. You get my GO :-)</comment>
                    <comment id="12381415" author="mohammad.rezaei@gs.com" created="Wed, 10 Mar 2004 03:25:46 +0000"  >Created an attachment (id=10728)&lt;br/&gt;
patch with correct style and copyright&lt;br/&gt;
</comment>
                    <comment id="12381416" author="olegk" created="Wed, 10 Mar 2004 05:57:26 +0000"  >I believe the patch is almost ready. I&amp;#39;ll provide a few simple test cases, if&lt;br/&gt;
nobody steps in, and commit the patch in a day or two provided nobody objects. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381417" author="becke@u.washington.edu" created="Wed, 10 Mar 2004 11:21:41 +0000"  >Works for me...  Any comments on my changes to EntityEnclosingMethod?&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381418" author="olegk" created="Thu, 11 Mar 2004 04:17:42 +0000"  >Created an attachment (id=10750)&lt;br/&gt;
Latest Mohammad&amp;#39;s patch + test cases&lt;br/&gt;
</comment>
                    <comment id="12381419" author="olegk" created="Thu, 11 Mar 2004 04:18:51 +0000"  >I have added a few test cases to the latest Mohammad&amp;#39;s patch. If nobody objects&lt;br/&gt;
I&amp;#39;ll commit the patch in 24 hours.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381420" author="olegk" created="Thu, 11 Mar 2004 06:19:45 +0000"  >Mike,&lt;br/&gt;
I like the patch but can&amp;#39;t help thinking that 2.0 API compatibility code defeats&lt;br/&gt;
the whole beauty of it. I would rather see all the setRequestBody /&lt;br/&gt;
getRequestBody* methods removed for good. After all, we are going to ship a&lt;br/&gt;
major version upgrade.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381421" author="becke@u.washington.edu" created="Thu, 11 Mar 2004 11:49:35 +0000"  >Hi Oleg,&lt;br/&gt;
&lt;br/&gt;
Keeping the API compatibility definitely makes things a little nastier here.  The getRequestBody* &lt;br/&gt;
methods could possibly be removed.  I don&amp;#39;t believe they serve much of a purpose in general use.  The &lt;br/&gt;
setReqestBody* and content length methods should just be deprecated I think.  They are too widely &lt;br/&gt;
used to be removed I think.  They are also much less of a hack.  How does that sound?&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381422" author="olegk" created="Thu, 11 Mar 2004 23:02:07 +0000"  >Hi Mike,&lt;br/&gt;
That sounds like a good plan. Let us get rid of useless getRequestBody* methods&lt;br/&gt;
and deprecate setRequestBody ones&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381423" author="olegk" created="Fri, 12 Mar 2004 05:03:51 +0000"  >Mohammad&amp;#39;s ChunkedOutputStream patch committed. Many thanks, Mohammad, for this&lt;br/&gt;
contribution. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381424" author="becke@u.washington.edu" created="Mon, 26 Apr 2004 10:33:56 +0100"  >Created an attachment (id=11329)&lt;br/&gt;
RequestEntity patch 2&lt;br/&gt;
</comment>
                    <comment id="12381425" author="becke@u.washington.edu" created="Mon, 26 Apr 2004 10:40:30 +0100"  >Attached is above is an updated version of the RequestEntity patch.  This one adds some comments, &lt;br/&gt;
removes the getRequestBody* methods and deprecates the setContentLength() methods.  I am also &lt;br/&gt;
tempted to move the Content-Type into the RequestEntity, but have not decided for sure yet.  Any &lt;br/&gt;
comments, suggestions?&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381426" author="mohammad.rezaei@gs.com" created="Mon, 26 Apr 2004 23:12:16 +0100"  >Looks great. +1 to apply.</comment>
                    <comment id="12381427" author="olegk" created="Tue, 27 Apr 2004 06:25:08 +0100"  >+1 from me. Making Content-Type a propery of the RequestEntity does seem&lt;br/&gt;
reasonable, too.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381428" author="becke@u.washington.edu" created="Wed, 28 Apr 2004 10:24:12 +0100"  >Patch applied. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m going to create a new RFE to cover moving the Content-Type.  I have also removed &lt;br/&gt;
the deprecated tag on setRequestBody(String) until the content type is moved.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381429" author="olegk" created="Thu, 29 Apr 2004 04:17:24 +0100"  >Created an attachment (id=11368)&lt;br/&gt;
Followup patch&lt;br/&gt;
</comment>
                    <comment id="12381430" author="olegk" created="Thu, 29 Apr 2004 04:23:55 +0100"  >Folks, &lt;br/&gt;
&lt;br/&gt;
I would like to have a few more constructors added to the ByteArrayRequestEntity&lt;br/&gt;
&amp;amp; InputStreamRequestEntity classes, if nobody objects. I would also like to&lt;br/&gt;
suggest that all concrete classes implementing RequestEntity made immutable.&lt;br/&gt;
That is, no more parameterless constructors, no more setContent methods. &lt;br/&gt;
&lt;br/&gt;
The patch also adds StringRequestEntity class in addition to&lt;br/&gt;
ByteArrayRequestEntity &amp;amp; InputStreamRequestEntity&lt;br/&gt;
&lt;br/&gt;
Let me know what you think&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12381431" author="becke@u.washington.edu" created="Thu, 29 Apr 2004 07:34:41 +0100"  >Hi Oleg,&lt;br/&gt;
&lt;br/&gt;
A few comments:&lt;br/&gt;
&lt;br/&gt;
- The new constructors are good, but there is a problem with the ByteArrayRequestEntity().  It will &lt;br/&gt;
always result in an exception since it&amp;#39;s calling this(null). &lt;br/&gt;
&amp;nbsp;- I have no problem making these classes immutable, but I&amp;#39;m not sure it&amp;#39;s really required.  What&amp;#39;s the &lt;br/&gt;
motivation?&lt;br/&gt;
&amp;nbsp;- I think we should wait until we move the Content-Type to add a StringRequestEntity. That way we can &lt;br/&gt;
handle the charset problems all at once.  I had originally created a StringRequestEntity but left it out for &lt;br/&gt;
this reason.&lt;br/&gt;
&amp;nbsp;- Could StringRequestEntity.writeRequest() be simplified to:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Writer writer = null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (this.charset != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;writer = new OutputStreamWriter(out, this.charset); &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;writer = new OutputStreamWriter(out); &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;writer.write(content);&lt;br/&gt;
&lt;br/&gt;
Mike&lt;br/&gt;
</comment>
                    <comment id="12381432" author="olegk" created="Thu, 29 Apr 2004 14:59:35 +0100"  >&amp;gt; The new constructors are good, but there is a problem with the&lt;br/&gt;
ByteArrayRequestEntity().  &lt;br/&gt;
&amp;gt; It will always result in an exception since it&amp;#39;s calling this(null). &lt;br/&gt;
&lt;br/&gt;
My initial intention was to do away with ByteArrayRequestEntity(), but than I&lt;br/&gt;
thought I should discuss it with you first.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  - I have no problem making these classes immutable, but I&amp;#39;m not sure it&amp;#39;s&lt;br/&gt;
really required.  What&amp;#39;s the&lt;br/&gt;
&amp;gt; motivation?&lt;br/&gt;
&lt;br/&gt;
Primarily in order to avoid throwing IllegalStateException. If parameterless&lt;br/&gt;
constructors and setContent may leave entity request objects in a inconsistent&lt;br/&gt;
state, why should they exist in the first place?&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  - I think we should wait until we move the Content-Type to add a&lt;br/&gt;
StringRequestEntity. That way we can &lt;br/&gt;
&amp;gt; handle the charset problems all at once.  I had originally created a&lt;br/&gt;
StringRequestEntity but left it out for &lt;br/&gt;
&amp;gt; this reason.&lt;br/&gt;
&lt;br/&gt;
I have concerns that some JDKs may end up converting the entire String to an&lt;br/&gt;
array of bytes prior to writing into the underlying output stream, which would&lt;br/&gt;
result in unnecessary waste of memory. I may be a little too pessimistic here,&lt;br/&gt;
though&lt;br/&gt;
&lt;br/&gt;
Mike, just take over those bits that you think make sense and incorporate them&lt;br/&gt;
into your coming patch.</comment>
                    <comment id="12381433" author="oglueck" created="Thu, 29 Apr 2004 15:22:01 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
Okay with me to make them immutable. This is generally a good design choice.&lt;br/&gt;
&lt;br/&gt;
Ortwin Gl&amp;#xC3;&amp;#xBC;ck</comment>
                    <comment id="12381434" author="becke@u.washington.edu" created="Fri, 30 Apr 2004 12:07:49 +0100"  >&amp;gt; My initial intention was to do away with ByteArrayRequestEntity(), but than I&lt;br/&gt;
&amp;gt; thought I should discuss it with you first.&lt;br/&gt;
&lt;br/&gt;
What would we use as a replacement?  The InputStreamReqestEntity?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Primarily in order to avoid throwing IllegalStateException. If parameterless&lt;br/&gt;
&amp;gt; constructors and setContent may leave entity request objects in a inconsistent&lt;br/&gt;
&amp;gt; state, why should they exist in the first place?&lt;br/&gt;
&lt;br/&gt;
I hear you.  This goes along with the immutability.  Fine with me.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I have concerns that some JDKs may end up converting the entire String to an&lt;br/&gt;
&amp;gt; array of bytes prior to writing into the underlying output stream, which would&lt;br/&gt;
&amp;gt; result in unnecessary waste of memory. I may be a little too pessimistic here,&lt;br/&gt;
&amp;gt; though&lt;br/&gt;
&lt;br/&gt;
I think we should stay simple here until we run into a potential performance problem.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Mike, just take over those bits that you think make sense and incorporate them&lt;br/&gt;
&amp;gt; into your coming patch.&lt;br/&gt;
&lt;br/&gt;
Ok.  Can do.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12381435" author="olegk" created="Fri, 30 Apr 2004 16:21:31 +0100"  >&amp;gt; What would we use as a replacement?  The InputStreamReqestEntity?&lt;br/&gt;
&lt;br/&gt;
Mike, I apologize for not making myself clear enough. I did not mean the&lt;br/&gt;
ByteArrayRequestEntity class itself, but rather its parameterless constructor,&lt;br/&gt;
the one that causes an exception in my patch.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12327056" name="ASF.LICENSE.NOT.GRANTED--chunkedout.patch" size="17124" author="olegk" created="Thu, 11 Mar 2004 04:17:42 +0000" />
                    <attachment id="12327053" name="ASF.LICENSE.NOT.GRANTED--ChunkedOutputStream.java" size="3812" author="mohammad.rezaei@gs.com" created="Mon, 8 Mar 2004 23:19:20 +0000" />
                    <attachment id="12327055" name="ASF.LICENSE.NOT.GRANTED--chunkedpatch.txt" size="12776" author="mohammad.rezaei@gs.com" created="Wed, 10 Mar 2004 03:25:46 +0000" />
                    <attachment id="12327054" name="ASF.LICENSE.NOT.GRANTED--chunkedpatch.txt" size="15435" author="mohammad.rezaei@gs.com" created="Tue, 9 Mar 2004 02:57:13 +0000" />
                    <attachment id="12327058" name="ASF.LICENSE.NOT.GRANTED--entity.patch" size="7075" author="olegk" created="Thu, 29 Apr 2004 04:17:24 +0100" />
                    <attachment id="12327057" name="ASF.LICENSE.NOT.GRANTED--requestEntity.patch" size="34410" author="becke@u.washington.edu" created="Mon, 26 Apr 2004 10:33:56 +0100" />
                    <attachment id="12327051" name="ASF.LICENSE.NOT.GRANTED--StreamedPostMethod.zip" size="6020" author="mohammad.rezaei@gs.com" created="Tue, 13 Jan 2004 03:28:24 +0000" />
                    <attachment id="12327052" name="ASF.LICENSE.NOT.GRANTED--stream.patch" size="21904" author="becke@u.washington.edu" created="Sun, 7 Mar 2004 02:03:53 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                <customfieldname>Bugzilla Id</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26070</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 16 Jan 2004 16:56:37 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133358</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>189281</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>