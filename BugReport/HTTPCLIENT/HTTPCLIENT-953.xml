<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:22:33 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-953/HTTPCLIENT-953.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-953] ConnPoolByRoute driving RouteSpecificPool to IllegalState</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-953</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>Hi all,&lt;br/&gt;
&lt;br/&gt;
I encountered an issue on ConnPoolByRoute / RouteSpecificPool on HTTPClient 4.0.1, akin to &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPCLIENT-747&quot; title=&quot;No entry created for this pool.&quot;&gt;&lt;strike&gt;HTTPCLIENT-747&lt;/strike&gt;&lt;/a&gt; (it also leads to a java.lang.IllegalStateException: No entry created for this pool. HttpRoute[{}XXX] ), but it is not a concurrency issue (no race condition, just a logic error if I understood it correctly).&lt;br/&gt;
&lt;br/&gt;
From my understanding, the error lies in ConnPoolByRoute#getEntryBlocking&lt;br/&gt;
Quoting from the code (line 309-314) :&lt;br/&gt;
RouteSpecificPool rospl = getRoutePool(route, true);&lt;br/&gt;
... &lt;br/&gt;
} else if (hasCapacity &amp;amp;&amp;amp; !freeConnections.isEmpty()) {&lt;br/&gt;
&lt;br/&gt;
deleteLeastUsedEntry();&lt;br/&gt;
entry = createEntry(rospl, operator);&lt;br/&gt;
&lt;br/&gt;
} else { ...&lt;br/&gt;
&lt;br/&gt;
The short version of the issue is : under certain circumstances, #deleteLeastUsedEntry can remove rospl from the map of known RootSpecificPool. But as this code still holds on to the rospl instance, it will modify its state in a way the pool will never recover from later, not having any other way to access this instance when the connection gets released.&lt;br/&gt;
&lt;br/&gt;
A Step by Step guide to what&amp;#39;s going wrong.&lt;br/&gt;
0) You have to be in a condition that leads to the execution of said code extract (i.e. no free entry on the current route - but the route already is registered to the global pool -, current Route has capacity, max connections reached for the global pool, but there are free connections to destroy).&lt;br/&gt;
2) We arrive in deleteLeastUsedEntry(). We get the last entry from a queue. It can be that this entry is bound to the same (hashCode() wise) Route that the one we are getting a connection to (i.e. rospl instance held in the #getEntryBlocking context)&lt;br/&gt;
3) this entry can be the last of its pool, thus at this point, rospl.isUnused() == true&lt;br/&gt;
4) As a consequence, deleteEntry() will remove rospl from the routeToPool map&lt;br/&gt;
5) Back in the getEntryBlocking method, we do entry = createEntry(rospl, operator), which will do createdEntry() on the &amp;quot;locally-scoped&amp;quot; rospl instance that has just been removed from routeToPool &lt;br/&gt;
6) When the connexion from this new entry is released at some point in the future, the rospl instance that got the createdEntry() does not exist anymore, and it is a new one that gets the freeEntry() call&lt;br/&gt;
7) App breaks : this newly created RouteSpecificPool throws IllegalStateException.&lt;br/&gt;
&lt;br/&gt;
Step 0, though, is a rare condition that I only reached during stress tests, and on a SSL client-auth server. This is so because this is the only condition that I know of in HTTPClient, where there is a keep-alive connection in the RouteSpecificPool that can not be reused (when the State is set to the X500 principals of the client cert in the pool, but not in the request).&lt;br/&gt;
&lt;br/&gt;
Possible fix (from what I understand) :&lt;br/&gt;
The rospl instance variable in the context of getEntryBlocking() should be protected against the consequences of #deleteLeastUsedEntry().&lt;br/&gt;
Not being confortable with all issues at hand, nor with the code base, the simplest thing I can think of would be to preemptively reset the rospl variable after deleteLeastUsedEntry(), thus writing the previous code extract as :&lt;br/&gt;
&lt;br/&gt;
} else if (hasCapacity &amp;amp;&amp;amp; !freeConnections.isEmpty()) {&lt;br/&gt;
&lt;br/&gt;
deleteLeastUsedEntry();&lt;br/&gt;
// delete may have made deprecated the RouteSpecificPool instance&lt;br/&gt;
rospl = getRoutePool(route, true);&lt;br/&gt;
entry = createEntry(rospl, operator);&lt;br/&gt;
&lt;br/&gt;
} else { ...&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
I have a test case that I will attach to this issue ASAP.&lt;br/&gt;
It is a simple example that triggers the above conditions with 3 HttpGet calls, in a serial fashion. As stated previsouly, these calls need nothing particular, except that one of these calls must go to a HTTPS server with client-side certificate authentication (I guess NTLM would be OK, anything that will place a non null state along with the route in BasicEntryPool).&lt;br/&gt;
&lt;br/&gt;
I hope code is self-explainatory. I get 100% failure in my setup. Just configure your 2 URLS, configure classpath, set your keystores system properties, and launch.&lt;br/&gt;
&lt;br/&gt;
Workaround :&lt;br/&gt;
Best workaround I found is : do not get to step 0.&lt;br/&gt;
The most robust way I found to do that (i.e. a way that does not involve things like setting max pool size to a gigantic number that can never be reached, ...) is to actively set the ClientContext.USER_TOKEN attribute in an exec context while submitting the request to the client.&lt;br/&gt;
Step 0 triggers when there is an idle connection that waits, and when this idle connection can not be reused, which can only happen if the request&amp;#39;s &amp;quot;USER_TOKEN&amp;quot; does not match the BasicPoolEntry#getState(). As, in the SSL case, the state is the SSL Cert&amp;#39;s X500PrincipalName, and I know it in advance, it&amp;#39;s easy to set up front.&lt;br/&gt;
&lt;br/&gt;
By the way, this taught me that I never could benefit from connection reuse strategies in this SSL case, as connections would always get into the pool with a USER_TOKEN that my requests never had. Don&amp;#39;t know if it&amp;#39;s mentionned somewhere in the documentation, but this is a noteworthy fact to me.&lt;br/&gt;
&lt;br/&gt;
Please feel free to comment / correct any mistakes.</description>
                <environment>Java 6, WinXP (probably OS agnostic)</environment>
            <key id="12466584">HTTPCLIENT-953</key>
            <summary>ConnPoolByRoute driving RouteSpecificPool to IllegalState</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="gueugaie">Guillaume</reporter>
                        <labels>
                    </labels>
                <created>Wed, 9 Jun 2010 17:59:41 +0100</created>
                <updated>Tue, 25 Jan 2011 11:00:11 +0000</updated>
                    <resolved>Sun, 13 Jun 2010 17:53:39 +0100</resolved>
                            <version>4.0.1</version>
                                <fixVersion>4.1 Beta1</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12877136" author="gueugaie" created="Wed, 9 Jun 2010 18:02:10 +0100"  >Attached sample code to trigger the behaviour.</comment>
                    <comment id="12877216" author="olegk" created="Wed, 9 Jun 2010 22:25:32 +0100"  >Guillaume&lt;br/&gt;
&lt;br/&gt;
Many thanks for a such a precise and detailed analysis of the problem. Do you think you could submit your fix in the udiff format?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12877358" author="gueugaie" created="Thu, 10 Jun 2010 08:33:12 +0100"  >Well, I really needed a workaround, (as we do not, as a policy, use self-patched libs in our dev process), so I had to understand what was going on.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll try to produce a patch later in the day, I have to qualify my workaround today.&lt;br/&gt;
It&amp;#39;s the usual SVN checkout (I suppose starting from the trunk is the best way to go ? Would you prefer a patch against 4.0.1 specifically ?), and then a svn diff ?&lt;br/&gt;
&lt;br/&gt;
The solution presented in my first post clearly is not the most efficient (carrying a boolean around 2 method invocations beats calculating a Route&amp;#39;s hashCode() any time), but given the rare nature of the condition that triggers it, I guess safer is better. It also is a good way to clearly state in context, that the rospl instance may be unsafe for use (dirty) after deleteLeastUsedConnection.</comment>
                    <comment id="12877362" author="olegk" created="Thu, 10 Jun 2010 09:00:27 +0100"  >Another workaround you might want to investigate could be disabling the state tracking for SSL connections. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Would you prefer a patch against 4.0.1 specifically ?), &lt;br/&gt;
&lt;br/&gt;
SVN trunk. I&amp;#39;ll back-port the fix onto the 4.0.x branch once it is ready and reasonably tested.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; and then a svn diff ? &lt;br/&gt;
&lt;br/&gt;
Yep. &amp;#39;svn diff &amp;gt; patch.diff&amp;#39;&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The solution presented in my first post clearly is not the most efficient&lt;br/&gt;
&lt;br/&gt;
This does not matter. It is always easier to start with something that works and then improve on it&lt;br/&gt;
&lt;br/&gt;
Meanwhile I will be trying to reproduce the problem with a test case that does not involve SSL and external resources.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12877390" author="olegk" created="Thu, 10 Jun 2010 11:03:07 +0100"  >Guillaume,&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s the test case reproducing the problem using the HttpClient&amp;#39;s testing framework. Feel free to incorporate it in your patch.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12878329" author="gueugaie" created="Sun, 13 Jun 2010 01:18:05 +0100"  >Here&amp;#39;s my unified patch.&lt;br/&gt;
Just corrected a few comments on the unit test - because I guess the test comments should not say that the test will fail but rather what it will test.&lt;br/&gt;
&lt;br/&gt;
Suggested fix was applied, which succeeds, in my tests, with no impact on the other tests&amp;#39; results. It also worked in the original context that triggered my observations in the first place.&lt;br/&gt;
&lt;br/&gt;
==&lt;br/&gt;
&lt;br/&gt;
About the workaround, I finally adopted a solution that uses a custom UserTokenHandler on the client. It basically removes the SSL part of the default one.&lt;br/&gt;
The reason I chose this path is threefold :&lt;br/&gt;
- It interacts nicely with my code (not leaking the workaround to higher level classes)&lt;br/&gt;
- My HttpClient(s) are created per SSL Socket factory, with single certs per Key/Trust Manager, so I know for sure there is only one possible principal for any request &lt;br/&gt;
- This enables actual connection reuse, which is good as SSL handshakes (+ hostname checks, ...) have a somewhat noticeable impact on my app</comment>
                    <comment id="12878402" author="olegk" created="Sun, 13 Jun 2010 17:53:38 +0100"  >Fix committed to SVN trunk and 4.0.x branch. Many thanks, Guillaume.</comment>
                </comments>
                    <attachments>
                    <attachment id="12446709" name="ConnPoolFailureEx.java" size="4603" author="gueugaie" created="Wed, 9 Jun 2010 18:02:09 +0100" />
                    <attachment id="12446961" name="HTTPCLIENT-953.candidate.patch" size="4683" author="gueugaie" created="Sun, 13 Jun 2010 01:18:04 +0100" />
                    <attachment id="12446755" name="HTTPCLIENT-953-testcase.patch" size="4086" author="olegk" created="Thu, 10 Jun 2010 11:03:06 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 9 Jun 2010 21:25:32 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133958</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47345</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>