<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:22:31 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-951/HTTPCLIENT-951.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-951] Incorrect handling of InputStreams when connecting to a server that requires authentication</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-951</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>I&amp;#39;m trying to upload a file to a WebDav server (mod_dav on Apache Web Server 2.2.14) that has basic (or digest, the result is the same) authentication enabled.&lt;br/&gt;
I&amp;#39;m using the following code:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String url = &amp;quot;&lt;a href=&quot;http://myserver/dir/test2.gif&quot;&gt;http://myserver/dir/test2.gif&lt;/a&gt;&amp;quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;File file = new File(&amp;quot;d:/test2.gif&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DefaultHttpClient httpClient = new DefaultHttpClient();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HttpPut put = new HttpPut(url);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;put.setEntity(new InputStreamEntity(new FileInputStream(file), file.length()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;URI uri = put.getURI();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;httpClient.getCredentialsProvider().setCredentials(new AuthScope(uri.getHost(), uri.getPort()),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getCredentials());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;put.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, true);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HttpResponse response = httpClient.execute(put);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(response.getStatusLine());&lt;br/&gt;
&lt;br/&gt;
When running the above code, I&amp;#39;m getting a org.apache.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity. I tested both the latest alpha &amp;amp; the svn head. Doing the same thing in HttpClient 3.1 worked as expected. &lt;br/&gt;
&lt;br/&gt;
This could be normal, as I&amp;#39;m using an InputStream that is indeed not repeatable, but as I&amp;#39;m also using Expect: 100-Continue, the stream shouldn&amp;#39;t have been consumed with the first connection (the one that gets a code 401 from the WebDav server), and only in the second one, when the credentials are provided.&lt;br/&gt;
&lt;br/&gt;
The problem is that DefaultRequestDirector.execute doesn&amp;#39;t take this into account and assumes that if a request has been tried once, its associated entity (if any) has been consumed.&lt;br/&gt;
Here&amp;#39;s the fix that I came up with:&lt;br/&gt;
Change DefaultRequestDirector.execute so that if the wrapper is an EntityEnclosingRequestWrapper, it checks if the entity has actually been consumed before throwing a NonRepeatableRequestException. I&amp;#39;m using the method isStreaming() from HttpEntity, as it&amp;#39;s the closest thing to what I was looking for. Reading the JavaDoc, it could lead to the situation where an entity has started streaming but has not yet finished, and so is not in a state where it can be used. However I don&amp;#39;t think that&amp;#39;s a problem as the javadoc for HttpEntity.getContent() states that it can&amp;#39;t be called two times on a non-repeatable entity, so it&amp;#39;s just a matter of when the request will fail.&lt;br/&gt;
This lead me to also modify InputStreamEntity (from the httpCore project) as it didn&amp;#39;t comply with the javadoc. With these two modifications, The file upload completes successfully.&lt;br/&gt;
&lt;br/&gt;
I also modified:&lt;br/&gt;
&amp;nbsp;* TestInputStreamEntity.testBasics() (from the httpCore project) test so that it complies with getContent()&amp;#39;s Javadoc.&lt;br/&gt;
&amp;nbsp;* TestDefaultClientRequestDirector.FaultyHttpRequestExecutor because it didn&amp;#39;t consume the entity&amp;#39;s content.&lt;br/&gt;
All the tests from both httpCore and httpClient pass.&lt;br/&gt;
I tested both InputStreamEntity and BasicHttpEntity.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Please keep in mind that I am by no means an httpClient (or http, for that matter) expert, and these modifications may have some unexpected side-effects that I did not foresee, contain plain dumb code, or whatever, so it would be great if someone could review my changes and give their opinion.&lt;br/&gt;
</description>
                <environment>Windows XP, Java 1.6.20</environment>
            <key id="12466463">HTTPCLIENT-951</key>
            <summary>Incorrect handling of InputStreams when connecting to a server that requires authentication</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="tguerin">Thierry Gu&#233;rin</reporter>
                        <labels>
                    </labels>
                <created>Tue, 8 Jun 2010 16:26:08 +0100</created>
                <updated>Tue, 25 Jan 2011 11:00:09 +0000</updated>
                    <resolved>Tue, 22 Jun 2010 21:31:48 +0100</resolved>
                            <version>4.0 Final</version>
                <version>4.0.1</version>
                <version>4.1 Alpha1</version>
                <version>4.1 Alpha2</version>
                                <fixVersion>4.1 Beta1</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12876700" author="tguerin" created="Tue, 8 Jun 2010 16:27:44 +0100"  >Here are the diffs against tag 4.0.1 of both httpClient and httpCore</comment>
                    <comment id="12876776" author="olegk" created="Tue, 8 Jun 2010 20:29:47 +0100"  >Thierry&lt;br/&gt;
&lt;br/&gt;
Would it be a big deal for you to re-create the diffs against HttpCore trunk [1]? There has been a number of changes in HttpCore since the last official release. In particular HttpEntity contract has been simplified and clarified. It is quite possible you will no longer need to patch HttpCore.&lt;br/&gt;
&lt;br/&gt;
A test case for the bug would also be just great ;-). You might use this class as a starting point [2]   &lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpcore/trunk/&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpcore/trunk/&lt;/a&gt; &lt;br/&gt;
[2] &lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/impl/client/TestClientAuthentication.java&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/impl/client/TestClientAuthentication.java&lt;/a&gt;</comment>
                    <comment id="12877002" author="tguerin" created="Wed, 9 Jun 2010 10:21:30 +0100"  >Here are the diffs against the trunk. Reason I did them first against the 4.0.1 tag is that my goal is to use this on a production server, and I&amp;#39;m kind of not inclined to use versions that are labeled alpha ;)&lt;br/&gt;
I also couldn&amp;#39;t find if there was a planned bugFix release (4.0.2), do you think this could happen in the somewhat near future?&lt;br/&gt;
Anyway, back to the changes: the new HttpEntity contract indeed clarifies isStreaming, but it raises two new problems:&lt;br/&gt;
* InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true)&lt;br/&gt;
* there is no way now to test whether a stream has been consumed or not.&lt;br/&gt;
&lt;br/&gt;
For now, I kept the fix the same as for 4.0.1 (I&amp;#39;m using isStreaming to check if a stream has been consumed), but I think HttpEntity needs a isConsumed() method, otherwise I don&amp;#39;t see how I can make this work without relying on code that doesn&amp;#39;t comply with the contract. What do you think?&lt;br/&gt;
&lt;br/&gt;
As for the test case, thanks for providing the starting point, I must admit I didn&amp;#39;t know where to start... I&amp;#39;ll try to find the time to do it by the end of the week&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12877034" author="olegk" created="Wed, 9 Jun 2010 11:14:29 +0100"  >&amp;gt; I also couldn&amp;#39;t find if there was a planned bugFix release (4.0.2), do you think this could happen in the somewhat near future? &lt;br/&gt;
&lt;br/&gt;
At the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  * InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true) &lt;br/&gt;
&lt;br/&gt;
I am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; * there is no way now to test whether a stream has been consumed or not. &lt;br/&gt;
&lt;br/&gt;
The trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying content stream, which is something I would like to avoid.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; For now, I kept the fix the same as for 4.0.1 (I&amp;#39;m using isStreaming to check if a stream has been consumed), &lt;br/&gt;
&amp;gt; but I think HttpEntity needs a isConsumed() method, otherwise I don&amp;#39;t see how I can make this work without &lt;br/&gt;
&amp;gt; relying on code that doesn&amp;#39;t comply with the contract. What do you think? &lt;br/&gt;
&lt;br/&gt;
I think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking EntityEnclosingRequestWrapper class. That is why it is super-critical that we have a test case for the problem.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12877822" author="tguerin" created="Fri, 11 Jun 2010 15:35:38 +0100"  >&amp;gt; At the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider&lt;br/&gt;
&lt;br/&gt;
ok. As for me I find it a pretty severe bug, because the workaround is to use ByteArrayInputStreams, and this would quickly be a memory hog, but then again, as no one reported this bug before, I guess not many people use the same scenario as me :)&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; * InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true)&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot.&lt;br/&gt;
&lt;br/&gt;
my bad, didn&amp;#39;t update before diffing. getContent is still broken though ;)&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; * there is no way now to test whether a stream has been consumed or not.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;The trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another&lt;br/&gt;
&amp;gt;problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying&lt;br/&gt;
&amp;gt;content stream, which is something I would like to avoid.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;I think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the&lt;br/&gt;
&amp;gt;enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking&lt;br/&gt;
&amp;gt;EntityEnclosingRequestWrapper class. &lt;br/&gt;
&lt;br/&gt;
Well, seeing that EntityEnclosingRequestWrapper has no way of knowing what&amp;#39;s done with the entity once getEntity has been called, I don&amp;#39;t really see how you would know the enclosed entity has been written out to the socket without wrapping the entity itself and overriding writeTo (other than using events but I don&amp;#39;t think you want to go there).&lt;br/&gt;
The solution may lie in RequestWrapper.getExecCount, which only seems targeted at knowing if a request can be repeated (and is the source of the bug in DefaultRequestDirector.tryExecute: &amp;quot;wrapper.getExecCount() &amp;gt; 1 &amp;amp;&amp;amp; !wrapper.isRepeatable()&amp;quot;). From what I understand, a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn&amp;#39;t been consumed; Is this correct? If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn&amp;#39;t reflect the entity&amp;#39;s status. &lt;br/&gt;
&lt;br/&gt;
What do you think?&lt;br/&gt;
&lt;br/&gt;
&amp;gt;That is why it is super-critical that we have a test case for the problem.&lt;br/&gt;
&lt;br/&gt;
Here they are (testClientAuthentication.diff). Unfortunately, the testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue() test can&amp;#39;t pass even if the bug is fixed, because LocalTestServer sends a 100 (instead of a 401) during the handshake when it receives a header with Expect: Continue. I don&amp;#39;t feel confident enough with the code to try and fix that, sorry.&lt;br/&gt;
The second test (testBasicAuthenticationFailureOnNonRepeatablePutDontExpectContinue()) is somewhat  redundant with testBasicAuthenticationFailureOnNonRepeatablePost(), but as it explicitly specifies setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false), I find it useful. Feel free to discard it.&lt;br/&gt;
&lt;br/&gt;
Thierry</comment>
                    <comment id="12877938" author="olegk" created="Fri, 11 Jun 2010 20:44:13 +0100"  >&amp;gt; ok. As for me I find it a pretty severe bug&lt;br/&gt;
&lt;br/&gt;
Look. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug.  I have a one month old daughter, grumpy wife and lots of other things I need to take care of besides HttpClient. &lt;br/&gt;
&lt;br/&gt;
There has been a few other bug reports recently, which makes 4.0.2 more likely.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; getContent is still broken though ;)&lt;br/&gt;
&lt;br/&gt;
Huh, why? HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do with the content stream.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn&amp;#39;t been consumed; Is this correct? &lt;br/&gt;
&lt;br/&gt;
Correct&lt;br/&gt;
&lt;br/&gt;
&amp;gt; If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn&amp;#39;t reflect the entity&amp;#39;s status. &lt;br/&gt;
&lt;br/&gt;
I disagree. The exec count is merely a request count. It does what it does.&lt;br/&gt;
&lt;br/&gt;
The core of the problem is that HttpClient currently can&amp;#39;t know whether &amp;#39;expect-continue&amp;#39; handshake was used or not. There are different ways of addressing the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping HttpClientConnection and monitoring #sendRequestEntity method.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; because LocalTestServer sends a 100 (instead of a 401) during the handshake when it receives a header with Expect: Continue&lt;br/&gt;
&lt;br/&gt;
This behaviour can be changed by using a custom expectation verifier. &lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
</comment>
                    <comment id="12877964" author="tguerin" created="Fri, 11 Jun 2010 22:05:09 +0100"  >&amp;gt; Look. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug. I have a one month old daughter, &lt;br/&gt;
&amp;gt; grumpy wife and lots of other things I need to take care of besides HttpClient. &lt;br/&gt;
As always, smileys can&amp;#39;t convey entirely one&amp;#39;s thoughts, so let me (try to) be more clear: I&amp;#39;d be glad to have a 4.0.2, but I understand that this bug cannot be labeled as breaking the 4.0.1 release and warranting a new release on its own, seeing that it doesn&amp;#39;t look to bother anyone but me. And I appreciate the time you&amp;#39;re putting into this. I&amp;#39;m just trying to help, please bear with me as English is not my primary language and I know what I&amp;#39;m writing can be tactless. This is not my intent at all.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Huh, why? HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do &lt;br/&gt;
&amp;gt; with the content stream.&lt;br/&gt;
Well, as I told you, I&amp;#39;m no HttpCore/Client expert, so I&amp;#39;m relying on the API and the code, and in httpCore trunk, here&amp;#39;s the javaDoc for HttpEntity.getContent():&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* Creates a new InputStream object of the entity. It is an interface&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* violation to return the same {@link InputStream} object more than&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* once. Entities that are not {@link #isRepeatable repeatable}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* should throw an exception if this method is called multiple times.&lt;br/&gt;
Looks like it&amp;#39;s not up to date, so disregard my comment on getContent being broken.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn&amp;#39;t reflect the entity&amp;#39;s status.&lt;br/&gt;
&amp;gt;I disagree. The exec count is merely a request count. It does what it does. &lt;br/&gt;
What I meant is that it looked to me that the exec count was created to know if an entityEnclosingRequest could be repeated, as I couldn&amp;#39;t find any other uses in the code for it, and so its purpose was not fulfilled. Didn&amp;#39;t think it could have been created without this purpose in mind, my bad. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; The core of the problem is that HttpClient currently can&amp;#39;t know whether &amp;#39;expect-continue&amp;#39; handshake was used or not. There are different ways of addressing&lt;br/&gt;
&amp;gt; the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping&lt;br/&gt;
&amp;gt; HttpClientConnection and monitoring #sendRequestEntity method.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; This behaviour can be changed by using a custom expectation verifier.&lt;br/&gt;
&lt;br/&gt;
Thanks for the pointers, I&amp;#39;ll look into it next week&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12878117" author="olegk" created="Fri, 11 Jun 2010 23:35:00 +0100"  >My apologies for being such a grumpy old man. Thanks for pointing out inconsistencies in Javadocs of the HttpEntity interface I overlooked. Please review the updated version:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?rev=953893&amp;view=rev&quot;&gt;http://svn.apache.org/viewvc?rev=953893&amp;amp;view=rev&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I committed the test cases with some minor tweaks. The testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue test case now verifies user credentials during the expect-continue phase by means of a custom HttpExpectionVerifier. Please review:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewvc?rev=953890&amp;view=rev&quot;&gt;http://svn.apache.org/viewvc?rev=953890&amp;amp;view=rev&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Thanks for all your help and contributions. &lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</comment>
                    <comment id="12880764" author="tguerin" created="Mon, 21 Jun 2010 10:36:27 +0100"  >After looking at HttpRequestExecutor: would it be ok to use the ExecutionContext to store the fact that the request entity has been consumed, just as HttpRequestExecutor does it for the whole http request (cf  line 252: context.setAttribute(ExecutionContext.HTTP_REQ_SENT, Boolean.TRUE))?&lt;br/&gt;
It would only require to add a constant to ExecutionContext (HTTP_REQ_ENT_CONSUMED for instance) and change the test in DefaultRequestDirector to check for this boolean instead of the wrapper request count. &lt;br/&gt;
&lt;br/&gt;
I did a quick test and it works as expected, what do you think?&lt;br/&gt;
</comment>
                    <comment id="12880791" author="olegk" created="Mon, 21 Jun 2010 12:43:35 +0100"  >Thierry,&lt;br/&gt;
&lt;br/&gt;
Feel free to raise a separate JIRA for this change against HttpCore. However, I suggest we go for the entity decorator / wrapper approach, as it would enable us to back-port the fix to 4.0.x branch without too much trouble. &lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg </comment>
                    <comment id="12880817" author="tguerin" created="Mon, 21 Jun 2010 14:16:34 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m a bit confused here, as looking at the 4.0.x sources, the code change would be exactly the same (setting a boolean in the HttpContext during HttpRequestExecutor#doSendRequest, and changing DefaultRequestDirector to take that into account). Am I missing something?&lt;br/&gt;
&lt;br/&gt;
Still, if you prefer wrapping the HttpClientConnection, I&amp;#39;ll look into it, but I&amp;#39;m not sure I&amp;#39;ll have time before mid-July (holidays).</comment>
                    <comment id="12880838" author="olegk" created="Mon, 21 Jun 2010 15:10:01 +0100"  >&amp;gt; Am I missing something? &lt;br/&gt;
&lt;br/&gt;
The problem is the change would require a release of HttpCore before it could be employed by HttpClient. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Still, if you prefer wrapping the HttpClientConnection, I&amp;#39;ll look into it, but I&amp;#39;m not sure I&amp;#39;ll have time before mid-July (holidays). &lt;br/&gt;
&lt;br/&gt;
Of course, my sinister plan was to talk you into seeing the whole issue to some sort of a logical conclusion. No problem, though, I&amp;#39;ll come up with a fix within a few days.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12881136" author="tguerin" created="Tue, 22 Jun 2010 10:12:22 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
had some spare time, so here are the changes using a connection wrapper.&lt;br/&gt;
&lt;br/&gt;
Are you still interested in the diff to core 4.1 that adds the HTTP_REQ_ENT_CONSUMED to the context when the entity? It would avoid having the wrapper and make for nicer code IMHO.&lt;br/&gt;
&lt;br/&gt;
cheers,&lt;br/&gt;
&lt;br/&gt;
Thierry</comment>
                    <comment id="12881140" author="olegk" created="Tue, 22 Jun 2010 10:33:45 +0100"  >&amp;gt; had some spare time, so here are the changes using a connection wrapper. &lt;br/&gt;
&lt;br/&gt;
Yep. Almost there. I can&amp;#39;t help thinking, though, wrapping HttpEntity would probably be somewhat cleaner. I did not like the idea of wrapping the underlying content stream, but wrapping the entity should be perfectly fine.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Are you still interested in the diff to core 4.1 that adds the HTTP_REQ_ENT_CONSUMED to the context when the entity?&lt;br/&gt;
&lt;br/&gt;
Yes, I am. Please raise a separate issue for this change against HttpCore module.&lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12881343" author="olegk" created="Tue, 22 Jun 2010 21:31:47 +0100"  >Fixed  in SVN trunk and 4.0.x branch. Please review.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12901048" author="orcking" created="Sat, 21 Aug 2010 17:41:37 +0100"  >I am using the latest in trunk for both httpClient and httpCore&lt;br/&gt;
&lt;br/&gt;
I am getting this error on some devices (cell phones) , not all&lt;br/&gt;
Here is the code:&lt;br/&gt;
&lt;br/&gt;
InputStreamEntity reqEntity = new InputStreamEntity(&lt;br/&gt;
		new MyFileInputStream(file,upl), fileLength);&lt;br/&gt;
reqEntity.setContentType(&amp;quot;binary/octet-stream&amp;quot;);&lt;br/&gt;
reqEntity.setChunked(false);&lt;br/&gt;
&lt;br/&gt;
	&lt;br/&gt;
httppost.setEntity(reqEntity);&lt;br/&gt;
HttpResponse response = httpclient.execute(httppost);	//failure&lt;br/&gt;
HttpEntity resEntity = response.getEntity();&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
org.apache.http.client.ClientProtocolException&lt;br/&gt;
at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)&lt;br/&gt;
at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)&lt;br/&gt;
at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)&lt;br/&gt;
Caused by: org.apache.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Any ideas?????&lt;br/&gt;
</comment>
                    <comment id="12901092" author="olegk" created="Sat, 21 Aug 2010 21:37:27 +0100"  >You can use wire / context logging to find out why the request had to be retried.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://hc.apache.org/httpcomponents-client-4.0.1/logging.html&quot;&gt;http://hc.apache.org/httpcomponents-client-4.0.1/logging.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12901199" author="orcking" created="Sun, 22 Aug 2010 19:44:25 +0100"  >Thanks Oleg:&lt;br/&gt;
It seems to be something with the SSL&lt;br/&gt;
I added the logs:&lt;br/&gt;
&lt;br/&gt;
Here is a sample log from a working upload(I removed the host and IP):&lt;br/&gt;
It has a lot of debug here (I Think its the file content)&lt;br/&gt;
then.....&lt;br/&gt;
08-22 12:23:52.979: &amp;lt;&amp;lt; &amp;quot;HTTP/1.1 200 OK[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:52.981: &amp;lt;&amp;lt; &amp;quot;Date: Sun, 22 Aug 2010 16:25:20 GMT[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:52.991: &amp;lt;&amp;lt; &amp;quot;Server: Microsoft-IIS/6.0[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:52.991: &amp;lt;&amp;lt; &amp;quot;X-Powered-By: ASP.NET[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:52.991: &amp;lt;&amp;lt; &amp;quot;X-AspNet-Version: 2.0.50727[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.001: &amp;lt;&amp;lt; &amp;quot;Cache-Control: private[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.001: &amp;lt;&amp;lt; &amp;quot;Content-Type: text/html; charset=utf-8[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.001: &amp;lt;&amp;lt; &amp;quot;Content-Length: 484[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.001: &amp;lt;&amp;lt; &amp;quot;[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.011: Receiving response: HTTP/1.1 200 OK&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; HTTP/1.1 200 OK&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; Date: Sun, 22 Aug 2010 16:25:20 GMT&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; Server: Microsoft-IIS/6.0&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; X-Powered-By: ASP.NET&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; X-AspNet-Version: 2.0.50727&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; Cache-Control: private&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; Content-Type: text/html; charset=utf-8&lt;br/&gt;
08-22 12:23:53.011: &amp;lt;&amp;lt; Content-Length: 484&lt;br/&gt;
08-22 12:23:53.021: Connection can be kept alive for ever&lt;br/&gt;
08-22 12:23:53.021: Shutting down&lt;br/&gt;
08-22 12:23:53.021: Connection closed&lt;br/&gt;
08-22 12:23:53.091: Get connection: HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;], timeout = 10000&lt;br/&gt;
08-22 12:23:53.091: [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20&lt;br/&gt;
08-22 12:23:53.091: No free connections [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;]][null]&lt;br/&gt;
08-22 12:23:53.091: Available capacity: 2 out of 2 [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;]][null]&lt;br/&gt;
08-22 12:23:53.091: Creating new connection [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;]]&lt;br/&gt;
08-22 12:23:53.091: Connecting to ****.com/*.*.*.*:443&lt;br/&gt;
08-22 12:23:53.461: CookieSpec selected: best-match&lt;br/&gt;
08-22 12:23:53.461: Attempt 1 to execute request&lt;br/&gt;
08-22 12:23:53.501: Shutting down&lt;br/&gt;
08-22 12:23:53.501: Sending request: POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-22 12:23:53.501: &amp;gt;&amp;gt; &amp;quot;POST /UploadFiles.aspx HTTP/1.1[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.501: &amp;gt;&amp;gt; &amp;quot;Cache-Control: no-cache[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.501: &amp;gt;&amp;gt; &amp;quot;Pragma: no-cache[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.501: &amp;gt;&amp;gt; &amp;quot;Authorization: Basic *****************[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;ty: 0[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;v: 252[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;u: 354957030634904[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;postType: 0[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;filenum: -999[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;pl: 1[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.511: &amp;gt;&amp;gt; &amp;quot;on: 1[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;mf: 5[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Transfer-File-Name: **** [\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Transfer-File-Chunk-Count: 1[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Transfer-File-Chunk: 0[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;filelength: 5120[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Cookie: ASP.NET_SessionId=4eypxj45tsnabe45ficbnd55; path=/; HttpOnly[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Content-Length: 5120[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Content-Type: binary/octet-stream[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Host: ****.com[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.521: &amp;gt;&amp;gt; &amp;quot;Connection: Keep-Alive[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; &amp;quot;[\r][\n]&amp;quot;&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Cache-Control: no-cache&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Pragma: no-cache&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Authorization: Basic  *****************&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; ty: 0&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; v: 252&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; u: 354957030634904&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; postType: 0&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; filenum: -999&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; pl: 1&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; on: 1&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; mf: 5&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Transfer-File-Name: ****&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Transfer-File-Chunk-Count: 1&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Transfer-File-Chunk: 0&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; filelength: 5120&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Cookie: ASP.NET_SessionId=4eypxj45tsnabe45ficbnd55; path=/; HttpOnly&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Content-Length: 5120&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Content-Type: binary/octet-stream&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Host: ****.com&lt;br/&gt;
08-22 12:23:53.531: &amp;gt;&amp;gt; Connection: Keep-Alive&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
And here is the same log from a non working device:&lt;br/&gt;
It has a lot of debug here (I Think its the file content)&lt;br/&gt;
then.....&lt;br/&gt;
08-22 12:19:18.374 D: Connection closed&lt;br/&gt;
08-22 12:19:18.374 D: Closing the connection.&lt;br/&gt;
08-22 12:19:18.374 D: Connection closed&lt;br/&gt;
08-22 12:19:18.374 I: I/O exception (java.io.IOException) caught when processing request: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-22 12:19:18.397 D: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-22 12:19:18.397 D: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)&lt;br/&gt;
08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)&lt;br/&gt;
08-22 12:19:18.397 D:   at hg.a(ProGuard:2446)&lt;br/&gt;
08-22 12:19:18.397 D:   at b.a(ProGuard:1962)&lt;br/&gt;
08-22 12:19:18.397 D:   at b.a(ProGuard:1563)&lt;br/&gt;
08-22 12:19:18.397 D:   at e.run(ProGuard:1509)&lt;br/&gt;
08-22 12:19:18.397 I: Retrying request&lt;br/&gt;
08-22 12:19:18.405 D: Reopening the direct connection.&lt;br/&gt;
08-22 12:19:18.405 D: Connecting to ****.com/*.*.*.*:443&lt;br/&gt;
08-22 12:19:20.288 D: Cannot retry non-repeatable request&lt;br/&gt;
08-22 12:19:20.296 D: Connection shut down&lt;br/&gt;
08-22 12:19:20.296 D: Released connection is not reusable.&lt;br/&gt;
08-22 12:19:20.296 D: Releasing connection [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://****.com&quot;&gt;https://****.com&lt;/a&gt;]][null]&lt;br/&gt;
08-22 12:19:20.296 D: Notifying no-one, there are no waiting threads&lt;br/&gt;
08-22 12:19:20.311 E: null&lt;br/&gt;
08-22 12:19:20.311 E: org.apache41.http.client.ClientProtocolException&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)&lt;br/&gt;
08-22 12:19:20.311 E:   at hg.a(ProGuard:2446)&lt;br/&gt;
08-22 12:19:20.311 E:   at b.a(ProGuard:1962)&lt;br/&gt;
08-22 12:19:20.311 E:   at b.a(ProGuard:1563)&lt;br/&gt;
08-22 12:19:20.311 E:   at e.run(ProGuard:1509)&lt;br/&gt;
08-22 12:19:20.311 E: Caused by: org.apache41.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:610)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)&lt;br/&gt;
08-22 12:19:20.311 E:   ... 6 more&lt;br/&gt;
08-22 12:19:20.311 E: Caused by: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)&lt;br/&gt;
08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)&lt;br/&gt;
08-22 12:19:20.311 E:   ... 8 more&lt;br/&gt;
08-22 12:19:20.319 D: Shutting down&lt;br/&gt;
08-22 12:19:22.507 D: Shutting down</comment>
                    <comment id="12901208" author="olegk" created="Sun, 22 Aug 2010 21:33:46 +0100"  >Richard &lt;br/&gt;
&lt;br/&gt;
The log does not seem complete. It starts with &amp;#39;Connection closed&amp;#39; entry, which is strange. What kind of JRE are you using? It is Harmony?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12901209" author="orcking" created="Sun, 22 Aug 2010 21:56:24 +0100"  >Oleg&lt;br/&gt;
&lt;br/&gt;
Thanks again for the quick reply&lt;br/&gt;
The log starts with&lt;br/&gt;
---------beginning of /dev/log/main&lt;br/&gt;
then I see a bunch of unreadable text&lt;br/&gt;
I am assuming its base64 of the file content then&lt;br/&gt;
Connection closed. Message&lt;br/&gt;
This is running on Android&lt;br/&gt;
It seems the close is getting called from httpclient&lt;br/&gt;
&lt;br/&gt;
Any more ideas?</comment>
                    <comment id="12901210" author="olegk" created="Sun, 22 Aug 2010 22:02:26 +0100"  >Right, but I need to know what leads to that close() method call. Try disabling wire logs, while leaving context / header logs on.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12901563" author="orcking" created="Mon, 23 Aug 2010 20:47:39 +0100"  >OK..&lt;br/&gt;
&lt;br/&gt;
The new log has no wire just context:&lt;br/&gt;
&lt;br/&gt;
it&amp;#39;s not failing all the time, just intermittently,  in this case there was one pass and one fail after it.&lt;br/&gt;
&lt;br/&gt;
I am suspecting that the socket is not getting closed properly from the pass?&lt;br/&gt;
although I am calling&lt;br/&gt;
httpclient.getConnectionManager().shutdown();&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Here are the logs:&lt;br/&gt;
&lt;br/&gt;
08-23 13:11:27.759 D/: Get connection: HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;], timeout = 10000&lt;br/&gt;
08-23 13:11:27.767 D/: [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20&lt;br/&gt;
08-23 13:11:27.767 D/: No free connections [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]][null]&lt;br/&gt;
08-23 13:11:27.767 D/: Available capacity: 2 out of 2 [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]][null]&lt;br/&gt;
08-23 13:11:27.767 D/: Creating new connection [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]]&lt;br/&gt;
08-23 13:11:27.876 D/: Connecting to .com/*.*.*.*:443&lt;br/&gt;
08-23 13:11:28.509 D/: CookieSpec selected: best-match&lt;br/&gt;
08-23 13:11:28.540 D/: Attempt 1 to execute request&lt;br/&gt;
08-23 13:11:28.540 D/: Sending request: POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Cache-Control: no-cache&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Pragma: no-cache&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Authorization: Basic ****&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; ty: 0&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; v: 252&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; u: A000002201F102&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; postType: 1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; filenum: 0&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; pl: 1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; on: 1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; mf: 5&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Transfer-File-Name: file1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Transfer-File-Chunk-Count: 1&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Transfer-File-Chunk: 0&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; filelength: 39024636&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Cookie: ASP.NET_SessionId=v2jltw45cmu4wtiznidhavnx; path=/; HttpOnly&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Content-Length: 39024636&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Content-Type: binary/octet-stream&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Host: .com&lt;br/&gt;
08-23 13:11:28.556 D/: &amp;gt;&amp;gt; Connection: Keep-Alive&lt;br/&gt;
08-23 13:13:12.150 D/: Get connection: HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;], timeout = 10000&lt;br/&gt;
08-23 13:13:12.150 D/: [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20&lt;br/&gt;
08-23 13:13:12.150 D/: No free connections [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]][null]&lt;br/&gt;
08-23 13:13:12.150 D/: Available capacity: 2 out of 2 [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]][null]&lt;br/&gt;
08-23 13:13:12.150 D/: Creating new connection [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]]&lt;br/&gt;
08-23 13:13:12.197 D/: Connecting to .com/*.*.*.*:443&lt;br/&gt;
08-23 13:13:12.868 D/: CookieSpec selected: best-match&lt;br/&gt;
08-23 13:13:12.868 D/: Attempt 1 to execute request&lt;br/&gt;
08-23 13:13:12.868 D/: Sending request: POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; POST /UploadFiles.aspx HTTP/1.1&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; Cache-Control: no-cache&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; Pragma: no-cache&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; Authorization: Basic ****&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; ty: 0&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; v: 252&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; u: A000002201F102&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; postType: 1&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; filenum: 0&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; pl: 1&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; on: 1&lt;br/&gt;
08-23 13:13:12.876 D/: &amp;gt;&amp;gt; mf: 5&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Transfer-File-Name: file2&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Transfer-File-Chunk-Count: 1&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Transfer-File-Chunk: 0&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; filelength: 39024636&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Cookie: ASP.NET_SessionId=v2jltw45cmu4wtiznidhavnx; path=/; HttpOnly&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Content-Length: 39024636&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Content-Type: binary/octet-stream&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Host: .com&lt;br/&gt;
08-23 13:13:12.884 D/: &amp;gt;&amp;gt; Connection: Keep-Alive&lt;br/&gt;
08-23 13:13:57.556 D/: Connection closed&lt;br/&gt;
08-23 13:13:57.587 D/: Closing the connection.&lt;br/&gt;
08-23 13:13:57.587 D/: Connection closed&lt;br/&gt;
08-23 13:13:57.650 I/: I/O exception (java.io.IOException) caught when processing request: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-23 13:13:57.665 D/: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-23 13:13:57.665 D/: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)&lt;br/&gt;
08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)&lt;br/&gt;
08-23 13:13:57.665 D/:       at hg.a(ProGuard:2446)&lt;br/&gt;
08-23 13:13:57.665 D/:       at b.a(ProGuard:1962)&lt;br/&gt;
08-23 13:13:57.665 D/:       at b.a(ProGuard:1563)&lt;br/&gt;
08-23 13:13:57.665 D/:       at e.run(ProGuard:1509)&lt;br/&gt;
08-23 13:13:57.665 I/: Retrying request&lt;br/&gt;
08-23 13:13:57.665 D/: Reopening the direct connection.&lt;br/&gt;
08-23 13:13:57.665 D/: Connecting to .com/*.*.*.*:443&lt;br/&gt;
08-23 13:13:58.025 D/: Cannot retry non-repeatable request&lt;br/&gt;
08-23 13:13:58.033 D/: Connection shut down&lt;br/&gt;
08-23 13:13:58.033 D/: Released connection is not reusable.&lt;br/&gt;
08-23 13:13:58.033 D/: Releasing connection [HttpRoute[{s}-&amp;gt;&lt;a href=&quot;https://.com&quot;&gt;https://.com&lt;/a&gt;]][null]&lt;br/&gt;
08-23 13:13:58.040 D/: Notifying no-one, there are no waiting threads&lt;br/&gt;
08-23 13:13:58.056 E/: null&lt;br/&gt;
08-23 13:13:58.056 E/: org.apache41.http.client.ClientProtocolException&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)&lt;br/&gt;
08-23 13:13:58.056 E/:   at hg.a(ProGuard:2446)&lt;br/&gt;
08-23 13:13:58.056 E/:   at b.a(ProGuard:1962)&lt;br/&gt;
08-23 13:13:58.056 E/:   at b.a(ProGuard:1563)&lt;br/&gt;
08-23 13:13:58.056 E/:   at e.run(ProGuard:1509)&lt;br/&gt;
08-23 13:13:58.056 E/: Caused by: org.apache41.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:610)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)&lt;br/&gt;
08-23 13:13:58.056 E/:   ... 6 more&lt;br/&gt;
08-23 13:13:58.056 E/: Caused by: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)&lt;br/&gt;
08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)&lt;br/&gt;
08-23 13:13:58.056 E/:   ... 8 more&lt;br/&gt;
08-23 13:13:58.064 D/: Shutting down</comment>
                    <comment id="12902212" author="orcking" created="Wed, 25 Aug 2010 01:35:29 +0100"  >Oleg:&lt;br/&gt;
&lt;br/&gt;
Any ideas on the log I posted please...&lt;br/&gt;
&lt;br/&gt;
Thanks</comment>
                    <comment id="12902428" author="olegk" created="Wed, 25 Aug 2010 14:07:18 +0100"  >So, do I understand it correctly that your application is posting ~30MB of stuff using a non-repeatable entity? Well, what are the changes of temporarily losing the connection while such amount of data is being uploaded over a wireless link? The only problem on the HttpClient side is that the original I/O exception gets lost because the HttpConnection#close() method called by HttpRequestExecutor also terminates abnormally with an I/O exception. Feel free to raise a JIRA for this issue. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12902470" author="orcking" created="Wed, 25 Aug 2010 15:56:26 +0100"  >In the mean time..&lt;br/&gt;
&lt;br/&gt;
Is there a work around..???&lt;br/&gt;
&lt;br/&gt;
when it retries why does it fail?????&lt;br/&gt;
&lt;br/&gt;
is it not shutting down properly??</comment>
                    <comment id="12902477" author="olegk" created="Wed, 25 Aug 2010 16:31:04 +0100"  >Use self-contained (repeatable) entity implementation.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://hc.apache.org/httpcomponents-client-4.0.1/tutorial/html/fundamentals.html#d4e93&quot;&gt;http://hc.apache.org/httpcomponents-client-4.0.1/tutorial/html/fundamentals.html#d4e93&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Please post all your further questions to the user list.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12902878" author="orcking" created="Thu, 26 Aug 2010 15:36:00 +0100"  >repeatable entity means that I have to buffer the whole file into memory, (this is why I started using httpclient to start with, because URLConnection buffers the whole thing and I get outofmemory exception)&lt;br/&gt;
&lt;br/&gt;
Are you saying this is a bug with httpClient???</comment>
                    <comment id="12902884" author="olegk" created="Thu, 26 Aug 2010 15:53:06 +0100"  >&amp;gt; repeatable entity means that I have to buffer the whole file into memory,&lt;br/&gt;
&lt;br/&gt;
No, it does not. An entity does not have to be buffered in memory in order to be repeatable. It just need to be able to recreate its input stream&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Are you saying this is a bug with httpClient???&lt;br/&gt;
&lt;br/&gt;
No, it is not.&lt;br/&gt;
&lt;br/&gt;
Did you read the section of the tutorial I referred you to? If you have any further questions, post them to the user list.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12447678" name="httpClient4.0.x.diff" size="8004" author="tguerin" created="Tue, 22 Jun 2010 10:12:22 +0100" />
                    <attachment id="12447679" name="httpClient4.1.diff" size="7898" author="tguerin" created="Tue, 22 Jun 2010 10:12:22 +0100" />
                    <attachment id="12446599" name="httpClient.diff" size="2635" author="tguerin" created="Tue, 8 Jun 2010 16:27:44 +0100" />
                    <attachment id="12446670" name="httpClientTrunk.diff" size="2492" author="tguerin" created="Wed, 9 Jun 2010 10:21:30 +0100" />
                    <attachment id="12446598" name="httpCore.diff" size="2504" author="tguerin" created="Tue, 8 Jun 2010 16:27:44 +0100" />
                    <attachment id="12446671" name="httpCoreTrunk.Diff" size="2666" author="tguerin" created="Wed, 9 Jun 2010 10:21:30 +0100" />
                    <attachment id="12446868" name="testClientAuthentication.diff" size="3803" author="tguerin" created="Fri, 11 Jun 2010 15:36:21 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 8 Jun 2010 19:29:47 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133956</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47349</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>