<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:13:22 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-1153/HTTPCLIENT-1153.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-1153] org.apache.http.impl.client.cache.memcached.MemcachedHttpCacheStorage uses URL as cache key - shouldn&apos;t.</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-1153</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>Spy memcached has 250 defined as max key length:&lt;br/&gt;
&lt;a href=&quot;http://dustin.github.com/java-memcached-client/apidocs/constant-values.html#net.spy.memcached.MemcachedClientIF.MAX_KEY_LENGTH&quot;&gt;http://dustin.github.com/java-memcached-client/apidocs/constant-values.html#net.spy.memcached.MemcachedClientIF.MAX_KEY_LENGTH&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
URLs can be (and often are) much longer than 250 characters.&lt;br/&gt;
&lt;br/&gt;
URLs should be hashed before being used as keys.</description>
                <environment></environment>
            <key id="12535892">HTTPCLIENT-1153</key>
            <summary>org.apache.http.impl.client.cache.memcached.MemcachedHttpCacheStorage uses URL as cache key - shouldn&apos;t.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jonm">Jon Moore</assignee>
                                <reporter username="tinclon">Clinton Nielsen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 20 Dec 2011 20:03:00 +0000</created>
                <updated>Wed, 18 Jan 2012 15:36:53 +0000</updated>
                    <resolved>Wed, 18 Jan 2012 15:36:53 +0000</resolved>
                            <version>4.1.1</version>
                <version>4.1.2</version>
                                <fixVersion>4.1.3</fixVersion>
                <fixVersion>4.2 Beta1</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13185192" author="jonm" created="Thu, 12 Jan 2012 20:01:32 +0000"  >Hey all, I&amp;#39;m starting to work on this. I realized once we start hashing the keys there is a possibility (however remote) that we&amp;#39;ll get collisions, so I am working on a not-overly-complicated solution to serialize the original URL key in with the cache entry itself, so it can be compared when we retrieve it. I&amp;#39;ll be sure to go back around and add all the proper factory/interface/dependency-injection framework to make sure it&amp;#39;s extensible.&lt;br/&gt;
</comment>
                    <comment id="13185211" author="sebb@apache.org" created="Thu, 12 Jan 2012 20:32:41 +0000"  >Do we need to be careful to avoid the recently announced hashtable collision DoS vulnerability which can arise from the Java hashtable implementation [1] ?&lt;br/&gt;
&lt;br/&gt;
AIUI, the issue is that by carefully chosen input, an attacker can deliberately cause hash collisions; in turn these cause extra CPU to be used.&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;http://www.nruns.com/_downloads/advisory28122011.pdf&quot;&gt;http://www.nruns.com/_downloads/advisory28122011.pdf&lt;/a&gt;</comment>
                    <comment id="13185226" author="jonm" created="Thu, 12 Jan 2012 20:47:52 +0000"  >@Sebb: I don&amp;#39;t think this applies to us, as we&amp;#39;re not using a HashMap. Rather, I&amp;#39;m applying a hash function to map one set of values (the URLs the caching layer uses as cache keys) to another set of values (keys short enough to fit in the 250-byte constraint). The actual data structure (if any) that might be affected here would be in memcached. However, I&amp;#39;m planning on using a cryptographic hash algorithm, so it&amp;#39;s unlikely to be subject to the types of the attacks described in the vulnerability (e.g. the very simple hash functions commonly used for Object#hashCode()).</comment>
                    <comment id="13187812" author="jonm" created="Tue, 17 Jan 2012 17:18:42 +0000"  >Ok, just checked in the implementation here. Worth discussing: I ended up deprecating one of the existing constructors (one that took a custom serializer) because I had to change the serialization mechanism to accommodate fixing this bug. I somewhat suspect few folks would have been using custom serializers anyway, but there is a new constructor and some new interfaces that can be implemented if custom serialization is still desired.&lt;br/&gt;
&lt;br/&gt;
I chose SHA-256 as the default hashing scheme here. Do you think it is worth implementing fallback algorithms based on SHA-1 or MD5? I&amp;#39;m somewhat inclined to just let others contribute them if desired. The current default scheme with SHA-256 essentially resorts to not caching at all if it can&amp;#39;t find a SHA-256 algorithm, which might not be great for a default. Falling back to a weaker algorithm is probably not hard, so perhaps I&amp;#39;ll look at that next.&lt;br/&gt;
&lt;br/&gt;
At any rate, the KeyHashingScheme interface should let us also provide a prefix-naming scheme to solve &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPCLIENT-1154&quot; title=&quot;org.apache.http.impl.client.cache.memcached.MemcachedHttpCacheStorage should allow client to specify custom prefix string for keys&quot;&gt;&lt;strike&gt;HTTPCLIENT-1154&lt;/strike&gt;&lt;/a&gt; as well.&lt;br/&gt;
&lt;br/&gt;
@Clinton: does this work for you?</comment>
                    <comment id="13187826" author="tinclon" created="Tue, 17 Jan 2012 17:42:10 +0000"  >@Jon: Yeah, I took a brief look through the code and it looks good.&lt;br/&gt;
&lt;br/&gt;
One suggestion I have is that java.security.MessageDigest, as I understand it, is not threadsafe. So if multiple threads are trying to use MemcachedHttpCacheStorage (and even if they all have their own instance of the same), the MessageDigest class will always be using the same underlying instance and therefore one thread might stomp another while trying to generate a hash.&lt;br/&gt;
&lt;br/&gt;
Consider cloning the MessageDigest instance or synchronizing the creation of the hash.&lt;br/&gt;
&lt;br/&gt;
Thanks.&lt;br/&gt;
</comment>
                    <comment id="13187991" author="jonm" created="Tue, 17 Jan 2012 20:56:01 +0000"  >@Clinton: I was aware of the thread safety issues with MessageDigest, which is why I&amp;#39;m getting a new instance of it for each hash. I just verified that two subsequent calls to MessageDigest.getInstance() return distinct objects, so I think we&amp;#39;re ok there.&lt;br/&gt;
</comment>
                    <comment id="13188036" author="tinclon" created="Tue, 17 Jan 2012 21:37:39 +0000"  >Ah, very good then. Thanks for confirming.</comment>
                    <comment id="13188037" author="jonm" created="Tue, 17 Jan 2012 21:37:47 +0000"  >@Oleg - I&amp;#39;m ready to backport this to the 4.1.x branch but would like to hear your opinion on the deprecated constructor at least before I do.&lt;br/&gt;
</comment>
                    <comment id="13188068" author="olegk" created="Tue, 17 Jan 2012 22:15:02 +0000"  >@Jon: Ideally all new features, especially substantial like this one, should go through a BETA testing phase. Personally I would not merge to the 4.1.x branch, but will not object should you decide otherwise. Your opinion matters as much as mine.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="13188462" author="jonm" created="Wed, 18 Jan 2012 14:17:44 +0000"  >I&amp;#39;m somewhat torn here, because this is a bug currently, not a new feature. I&amp;#39;m going to research what the memcached client does when it gets a key that&amp;#39;s too long; if it silently ignores it (i.e. doesn&amp;#39;t do the put, and returns null for a get) or throws an exception we can catch where we can treat it the same way, then I&amp;#39;m ok not backporting this more thorough fix, as we won&amp;#39;t have correctness problems (we just won&amp;#39;t get effective caching, which while not optimal, is still compliant). If it truncates the key instead, though, then we could have cache collisions that would result in incorrect behavior, and I&amp;#39;d be more likely to want to backport the fix.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll see what I can find out and will post an update.&lt;br/&gt;
</comment>
                    <comment id="13188468" author="jonm" created="Wed, 18 Jan 2012 14:25:24 +0000"  >Ok, I looked into the spy-memcached source, and it throws an IllegalArgumentException when it encounters a key that&amp;#39;s too long. I think, then, that there&amp;#39;s a simpler fix similar to what we did for &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPCLIENT-1157&quot; title=&quot;MemcachedHttpCacheStorage should throw IOExceptions instead of Runtime Exceptions&quot;&gt;&lt;strike&gt;HTTPCLIENT-1157&lt;/strike&gt;&lt;/a&gt;, where we catch the IllegalArgumentException and re-throw it as an IOException (which the CachingHttpClient can then handle gracefully). I&amp;#39;ll work up a patch for that for the 4.1.x branch.</comment>
                    <comment id="13188508" author="jonm" created="Wed, 18 Jan 2012 15:36:45 +0000"  >Stopgap bugfix checked into 4.1.x as described. This is the lowest-risk solution to the problem; restores correct behavior at the cost of not caching those urls (which it wasn&amp;#39;t doing anyway; but at least this way the client can proceed with a non-cached backend request).&lt;br/&gt;
</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 12 Jan 2012 20:01:32 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>221576</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>46890</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>