<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:17:21 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-427/HTTPCLIENT-427.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-427] Implement a cache to perform real request only when needed</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-427</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>Browsers may cache received content according to the values of different&lt;br/&gt;
response headers. It would be great if HttpClient could do the same.</description>
                <environment>Operating System: Linux&lt;br/&gt;
Platform: PC</environment>
            <key id="12333986">HTTPCLIENT-427</key>
            <summary>Implement a cache to perform real request only when needed</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="mguillemot@yahoo.fr">Marc Guillemot</reporter>
                        <labels>
                    </labels>
                <created>Fri, 11 Feb 2005 01:34:13 +0000</created>
                <updated>Tue, 25 Jan 2011 10:58:34 +0000</updated>
                    <resolved>Thu, 6 May 2010 22:47:08 +0100</resolved>
                                            <fixVersion>4.1 Alpha2</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>4</votes>
                        <watches>8</watches>
                                                    <comments>
                    <comment id="12382150" author="olegk" created="Fri, 11 Feb 2005 05:12:55 +0000"  >HttpClient has never been meant to be a browser, however we MAY consider&lt;br/&gt;
providing a lightweight caching API without a concrete implementation in version 4.0&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12470330" author="rolandw" created="Mon, 5 Feb 2007 19:48:08 +0000"  >make that version 5</comment>
                    <comment id="12673283" author="sebb@apache.org" created="Fri, 13 Feb 2009 16:27:31 +0000"  >This would be useful for JMeter, though it would probably not want to store the full pages, only enough to identify them and the relevant headers.&lt;br/&gt;
&lt;br/&gt;
So it would be useful if the logic to determine cacheability etc was implemented independently of the store.</comment>
                    <comment id="12833405" author="youngm" created="Sat, 13 Feb 2010 16:28:21 +0000"  >This would be extremely useful in the case of restful service calls.  If http client could emulate a browsers caching logic and then expose an api that that will allow developers to plug this logic into their system&amp;#39;s caching solution that would be awesome!!!!!  I&amp;#39;ve looked around and couldn&amp;#39;t find any other http library that offers such functionality.  Client side caching could mark a big reason for frameworks such as CXF and Spring RestTemplate (provides Commons Http Client) to add Http Components as an optional client.&lt;br/&gt;
&lt;br/&gt;
This isn&amp;#39;t really a case of HttpClient trying to be a browser.  It&amp;#39;s a case for HttpClient to taking advantage of standard http headers to provide a well understood caching model.</comment>
                    <comment id="12835177" author="avlesh" created="Thu, 18 Feb 2010 12:19:39 +0000"  >I agree to Mike&amp;#39;s comment. Caching would be a boon for all rest based API&amp;#39;s. &lt;br/&gt;
I am ready to take on this issue and come up with a prototype. Can someone help me on where exactly to get started with? Is it HttpMethodBase?&lt;br/&gt;
&lt;br/&gt;
Would common&amp;#39;s cache (&lt;a href=&quot;http://commons.apache.org/sandbox/cache/&quot;&gt;http://commons.apache.org/sandbox/cache/&lt;/a&gt;) be good enough to start with, or something as complex as JSC (&lt;a href=&quot;http://jakarta.apache.org/jcs/&quot;&gt;http://jakarta.apache.org/jcs/&lt;/a&gt;) is needed?</comment>
                    <comment id="12835192" author="olegk" created="Thu, 18 Feb 2010 13:44:15 +0000"  >Avlesh,&lt;br/&gt;
&lt;br/&gt;
This is how I _personally_ think this issue should be addressed :&lt;br/&gt;
&lt;br/&gt;
(1) Firstly, one needs to define an abstract API for storing and retrieving content from an abstract cache. A single interface HttpCache (or some such) is likely to be sufficient.&lt;br/&gt;
&lt;br/&gt;
(2) Different implementations of the said caching API should be possible. The default one can be very simple just backed by a HashMap instance. For a more sophisticated implementation I would recommend using ehcache [1]&lt;br/&gt;
&lt;br/&gt;
(3) The caching logic should be implemented as a decorator for the HttpClient interface [2]. It should be possible to take any arbitrary instance of HttpClient and enhance it with caching capabilities.&lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;http://www.ehcache.org/&quot;&gt;http://www.ehcache.org/&lt;/a&gt;&lt;br/&gt;
[2] &lt;a href=&quot;http://hc.apache.org/httpcomponents-client/httpclient/apidocs/org/apache/http/client/HttpClient.html&quot;&gt;http://hc.apache.org/httpcomponents-client/httpclient/apidocs/org/apache/http/client/HttpClient.html&lt;/a&gt;</comment>
                    <comment id="12835277" author="avlesh" created="Thu, 18 Feb 2010 16:28:59 +0000"  >Thanks Oleg, these would be good for me to get started.&lt;br/&gt;
For your #3, shouldn&amp;#39;t caching be tightly coupled with HttpClient rather than being implemented as a decorator? More so, because, caching can only be implemented if the response headers direct an HttpClient instance to do so. Having said this, I definitely agree to the fact that actual cache should be an API implementation thereby giving users the flexibility to use a custom cache. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll come up with a basic cache API definition and share shortly.</comment>
                    <comment id="12835342" author="olegk" created="Thu, 18 Feb 2010 19:15:46 +0000"  >&amp;gt; For your #3, shouldn&amp;#39;t caching be tightly coupled with HttpClient rather than being implemented as a decorator?&lt;br/&gt;
&lt;br/&gt;
I am pretty sure it should not. Moreover, I think a good caching implementation should require no changes in the DefaultHttpClient at all.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12851047" author="cimjmoore" created="Mon, 29 Mar 2010 19:47:42 +0100"  >Hi folks,&lt;br/&gt;
&lt;br/&gt;
We had a group of engineers work on a CachingHttpClient as a &amp;quot;lab week&amp;quot; project last week, following (as it turns out) the same decorator pattern Oleg outlined. We&amp;#39;ve also developed a pluggable cache storage interface and have in-memory (basically a LRU HashMap), ehcache, and memcache backends. We&amp;#39;re not quite standards-compliant yet, but hopefully will be soon.&lt;br/&gt;
&lt;br/&gt;
Currently this builds as a separate JAR with all the classes under org.apache.http.client.cache as a new package (the adapters for the ehcache and memcache backends are also separate JARs so you can just include the dependencies you need).&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;d like to contribute this back to the community; are there any particulars about the best way to do this?&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
Jon Moore&lt;br/&gt;
Comcast Interactive Media&lt;br/&gt;
</comment>
                    <comment id="12851050" author="olegk" created="Mon, 29 Mar 2010 20:07:10 +0100"  >Jon,&lt;br/&gt;
&lt;br/&gt;
Simply attach the source (preferably in a form of a patch) to this issue and do not forget to select &amp;#39;Grant license to ASF for inclusion in ASF works&amp;#39;.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12851084" author="cimjmoore" created="Mon, 29 Mar 2010 21:47:05 +0100"  >Ok, great. It may take us a week or two to get it all tied up, but shouldn&amp;#39;t be a problem.&lt;br/&gt;
&lt;br/&gt;
Jon&lt;br/&gt;
</comment>
                    <comment id="12854521" author="cimjmoore" created="Wed, 7 Apr 2010 15:37:01 +0100"  >We&amp;#39;re taking the approach of trying to be a conditionally-compliant (meaning, we implement all the MUSTs and MUST NOTs in the RFC) HTTP/1.1 transparent proxy cache, even though technically the CachingHttpClient decorator isn&amp;#39;t a full proxy (since it doesn&amp;#39;t actually talk HTTP with its upstream client; we use the HttpClient API). In general, we feel like this will maximize interoperability but could lead to some surprising behavior.&lt;br/&gt;
&lt;br/&gt;
One example requirement of the RFC is: &amp;quot;Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.&amp;quot;&lt;br/&gt;
&lt;br/&gt;
Let&amp;#39;s say the client program issues a request like this:&lt;br/&gt;
&lt;br/&gt;
PUT / HTTP/1.1&lt;br/&gt;
Host: foo.example.com&lt;br/&gt;
Content-Length: 6&lt;br/&gt;
Content-Type: text/plain&lt;br/&gt;
If-Match: W/&amp;quot;etag&amp;quot;&lt;br/&gt;
&lt;br/&gt;
stuff&lt;br/&gt;
&lt;br/&gt;
If I were a compliant, standalone proxy, I would not be allowed to send this request downstream per the RFC, and would probably return a 400 (Bad Request). Now, the CachingHttpClient could likewise construct a 400 response and hand it right back, but this might be surprising to a client who had previously been interacting with a non-compliant origin that allowed this, in which case the CachingHttpClient wouldn&amp;#39;t really be a drop-in replacement.&lt;br/&gt;
&lt;br/&gt;
Is there some community opinion on how to behave in cases like this? Is subjecting ourselves to the rigors of requirements on proxies too much? Should this type of behavior be configurable?&lt;br/&gt;
</comment>
                    <comment id="12854535" author="oglueck" created="Wed, 7 Apr 2010 15:59:35 +0100"  >Jon, I like your approach. &lt;br/&gt;
&lt;br/&gt;
If you don&amp;#39;t know what to do with a request, the best thing you can do is to pass it on verbatim to the server, as would do the client without a cache. The server will know the answer. If you can&amp;#39;t decide whether it&amp;#39;s correct to cache the response or not, then don&amp;#39;t. Better make an extra request to the server than deliver stale or incorrect data (especially with WebDav you can easily loose data).&lt;br/&gt;
&lt;br/&gt;
My opinion on the case in question: The correct behaviour of a compliant server is undefined, especially no meaning must be implied to the returned status code or headers. Trying to be as transparent as possible should be the way to go here (trying not to break anything). So pass on the request verbatim to the destination and remove the resource from the cache, as you can&amp;#39;t know what the server will do.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12856419" author="cimjmoore" created="Tue, 13 Apr 2010 14:20:40 +0100"  >Just wanted to touch base here on progress, to keep the thread alive. We&amp;#39;ve got basic functionality working, and are working our way through the RFC to create unit tests around all the MUST/MUST NOT protocol requirements. In the meantime, here&amp;#39;s a couple more behavior questions:&lt;br/&gt;
&lt;br/&gt;
Options and Max-Forwards: in theory, if a proxy receives an OPTIONS request with a Max-Fowards: 0, it is not supposed to forward the request and instead should consider the OPTIONS request to be directed to it directly. Should the CachingHttpClient consider itself a proxy in this sense (i.e. count itself as a hop in the request/response chain)? Again, this is the &amp;quot;am I just part of the client or am I a proxy&amp;quot; question.&lt;br/&gt;
&lt;br/&gt;
Via header: probably related in spirit. Should the CachingHttpClient add Via headers as a proxy? i.e.&lt;br/&gt;
&lt;br/&gt;
Via: 1.0 localhost (CachingHttpClient/4.0.1)&lt;br/&gt;
</comment>
                    <comment id="12856424" author="oglueck" created="Tue, 13 Apr 2010 14:38:35 +0100"  >Jon,&lt;br/&gt;
&lt;br/&gt;
You are *not* implementing a proxy! Only a cache. A proxy is an intermediate server that the client is fully aware of. The client uses the CONNECT method and proxy-specific headers to interact with a proxy. A cache however is fully transparent to the client. The client has no knowledge about the proxy. No Via headers. No Max-Forwards interpretation. A cache only interacts with the headers that control lifetime of the cached object. Apart from that it just replays responses to the client. That implies that you have to store also the original headers and not just the request body. In my opinion the cache should even issue the original Date and Server headers back to the client and not generate new ones.</comment>
                    <comment id="12856428" author="olegk" created="Tue, 13 Apr 2010 14:56:25 +0100"  >+1 to what Odi said.&lt;br/&gt;
&lt;br/&gt;
BTW, I intend to start working on the 4.1-a2 release in a few days. If you think your code is ready for testing by a larger community of users I could hold back the release for a week or so.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12857193" author="cimjmoore" created="Thu, 15 Apr 2010 05:26:41 +0100"  >Ok, I think we have something ready to be poked at by a larger community. We&amp;#39;re getting the signoff from the legal team (shouldn&amp;#39;t be a problem), and it should be pretty easy to produce the patch from what we have going in our internal repository. Let us know what your release deadline would be and we&amp;#39;ll try to hit it.</comment>
                    <comment id="12857248" author="olegk" created="Thu, 15 Apr 2010 10:39:52 +0100"  >There is no deadline, but due to personal circumstances I would like to get the next release out within the next two weeks.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12857815" author="davidmays" created="Fri, 16 Apr 2010 14:54:33 +0100"  >Hi, I&amp;#39;m working with Jonathan on the caching client. Am I correct in assuming that I should create the patch against the 4.1-alpha1 tag in SVN? </comment>
                    <comment id="12857817" author="olegk" created="Fri, 16 Apr 2010 15:03:23 +0100"  >Usually one should always be using trunk when submitting new features&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
In this particular case it should not really matter, though, as the code should be self-contained and should not require any changes to the existing classes.&lt;br/&gt;
&lt;br/&gt;
Either a patch or a bunch of ZIPPED classes should do just fine.&lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
</comment>
                    <comment id="12859810" author="davidmays" created="Thu, 22 Apr 2010 14:04:38 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve sent you a tgz of the source code for the caching client. Let me know if you need anything or have any questions.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12859815" author="olegk" created="Thu, 22 Apr 2010 14:24:50 +0100"  >Hhhm. I guess you did not get my response to your message for some reason. I simply cannot commit code sent to me directly. You MUST attach the patch to this issue and clearly state that the code is granted to the ASF (Apache Software Foundation) under the terms of ASL (Apache Software License) and that you are acting with a consent of your employer. &lt;br/&gt;
&lt;br/&gt;
Oleg </comment>
                    <comment id="12859823" author="davidmays" created="Thu, 22 Apr 2010 15:15:11 +0100"  >This patch is being submitted by David Mays on behalf of Comcast Corporation. I am acting with the consent of my employer. &lt;br/&gt;
&lt;br/&gt;
It is intended for redistribution and is granted to the Apache Software Foundation under the terms of the Apache Software License.&lt;br/&gt;
&lt;br/&gt;
Contributors to this patch:&lt;br/&gt;
Joe Campbell&lt;br/&gt;
David Cleaver&lt;br/&gt;
David Mays&lt;br/&gt;
Jon Moore&lt;br/&gt;
Brad Spenla&lt;br/&gt;
</comment>
                    <comment id="12859824" author="davidmays" created="Thu, 22 Apr 2010 15:16:56 +0100"  >You are correct. I did not receive your message. However you should now be able to see the attachment I have just uploaded.&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12859826" author="olegk" created="Thu, 22 Apr 2010 15:26:23 +0100"  >I will review and commit the patch either today or tomorrow.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12860384" author="davidmays" created="Fri, 23 Apr 2010 22:35:57 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
We discovered that something seems to be fatally broken right now, in the sense that it is not caching anything. Please hold off integrating this for now. My apologies for the false start.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll get back to you about it on Monday. It&amp;#39;s likely a very small bug, since we did at one time have certainty that it WAS working correctly.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12860502" author="olegk" created="Sat, 24 Apr 2010 09:53:51 +0100"  >Dave,&lt;br/&gt;
&lt;br/&gt;
No worries. Even if it is broken it might be better if I check in the code sooner than later, so others could start reviewing the API. However, it looks like I will have to migrate HttpClient from JUnit 3 to JUnit 4 before your code could be committed.&lt;br/&gt;
&lt;br/&gt;
Another thing. I&amp;#39;d be really great if you could contribute a short section on the caching extension to the HttpClient tutorial.&lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12860544" author="sebb@apache.org" created="Sat, 24 Apr 2010 17:33:10 +0100"  >JUnit4 is backwards compatible with JUnit3, and HttpClient requires Java 1.5+ so the dependency for HttpClient could just be changed to 4.8.1. (4.8.2 has been released, but is not yet in Maven or on SourceForge)&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s probably not a good idea to mix JUnit3 and 4 syntax in the same class, however ;-)</comment>
                    <comment id="12860921" author="davidmays" created="Mon, 26 Apr 2010 14:44:25 +0100"  >Oops. I didn&amp;#39;t even consider the JUnit version issue when submitting this.&lt;br/&gt;
&lt;br/&gt;
I believe we&amp;#39;ll be ready with a non-broken submission later today. One of our guys spent some time this weekend fixing that, as well as making some other new unit tests pass. He&amp;#39;s down to the last failing test, so I think we&amp;#39;re in good shape.&lt;br/&gt;
&lt;br/&gt;
How do I go about contributing to the tutorial?</comment>
                    <comment id="12861053" author="davidmays" created="Mon, 26 Apr 2010 20:06:31 +0100"  >This file supercedes my previous submission of cachingclient.tgz. This one actually works, and has more passing tests.&lt;br/&gt;
&lt;br/&gt;
I am submitting this and granting the software to the ASF, under the terms of the ASL, with full consent of my employer, Comcast Corporation.&lt;br/&gt;
</comment>
                    <comment id="12861417" author="olegk" created="Tue, 27 Apr 2010 15:49:08 +0100"  >&amp;gt; How do I go about contributing to the tutorial?&lt;br/&gt;
&lt;br/&gt;
Ideally, by submitting a patch. The latest tutorial snapshot in the DocBook format can be found here:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/src/docbkx/&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/src/docbkx/&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I took a _very_ cursory look at the code. Overall, great stuff. Some minor remarks:&lt;br/&gt;
&lt;br/&gt;
(1) I spotted quite a few instance variables that could be made final. Final variables make code somewhat less prone to race conditions and generally make it easier to ensure thread-safety when accessed by multiple threads.&lt;br/&gt;
&lt;br/&gt;
(2) Static Logs are considered harmful in managed environments such as JEE containers. HttpClient uses non-static Log instances as recommended by the developers of Commons Logging. Cache should be consistent with the rest of the code base.&lt;br/&gt;
&lt;br/&gt;
(3) I see lots of places where CacheOperationExceptions are silently discarded. Each particular case should be reviewed and the exception should either be propagated, handled or logged. Exceptions should be ignored in very special cases only. In most cases logging at DEBUG or WARN priority is all that it takes. &lt;br/&gt;
&lt;br/&gt;
(4) Ideally CacheEntry class should not impose a particular physical representation of the cache entry content (for instance, as a byte array). We might also want to provide a file system based cache implementation, which ideally should function without buffering the entire response content in memory. I kind of think CacheEntry might even use HttpEntity interface for content representation.&lt;br/&gt;
&lt;br/&gt;
There are two ways we could proceed. (1) I can commit the patch pretty much as is and let you work on improvements incrementally by submitting smaller patches, or (2) you can resubmit the whole thing if that is easier for you. &lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg </comment>
                    <comment id="12861878" author="olegk" created="Wed, 28 Apr 2010 19:05:59 +0100"  >David,&lt;br/&gt;
&lt;br/&gt;
I started messing with your code. You probably should not make any major changes in your local code tree until the code is committed to the repository.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12862199" author="davidmays" created="Thu, 29 Apr 2010 14:49:24 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
Thanks for letting me know! I was actually planning to suggest this morning that you go ahead and commit the code if you are ready, so that I can check out the trunk and work on the suggestions you had.&lt;br/&gt;
&lt;br/&gt;
If you&amp;#39;re not ready to commit it to the trunk yet, that is fine also; I can put off any local modifications for a while.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&lt;br/&gt;
Dave&lt;br/&gt;
</comment>
                    <comment id="12862372" author="olegk" created="Thu, 29 Apr 2010 20:48:26 +0100"  >Dave,&lt;br/&gt;
&lt;br/&gt;
My wife just gave birth to our first child. Things are a bit hectic right now. I&amp;#39;ll try to commit the code tomorrow.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12862399" author="davidmays" created="Thu, 29 Apr 2010 21:33:43 +0100"  >Oleg, &lt;br/&gt;
&lt;br/&gt;
That&amp;#39;s outstanding! Congratulations on the addition to your family.&lt;br/&gt;
&lt;br/&gt;
I certainly understand if it isn&amp;#39;t committed very soon.&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12862602" author="olegk" created="Fri, 30 Apr 2010 10:26:02 +0100"  >Dave,&lt;br/&gt;
&lt;br/&gt;
Please find a slightly reworked version of your code attached to the issue. I took liberty of making a number of changes in order to make the code more consistent with the rest of HttpClient. I started splitting the code into API and impl parts and generified some public interfaces. I also converted all test cases to JUnit 4 (by the way the test coverage in truly impressive).&lt;br/&gt;
&lt;br/&gt;
If I hear no objections, I&amp;#39;ll commit the code tonight (~20:00 GMT)&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12862682" author="davidmays" created="Fri, 30 Apr 2010 15:29:26 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
Sounds good. I like the direction you&amp;#39;re going, separating it into Impl and interfaces. &lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12862868" author="olegk" created="Fri, 30 Apr 2010 22:13:34 +0100"  >Dave,&lt;br/&gt;
&lt;br/&gt;
Module checked in. Many thanks you all you, guys, for contributing it!&lt;br/&gt;
&lt;br/&gt;
I forgot to mention another minor issue. One of the tests TestCachingHttpClient#testRealResultsMatch depends on an external resource. If possible, consider replacing it with a mock service based on LocalTestServer. You can use TestRedirects test cases as a starting point.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/client/protocol/TestRedirects.java&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/client/protocol/TestRedirects.java&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/localserver/LocalTestServer.java&quot;&gt;http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/localserver/LocalTestServer.java&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
As soon as the issues I mentioned previously have been looked into, I&amp;#39;ll proceed with cutting an official release&lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12862929" author="sebb@apache.org" created="Sat, 1 May 2010 00:38:56 +0100"  >The volatile long count fields in CachingHttpClient are not guaranteed to be updated correctly by multiple threads.&lt;br/&gt;
&lt;br/&gt;
This is because:&lt;br/&gt;
* increment is not atomic&lt;br/&gt;
* long read/write are not guaranteed atomic (though they probably are on most modern hardware)&lt;br/&gt;
&lt;br/&gt;
The first could cause lost updates, the second could cause rubbish values to be stored.&lt;br/&gt;
&lt;br/&gt;
Could either use AtomicLong, or could synchronize updates.</comment>
                    <comment id="12862937" author="sebb@apache.org" created="Sat, 1 May 2010 01:03:28 +0100"  >I think one or two classes are not currently thread-safe:&lt;br/&gt;
&lt;br/&gt;
CacheEntry&lt;br/&gt;
CachingHttpClient (only the counts are a possible problem)&lt;br/&gt;
OptionsHttp11Response - not sure why the instance fields are not final &amp;amp; private?&lt;br/&gt;
SizeLimitedResponseReader&lt;br/&gt;
&lt;br/&gt;
Are these classes intended to be shared between threads?</comment>
                    <comment id="12863003" author="olegk" created="Sat, 1 May 2010 11:08:02 +0100"  >I think all these classes need to be thread-safe, as the cache may be accessed from multiple worker threads concurrently.&lt;br/&gt;
&lt;br/&gt;
Oleg </comment>
                    <comment id="12863447" author="davidmays" created="Mon, 3 May 2010 19:23:11 +0100"  >For the SizeLimitedResponseReader and OptionsHttp11Response, these are &amp;quot;new&amp;quot; for every request, and so should not be accessed by multiple threads unless someone was doing something very unusual in their client code.&lt;br/&gt;
&lt;br/&gt;
The counters in CachingHttpClient are being updated to AtomicLong.&lt;br/&gt;
&lt;br/&gt;
The tricky bit is the CacheEntry.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m thinking that the atomicity there should be in the updates to the cache, rather than the entry itself. We already have this notion with the HttpCacheUpdateCallback, which enables atomic updates to the cache. The key is preventing existing instances of a CacheEntry from being updated while someone is reading one. I believe we have a handle on how to make this happen, so we are working on it now.&lt;br/&gt;
&lt;br/&gt;
What do you consider the top priority items to complete before you consider this ready for release? Specifically, is the CacheEntry physical representation something you consider gating for release, or can that go as-is for now?&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12863488" author="olegk" created="Mon, 3 May 2010 20:42:21 +0100"  >Dave,&lt;br/&gt;
&lt;br/&gt;
Only threading issue is a show stopper. All others can be addressed at a later point and should not block the release. &lt;br/&gt;
&lt;br/&gt;
In my opinion the best way to ensure CacheEntity thread safety is by making it immutable. Basically instead of updating an exiting entry the cache should replace an existing entry with a new one thus making synchronisation on that entity unnecessary. This solves threading issue without decreasing performance.   &lt;br/&gt;
&lt;br/&gt;
I already have started working on a patch but was unable to fix 5 test cases that currently fail. I will do my best to finish my changes tomorrow and pass it onto you for review. &lt;br/&gt;
&lt;br/&gt;
I have stumbled upon one particular bit which I cannot fully understand without your help. What is the intent of variantURIs set? I could not figure out just by looking at the test cases.  &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12863495" author="davidmays" created="Mon, 3 May 2010 21:02:48 +0100"  >The idea behind Variant URIs is that for a resource that has Vary response headers, we store a &amp;quot;parent&amp;quot; cache entry, which has pointers (variant URIs) to &amp;quot;child&amp;quot; entries. The child entries will contain the &amp;quot;variable&amp;quot; content for that resource. So the parent entry becomes the map to find a given child entry, where the URI (cache key) has had a string like {Content-Encoding:gzip} prepended to it&lt;br/&gt;
&lt;br/&gt;
So you might have a parent entry like this:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;&lt;a href=&quot;http://www.example.com/foo&quot;&gt;http://www.example.com/foo&lt;/a&gt;&amp;quot;&lt;br/&gt;
&lt;br/&gt;
With children like these:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;{Content-Encoding:gzip}&lt;a href=&quot;http://www.example.com/foo&quot;&gt;http://www.example.com/foo&lt;/a&gt;&amp;quot; (Caused by a request that had Accept-Encoding:gzip header)&lt;br/&gt;
&amp;quot;{Content-Encoding:identity}&lt;a href=&quot;http://www.example.com/foo&quot;&gt;http://www.example.com/foo&lt;/a&gt;&amp;quot; (Caused by a request that had Accept-Encoding:identity header)&lt;br/&gt;
&lt;br/&gt;
The idea of keeping the list of variant children with the parent entry is so that we can clean up all child entries when a parent is invalidated. It prevents orphan cache entries.&lt;br/&gt;
&lt;br/&gt;
Regarding the atomic updates, we had also started working on a patch for that, where CacheEntry had a new constructor that took everything you need, instead of the HttpResponse. Obviously all the other setters were to be removed also. This way, every time a cache entry is &amp;quot;pulled&amp;quot; from the cache, it is effectively a copy, rather than a reference.&lt;br/&gt;
&lt;br/&gt;
The CacheEntryUpdater class would have to be changed slightly to work with this, but would not be especially difficult to do.&lt;br/&gt;
&lt;br/&gt;
Dave&lt;br/&gt;
</comment>
                    <comment id="12863613" author="sebb@apache.org" created="Tue, 4 May 2010 02:55:46 +0100"  >For OptionsHttp11Response - is there any need for the instance variables statusLine and version to be mutable? Can they be made private?&lt;br/&gt;
I know fixing this is not strictly necessary, but then again is it necessary for the fields to be mutable and not private?&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s a lot better to start with all fields private - and final if possible - and only increase the visibility if strictly necessary.</comment>
                    <comment id="12863786" author="vwdiesel" created="Tue, 4 May 2010 13:34:43 +0100"  >Yes - they can be made private and final - as they are never meant to change.  In fact, I added the @Immutable annotation to the class (similar to other classes assumed to have been modified by Oleg).  OptionsHttp11Response&amp;#39;s purpose is to serve as the response container for a request OPTIONS query with maxforwards set to 0 (essentially a loopback to indicate all the various things that the cache will support).  &lt;br/&gt;
&lt;br/&gt;
This change will be included in a patch from us when Oleg is complete with making CacheEntry immutable as well.  We are trying not to collide changes by pausing to wait for Oleg&amp;#39;s changes on the tree and then supplying a patch for some of the other minor changes requested based on that.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Joe  &lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12863797" author="olegk" created="Tue, 4 May 2010 13:54:30 +0100"  >Dave, Joe&lt;br/&gt;
&lt;br/&gt;
I could not fully complete the changes that I had in mind. So far I managed to have made all variables in the CacheEntry class final which helps a great deal to ensure thread safety of the class, but I was unable to make it truly immutable. Variant URIs can still be mutated by multiple threads leading to a race condition. I have also failed miserably trying to wrap my head around EasyMock which turned out to be far from easy. One of the test cases still fails after my changes and I was not able to fix it nor to fully understand why it is failing in the first place. I think it is better if you take over from here and incorporate the patch (attached) into your change set.&lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12863805" author="vwdiesel" created="Tue, 4 May 2010 14:20:14 +0100"  >Thanks Oleg.&lt;br/&gt;
&lt;br/&gt;
I think that Dave was heading down the very same path that you were (attempting to make CacheEntry immutable).  We&amp;#39;ll take a look at your patch and incorporate as needed.  I don&amp;#39;t want to speak for Dave (as he was the one making the change) but we should have a patch in the next day, TWO at the most.&lt;br/&gt;
&lt;br/&gt;
Also if you have specific questions about EasyMock - don&amp;#39;t hesitate to send a direct email to Dave or myself.  Happy to help the learning and information dissemination of a wonderful framework for mocking.  8-)&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Joe</comment>
                    <comment id="12864756" author="davidmays" created="Thu, 6 May 2010 13:55:40 +0100"  >This patch correctly makes CacheEntry immutable, and fixes all the unit tests that broke based on this change.</comment>
                    <comment id="12864902" author="olegk" created="Thu, 6 May 2010 21:11:48 +0100"  >Patch checked in. Many thanks, David&lt;br/&gt;
&lt;br/&gt;
As far as I can tell all major issues have been addressed. I&amp;#39;ll start cutting preview packages sometime this weekend.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12864912" author="sebb@apache.org" created="Thu, 6 May 2010 21:36:48 +0100"  >I think there is still a minor issue with the CacheEntry class.&lt;br/&gt;
&lt;br/&gt;
It contains the field:&lt;br/&gt;
&lt;br/&gt;
private final byte[] body;&lt;br/&gt;
&lt;br/&gt;
However, this is exposed by both the constructor and getBody(), neither of which copy the array.&lt;br/&gt;
&lt;br/&gt;
As it stands, the class is not @Immutable, because the body array can be changed externally.&lt;br/&gt;
&lt;br/&gt;
Simplest solution is to copy the array.&lt;br/&gt;
&lt;br/&gt;
Also, the CacheInvalidator class is definitely not @Immutable, because the cache can be upated.&lt;br/&gt;
It is @ThreadSafe, so long as the cache implementation is @ThreadSafe&lt;br/&gt;
&lt;br/&gt;
The AtomicLong fields in CachingHttpClient don&amp;#39;t need to be volatile; also I think the class is now @ThreadSafe, so long as the responseCache is.&lt;br/&gt;
</comment>
                    <comment id="12864930" author="olegk" created="Thu, 6 May 2010 22:14:10 +0100"  >Sebastian,&lt;br/&gt;
&lt;br/&gt;
I would like that byte array be eventually replaced with a more complex object similar to HttpEntity. While CacheEntity is not truly immutable, it is thread safe now. This is good enough for the first cut and should not be a release blocker. Feel free to remove @Immutable annotations which you find inappropriate.  Please just go ahead and make whatever changes you deem necessary to close the issue and proceed with the release.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12864941" author="sebb@apache.org" created="Thu, 6 May 2010 22:47:08 +0100"  >CacheEntity is not inherently thread-safe, because external classes can affect the byte array in non-threadsafe manner.&lt;br/&gt;
It is only threadsafe if the external classes behave themselves.&lt;br/&gt;
However, cloning the body array means that the class is now @Immutable.&lt;br/&gt;
&lt;br/&gt;
Other issues also fixed.</comment>
                    <comment id="12864982" author="vwdiesel" created="Fri, 7 May 2010 01:43:24 +0100"  >Sebastian,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The volatile keyword effects the multi-thread visibility of the value located in the AtomicLong.  To be appropriate, the volatile keyword should remain.  From the util.concurrent java doc:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form...&amp;quot;&lt;br/&gt;
&lt;br/&gt;
volatility and atomicity are not the same by this notation, would you be ok with putting that keyword back?&lt;br/&gt;
&lt;br/&gt;
Also - I am curious about the @Immutable annotation in reference to the CacheInvalidator... by your definition CacheInvalidator is not immutable because a member variable of the invalidator can change internally (meaning things can be added and removed from the cache) - I am unclear though why this &amp;#39;cache&amp;#39; mutability effects the mutability of the Invalidator class.  Once the Cache is set on the CacheInvalidator it can only be changed if the cache is reconstructed/replaced (i.e. a new instance of the CacheInvalidator is needed to change the cache it uses).  &lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Joe</comment>
                    <comment id="12865107" author="sebb@apache.org" created="Fri, 7 May 2010 11:25:53 +0100"  >@Joe: &lt;br/&gt;
&lt;br/&gt;
From the Javadoc for java.util.concurrent.atomic:&lt;br/&gt;
&lt;br/&gt;
#  get has the memory effects of reading a volatile variable.&lt;br/&gt;
# set has the memory effects of writing (assigning) a volatile variable. &lt;br/&gt;
&lt;br/&gt;
The way I read that, there is no need to use volatile. &lt;br/&gt;
If there were, then AtomicLong would not be thread-safe.&lt;br/&gt;
&lt;br/&gt;
I already changed CacheInvalidator to @ThreadSafe rather than @Immutable.</comment>
                    <comment id="12865134" author="sberlin" created="Fri, 7 May 2010 14:02:27 +0100"  >One statement, one question:&lt;br/&gt;
&lt;br/&gt;
1) Without looking at the code involved, the AtomicLong variable would only need to be volatile if the variable itself were being assigned to a new AtomicLong in one thread and used in another.  If the AtomicLong object is created &amp;amp; assigned in one place (preferably the constructor, allowing the object to be final), then calling &amp;#39;set&amp;#39; or &amp;#39;get&amp;#39; on it is effectively the same as calling get or set on a volatile long.  If you say &amp;#39;new AtomicLong&amp;#39; somewhere other than the constructor, something is probably wrong with the code.&lt;br/&gt;
&lt;br/&gt;
2) Re: the byte[].clone() that sebb added.  Again I haven&amp;#39;t looked too deeply at the code (just the diffs), but is that the byte[] of the body of a cached response?  If so, that could potentially be very large.  Cloning it could lead to memory crunches.  Is it possible to change the objects involved to ByteBuffers &amp;amp; convert it using asReadOnly?  Additionally, if it is a byte[] of the body of cached response... I&amp;#39;m concerned that larger responses (ie, downloading a large file) wouldn&amp;#39;t even be able to be stored in memory.  Does the API allow for reading the data from an InputStream (or Channel?).  (If that byte[] is not for the body of cached responses, you can ignore this question.)</comment>
                    <comment id="12865145" author="cimjmoore" created="Fri, 7 May 2010 14:25:36 +0100"  >@Sam:&lt;br/&gt;
&lt;br/&gt;
The byte[] is indeed the cached response body, and I would agree with Seb that as-is, it&amp;#39;s not threadsafe because someone can muck with the bytearray. I think clone() on the byte array solves this, but at the expense of extra copies of the data. The Right Way is probably going down the road that Oleg suggests, which is to use something like HttpEntity instead which can be treated as immutable.&lt;br/&gt;
&lt;br/&gt;
With regard to the potential size of the response, the CachingHttpClient lets you specify a max object size (with a heuristic default behavior that I&amp;#39;d have to recheck in the code); if the CachingHttpClient encounters a response that exceeds this, it won&amp;#39;t try to cache it and will just stream the result through (it will optimistically consume some of the input stream, in case there is a chunked-encoding response that will fit, but if this process exceeds the max length then it will return a response with a &amp;quot;composite&amp;quot; input stream that returns the byte array read so far, then &amp;quot;appends&amp;quot; the rest of the unconsumed origin response stream.&lt;br/&gt;
</comment>
                    <comment id="12865149" author="cimjmoore" created="Fri, 7 May 2010 14:34:45 +0100"  >Please find attached a patch that adds some more acceptance tests to TestProtocolRequirements, as gleaned from Section 13 of RFC 2616, in terms of MUST and MUST NOT requirements. Existing code already passed these, so this is a net addition of passing unit tests.&lt;br/&gt;
&lt;br/&gt;
This contribution is made with the consent of my employer, Comcast Interactive Media, and license is granted to the ASF for inclusion in ASF works.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12865162" author="vwdiesel" created="Fri, 7 May 2010 15:08:28 +0100"  >@Sam:&lt;br/&gt;
&lt;br/&gt;
RE #1) Thank you for the more in depth explanation of volatile keywords use in this case.  This clarified the use of the keyword for me quite a bit and has made my understanding of what that keyword &amp;#39;really&amp;#39; does in code more precise.  &lt;br/&gt;
&lt;br/&gt;
RE #2) I think Jon covered that explanation.  I think all here (that have worked on the Caching client) agree that we would like to head down the path that Oleg suggested - but we don&amp;#39;t want that work to gate getting the &amp;#39;working foundation&amp;#39; of this code checked in and released.  We are happy to continue to work with the group to make suggested changes to improve and strengthen this code base contribution.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Joe</comment>
                    <comment id="12865169" author="olegk" created="Fri, 7 May 2010 15:28:53 +0100"  >@Jonathan&lt;br/&gt;
&lt;br/&gt;
Many thanks for contributing the patch. Committed to SVN trunk&lt;br/&gt;
&lt;br/&gt;
@all&lt;br/&gt;
&lt;br/&gt;
I think things are in a shape good enough for an ALPHA release. &lt;br/&gt;
&lt;br/&gt;
I raised a new JIRA for the cache entry representation issue, see &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPCLIENT-937&quot; title=&quot;Make CacheEntry use an immutable object to represent cache content &quot;&gt;&lt;strike&gt;HTTPCLIENT-937&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
@Jonathan, Joe and Dave&lt;br/&gt;
&lt;br/&gt;
A short tutorial section about caching support would make things absolutely perfect &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12865248" author="davidmays" created="Fri, 7 May 2010 18:42:19 +0100"  >I&amp;#39;m working on an additional chapter for the documentation, titled &amp;quot;HTTP Caching&amp;quot; which will include general background on the caching code, its effort at being compliant with the caching requirements in RFC-2616 and a trivial example of how one might configure it.&lt;br/&gt;
&lt;br/&gt;
I should be ready to send a patch with that sometime today.&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12865295" author="davidmays" created="Fri, 7 May 2010 21:17:28 +0100"  >Attached is a patch that contains a new docbook chapter about the Caching Client.&lt;br/&gt;
&lt;br/&gt;
Let me know if you would like it to be more or less than it is, or modify as you see fit.&lt;br/&gt;
&lt;br/&gt;
Dave</comment>
                    <comment id="12865435" author="olegk" created="Sat, 8 May 2010 10:24:04 +0100"  >I think it is about right. Patch checked in. Many thanks, Dave&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12442884" name="caching_client.zip" size="82012" author="davidmays" created="Mon, 26 Apr 2010 20:06:31 +0100" />
                    <attachment id="12443993" name="docbook-caching-tutorial.patch" size="6584" author="davidmays" created="Fri, 7 May 2010 21:17:28 +0100" />
                    <attachment id="12443855" name="HTTPCLIENT-427-Immutable-CacheEntry2.patch" size="136694" author="davidmays" created="Thu, 6 May 2010 13:55:40 +0100" />
                    <attachment id="12443577" name="HTTPCLIENT-427-immutable-cachenentry.patch" size="53678" author="olegk" created="Tue, 4 May 2010 13:54:30 +0100" />
                    <attachment id="12443963" name="HTTPCLIENT-427-rfc2616-sec13-tests.patch" size="25942" author="cimjmoore" created="Fri, 7 May 2010 14:34:45 +0100" />
                    <attachment id="12443271" name="httpclient-cache.zip" size="108437" author="olegk" created="Fri, 30 Apr 2010 10:26:02 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                <customfieldname>Bugzilla Id</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>33496</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 11 Feb 2005 05:12:55 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133474</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47477</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>