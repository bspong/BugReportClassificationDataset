<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:19:55 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-677/HTTPCLIENT-677.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-677] Connection pool uses Thread.interrupt()</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-677</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>The connection pool for TSCCM uses Thread.interrupt() to wake up waiting threads.&lt;br/&gt;
This interferes with application interrupts.&lt;br/&gt;
&lt;br/&gt;
- expose InterruptedException in interface&lt;br/&gt;
- change pool implementation to use wait/notify&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12374818">HTTPCLIENT-677</key>
            <summary>Connection pool uses Thread.interrupt()</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="rolandw">Roland Weber</assignee>
                                <reporter username="rolandw">Roland Weber</reporter>
                        <labels>
                    </labels>
                <created>Fri, 27 Jul 2007 16:57:46 +0100</created>
                <updated>Tue, 25 Jan 2011 10:58:40 +0000</updated>
                    <resolved>Sat, 29 Dec 2007 14:41:04 +0000</resolved>
                            <version>4.0 Alpha 1</version>
                <version>4.0 Alpha 2</version>
                                <fixVersion>4.0 Alpha 3</fixVersion>
                                <component>HttpConn</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12552401" author="rolandw" created="Mon, 17 Dec 2007 13:20:27 +0000"  >This is a nasty one. Currently, all synchronization is done on the pool level to protect access to the various queues. Threads wait() on the pool, thereby releasing the lock while they wait. There are no notifications, instead the chosen threads are interrupted.&lt;br/&gt;
&lt;br/&gt;
To avoid the interrupt, threads have to wait on distinct objects, at least one per route queue, better one per thread. To wait on those objects, a thread needs to synchronize on the object. During the wait, only the lock on the extra object will be released, but not the lock on the pool. The following sequence is necessary to make this work:&lt;br/&gt;
- create thread specific object&lt;br/&gt;
- acquire lock on the pool&lt;br/&gt;
- update queues&lt;br/&gt;
- release lock on the pool (*)&lt;br/&gt;
- acquire lock on the object (*)&lt;br/&gt;
- call wait() on the object (*)&lt;br/&gt;
- release lock on the object (?)&lt;br/&gt;
- acquire a new lock on the pool (?)&lt;br/&gt;
- update queues&lt;br/&gt;
- release lock on the pool&lt;br/&gt;
The obvious weak spot (*) is the time between releasing the first lock on the queue and calling wait() on the object. The wakeup notification from another thread may be triggered inbetween and must not be lost. Therefore, the object needs to remember a notification until a thread comes to wait.&lt;br/&gt;
A second potential weak spot (?) is the time from wakeup until the lock on the pool is re-acquired. A thread might be chosen for notification a second time in this timeframe. Either the object must carry an indicator that it has already been chosen, or the first notifier must remove the object from the queues before notification. In the second case, the thread has to reacquire the pool lock and to update the queues only if it is interrupted externally rather than being notified. Which still leaves a window for notification to the interrupted thread. &lt;br/&gt;
&lt;br/&gt;
I know how to deal with (*), but I need a bit more time to think about (?).&lt;br/&gt;
&lt;br/&gt;
yuck.&lt;br/&gt;
</comment>
                    <comment id="12552447" author="olegk" created="Mon, 17 Dec 2007 15:37:36 +0000"  >&amp;gt; - release lock on the object (?)&lt;br/&gt;
&amp;gt; - acquire a new lock on the pool (?) &lt;br/&gt;
&lt;br/&gt;
I think granular lock management should be relatively simple since we have an option of using java.util.concurrent. CountDownLatch may be the right thing to use in this situation.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/CountDownLatch.html&quot;&gt;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/CountDownLatch.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Alternatively, this may be the right moment to evaluate Commons Pool or some other external pooling library and see if that would make our life somewhat simpler.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12552464" author="rolandw" created="Mon, 17 Dec 2007 16:40:08 +0000"  >Yes, I was hoping for java.util.concurrent too. Lock and Condition seem to fit the problem:&lt;br/&gt;
&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/locks/Condition.html&quot;&gt;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/locks/Condition.html&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/locks/Lock.html&quot;&gt;http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/locks/Lock.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
One lock for the pool, one condition for each thread. I&amp;#39;ll have to dig through the JavaDocs.&lt;br/&gt;
&lt;br/&gt;
cheers,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Roland&lt;br/&gt;
</comment>
                    <comment id="12554820" author="rolandw" created="Fri, 28 Dec 2007 17:27:38 +0000"  >Done. Thread.interrupt() is now used only during shutdown.&lt;br/&gt;
The code didn&amp;#39;t get prettier though. Plenty of cleanup pending.&lt;br/&gt;
</comment>
                    <comment id="12554822" author="rolandw" created="Fri, 28 Dec 2007 17:40:04 +0000"  >Thread.interrupt() shouldn&amp;#39;t be used during shutdown either.&lt;br/&gt;
Locks are not guaranteed to implement interrupts.&lt;br/&gt;
&lt;br/&gt;
Use regular signal plus a shutdown flag to detect that case,&lt;br/&gt;
throw dedicated shutdown exception instead of InterruptedException.&lt;br/&gt;
</comment>
                    <comment id="12554922" author="rolandw" created="Sat, 29 Dec 2007 14:41:04 +0000"  >Done.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12378912">HTTPCLIENT-692</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 17 Dec 2007 15:37:36 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133715</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>47467</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>