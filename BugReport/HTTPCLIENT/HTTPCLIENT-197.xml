<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:14:39 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-197/HTTPCLIENT-197.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-197] Problem with redirect on HEAD when (bad, naughty) server returns body content</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-197</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>I&amp;#39;ve been testing/using HttpClient 2.0a3 with Resin 2.1.9. I&amp;#39;ve found that when&lt;br/&gt;
using a HEAD request on a JSP, Resin returns the body content along with the&lt;br/&gt;
headers.&lt;br/&gt;
&lt;br/&gt;
In this case, something in the HttpClient breaks. Looking at the httpclient&lt;br/&gt;
logs, it looks like:&lt;br/&gt;
&lt;br/&gt;
1) HttpClient does a HEAD against the original URL&lt;br/&gt;
2) Resin returns valid status line and headers&lt;br/&gt;
3) HttpClient parses the headers and recognizes the redirect header&lt;br/&gt;
4) HttpClient does a HEAD against the new URL (from the Location header)&lt;br/&gt;
5) HttpMethodBase calls readStatusLine, which (eventually) calles readRawLine in&lt;br/&gt;
HttpConnection (which reads from the internal inputStream)&lt;br/&gt;
6) readRawLine returns the first line in the body from the original HEAD request&lt;br/&gt;
in (1).&lt;br/&gt;
&lt;br/&gt;
It looks like the original body content (in response to the first HEAD) is being&lt;br/&gt;
buffered somewhere, but I can&amp;#39;t figure out where.&lt;br/&gt;
&lt;br/&gt;
I know that this is invalid behavior on the server&amp;#39;s part, but I would like to&lt;br/&gt;
be able to recover from it.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
---- redir_test.jsp ----&lt;br/&gt;
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&lt;br/&gt;
&amp;lt;% &lt;br/&gt;
&amp;nbsp;&amp;nbsp;response.setStatus(response.SC_MOVED_TEMPORARILY);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;response.setHeader(&amp;quot;Location&amp;quot;, &amp;quot;redirect_pass.xml&amp;quot;);&lt;br/&gt;
%&amp;gt;&lt;br/&gt;
&amp;lt;some&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;lt;dummy&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;data attr=&amp;quot;yea, well&amp;quot;/&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;lt;/dummy&amp;gt;&lt;br/&gt;
&amp;lt;/some&amp;gt;</description>
                <environment>Operating System: All&lt;br/&gt;
Platform: PC</environment>
            <key id="12333756">HTTPCLIENT-197</key>
            <summary>Problem with redirect on HEAD when (bad, naughty) server returns body content</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="olegk">Oleg Kalnichevski</assignee>
                                <reporter username="philion@acmerocket.com">Paul Philion</reporter>
                        <labels>
                    </labels>
                <created>Wed, 23 Apr 2003 05:30:44 +0100</created>
                <updated>Sun, 22 Apr 2007 08:10:20 +0100</updated>
                    <resolved>Sun, 22 Apr 2007 08:10:20 +0100</resolved>
                            <version>2.0 Alpha 3</version>
                                <fixVersion>2.0 Beta 2</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12380276" author="olegk" created="Fri, 25 Apr 2003 15:32:13 +0100"  >Paul,&lt;br/&gt;
I have heard about this problem before but so far have been unable to reproduce&lt;br/&gt;
it. I&amp;#39;ll look into it one more time. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380277" author="philion@acmerocket.com" created="Fri, 25 Apr 2003 18:49:58 +0100"  >Oleg -&lt;br/&gt;
&lt;br/&gt;
I think it can be reproduced using Resin 2.1.9 as the JSP container. If you&lt;br/&gt;
would like I&amp;#39;ll try to get a JSP together.</comment>
                    <comment id="12380278" author="olegk" created="Fri, 25 Apr 2003 19:36:27 +0100"  >Paul,&lt;br/&gt;
&lt;br/&gt;
I am a bit reluctant to install Resin unless the bug can&amp;#39;t be reproduced using &lt;br/&gt;
other tools at my disposal. The test JSP will be highly appreciated&lt;br/&gt;
&lt;br/&gt;
Cheers&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380279" author="olegk" created="Mon, 5 May 2003 04:47:13 +0100"  >Created an attachment (id=6192)&lt;br/&gt;
Patch (take 1)&lt;br/&gt;
</comment>
                    <comment id="12380280" author="olegk" created="Mon, 5 May 2003 04:51:39 +0100"  >I guess that should fix the problem. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380281" author="becke@u.washington.edu" created="Mon, 5 May 2003 06:05:16 +0100"  >Oleg,&lt;br/&gt;
&lt;br/&gt;
I do not think this will fix the problem. I have no way of testing this so I may be completely wrong &lt;br/&gt;
though:)  It does not seem that the response (invalid though it may be) is ever being read.  I would &lt;br/&gt;
suggest adding the following instead of responseBodyConsumed():&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (getResponseBodyAsStream() != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getResponseBodyAsStream().close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12380282" author="olegk" created="Mon, 5 May 2003 17:50:55 +0100"  >Mike,&lt;br/&gt;
You are right. The patch does not fix the problem. On top of that, the solution &lt;br/&gt;
you proposed seems to be causing some side-effects as well. It looks like the &lt;br/&gt;
fix will require a bit more work than I initially thought. I am going to target &lt;br/&gt;
the resolution of this bug for beta-2, as this bug is no show-stopper for the &lt;br/&gt;
pending beta-1 release.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380283" author="eric@tibco.com" created="Mon, 5 May 2003 20:31:47 +0100"  >Part of the difficulty with the HEAD response is that it is _supposed_ to&lt;br/&gt;
indicate a content length if available, but not return any content.  If&lt;br/&gt;
HttpClient attempts to treat the HEAD method like any other, that would mean, of&lt;br/&gt;
course, that HttpClient would attempt to consume the indicated length of&lt;br/&gt;
content, even though in most cases it will never be there.  Badness ensues.&lt;br/&gt;
&lt;br/&gt;
If you want to recover from an HTTP server that erroneously returns content on a&lt;br/&gt;
HEAD request, it might be better to improve the code that scans for the HTTP&lt;br/&gt;
response line - for example by looking for &amp;quot;HTTP/1.0&amp;quot; or &amp;quot;HTTP/1.1&amp;quot; in the input&lt;br/&gt;
stream, rather than CR+LF+&amp;quot;HTTP&amp;quot;, which presupposes that a response with extra&lt;br/&gt;
data would be so kind as to terminate with a CR/LF.</comment>
                    <comment id="12380284" author="olegk" created="Mon, 5 May 2003 20:46:58 +0100"  >Absolutely correct. &lt;br/&gt;
&lt;br/&gt;
However, I believe there&amp;#39;s another approach possible. Since we already have a &lt;br/&gt;
PushbackInputStream wrapper around our socket input stream, anyway, I am &lt;br/&gt;
thinking about implementing a read ahead method which would allow me to peek &lt;br/&gt;
into the data that is about to come without really &amp;quot;reading&amp;quot; it (sort of).&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380285" author="oglueck" created="Mon, 5 May 2003 20:56:49 +0100"  >Do we actually want HttpClient to look for &amp;quot;HTTP/1.x&amp;quot; strings in the response?&lt;br/&gt;
Can we not just use the information given by the Headers to read/skip as many&lt;br/&gt;
bytes as necessary? (didn&amp;#39;t look at the code recently...)</comment>
                    <comment id="12380286" author="olegk" created="Mon, 5 May 2003 20:59:44 +0100"  >Odi, I am afraid chunk-encoded content unfortunately spoils this kind of &lt;br/&gt;
scheme. &lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380287" author="oglueck" created="Mon, 5 May 2003 21:44:58 +0100"  >Oleg, why? With chunked-TransferEncoding the end of the body is also&lt;br/&gt;
well-defined. The only difference to Content-Length is that you have to parse&lt;br/&gt;
the chunks and can not just skip a known number of bytes.</comment>
                    <comment id="12380288" author="olegk" created="Mon, 5 May 2003 22:14:00 +0100"  >Odi, &lt;br/&gt;
What I meant was that we couldn&amp;#39;t just blindly skip the number of bytes given &lt;br/&gt;
in the Content-Length header. I do agree that we should leverage the content &lt;br/&gt;
information given in the headers. Oleg</comment>
                    <comment id="12380289" author="oglueck" created="Mon, 5 May 2003 22:30:47 +0100"  >Ah I guess I understand the problem now. So forget about my comments.&lt;br/&gt;
&lt;br/&gt;
Well, actually it&amp;#39;s a little hard to try and fix this server problem on the&lt;br/&gt;
client side... I mean, if the server sends a body even though it is supposed not&lt;br/&gt;
to, then who on earth tells us *that* it sent this body. The real problem is, we&lt;br/&gt;
do not *when* this body will arrive.&lt;br/&gt;
&lt;br/&gt;
The body could (in theory) arrive a long time (HTTP/1.1 keep-alive connections)&lt;br/&gt;
after the headers were sent. We can not just wait for an indefinite time after&lt;br/&gt;
each HEAD request just because some response body might arrive unexpectedly, can we?&lt;br/&gt;
&lt;br/&gt;
As I see it, we *can not* recover from such a protocol violation on the same&lt;br/&gt;
connection - we just can not detect this situation well enough. We can only&lt;br/&gt;
detect that there is not HTTP/1.x response in the body and correctly assume taht&lt;br/&gt;
something went wrong. We can then only close the connection and retry with a&lt;br/&gt;
fresh one. </comment>
                    <comment id="12380290" author="olegk" created="Mon, 5 May 2003 22:39:23 +0100"  >Odi, it&amp;#39;ll never work 100%. However, we still wait a little while to see if &lt;br/&gt;
there&amp;#39;s anything coming our way to make sure that we can gracefuly recover in &lt;br/&gt;
most of the cases.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380291" author="olegk" created="Mon, 5 May 2003 23:47:21 +0100"  >Created an attachment (id=6212)&lt;br/&gt;
Patch (take 2)&lt;br/&gt;
</comment>
                    <comment id="12380292" author="olegk" created="Mon, 5 May 2003 23:54:41 +0100"  >Another attempt at fixing the problem. Minor ChunkedInputStream class clean-ups &lt;br/&gt;
that are related to the fix. Feedback welcome.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380293" author="oglueck" created="Tue, 6 May 2003 00:44:25 +0100"  >Maybe we should check for strict mode here and throw an exception in strict mode.</comment>
                    <comment id="12380294" author="olegk" created="Tue, 6 May 2003 01:13:10 +0100"  >That, of course, can be done.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380295" author="olegk" created="Tue, 6 May 2003 15:49:52 +0100"  >Created an attachment (id=6226)&lt;br/&gt;
Patch (take 3)&lt;br/&gt;
</comment>
                    <comment id="12380296" author="olegk" created="Tue, 6 May 2003 15:51:04 +0100"  >Odi&amp;#39;s suggestion has been implemented. Any additional comments, objections?&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380297" author="eric@tibco.com" created="Tue, 6 May 2003 21:23:01 +0100"  >I still think we&amp;#39;re chasing the wrong problem, here, and the patch makes me&lt;br/&gt;
uncomfortable on several fronts.&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t think that a GET or POST response with too much data should be treated&lt;br/&gt;
any differently than a HEAD response with too much data.  The scan for HTTP/1.1&lt;br/&gt;
exists for precisely that reason.  I have not personally tried the scenario that&lt;br/&gt;
the original poster indicated, but it seems no different in principle than a&lt;br/&gt;
server that tacks an extra CRLF pair at the end of a GET response - when we read&lt;br/&gt;
the next response we have to scan for the HTTP/1.1 line start.  The current code&lt;br/&gt;
might be a problem, though, if the previous response has extra data, but doesn&amp;#39;t&lt;br/&gt;
end with a CRLF.  I think THAT is the problem we should be solving.&lt;br/&gt;
&lt;br/&gt;
I looked through the patch, and as best I can tell, it changes the default&lt;br/&gt;
behavior of the HeadMethod to wait for 100ms for invalid content.  That seems&lt;br/&gt;
like a bad default, at a minimum.  My application uses HEAD in a number of&lt;br/&gt;
places, and having to revisit all my code where HEAD is invoked just to solve a&lt;br/&gt;
problem I never encounter seems weird to me.  And if I miss a case, I get an&lt;br/&gt;
inexplicably performance penalty.  Ugh.  Maybe I read the code wrong though.&lt;br/&gt;
&lt;br/&gt;
testNoncompliantHeadStrickMode - &amp;quot;strict&amp;quot; is misspelled.&lt;br/&gt;
&lt;br/&gt;
I like the test cases you provided!  It is certainly a clever way to reproduce&lt;br/&gt;
the problem.</comment>
                    <comment id="12380298" author="olegk" created="Tue, 6 May 2003 22:04:13 +0100"  >Eric,&lt;br/&gt;
I see your point. However, this is where we differ quite radically: it is one &lt;br/&gt;
story to skip a few blank lines mistakenly appended to the response body, and &lt;br/&gt;
it is an entirely different story to scan an arbitrary sequence of characters &lt;br/&gt;
for a rather common pattern such as ^HTTP. I personally find it fairly &lt;br/&gt;
pointless due to the high probability of erroneous results. Even if we attempt &lt;br/&gt;
to be a bit more creating about pattern matching mistakes are still quite &lt;br/&gt;
likely. It&amp;#39;s just not worth the trouble (imho) since we can&amp;#39;t make it work 100%&lt;br/&gt;
&lt;br/&gt;
On the other hand, my intention was to address only a very specific problem &lt;br/&gt;
where we can have significantly more certainty about being able to gracefully &lt;br/&gt;
recover from most of non-compliant responses. &lt;br/&gt;
&lt;br/&gt;
I do admit that the price in terms of performance degradation is high. &lt;br/&gt;
Therefore, I provided an option to disable the check. Maybe the check should be &lt;br/&gt;
off by default, as the overwhelming majority of HTTP servers are spec compliant &lt;br/&gt;
in this particular regard?&lt;br/&gt;
&lt;br/&gt;
I apologize for spelling mistakes&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380299" author="eric@tibco.com" created="Tue, 6 May 2003 23:49:29 +0100"  >Well, I definitely think the wait should be avoided by default, otherwise you&amp;#39;ve&lt;br/&gt;
defeated most of the client value of the HEAD method as a less &amp;quot;expensive&amp;quot;&lt;br/&gt;
alternative to GET.&lt;br/&gt;
&lt;br/&gt;
Since the original poster knows that he is going against a non-compliant server,&lt;br/&gt;
is it more appropriate to simply work around it there?  Perhaps not, or they&lt;br/&gt;
wouldn&amp;#39;t have posted the bug.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m torn about the pattern matching problem.  The only time looking for byte&lt;br/&gt;
level HTTP/1.1 would generate problems is if server is genuinely misbehaving. &lt;br/&gt;
The code we have now consumes the entire response even if the caller doesn&amp;#39;t&lt;br/&gt;
read it all, solving many of the potential response alignment issues.  Thus in&lt;br/&gt;
most cases (except this one), my experience suggests we only have to worry about&lt;br/&gt;
the occassional stray CRLF pair. These wouldn&amp;#39;t cause a problem with my&lt;br/&gt;
alternative.  Of course the problem with this particular case is that you could&lt;br/&gt;
easily imagine the server returning:&lt;br/&gt;
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;HTTP/1.1 301 Moved permanently&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;Ask server admin for&lt;br/&gt;
details.&amp;lt;/p&amp;gt;&lt;br/&gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;br/&gt;
&lt;br/&gt;
Which would cause the problem that I&amp;#39;m guessing the original poster saw if there&lt;br/&gt;
was no CRLF after the &amp;lt;/html&amp;gt; tag.  Yet if you did a byte level search for&lt;br/&gt;
HTTP/1.1 as I suggest, it would still fail, as my approach would &amp;quot;find&amp;quot; the&lt;br/&gt;
first occurrance and try to read the header prematurely.  In the absence of a&lt;br/&gt;
wire log, and thinking about the potentially diabolically misbehaved servers, I&lt;br/&gt;
concede that your approach might be better.&lt;br/&gt;
&lt;br/&gt;
Your change to HttpMethodBase puzzled me for a while, as I was worried that it&lt;br/&gt;
might change the performance.  Now that I look at it again, it makes more sense,&lt;br/&gt;
and it might prevent an exception for badly behaved servers.  Might this be a&lt;br/&gt;
behavior change that should be aware of &amp;quot;strict&amp;quot; mode, though?  Except wait - I&lt;br/&gt;
just did a search for &amp;quot;isStrictMode()&amp;quot; uses and I didn&amp;#39;t find any, except in&lt;br/&gt;
your new patch.  Did this sneak in while I wasn&amp;#39;t watching?&lt;br/&gt;
&lt;br/&gt;
Sorry about the rambling, but I&amp;#39;ve been puzzling through this one, and you seem&lt;br/&gt;
to be quite a bit ahead of my thinking.&lt;br/&gt;
</comment>
                    <comment id="12380300" author="oglueck" created="Wed, 7 May 2003 00:31:56 +0100"  >Eric,&lt;br/&gt;
&lt;br/&gt;
The status line does not have to be preceded by a CRLF at all. The only thing&lt;br/&gt;
that defines the end of the response body is the Content-Length Header or the&lt;br/&gt;
ending chunk if Chunked Transfer Ecoding is used. The HTTP response body is to&lt;br/&gt;
be treated as a binary entity and should not be parsed (for CRLF) by HTTP&lt;br/&gt;
servers nor clients.</comment>
                    <comment id="12380301" author="olegk" created="Wed, 7 May 2003 01:28:21 +0100"  >Eric,&lt;br/&gt;
Both approaches in question have their advantages and disadvantages. None of &lt;br/&gt;
them is a panacea and is guaranteed to be able to recover gracefully in all &lt;br/&gt;
possible scenarios. &lt;br/&gt;
&lt;br/&gt;
This, of course, is subjective but I just do not like the idea of scanning &lt;br/&gt;
through the response body that may contain any arbitrary sequence of bytes. The &lt;br/&gt;
use of header information is by no means a more effective method that the one &lt;br/&gt;
you suggest, but it does appear a more proper, more compliant approach (at &lt;br/&gt;
least to me). If a particular server sends just an arbitrary stream of garbage &lt;br/&gt;
that has no correlation with information in the header, I do not think we &lt;br/&gt;
should go at extraordinary lengths to recover from this kind of HTTP spec &lt;br/&gt;
abuse. &lt;br/&gt;
&lt;br/&gt;
As to those modifications I made to HttpMethodBase they are (intended to be) &lt;br/&gt;
mere clean-ups. They should have no performance impact of what so ever (or so &lt;br/&gt;
I&amp;#39;d like to hope) I just moved the check for improperly terminated empty chunk-&lt;br/&gt;
encoded body from the ChunkedInputStream class to HttpMethodBase where we have &lt;br/&gt;
more information about the execution environment and therefore are in a better &lt;br/&gt;
position to take appropriate corrective measures. &lt;br/&gt;
&lt;br/&gt;
I agree this check may be inappropriate when executing in the strict mode. &lt;br/&gt;
Unfortunately the RFC is a bit vague on whether an empty chunk-encoded response &lt;br/&gt;
body must have a closing chunk or may be omitted altogether. There are &lt;br/&gt;
conflicting opinions. For instance, the company that produces the IIS web &lt;br/&gt;
server seems to subscribe to the latter point of view. &lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
</comment>
                    <comment id="12380302" author="olegk" created="Wed, 7 May 2003 01:29:12 +0100"  >Created an attachment (id=6237)&lt;br/&gt;
Patch (take 4)&lt;br/&gt;
</comment>
                    <comment id="12380303" author="oglueck" created="Wed, 7 May 2003 15:10:53 +0100"  >Let me recall the two main user groups of HttpClient:&lt;br/&gt;
&lt;br/&gt;
1. People who want to transfer data: They just want it to work flawlessly with&lt;br/&gt;
the most common servers (Apache httpd, Tomcat, IIS, Squid, most popular app&lt;br/&gt;
servers and proxies). They will most reasonably run HttpClient in non-strict mode.&lt;br/&gt;
&lt;br/&gt;
2. People who want to test servers for standards compliance. They will most&lt;br/&gt;
reasonably run HttpClient in strict mode.&lt;br/&gt;
&lt;br/&gt;
We are *not* supposed to make a client that works with everything out there that&lt;br/&gt;
calls itself a Http server. &lt;br/&gt;
For group 1 it&amp;#39;s enough if it works for (the big) servers that are usually&lt;br/&gt;
regarded as standards compliant. &lt;br/&gt;
For group 2 it&amp;#39;s enough if HttpClient notifies them (exceptions, logs,&lt;br/&gt;
misbehaviour) that their implementation is not good. Note that for group 2 we do&lt;br/&gt;
not have to be very explicit or verbose about what went wrong. It&amp;#39;s sufficient&lt;br/&gt;
that they can actually notice an error.&lt;br/&gt;
&lt;br/&gt;
So in my humble opinion we should refrain from building ugly work-arounds for&lt;br/&gt;
gross violations of the Http standard.</comment>
                    <comment id="12380304" author="olegk" created="Wed, 7 May 2003 19:05:05 +0100"  >Created an attachment (id=6256)&lt;br/&gt;
Patch (take 5)&lt;br/&gt;
</comment>
                    <comment id="12380305" author="olegk" created="Wed, 7 May 2003 19:20:09 +0100"  >Some minor tweaks regarding HTTP spec compliance in the strict mode. &lt;br/&gt;
&lt;br/&gt;
Summary of changes:&lt;br/&gt;
&lt;br/&gt;
- Minor ChunkedInputStream class clean-ups.&lt;br/&gt;
- HttpExcption is thrown in the strict mode when chunk-encoded body has been &lt;br/&gt;
declared with &amp;#39;Transfer-Encoding&amp;#39; header but not sent. &lt;br/&gt;
- Per default HttpClient does not check for presence of HTTP HEAD response &lt;br/&gt;
body. Such check can be optionally activated on an individual HEAD method when &lt;br/&gt;
necessary. In the strict mode presence of a content body in response to HTTP &lt;br/&gt;
HEAD request will cause an HttpException to be thrown.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380306" author="becke@u.washington.edu" created="Wed, 7 May 2003 20:44:22 +0100"  >In general it looks good to me.  Just a few comments.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- I haven&amp;#39;t tried this, but I wonder if the isResponseAvailable() calls will&lt;br/&gt;
cause problems with HTTPS in pre 1.4 JVMs ala the isStale() problem.&lt;br/&gt;
&amp;nbsp;- There seems to be tab characters in HeadMethod.  I am guessing the&lt;br/&gt;
bodyCheckTimeout accessor methods were autogenerated with tabs by Eclipse.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12380307" author="olegk" created="Wed, 7 May 2003 22:14:31 +0100"  >Mike,&lt;br/&gt;
I was also concerned about possible side effects on HTTPS connections. I have &lt;br/&gt;
run a few really nasty tests in order to simulate the potential problem. &lt;br/&gt;
Everything seems quite all right at least in my usual development environment. &lt;br/&gt;
I have tweaked RequestBodyServlet to pause for 5 seconds prior to sending out &lt;br/&gt;
the response body to the client. I hit the server over SSL with two consecutive &lt;br/&gt;
request: a GET followed by a POST. The connection was declared stale after the &lt;br/&gt;
GET and re-opened. POST method did pause for approximately 5 seconds before the &lt;br/&gt;
chunk-encoded body started arriving. At least as far I can tell things look ok &lt;br/&gt;
to me&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12380308" author="olegk" created="Fri, 9 May 2003 01:36:43 +0100"  >Patch committed.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                </comments>
                    <attachments>
                    <attachment id="12326830" name="ASF.LICENSE.NOT.GRANTED--head.patch" size="731" author="olegk" created="Mon, 5 May 2003 04:47:13 +0100" />
                    <attachment id="12326834" name="ASF.LICENSE.NOT.GRANTED--readahead.patch" size="21466" author="olegk" created="Wed, 7 May 2003 19:05:05 +0100" />
                    <attachment id="12326833" name="ASF.LICENSE.NOT.GRANTED--readahead.patch" size="21174" author="olegk" created="Wed, 7 May 2003 01:29:12 +0100" />
                    <attachment id="12326832" name="ASF.LICENSE.NOT.GRANTED--readahead.patch" size="21741" author="olegk" created="Tue, 6 May 2003 15:49:52 +0100" />
                    <attachment id="12326831" name="ASF.LICENSE.NOT.GRANTED--readahead.patch" size="20655" author="olegk" created="Mon, 5 May 2003 23:47:21 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                <customfieldname>Bugzilla Id</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>19235</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 25 Apr 2003 14:32:13 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>133251</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>189190</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>