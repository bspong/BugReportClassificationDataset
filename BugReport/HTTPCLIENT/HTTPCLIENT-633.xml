<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:19:24 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-633/HTTPCLIENT-633.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-633] MultiThreadedHttpConnectionManager does not properly respond to thread interrupts</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-633</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>MultiThreadedHttpConnectionManager uses interrupts to notify waiting threads when a connection is ready for them. Issues arise if the threads are interrupted by someone else while they are still waiting on a thread, because doGetConnection does not remove the threads from the queue of waiting threads when they are interrupted:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;connectionPool.wait(timeToWait);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// we have not been interrupted so we need to remove ourselves from the &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// wait queue&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hostPool.waitingThreads.remove(waitingThread);                        connectionPool.waitingThreads.remove(waitingThread);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// do nothing                    } finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (useTimeout) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;endWait = System.currentTimeMillis();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timeToWait -= (endWait - startWait);                        }                    }&lt;br/&gt;
&lt;br/&gt;
Under ordinary circumstances, the queue maintenance is done by the notifyWaitingThread method. However, if the thread is interrupted by any other part of the system, it will (1) not actually be released, since the loop in doGetConnection will force it back to the wait, and (2) will be added the waiting thread to the queue repeatedly, which basically means that the thread will eventually receive the interrupt from notifyWaitingThread at some later point, when it is no longer actually waiting for a connection.&lt;br/&gt;
&lt;br/&gt;
This code could probably be re-architected to make it less error-prone, but the fundamental issue seems to be the use of interrupts to signal waiting threads, as opposed to something like a notify. </description>
                <environment></environment>
            <key id="12362809">HTTPCLIENT-633</key>
            <summary>MultiThreadedHttpConnectionManager does not properly respond to thread interrupts</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mbecke">Michael Becke</assignee>
                                <reporter username="johnnyb">John Goodwin</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Feb 2007 16:27:19 +0000</created>
                <updated>Thu, 21 Jul 2011 20:52:52 +0100</updated>
                    <resolved>Tue, 20 Feb 2007 14:59:56 +0000</resolved>
                            <version>3.1 Beta 1</version>
                                <fixVersion>3.1 RC1</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12473237" author="mbecke" created="Wed, 14 Feb 2007 22:53:57 +0000"  >Hi John,&lt;br/&gt;
&lt;br/&gt;
I would agree, using object notification is probably a cleaner way to do this.  I&amp;#39;m not sure why I did it this way originally, simplicity perhaps.  My question is if interrupting a waiting thread outside of the connection manager is something we want to support.  If we did, would we just throw a ConnectionPoolTimeoutException when it occurs?   This would seem to break the contract of doGetConnection.  I&amp;#39;m not sure how we will handle HttpConnection getConnection(HostConfiguration hostConfiguration) without an API change.&lt;br/&gt;
&lt;br/&gt;
Assuming we did want to change this, we would need to wait on the HostConnectionPool instead of the ConnectionPool.  Doing this brings up a couple of potential issues, but I think they&amp;#39;re all fixable.  In particular:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- We would have two layers of synchronization to go through, ConnectionPool and HostConnectionPool, and would need to handle this carefully to avoid potential dead-locks, race conditions, etc.  &lt;br/&gt;
&amp;nbsp;- We lose the FIFO nature currently guaranteed to waiting threads.  Object.notify() makes no guarantees about which thread will be woken first.&lt;br/&gt;
&lt;br/&gt;
To get this into 3.1 we will definitely want to have an RC release with this change first.  Given the complexity of synchronization I would want to give it some time for testing.&lt;br/&gt;
&lt;br/&gt;
Any other thoughts?&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12473624" author="mbecke" created="Fri, 16 Feb 2007 06:14:55 +0000"  >I did a little more digging on this last night and have narrowed down our choices for correctly responding to external interrupts:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- Change from using interrupt to ConnectionPool.wait() and ConnectionPool.notifyAll().  This would allow us to correctly identify interrupts and handle them appropriately.  There are two downsides however.  1) We lose the FIFO nature of the waiting threads.  2) We significantly reduce the performance of the ConnectionPool since all threads would have to be notified on any connection release.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- Switch to nested locking, one for the connection pool and another for the individual host pools.  This would allow for finer grained control of waiting threads.  Again there are downsides.  FIFO would be lost.  Also, given the inherent limitations of Java monitors the only way to correctly implement this would be with mutexes.  Since we&amp;#39;re not using 1.4 we would have to implement these ourselves.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- The third option is to create a way to determine who interrupted the waiting thread: the connection pool or some other thread.  We could then cleanup appropriately and re-throw the InterruptedException if we want.  The only issue here is that I don&amp;#39;t see a foolproof way to do this.  If a waiting thread were interrupted by the connection pool and then again by an external thread before it resumed processing it would not be able to accurately tell who interrupted.  I&amp;#39;m assuming this is a fairly rare occurrence, but it could technically still happen.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- The fourth option is to ignore external interrupts and fix the bug where they corrupt the internal state of the ConnectionManager.&lt;br/&gt;
&lt;br/&gt;
At this point my preference is for either 3 or 4.  Does anyone see a better way to go?&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12473629" author="mbecke" created="Fri, 16 Feb 2007 06:40:31 +0000"  >Here&amp;#39;s a quick patch to resolve the bug.  It doesn&amp;#39;t address the question of what to do about re-throwing the external interruption, but that&amp;#39;s more of a question of if/how we want to make an API change.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12473728" author="johnnyb" created="Fri, 16 Feb 2007 15:26:53 +0000"  >Hi Michael,&lt;br/&gt;
&lt;br/&gt;
I appreciate the quick response and follow-up. In the longer term, I, at least, would lobby for a re-throw of the interrupt. My application is a high-load, highly concurrent system, where we need the ability to interrupt threads if they have been working too long. (NB: a HUGE help to us would be an HttpClient that uses NIO, but I realize that&amp;#39;s pretty out there.) &lt;br/&gt;
&lt;br/&gt;
I agree, however, that the FIFO feature is quite desireable. You could use a fair lock, but that obviously has negative performance side-effects (perhaps FIFO could be optional?), and is another component that would have to be built from scratch unless you mandate Java 5.0+.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
John</comment>
                    <comment id="12473731" author="olegk" created="Fri, 16 Feb 2007 15:35:02 +0000"  >Hi Mike,&lt;br/&gt;
I think this is as good as it gets for HttpClient 3.1. As far as InterruptedException caused by an external interrupt is concerned we can&amp;#39;t simply re-throw it. I see two options here. Both are quite ugly, so alternative ideas are very welcome&lt;br/&gt;
(1) Quietly shutdown the connection manager. At the end of day this is likely to be the main reason for interrupting the connection manager&amp;#39;s thread in the first place.&lt;br/&gt;
(2) Re-throw InterruptedException as an exception derived from ConnectionPoolTimeoutException (yes, I know)&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12473732" author="johnnyb" created="Fri, 16 Feb 2007 15:38:52 +0000"  >I would vote against option 1. The connection manager has a shutdown method if that is the desired result. Interrupting a single thread might be done simple for throughput maintenance.</comment>
                    <comment id="12473740" author="rolandw" created="Fri, 16 Feb 2007 16:11:55 +0000"  >Hi all,&lt;br/&gt;
&lt;br/&gt;
one more alternative, which Mike already mentioned on the dev list:&lt;br/&gt;
(3) Re-throw InterruptedException as a RuntimeException, for example IllegalThreadStateException&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also for re-throwing, and a RuntimeException would make sure that this doesn&amp;#39;t trigger application code explicitly handling the ConnectionManagerTimeoutException exception. Yes it&amp;#39;s an API change, but one that only affects the application in situations where MTHCM would be screwing up. Applications that work correctly now will work correctly despite the change, and applications that fail because of the RuntimeException will be better off than before, where they would fail in some unpredictable way because of the corrupted state in MTHCM.&lt;br/&gt;
&lt;br/&gt;
That we can&amp;#39;t reliably tell whether there is an external InterruptedException or not can&amp;#39;t be helped. If the thread was interrupted just after getting the connection, it would simply return with the connection and have it&amp;#39;s interrupted flag set. I don&amp;#39;t see a problem with keeping this behavior if two interruptions occur in quick succession.&lt;br/&gt;
&lt;br/&gt;
cheers,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Roland&lt;br/&gt;
</comment>
                    <comment id="12473883" author="mbecke" created="Sat, 17 Feb 2007 06:40:14 +0000"  >This one fixes a small bug in the previous patch, adds the IllegalThreadStateException, and includes a test case.  If there are no objections I will apply this in the next few days.&lt;br/&gt;
&lt;br/&gt;
Mike</comment>
                    <comment id="12473927" author="olegk" created="Sat, 17 Feb 2007 13:18:59 +0000"  >Looks good to me&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="12473940" author="rolandw" created="Sat, 17 Feb 2007 16:54:29 +0000"  >Hi Mike,&lt;br/&gt;
&lt;br/&gt;
please declare the &amp;#39;interruptedByConnectionPool&amp;#39; attribute volatile. Otherwise, it looks like a straightforward fix for the problem.&lt;br/&gt;
&lt;br/&gt;
cheers,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Roland&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12473947" author="rolandw" created="Sat, 17 Feb 2007 18:01:21 +0000"  >HttpClient is the only component existing in 3.1.</comment>
                    <comment id="12474461" author="mbecke" created="Tue, 20 Feb 2007 14:59:56 +0000"  >Patch applied</comment>
                    <comment id="13069161" author="isilva" created="Thu, 21 Jul 2011 20:52:52 +0100"  >Hi group, I need to know what problem Can I have with this extract&lt;br/&gt;
org/apache/commons/httpclient/MultiThreadedHttpConnectionManager$Connect&lt;br/&gt;
&lt;a href=&apos;mailto:ionPool@0x00000000408C3638&apos;&gt;ionPool@0x00000000408C3638&lt;/a&gt;/0x00000000408C3644: &amp;lt;unowned&amp;gt;                &lt;br/&gt;
Waiting to be notified:                                                 &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 0&amp;quot; (0x0000000031B71C00)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 1&amp;quot; (0x0000000031AE6700)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 2&amp;quot; (0x0000000031E22900)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 3&amp;quot; (0x000000003202AF00)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 5&amp;quot; (0x0000000031CCDB00)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 6&amp;quot; (0x0000000032294B00)                              &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;..................                                                 &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 55&amp;quot; (0x0000000032620000)                           &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 56&amp;quot; (0x000000003266F200)                           &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 58&amp;quot; (0x000000003267CE00)                           &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;WebContainer : 59&amp;quot; (0x000000003267DE00)                           &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;quot;WebContainer : 0&amp;quot; J9VMThread:0x0000000031B71C00,                       &lt;br/&gt;
j9thread_t:0x000000011A85AD40,                                          &lt;br/&gt;
java/lang/Object.wait(Native Method)                                    &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
java/lang/Object.wait(Object.java:196(Compiled Code))                   &lt;br/&gt;
org/apache/commons/httpclient/MultiThreadedHttpConnectionManager.doGetConnectin                                                                 &lt;br/&gt;
org/apache/commons/httpclient/MultiThreadedHttpConnectionManager.getConn&lt;br/&gt;
org/apache/commons/httpclient/HttpMethodDirector.executeMethod(HttpMetho&lt;br/&gt;
org/apache/commons/httpclient/HttpClient.executeMethod(HttpClient.java:3&lt;br/&gt;
org/apache/commons/httpclient/HttpClient.executeMethod(HttpClient.java:3&lt;br/&gt;
com/citibank/latam/sgway/service/HttpConnectorImpl.doPost(HttpConnectorI&lt;br/&gt;
com/citibank/latam/sgway/service/HttpConnectorImpl.doPost(HttpConnectorI&lt;br/&gt;
com/citibank/latam/sgway/service/LegacySgConnector.doPost(LegacySgConnec&lt;br/&gt;
com/citibank/latam/sgway/service/LegacySgConnector.authenticateFull(Lega&lt;br/&gt;
com/citi/acam/session/impl/SGTokenGenerator.getToken(SGTokenGenerator.ja&lt;br/&gt;
com/citi/acam/session/ACAMCredential.&amp;lt;init&amp;gt;(ACAMCredential.java:24(Compi&lt;br/&gt;
com/citi/common/transaction/web/CtrlLogin.actionSetLogin(CtrlLogin.java:&lt;br/&gt;
com/citi/common/transaction/web/CtrlLogin.doPost(CtrlLogin.java:67(Compi&lt;br/&gt;
&lt;br/&gt;
Can you help me please? Can be MultiThreadedHttpConnectionManager don&amp;#39;t properly respond to thread interrupts?&lt;br/&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12351420" name="mthcm-interruption.patch" size="6752" author="mbecke" created="Sat, 17 Feb 2007 06:40:14 +0000" />
                    <attachment id="12351319" name="mthcm-interruption.patch" size="3694" author="mbecke" created="Fri, 16 Feb 2007 06:40:31 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 14 Feb 2007 22:53:57 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>67233</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>46999</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>