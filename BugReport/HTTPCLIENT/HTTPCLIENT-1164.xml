<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Mon Jul 08 06:13:31 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HTTPCLIENT-1164/HTTPCLIENT-1164.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[HTTPCLIENT-1164] Compressed entities are not being cached properly</title>
                <link>https://issues.apache.org/jira/browse/HTTPCLIENT-1164</link>
                <project id="12310360" key="HTTPCLIENT">HttpComponents HttpClient</project>
                        <description>org.apache.http.impl.client.cache.CacheValidityPolicy.contentLengthHeaderMatchesActualLength() returns false for entities decompressed by ContentEncodingHttpClient, because the length of decompressed entity stored in cache will be different from the length specified in the response header.&lt;br/&gt;
Consequently, gzipped/deflated entities will never be satisfied from the cache.&lt;br/&gt;
&lt;br/&gt;
Proposed fix: introduce new field in HttpCacheEntry() - actualContentLength, and populate it with the actual content length rigth before the cache entry is stored in the cache. Change the org.apache.http.impl.client.cache.CacheValidityPolicy.contentLengthHeaderMatchesActualLength() method to compare&lt;br/&gt;
entry.getResource().length() with entry.getActualContentLength()&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12542499">HTTPCLIENT-1164</key>
            <summary>Compressed entities are not being cached properly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jonm">Jon Moore</assignee>
                                <reporter username="mtripathi">Manish Tripathi</reporter>
                        <labels>
                    </labels>
                <created>Tue, 14 Feb 2012 09:19:41 +0000</created>
                <updated>Sun, 13 May 2012 15:20:19 +0100</updated>
                    <resolved>Fri, 16 Mar 2012 15:02:08 +0000</resolved>
                            <version>Snapshot</version>
                                <fixVersion>4.2 Final</fixVersion>
                                <component>HttpClient</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13207762" author="jonm" created="Tue, 14 Feb 2012 15:01:13 +0000"  >This definitely deserves some thought, although the proposed fix would break backwards compatibility by modifying HttpCacheEntry, so we probably want to find a different solution.&lt;br/&gt;
</comment>
                    <comment id="13221621" author="jonm" created="Sat, 3 Mar 2012 16:06:32 +0000"  >Ok, I think the right solution here is the following:&lt;br/&gt;
&lt;br/&gt;
1. Turn the ContentEncodingHttpClient into a decorator, taking a backend HttpClient as a constructor dependency. Backwards compatibility can be achieved by supplying a DefaultHttpClient if one is not provided.&lt;br/&gt;
2. This now permits users to use both bits of functionality by wiring up as ContentEncodingHttpClient -&amp;gt; CachingHttpClient -&amp;gt; DefaultHttpClient.&lt;br/&gt;
&lt;br/&gt;
Thoughts?&lt;br/&gt;
</comment>
                    <comment id="13221658" author="jonm" created="Sat, 3 Mar 2012 18:21:07 +0000"  >Ugh, didn&amp;#39;t realize the ContentEncodingHttpClient extended DefaultHttpClient. Still researching.&lt;br/&gt;
</comment>
                    <comment id="13221660" author="jonm" created="Sat, 3 Mar 2012 18:31:25 +0000"  >Here&amp;#39;s another thought: perhaps the DecompressingEntity should remove the Content-Length header if it exists? It already returns -1 for getContentLength() as it accurately indicates the length of decompressed body is unknown. I think if we did this, then you could successfully plug a ContentEncodingHttpClient as the backend for the CachingHttpClient. Since it would appear that the DecompressingEntity is modifying the response to keep it semantically unchanged (e.g. by removing Content-Encoding as well), this might actually be what we want.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13221675" author="olegk" created="Sat, 3 Mar 2012 19:24:26 +0000"  >&amp;gt; Ugh, didn&amp;#39;t realize the ContentEncodingHttpClient extended DefaultHttpClient. Still researching. &lt;br/&gt;
&lt;br/&gt;
ContentEncodingHttpClient can be deprecated if necessary.&lt;br/&gt;
&lt;br/&gt;
Making DecompressingEntity remove Content-Length header also sounds acceptable. &lt;br/&gt;
&lt;br/&gt;
See what makes more sense.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="13221678" author="mtripathi" created="Sat, 3 Mar 2012 19:33:26 +0000"  >Removing Content-Length is basically what I did as a quick hack to solve the issue on my end. However, I believe that it is not at all a perfect solution. The reason being that without Content-Length header it would be impossible to perform entity validity checks. For instance, if the entity was partially downloaded and decompressor was able to decompress partial content successfully, the cache would return partial (=invalid) content to the requesting code. Right now this problem is mitigated by comparing Content-Length value to actual length of the entity.&lt;br/&gt;
&lt;br/&gt;
I personally like the first idea much better (to make ContentEncodingHttpClient a wrapper around HttpClient). Apart from being a solution to this issue, such approach is conceptually more correct than extending DefaultHttpClient, in my opinion. I must say that this idea also crossed my mind, but when I looked at the implementation of ContentEncodingHttpClient and how deeply it integrates with implementation of various aspects of the client, I dropped the idea. Though I still believe it is the best aproach.</comment>
                    <comment id="13221852" author="jonm" created="Sun, 4 Mar 2012 11:17:11 +0000"  >I think the issue is that you can&amp;#39;t have length checks if the ContentEncodingHttpClient (however it is implemented) is &amp;quot;under&amp;quot; the CachingHttpClient; rather you want the ContentEncodingHttpClient to sit &amp;quot;on top of&amp;quot; the CachingHttpClient. So I think I&amp;#39;m going to go with the following:&lt;br/&gt;
&lt;br/&gt;
1. Remove Content-Length at DecompressingEntity.&lt;br/&gt;
2. Implement a new decorator equivalent to ContentEncodingHttpClient.&lt;br/&gt;
3. Deprecate the existing ContentEncodingHttpClient.&lt;br/&gt;
</comment>
                    <comment id="13221860" author="olegk" created="Sun, 4 Mar 2012 11:53:28 +0000"  >Jon,&lt;br/&gt;
&lt;br/&gt;
I just realized that absence of the Content-Length header is likely to have an impact on DefaultConnectionReuseStrategy. Is there a chance we could keep the Content-Length header? Alternatively we will also have to provide a custom ConnectionReuseStrategy implementation for ContentEncodingHttpClient or its equivalent.&lt;br/&gt;
&lt;br/&gt;
Oleg</comment>
                    <comment id="13221897" author="jonm" created="Sun, 4 Mar 2012 14:10:23 +0000"  >Ok, in that case, I think we can just do:&lt;br/&gt;
1. Implement new CompressionDecorator.&lt;br/&gt;
2. Deprecate ContentEncodingHttpClient.&lt;br/&gt;
3. Document known behavior and provide recommendations around compression + caching.&lt;br/&gt;
</comment>
                    <comment id="13230302" author="jonm" created="Thu, 15 Mar 2012 17:05:45 +0000"  >Ok, I just checked a CompressionDecorator into trunk that can be wired in either under or over the CachingHttpClient. Ended up not needing to change the existing ContentEncodingHttpClient, although I did reuse the request and response interceptors. The decorator removes the Content-Length header if it uncompresses things; will go back to verify the impact on DefaultConnectionReuseStrategy.&lt;br/&gt;
</comment>
                    <comment id="13230348" author="jonm" created="Thu, 15 Mar 2012 17:38:12 +0000"  >@Oleg: I just wired up the CompressionDecorator around a DefaultHttpClient and the connections seem to be reused just fine, per wire logging + context logging. The DefaultConnectionKeepAliveStrategy doesn&amp;#39;t seem to look at the Content-Length header. Am I missing something?&lt;br/&gt;
</comment>
                    <comment id="13230366" author="jonm" created="Thu, 15 Mar 2012 17:55:24 +0000"  >This should clearly go into 4.2, at least. Oleg, what&amp;#39;s your thought on backporting? Do we have plans for a 4.1.4 release anytime soon (or sooner than 4.2 GA)? I think this is technically not a bug, per se, because everything still works correctly HTTP-wise. I&amp;#39;ll default to backporting it next week unless folks have opinions it&amp;#39;s not worth it.&lt;br/&gt;
</comment>
                    <comment id="13231174" author="olegk" created="Fri, 16 Mar 2012 13:41:35 +0000"  >@Jon:&lt;br/&gt;
&amp;gt; I just wired up the CompressionDecorator around a DefaultHttpClient and the connections seem to be reused just fine, per wire logging + context logging. &lt;br/&gt;
&amp;gt; The DefaultConnectionKeepAliveStrategy doesn&amp;#39;t seem to look at the Content-Length header. Am I missing something? &lt;br/&gt;
&lt;br/&gt;
Indeed, DefaultConnectionKeepAliveStrategy does not look at the Content-Length header, but the DefaultConnectionReuseStrategy does. The strategy considers connections reusable only if the last message length is delineated either with Content-Length or Transfer-Encoding header.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://hc.apache.org/httpcomponents-core-ga/httpcore/xref-test/org/apache/http/impl/TestDefaultConnectionReuseStrategy.html#89&quot;&gt;http://hc.apache.org/httpcomponents-core-ga/httpcore/xref-test/org/apache/http/impl/TestDefaultConnectionReuseStrategy.html#89&lt;/a&gt; &lt;br/&gt;
&lt;br/&gt;
However, we are all good, since the headers are removed by the decorator, and not by the protocol interceptor (before ConnectionReuseStrategy is called), as I initially assumed. The decorator correctly updates the message after the backend has already completed its execution.   &lt;br/&gt;
&lt;br/&gt;
Great job!&lt;br/&gt;
&lt;br/&gt;
Oleg&lt;br/&gt;
&lt;br/&gt;
PS: I do not think we should backport this feature. There unlikely to be any more releases from the 4.1.x branch. The stable branch should be for critical bug fixes only.</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 14 Feb 2012 15:01:13 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>227786</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>46833</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>