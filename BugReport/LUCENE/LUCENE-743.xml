<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:20:15 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-743/LUCENE-743.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-743] IndexReader.reopen()</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-743</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is Robert Engels&apos; implementation of IndexReader.reopen() functionality, as a set of 3 new classes (this was easier for him to implement, but should probably be folded into the core, if this looks good).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12358344">LUCENE-743</key>
            <summary>IndexReader.reopen()</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="michaelbusch">Michael Busch</assignee>
                                <reporter username="otis">Otis Gospodnetic</reporter>
                        <labels>
                    </labels>
                <created>Mon, 11 Dec 2006 22:46:21 +0000</created>
                <updated>Thu, 2 May 2013 03:29:08 +0100</updated>
                    <resolved>Sat, 17 Nov 2007 21:38:16 +0000</resolved>
                                            <fixVersion>2.3</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>3</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12457502" author="otis" created="Mon, 11 Dec 2006 22:47:20 +0000"  >&lt;p&gt;In a direct email to me, Robert said: &quot;All of the files can be prepended with the ASL.&quot;&lt;/p&gt;</comment>
                    <comment id="12457504" author="rengels@tylertechinc.com" created="Mon, 11 Dec 2006 22:57:08 +0000"  >&lt;p&gt;A generic version probably needs to implement reference counting on the Segments or IndexReader in order to know when they can be safely closed.&lt;/p&gt;</comment>
                    <comment id="12513772" author="hossman" created="Thu, 19 Jul 2007 01:39:51 +0100"  >&lt;p&gt;i somehow missed seeing this issues before ... i don&apos;t really understand the details, but a few comments that come to mind...&lt;/p&gt;

&lt;p&gt;1) this approach seems to assume that when reopening a MyMultiReader, the sub readers will all be MySegmentReaders .. assuming we generalize this to MultiReader/SegmentTeader, this wouldn&apos;t work in the case were people are using a MultiReader containing other MultiReaders ... not to mention the possibility of people who have written their own IndexReader implementations.&lt;br/&gt;
in generally we should probably try to approach reopening a reader as a recursive operation if possible where each type of reader is responsible for checking to see if it&apos;s underlying data has changed, if not return itself, if so return a new reader in it&apos;s place  (much like rewrite works for Queries)&lt;/p&gt;

&lt;p&gt;2) there is no more commit lock correct? ... is this approach something that can still be valid using the current backoff/retry mechanism involved with opening segments?&lt;/p&gt;</comment>
                    <comment id="12514131" author="michaelbusch" created="Fri, 20 Jul 2007 08:10:38 +0100"  >&lt;p&gt;&amp;gt; i somehow missed seeing this issues before ... &lt;/p&gt;

&lt;p&gt;actually, me too... first I came across this thread:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/31592?search_string=refresh;#31592&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/31592?search_string=refresh;#31592&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;in which Doug suggested adding a static method IndexReader.open(IndexReader) &lt;br/&gt;
which would either return the passed in IndexReader instance in case is is&lt;br/&gt;
up to date or return a new, refreshed instance. &lt;/p&gt;

&lt;p&gt;I started implementing this, using Dougs and Roberts ideas and then realized &lt;br/&gt;
that there was already this open issue. But the code here is quite outdated.&lt;/p&gt;

&lt;p&gt;&amp;gt; in generally we should probably try to approach reopening a reader as a &lt;br/&gt;
&amp;gt; recursive operation&lt;/p&gt;

&lt;p&gt;Yeah we could do that. However, this might not be so easy to implement.&lt;br/&gt;
For example, if a user creates a MultiReader instance and adds whatever&lt;br/&gt;
subreaders, we would have to recursively refresh the underlying readers.&lt;br/&gt;
But if the MultiReader was created automatically by IndexReader.open() just&lt;br/&gt;
calling refresh on the subreaders is not enough. New SegmentReaders have to&lt;br/&gt;
be opened for new segments.&lt;/p&gt;

&lt;p&gt;Also the recursive walk would have to take place within the FindSegmentsFile&lt;br/&gt;
logic.&lt;/p&gt;

&lt;p&gt;I decided therefore to only allow IndexReaders to be refreshed if they were&lt;br/&gt;
created by one of the IndexReader.open() methods. I&apos;m going to submit a first&lt;br/&gt;
version of my patch soon. Do you think this is too limiting? &lt;/p&gt;</comment>
                    <comment id="12514132" author="michaelbusch" created="Fri, 20 Jul 2007 08:13:34 +0100"  >&lt;p&gt;First version of my patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Adds the static method IndexReader.open(IndexReader)&lt;br/&gt;
     that returns a new instance of IndexReader in case&lt;br/&gt;
     the reader could be updated. If it was up to date&lt;br/&gt;
     then the passed-in instance is returned. Only&lt;br/&gt;
     IndexReader instances that were created by one of&lt;br/&gt;
     the IndexReader.open() methods can be refreshed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SegmentsReader.reopen(SegmentInfos) looks in the&lt;br/&gt;
     SegmentInfos for a segment with the same name. If&lt;br/&gt;
     one could be found then either the deleted docs or&lt;br/&gt;
     the norms were updated, otherwise the segment name&lt;br/&gt;
     would have changed. reopen() clones the &lt;br/&gt;
     SegmentReader and either loads the deleted docs,&lt;br/&gt;
     the norms or both. Then the clone is returned and&lt;br/&gt;
     the original SegmentReader is marked as closed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If the index has only one segment, then&lt;br/&gt;
     IndexReader.open(IndexReader) checks if the passed&lt;br/&gt;
     in IndexReader can be refreshed. This is only &lt;br/&gt;
     possible if it is no MultiReader and if the segment&lt;br/&gt;
     name has not changed. Otherwise a new SegmentReader&lt;br/&gt;
     instance is returned and the old reader is closed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If the index has multiple segments, then&lt;br/&gt;
     IndexReader.open(IndexReader) creates a new &lt;br/&gt;
     MultiReader and tries to reuse the passed-in&lt;br/&gt;
     reader (in case it&apos;s a SegmentReader) or its &lt;br/&gt;
     subreaders (in case it&apos;s a MultiReader). For new&lt;br/&gt;
     segments new SegmentReaders are created. Old &lt;br/&gt;
     readers that couldn&apos;t be reused are closed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Adds the new testcase TestIndexReaderReopen. It&lt;br/&gt;
     includes the method &lt;br/&gt;
     assertIndexEquals(IndexReader, IndexReader) that&lt;br/&gt;
     checks whether boths IndexReaders have the same&lt;br/&gt;
     content. The testcase creates an index and &lt;br/&gt;
     performes different modifications on that index.&lt;br/&gt;
     One IndexReader is refreshed after each index&lt;br/&gt;
     modification and compared to a fresh IndexReader&lt;br/&gt;
     which is opened after each modification.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;This first version is for review and not ready to &lt;br/&gt;
commit. I want to add more extensive tests and &lt;br/&gt;
probably clean up the code.&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                    <comment id="12514379" author="hossman" created="Sat, 21 Jul 2007 01:26:00 +0100"  >
&lt;p&gt;&amp;gt; Yeah we could do that. However, this might not be so easy to implement.&lt;br/&gt;
&amp;gt; For example, if a user creates a MultiReader instance and adds whatever&lt;br/&gt;
&amp;gt; subreaders, we would have to recursively refresh the underlying readers.&lt;br/&gt;
&amp;gt; But if the MultiReader was created automatically by IndexReader.open() just&lt;br/&gt;
&amp;gt; calling refresh on the subreaders is not enough. New SegmentReaders have to&lt;br/&gt;
&amp;gt; be opened for new segments. &lt;/p&gt;

&lt;p&gt;...this being the curse that is MultiReader &amp;#8211; it can serve two very differenet purposes.  &lt;/p&gt;

&lt;p&gt;You seem to have already solved the multisegments in a single directory approach, the MultiReader over many subreader part actually seems much easier to me (just call your open method on all of the subreaders) the only tricky part is detecting which behavior should be used when. This could be driven by a simple boolean property of MultiReader indicating whether it owns it&apos;s directory and we need to look for new segments or not &amp;#8211; in which case we just need to refresh the subreaders.  (My personal preference would be to change MultiReader so &quot;this.directory&quot; is null if it was open over several other subReaders, right now it&apos;s just assigned to the first one arbitrarily, but there may be other consequences of changing that)&lt;/p&gt;

&lt;p&gt;Incidentally: I don&apos;t think it&apos;s crucial that this be done as a recursive method.  the same approach i describe could be added to  static utility like what you&apos;ve got, I just think that if it&apos;s possible to do it recursively we should so that  &lt;b&gt;if&lt;/b&gt; someone does write their own MultiReader or SegmentReader subclass they can still benefit from any core reopening logic as long as theey do their part to &quot;reopen&quot; their extensions.&lt;/p&gt;</comment>
                    <comment id="12514381" author="hossman" created="Sat, 21 Jul 2007 02:46:39 +0100"  >&lt;p&gt;an extremely hackish refactoring of the previous patch that demonstrates the method working recursively and dealing with MultiReaders constructed over multiple subReaders.&lt;/p&gt;

&lt;p&gt;a few notes:&lt;/p&gt;

&lt;p&gt;1) no where near enough tests of the subReader situation&lt;br/&gt;
2) the refactoring is very very ugly and brutish ... most of the code is still in IndexReader just because it needs so many things that are private &amp;#8211; things that really seems like they should be pushed down into SegmentReader (or made protected)&lt;br/&gt;
3) test triggered an apparent NPE in MultiReader.isOptimized() when there are subReaders, i hacked arround this in the test, see usages of assertIndexEqualsZZZ vs assertIndexEquals&lt;br/&gt;
4) the FilterIndexReader situation is ... interesting.  in theory FilterIndexReader should really be abstract (since if you aren&apos;t subclassing it anyway, why do you want it?) &lt;/p&gt;</comment>
                    <comment id="12517085" author="michaelbusch" created="Wed, 1 Aug 2007 22:41:08 +0100"  >&lt;p&gt;Now, after &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-781&quot; title=&quot;NPE in MultiReader.isCurrent() and getVersion()&quot;&gt;&lt;del&gt;LUCENE-781&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-970&quot; title=&quot;FilterIndexReader should overwrite isOptimized()&quot;&gt;&lt;del&gt;LUCENE-970&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-832&quot; title=&quot;NPE when calling isCurrent() on a ParallellReader&quot;&gt;&lt;del&gt;LUCENE-832&lt;/del&gt;&lt;/a&gt; are committed, I updated the latest&lt;br/&gt;
patch here, which was now easier because MultiReader is now separated into two classes.&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;As Hoss suggested I added the reopen() method to IndexReader non-static.&lt;/li&gt;
	&lt;li&gt;MultiReader and ParallelReader now overwrite reopen() to reopen the subreaders&lt;br/&gt;
     recursively.&lt;/li&gt;
	&lt;li&gt;FilteredReader also overwrites reopen(). It checks if the underlying reader has&lt;br/&gt;
     changed, and in that case returns a new instance of FilteredReader.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think the general contract of reopen() should be to always return a new IndexReader &lt;br/&gt;
instance if it was successfully refreshed and return the same instance otherwise, &lt;br/&gt;
because IndexReaders are used as keys in caches.&lt;br/&gt;
A remaining question here is if the old reader(s) should be closed then or not.&lt;br/&gt;
This patch closes the old readers for now, if we want to change that we probably have &lt;br/&gt;
to add some reference counting mechanism, as Robert suggested already. Then I would&lt;br/&gt;
also have to change the SegmentReader.reopen() implementation to clone resources like&lt;br/&gt;
the dictionary, norms and delete bits. &lt;br/&gt;
I think closing the old reader is fine. What do others think? Is keeping the old &lt;br/&gt;
reader after a reopen() a useful usecase?&lt;/p&gt;</comment>
                    <comment id="12517087" author="michaelbusch" created="Wed, 1 Aug 2007 22:46:21 +0100"  >&lt;p&gt;I ran some quick performance tests with this patch:&lt;/p&gt;

&lt;p&gt;1) The test opens an IndexReader, deletes one document by random docid, closes the Reader.&lt;br/&gt;
   So this reader doesn&apos;t have to open the dictionary or the norms.&lt;br/&gt;
2) Another reader is opened (or alternatively reopened) and one TermQuery is executed, so &lt;br/&gt;
   this reader has to read the norms and the dictionary. &lt;/p&gt;

&lt;p&gt;I run these two steps 5000 times in a loop.&lt;/p&gt;

&lt;p&gt;First run: Index size: 4.5M, optimized &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;1) + TermQuery:    103 sec&lt;/li&gt;
	&lt;li&gt;1) + 2) (open):    806 sec, so open()   takes 703 sec&lt;/li&gt;
	&lt;li&gt;1) + 2) (reopen):  118 sec, so reopen() takes  15 sec ==&amp;gt; Speedup: 46.9 X&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Second run: Index size: 3.3M, 24 segments (14x 230.000, 10x 10.000)&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;1) + TermQuery:    235 sec&lt;/li&gt;
	&lt;li&gt;1) + 2) (open):   1162 sec, so open()   takes 927 sec&lt;/li&gt;
	&lt;li&gt;1) + 2) (reopen):  321 sec, so reopen() takes  86 sec ==&amp;gt; Speedup: 10.8X&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12518030" author="yseeley@gmail.com" created="Mon, 6 Aug 2007 23:07:38 +0100"  >&lt;p&gt;&amp;gt; I think closing the old reader is fine. What do others think? Is keeping the old&lt;br/&gt;
&amp;gt; reader after a reopen() a useful usecase?&lt;/p&gt;

&lt;p&gt;In a multi-threaded environment, one wants to open a new reader, but needs to wait until all requests finish before closing the old reader.  Seems like reference counting is the only way to handle that case.&lt;/p&gt;</comment>
                    <comment id="12519377" author="hossman" created="Mon, 13 Aug 2007 07:15:45 +0100"  >
&lt;p&gt;(note: i haven&apos;t looked at the latest patch in detail, just commenting on the comments)&lt;/p&gt;

&lt;p&gt;One key problem i see with automatically closing things in reopen is MultiReader: it&apos;s perfectly legal to do something like this psuedocode...&lt;/p&gt;

&lt;p&gt;   IndexReader a, b, c = ...&lt;br/&gt;
   MultiReader ab = new MultiReader(&lt;/p&gt;
{a, b}
&lt;p&gt;)&lt;br/&gt;
   MultiReader bc = new MultiReader(&lt;/p&gt;
{b, c}
&lt;p&gt;)&lt;br/&gt;
   ...b changes on disk...&lt;br/&gt;
   ab.reopen(); // this shouldn&apos;t affect bc;&lt;/p&gt;

&lt;p&gt;one possibility would be for the semantics of reopen to close old readers only if it completely owns them; ie: MultiReader should never close anything in reopen, MultiSegmentReader should close all of the subreaders since it opened them in the first place ... things get into a grey area with SegementReader though.&lt;/p&gt;

&lt;p&gt;In general i think the safest thing to do is for reopen to never close.  Yonik&apos;s comment showcases one of the most compelling reasons why it can be important for clients to be able to keep using an old IndexReader instance, and it&apos;s easy enough for clients that want the old one closed to do something like...&lt;/p&gt;

&lt;p&gt;   IndexReader r = ...&lt;br/&gt;
   ...&lt;br/&gt;
   IndexReader tmp = r.reopen();&lt;br/&gt;
   if (tmp != r) r.close(); &lt;br/&gt;
   r = tmp;&lt;br/&gt;
   ...&lt;/p&gt;


&lt;p&gt;(one question that did jump out at me while greping the patch for the where old readers were being closed: why is the meat of reopen still in &quot;IndexReader&quot; with a &quot;if (reader instanceof SegmentReader)&quot; style logic in it?  can&apos;t the different reopen mechanisms be refactored down into SegmentReader and MultiSegmentReader respectively?  shouldn&apos;t the default impl of IndexReader throw an UnsuppportedOperationException?)&lt;/p&gt;</comment>
                    <comment id="12520476" author="michaelbusch" created="Fri, 17 Aug 2007 08:10:56 +0100"  >&lt;p&gt;&amp;gt;   IndexReader a, b, c = ...&lt;br/&gt;
&amp;gt;   MultiReader ab = new MultiReader(&lt;/p&gt;
{a, b}
&lt;p&gt;)&lt;br/&gt;
&amp;gt;   MultiReader bc = new MultiReader(&lt;/p&gt;
{b, c}
&lt;p&gt;)&lt;br/&gt;
&amp;gt;   ...b changes on disk...&lt;br/&gt;
&amp;gt;   ab.reopen(); // this shouldn&apos;t affect bc;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; one possibility would be for the semantics of reopen to close old readers only &lt;br/&gt;
&amp;gt; if it completely owns them; ie: MultiReader should never close anything in &lt;br/&gt;
&amp;gt; reopen, MultiSegmentReader should close all of the subreaders since it opened &lt;br/&gt;
&amp;gt; them in the first place&lt;/p&gt;

&lt;p&gt;So if &apos;b&apos; in your example is a MultiSegmentReader, then the reopen() call &lt;br/&gt;
triggered from MultiReader.reopen() would close old readers, because it owns them, &lt;br/&gt;
thus &apos;bc&apos; wouldn&apos;t work anymore. So it depends on the caller of &lt;br/&gt;
MultiSegmentReader.reopen() whether or not to close the subreaders. I think this &lt;br/&gt;
is kind of messy. Well instead of reopen() we could add &lt;br/&gt;
reopen(boolean closeOldReaders), but then...&lt;/p&gt;

&lt;p&gt;&amp;gt;   IndexReader r = ...&lt;br/&gt;
&amp;gt;   ...&lt;br/&gt;
&amp;gt;   IndexReader tmp = r.reopen();&lt;br/&gt;
&amp;gt;   if (tmp != r) r.close(); &lt;br/&gt;
&amp;gt;   r = tmp;&lt;br/&gt;
&amp;gt;   ...&lt;/p&gt;

&lt;p&gt;... is actually easy enough as you pointed out, so that the extra complexity is not &lt;br/&gt;
really worth it IMO.&lt;/p&gt;

&lt;p&gt;&amp;gt; In general i think the safest thing to do is for reopen to never close.  &lt;/p&gt;

&lt;p&gt;So yes, I agree.&lt;/p&gt;

&lt;p&gt;&amp;gt; why is the meat of reopen still in &quot;IndexReader&quot; with a &quot;if (reader instanceof &lt;br/&gt;
&amp;gt; SegmentReader)&quot; style logic in it?  can&apos;t the different reopen mechanisms be &lt;br/&gt;
&amp;gt; refactored down into SegmentReader and MultiSegmentReader respectively? &lt;/p&gt;

&lt;p&gt;I&apos;m not sure if the code would become cleaner if we did that. Sometimes a &lt;br/&gt;
SegmentReader would then have to return a MultiSegmentReader instance and vice&lt;br/&gt;
versa. So we&apos;d probably have to duplicate some of the code in these two classes.&lt;/p&gt;</comment>
                    <comment id="12521243" author="hossman" created="Mon, 20 Aug 2007 21:40:32 +0100"  >

&lt;p&gt;&amp;gt; I&apos;m not sure if the code would become cleaner if we did that. Sometimes a SegmentReader would then have to &lt;br/&gt;
&amp;gt; return a MultiSegmentReader instance and vice versa. So we&apos;d probably have to duplicate some of the code in&lt;br/&gt;
&amp;gt; these two classes.&lt;/p&gt;

&lt;p&gt;i don&apos;t hink there would be anything wrong with SegmentReader.reopen returning a MultiSegmentReader in some cases (or vice versa) but it definitely seems wrong to me for a parent class to be explicitly casing &quot;this&quot; to one of two know subclasses ... making reopen abstract in the base class (or throw UnsupportOp if for API back compatibility) seems like the only safe way to ensure any future IndexReader subclasses work properly.&lt;/p&gt;</comment>
                    <comment id="12521962" author="michaelbusch" created="Thu, 23 Aug 2007 00:21:49 +0100"  >&lt;p&gt;We should first refactor segmentInfos into IndexReader&apos;s subclasses.&lt;/p&gt;</comment>
                    <comment id="12524694" author="testn" created="Tue, 4 Sep 2007 12:42:38 +0100"  >&lt;p&gt;Please also consider making an option where the reopen can be automated (i.e. when the index is updated) instead of having to call it explicitly. Thread safety should be taken into account as well.&lt;/p&gt;</comment>
                    <comment id="12531698" author="michaelbusch" created="Tue, 2 Oct 2007 07:24:21 +0100"  >&lt;p&gt;I&apos;m attaching a new version of the patch that has a lot of changes compared to the last patch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I factored most of the reopen logic into the subclasses of IndexReader. Now that we&apos;re having the DirectoryIndexReader layer this was possible in a more elegant way.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;IndexReader.reopen() now does not close the old readers by default. This was somewhat tricky, because now the IndexReaders must be cloneable. I changed IndexReader to implement the Cloneable interface and implemented clone() for all Lucene built-in IndexReaders. However, there are probably custom IndexReader implementations out there that do not implement clone() and reopen() should throw an exception when an attempt is made to reopen such a reader. But I don&apos;t want to throw an exception in IndexReader.clone() itself, because then it would not be possible anymore for subclasses to recursively call the native Object.clone() via super.clone(). To solve this conflict I added the method
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  /**
   * Returns &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader instance supports the clone() operation.
   */
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isCloneSupported();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;to IndexReader which returns false by default. IndexReader.clone() checks if the actual implementation supports clone() (i. e. the above method returns true). If not, it throws an UnsupportedOperationException, if yes, it returns super.clone().&lt;/p&gt;

&lt;p&gt;I was not sure about whether to throw an (unchecked) UnsupportedOperationException or a CloneNotSupportedException in this case. I decided to throw UnsupportedOperationException even though it&apos;s not really following the clone() guidelines, because it avoids the necessity to catch the CloneNotSupportedException every time clone() is called (in the reopen() methods of all IndexReader implementations).&lt;/p&gt;

&lt;p&gt;As an example for how the clone() method is used let me describe how MultiReader.reopen() works: it tries to reopen every of its subreaders. If at least one subreader could be reopened successfully, then a new MultiReader instance is created and the reopened subreaders are added to it. Every of the old MultiReader&apos;s subreaders, that was not reopened (because of no index changes) is now cloned() and added to the new MultiReader.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I also added the new method
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  /**
   * In addition to {@link #reopen()} &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; methods offers the ability to close
   * the old IndexReader instance. This speeds up the reopening process &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;
   * certain IndexReader implementations and reduces memory consumption, because
   * resources of the old instance can be reused &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the reopened IndexReader
   * as it avoids the need of copying the resources.
   * &amp;lt;p&amp;gt;
   * The reopen performance especially benefits &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; IndexReader instances returned 
   * by one of the &amp;lt;code&amp;gt;open()&amp;lt;/code&amp;gt; methods are reopened with 
   * &amp;lt;code&amp;gt;closeOldReader==&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;lt;/code&amp;gt;.
   * &amp;lt;p&amp;gt;
   * Certain IndexReader implementations ({@link MultiReader}, {@link ParallelReader})
   * require that the subreaders support the clone() operation (see {@link #isCloneSupported()}
   * in order to perform reopen with &amp;lt;code&amp;gt;closeOldReader==&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&amp;lt;/code&amp;gt;.  
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; IndexReader reopen(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; closeOldReader);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As the javadoc says it has two benefits: 1) it speeds up reopening and reduces ressources, and 2) it allows to reopen readers, that use non-cloneable subreaders.&lt;/p&gt;


&lt;p&gt;Please let me know what you think about these changes, especially about the clone() implementation.&lt;/p&gt;</comment>
                    <comment id="12532585" author="michaelbusch" created="Fri, 5 Oct 2007 08:41:49 +0100"  >&lt;p&gt;I ran new performance tests with the latest patch similar to the tests I explained in an earlier comment on this issue.&lt;/p&gt;

&lt;p&gt;I&apos;m using again a 4.5M index. In each round I delete one document and (re)open the IndexReader thereafter. Here are the numbers for 5000 rounds:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Time &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Speedup &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; open &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  703s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; reopen(closeOldReader==false) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 62s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 11x &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; reopen(closeOldReader==true) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;16s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 44x &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Now in each round I delete on document and also set the norm for one random document. Numbers for 1000 rounds:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;&amp;nbsp;&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Time &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Speedup &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; open &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  166s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; reopen(closeOldReader==false) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 33s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 5.0x &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; reopen(closeOldReader==true) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 29s &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 5.7x &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;I think these numbers look pretty good. We get a quite decent speedup even if the old readers are not closed.&lt;/p&gt;

&lt;p&gt;I would like to commit this in a couple of days to get ready for Lucene 2.3. It would be nice if someone could review the latest patch! Hoss? Others?&lt;/p&gt;</comment>
                    <comment id="12532806" author="yseeley@gmail.com" created="Sat, 6 Oct 2007 01:58:19 +0100"  >&lt;p&gt;I think this looks pretty good Michael!&lt;br/&gt;
Too bad so much needs to be cloned in the case that closeOldReader==false... maybe someday in the future we can have read-only readers.&lt;/p&gt;</comment>
                    <comment id="12532817" author="michaelbusch" created="Sat, 6 Oct 2007 04:43:56 +0100"  >&lt;p&gt;&amp;gt; Too bad so much needs to be cloned in the case that closeOldReader==false... maybe someday in the future we can have read-only readers.&lt;/p&gt;

&lt;p&gt;Yeah, the cloning part was kind of tedious. Read-only readers would indeed make our life much easier here. I&apos;m wondering how many people are using the IndexReader to alter the norms anyway?&lt;/p&gt;

&lt;p&gt;Well, thanks for reviewing the patch, Yonik!&lt;/p&gt;</comment>
                    <comment id="12532819" author="rengels@ix.netcom.com" created="Sat, 6 Oct 2007 05:24:47 +0100"  >&lt;p&gt;Nice to see all the good work on this. We are still on a 1.9 derivative.&lt;/p&gt;

&lt;p&gt;Hopefully we&apos;ll be able to move to stock 2.X release in the future.&lt;/p&gt;
</comment>
                    <comment id="12532829" author="hossman" created="Sat, 6 Oct 2007 06:37:46 +0100"  >&lt;p&gt;I haven&apos;t looked at the patch yet (i really really plan to this weekend, baring catastrophe) but i&apos;m confused as to why you went the cloning route (along with the complexity of the api changes to indicate when it is/isn&apos;t supported) ... based on the comments, it seems to boil down to...&lt;/p&gt;

&lt;p&gt;&amp;gt; As an example for how the clone() method is used let me describe how MultiReader.reopen()&lt;br/&gt;
&amp;gt; works: it tries to reopen every of its subreaders. If at least one subreader could be reopened&lt;br/&gt;
&amp;gt; successfully, then a new MultiReader instance is created and the reopened subreaders are&lt;br/&gt;
&amp;gt; added to it. Every of the old MultiReader&apos;s subreaders, that was not reopened (because of no&lt;br/&gt;
&amp;gt; index changes) is now cloned() and added to the new MultiReader.&lt;/p&gt;

&lt;p&gt;that seems like circular logic: the clone method is used so that the sub readers can be cloned &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;why use clones at all? why not just use the original reader (if the &quot;index&quot; that reader represents hasn&apos;t changed, why clone it?&lt;/p&gt;

&lt;p&gt;And if (for reasons that aren&apos;t clear to me) it is important for MultiReader to use a clone of it&apos;s subreaders when their reopen method returns &quot;this&quot; then shouldn&apos;t clients do the same thing? ... why not make reopen always return this.clone() if the index hasn&apos;t changed (which now that i think about it, would also help by punting on the isCloneSupported issue &amp;#8211; each class would already know if it was clonable.&lt;/p&gt;

&lt;p&gt;maybe this will make more sense once i read the patch ... i just wanted to through it out there in case someone had a chance to reply before i get a chance.&lt;/p&gt;
</comment>
                    <comment id="12532833" author="michaelbusch" created="Sat, 6 Oct 2007 07:56:42 +0100"  >&lt;p&gt;&amp;gt; why use clones at all? why not just use the original reader (if the &quot;index&quot; that reader represents hasn&apos;t changed, why clone it?&lt;/p&gt;

&lt;p&gt;Let&apos;s say you have a MultiReader with two subreaders:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader ir1 = IndexReader.open(index1);
IndexReader ir2 = IndexReader.open(index2);
IndexReader mr = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {ir1, ir2});
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now index1 changes and you reopen the MultiReader and keep the old one open:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader mr2 = mr.reopen();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ir1 would now be reopened and let&apos;s assume we wouldn&apos;t clone ir2. If you use mr2 now to e.g. delete a doc and that doc happens to be in index2, then mr1 would also see the changes because both MultiReaders share the same subreader ir2 and are thus not independent from each other.&lt;/p&gt;

&lt;p&gt;&amp;gt; why not make reopen always return this.clone()&lt;/p&gt;

&lt;p&gt;clone() might be an expensive operation. We only need to clone if at least one of the subreaders has changed.&lt;/p&gt;</comment>
                    <comment id="12532867" author="mikemccand" created="Sat, 6 Oct 2007 14:26:50 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; Too bad so much needs to be cloned in the case that&lt;br/&gt;
&amp;gt; &amp;gt; closeOldReader==false... maybe someday in the future we can have&lt;br/&gt;
&amp;gt; &amp;gt; read-only readers.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Yeah, the cloning part was kind of tedious. Read-only readers would&lt;br/&gt;
&amp;gt; indeed make our life much easier here. I&apos;m wondering how many people&lt;br/&gt;
&amp;gt; are using the IndexReader to alter the norms anyway?&lt;/p&gt;

&lt;p&gt;I think the closeOldReader=false case is actually quite important.&lt;/p&gt;

&lt;p&gt;Because in production, I think you&apos;d have to use that, so that your&lt;br/&gt;
old reader stays alive and is used to service incoming queries, up&lt;br/&gt;
until the point where the re-opened reader is &quot;fully warmed&quot;.&lt;/p&gt;

&lt;p&gt;Since fully warming could take a long time (minutes?) you need that&lt;br/&gt;
old reader to stay open.&lt;/p&gt;

&lt;p&gt;Can we take a copy-on-write approach?  EG, this is how OS&apos;s handle the&lt;br/&gt;
virtual memory pages when forking a process.  This would mean whenever&lt;br/&gt;
a clone has been made of a SegmentReader, they cross-reference one&lt;br/&gt;
another. Then whenever either needs to alter deleted docs, one of them&lt;br/&gt;
makes a copy then.  Likewise for the norms.&lt;/p&gt;

&lt;p&gt;This would mean that &quot;read-only&quot; uses of the cloned reader never&lt;br/&gt;
pay the cost of copying the deleted docs bit vector nor norms.&lt;/p&gt;</comment>
                    <comment id="12532875" author="mikemccand" created="Sat, 6 Oct 2007 15:16:18 +0100"  >
&lt;p&gt;Actually if we went back to the sharing (not cloning) approach, could&lt;br/&gt;
we insert a check for any writing operation against the re-opened&lt;br/&gt;
reader that throws an exception if the original reader is not yet&lt;br/&gt;
closed?&lt;/p&gt;

&lt;p&gt;In Michael&apos;s example above, on calling mr2.deleteDoc, you would hit an&lt;br/&gt;
exception because mr2 would check and see that it&apos;s &quot;original&quot; reader&lt;br/&gt;
mr is not yet closed.  But once you&apos;ve closed mr, then the call&lt;br/&gt;
succeeds.&lt;/p&gt;

&lt;p&gt;I think this would let us have our cake and eat it too: re-opening&lt;br/&gt;
would be very low cost for unchanged readers (no clones created), and,&lt;br/&gt;
you can still do deletes, etc, after you have closed your prior&lt;br/&gt;
reader.  You control when your prior reader gets closed, to allow for&lt;br/&gt;
warming time and for queries to finish on the old reader.&lt;/p&gt;

&lt;p&gt;Would this work?&lt;/p&gt;</comment>
                    <comment id="12532877" author="mikemccand" created="Sat, 6 Oct 2007 15:29:08 +0100"  >
&lt;p&gt;A couple other questions/points:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Just to verify: if you have a DirectoryIndexReader that is holding&lt;br/&gt;
    the write lock (because it has made changes to deletes/norms) then&lt;br/&gt;
    calling reopen on this reader should always return &apos;this&apos;, right?&lt;br/&gt;
    Because it has the write lock, it must be (better be!) current.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This might be a good place to add an assert: if you are not&lt;br/&gt;
    current, assert that you don&apos;t have the write lock, and if you&lt;br/&gt;
    have the write lock, assert that you are current.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think you should add &quot;ensureOpen()&quot; at the top of&lt;br/&gt;
    MultiReader.reopen(...)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If an Exception is hit during reopen, what is the resulting state&lt;br/&gt;
    of your original reader?  I think, ideally, it is unaffected by&lt;br/&gt;
    the attempt to re-open?  EG if you&apos;re on the hairy edge of file&lt;br/&gt;
    descriptor limits, and the attempt to re-open failed because you&lt;br/&gt;
    hit the limit, ideally your original reader is unaffected (even if&lt;br/&gt;
    you specified closeOldReader=true).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12532990" author="hossman" created="Sun, 7 Oct 2007 19:22:45 +0100"  >&lt;p&gt;Okay, read the patch.  I&apos;m on board with the need for Clonable now ... it&apos;s all about isolation.  if &quot;r.reopen(false) == r&quot; then the client is responsible for recognizing that it&apos;s got the same instance and can make the judgement call about reusing the instance or cloning depending on it&apos;s needs ... internally in things like MultiReader we have to assume we need a clone for isolation.&lt;/p&gt;

&lt;p&gt;Questions and comments...&lt;/p&gt;

&lt;p&gt;1. CompoundFileReader, FieldsReader, IndexReader, and BitVector all have clone methods where they silently catch and ignore CloneNotSupportedExceptions from super.clone()... if we don&apos;t expect the exception to ever happen, we should just let the exception propogate up the stack (there is no down side to declaring that clone() throws CloneNotSupportedException).  If we think the exception might happen, but it&apos;s not a big deal if it does and we can ignore it, then we should put a comment in the catch block to that effect.  i&apos;m not clear which are the cases here.&lt;/p&gt;

&lt;p&gt;2. i don&apos;t remember if the old patches had this issue as well, but having &quot;return new FilterIndexReader(reopened);&quot; in FilterIndexReader doesn&apos;t really help anyone using FilterIndexReader &amp;#8211; they&apos;re going to want an instance of their own subclass.  to meet the contract of FilterIndexReader, we should implement all &quot;abstract&quot; methods and delegate to the inner reader - so in theory do don&apos;t need a new instance of FIlterIndexReader, we could just return in.reopen(closeold) ... my gut says it would be better to leave the method out entirely so that the default impl which throws UnSupOpEx is used &amp;#8212; that way subclasses who want to use reopen &lt;b&gt;must&lt;/b&gt; define their own (instead of getting confused when their filtering logic stops working after they reopen for the first time)&lt;/p&gt;

&lt;p&gt;3. instead of having an isClonable() method, why don&apos;t we just remove the &quot;implements Clonable&quot; declaration from IndexReader and put it on the concrete subclasses &amp;#8211; then use &quot;instanceof Cloneable&quot; to determine if something is clonable?  ... for that matter, the only place isCloneSupported is really used is in IndexReader.clone where an exception is thrown if Clone is not  supported ... subclasses which know they are Clonable don&apos;t need this from the base class, subclasses which don&apos;t implement Clonable but are used in combination with core classes whose reopen method requires it could be skiped by the caller (since they don&apos;t implement Clonable) .. &lt;/p&gt;

&lt;p&gt;4. javadocs frequently refer to &quot;reopened successfully&quot; and &quot;refreshed successfully&quot; when what it really means is &quot;reopen() returned a newer/fresher reader&quot; ... this may confuse people who are use to thinking of &quot;successfully&quot; a &quot;without error&quot;&lt;/p&gt;

&lt;p&gt;5. random thought: are their any synchronization issues we&apos;re missing here?  I&apos;m wondering about the case where once thread calls reopen while another thread is updating norms or deleting docs.  is there any chance for inconsistent state?&lt;/p&gt;
</comment>
                    <comment id="12532997" author="hossman" created="Sun, 7 Oct 2007 20:57:08 +0100"  >&lt;p&gt;a rough variation on Michael&apos;s latest patch that makes the changes along two of the lines i was suggesting before reagrding FilterIndexReader and ising &quot;instanceof Cloneable&quot; instead of &quot;isCloneSupported()&quot; two important things to note:&lt;/p&gt;

&lt;p&gt;1) i didn&apos;t change any of the documentation, i was trying to change as little aspossibel so the two patches could be compared side-by-side&lt;/p&gt;

&lt;p&gt;2) this patch is currently broken.  TestIndexReaderReopen gets an exception i can&apos;t understand ... but i have to stop now, and i wanted to post what i had in case people had comments.&lt;/p&gt;

&lt;p&gt;...now that i&apos;ve done this exercise, i&apos;m not convinced that it&apos;s a better way to go, but it does seem like isCloneSupported isn&apos;t neccessary, that&apos;s the whole point of the Cloneable interface.&lt;/p&gt;
</comment>
                    <comment id="12533000" author="yseeley@gmail.com" created="Sun, 7 Oct 2007 21:09:29 +0100"  >&lt;p&gt;&amp;gt; I&apos;m wondering about the case where once thread calls reopen while another thread is updating norms or deleting docs.&lt;/p&gt;

&lt;p&gt;Hmmm  there is cause for concern (and I should have had my mt-safe hat on &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Reopen is synchronized on the reader, and so are norms access and docs, but from a quick look:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;reopen() may be synchronized, but clone() called on sub-readers isn&apos;t in a synchronized context that the sub-reader cares about.  For example, MultiReader.reopen has the lock on the multireader, but calles subreader.clone() which iterates over the norms in a non thread-safe way.&lt;/li&gt;
	&lt;li&gt;IndexInput objects that are in use should never be cloned... (like what is done in FieldsReader.clone())&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12533172" author="michaelbusch" created="Mon, 8 Oct 2007 18:56:11 +0100"  >&lt;p&gt;Thanks all for the reviews and comments!&lt;/p&gt;

&lt;p&gt;There seem to be some issues/open questions concerning the cloning. &lt;br/&gt;
Before I comment on them I think it would make sense to decide whether&lt;br/&gt;
we want to stick with the cloning approach or not. Mike suggests this &lt;br/&gt;
approach:&lt;/p&gt;

&lt;p&gt;&amp;gt; Actually if we went back to the sharing (not cloning) approach, could&lt;br/&gt;
&amp;gt; we insert a check for any writing operation against the re-opened&lt;br/&gt;
&amp;gt; reader that throws an exception if the original reader is not yet&lt;br/&gt;
&amp;gt; closed?&lt;/p&gt;

&lt;p&gt;Interesting, yes that should work in case we have two readers (the &lt;br/&gt;
original one and the re-opened one). But what happens if the user calls &lt;br/&gt;
reopen twice to get two re-opened instances back? Then there would be &lt;br/&gt;
three instances, and without cloning the two re-opened ones would also &lt;br/&gt;
share the same resources. Is this a desirable use case or would it be &lt;br/&gt;
okay to restrict reopen() so that it can only create one new instance?&lt;/p&gt;</comment>
                    <comment id="12533186" author="mikemccand" created="Mon, 8 Oct 2007 19:45:12 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; Actually if we went back to the sharing (not cloning) approach,&lt;br/&gt;
&amp;gt; &amp;gt; could we insert a check for any writing operation against the&lt;br/&gt;
&amp;gt; &amp;gt; re-opened reader that throws an exception if the original reader&lt;br/&gt;
&amp;gt; &amp;gt; is not yet closed?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Interesting, yes that should work in case we have two readers (the&lt;br/&gt;
&amp;gt; original one and the re-opened one). But what happens if the user&lt;br/&gt;
&amp;gt; calls reopen twice to get two re-opened instances back? Then there&lt;br/&gt;
&amp;gt; would be three instances, and without cloning the two re-opened ones&lt;br/&gt;
&amp;gt; would also share the same resources. Is this a desirable use case or&lt;br/&gt;
&amp;gt; would it be okay to restrict reopen() so that it can only create one&lt;br/&gt;
&amp;gt; new instance?&lt;/p&gt;

&lt;p&gt;Hmmm good point.&lt;/p&gt;

&lt;p&gt;Actually, we could allow more then one re-open call if we take the&lt;br/&gt;
following approach: every time a cloned Reader &quot;borrows&quot; a reference&lt;br/&gt;
to a sub-reader, it increments a counter (call it the &quot;referrer&lt;br/&gt;
count&quot;).  When the Reader is closed, it decrements the count (by 1)&lt;br/&gt;
for each of the sub-readers.&lt;/p&gt;

&lt;p&gt;Then, any reader should refuse to do a writing operation if its&lt;br/&gt;
&quot;referrer&quot; count is greater than 1, because it&apos;s being shared across&lt;br/&gt;
more than one referrer.&lt;/p&gt;

&lt;p&gt;This way if you have a reader X and you did reopen to get Y and did&lt;br/&gt;
reopen again to get Z then the shared sub-readers between X, Y and Z&lt;br/&gt;
would not allow any write operations until 2 of the three had been&lt;br/&gt;
closed.  I think that would work?&lt;/p&gt;

&lt;p&gt;BTW this would also allow for very efficient &quot;snapshots&quot; during&lt;br/&gt;
searching: keeping multiple readers &quot;alive&quot;, each searching a&lt;br/&gt;
different point-in-time commit of the index, because they would all&lt;br/&gt;
share the underlying segment readers that they have in common.  Vs&lt;br/&gt;
cloning which would have to make many copies of each segment reader.&lt;/p&gt;</comment>
                    <comment id="12533205" author="michaelbusch" created="Mon, 8 Oct 2007 22:42:29 +0100"  >&lt;p&gt;&amp;gt; This way if you have a reader X and you did reopen to get Y and did&lt;br/&gt;
&amp;gt; reopen again to get Z then the shared sub-readers between X, Y and Z&lt;br/&gt;
&amp;gt; would not allow any write operations until 2 of the three had been&lt;br/&gt;
&amp;gt; closed.  I think that would work?&lt;/p&gt;

&lt;p&gt;Yes I think it would work. However, this approach has two downside IMO:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;reopen() becomes more complicated and restricted for the user. With&lt;br/&gt;
the cloning approach the user doesn&apos;t have to care about when index &lt;br/&gt;
modifications are not allowed. IndexReader instances returned by open()&lt;br/&gt;
or reopen() can be used exactly the same without any restrictions.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We have to be very careful about cross-referencing multiple readers.&lt;br/&gt;
If for some reason any references between two or more readers are not&lt;br/&gt;
cleared after one was closed, then that reader might not become GC&apos;d.&lt;br/&gt;
I&apos;m not saying it&apos;s not possible or even very hard, we just have to &lt;br/&gt;
make sure those things can&apos;t ever happen.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Of course the cloning approach has disadvantages too. For custom &lt;br/&gt;
readers clone() has to be implemented in order to make reopen() work&lt;br/&gt;
correctly. Also reopen() is more expensive in case of &lt;br/&gt;
closeOldReader=false. Well we could certainly consider the lazy clone&lt;br/&gt;
approach that you suggested, Mike, but we have to be careful about the&lt;br/&gt;
cross-referencing issue again.&lt;/p&gt;

&lt;p&gt;So I&apos;m really not sure which way the better one is. I think I&apos;m slightly&lt;br/&gt;
in favor for the cloning approach, so that reopen() returns instances &lt;br/&gt;
that are completely independant from each other, which seems cleaner IMO.&lt;br/&gt;
What do others think?&lt;/p&gt;</comment>
                    <comment id="12533213" author="mikemccand" created="Mon, 8 Oct 2007 23:15:09 +0100"  >
&lt;p&gt;&amp;gt; We have to be very careful about cross-referencing multiple readers.&lt;br/&gt;
&amp;gt; If for some reason any references between two or more readers are&lt;br/&gt;
&amp;gt; not cleared after one was closed, then that reader might not become&lt;br/&gt;
&amp;gt; GC&apos;d.  I&apos;m not saying it&apos;s not possible or even very hard, we just&lt;br/&gt;
&amp;gt; have to make sure those things can&apos;t ever happen.&lt;/p&gt;

&lt;p&gt;One correction: there should be no cross-referencing, right?  The only&lt;br/&gt;
thing that&apos;s happening is incrementing &amp;amp; decrementing the &quot;referrer&lt;br/&gt;
count&quot; for a reader?  (But, you&apos;re right: the &quot;copy on write&quot; approach&lt;br/&gt;
to cloning would have cross-referencing).&lt;/p&gt;

&lt;p&gt;I think the downside of this proposed &quot;shared readers&quot; (non-cloning)&lt;br/&gt;
approach is that you can&apos;t delete/setNorm on the clone until you close&lt;br/&gt;
the original.  But I think that&apos;s fairly minor?  Also if you really&lt;br/&gt;
need a full deep copy of your reader you could just open a new one&lt;br/&gt;
(ie, not use &quot;reopen&quot;)?&lt;/p&gt;

&lt;p&gt;I think the big upside of &quot;shared readers&quot; is reopening becomes quite&lt;br/&gt;
a bit more resource efficient: the cost of re-opening a reader would&lt;br/&gt;
be in proportion to what has actually changed in the index.  EG, if&lt;br/&gt;
your index has added a few tiny segments since you last opened then&lt;br/&gt;
the reopen would be extremely fas but with cloning you are forced&lt;br/&gt;
to make a full deep copy of all other &lt;span class=&quot;error&quot;&gt;&amp;#91;unchanged&amp;#93;&lt;/span&gt; segments.&lt;/p&gt;</comment>
                    <comment id="12534123" author="hossman" created="Thu, 11 Oct 2007 19:43:26 +0100"  >
&lt;p&gt;in deciding &quot;to clone or not clone&quot; for the purposes of implementing reopen, it may make sense to step back and ask a two broader questions...&lt;/p&gt;

&lt;p&gt;1) what was the motivation for approaching reopen using clones in the first place&lt;br/&gt;
2) what does it inherently mean to clone an indexreader.&lt;/p&gt;

&lt;p&gt;the answer to the first question, as i understand it, relates to the issue of indexreaders not being &quot;read only&quot; object ... operations can be taken which modify the readers state, and those operations can be flushed to disk when the reader is closed.  so readerB = readerA.reopen(closeOld=false) and then readerA.delete(...) is called, there is ambiguity as to what should happen in readerB.  so the clone route seems pretty straight forward if and only if we have an unambiguous concept of cloning a reader (because then the clone approach to reopen becomes unambiguous as well).  alternately, since reopen is a new method, we can resolve the ambiguity anyway we want, as long as it&apos;s documented ... in theory we should pick a solution that seems to serve the most benefit ... perhaps that solution is to document reopen with &quot;if reopen(closeOld=false) returns a new reader it will share state with the current reader, attempting to do the following operations on this new reader will result in undefined behavior&quot;&lt;/p&gt;

&lt;p&gt;the answer the the second is only important if we want to go the cloning route ... but it is pretty important in a larger sense then just reopening ... f we start to say that any of the IndexReader classes are Clonable we have to be very clear about what that means in &lt;b&gt;all&lt;/b&gt; cases where someone might clone it in addition to reopen ... in particular, i worry about what it means to clone a reader which has already had &quot;write&quot; operations performed on it (something the clone based version of reopen will never do because a write operation indicates the reader must be current), but some client code might as soon as we add the Clonable interface to a class.&lt;/p&gt;
</comment>
                    <comment id="12535335" author="michaelbusch" created="Tue, 16 Oct 2007 21:34:24 +0100"  >&lt;p&gt;&amp;gt; in deciding &quot;to clone or not clone&quot; for the purposes of implementing &lt;br/&gt;
&amp;gt; reopen, it may make sense to step back and ask a two broader questions...&lt;/p&gt;

&lt;p&gt;I agree!&lt;/p&gt;

&lt;p&gt;&amp;gt; 1) what was the motivation for approaching reopen using clones in the &lt;br/&gt;
&amp;gt; first place&lt;/p&gt;

&lt;p&gt;Good summarization! You are right, I started the clone approach because&lt;br/&gt;
IndexReaders are not &quot;read only&quot; objects.&lt;/p&gt;

&lt;p&gt;&amp;gt; &quot;if reopen(closeOld=false) returns a new reader it will share state with &lt;br/&gt;
&amp;gt; the current reader, attempting to do the following operations on this &lt;br/&gt;
&amp;gt; new reader will result in undefined behavior&quot;&lt;/p&gt;

&lt;p&gt;This would mean, that we simply warn the user that performing write &lt;br/&gt;
operations with the re-opened indexreader will result in undefined behavior,&lt;br/&gt;
whereas with Mike&apos;s approach we would prevent such an undefined behavior by &lt;br/&gt;
using reference counting.&lt;/p&gt;

&lt;p&gt;Hmm, so what are our long-term plans for indexreaders? If our goal is to &lt;br/&gt;
make them read-only (we can delete via IndexWriter already), then I think &lt;br/&gt;
adding those warning comments to reopen(), as you suggest Hoss, would be &lt;br/&gt;
sufficient. &lt;/p&gt;

&lt;p&gt;If everybody likes this approach I&apos;ll go ahead and submit a new patch.&lt;/p&gt;
</comment>
                    <comment id="12535342" author="cutting" created="Tue, 16 Oct 2007 21:51:22 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Hmm, so what are our long-term plans for indexreaders? If our goal is to&lt;br/&gt;
make them read-only (we can delete via IndexWriter already), then I think&lt;br/&gt;
adding those warning comments to reopen(), as you suggest Hoss, would be&lt;br/&gt;
sufficient.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s a fine direction.  Note however that IndexWriter implements delete by calling IndexReader.delete().  That method could be made package-private, so that users cannot call it, but then this makes it impossible for someone to subclass IndexReader from a different package.  So perhaps delete() needs to move to a subclass of IndexReader?  That gets messy...&lt;/p&gt;</comment>
                    <comment id="12535350" author="michaelbusch" created="Tue, 16 Oct 2007 22:24:13 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I think that&apos;s a fine direction. Note however that IndexWriter implements delete by calling IndexReader.delete(). That method could be made package-private, so that users cannot call it, but then this makes it impossible for someone to subclass IndexReader from a different package. So perhaps delete() needs to move to a subclass of IndexReader? That gets messy...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually all of the lock/commit logic moved from IndexReader to DirectoryIndexReader already, and the delete logic is in SegmentReader, which subclasses DirectoryIndexReader. So we could remove the deleteDocument() API from IndexReader but leave it in DirectoryIndexReader. Then it would still be possible to extend IndexReader from a different package just as today, and IndexWriter could use DirectoryIndexReader for performing deletes. These changes should be trivial.&lt;/p&gt;</comment>
                    <comment id="12535352" author="cutting" created="Tue, 16 Oct 2007 22:33:04 +0100"  >&lt;p&gt;Got it.  IndexWriter only works with SegmentReaders anyway, not with an arbitrary IndexReader implementation: IndexReader is extensible, but IndexWriter is not.  I&apos;d (momentarily) forgotten that.  Nevermind.&lt;/p&gt;</comment>
                    <comment id="12535354" author="yseeley@gmail.com" created="Tue, 16 Oct 2007 22:40:11 +0100"  >&lt;p&gt;Having a read-only IndexReader would (should?) mean being able to remove &quot;synchronized&quot; from some things like isDeleted()... a nice performance win for multi-processor systems for things that didn&apos;t have access to the deleted-docs bitvec.&lt;/p&gt;

&lt;p&gt;&amp;gt; If our goal is to make them read-only (we can delete via IndexWriter already)&lt;/p&gt;

&lt;p&gt;But you can only delete-by-term.&lt;br/&gt;
It&apos;s more powerful to be able to delete by docid, however I manage to come up with it.&lt;br/&gt;
So I think deleteDocument(int id) should either be moved to a subclass.  same with setNorms?&lt;/p&gt;</comment>
                    <comment id="12535362" author="michaelbusch" created="Tue, 16 Oct 2007 23:29:00 +0100"  >&lt;blockquote&gt;
&lt;p&gt;So I think deleteDocument(int id) should either be moved to a subclass. same with setNorms?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or we could take the approach you suggested in &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/52017&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/52017&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That would mean to add a callback after flush to get a current IndexReader to get the docids and to use the IndexWriter then to perform deleteDocument(docId) or setNorm(). These methods could also take an IndexReader as argument, e. g. deleteDocument(IndexReader reader, int docId), which would throw an IOException if the passed in reader is stale (i. e. docids have changed since the reader was opened). Just as IndexReader does it today. Does this make sense or am I missing something?&lt;/p&gt;</comment>
                    <comment id="12535669" author="michaelbusch" created="Wed, 17 Oct 2007 19:35:47 +0100"  >&lt;p&gt;I just opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1030&quot; title=&quot;&amp;quot;Read-only&amp;quot; IndexReaders&quot;&gt;&lt;del&gt;LUCENE-1030&lt;/del&gt;&lt;/a&gt; and would like to move discussions related to &quot;read-only&quot; IndexReaders to that issue.&lt;/p&gt;

&lt;p&gt;As for reopen() I&apos;d like to go with Hoss&apos; suggestion for now and add warning comments to reopen() saying that using an re-opened IndexReader with closeOldReader==false for write operations will result in an undefined behavior. Any objections?&lt;/p&gt;</comment>
                    <comment id="12535743" author="yseeley@gmail.com" created="Wed, 17 Oct 2007 22:02:00 +0100"  >&lt;blockquote&gt;
&lt;p&gt;As for reopen() I&apos;d like to go with Hoss&apos; suggestion for now and add warning comments to reopen() saying that using an re-opened IndexReader with closeOldReader==false for write operations will result in an undefined behavior.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about just defining the behavior such that any pending changes are flushed.  That would make it more useful because you could then reopen readers you used for deletes.  An alternative would be a method to explicitly flush changes on a reader, giving one the ability to then reopen it, but  I like the former better since it avoids adding another API call.&lt;/p&gt;</comment>
                    <comment id="12535753" author="michaelbusch" created="Wed, 17 Oct 2007 22:23:30 +0100"  >&lt;blockquote&gt;
&lt;p&gt;How about just defining the behavior such that any pending changes are flushed. That would make it more useful because you could then reopen readers you used for deletes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, I&apos;m not sure I understand. A reader which is being used for deletes or setting norms is always current (it owns the write lock), so there should never be the need to re-open such a reader.&lt;/p&gt;

&lt;p&gt;However, if you re-open an existing reader which was not used for deletes before and use the new instance (b) to perform deletes, it will result in a undefined behavior for the old reader (a):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader a = .....
....
IndexReader b = a.reopen();
b.deleteDocument(...);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12535970" author="yseeley@gmail.com" created="Thu, 18 Oct 2007 17:55:12 +0100"  >&lt;blockquote&gt;
&lt;p&gt;A reader which is being used for deletes or setting norms is always current (it owns the write lock), so there should never be the need to re-open such a reader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was thinking about the &quot;add some docs&quot; then &quot;delete some docs&quot; scenario:&lt;br/&gt;
One currently needs to close() the deleting reader to open an IndexWriter.  If IndexReader.commit() was public, then one could simply flush changes, and then call reopen() after the IndexWriter was done adding new documents.  But perhaps longer term, all deletions should be done via the IndexWriter anyway.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if you re-open an existing reader which was not used for deletes before and use the new instance (b) to perform deletes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah, thanks for that clarification.  I guess that should remain undefined.&lt;/p&gt;</comment>
                    <comment id="12536028" author="michaelbusch" created="Thu, 18 Oct 2007 20:49:19 +0100"  >&lt;p&gt;Hmm one other thing: how should IndexReader.close() work? If we re-open a reader (a is the old reader, b is the new one), and then someone calls a.close(), then a should not close any resources that it shares with b. &lt;/p&gt;

&lt;p&gt;One way to make this work would be reference counting. Since we want to avoid that, we could simply restrict reopen() from being called twice for the same reader. Then there would never be more than 2 readers sharing the same ressources. The old reader a would remember that reopen() was called already and would not close the shared ressources on close(). However, the new reader b would close all ressources, meaning that reader a would not work anymore after b.close() was called. &lt;br/&gt;
Thoughts?&lt;/p&gt;</comment>
                    <comment id="12536033" author="mikemccand" created="Thu, 18 Oct 2007 21:03:05 +0100"  >&lt;p&gt;I think reference counting would solve this issue quite nicely.  How come we want to avoid reference counting?  It seems like the right solution here.&lt;/p&gt;

&lt;p&gt;The implementation seems simple.  When a reader is opened, it starts with RC 1.  When it is closed, it decrefs the RC and marks itself closed (to make sure double-close does not re-decref the RC).  When a MultiReader needs to use the reader, it calls incref.  And when that MultiReader is done with it, it calls decref.  Whenever the RC hits 0 it&apos;s safe to free all resources.&lt;/p&gt;

&lt;p&gt;Wouldn&apos;t that work?&lt;/p&gt;</comment>
                    <comment id="12536041" author="yseeley@gmail.com" created="Thu, 18 Oct 2007 21:35:03 +0100"  >&lt;p&gt;&amp;gt; When it is closed, it decrefs the RC and marks itself closed (to make sure double-close does not re-decref the RC)&lt;/p&gt;

&lt;p&gt;But if a reader is shared, how do you tell two real closes from an erronous double-close?  &lt;br/&gt;
Perhaps have a top level close() that is only invoked once via isClosed, and a projected doClose() that a multi-reader would use that actually does the decref?&lt;/p&gt;</comment>
                    <comment id="12536044" author="michaelbusch" created="Thu, 18 Oct 2007 21:43:57 +0100"  >&lt;blockquote&gt;
&lt;p&gt;The implementation seems simple. When a reader is opened, it starts with RC 1. When it is closed, it decrefs the RC and marks itself closed (to make sure double-close does not re-decref the RC). When a MultiReader needs to use the reader, it calls incref. And when that MultiReader is done with it, it calls decref. Whenever the RC hits 0 it&apos;s safe to free all resources.&lt;/p&gt;

&lt;p&gt;Wouldn&apos;t that work?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right, for a MultiReader and ParallelReader this would work and wouldn&apos;t be hard to implement. &lt;/p&gt;

&lt;p&gt;It is quite different when it comes to SegmentReaders. SegmentReader.reopen() checks SegmentInfos if there is a segment with the same name but newer normGen or delGen. If there is one then a new SegmentReader instance is created that reuses resources like e. g. TermInfosReader and loads the new generation of the del or norm file.&lt;/p&gt;

&lt;p&gt;Now you can end up having a bunch of SegmentReaders that share the same resources but don&apos;t know about each other. The reference counting would have to happen somewhere else, e. g. in the TermInfosReader. Of course this is doable, but it&apos;s a special case and more complicated compared to the &quot;restrict reopen() to only be called once&quot;-approach.&lt;/p&gt;</comment>
                    <comment id="12536063" author="mikemccand" created="Thu, 18 Oct 2007 22:53:38 +0100"  >&lt;p&gt;&amp;gt; But if a reader is shared, how do you tell two real closes from an erronous double-close?&lt;br/&gt;
&amp;gt; Perhaps have a top level close() that is only invoked once via isClosed, and a projected doClose() that a multi-reader would use that actually does the decref?&lt;/p&gt;

&lt;p&gt;Yes I think that&apos;s the right approach.&lt;/p&gt;

&lt;p&gt;&amp;gt; It is quite different when it comes to SegmentReaders. SegmentReader.reopen() checks SegmentInfos if there is a segment with the same name but newer normGen or delGen. If there is one then a new SegmentReader instance is created that reuses resources like e. g. TermInfosReader and loads the new generation of the del or norm file.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Now you can end up having a bunch of SegmentReaders that share the same resources but don&apos;t know about each other. The reference counting would have to happen somewhere else, e. g. in the TermInfosReader. Of course this is doable, but it&apos;s a special case and more complicated compared to the &quot;restrict reopen() to only be called once&quot;-approach.&lt;/p&gt;

&lt;p&gt;For SegmentReader, I think on reopen(), everything would be shared&lt;br/&gt;
except norms and/or deletedDocs right?  In which case couldn&apos;t all&lt;br/&gt;
cascaded reopens hold onto the original SegmentReader &amp;amp; call doClose()&lt;br/&gt;
on it when they are closed?  (Ie it is the &quot;owner&quot; of all the shared&lt;br/&gt;
parts of a SegmentReader).  Then, deletedDocs needs no protection (it&lt;br/&gt;
has no close()), and for Norms we could push the reference counting&lt;br/&gt;
down into it as well?&lt;/p&gt;

&lt;p&gt;We wouldn&apos;t need to push reference counting into all the readers that&lt;br/&gt;
a SegmentReader holds because those are always shared when a&lt;br/&gt;
SegmentReader is reopened?&lt;/p&gt;</comment>
                    <comment id="12536353" author="michaelbusch" created="Fri, 19 Oct 2007 22:49:45 +0100"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;I&apos;m not sure if I fully understand your comment. Consider the following (quite constructed) example:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  &lt;span class=&quot;code-comment&quot;&gt;// optimized index, reader1 is a SegmentReader
&lt;/span&gt;IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
... &lt;span class=&quot;code-comment&quot;&gt;// modify index2
&lt;/span&gt;IndexReader multiReader2 = multiReader1.reopen();  
&lt;span class=&quot;code-comment&quot;&gt;// only index2 changed, so multiReader2 uses reader1 and has to increment the refcount of reader1
&lt;/span&gt;... &lt;span class=&quot;code-comment&quot;&gt;// modify index1
&lt;/span&gt;IndexReader reader2 = reader1.reopen();
&lt;span class=&quot;code-comment&quot;&gt;// reader2 is a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; instance of SegmentReader that shares resources with reader1
&lt;/span&gt;... &lt;span class=&quot;code-comment&quot;&gt;// modify index1
&lt;/span&gt;IndexReader reader3 = reader2.reopen();
&lt;span class=&quot;code-comment&quot;&gt;// reader3 is a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; instance of SegmentReader that shares resources with reader1 and reader2&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now the user closes the readers in this order:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;multiReader1.close();&lt;/li&gt;
	&lt;li&gt;multiReader2.close();&lt;/li&gt;
	&lt;li&gt;reader2.close();&lt;/li&gt;
	&lt;li&gt;reader3.close();&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;reader1 should be marked as closed after 2., right? Because multiReader1.close() and multiReader2.close() have to decrement reader1&apos;s refcount. But the underlying files have to remain open until after 4., because reader2 and reader3 use reader1&apos;s resources.&lt;/p&gt;

&lt;p&gt;So don&apos;t we need 2 refcount values in reader1? One that tells us when the reader itself can be marked as closed, and one that tells when the resources can be closed? Then multiReader1 and multiReader2 would decrement the first refCount, whereas reader2 and reader3 both have to &quot;know&quot; reader1, so that they can decrement the second refcount.&lt;/p&gt;

&lt;p&gt;I hope I&apos;m just completely confused now and someone tells me that the whole thing is much simpler &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                    <comment id="12536409" author="mikemccand" created="Sat, 20 Oct 2007 10:09:31 +0100"  >&lt;p&gt;It&apos;s not nearly this complex (we don&apos;t need two ref counts). If we&lt;br/&gt;
follow the simple rule that &quot;every time reader X wants to use reader&lt;br/&gt;
Y, it increfs it&quot; and &quot;whenver reader X is done using reader Y, it&lt;br/&gt;
decrefs it&quot;,  all should work correctly.&lt;/p&gt;

&lt;p&gt;Also we should think of &quot;close()&quot; as the way that the external user&lt;br/&gt;
does the decref of their reader.  We just special-case this call, by&lt;br/&gt;
setting isOpen=false, to make sure we don&apos;t double decref on a double&lt;br/&gt;
close call.&lt;/p&gt;

&lt;p&gt;Let&apos;s walk through your example...&lt;/p&gt;

&lt;p&gt;I&apos;m assuming in your example you meant for reader2 and reader3 to also&lt;br/&gt;
be SegmentReaders?  Ie, the changes that are happening to the&lt;br/&gt;
single-segment index1 are just changes to norms and/or deletes.  If&lt;br/&gt;
not, the example is less interesting because reader1 will be closed&lt;br/&gt;
sooner &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Also in your example let&apos;s insert missing &quot;reader1.close()&quot; as the&lt;br/&gt;
very first close?  (Else it will never be closed because it&apos;s RC never&lt;br/&gt;
hits 0).&lt;/p&gt;

&lt;p&gt;When reader1 is created it has RC 1.&lt;/p&gt;

&lt;p&gt;When multiReader1 is created, reader1 now has RC 2.&lt;/p&gt;

&lt;p&gt;When multiReader2 is created, reader1 now has RC 3.&lt;/p&gt;

&lt;p&gt;When reader2 is created (by reader1.reopen()), it incref&apos;s reader1&lt;br/&gt;
because it&apos;s sharing the sub-readers in reader1.  So reader1 now has&lt;br/&gt;
RC 4.&lt;/p&gt;

&lt;p&gt;When reader3 was created (by reader2.reopen()), it incref&apos;s reader2&lt;br/&gt;
because it&apos;s sharing the sub-readers reader2 contains.  So reader1 is&lt;br/&gt;
still at RC 4 and reader2 is now at RC 2.&lt;/p&gt;

&lt;p&gt;Now, we close.&lt;/p&gt;

&lt;p&gt;After reader1.close() is called, reader1 sets isOpen=false (to prevent&lt;br/&gt;
double close by the user) and RC drops to 3.&lt;/p&gt;

&lt;p&gt;With multiReader1.close(), multiReader1 is not at RC 0, and so it&lt;br/&gt;
decrefs all readers it was using, and so reader1 RC is now 2.&lt;/p&gt;

&lt;p&gt;With multiReader2.close(), likewise it is now at RC 0 and so it&lt;br/&gt;
decrefs all readers it was using, and so reader1 RC is now 1.&lt;/p&gt;

&lt;p&gt;With reader2.close(), it decrefs its own RC, however that brings its&lt;br/&gt;
RC to 1 (reader3 is still referring to it) and so it does not decref&lt;br/&gt;
the reader1 that it&apos;s referring to.&lt;/p&gt;

&lt;p&gt;Finally, with reader3.close(), it is now at RC 0 and so it decrefs the&lt;br/&gt;
reader2 it refers to.  This brings reader2&apos;s RC to 0, and so reader2&lt;br/&gt;
decrefs the reader1 that it&apos;s referring to.  Which brings reader1&apos;s RC&lt;br/&gt;
to 0, and so reader1 finally closes all its internal sub-readers.&lt;/p&gt;</comment>
                    <comment id="12536413" author="michaelbusch" created="Sat, 20 Oct 2007 10:46:35 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;m assuming in your example you meant for reader2 and reader3 to also&lt;br/&gt;
be SegmentReaders?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes that&apos;s what I meant. Sorry, I didn&apos;t make that clear.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Also in your example let&apos;s insert missing &quot;reader1.close()&quot; as the&lt;br/&gt;
very first close? (Else it will never be closed because it&apos;s RC never&lt;br/&gt;
hits 0).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Doesn&apos;t what you describe change the semantics of MultiReader.close()?&lt;/p&gt;

&lt;p&gt;If you do:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  
IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
multiReader1.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then today multiReader1.close() also closes reader1. That&apos;s why I consciously omitted reader1.close().&lt;/p&gt;

&lt;p&gt;Consequently, if you do&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  
IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
IndexReader multiReader2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index3)});
multiReader1.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then multiReader2 is not usable anymore, because multiReader1.close() closes reader1. But that can be explicitly avoided by the user because it&apos;s known that multiReader1 and multiReader2 share the same reader.&lt;/p&gt;

&lt;p&gt;Now, with the reopen() code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  &lt;span class=&quot;code-comment&quot;&gt;// optimized index, reader1 is a SegmentReader
&lt;/span&gt;IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
... &lt;span class=&quot;code-comment&quot;&gt;// modify index2
&lt;/span&gt;IndexReader multiReader2 = multiReader1.reopen();  
&lt;span class=&quot;code-comment&quot;&gt;// only index2 changed, so multiReader2 uses reader1 and has to increment the refcount of reader1&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The user gets a new reader instance from multiReader.reopen(), but can&apos;t tell which of the subreaders has been reopened and which are shared. That&apos;s why multiReader1.close() should not close reader1 in this case and we need refcounting in order to make this work.&lt;/p&gt;

&lt;p&gt;So do you suggest that a MultiReader should increment the refcounts when it is opened as well (in the constructor)? I believe we can implement it like this, but as I said it changes the semantics of MultiReader.close() (and ParallelReader.close() is, I believe, the same). A user would then have to close subreaders manually.&lt;/p&gt;
</comment>
                    <comment id="12536418" author="mikemccand" created="Sat, 20 Oct 2007 11:45:29 +0100"  >&lt;blockquote&gt;
&lt;p&gt;If you do:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  
IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
multiReader1.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then today multiReader1.close() also closes reader1. That&apos;s why I consciously omitted reader1.close().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh, I missed that MultiReader is allowed to close all readers that&lt;br/&gt;
were passed into it, when it is closed.  OK, let&apos;s leave&lt;br/&gt;
reader1.close() out of the example.&lt;/p&gt;

&lt;p&gt;It&apos;s somewhat &quot;aggressive&quot; of MultiReader/ParallelReader to do that?&lt;br/&gt;
If you go and use those same sub-readers in other MultiReaders then&lt;br/&gt;
they closing of the first MultiReader will then break the other ones?&lt;/p&gt;

&lt;p&gt;I think we are forced to keep this semantics, for backwards&lt;br/&gt;
compatibility.  But I don&apos;t really think MultiReader/ParallelReader&lt;br/&gt;
should actually be this aggressive.  Maybe in the future we can add&lt;br/&gt;
ctors for MultiReader/ParallelReader that accept a &quot;doClose&quot; boolean&lt;br/&gt;
to turn this off.&lt;/p&gt;

&lt;p&gt;Anyway, it&apos;s simple to preserve this semantics with reference&lt;br/&gt;
counting.  It just means that IndexReader / MultiReader do not incref&lt;br/&gt;
the readers they receive, and, when they are done with those readers,&lt;br/&gt;
they must call their close(), not decref.  Ie they &quot;borrow the&lt;br/&gt;
reference&quot; that was passed in, rather than incref&apos;ing their own&lt;br/&gt;
reference, to the child readers.&lt;/p&gt;

&lt;p&gt;With that change, plus the change below, your example works fine.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Consequently, if you do&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  
IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
IndexReader multiReader2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index3)});
multiReader1.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;then multiReader2 is not usable anymore, because multiReader1.close() closes reader1. But that can be explicitly avoided by the user because it&apos;s known that multiReader1 and multiReader2 share the same reader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is why I don&apos;t like the semantics we have today &amp;#8211; I don&apos;t think&lt;br/&gt;
it&apos;s right that the multiReader1.close() breaks multiReader2.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Now, with the reopen() code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader reader1 = IndexReader.open(index1);  &lt;span class=&quot;code-comment&quot;&gt;// optimized index, reader1 is a SegmentReader
&lt;/span&gt;IndexReader multiReader1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MultiReader(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[] {reader1, IndexReader.open(index2)});
... &lt;span class=&quot;code-comment&quot;&gt;// modify index2
&lt;/span&gt;IndexReader multiReader2 = multiReader1.reopen();  
&lt;span class=&quot;code-comment&quot;&gt;// only index2 changed, so multiReader2 uses reader1 and has to increment the refcount of reader1&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The user gets a new reader instance from multiReader.reopen(), but can&apos;t tell which of the subreaders has been reopened and which are shared. That&apos;s why multiReader1.close() should not close reader1 in this case and we need refcounting in order to make this work.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Both of these cases are easy to fix with reference counting: we just&lt;br/&gt;
have to change ensureOpen() to assert that RC &amp;gt; 0 instead of&lt;br/&gt;
closed==false.  Ie, a reader may still be used as long as its RC is&lt;br/&gt;
still non-zero.&lt;/p&gt;</comment>
                    <comment id="12536419" author="mikemccand" created="Sat, 20 Oct 2007 12:05:46 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I think we are forced to keep this semantics, for backwards&lt;br/&gt;
compatibility.  But I don&apos;t really think MultiReader/ParallelReader&lt;br/&gt;
should actually be this aggressive.  Maybe in the future we can add&lt;br/&gt;
ctors for MultiReader/ParallelReader that accept a &quot;doClose&quot; boolean&lt;br/&gt;
to turn this off.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually I retract this: it&apos;s no longer necessary as long as we change&lt;br/&gt;
ensureOpen to assert that RC &amp;gt; 0 instead of closed==false.&lt;/p&gt;

&lt;p&gt;I think this is actually a nice unexpected side-effect of using&lt;br/&gt;
reference counting: it resolves this overly aggressive behavior of&lt;br/&gt;
MultiReader/ParallelReader.&lt;/p&gt;</comment>
                    <comment id="12536805" author="michaelbusch" created="Mon, 22 Oct 2007 20:36:00 +0100"  >&lt;blockquote&gt;
&lt;p&gt;With that change, plus the change below, your example works fine.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Two things:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;MultiReader/ParallelReader must not incref the subreaders on open()&lt;br/&gt;
as you said. But on reopen() it must incref the subreaders that &lt;br/&gt;
haven&apos;t changed and thus are shared with the old MultiReader/&lt;br/&gt;
ParallelReader. This further means, that the re-opened MultiReader/&lt;br/&gt;
ParallelReader must remember which of the subreaders to decref on&lt;br/&gt;
close(), right?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If we change ensureOpen() like you suggest, then the user might&lt;br/&gt;
still be able to use reader1 (in my example), even after &lt;br/&gt;
reader1.close() was explicitly called. Probably not a big deal?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12536827" author="mikemccand" created="Mon, 22 Oct 2007 21:36:03 +0100"  >&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;MultiReader/ParallelReader must not incref the subreaders on open()&lt;br/&gt;
      as you said. But on reopen() it must incref the subreaders that&lt;br/&gt;
      haven&apos;t changed and thus are shared with the old MultiReader/&lt;br/&gt;
      ParallelReader. This further means, that the re-opened MultiReader/&lt;br/&gt;
      ParallelReader must remember which of the subreaders to decref on&lt;br/&gt;
      close(), right?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hmm, right.  MultiReader/ParallelReader must keep track of whether it&lt;br/&gt;
should call decref() or close() on each of its child readers, when it&lt;br/&gt;
itself is closed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;If we change ensureOpen() like you suggest, then the user might&lt;br/&gt;
      still be able to use reader1 (in my example), even after&lt;br/&gt;
      reader1.close() was explicitly called. Probably not a big deal?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think this is OK?&lt;/p&gt;</comment>
                    <comment id="12536845" author="michaelbusch" created="Mon, 22 Oct 2007 22:35:46 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I think this is OK?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was essentially the reason why I suggested to use two refcount values:&lt;br/&gt;
one to control when to close a reader, and one to control when to close&lt;br/&gt;
it&apos;s (shared) resources in case of SegmentReader. That approach would not&lt;br/&gt;
alter the behaviour of IndexReader.close(). &lt;br/&gt;
But I agree that your approach is simpler and I also think it is okay to &lt;br/&gt;
change ensureOpen() and accept the slight API change.&lt;/p&gt;

&lt;p&gt;So I&apos;ll go ahead and implement the refcount approach unless anybody objects.&lt;/p&gt;

&lt;p&gt;Oh and Mike, thanks for bearing with me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12536848" author="yseeley@gmail.com" created="Mon, 22 Oct 2007 22:54:41 +0100"  >&lt;p&gt;What about a new constructor for MultiReader/ParallelReader that implements more sensible semantics (increment refcount on readers passed to it, and decrement on close())?&lt;/p&gt;</comment>
                    <comment id="12536862" author="michaelbusch" created="Tue, 23 Oct 2007 00:06:51 +0100"  >&lt;blockquote&gt;
&lt;p&gt;What about a new constructor for MultiReader/ParallelReader that implements more sensible semantics (increment refcount on readers passed to it, and decrement on close())?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, when reference counting is implemented then such a constructor should be easy to add.&lt;/p&gt;</comment>
                    <comment id="12536866" author="mikemccand" created="Tue, 23 Oct 2007 00:31:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Oh and Mike, thanks for bearing with me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thank you for bearing with me!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What about a new constructor for MultiReader/ParallelReader that implements more sensible semantics (increment refcount on readers passed to it, and decrement on close())?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12538590" author="michaelbusch" created="Mon, 29 Oct 2007 20:53:24 +0000"  >&lt;p&gt;Ok here is the next one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;...&lt;/p&gt;

&lt;p&gt;This patch implements the refCounting as discussed with Mike and Yonik&lt;br/&gt;
above.&lt;/p&gt;

&lt;p&gt;Other changes/improvements/comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ensureOpen() is now also called in MultiReader.reopen() and&lt;br/&gt;
ParallelReader.reopen(). (thanks, Mike)&lt;/li&gt;
	&lt;li&gt;in case an exception occurs during reopen() it is taken care of&lt;br/&gt;
closing or decreasing the refCount of already created readers.&lt;br/&gt;
Also old readers should not be affected in case an exception occurs.&lt;/li&gt;
	&lt;li&gt;I improved how norms are re-opened in a MultiSegmentReader (MSR).&lt;br/&gt;
It now checks which parts of the normsCache haven&apos;t changed and &lt;br/&gt;
copies those to the new normsCache. Because I&apos;m imagining Yonik with &lt;br/&gt;
his thread-safety hat on now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, another comment about this: In case &lt;br/&gt;
a MSR is refreshed, then the synchronized MSR.reopen() method has the &lt;br/&gt;
lock on the old MSR. This method creates the new MSR and the values&lt;br/&gt;
from the old cache are copied to the new cache in the constructor, so&lt;br/&gt;
while the lock on the old MSR is still being held.&lt;/li&gt;
	&lt;li&gt;added new constructors to MultiReader and ParallelReader that&lt;br/&gt;
increase the refCount on the subReaders and thus prevent closing the&lt;br/&gt;
subReaders on close(). (thanks, Yonik)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I also made the changes suggested by Hoss (thanks!):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;changed the &quot;successfully reopened&quot; comments int the javadocs&lt;/li&gt;
	&lt;li&gt;added comments to the javadocs saying that write operations on the&lt;br/&gt;
re-opened reader will result in undefined behavior unless the old &lt;br/&gt;
reader is closed&lt;/li&gt;
	&lt;li&gt;FilterIndexReader.reopen() not implemented, i. e. will throw an&lt;br/&gt;
UnsupportedOperationException.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All unit tests pass.&lt;/p&gt;</comment>
                    <comment id="12538705" author="mikemccand" created="Tue, 30 Oct 2007 08:55:11 +0000"  >&lt;p&gt;Patch looks great!  I&apos;m still working through it but found a few small&lt;br/&gt;
issues...&lt;/p&gt;

&lt;p&gt;It might be good to put a &quot;assert refCount &amp;gt; 0&quot; at various places like&lt;br/&gt;
decRef(), incRef(), ensureOpen()?  That would require changing the&lt;br/&gt;
constructors to init refCount=1 rather than incRef() it to 1.&lt;/p&gt;

&lt;p&gt;I&apos;m seeing a failure in contrib/memory testcase:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    [junit] *********** FILE=./NOTICE.txt
    [junit] Fatal error at query=Apache, file=./NOTICE.txt, anal=org.apache.lucene.analysis.SimpleAnalyzer@341960
    [junit] ------------- ---------------- ---------------
    [junit] Testcase: testMany(org.apache.lucene.index.memory.MemoryIndexTest):	Caused an ERROR
    [junit] &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed
    [junit] org.apache.lucene.store.AlreadyClosedException: &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed
    [junit] 	at org.apache.lucene.index.IndexReader.ensureOpen(IndexReader.java:158)
    [junit] 	at org.apache.lucene.index.IndexReader.termDocs(IndexReader.java:632)
    [junit] 	at org.apache.lucene.search.TermQuery$TermWeight.scorer(TermQuery.java:64)
    [junit] 	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:143)
    [junit] 	at org.apache.lucene.search.Searcher.search(Searcher.java:118)
    [junit] 	at org.apache.lucene.search.Searcher.search(Searcher.java:97)
    [junit] 	at org.apache.lucene.index.memory.MemoryIndexTest.query(MemoryIndexTest.java:412)
    [junit] 	at org.apache.lucene.index.memory.MemoryIndexTest.run(MemoryIndexTest.java:313)
    [junit] 	at org.apache.lucene.index.memory.MemoryIndexTest.testMany(MemoryIndexTest.java:234)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think it&apos;s because MemoryIndexReader (private class in&lt;br/&gt;
MemoryIndex.java) calls super(null) =&lt;br/&gt;
IndexReader.IndexReader(Directory) in its constructor, which does not&lt;br/&gt;
initialize the refCount to 1?  If I insert incRef() into&lt;br/&gt;
IndexReader.IndexReader(Directory) constructor, the test passes, but&lt;br/&gt;
who else is using that constructor (ie will this double-incref in&lt;br/&gt;
those cases?).&lt;/p&gt;</comment>
                    <comment id="12538743" author="mikemccand" created="Tue, 30 Oct 2007 11:41:25 +0000"  >&lt;p&gt;OK I think this patch is very close!  I finished reviewing it &amp;#8211;&lt;br/&gt;
here&apos;s some more feedback:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In multiple places you catch an IOException and undo the attempted&lt;br/&gt;
    re-open, but shouldn&apos;t this be a try/finally instead so you also&lt;br/&gt;
    clean up on hitting any unchecked exceptions?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I think you need an explicit refCount for the Norm class in&lt;br/&gt;
    SegmentReader.&lt;br/&gt;
    .&lt;br/&gt;
    Say I&apos;ve done a chain of 10 re-opens for SegmentReader and each&lt;br/&gt;
    time only the segment&apos;s norms has changed.  I&apos;ve closed all but&lt;br/&gt;
    the last SegmentReader.  At this point all 10 SegmentReaders are&lt;br/&gt;
    still alive (RC &amp;gt; 0) and holding open all file handles for their&lt;br/&gt;
    copies of the norms.  So this will leak file handles/RAM with each&lt;br/&gt;
    reopen?&lt;br/&gt;
   .&lt;br/&gt;
    To fix this, I think you just need to add refCount into Norm class&lt;br/&gt;
    &amp;amp; set refCount to 1 in the constructor.  Then, each each&lt;br/&gt;
    SegmentReader calls Norm.decRef(), not Norm.close(), when it&apos;s&lt;br/&gt;
    done.  When refCount hits 0 then the Norm closes itself.  Finally,&lt;br/&gt;
    during re-open you should share a Norm instance (rather than open&lt;br/&gt;
    a new one) if it had not changed from the previous SegmentReader.&lt;br/&gt;
  .&lt;br/&gt;
    For singleNormStream, I think each reopened SegmentReader should&lt;br/&gt;
    always re-open this descriptor and then we can forcefully close&lt;br/&gt;
    this stream when the SegmentReader is closed (what you are doing&lt;br/&gt;
    now).  Ie the SegmentReader fully owns singleNormStream.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If you have a long series of reopens, then, all SegmentReaders in&lt;br/&gt;
    the chain will remain alive.  So this is a &lt;span class=&quot;error&quot;&gt;&amp;#91;small&amp;#93;&lt;/span&gt; memory leak&lt;br/&gt;
    with time.  I think if you changed referencedSegmentReader to&lt;br/&gt;
    always be the &lt;b&gt;starting&lt;/b&gt; SegmentReader then this chain is broken&lt;br/&gt;
    and after 10 reopens only the original SegmentReader and the most&lt;br/&gt;
    recent one will remain alive (assuming I closed all SegmentReaders&lt;br/&gt;
    but the most recent one).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12539016" author="buschmic" created="Wed, 31 Oct 2007 07:02:46 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Patch looks great!  I&apos;m still working through it but found a few small&lt;br/&gt;
issues...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Thanks Mike! Very good review and feedback!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It might be good to put a &quot;assert refCount &amp;gt; 0&quot; at various places like...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Agreed. I added those asserts to incRef() and decRef(). I didn&apos;t add it&lt;br/&gt;
to ensureOpen(), because it throws an AlreadyClosedException anyway, and&lt;br/&gt;
some testcases check if this exception is thrown.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m seeing a failure in contrib/memory testcase:&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oups, I fixed this already. I changed the (deprecated) ctr &lt;br/&gt;
IndexReader.IndexReader(Directory) to call this() which sets the refCount &lt;br/&gt;
to 1. The test passes then. I made this fix yesterday, I think I just &lt;br/&gt;
forgot to update the patch file before I submitted it, sorry about this.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In multiple places you catch an IOException and undo the attempted&lt;br/&gt;
    re-open, but shouldn&apos;t this be a try/finally instead so you also&lt;br/&gt;
    clean up on hitting any unchecked exceptions?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes of course! Changed it.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I think you need an explicit refCount for the Norm class in&lt;br/&gt;
    SegmentReader.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK I see. I made this change as well. I also made the change that&lt;br/&gt;
there is no chain, but one starting SegmentReader which all re-opened &lt;br/&gt;
ones reference (see below). Now this starting SegmentReader won&apos;t close &lt;br/&gt;
its norms until all other readers that reference it are closed (RC=0),&lt;br/&gt;
because only then doClose() is called, which calls closeNorms().&lt;br/&gt;
Do you see an easy way how to improve this?&lt;br/&gt;
Hmm, probably I have to definalize IndexReader.incRef() and decRef()&lt;br/&gt;
and overwrite them in SegmentReader. Then SegmentReader.incRef() would&lt;br/&gt;
also incRef the norms, SegmentReader.decref() would decref the norms,&lt;br/&gt;
and somehow a clone that shares references the reader but not the norms&lt;br/&gt;
(because they changed) would only incref the reader itself, but not&lt;br/&gt;
the norms... Or do you see an easier way?&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If you have a long series of reopens, then, all SegmentReaders in&lt;br/&gt;
    the chain will remain alive.  So this is a &lt;span class=&quot;error&quot;&gt;&amp;#91;small&amp;#93;&lt;/span&gt; memory leak&lt;br/&gt;
    with time.  I think if you changed referencedSegmentReader to&lt;br/&gt;
    always be the &lt;b&gt;starting&lt;/b&gt; SegmentReader then this chain is broken&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Good point. Ok I changed this and also the test cases that check the refCount&lt;br/&gt;
values.&lt;/p&gt;</comment>
                    <comment id="12539139" author="mikemccand" created="Wed, 31 Oct 2007 18:04:28 +0000"  >&lt;p&gt;Looks great!  All tests pass for me.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OK I see. I made this change as well. I also made the change that&lt;br/&gt;
there is no chain, but one starting SegmentReader which all re-opened&lt;br/&gt;
ones reference (see below). Now this starting SegmentReader won&apos;t close&lt;br/&gt;
its norms until all other readers that reference it are closed (RC=0),&lt;br/&gt;
because only then doClose() is called, which calls closeNorms().&lt;br/&gt;
Do you see an easy way how to improve this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about if SegmentReader.close() always calls Norm.decRef(),&lt;br/&gt;
immediately, for each Norm is has open?  EG you could implement&lt;br/&gt;
doCloseUnsharedResources in SegmentReader and do it there).  This way,&lt;br/&gt;
if the SegmentReader has been closed but it shares resources (and not&lt;br/&gt;
the Norms) with reopened SegmentReaders then its Norms would all&lt;br/&gt;
decRef to 0 &amp;amp; be closed.&lt;/p&gt;

&lt;p&gt;Also make sure that if a SegmentReader is decRef&apos;d to 0 and close was&lt;br/&gt;
never called, that also in this case you remember to call Norm.decRef&lt;br/&gt;
for all open norms.&lt;/p&gt;

&lt;p&gt;One more comment: I think you can partially share Norm instances?  Eg&lt;br/&gt;
if I have 2 fields that have norms, but only one of them changed since&lt;br/&gt;
I opened this SegmentReader, then the reopened SegmentReader could&lt;br/&gt;
share the Norm instance of the field that didn&apos;t change with the old&lt;br/&gt;
SegmentReader?  But right now you&apos;re re-loading all the Norms.&lt;/p&gt;

&lt;p&gt;Otherwise no more comments!&lt;/p&gt;</comment>
                    <comment id="12539208" author="buschmic" created="Wed, 31 Oct 2007 22:56:20 +0000"  >&lt;blockquote&gt;
&lt;p&gt;How about if SegmentReader.close() always calls Norm.decRef(),&lt;br/&gt;
immediately, for each Norm is has open?  EG you could implement&lt;br/&gt;
doCloseUnsharedResources in SegmentReader and do it there).  This way,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm I was thinking about this before (that&apos;s actually why I put that&lt;br/&gt;
method in there). But I don&apos;t think this is gonna work. For example,&lt;br/&gt;
let&apos;s say we use a MultiReader that has two SegmentReader SR1 and SR2.&lt;br/&gt;
Now only SR2 changed, we reopen the MR which increases the refCount on&lt;br/&gt;
SR1, because it shares that SR. Now we close the old MultiReader, which&lt;br/&gt;
calls close() on SR1. If now SegmentReader.close() calls Norm.decRef(), &lt;br/&gt;
then it will close the norms even though they are still used by the new&lt;br/&gt;
MultiReader.&lt;/p&gt;</comment>
                    <comment id="12539209" author="buschmic" created="Wed, 31 Oct 2007 22:56:54 +0000"  >&lt;blockquote&gt;
&lt;p&gt;One more comment: I think you can partially share Norm instances? Eg&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good idea! Will make the change.&lt;/p&gt;</comment>
                    <comment id="12539359" author="mikemccand" created="Thu, 1 Nov 2007 13:12:16 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Hmm I was thinking about this before (that&apos;s actually why I put that&lt;br/&gt;
method in there). But I don&apos;t think this is gonna work. For example,&lt;br/&gt;
let&apos;s say we use a MultiReader that has two SegmentReader SR1 and SR2.&lt;br/&gt;
Now only SR2 changed, we reopen the MR which increases the refCount on&lt;br/&gt;
SR1, because it shares that SR. Now we close the old MultiReader, which&lt;br/&gt;
calls close() on SR1. If now SegmentReader.close() calls Norm.decRef(), &lt;br/&gt;
then it will close the norms even though they are still used by the new&lt;br/&gt;
MultiReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ugh, you&apos;re right.  The challenge is sometimes a reference to SR means&lt;br/&gt;
&quot;I will use norms&quot; (this is when MultiReader incRefs) but other times&lt;br/&gt;
it means &quot;I will not use norms&quot; (this is when SR incRefs due to&lt;br/&gt;
reopen).&lt;/p&gt;

&lt;p&gt;OK, I like your original proposal: SR overrides incRef() and incrs its&lt;br/&gt;
RC as well as the RC for each Norm it&apos;s using.  Then, in SR&apos;s&lt;br/&gt;
reopenSegment, you carefully incRef the &quot;original&quot; SR without&lt;br/&gt;
incRef&apos;ing its Norms (except for those Norms you will keep).&lt;/p&gt;

&lt;p&gt;Likewise, SR overrides decRef() to decr its RC and RC for each Norm.&lt;br/&gt;
But, when a reopened SR1.doClose() is called, you must carefully&lt;br/&gt;
decRef the RD of the original SR but not decRef each of its Norms&lt;br/&gt;
(except for those you had actually shared).&lt;/p&gt;

&lt;p&gt;This way when MR calls SR.incRef/decRef then all Norms and the SR&apos;s RC&lt;br/&gt;
are incr&apos;d/decr&apos;d.  But when SR1 shares resources with an original SR&lt;br/&gt;
it only incr&apos;s/decr&apos;s the refCount of the SR.&lt;/p&gt;</comment>
                    <comment id="12539554" author="michaelbusch" created="Fri, 2 Nov 2007 09:53:07 +0000"  >&lt;p&gt;OK, I think it&apos;s finally working now! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;SegmentReader now overwrites incRef() and increments the readers RC,&lt;br/&gt;
as well as the RCs of all norms. I further added the private method&lt;br/&gt;
incRefReaderNotNorms() to SegmentReader, which is called in &lt;br/&gt;
reopenSegment(), because it takes care of incrementing the RCs of&lt;br/&gt;
all shared norms.&lt;/p&gt;

&lt;p&gt;I also added the method doCloseUnsharedResources() to IndexReader,&lt;br/&gt;
which is a NOOP by default. It is called when a reader is closed,&lt;br/&gt;
even if its RC &amp;gt; 0. SegmentReader overwrites this method and &lt;br/&gt;
closes (=decRef) the norms in it. The SegmentReader then remembers&lt;br/&gt;
that it closed the norms already and won&apos;t close them again in&lt;br/&gt;
doClose(), which is called when its RC finally drops to 0.&lt;/p&gt;

&lt;p&gt;I also made the change you suggested, Mike, to only reload the &lt;br/&gt;
field norms that actually changed. SegmentReader.openNorms() now&lt;br/&gt;
checks if there is already a norm for a field in the HashTable,&lt;br/&gt;
and only loads it if it&apos;s not there. reopenSegment() puts all&lt;br/&gt;
norms in the new SegmentReader that haven&apos;t changed.&lt;/p&gt;

&lt;p&gt;I added some new tests to verify the norms ref counting. All unit&lt;br/&gt;
tests pass now. So I think this is ready to commit, but I&apos;d feel &lt;br/&gt;
more comfortable if you could review it again before I commit it.&lt;/p&gt;</comment>
                    <comment id="12539588" author="yseeley@gmail.com" created="Fri, 2 Nov 2007 14:09:40 +0000"  >&lt;p&gt;I just did a quick partial review of SegmentReader for thread safety only and ran across some potential issues&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It looks like fieldsReader is shared between clones(), and that isn&apos;t thread-safe (synchronization is done at the SegmentReader level, and now there is more than one)&lt;/li&gt;
	&lt;li&gt;maybe the same issue with deletedDocs?  mutual exclusion is no longer enforced.&lt;/li&gt;
	&lt;li&gt;it looks like the norms Hashtable could be shared... looping over the individual norms and calling incRef doesn&apos;t seem safe for a number of reasons (for example, you might miss some just being added)&lt;/li&gt;
	&lt;li&gt;reading new norms isn&apos;t safe...&lt;br/&gt;
  synchronized norms(String field, byte[] bytes, int offset) uses the &quot;norm&apos; IndexInput that is shared.  synchronization on a single reader no longer guarantees mutual exclusion.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There&apos;s probably other stuff, but I stopped looking.  Since we are sharing things now, every method that was synchronized is now potentially unsafe.  Synchronizing on the object being shared is probably a much better strategy now.&lt;/p&gt;

&lt;p&gt;This is complex enough that in addition to review, I think we need a good multi-threaded test - 100 or 1000 threads over a ram directory, all changing, querying, retrieving docs, reopening, closing, etc.&lt;/p&gt;</comment>
                    <comment id="12539596" author="yseeley@gmail.com" created="Fri, 2 Nov 2007 14:37:34 +0000"  >&lt;p&gt;It also looks like Norm.incRef is used in an unsafe manner (unsynchronized, or synchronized on the reader), and also Norm.decRef() is called inside a synchronized(norms) block, but an individual Norm may be shared across multiple Hashtables, right?&lt;/p&gt;

&lt;p&gt;I don&apos;t think that norms even needs to be a synchronized Hashtable... it could be changed to a HashMap since it&apos;s contents never change, right?&lt;/p&gt;</comment>
                    <comment id="12539598" author="mikemccand" created="Fri, 2 Nov 2007 14:43:14 +0000"  >
&lt;p&gt;OK, reviewed the latest patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;In this code:
  &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;// singleNormFile means multiple norms share &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; file
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (fileName.endsWith(&lt;span class=&quot;code-quote&quot;&gt;&quot;.&quot;&lt;/span&gt; + IndexFileNames.NORMS_EXTENSION)) {
  clone.singleNormStream = d.openInput(fileName, readBufferSize);            
}
  &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  I think the comment should be removed (it doens&apos;t apply) and also&lt;br/&gt;
  won&apos;t this incorrectly open the singleNormStream more than once if&lt;br/&gt;
  more than one field does not have separate norms?  I think you should&lt;br/&gt;
  init that to null and then only reopen it, once, if it&apos;s still null?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In MultiSegmentReader, the logic that copies over unchanged norms&lt;br/&gt;
  from the old norms cache can be simplified.  I think you can just&lt;br/&gt;
  look up the old Norm instance &amp;amp; the new Norm instance and if they&lt;br/&gt;
  are == then you can copy bytes over?  This would also let you remove&lt;br/&gt;
  &quot;sharedNorms&quot; entirely which is good because it&apos;s not a just a&lt;br/&gt;
  boolean thing anymore since some Norm instances are shared and some&lt;br/&gt;
  aren&apos;t.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think you also need to override decRef (and add&lt;br/&gt;
  decRefReaderNotNorms) to SegmentReader?  Because now there is a&lt;br/&gt;
  mismatch: incRef incr&apos;s the Norm RC&apos;s, but, decRef does not.  So I&lt;br/&gt;
  think norms are not getting closed?  I think we should modify the&lt;br/&gt;
  &quot;assertReaderClosed()&quot; in the unit test to verify (when appropriate)&lt;br/&gt;
  that also the RC of all Norm instances is also 0 (ie&lt;br/&gt;
  assertTrue(SR.normsClosed())).  Then, make sure SR calls&lt;br/&gt;
  referencedSegmentReader.decRefReaderNotNorms instead of decRef.  I&lt;br/&gt;
  think you then don&apos;t need to track &quot;closedNorms&quot; boolean, at all.&lt;br/&gt;
  You simply always decRef the norms whenever SR.decRef is called.&lt;br/&gt;
  The doCloseUnsharedResources is still needed to close the&lt;br/&gt;
  singleNormStream.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12539600" author="mikemccand" created="Fri, 2 Nov 2007 14:47:05 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This is complex enough that in addition to review, I think we need a&lt;br/&gt;
good multi-threaded test - 100 or 1000 threads over a ram directory,&lt;br/&gt;
all changing, querying, retrieving docs, reopening, closing, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;We should fix all the synchronization issues you&apos;ve found, create this&lt;br/&gt;
unit test, and then iterate from there.&lt;/p&gt;</comment>
                    <comment id="12539606" author="yseeley@gmail.com" created="Fri, 2 Nov 2007 14:57:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;We should fix all the synchronization issues you&apos;ve found, create this&lt;br/&gt;
unit test, and then iterate from there.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or reverse it... write the test first so we have confidence that it can at least uncover some of these issues.&lt;br/&gt;
The test should do as little synchronization as possible of it&apos;s own so it doesn&apos;t mask a lack of synchronization in the core.&lt;br/&gt;
It should be possible to uncover the unsynchronized concurrent use of IndexInput at least, and hopefully some of the refcounting issues too.&lt;/p&gt;</comment>
                    <comment id="12539610" author="mikemccand" created="Fri, 2 Nov 2007 15:08:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Or reverse it... write the test first so we have confidence that it can at least uncover some of these issues.&lt;br/&gt;
The test should do as little synchronization as possible of it&apos;s own so it doesn&apos;t mask a lack of synchronization in the core.&lt;br/&gt;
It should be possible to uncover the unsynchronized concurrent use of IndexInput at least, and hopefully some of the refcounting issues too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Excellent, I agree!&lt;/p&gt;</comment>
                    <comment id="12539634" author="michaelbusch" created="Fri, 2 Nov 2007 16:32:18 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I just did a quick partial review of SegmentReader for thread safety only and ran across some potential issues&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, let&apos;s scratch my &quot;ready to commit&quot; comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;A question about thread-safety here. I agree that we must&lt;br/&gt;
fix all possible problems concerning two or more &lt;br/&gt;
IndexReaders in &lt;b&gt;read-mode&lt;/b&gt;, like the FieldsReader issue.&lt;/p&gt;

&lt;p&gt;On the other hand: We&apos;re saying that performing write&lt;br/&gt;
operations on a re-opened reader results in undefined&lt;br/&gt;
behavior. Some of the issues you mentioned, Yonik, should &lt;br/&gt;
only apply in case one of the shared readers is used to&lt;br/&gt;
perform index modifications, right? Then the question is: &lt;br/&gt;
how much sense does it make to make reopen() thread-safe &lt;br/&gt;
in the write case then?&lt;/p&gt;

&lt;p&gt;So I think the multi-threaded testcase should not&lt;br/&gt;
perform index modifications using readers involved in a&lt;br/&gt;
reopen()?&lt;/p&gt;
</comment>
                    <comment id="12539637" author="yseeley@gmail.com" created="Fri, 2 Nov 2007 16:58:53 +0000"  >&lt;p&gt;Sorry, I hadn&apos;t kept up with this issue wrt what was going to be legal (and we should definitely only test what will be legal in the MT test).   So that removes the deletedDocs issue I guess.&lt;/p&gt;</comment>
                    <comment id="12540145" author="tpeuss" created="Mon, 5 Nov 2007 07:34:11 +0000"  >&lt;p&gt;To find concurrency issues with an unit test is hard to do, because your potential problems lie in the time domain and not in the code domain. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;From my experience following things can have impact on the results of such a test:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Running on SP or SMP machines. SMP machines (the more cores the better) reveal concurrency issues much earlier.&lt;/li&gt;
	&lt;li&gt;The Java implementation you are using. IBM&apos;s and Sun&apos;s thread implementations behave slightly different for example.&lt;/li&gt;
	&lt;li&gt;The OS you are running. This may seem odd in the first run but remember that modern Java implementations rely heavily on the threading implementations of the OS.&lt;/li&gt;
	&lt;li&gt;The processor platform you are running. NUMA vs. UMA (which is AMD vs. intel). The timing of threads can differ because of this.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And be prepared that one time your tests runs through without a problem and on the next run it breaks...&lt;/p&gt;

&lt;p&gt;Just my &#8364; 0.02&lt;/p&gt;</comment>
                    <comment id="12541517" author="michaelbusch" created="Sat, 10 Nov 2007 06:47:42 +0000"  >&lt;p&gt;Changes in this patch:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Fixed ParallelReader and MultiReader so that they don&apos;t incRef the subreaders anymore in case reopen() is a NOOP (i. e. reopen() doesn&apos;t return a new instance)&lt;/li&gt;
	&lt;li&gt;In the new ctr in MultiSegmentReader it was possible to hit a NullPointerException during filling the norms cache, because I didn&apos;t check for null after retrieving the old reader from the HashMap. I fixed this.&lt;/li&gt;
	&lt;li&gt;SegmentReader now also overwrites decRef() and implements decRefReaderNotNorms().&lt;/li&gt;
	&lt;li&gt;As Mike suggested I removed &quot;boolean sharedNorms&quot; from SegmentReader. Now in MultiSegmentReader I compare the norm instances from the old and the new subReaders and copy the bytes to the new cache in case they are ==.&lt;/li&gt;
	&lt;li&gt;In SegmentReader I changed norms to be a HashMap instead of HashTable.&lt;/li&gt;
	&lt;li&gt;Norm.decRef() and Norm.incRef() are synchronized now.&lt;/li&gt;
	&lt;li&gt;SegmentReader#norms(String field, byte[] bytes, int offset) now synchronizes on the norm object that is to be read.&lt;/li&gt;
	&lt;li&gt;SegmentReader#reopen() now opens a new FieldsReader because it is not thread-safe.&lt;/li&gt;
	&lt;li&gt;SegmentReader.Norm has a new boolean variable &quot;useSingleNormStream&quot;. SegmentReader#norms(String field, byte[] bytes, int offset) checks if it is true. If yes, then the readers&apos; singleNormStream is used, otherwise norm.in. This is necessary so that a reopened SegmentReader always uses its own singleNormStream and to avoid synchronization on the singleNormStream.&lt;/li&gt;
	&lt;li&gt;I added a bunch of code to TestIndexReaderReopen to test the thread-safety of reopen(). It starts 150 threads: some modify the index (some delete docs, some add docs and some set norms), some reopen readers and check if the re-opened ones deliver the same results as fresh ones.&lt;/li&gt;
	&lt;li&gt;assertReaderClosed now checks if the norms are closed and also checks recursively if all subReaders are closed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Still outstanding:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;On the IBM JVM all tests pass. On Sun, the thread-safety test &lt;b&gt;sometimes&lt;/b&gt; fails. When it fails, then in assertReaderClosed, because the refCounts of either the norms or some subReaders aren&apos;t 0 at the end of the test. At this point I&apos;m not sure why and I&apos;m still debugging. I just wanted to submit the patch to give others the chance to review the patch or possibly (hopefully) find the problem before me.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12541732" author="michaelbusch" created="Mon, 12 Nov 2007 10:28:08 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Updated patch to current trunk (I just realized that the&lt;br/&gt;
  latest didn&apos;t apply cleanly anymore)&lt;/li&gt;
	&lt;li&gt;MultiSegmentReader now decRefs the subReaders correctly&lt;br/&gt;
  in case an exception is thrown during reopen()&lt;/li&gt;
	&lt;li&gt;Small changes in TestIndexReaderReopen.java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The thread-safety test still sometimes fails. The weird&lt;br/&gt;
thing is that the test verifies that the re-opened &lt;br/&gt;
readers always return correct results. The only problem&lt;br/&gt;
is that the refCount value is not always 0 at the end&lt;br/&gt;
of the test. I&apos;m starting to think that the testcase&lt;br/&gt;
itself has a problem? Maybe someone else can take a look&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it&apos;s probably something really obvious but I&apos;m already&lt;br/&gt;
starting to feel dizzy while pondering about &lt;br/&gt;
thread-safety.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12541955" author="mikemccand" created="Mon, 12 Nov 2007 21:34:33 +0000"  >&lt;p&gt;I think the cause of the intermittant failure in the test is a missing&lt;br/&gt;
try/finally in doReopen to properly close/decRef everything on&lt;br/&gt;
exception.&lt;/p&gt;

&lt;p&gt;Because of lockless commits, a commit could be in-process while you&lt;br/&gt;
are re-opening, in which case you could hit an IOexception and you&lt;br/&gt;
must therefore decRef those norms you had incRef&apos;d (and, close eg the&lt;br/&gt;
newly opened FieldsReader).&lt;/p&gt;</comment>
                    <comment id="12541998" author="michaelbusch" created="Tue, 13 Nov 2007 00:14:45 +0000"  >&lt;p&gt;&amp;gt; I think the cause of the intermittant failure in the test is a missing&lt;br/&gt;
&amp;gt; try/finally in doReopen to properly close/decRef everything on&lt;br/&gt;
&amp;gt; exception.&lt;/p&gt;

&lt;p&gt;Awesome! Thanks so much for pointing me there, Mike! I was getting a &lt;br/&gt;
little suicidal here already ... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I should have read the comment in SegmentReader#initialize more &lt;br/&gt;
carefully:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {

      &lt;span class=&quot;code-comment&quot;&gt;// With lock-less commits, it&apos;s entirely possible (and
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// fine) to hit a FileNotFound exception above.  In
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;, we want to explicitly close any subset
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// of things that were opened so that we don&apos;t have to
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// wait &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; a GC to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; so.
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!success) {
        doClose();
      }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While debugging, it&apos;s easy to miss such an exception, because &lt;br/&gt;
SegmentInfos.FindSegmentsFile#run() ignores it. But it&apos;s good that it&lt;br/&gt;
logs such an exception, I just have to remember to print out the &lt;br/&gt;
infoStream next time.&lt;/p&gt;

&lt;p&gt;So it seems that this was indeed the cause for the failing test case.&lt;br/&gt;
I made the change and so far the tests didn&apos;t fail anymore (ran it &lt;br/&gt;
about 10 times so far). I&apos;ll run it another few times on a different &lt;br/&gt;
JVM and submit an updated patch in a short while if it doesn&apos;t fail &lt;br/&gt;
again.&lt;/p&gt;</comment>
                    <comment id="12542019" author="michaelbusch" created="Tue, 13 Nov 2007 01:26:32 +0000"  >&lt;p&gt;OK, all tests pass now, including the thread-safety test.&lt;br/&gt;
I ran it several times on different JVMs.&lt;/p&gt;

&lt;p&gt;Changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;As Mike suggested I added a try ... finally block to&lt;br/&gt;
SegmentReader#reopenSegment() which cleans up after an&lt;br/&gt;
exception was hit.&lt;/li&gt;
	&lt;li&gt;Added some additional comments.&lt;/li&gt;
	&lt;li&gt;Minor improvements to TestIndexReaderReopen&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12542201" author="mikemccand" created="Tue, 13 Nov 2007 19:18:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Awesome! Thanks so much for pointing me there, Mike! I was getting a&lt;br/&gt;
little suicidal here already ... &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No problem, I lost some hairs tracking that one down too!!&lt;/p&gt;

&lt;p&gt;OK, latest patch looks good!  I love the new threaded unit test.&lt;/p&gt;

&lt;p&gt;Only two smallish comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;You should also close fieldsReader when referencedSegmentReader !=&lt;br/&gt;
    null, right?  (in SegmentReader.doClose)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In the new try/finally in reopenSegment: if you first setup&lt;br/&gt;
    referencedSegmentReader, then can&apos;t that finally clause just be&lt;br/&gt;
    clone.decRef() instead of duplicating code for decRef&apos;ing norms,&lt;br/&gt;
    closeNorms(), etc.?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12542212" author="yseeley@gmail.com" created="Tue, 13 Nov 2007 19:54:01 +0000"  >&lt;p&gt;So how about a public IndexReader.flush() method so that one could also reopen readers that  were used for changes?&lt;/p&gt;

&lt;p&gt;Usecase:&lt;/p&gt;

&lt;p&gt;reader.deleteDocument()&lt;br/&gt;
reader.flush()&lt;br/&gt;
writer = new IndexWriter()&lt;br/&gt;
writer.addDocument()&lt;br/&gt;
writer.close()&lt;br/&gt;
reader.reopen()&lt;br/&gt;
reader.deleteDocument()&lt;/p&gt;</comment>
                    <comment id="12542332" author="michaelbusch" created="Wed, 14 Nov 2007 06:02:14 +0000"  >&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;You should also close fieldsReader when referencedSegmentReader !=&lt;br/&gt;
    null, right?  (in SegmentReader.doClose)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yes, will do!&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;In the new try/finally in reopenSegment: if you first setup&lt;br/&gt;
    referencedSegmentReader, then can&apos;t that finally clause just be&lt;br/&gt;
    clone.decRef() instead of duplicating code for decRef&apos;ing norms,&lt;br/&gt;
    closeNorms(), etc.?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hmm, what if then in clone.close() an exception is thrown from&lt;br/&gt;
FieldsReader.close() or singleNormStream.close(). In that case it &lt;br/&gt;
would not decRef the referenced reader. &lt;/p&gt;

&lt;p&gt;Hmm but actually we could change the order in close() so that &lt;br/&gt;
referencedSegmentReader.decRefReaderNotNorms() is done first even&lt;br/&gt;
if the following close() operations don&apos;t succeed?&lt;/p&gt;</comment>
                    <comment id="12542333" author="michaelbusch" created="Wed, 14 Nov 2007 06:05:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;So how about a public IndexReader.flush() method &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since our goal is it to make IndexReader read-only in the future&lt;br/&gt;
(&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1030&quot; title=&quot;&amp;quot;Read-only&amp;quot; IndexReaders&quot;&gt;&lt;del&gt;LUCENE-1030&lt;/del&gt;&lt;/a&gt;), do you really think we need to add this?&lt;/p&gt;</comment>
                    <comment id="12542390" author="mikemccand" created="Wed, 14 Nov 2007 10:10:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Hmm but actually we could change the order in close() so that&lt;br/&gt;
referencedSegmentReader.decRefReaderNotNorms() is done first even&lt;br/&gt;
if the following close() operations don&apos;t succeed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12542411" author="mikemccand" created="Wed, 14 Nov 2007 10:59:55 +0000"  >&lt;blockquote&gt;
&lt;p&gt;So how about a public IndexReader.flush() method&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think also if we do decide to do this we should open a new issue for it?&lt;/p&gt;</comment>
                    <comment id="12542462" author="yseeley@gmail.com" created="Wed, 14 Nov 2007 13:50:36 +0000"  >&lt;p&gt;&amp;gt; Since our goal is it to make IndexReader read-only in the future&lt;br/&gt;
&amp;gt; (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1030&quot; title=&quot;&amp;quot;Read-only&amp;quot; IndexReaders&quot;&gt;&lt;del&gt;LUCENE-1030&lt;/del&gt;&lt;/a&gt;), do you really think we need to add this?&lt;/p&gt;

&lt;p&gt;flush() would make reopen() useful in more cases, and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1030&quot; title=&quot;&amp;quot;Read-only&amp;quot; IndexReaders&quot;&gt;&lt;del&gt;LUCENE-1030&lt;/del&gt;&lt;/a&gt; is further off (not Lucene 2.3, right?)&lt;br/&gt;
Anyway, flush() would be considered a write operation like setNorm() &amp;amp; deleteDocument() and could be deprecated along with them in the future if that&apos;s how we decide to go.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think also if we do decide to do this we should open a new issue for it?&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s fine.&lt;/p&gt;</comment>
                    <comment id="12542492" author="michaelbusch" created="Wed, 14 Nov 2007 15:57:30 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think also if we do decide to do this we should open a new issue for it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;I&apos;ll open a new issue.&lt;/p&gt;</comment>
                    <comment id="12542593" author="michaelbusch" created="Wed, 14 Nov 2007 20:59:59 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Close FieldsReader in SegmentReader#doClose() even if&lt;br/&gt;
referencedReader!=null&lt;/li&gt;
	&lt;li&gt;Call clone.decRef() in the finally clause of&lt;br/&gt;
SegmentReader#reopenSegment()&lt;/li&gt;
	&lt;li&gt;decRef referencedReader before closing other resources&lt;br/&gt;
in SegmentReader#doClose()&lt;/li&gt;
	&lt;li&gt;Removed IndexReader#doCloseUnsharedResources().&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12542786" author="mikemccand" created="Thu, 15 Nov 2007 14:22:53 +0000"  >&lt;p&gt;Patch looks good.  Only thing I found was this leftover&lt;br/&gt;
System.out.println, in SegmentReader.java:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;refCount &quot;&lt;/span&gt; + getRefCount());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12542790" author="michaelbusch" created="Thu, 15 Nov 2007 15:02:15 +0000"  >&lt;p&gt;Thanks for the review, Mike! I&apos;ll remove the println.&lt;/p&gt;

&lt;p&gt;Ok, I think this patch has been reviewed a bunch of times and&lt;br/&gt;
should be ready to commit now. I&apos;ll wait another day and commit&lt;br/&gt;
it then if nobody objects.&lt;/p&gt;</comment>
                    <comment id="12543311" author="michaelbusch" created="Sat, 17 Nov 2007 20:44:04 +0000"  >&lt;p&gt;Changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Updated to current trunk.&lt;/li&gt;
	&lt;li&gt;Removed println in SegmentReader.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m going to commit this soon!&lt;/p&gt;</comment>
                    <comment id="12543315" author="michaelbusch" created="Sat, 17 Nov 2007 21:38:16 +0000"  >&lt;p&gt;Committed! Phew!!! &lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12380626">LUCENE-1030</issuekey>
        </issuelink>
                    </outwardlinks>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12364883">LUCENE-831</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12376572">LUCENE-986</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12346947" name="IndexReaderUtils.java" size="5051" author="otis" created="Mon, 11 Dec 2006 22:47:20 +0000" />
                    <attachment id="12363001" name="lucene-743.patch" size="29182" author="michaelbusch" created="Wed, 1 Aug 2007 22:41:08 +0100" />
                    <attachment id="12362275" name="lucene-743.patch" size="24141" author="hossman" created="Sat, 21 Jul 2007 02:46:39 +0100" />
                    <attachment id="12362199" name="lucene-743.patch" size="21526" author="michaelbusch" created="Fri, 20 Jul 2007 08:13:33 +0100" />
                    <attachment id="12369730" name="lucene-743-take10.patch" size="82114" author="michaelbusch" created="Sat, 17 Nov 2007 20:44:04 +0000" />
                    <attachment id="12366883" name="lucene-743-take2.patch" size="53494" author="michaelbusch" created="Tue, 2 Oct 2007 07:24:21 +0100" />
                    <attachment id="12368626" name="lucene-743-take3.patch" size="55432" author="michaelbusch" created="Mon, 29 Oct 2007 20:53:24 +0000" />
                    <attachment id="12368741" name="lucene-743-take4.patch" size="60910" author="buschmic" created="Wed, 31 Oct 2007 07:02:27 +0000" />
                    <attachment id="12368868" name="lucene-743-take5.patch" size="63509" author="michaelbusch" created="Fri, 2 Nov 2007 09:53:06 +0000" />
                    <attachment id="12369287" name="lucene-743-take6.patch" size="78016" author="michaelbusch" created="Sat, 10 Nov 2007 06:47:42 +0000" />
                    <attachment id="12369359" name="lucene-743-take7.patch" size="77727" author="michaelbusch" created="Mon, 12 Nov 2007 10:28:08 +0000" />
                    <attachment id="12369408" name="lucene-743-take8.patch" size="81831" author="michaelbusch" created="Tue, 13 Nov 2007 01:26:32 +0000" />
                    <attachment id="12369549" name="lucene-743-take9.patch" size="80946" author="michaelbusch" created="Wed, 14 Nov 2007 20:59:59 +0000" />
                    <attachment id="12346948" name="MyMultiReader.java" size="657" author="otis" created="Mon, 11 Dec 2006 22:47:20 +0000" />
                    <attachment id="12346949" name="MySegmentReader.java" size="667" author="otis" created="Mon, 11 Dec 2006 22:47:20 +0000" />
                    <attachment id="12367221" name="varient-no-isCloneSupported.BROKEN.patch" size="54623" author="hossman" created="Sun, 7 Oct 2007 20:57:08 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>16.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 11 Dec 2006 22:57:08 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13009</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26987</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>