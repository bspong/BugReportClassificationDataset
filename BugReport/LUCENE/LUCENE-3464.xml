<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:14:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3464/LUCENE-3464.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3464] Rename IndexReader.reopen to make it clear that reopen may not happen</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3464</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Spinoff from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3454&quot; title=&quot;rename optimize to a less cool-sounding name&quot;&gt;&lt;del&gt;LUCENE-3454&lt;/del&gt;&lt;/a&gt; where Shai noted this inconsistency.&lt;/p&gt;

&lt;p&gt;IR.reopen sounds like an unconditional operation, which has trapped users in the past into always closing the old reader instead of only closing it if the returned reader is new.&lt;/p&gt;

&lt;p&gt;I think this hidden maybe-ness is trappy and we should rename it (maybeReopen?  reopenIfNeeded?).&lt;/p&gt;

&lt;p&gt;In addition, instead of returning &quot;this&quot; when the reopen didn&apos;t happen, I think we should return null to enforce proper usage of the maybe-ness of this API.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12524576">LUCENE-3464</key>
            <summary>Rename IndexReader.reopen to make it clear that reopen may not happen</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Sun, 25 Sep 2011 20:08:31 +0100</created>
                <updated>Sun, 27 Nov 2011 12:29:37 +0000</updated>
                    <resolved>Tue, 22 Nov 2011 13:17:18 +0000</resolved>
                                            <fixVersion>3.5</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13114354" author="markrmiller@gmail.com" created="Sun, 25 Sep 2011 21:20:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;reopenIfNeeded&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 - can&apos;t think of anything better yet&lt;/p&gt;</comment>
                    <comment id="13114492" author="simonw" created="Mon, 26 Sep 2011 08:01:54 +0100"  >&lt;p&gt;just a couple of variants:&lt;/p&gt;

&lt;p&gt;tryReopen()&lt;br/&gt;
reopenOnChange()&lt;/p&gt;


&lt;p&gt;just and idea, we could also have a higherlevel api here on IR that refreshes the reader something like IR IR#refresh(IR prefious, boolean closePrevious)&lt;/p&gt;</comment>
                    <comment id="13114521" author="martijn.v.groningen" created="Mon, 26 Sep 2011 08:58:31 +0100"  >&lt;p&gt;+1 reopenOnChange()&lt;/p&gt;

&lt;p&gt;Names that contain maybe or try sound vague to me as a user.&lt;/p&gt;</comment>
                    <comment id="13114656" author="doronc" created="Mon, 26 Sep 2011 14:22:08 +0100"  >&lt;p&gt;I liked reopen()... (but also like returning null in case there&apos;s nothing newer...)&lt;/p&gt;

&lt;p&gt;If the name is going to change, two additional names to consider:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;newest()&lt;/li&gt;
	&lt;li&gt;newer()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For &quot;newest()&quot; I think current behavior of returning &quot;this&quot; makes sense when &quot;this&quot; is the newest.&lt;br/&gt;
For &quot;newer()&quot; returning null in that case seems right.&lt;/p&gt;

&lt;p&gt;One problem I have with these names is that they both seem to hide the fact that things are going on down there, when it is required to open a new reader...&lt;/p&gt;</comment>
                    <comment id="13114662" author="ryantxu" created="Mon, 26 Sep 2011 14:31:29 +0100"  >&lt;p&gt;maybe: &lt;br/&gt;
reopenIfChanged()&lt;/p&gt;

&lt;p&gt;reopenOnChange suggests, it will reopen when something changes.&lt;/p&gt;</comment>
                    <comment id="13114667" author="thetaphi" created="Mon, 26 Sep 2011 14:37:26 +0100"  >&lt;p&gt;We can even do the change in 3.x, if we keep the old method delegating to the new one. In 3.x we also need some sophisticated VirtualMethod usage then, as we have to take care of custom IR implementations that may only override the old one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; - unfortunately, reopen() is not final in IR and uses doReopen, like the other methods.&lt;/p&gt;

&lt;p&gt;reopenIfChanged() - my favourite!&lt;/p&gt;</comment>
                    <comment id="13114748" author="mikemccand" created="Mon, 26 Sep 2011 17:08:33 +0100"  >&lt;p&gt;I like reopenIfChanged too!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;unfortunately, reopen() is not final in IR and uses doReopen,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can we just make it final when we backport this change?  It&apos;s very expert to externally subclass IR and override reopen...&lt;/p&gt;</comment>
                    <comment id="13114760" author="mikemccand" created="Mon, 26 Sep 2011 17:23:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can we just make it final when we backport this change? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Duh no we can&apos;t since we have core IR impls subclassing IR...&lt;/p&gt;</comment>
                    <comment id="13114795" author="mikemccand" created="Mon, 26 Sep 2011 18:09:23 +0100"  >&lt;p&gt;Another trappiness I&apos;ve seen on IR.reopen is... the method implies that the reopen will happen &quot;in place&quot;.  And I&apos;ve seen users try to simply do IR.reopen().&lt;/p&gt;

&lt;p&gt;Maybe, the public API we expose should be something like IR.openIfChanged(oldReader), a static method?  This would open a new reader only if there are changes vs the old one, and would try to share resources (ie shared segments) with the old reader, when possible.&lt;/p&gt;

&lt;p&gt;We&apos;d have to add protected IR methods that &quot;really&quot; try to do the reopen.&lt;/p&gt;</comment>
                    <comment id="13114993" author="mikemccand" created="Mon, 26 Sep 2011 23:42:53 +0100"  >&lt;p&gt;Patch, changing to .reopenIfChanged.&lt;/p&gt;

&lt;p&gt;Still wondering about IR.openIfChanged though....&lt;/p&gt;</comment>
                    <comment id="13115030" author="ryantxu" created="Tue, 27 Sep 2011 00:22:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;the method implies that the reopen will happen &quot;in place&quot;. And I&apos;ve seen users try to simply do IR.reopen().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;funny, that&apos;s what i thought it did!&lt;/p&gt;

&lt;p&gt;If you have to use the results value, should it be:&lt;br/&gt;
getFreshReader(oldReader)&lt;br/&gt;
or something?&lt;/p&gt;

&lt;p&gt;without the &apos;get&apos; it seems like it operates on the reader itself, not the return value.&lt;/p&gt;

</comment>
                    <comment id="13118019" author="mikemccand" created="Fri, 30 Sep 2011 13:33:56 +0100"  >&lt;p&gt;New patch, cutting over to IndexReader.openIfChanged(oldReader) static&lt;br/&gt;
methods... I like this much better since it in no way implies the old&lt;br/&gt;
reader is reopened / altered in place.  It returns null if there is no&lt;br/&gt;
change to the index.  I think it&apos;s ready!&lt;/p&gt;</comment>
                    <comment id="13119751" author="mikemccand" created="Tue, 4 Oct 2011 00:33:33 +0100"  >&lt;p&gt;Tentative 3.x patch.&lt;/p&gt;

&lt;p&gt;I had to whip out VirtualMethod for back compat.... would appreciate a review that I did this correctly!  Heavy guns.&lt;/p&gt;</comment>
                    <comment id="13120014" author="thetaphi" created="Tue, 4 Oct 2011 12:13:20 +0100"  >&lt;p&gt;This sophisticated backwards seems fine.&lt;/p&gt;

&lt;p&gt;The most common use-case is:&lt;br/&gt;
One has a FilterIndexReader. All FilterIndexReaders should override reopen(), as the reopened reader has to be wrapped, too. In that case the filter would call super.reopen (or delegate.reopen), this would then trigger backwards. IndexReader.openIfChanged() would also work on this filtered reader, as it would detect the FilterIR to be old-style and would call its reopen method (so the call chain would be: IR.openIfChanged(filter) -&amp;gt; filter.reopen() -&amp;gt; wrappedReader.reopen() -&amp;gt; IR.openIfChanged(wrappedReader)) &lt;span class=&quot;error&quot;&gt;&amp;#91;wrappedReader is new-style in this example&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I have to think about other use-cases, but the most common one seems to be fine.&lt;/p&gt;</comment>
                    <comment id="13121041" author="mikemccand" created="Wed, 5 Oct 2011 16:23:05 +0100"  >&lt;p&gt;Thanks everyone!&lt;/p&gt;</comment>
                    <comment id="13154430" author="thetaphi" created="Mon, 21 Nov 2011 20:02:16 +0000"  >&lt;p&gt;I am reopening this issue as there is some API problem which makes openIfChanged not consistently useable with FilterIndexReader:&lt;/p&gt;

&lt;p&gt;If you have a FilterIndexReader that did in the past not implement reopen(...), the base class IndexReader throwed UOE. This was fine, as a FilterIndexReader cannot support reopen unless specifically supported. A FilterIndexReader of course must reopen the delegate reader and then wrap it again to Filter. This was done by overriding reopen() methods, checking if the delegate returned another reader and if yes, wrapping it.&lt;/p&gt;

&lt;p&gt;I tried to transform code that implement this pattern to Lucene 3.5RC1 but failed to do it in the clean way: Reopen was replaced by a static IR.openIfChanged(IR oldReader) that delegates to the specific IndexReaders implementation of doOpenIfChanged (which is protected).&lt;/p&gt;

&lt;p&gt;To implement the above pattern, doOpenIfChanged must be overridden in FilterIndexReader (again the default &lt;b&gt;must&lt;/b&gt; thorw UOE, otherwise reopening a filtered reader returns a non-filtered one). This method must call delegate&apos;s doOpenIfChanged and if it returns != null, wrap by our FilterIndexReader implementation. The problem: This cannot be implemented if the custom Filter is in a 3rd party package, as it cannot call the protected doOpenIfChanged. The workaround is to use IndexReader.openIfChanged(delegate), but this look borken and violates the pattern.&lt;/p&gt;

&lt;p&gt;The good thing with the workaround is that the VirtualMethod sophisticated backwards works correctly. We must at least document this behaviour in FilterIndexReader or fix the API.&lt;/p&gt;</comment>
                    <comment id="13154434" author="rcmuir" created="Mon, 21 Nov 2011 20:06:26 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The problem: This cannot be implemented if the custom Filter is in a 3rd party package, as it cannot call the protected doOpenIfChanged.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t understand this statement, because FilterReader extends IndexReader so it should be able to call protected IR methods.&lt;/p&gt;</comment>
                    <comment id="13154437" author="simonw" created="Mon, 21 Nov 2011 20:09:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t understand this statement, because FilterReader extends IndexReader so it should be able to call protected IR methods.&lt;/p&gt;&lt;/blockquote&gt;


&lt;p&gt;but not the delegates method though.&lt;/p&gt;</comment>
                    <comment id="13154439" author="rcmuir" created="Mon, 21 Nov 2011 20:16:17 +0000"  >&lt;p&gt;Thats no problem, it just calls super.doOpenIfChanged, see my proof of concept.&lt;/p&gt;</comment>
                    <comment id="13154440" author="thetaphi" created="Mon, 21 Nov 2011 20:16:36 +0000"  >&lt;p&gt;This code does not compile (fails by saying IndexReader has no accessible method doOpenIfChanged()):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; my.sophisticated.&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt;;

@Override
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; IndexReader doOpenIfChanged() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
  &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; IndexReader n=in.doOpenIfChanged();
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (n==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; : &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MySophisticatedIndexReader(n);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the working workaround but looks wrong (and works around the VirtualMethod issues):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Override
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; IndexReader doOpenIfChanged() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
  &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; IndexReader n=IndexReader.openIfChanged(in);
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (n==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; : &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MySophisticatedIndexReader(n);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13154441" author="rcmuir" created="Mon, 21 Nov 2011 20:18:15 +0000"  >&lt;p&gt;Uwe, see my patch, it uses its own sophisticated packaged and works fine.&lt;/p&gt;</comment>
                    <comment id="13154442" author="thetaphi" created="Mon, 21 Nov 2011 20:18:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;Thats no problem, it just calls super.doOpenIfChanged, see my proof of concept.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This throws UOE as FilterIndexReader (correctly!!!) does not implement doOpenIfChanged. If it would implement if a FilterIndexReader without any doOpenIfChanged impl would be horribly broken as it would return an unfiltered reader!!!&lt;/p&gt;</comment>
                    <comment id="13154444" author="rcmuir" created="Mon, 21 Nov 2011 20:19:30 +0000"  >&lt;p&gt;In my patch FIR returns whatever the underlying reader does.&lt;/p&gt;

&lt;p&gt;If you want this to be UOE &lt;b&gt;if doReopen is not overridden&lt;/b&gt;, well, you know how to do that &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13154445" author="thetaphi" created="Mon, 21 Nov 2011 20:20:04 +0000"  >&lt;p&gt;Robert read my comment about the reason why FilterIndexReader should never delegate to doOpenIfChanged(), as it would return an unfiltered reader on reopening, which would be a hidden bug for an implementor!&lt;/p&gt;</comment>
                    <comment id="13154448" author="thetaphi" created="Mon, 21 Nov 2011 20:22:26 +0000"  >&lt;p&gt;Robert: If you wrap a standard SegmentReader, it supports doOpenIfChanged. If I wrap it with my own custom FilterIndexReader that does not implement doOpenIfChanged, it will silently pass the return value of SegmentReader.doOpenIfChanged() which is no longer filtered. By throwing UOE in the default FilterIndexReader the user will see this when he tries to reopen.&lt;/p&gt;</comment>
                    <comment id="13154449" author="rcmuir" created="Mon, 21 Nov 2011 20:23:03 +0000"  >&lt;p&gt;As I said before, this is simple, FIR&apos;s impl only delegates if its overriden. otherwise throws UOE.&lt;/p&gt;</comment>
                    <comment id="13154456" author="thetaphi" created="Mon, 21 Nov 2011 20:26:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;As I said before, this is simple, FIR&apos;s impl only delegates if its overriden. otherwise throws UOE.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not in your proof of concept. And this proof of concept is no proof as it modifies FilteredIndexReader, so it would not work with 3.5.0RC1.&lt;/p&gt;

&lt;p&gt;Please note: For the above reason: FilterIndexReader in the past never delegated reopen() - for this exact reason (there was an issue open why delegating is wrong - have to look it up).&lt;/p&gt;</comment>
                    <comment id="13154463" author="rcmuir" created="Mon, 21 Nov 2011 20:31:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Not in your proof of concept. And this proof of concept is no proof as it modifies FilteredIndexReader, so it would not work with 3.5.0RC1.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not arguing that nothing needs to be done: I&apos;m just saying that the fact its protected isnt really a problem.&lt;/p&gt;

&lt;p&gt;For 3.5.0 there is already a workaround.&lt;/p&gt;</comment>
                    <comment id="13154468" author="rcmuir" created="Mon, 21 Nov 2011 20:35:29 +0000"  >&lt;p&gt;And just again: I want to point out this is the same fundamental problem as &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2828&quot; title=&quot;SimilarityDelegator broke back-compat for subclasses overriding lengthNorm&quot;&gt;&lt;del&gt;LUCENE-2828&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is why abstract classes are NOT the solution to backwards compatibility, because&lt;br/&gt;
delegators over abstract classes get all jacked up.&lt;/p&gt;</comment>
                    <comment id="13155094" author="thetaphi" created="Tue, 22 Nov 2011 13:14:17 +0000"  >&lt;p&gt;I will add a comment to the javadocs with a simple statement:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Note:&amp;lt;/b&amp;gt; The default implementation of {@link FilterIndexReader#doOpenIfChanged}
 * throws {@link UnsupportedOperationException} (like the base class),
 * so it&apos;s not possible to reopen a &amp;lt;code&amp;gt;FilterIndexReader&amp;lt;/code&amp;gt;.
 * To reopen, you have to first reopen the underlying reader
 * and wrap it again with the custom filter.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this case the responsibility is moved over to the consumer. Its the same like with SlowMultiReaderWrapper: It does not support reopen, to support this, reopen the underlying reader and make it slow again &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13155106" author="thetaphi" created="Tue, 22 Nov 2011 13:17:18 +0000"  >&lt;p&gt;Committed 3.x revision: 1204970&lt;br/&gt;
Merged to trunk revision: 1204971&lt;/p&gt;</comment>
                    <comment id="13157819" author="thetaphi" created="Sun, 27 Nov 2011 12:29:37 +0000"  >&lt;p&gt;Bulk close after release of 3.5&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12497569" name="LUCENE-3464.3x.patch" size="59091" author="mikemccand" created="Tue, 4 Oct 2011 00:33:33 +0100" />
                    <attachment id="12497154" name="LUCENE-3464.patch" size="61384" author="mikemccand" created="Fri, 30 Sep 2011 13:33:56 +0100" />
                    <attachment id="12496580" name="LUCENE-3464.patch" size="52225" author="mikemccand" created="Mon, 26 Sep 2011 23:42:53 +0100" />
                    <attachment id="12504542" name="LUCENE-3464_see_its_just_fine.patch" size="1766" author="rcmuir" created="Mon, 21 Nov 2011 20:16:16 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 25 Sep 2011 20:20:03 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2262</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24232</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>