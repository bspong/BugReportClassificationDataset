<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:20:46 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2529/LUCENE-2529.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2529] always apply position increment gap between values</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2529</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I&apos;m doing some fancy stuff with span queries that is very sensitive to term positions.  I discovered that the position increment gap on indexing is only applied between values when there are existing terms indexed for the document.  I suspect this logic wasn&apos;t deliberate, it&apos;s just how its always been for no particular reason.  I think it should always apply the gap between fields.  Reference DocInverterPerField.java line 82:&lt;/p&gt;

&lt;p&gt;if (fieldState.length &amp;gt; 0)&lt;br/&gt;
          fieldState.position += docState.analyzer.getPositionIncrementGap(fieldInfo.name);&lt;/p&gt;

&lt;p&gt;This is checking fieldState.length.  I think the condition should simply be:  if (i &amp;gt; 0).&lt;br/&gt;
I don&apos;t think this change will affect anyone at all but it will certainly help me.  Presently, I can either change this line in Lucene, or I can put in a hack so that the first value for the document is some dummy value which is wasteful.&lt;/p&gt;</description>
                <environment>&lt;p&gt;(I don&apos;t know which version to say this affects since it&apos;s some quasi trunk release and the new versioning scheme confuses me.)&lt;/p&gt;</environment>
            <key id="12468646">LUCENE-2529</key>
            <summary>always apply position increment gap between values</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="koji">Koji Sekiguchi</assignee>
                                <reporter username="dsmiley">David Smiley</reporter>
                        <labels>
                    </labels>
                <created>Tue, 6 Jul 2010 17:30:45 +0100</created>
                <updated>Wed, 30 Mar 2011 16:50:03 +0100</updated>
                    <resolved>Tue, 28 Sep 2010 03:21:58 +0100</resolved>
                            <version>2.9.3</version>
                <version>3.0.2</version>
                <version>3.1</version>
                <version>4.0-ALPHA</version>
                                <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                          <timeoriginalestimate seconds="3600">1h</timeoriginalestimate>
                    <timeestimate seconds="3600">1h</timeestimate>
                                  <comments>
                    <comment id="12886670" author="mikemccand" created="Fri, 9 Jul 2010 11:12:46 +0100"  >&lt;p&gt;I agree it&apos;s weird that the if checks fieldState.length instead of i; we should fix it, though, this is a subtle break in back-compat.&lt;/p&gt;

&lt;p&gt;Once we do &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2309&quot; title=&quot;Fully decouple IndexWriter from analyzers&quot;&gt;&lt;del&gt;LUCENE-2309&lt;/del&gt;&lt;/a&gt; (fully decouple indexing &amp;amp; analysis) and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2450&quot; title=&quot;Explore write-once attr bindings in the analysis chain&quot;&gt;LUCENE-2450&lt;/a&gt; (write-once attr bindings in the analyzer chain), this sort of fix would be nicely &quot;external&quot; to Lucene.  Ie the semantics of how positions / offsets increment across boundaries of multiple fields would be fully determined by the app/analyzer, not baked into Lucene&apos;s core.&lt;/p&gt;</comment>
                    <comment id="12886986" author="dsmiley" created="Sat, 10 Jul 2010 04:33:54 +0100"  >&lt;p&gt;How does this change backwards compatibility?  The index format is certainly the same.  And there&apos;s no documented or implied contract I&apos;m breaking with this change in increment gap behavior.  I&apos;d be really surprised to learn that anyone actually depends on the current behavior.  When I went into the code I was figuring it might smartly only apply the increment gap if the offset &lt;b&gt;changed&lt;/b&gt; from one value to another but it doesn&apos;t even do that, and so the current algorithm strikes me as a bit arbitrary.  Seems like a safe one-liner commit to me.  But then I&apos;m biased as the reporter &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12887041" author="mikemccand" created="Sat, 10 Jul 2010 15:49:57 +0100"  >&lt;p&gt;Well, if an app has a multi-valued field today where the first N (&amp;gt; 1) values analyze to 0 tokens, then this change will alter the positions of subsequent tokens.&lt;/p&gt;

&lt;p&gt;Still, I agree, it seems unlikely that an app is relying on this... so I think we can just break it (and advertise that we did so, in CHANGES under back compat breaks).&lt;/p&gt;

&lt;p&gt;Note that offsets also have logic that avoids adding the offset gap if there were no tokens; but it&apos;s slightly different since it will not add the gap if the current value in the multi-valued field had no tokens (whereas the logic for the position gap is only if we&apos;ve seen net 0 tokens so far).  Seems like we should also fix offset to always add the gap?&lt;/p&gt;

&lt;p&gt;Wanna cons up a patch...?&lt;/p&gt;</comment>
                    <comment id="12887062" author="dsmiley" created="Sat, 10 Jul 2010 18:03:09 +0100"  >&lt;p&gt;I changed the conditional as described in this issue &amp;#8211; a one-liner.&lt;/p&gt;

&lt;p&gt;I have no comment on the &quot;offset gap&quot; as I&apos;m not familiar with the logic you speak of, Michael.&lt;/p&gt;</comment>
                    <comment id="12915063" author="koji" created="Sun, 26 Sep 2010 23:35:19 +0100"  >&lt;p&gt;I&apos;ll see this issue and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2668&quot; title=&quot;offset gap should be added regardless of existence of tokens in DocInverterPerField&quot;&gt;&lt;del&gt;LUCENE-2668&lt;/del&gt;&lt;/a&gt; all together.&lt;/p&gt;</comment>
                    <comment id="12915593" author="koji" created="Tue, 28 Sep 2010 03:21:58 +0100"  >&lt;p&gt;trunk: Committed revision 1001796 and 1001957.&lt;br/&gt;
branch_3x: Committed revision 1001991.&lt;/p&gt;

&lt;p&gt;Thanks, David!&lt;/p&gt;</comment>
                    <comment id="12915726" author="dsmiley" created="Tue, 28 Sep 2010 13:40:48 +0100"  >&lt;p&gt;I&apos;ve been so busy; I intended to return to this issue later in the week.  Unfortunately this issue isn&apos;t completely resolved in my testing.  It&apos;s good that the position increment gap is always applied now, but there is some other increment logic in this class that foils my attempts to coordinate the positions across multiple fields, particularly when the first value is non-existent for a multi-valued field.  I&apos;ll post more about it later.&lt;/p&gt;</comment>
                    <comment id="12917157" author="dsmiley" created="Sat, 2 Oct 2010 05:27:45 +0100"  >&lt;p&gt;Always adding the position increment is good but insufficient to solve my problem.&lt;/p&gt;

&lt;p&gt;A new patch rectifies the followup situation I reported inadvertently to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2668&quot; title=&quot;offset gap should be added regardless of existence of tokens in DocInverterPerField&quot;&gt;&lt;del&gt;LUCENE-2668&lt;/del&gt;&lt;/a&gt; that I should have said here.  The jist is that DocInverterPerField &lt;em&gt;conditionally&lt;/em&gt; decrements the position and then always increments it, and this is problematic for attempting to keep position increments across several multi-value fields aligned (using an analyzer setting posIncr to 0) when the first value generates no tokens (either blank or stop words).  Mike McCandless pointed out that the unfortunate existing logic had to do with preventing the position from becoming -1 which doesn&apos;t work with payloads &amp;#8211; &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1542&quot; title=&quot;Lucene can incorrectly set the position of tokens that start a field with positonInc 0.&quot;&gt;&lt;del&gt;LUCENE-1542&lt;/del&gt;&lt;/a&gt;.  &lt;/p&gt;

&lt;p&gt;My new patch here doesn&apos;t even have a pre-decrement nor post-increment and thus I find the code easier to follow.  It ignores the provided position increment of the first token (typically 1), voiding the need to shift them back and forth.  There is one oddity included here and that is I always add 1 to the position increment &lt;em&gt;gap&lt;/em&gt; (i.e. between values).  With this oddity included, all the tests pass (except for the test for this very issue, which I correct in this patch)  --yay!  Without this oddity, a handful of tests failed that depended on the first token adding one to the position.  My +1 up at the value loop can be seen as actually enforcing that the first token&apos;s position is 1, and also adding a +1 for when there is no token for a value (critical for aligning multiple fields).  Perhaps this +1 should happen at a different line number to be less confusing but the end result should be the same.&lt;/p&gt;

&lt;p&gt;I expect for many people this is very confusing, especially if you&apos;re not knee deep in this subject as I am presently.  Mike, hopefully you&apos;re understanding what I&apos;m up to here.  The tests pass, remember.&lt;/p&gt;</comment>
                    <comment id="12917177" author="mikemccand" created="Sat, 2 Oct 2010 11:10:36 +0100"  >&lt;p&gt;I like the idea of disregarding the posIncrGap of the first token.&lt;/p&gt;

&lt;p&gt;Maybe, instead of that +1 inside IW, we change the default posIncrGap&lt;br/&gt;
to 1?&lt;/p&gt;

&lt;p&gt;Can you spell out examples of how the indexed positions will change w/&lt;br/&gt;
this patch &amp;#8211; I&apos;m having trouble visualizing this.  EG for a single&lt;br/&gt;
valued field, multi-valued, etc.&lt;/p&gt;

&lt;p&gt;For one, because we now ignore the token&apos;s posIncrGap if it&apos;s the&lt;br/&gt;
first token (per value in the field), any tokenizer that alters the&lt;br/&gt;
posIncr from the default (1) will now see different positions indexed,&lt;br/&gt;
right?&lt;/p&gt;

&lt;p&gt;Man I really want to get this logic out of indexer and into the&lt;br/&gt;
analysis chain (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2450&quot; title=&quot;Explore write-once attr bindings in the analysis chain&quot;&gt;LUCENE-2450&lt;/a&gt; enables this).  How multi-valued streams&lt;br/&gt;
should handle the transition from one value to another shouldn&apos;t be&lt;br/&gt;
inside the indexer... and maybe (someday) tokens should store their&lt;br/&gt;
position (not the gap) so we don&apos;t have this cryptic logic inside the&lt;br/&gt;
indexer...&lt;/p&gt;</comment>
                    <comment id="12917178" author="mikemccand" created="Sat, 2 Oct 2010 11:11:19 +0100"  >&lt;p&gt;Duh, sorry I meant &quot;I like the idea of disregarding the posIncr of the first token&quot; (not the posIncrGap).&lt;/p&gt;</comment>
                    <comment id="12917237" author="dsmiley" created="Sat, 2 Oct 2010 19:49:54 +0100"  >&lt;p&gt;(patch updated)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe, instead of that +1 inside IW, we change the default posIncrGap to 1?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I had the +1 for the gap (i.e. between values) level because I was trying to get a blank value (or a value consisting of stop words) to bump the position counter as well.  I&apos;ve been tinkering with this a bit more and I realize now that I can still achieve my aims without doing that, but it&apos;s still necessary to ignore the very first position increment of the very first value &amp;#8211; only.  See the new patch.  I think the result now should be even more amenable to others (i.e. is least disruptive) since anyone messing with the position increment of the first token of subsequent values will still be honored.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you spell out examples of how the indexed positions will change w/ this patch - I&apos;m having trouble visualizing this. EG for a single valued field, multi-valued, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A single valued field is unaffected.  The first emitted token (if there are any at all) will remain at position 0 no matter what the analyzer does.  This is also true for the first value of a multi-valued field if there is any.&lt;/p&gt;

&lt;p&gt;For multi-valued fields, it is now always the case that the first token of subsequent values (e.g. not the first value) will be the previous position (0 if none) + the gap + the first position increment of this value (typically 1).  This is consistent and sensible.  Formerly,&lt;br/&gt;
if the first value was a blank value (or a value consisting of stop words), then you&apos;d get 1 less than what you get now.  I hope the test I modified as part of this patch makes this more clear; I had to increment the tested positions by 1.&lt;/p&gt;

&lt;p&gt;As I said before, I also think that the code is more clear since it no longer has that conditional pre-decrement and post increment of the position that was probably only understood by you.  And I did away with the weird &quot;+1&quot; at the gap in my previous patch.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Man I really want to get this logic out of indexer and into the analysis chain (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2450&quot; title=&quot;Explore write-once attr bindings in the analysis chain&quot;&gt;LUCENE-2450&lt;/a&gt; enables this). How multi-valued streams should handle the transition from one value to another shouldn&apos;t be inside the indexer... and maybe (someday) tokens should store their position (not the gap) so we don&apos;t have this cryptic logic inside the indexer..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds great.  There are other strategies of messing with position increments that I simply can&apos;t do without hacking this code further.  For example, it would be neat if the first token of a value could be devised to start at posIncGap*valueIndex (ex: 0, 1000, 2000, ...) so that Span queries could determine which value index a term matched against by looking at it&apos;s position (ex: 3092: divide by 1000, drop remainder, add 1: the 4th value ).&lt;/p&gt;</comment>
                    <comment id="12917650" author="rcmuir" created="Mon, 4 Oct 2010 17:18:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;but there is some other increment logic in this class that foils my attempts to coordinate the positions across multiple fields, particularly when the first value is non-existent for a multi-valued field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think this will ever completely work correctly though, for example the only way to &quot;accumulate&quot; positions across a field that ends with a stopword / all stopwords would be to add a positional equivalent to end() that we did for offsets, so that highlighting would work for multi-valued fields. otherwise reset() -&amp;gt; clearAttributes() and the PositionIncrementAttribute is &quot;lost&quot;&lt;/p&gt;

&lt;p&gt;I think if you are trying to coordinate positions across multi-valued fields, it probably means you shouldn&apos;t be using a multivalued field. It seems to only make sense to put multiple &lt;b&gt;independent&lt;/b&gt; values in a multi-valued field, not ones that are &quot;continuations&quot; of each other. By definition if they are continuations of each other, I think its better to index the whole thing as single-valued... and you have complete control of the positions within your tokenstream.&lt;/p&gt;</comment>
                    <comment id="12917655" author="dsmiley" created="Mon, 4 Oct 2010 18:10:07 +0100"  >&lt;p&gt;Rob, I don&apos;t completely follow your first paragraph, but this patch I posted &lt;em&gt;does&lt;/em&gt; work correctly for what I&apos;m doing.  It is one part of the puzzle in searching multi-valued fields at coordinated positions.  The other part is span queries with field masking.  For my problem space, I&apos;m willing to sacrifice the ability to do phrase queries.  I can&apos;t do them because my solution forces all position increments to 0, but using a gap.&lt;/p&gt;

&lt;p&gt;My patch here (and the patch already applied by Koji recently) for this issue isn&apos;t really code specific to the problem I&apos;m solving, but it is necessary for my approach, and I think makes the logic in this class easier to follow and more consistent with respect to the behavior of the position increment gap and handling of the very first position increment.  All existing tests pass.  On the basis of that alone, I&apos;m hopeful that you, Michael, and other committers are amenable to applying this patch.&lt;/p&gt;

&lt;p&gt;I acknowledge I could try to operate completely within a single value and thereby have more control over the position increments.  That&apos;s an idea I didn&apos;t think of, thanks.  But I believe the point I just made on my patch being an improvement stands.&lt;/p&gt;</comment>
                    <comment id="12917663" author="rcmuir" created="Mon, 4 Oct 2010 18:26:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;Rob, I don&apos;t completely follow your first paragraph&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What i was trying to say, is that there&apos;s no way for positions to be properly accumulated across multi-valued fields.&lt;br/&gt;
for example (i will use the pipe as a field separator and assume english stopwords):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;brown fox | went to | market
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this case the index will &quot;lose&quot; the 2 position increments caused by &quot;went&quot;, and &quot;to&quot;, and they &lt;br/&gt;
won&apos;t be reflected in the &quot;market&quot; position.&lt;/p&gt;

&lt;p&gt;My suggestion is that if you have values like this with position dependencies, they are really&lt;br/&gt;
one single value, not independent values, and don&apos;t belong in a multivalued-field.&lt;/p&gt;

&lt;p&gt;In this case, if you simply index the entire content as one field, and in your tokenstream handle the &lt;br/&gt;
separator however you want, and the &quot;market&quot; token will properly reflect whatever you previously did &lt;br/&gt;
with the tokens, either via that separator and/or stopwords or other things.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For my problem space, I&apos;m willing to sacrifice the ability to do phrase queries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, but my concern is that other users are not. &lt;br/&gt;
I don&apos;t think we should discard the first token&apos;s position increment value completely, will the QueryParser do this too?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;My patch here (and the patch already applied by Koji recently) for this issue isn&apos;t really code specific to the problem I&apos;m solving, but it is necessary for my approach&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The previous patch (the one described on the issue) I definitely agreed with. &lt;br/&gt;
But what you speak of here (discarding the first token&apos;s position) is different, &lt;br/&gt;
and I&apos;m not convinced its necessary for your approach (you could use a single-valued field).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;All existing tests pass. On the basis of that alone, I&apos;m hopeful that you, Michael, and other committers are amenable to applying this patch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, unfortunately (not your fault at all!) that isn&apos;t very comforting to me. &lt;br/&gt;
For example, the queryparser has very minimal tests wrt this sorta stuff, yet&lt;br/&gt;
as I mentioned above its important to think about how it consumes tokenstreams, &lt;br/&gt;
because if its inconsistent with the indexer then queries start returning less results.&lt;/p&gt;</comment>
                    <comment id="12917696" author="rcmuir" created="Mon, 4 Oct 2010 19:41:32 +0100"  >&lt;p&gt;Here&apos;s a patch, showing what i mean about why it is bad to discard the first position.&lt;/p&gt;

&lt;p&gt;The test uses SpanFirstQuery (imagine a custom queryparser that supports a &quot;starts-with&quot; operator).&lt;/p&gt;

&lt;p&gt;the test passes on trunk, but fails if i apply the patch to discard the position of the first term.&lt;/p&gt;</comment>
                    <comment id="12917697" author="dsmiley" created="Mon, 4 Oct 2010 19:42:15 +0100"  >&lt;blockquote&gt;&lt;p&gt;My suggestion is that if you have values like this with position dependencies, they are really one single value, not independent values, and don&apos;t belong in a multivalued-field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My use-case is not like your example.  The value at index x has no relation to values before or after it in the same field.  It &lt;em&gt;does&lt;/em&gt; have a relationship to a separate multi-valued field&apos;s value at the same value index.  With this patch and an analyzer that sets all position increments to 0, all tokens for the same value index across both fields will have the same token position.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(me)    For my problem space, I&apos;m willing to sacrifice the ability to do phrase queries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;Right, but my concern is that other users are not.  I don&apos;t think we should discard the first token&apos;s position increment value completely, will the QueryParser do this too?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The fact that my entire solution (for which this patch is a subset) can&apos;t do phrases is not evident in this patch.  Perhaps I should have kept my overall use case a secret so as not to cloud the purpose of this patch.  This patch is about generating predictable/intuitive/sensible (in my opinion) position values, particularly at the very start of a field.  I hope you would share my opinion if you apply the patch and examine the results such as what the test case the patch modifies does.&lt;/p&gt;

&lt;p&gt;In my opinion (and apparently Mike McCandless &amp;#8211; &quot;I like the idea of disregarding the posIncrGap of the first token.&quot;) I disagree.  The point of a position increment gap is only meaningful &lt;em&gt;between&lt;/em&gt; values.  It&apos;s meaningless for the first token.  At your suggestion I looked in QueryParser.java to look for problems that may have to do with the position increment.  I don&apos;t see any problems that would be introduced by this patch.  For convenient reference here, the position increment is grabbed at line 608:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; positionIncrement = (posIncrAtt != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) ? posIncrAtt.getPositionIncrement() : 1;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (positionIncrement != 0) {
  positionCount += positionIncrement;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
  severalTokensAtSamePosition = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ensuing logic seems pretty sane to me (albeit complicated).  The only thing in here that could arguably be improved is line 645:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (positionCount == 1 || (!quoted &amp;amp;&amp;amp; !autoGeneratePhraseQueries)) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I think the &quot;== 1&quot; should be &quot;&amp;lt;= 1&quot; just in case there&apos;s some intentional oddities in the analyzer that 99.9% of people wouldn&apos;t ever do.  I&apos;m in the exception case.  But I have a different query time analyzer so I don&apos;t care that much.&lt;/p&gt;</comment>
                    <comment id="12917709" author="rcmuir" created="Mon, 4 Oct 2010 19:57:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;The point of a position increment gap is only meaningful between values.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thats not true, see my test for an example. Its a position increment, in my example I show how you would implement a &quot;starts-with&quot; &lt;br/&gt;
operator consistent with how PhraseQuery works by default: it respects the &quot;holes&quot; from stopwords for better precision. &lt;/p&gt;

&lt;p&gt;For example in the English language, lots of sentences start with stopwords so I think its a pretty big deal to just arbitrarily &lt;br/&gt;
throw out the position of the first token in the document.&lt;/p&gt;</comment>
                    <comment id="12917787" author="dsmiley" created="Mon, 4 Oct 2010 22:51:02 +0100"  >&lt;p&gt;I think you&apos;re right Rob, I didn&apos;t think of that at all.  I altered the patch further, and included your test as a part of it.  I also added a little to the existing test I patched so that I consider a leading stop word, which is really the jist of what you are drawing attention to in your patch.  The tests pass.  This patch is retains the spirit of the earlier patch, but it honors the first position increment, expecting it to be &amp;gt;= 1.  If it&apos;s 0, then the fieldState.position would end up being -1 but there&apos;s a quick check here that will correct it to be 0.  That suits my needs, and the whole result I think is clearer and more consistent than the existing code &amp;amp; behavior.&lt;/p&gt;</comment>
                    <comment id="12917796" author="rcmuir" created="Mon, 4 Oct 2010 23:02:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;but it honors the first position increment, expecting it to be &amp;gt;= 1. If it&apos;s 0, then the fieldState.position would end up being -1 but there&apos;s a quick check here that will correct it to be 0.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thank you... in my opinion here though (the zero case), we should just throw a hard Exception! &lt;/p&gt;

&lt;p&gt;Because if the first token in a field has posIncrement = 0, this is meaningless,&lt;br/&gt;
it means it has some negative position (it is floating around in the gap or before the field at all)&lt;/p&gt;

&lt;p&gt;Personally I would prefer if any of the code inside lucene does something this stupid, that we&lt;br/&gt;
get a hard test fail rather than a cover-up!&lt;/p&gt;</comment>
                    <comment id="12917807" author="rcmuir" created="Mon, 4 Oct 2010 23:32:28 +0100"  >&lt;p&gt;attached is a patch for BaseTokenStreamTestCase that tests if the first value has a posInc=0 (nonsensical position increment).&lt;/p&gt;

&lt;p&gt;The synonymfilter from solr fails with the test, but I don&apos;t really care... there is no point in indexing your text if you are going to put useless values in the index... I still think we should throw hard exception here.&lt;/p&gt;
</comment>
                    <comment id="12917993" author="dsmiley" created="Tue, 5 Oct 2010 15:30:13 +0100"  >&lt;p&gt;Just to see how the tests fared with your suggestion, I commented out my &quot;correction&quot; of position from -1 to 0, and instead put in:&lt;br/&gt;
  assert fieldState.position &amp;gt;= 0 : &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1542&quot; title=&quot;Lucene can incorrectly set the position of tokens that start a field with positonInc 0.&quot;&gt;&lt;del&gt;LUCENE-1542&lt;/del&gt;&lt;/a&gt;, pos &amp;lt; 0 doesn&apos;t work with payloads&quot;;&lt;/p&gt;

&lt;p&gt;Some lucene tests failed:&lt;br/&gt;
 TestIndexWriter.testNegativePositions&lt;br/&gt;
TestPositionIncrement.testSetPosition and testPayloadsPos0&lt;/p&gt;

&lt;p&gt;I ran the Solr tests and didn&apos;t see failures that had to do with the position.  No synonym failure like you reported.&lt;/p&gt;</comment>
                    <comment id="12917999" author="rcmuir" created="Tue, 5 Oct 2010 15:40:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;I ran the Solr tests and didn&apos;t see failures that had to do with the position. No synonym failure like you reported.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, you need my assert to catch that...&lt;/p&gt;

&lt;p&gt;So i really wish we could fix this, its a mess. An initial position increment of zero is meaningless, but lots of peoples&lt;br/&gt;
analysis chains do it... the whole PositionIncrementAttribute is really broken.&lt;/p&gt;

&lt;p&gt;e.g. just imagine a synonym-filter that injects &quot;hte&quot; for &quot;the&quot; followed by a stopfilter with setEnablePositionIncrements(false) &lt;/p&gt;

&lt;p&gt;at the moment i don&apos;t see how we can remove the &quot;turn zero into one&quot; hack easily... i don&apos;t like it.&lt;/p&gt;</comment>
                    <comment id="12918012" author="dsmiley" created="Tue, 5 Oct 2010 16:05:58 +0100"  >&lt;p&gt;I sympathize with your point of view Rob; arguably a position of &amp;lt; 0 is illogical and an error.  If the current behavior should stay then we can at least put a comment in the code here acknowledging the illogical nature of it.&lt;/p&gt;

&lt;p&gt;How do you feel about committing my latest patch, with the addition of a suitable comment just mentioned?&lt;/p&gt;</comment>
                    <comment id="12918029" author="rcmuir" created="Tue, 5 Oct 2010 16:37:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;How do you feel about committing my latest patch, with the addition of a suitable comment just mentioned?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;well honestly now that &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2529&quot; title=&quot;always apply position increment gap between values&quot;&gt;&lt;del&gt;LUCENE-2529&lt;/del&gt;&lt;/a&gt;_skip_posIncr_for_1st_token.patch doesnt skip the posIncr for the first token, I&apos;m having a tough time seeing what it changes?&lt;/p&gt;

&lt;p&gt;I do like that when we do the &quot;hack&quot; correction of &quot;turn zero into one&quot; that the numOverlaps is now consistent... but what else changes?&lt;/p&gt;</comment>
                    <comment id="12918034" author="dsmiley" created="Tue, 5 Oct 2010 16:48:49 +0100"  >&lt;p&gt;Quoting myself earlier:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For multi-valued fields, it is now always the case that the first token of subsequent values (e.g. not the first value) will be the previous position (0 if none) + the gap + the first position increment of this value (typically 1). This is consistent and sensible. Formerly, if the first value was a blank value (or a value consisting of stop words), then you&apos;d get 1 less than what you get now. I hope the test I modified as part of this patch makes this more clear; I had to increment the tested positions by 1.&lt;/p&gt;&lt;/blockquote&gt;</comment>
                    <comment id="12918260" author="rcmuir" created="Tue, 5 Oct 2010 23:19:15 +0100"  >&lt;p&gt;David, sorry to make you repeat yourself.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure about this change though, for example it breaks contrib/highlighter tests (I didnt look at the test to see more details).&lt;/p&gt;

&lt;p&gt;However, if we decide to do it in the future, I think we should remove these special checks from the main loop:&lt;br/&gt;
For example, instead of:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (firstToken &amp;amp;&amp;amp; i == 0)&lt;span class=&quot;code-comment&quot;&gt;//i.e. &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is the very first token we emit &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; field in &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; document
&lt;/span&gt;              fieldState.position--;&lt;span class=&quot;code-comment&quot;&gt;//we want to start at 0, not 1&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;this could check hasMoreTokens &amp;amp;&amp;amp; i == 0 before the loop, so its not checked for every token in the document.&lt;br/&gt;
in a similar sense I think the &quot;correct &amp;lt; 0 to 0&quot; check should probably be outside of the loop, since it can only really happen for the first term.&lt;/p&gt;</comment>
                    <comment id="12918576" author="dsmiley" created="Wed, 6 Oct 2010 17:29:02 +0100"  >&lt;p&gt;Yes, the check could move outside the loop.  I don&apos;t think so for the &quot;correct &amp;lt; 0&quot; but whatever.  And the Highlight test fails because the test is based off of a multi-valued field in which the first value is blank, thus triggering the subsequent positions to be off by one from the former behavior.&lt;br/&gt;
A small readability improvement might be to set fieldState.position to -1 instead of decrementing it because that is exactly the intended effect, which is more clear.&lt;/p&gt;

&lt;p&gt;FYI the observable change in behavior in this patch principally results from the &quot;firstToken&quot; boolean part of the condition in which the position is decremented.  Remove that part of the condition leaving simply i==0 and you get the former/existing behavior.&lt;/p&gt;

&lt;p&gt;Ugh, I&apos;ve thought about this issue way too much and I&apos;m suddenly having a change of opinion.  Arguably the current effect of positions is more consistent... it is as if the starting position (prior to looking at the position increment) is -1, no matter whether the first value has tokens or not.  I&apos;m going to achieve my objectives for my project via your suggestion of a single field with a value separator and a custom analyzer.  It&apos;s a little hacky but I&apos;ll then have full control over the positions and the field isn&apos;t stored any way.  I wish I had the ability to control positions in the indexer here a bit more but the support really isn&apos;t there and won&apos;t be until perhaps &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2450&quot; title=&quot;Explore write-once attr bindings in the analysis chain&quot;&gt;LUCENE-2450&lt;/a&gt;, the issue Mike referenced.&lt;/p&gt;

&lt;p&gt;As far as my patch goes, with the small modification to get the existing behavior, I think it&apos;s an improvement to readability over the current code.  I can submit an update if desired. &lt;/p&gt;</comment>
                    <comment id="13013349" author="gsingers" created="Wed, 30 Mar 2011 16:50:03 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12475114">LUCENE-2668</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12449163" name="LUCENE-2529_always_apply_position_increment_gap_between_values.patch" size="597" author="dsmiley" created="Sat, 10 Jul 2010 18:03:09 +0100" />
                    <attachment id="12456335" name="LUCENE-2529_nonsenseIncrements.patch" size="986" author="rcmuir" created="Mon, 4 Oct 2010 23:32:28 +0100" />
                    <attachment id="12456329" name="LUCENE-2529_skip_posIncr_for_1st_token.patch" size="8576" author="dsmiley" created="Mon, 4 Oct 2010 22:51:02 +0100" />
                    <attachment id="12456209" name="LUCENE-2529_skip_posIncr_for_1st_token.patch" size="4634" author="dsmiley" created="Sat, 2 Oct 2010 19:49:54 +0100" />
                    <attachment id="12456177" name="LUCENE-2529_skip_posIncr_for_1st_token.patch" size="3524" author="dsmiley" created="Sat, 2 Oct 2010 05:27:45 +0100" />
                    <attachment id="12456305" name="LUCENE-2529_test.patch" size="3424" author="rcmuir" created="Mon, 4 Oct 2010 19:41:32 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 9 Jul 2010 10:12:46 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11298</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25163</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>