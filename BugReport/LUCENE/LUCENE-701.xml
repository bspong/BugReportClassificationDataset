<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:04:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-701/LUCENE-701.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-701] Lock-less commits</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-701</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is a patch based on discussion a while back on lucene-dev:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200608.mbox/%3c44E5B16D.4010805@mikemccandless.com%3e&quot; class=&quot;external-link&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200608.mbox/%3c44E5B16D.4010805@mikemccandless.com%3e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The approach is a small modification over the original discussion (see&lt;br/&gt;
Retry Logic below).  It works correctly in all my cross-machine test&lt;br/&gt;
case, but I want to open it up for feedback, testing by&lt;br/&gt;
users/developers in more diverse environments, etc.&lt;/p&gt;

&lt;p&gt;This is a small change to how lucene stores its index that enables&lt;br/&gt;
elimination of the commit lock entirely.  The write lock still&lt;br/&gt;
remains.&lt;/p&gt;

&lt;p&gt;Of the two, the commit lock has been more troublesome for users since&lt;br/&gt;
it typically serves an active role in production.  Whereas the write&lt;br/&gt;
lock is usually more of a design check to make sure you only have one&lt;br/&gt;
writer against the index at a time.&lt;/p&gt;

&lt;p&gt;The basic idea is that filenames are never reused (&quot;write once&quot;),&lt;br/&gt;
meaning, a writer never writes to a file that a reader may be reading&lt;br/&gt;
(there is one exception: the segments.gen file; see &quot;RETRY LOGIC&quot;&lt;br/&gt;
below).  Instead it writes to generational files, ie, segments_1, then&lt;br/&gt;
segments_2, etc.  Besides the segments file, the .del files and norm&lt;br/&gt;
files (.sX suffix) are also now generational.  A generation is stored&lt;br/&gt;
as an &quot;_N&quot; suffix before the file extension (eg, _p_4.s0 is the&lt;br/&gt;
separate norms file for segment &quot;p&quot;, generation 4).&lt;/p&gt;

&lt;p&gt;One important benefit of this is it avoids files contents caching&lt;br/&gt;
entirely (the likely cause of errors when readers open an index&lt;br/&gt;
mounted on NFS) since the file is always a new file.&lt;/p&gt;

&lt;p&gt;With this patch I can reliably instantiate readers over NFS when a&lt;br/&gt;
writer is writing to the index.  However, with NFS, you are still forced to&lt;br/&gt;
refresh your reader once a writer has committed because &quot;point in&lt;br/&gt;
time&quot; searching doesn&apos;t work over NFS (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-673&quot; title=&quot;Exceptions when using Lucene over NFS&quot;&gt;&lt;del&gt;LUCENE-673&lt;/del&gt;&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;The changes are fully backwards compatible: you can open an old index&lt;br/&gt;
for searching, or to add/delete docs, etc.  I&apos;ve added a new unit test&lt;br/&gt;
to test these cases.&lt;/p&gt;

&lt;p&gt;All units test pass, and I&apos;ve added a number of additional unit tests,&lt;br/&gt;
some of which fail on WIN32 in the current lucene but pass with this&lt;br/&gt;
patch.  The &quot;fileformats.xml&quot; has been updated to describe the changes&lt;br/&gt;
to the files (but XXX references need to be fixed before committing).&lt;/p&gt;

&lt;p&gt;There are some other important benefits:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Readers are now entirely read-only.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Readers no longer block one another (false contention) on&lt;br/&gt;
    initialization.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;On hitting contention, we immediately retry instead of a fixed&lt;br/&gt;
    (default 1.0 second now) pause.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;No file renaming is ever done.  File renaming has caused sneaky&lt;br/&gt;
    access denied errors on WIN32 (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-665&quot; title=&quot;temporary file access denied on Windows&quot;&gt;&lt;del&gt;LUCENE-665&lt;/del&gt;&lt;/a&gt; ).  (Yonik, I used&lt;br/&gt;
    your approach here to not rename the segments_N file(try&lt;br/&gt;
    segments_(N-1) on hitting IOException on segments_N): the separate&lt;br/&gt;
    &quot;.done&quot; file did not work reliably under very high stress testing&lt;br/&gt;
    when a directory listing was not &quot;point in time&quot;).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;On WIN32, you can now call IndexReader.setNorm() even if other&lt;br/&gt;
    readers have the index open (fixes a pre-existing minor bug in&lt;br/&gt;
    Lucene).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;On WIN32, You can now create an IndexWriter with create=true even&lt;br/&gt;
    if readers have the index open (eg see&lt;br/&gt;
    www.gossamer-threads.com/lists/lucene/java-user/39265) .&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Here&apos;s an overview of the changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Every commit writes to the next segments_(N+1).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Loading the segments_N file (&amp;amp; opening the segments) now requires&lt;br/&gt;
    retry logic.  I&apos;ve captured this logic into a new static class:&lt;br/&gt;
    SegmentInfos.FindSegmentsFile.  All places that need to do&lt;br/&gt;
    something on the current segments file now use this class.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;No more deletable file.  Instead, the writer computes what&apos;s&lt;br/&gt;
    deletable on instantiation and updates this in memory whenever&lt;br/&gt;
    files can be deleted (ie, when it commits).  Created a common&lt;br/&gt;
    class index.IndexFileDeleter shared by reader &amp;amp; writer, to manage&lt;br/&gt;
    deletes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Storing more information into segments info file: whether it has&lt;br/&gt;
    separate deletes (and which generation), whether it has separate&lt;br/&gt;
    norms, per field (and which generation), whether it&apos;s compound or&lt;br/&gt;
    not.  This is instead of relying on IO operations (file exists&lt;br/&gt;
    calls).  Note that this fixes the current misleading&lt;br/&gt;
    FileNotFoundException users now see when an _X.cfs file is missing&lt;br/&gt;
    (eg &lt;a href=&quot;http://www.nabble.com/FileNotFound-Exception-t6987.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/FileNotFound-Exception-t6987.html&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed some small things about RAMDirectory that were not&lt;br/&gt;
    filesystem-like (eg opening a non-existent IndexInput failed to&lt;br/&gt;
    raise IOException; renames were not atomic).  I added a stress&lt;br/&gt;
    test against a RAMDirectory (1 writer thread &amp;amp; 2 reader threads)&lt;br/&gt;
    that uncovered these.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added option to not remove old files when create=true on creating&lt;br/&gt;
    FSDirectory; this is so the writer can do its own [more&lt;br/&gt;
    sophisticated because it retries on errors] removal.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Removed all references to commit lock, COMMIT_LOCK_TIMEOUT, etc.&lt;br/&gt;
    (This is an API change).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Extended index/IndexFileNames.java and index/IndexFileNameFilter.java&lt;br/&gt;
    with logic for computing generational file names.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed index/IndexFileNameFilter.java to use a HashSet to check&lt;br/&gt;
    file extentsions for better performance.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed the test case TestIndexReader.testLastModified: it was&lt;br/&gt;
    incorrectly (I think?) comparing lastModified to version, of the&lt;br/&gt;
    index.  I fixed that and then added a new test case for version.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Retry Logic (in index/SegmentInfos.java)&lt;/p&gt;

&lt;p&gt;If a reader tries to load the segments just as a writer is committing,&lt;br/&gt;
it may hit an IOException.  This is just normal contention.  In&lt;br/&gt;
current Lucene contention causes a &lt;span class=&quot;error&quot;&gt;&amp;#91;default&amp;#93;&lt;/span&gt; 1.0 second pause then&lt;br/&gt;
retry.  With lock-less the contention causes no added delay beyond the&lt;br/&gt;
time to retry.&lt;/p&gt;

&lt;p&gt;When this happens, we first try segments_(N-1) if present, because it&lt;br/&gt;
could be segments_N is still being written.  If that fails, we&lt;br/&gt;
re-check to see if there is now a newer segments_M where M &amp;gt; N and&lt;br/&gt;
advance if so.  Else we retry segments_N once more (since it could be&lt;br/&gt;
it was in process previously but must now be complete since&lt;br/&gt;
segments_(N-1) did not load).&lt;/p&gt;

&lt;p&gt;In order to find the current segments_N file, I list the directory and&lt;br/&gt;
take the biggest segments_N that exists.&lt;/p&gt;

&lt;p&gt;However, under extreme stress testing (5 threads just opening &amp;amp;&lt;br/&gt;
closing readers over and over), on one platform (OS X) I found that&lt;br/&gt;
the directory listing can be incorrect (stale) by up to 1.0 seconds.&lt;br/&gt;
This means the listing will show a segments_N file but that file does&lt;br/&gt;
not exist (fileExists() returns false).&lt;/p&gt;

&lt;p&gt;In order to handle this (and other such platforms), I switched to a&lt;br/&gt;
hybrid approach (originally proposed by Doron Cohen in the original&lt;br/&gt;
thread): on committing, the writer writes to a file &quot;segments.gen&quot; the&lt;br/&gt;
generation it just committed.  It writes 2 identical longs into this&lt;br/&gt;
file.  The retry logic, on detecting that the directory listing is&lt;br/&gt;
stale falls back to the contents of this file.  If that file is&lt;br/&gt;
consistent (the two longs are identical), and, the generation is&lt;br/&gt;
indeed newer than the dir listing, it will use that.&lt;/p&gt;

&lt;p&gt;Finally, if this approach is also stale, we fallback to stepping&lt;br/&gt;
through sequential generations (up to a maximum # tries).  If all 3&lt;br/&gt;
methods fail, we throw the original exception we hit.&lt;/p&gt;

&lt;p&gt;I added a static method SegmentInfos.setInfoStream() which will print&lt;br/&gt;
details of retry attempts.  In the patch it&apos;s set to System.out right&lt;br/&gt;
now (we should turn off before a real commit) so if there are problems&lt;br/&gt;
we can see what retry logic had done.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12354182">LUCENE-701</key>
            <summary>Lock-less commits</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Sat, 28 Oct 2006 00:39:47 +0100</created>
                <updated>Tue, 27 Feb 2007 18:10:35 +0000</updated>
                    <resolved>Fri, 17 Nov 2006 23:22:40 +0000</resolved>
                            <version>2.1</version>
                                <fixVersion>2.1</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>4</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12445298" author="mikemccand" created="Sat, 28 Oct 2006 00:41:51 +0100"  >&lt;p&gt;ZIP file that needs to be put in src/test/org/apache/lucene/index (used by backwards compatibility test).&lt;/p&gt;</comment>
                    <comment id="12445299" author="mikemccand" created="Sat, 28 Oct 2006 00:42:16 +0100"  >&lt;p&gt;ZIP file that needs to be put in src/test/org/apache/lucene/index (used by backwards compatibility test).&lt;/p&gt;</comment>
                    <comment id="12446122" author="yseeley@gmail.com" created="Tue, 31 Oct 2006 23:49:16 +0000"  >&lt;p&gt;Nice job on this very ambitious patch (all 3500 lines of it!) Good tests are certainly important!&lt;/p&gt;

&lt;p&gt;Could you elaborate on how the backward compatibility works w.r.t. modifying an old index?&lt;br/&gt;
How do versioned norms &amp;amp; del files mix with older unversion files?&lt;/p&gt;

&lt;p&gt;In the absense of contention, have you noticed any performance differences in opening an IndexReader?&lt;/p&gt;

&lt;p&gt;&amp;gt; on one platform (OS X) I found that the directory listing can be incorrect (stale) by up to 1.0 seconds. &lt;/p&gt;

&lt;p&gt;That sucks... (but great job on the very thorough testing).&lt;br/&gt;
Can it happen with the latest version of OS X?  If not, couldn&apos;t we just require an upgrade, or do you think that other platforms suffer from this.&lt;/p&gt;</comment>
                    <comment id="12446342" author="mikemccand" created="Wed, 1 Nov 2006 18:34:13 +0000"  >&lt;p&gt;Thanks Yonik for looking at this!&lt;/p&gt;

&lt;p&gt;&amp;gt; Could you elaborate on how the backward compatibility works w.r.t. modifying an old index?&lt;br/&gt;
&amp;gt; How do versioned norms &amp;amp; del files mix with older unversion files?&lt;/p&gt;

&lt;p&gt;OK, first off, the only file whose contents and name are changed is&lt;br/&gt;
the &quot;segments_N&quot; file.  Then, the only files whose name (but not&lt;br/&gt;
contents) is changed are the &quot;_X_N.del&quot; deletes file, and &quot;_X_N.sZ&quot;&lt;br/&gt;
separate norms files).  Finally, the only file that is deleted is&lt;br/&gt;
deletable.  All other segments files are unchanged.&lt;/p&gt;

&lt;p&gt;The unit test I added for this (TestBackwardsCompatibility) un-zips a&lt;br/&gt;
pre-lockless index (I have one zip file for CFS format and one for&lt;br/&gt;
non-CFS) and then runs various tests: adding docs, deleting a doc,&lt;br/&gt;
setting a norm for a doc, searching, etc., verifying that the results&lt;br/&gt;
are then as expected.&lt;/p&gt;

&lt;p&gt;On opening an pre-lockless index, first we see only a &quot;segments&quot; file&lt;br/&gt;
with no _N extension, and record its generation as 0.  Second, since&lt;br/&gt;
that file&apos;s contents doesn&apos;t lead with format lockless code (-2), we&lt;br/&gt;
know to load the old segments info format that does not contain the&lt;br/&gt;
&quot;del&quot; gen, &quot;separate norm&quot; gen nor the &quot;isCompundFile&quot; marker.&lt;/p&gt;

&lt;p&gt;When loading each Segmentinfo, since the format of the segments files&lt;br/&gt;
was old, we record this with &quot;preLockless = true&quot; and set delGen and&lt;br/&gt;
isCompoundFile to 0 and normGen to null.  0 means &quot;must check&lt;br/&gt;
filesystem for existence&quot;.  The various methods (hasSeparateNorms,&lt;br/&gt;
hasDeletions, etc.) know to handle these &quot;0&quot; cases as falling back to&lt;br/&gt;
filesystem existence checks of the existing naming (ie, _X.del).  I&lt;br/&gt;
tried to capture / contain all of this inside the methods of&lt;br/&gt;
SegmentInfo.&lt;/p&gt;

&lt;p&gt;Now, when a writer commits to this pre-lockless index, we write in the&lt;br/&gt;
new (format lockless) format and to the file &quot;segments_1&quot;.  (Actually,&lt;br/&gt;
with compound file turned on, we then make a .cfs file and commit&lt;br/&gt;
again to &quot;segments_2&quot;).  This file will reference all of the old&lt;br/&gt;
segments (except eg those deleted by a merge) plus the one new&lt;br/&gt;
segment.&lt;/p&gt;

&lt;p&gt;The old segments have written the &quot;0&quot;&apos;s for delGen, normGen (null is&lt;br/&gt;
written as -1 length), isCompoundFile so that on re-loading this&lt;br/&gt;
segments_2 file these segments remain pre-lockless.  The SegmentInfo&lt;br/&gt;
for the new segment file will have isCompoundFile=1 (meaning it is a&lt;br/&gt;
compound file), delGen=-1 (there are no separate deletes yet) and&lt;br/&gt;
normGen=null (there are no separate norms yet).  When normGen is null,&lt;br/&gt;
we look at &quot;preLockless&quot; to differentiate whether this means there are&lt;br/&gt;
no separate norms at all for any fields, or, this segment is pre&lt;br/&gt;
lockless and therefore we must fallback to the filesystem check.&lt;/p&gt;

&lt;p&gt;If a delete or setNorm call takes place against an old segment format,&lt;br/&gt;
we will at that time create &quot;generation 1&quot; for that file.  This means&lt;br/&gt;
you can have an old segment whose separate del file is still&lt;br/&gt;
&quot;generation 0&quot; (you have to check for existence of _X.del) but whose&lt;br/&gt;
separate norms generations are known (or, only certain fields are&lt;br/&gt;
known and the others are &quot;generation 0&quot; and require filesystem check).&lt;br/&gt;
This means an &quot;old&quot; segment file could become &quot;slightly newer&quot; as&lt;br/&gt;
norm/del changes are made against it.&lt;/p&gt;

&lt;p&gt;So an index can have mixed old/new segments.  The SegmentInfo for each&lt;br/&gt;
segment keeps track of old/new (and tries to hide these implementation&lt;br/&gt;
details under its methods) with delGen, normGen, isCompoundFile and&lt;br/&gt;
preLockless (which is derived from isCompoundFile).&lt;/p&gt;

&lt;p&gt;Once an optimize is done, or, all old segments have been merged away,&lt;br/&gt;
then all segments are now the lockless format.&lt;/p&gt;
</comment>
                    <comment id="12446344" author="mikemccand" created="Wed, 1 Nov 2006 18:35:38 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; on one platform (OS X) I found that the directory listing can be incorrect (stale) by up to 1.0 seconds.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; That sucks... (but great job on the very thorough testing).&lt;br/&gt;
&amp;gt; Can it happen with the latest version of OS X? If not, couldn&apos;t we just require an upgrade, or do you think that other platforms suffer from this.&lt;/p&gt;

&lt;p&gt;Yes, this was very surprising and annoying!  Unfortunately, this&lt;br/&gt;
happens on the latest version of OS X (10.4.8).  Other platforms that&lt;br/&gt;
I tested do &quot;the right thing&quot; meaning when you list a directory the&lt;br/&gt;
NFS client on Linux first checks with the server to see if its cache&lt;br/&gt;
is stale and correctly clears the cache.  Windows SMB is also always&lt;br/&gt;
correct.  But I think it&apos;s entirely likely that filesystems do this&lt;br/&gt;
kind of time-based (only) cache validation. I figured better safe than&lt;br/&gt;
sorry here, and Lucene should tolerate stale caching around either&lt;br/&gt;
file contents or directory listing.&lt;/p&gt;</comment>
                    <comment id="12446346" author="mikemccand" created="Wed, 1 Nov 2006 18:42:35 +0000"  >&lt;p&gt;&amp;gt; In the absense of contention, have you noticed any performance differences in opening an IndexReader? &lt;/p&gt;

&lt;p&gt;[First one side note: it&apos;s during contention that lock-less really&lt;br/&gt;
shines.  Because, currently Lucene hits at least a &lt;span class=&quot;error&quot;&gt;&amp;#91;default&amp;#93;&lt;/span&gt; 1.0&lt;br/&gt;
second delay under contention, whereas lockless immediately retries.&lt;br/&gt;
And, readers now have contention with one another, but not with&lt;br/&gt;
lock-less.]&lt;/p&gt;

&lt;p&gt;I ran the following basic performance test.  In each case I measure&lt;br/&gt;
avg wall clock time to instantiate readers &amp;amp; writers against the same&lt;br/&gt;
index.  A writer creates the index, adding documents as quickly as it&lt;br/&gt;
can, and commits and closes/reopens its writer every 2 seconds.  Then,&lt;br/&gt;
a reader reads against the same index, just instantiating a searcher&lt;br/&gt;
then closing it and then pausing for 2 seconds.  I skew the writer by&lt;br/&gt;
1 sec to try to minimize contention.  Each test is avg of 3 runs,&lt;br/&gt;
where each run is 2 minutes.&lt;/p&gt;

&lt;p&gt;In order to not count contention, I made temporary mods, to both&lt;br/&gt;
current lucene &amp;amp; lockless, to throw IOException on hitting contention.&lt;br/&gt;
Then, I catch that above and discard the time for that one&lt;br/&gt;
instantiation of reader or writer.&lt;/p&gt;

&lt;p&gt;All times are mili-seconds.  Each time is formatted as current Lucene&lt;br/&gt;
time followed by lockless in (...)s:&lt;/p&gt;

&lt;p&gt;       Local index (Linux):   4.62  (6.04)&lt;br/&gt;
       Local index (WIN32):  85.45 (66.37)&lt;/p&gt;

&lt;p&gt;  NFS remote index (Linux): 171.26 (11.04)&lt;br/&gt;
  SMB remote index (WIN32):  48.91 (31.55)&lt;/p&gt;

&lt;p&gt;The &quot;remote index&quot; case means a writer on that OS, and a reader on&lt;br/&gt;
another machine with the same OS, reading the index on a mount from&lt;br/&gt;
the writer machine (ie, writer is writing locally and reader is&lt;br/&gt;
reading remotely).&lt;/p&gt;

&lt;p&gt;One caveat: I saw quite a bit of variance between runs.  I tried to&lt;br/&gt;
eliminate causes (stopped all services, other applications, etc.)  but&lt;br/&gt;
still there is variance.  Maybe I should be taking the &quot;minumum&quot; time&lt;br/&gt;
seen instead of the average (this was mentioned on the benchmarking&lt;br/&gt;
Jira issue)...&lt;/p&gt;

&lt;p&gt;Anyway, the surprising thing is that lockless is faster in most cases&lt;br/&gt;
In the remote cases (especially NFS) it&apos;s quite a bit faster.  I think&lt;br/&gt;
this may be because lockless does far fewer &quot;fileExists&quot; calls&lt;br/&gt;
compared to current Lucene.  For example, the &quot;openNorms&quot; call&lt;br/&gt;
presently does a &quot;fileExists&quot; call per field that has norms index&lt;br/&gt;
times the number of segments.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure these speedups/differences are all that important in a&lt;br/&gt;
typical Lucene use case, where the cost of instantiating a reader is&lt;br/&gt;
amortized over all the searches that occur during the lifetime of that&lt;br/&gt;
reader.  Though, maybe one real difference is: if we can make sure the&lt;br/&gt;
latency is low enough, it&apos;s OK to have a single query pay the price of&lt;br/&gt;
reopening the searcher.  Ie, it becomes reasonable to have an incoming&lt;br/&gt;
query first check whether the searcher is current and if not, reopen&lt;br/&gt;
it, and then run the query, vs having separate background thread do&lt;br/&gt;
this, which is certainly feasible just more complicated.&lt;/p&gt;</comment>
                    <comment id="12446397" author="yseeley@gmail.com" created="Wed, 1 Nov 2006 22:55:25 +0000"  >&lt;p&gt;Thanks for all the details Michael!  A few more random comments and questions:&lt;/p&gt;

&lt;p&gt;In the future, it might be nice if there was an option to disable segments.gen to be more friendly to write-once filesystems like HDFS.&lt;/p&gt;

&lt;p&gt;As far as performance goes, I was personally interested in the contentionless case since that&apos;s what processes that coordinate everything (like Solr) will see.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure I understand the &quot;segments.gen&quot; logic of writing two longs that are identical.&lt;br/&gt;
Looking at the code, it doesn&apos;t seem like you are implementing this:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/Re%3A-Lock-less-commits-p5978090.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/Re%3A-Lock-less-commits-p5978090.html&lt;/a&gt;&lt;br/&gt;
Are there two longs instead of one in order to leave &quot;space&quot; for that implementation if needed, w/o having to change the file format?&lt;/p&gt;

&lt;p&gt;The file deleting code does much more than in the past, and that&apos;s a good thing IMO.  For example it looks like leftover non-compound segment files from a failed CFS merge (say the JVM dies) will now be cleaned up!&lt;/p&gt;

&lt;p&gt;I&apos;m having a hard time figuring out how older delete files are removed (since they contain the current segment name, it looks like findDeletableFiles would skip them).&lt;/p&gt;</comment>
                    <comment id="12446628" author="mikemccand" created="Thu, 2 Nov 2006 15:19:16 +0000"  >&lt;p&gt;Good questions!&lt;/p&gt;

&lt;p&gt;&amp;gt; In the future, it might be nice if there was an option to disable&lt;br/&gt;
&amp;gt; segments.gen to be more friendly to write-once filesystems like&lt;br/&gt;
&amp;gt; HDFS.&lt;/p&gt;

&lt;p&gt;I think this makes sense.  I will add control over this on the next&lt;br/&gt;
iteration of the patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; As far as performance goes, I was personally interested in the&lt;br/&gt;
&amp;gt; contentionless case since that&apos;s what processes that coordinate&lt;br/&gt;
&amp;gt; everything (like Solr) will see.&lt;/p&gt;

&lt;p&gt;Ahh got it, OK.  That&apos;s fair.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m not sure I understand the &quot;segments.gen&quot; logic of writing two&lt;br/&gt;
&amp;gt; longs that are identical.  Looking at the code, it doesn&apos;t seem like&lt;br/&gt;
&amp;gt; you are implementing this:&lt;br/&gt;
&amp;gt; &lt;a href=&quot;http://www.nabble.com/Re%3A-Lock-less-commits-p5978090.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/Re%3A-Lock-less-commits-p5978090.html&lt;/a&gt;&lt;br/&gt;
&amp;gt; Are there two longs instead of one in order to leave &quot;space&quot; for&lt;br/&gt;
&amp;gt; that implementation if needed, w/o having to change the file format?&lt;/p&gt;

&lt;p&gt;Right, I settled on a simplification of that approach.  I write two&lt;br/&gt;
longs so that reader can read both &amp;amp; compare and only trust them if they&lt;br/&gt;
are identical.  With one long I was worried eg that perhaps 3 bytes&lt;br/&gt;
from the writer were written but not yet the remaining 5 bytes, and&lt;br/&gt;
then reader would get the wrong value.  I don&apos;t think IO systems&lt;br/&gt;
guarantee atomicity of eg 8 byte chunks (though in practice it&apos;s&lt;br/&gt;
probably often the case).&lt;/p&gt;

&lt;p&gt;One thing I will also add is a version header to this file.&lt;/p&gt;

&lt;p&gt;&amp;gt; The file deleting code does much more than in the past, and that&apos;s a&lt;br/&gt;
&amp;gt; good thing IMO.  For example it looks like leftover non-compound&lt;br/&gt;
&amp;gt; segment files from a failed CFS merge (say the JVM dies) will now be&lt;br/&gt;
&amp;gt; cleaned up!&lt;/p&gt;

&lt;p&gt;Oh, right!  In fact any time an index crashes not having committed its&lt;br/&gt;
segments file, there is potential for leftover (unreferenced) files&lt;br/&gt;
now.  This separate IndexFileDeleter class should correctly reclaim in&lt;br/&gt;
such cases.  And even other potential future situations like the&lt;br/&gt;
discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-702&quot; title=&quot;Disk full during addIndexes(Directory[]) can corrupt index&quot;&gt;&lt;del&gt;LUCENE-702&lt;/del&gt;&lt;/a&gt; would be reclaimed correctly with this&lt;br/&gt;
approach.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m having a hard time figuring out how older delete files are&lt;br/&gt;
&amp;gt; removed (since they contain the current segment name, it looks like&lt;br/&gt;
&amp;gt; findDeletableFiles would skip them).&lt;/p&gt;

&lt;p&gt;Oooh &amp;#8211; you are correct.  I do record this file for deleting at the&lt;br/&gt;
point it becomes unreferenced (ie, as a reader is committing its&lt;br/&gt;
separate norms/deletes), and then I delete this file after the commit&lt;br/&gt;
is done.  But if JVM crashes after the new del file was written and&lt;br/&gt;
before the commit, then you&apos;re right on restarting I don&apos;t correctly&lt;br/&gt;
delete the unreferenced old _X_N.del files, nor I believe the separate&lt;br/&gt;
norms _X_N.sM files.  I will add a unit test to verify this bug and&lt;br/&gt;
then fix it &amp;#8211; good catch!&lt;/p&gt;</comment>
                    <comment id="12446638" author="ningli" created="Thu, 2 Nov 2006 16:11:02 +0000"  >&lt;p&gt;Can the following scenario happen with lock-less commits?&lt;/p&gt;

&lt;p&gt;1 A reader reads segments.1, which says the index contains seg_1.&lt;br/&gt;
2 A writer writes segments.2, which says the index now contains seg_2, and deletes seg_1.&lt;br/&gt;
3 The reader tries to load seg_1 and fails.&lt;/p&gt;</comment>
                    <comment id="12446649" author="yseeley@gmail.com" created="Thu, 2 Nov 2006 16:51:05 +0000"  >&lt;p&gt;&amp;gt; 3 The reader tries to load seg_1 and fails. &lt;/p&gt;

&lt;p&gt;That wouldn&apos;t be considered a failure because it&apos;s part of the retry logic.  At that point, an attempt would be made to open seg_2.&lt;br/&gt;
To minimize the possibility of this happening, the segments are opened in reverse order (since the last segments change the most often).&lt;/p&gt;

&lt;p&gt;Then a question might be, could a writer possibly change the index fast enough to prevent a reader from opening at all?  I don&apos;t think so (and it would be a mis-configured writer IMO), but maybe Michael could speak to that.&lt;/p&gt;</comment>
                    <comment id="12446656" author="ningli" created="Thu, 2 Nov 2006 17:18:24 +0000"  >&lt;p&gt;&amp;gt; That wouldn&apos;t be considered a failure because it&apos;s part of the retry logic. At that point, an attempt would be made to open seg_2. &lt;/p&gt;

&lt;p&gt;From the description of the retry logic, I thought the retry logic only applies to the loading of the &quot;segments_N&quot; file, but not to the entire process of loading all the files of an index.&lt;/p&gt;

&lt;p&gt;You are right, it wouldn&apos;t be a failure if the retry logic is applied to the loading of all the files of an index.&lt;/p&gt;</comment>
                    <comment id="12446665" author="yseeley@gmail.com" created="Thu, 2 Nov 2006 17:41:49 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; In the future, it might be nice if there was an option to disable&lt;br/&gt;
&amp;gt; &amp;gt; segments.gen to be more friendly to write-once filesystems like&lt;br/&gt;
&amp;gt; &amp;gt; HDFS.&lt;br/&gt;
&amp;gt; I think this makes sense. I will add control over this on the next&lt;br/&gt;
&amp;gt; iteration of the patch. &lt;/p&gt;

&lt;p&gt;Just to be clear, I didn&apos;t mean that I thought it was needed now... &lt;br/&gt;
there is another place in Lucene that prevents write-once from working (segment file lengths at the beginning IIRC).&lt;/p&gt;

&lt;p&gt;When this option is added, perhaps the configuration name should be generic and not tied to the implementation specifics that could change more frequently?  Something like WRITE_ONCE or setWriteOnce()?&lt;/p&gt;</comment>
                    <comment id="12446677" author="mikemccand" created="Thu, 2 Nov 2006 18:13:49 +0000"  >
&lt;p&gt;Right, this is just normal contention.  We do indeed retry around not&lt;br/&gt;
only loading of segments_N but also the loading of the individual&lt;br/&gt;
segments files.  There are other places (eg lastModified()) that do&lt;br/&gt;
other things with the segments file.  These places also use the retry&lt;br/&gt;
logic.&lt;/p&gt;

&lt;p&gt;In Lucene currently, contention causes a pause (default 1.0 second)&lt;br/&gt;
and then retry to obtain the commit lock.  With lockless, we simply&lt;br/&gt;
retry immediately loading the latest segments_N file.&lt;/p&gt;

&lt;p&gt;It&apos;s important to note that at any given instant, the index is always&lt;br/&gt;
&quot;consistent&quot; (well, except for issues like &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-702&quot; title=&quot;Disk full during addIndexes(Directory[]) can corrupt index&quot;&gt;&lt;del&gt;LUCENE-702&lt;/del&gt;&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;But, because a reader takes non-zero time to load the index, you can&lt;br/&gt;
hit contention if a writer&apos;s commit spans that time.  If a reader&lt;br/&gt;
could load an index in zero time there would never be contention.&lt;/p&gt;

&lt;p&gt;There are several ways that contention will manifest itself.  These&lt;br/&gt;
are just the different alignments / convolutions of the series of&lt;br/&gt;
steps that reader goes through &quot;sliding against&quot; the series of steps&lt;br/&gt;
that a writer goes through:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Reader opens the segments_N but in reading it hits EOF because&lt;br/&gt;
    writer has not finished writing it yet.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Reader opens segments_N, fully reads its contents, but then hits&lt;br/&gt;
    IOException on loading each segment file because during this team&lt;br/&gt;
    writer has committed and is now deleting segments files.  This&lt;br/&gt;
    case is your example above.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Reader opens segments_N, but hits IOException while reading its&lt;br/&gt;
    contents because it was deleted by writer before reader could read&lt;br/&gt;
    all of its contents (should only happen on fileystems that don&apos;t&lt;br/&gt;
    do &quot;delete on last close&quot; or &quot;can&apos;t delete open files&quot;).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Reader takes listing of directory, locates segments_N, but fails&lt;br/&gt;
    to open that file because writer has now removed it.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Anyway, on hitting an IOException, we first retry segments_N-1 (if it&lt;br/&gt;
exists).  Failing that we recheck the directory for latest segments_N.&lt;br/&gt;
If N has advanced we try that.  If N has not advanced we give it one&lt;br/&gt;
more chance to load (since it could be on first try we hit case 1&lt;br/&gt;
above).  If it fails that second chance and on re-listing we are still&lt;br/&gt;
at N, we throw the original exception we hit.&lt;/p&gt;

&lt;p&gt;I added a couple of tests cases to TestIndexWriter to verify that a&lt;br/&gt;
messed up index indeed throws an IOException.&lt;/p&gt;

&lt;p&gt;On Yonik&apos;s question:&lt;/p&gt;

&lt;p&gt;&amp;gt; Then a question might be, could a writer possibly change the index&lt;br/&gt;
&amp;gt; fast enough to prevent a reader from opening at all?  I don&apos;t think&lt;br/&gt;
&amp;gt; so (and it would be a mis-configured writer IMO), but maybe Michael&lt;br/&gt;
&amp;gt; could speak to that.&lt;/p&gt;

&lt;p&gt;This is definitely possible.  This really is a form of &quot;starvation&quot;.&lt;br/&gt;
If a writer is committing too fast, or, readers are constantly&lt;br/&gt;
re-opening too fast, they will starve one another.&lt;/p&gt;

&lt;p&gt;Both current Lucene and lockless will hit starvation under high enough&lt;br/&gt;
rate of commit/opens, but, different things happen.  EG &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-307&quot; title=&quot;Lock obtain time out errors when opening readers and writers&quot;&gt;&lt;del&gt;LUCENE-307&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
issue is exactly this case on the current Lucene.  Lockless will retry&lt;br/&gt;
indefinitely though may at some point succeed (but take many&lt;br/&gt;
retries to do so).&lt;/p&gt;

&lt;p&gt;Still, I think the point at which starvation starts to happen is far&lt;br/&gt;
beyond a normal usage of Lucene (ie, committing &amp;gt; ten times / sec).&lt;/p&gt;</comment>
                    <comment id="12446678" author="mikemccand" created="Thu, 2 Nov 2006 18:18:11 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; In the future, it might be nice if there was an option to disable&lt;br/&gt;
&amp;gt; &amp;gt; segments.gen to be more friendly to write-once filesystems like&lt;br/&gt;
&amp;gt; &amp;gt; HDFS.&lt;br/&gt;
&amp;gt; I think this makes sense. I will add control over this on the next&lt;br/&gt;
&amp;gt; iteration of the patch.&lt;/p&gt;

&lt;p&gt;&amp;gt; Just to be clear, I didn&apos;t mean that I thought it was needed now...&lt;br/&gt;
&amp;gt; there is another place in Lucene that prevents write-once from&lt;br/&gt;
&amp;gt; working (segment file lengths at the beginning IIRC).&lt;/p&gt;

&lt;p&gt;&amp;gt; When this option is added, perhaps the configuration name should be&lt;br/&gt;
&amp;gt; generic and not tied to the implementation specifics that could change&lt;br/&gt;
&amp;gt; more frequently? Something like WRITE_ONCE or setWriteOnce()?&lt;/p&gt;

&lt;p&gt;OK, I see, this is part of a wider context.  Maybe it&apos;s the creation&lt;br/&gt;
of the compound file you&apos;re thinking of?  That writes 0&apos;s into the&lt;br/&gt;
header, adds the files, then rewinds and puts the actual offsets into&lt;br/&gt;
it.  Then let&apos;s open a separate issue to track this &amp;#8211; I&apos;ll do that.&lt;br/&gt;
Don&apos;t want to make this patch any bigger!&lt;/p&gt;</comment>
                    <comment id="12447508" author="mikemccand" created="Mon, 6 Nov 2006 19:26:45 +0000"  >&lt;p&gt;OK, another version of the lockless commits patch with these fixes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added new unit test (TestIndexFileDeleter) for deleter, caught the&lt;br/&gt;
    above bug Yonik found (we can fail to delete orphan&apos;d separate&lt;br/&gt;
    del/norm files), fixed it, and unit test now passes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We were also failing to deleted orphan&apos;d .fN files (norm files&lt;br/&gt;
    that do get included into CFS file).  Fixed that case too.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added version header to segments.gen file.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added static setter/getters for advanced configuration of the&lt;br/&gt;
    retry logic.  Note: this required making the SegmentInfos class&lt;br/&gt;
    public.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You still need to put those two zip files into&lt;br/&gt;
src/test/org/apache/lucene/index after applying this patch.&lt;/p&gt;

&lt;p&gt;This addresses all feedback/TODOs that I knew about.&lt;/p&gt;

&lt;p&gt;All unit tests pass.&lt;/p&gt;</comment>
                    <comment id="12447574" author="yseeley@gmail.com" created="Mon, 6 Nov 2006 22:59:57 +0000"  >&lt;p&gt;Looks good Michael, I think this is ready to commit!&lt;br/&gt;
Does anyone have any concerns with this going into the trunk?&lt;/p&gt;</comment>
                    <comment id="12447601" author="steven_parkes" created="Tue, 7 Nov 2006 01:12:14 +0000"  >&lt;p&gt;I&apos;m all for the patch ... the only thing I&apos;m wondering is about release timing, if that&apos;s issue? This changes the on-disk format, which affects more than Lucene Java and, should anyone that&apos;s using Lucene out there care (via scripts, etc.), the naming of files on disk.&lt;/p&gt;

&lt;p&gt;I&apos;m just wondering if there&apos;s any interest/reason for doing a 2.1 before something with those side effects?&lt;/p&gt;</comment>
                    <comment id="12448892" author="otis" created="Fri, 10 Nov 2006 23:25:24 +0000"  >&lt;p&gt;Steven - I don&apos;t see any issues with this going in before 2.1.  As a matter of fact, this may be a sufficiently substantial change that will make us want to make a 2.1 release.&lt;/p&gt;

&lt;p&gt;Maybe Michael should commit this next week.&lt;/p&gt;</comment>
                    <comment id="12448902" author="mikemccand" created="Sat, 11 Nov 2006 00:13:35 +0000"  >&lt;p&gt;Oooh &amp;#8211; I would love to!&lt;/p&gt;</comment>
                    <comment id="12476269" author="mikemccand" created="Tue, 27 Feb 2007 18:10:35 +0000"  >&lt;p&gt;Closing all issues that were resolved for 2.1.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12343820" name="index.prelockless.cfs.zip" size="3837" author="mikemccand" created="Sat, 28 Oct 2006 00:41:51 +0100" />
                    <attachment id="12343821" name="index.prelockless.nocfs.zip" size="11147" author="mikemccand" created="Sat, 28 Oct 2006 00:42:16 +0100" />
                    <attachment id="12344414" name="lockless-commits-patch2.txt" size="115943" author="mikemccand" created="Mon, 6 Nov 2006 19:26:45 +0000" />
                    <attachment id="12343819" name="lockless-commits-patch.txt" size="127402" author="mikemccand" created="Sat, 28 Oct 2006 00:40:23 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 31 Oct 2006 23:49:16 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13051</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27029</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>