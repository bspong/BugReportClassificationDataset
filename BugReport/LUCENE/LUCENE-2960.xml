<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:03:21 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2960/LUCENE-2960.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2960] Allow (or bring back) the ability to setRAMBufferSizeMB on an open IndexWriter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2960</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;In 3.1 the ability to setRAMBufferSizeMB is deprecated, and removed in trunk. It would be great to be able to control that on a live IndexWriter. Other possible two methods that would be great to bring back are setTermIndexInterval and setReaderTermsIndexDivisor. Most of the other setters can actually be set on the MergePolicy itself, so no need for setters for those (I think).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12501011">LUCENE-2960</key>
            <summary>Allow (or bring back) the ability to setRAMBufferSizeMB on an open IndexWriter</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="kimchy">Shay Banon</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Mar 2011 12:28:47 +0000</created>
                <updated>Wed, 30 Mar 2011 16:49:52 +0100</updated>
                    <resolved>Fri, 18 Mar 2011 12:42:49 +0000</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="13005303" author="mikemccand" created="Thu, 10 Mar 2011 20:08:49 +0000"  >&lt;p&gt;Pulling back into 3.1 as blocker.&lt;/p&gt;</comment>
                    <comment id="13005305" author="mikemccand" created="Thu, 10 Mar 2011 20:10:38 +0000"  >&lt;p&gt;If you call IWC.setRAMBufferSizeMB even after the IW is init&apos;d, this &lt;b&gt;almost&lt;/b&gt; works; I think the only problem is that DocumentsWriter has a private copy of the RAM buffer size.  We can simply fix that (it can pull from config, too), and then re-enable the test we used to have that asserts that live changes to the RAM buffer take effect.&lt;/p&gt;</comment>
                    <comment id="13005311" author="yseeley@gmail.com" created="Thu, 10 Mar 2011 20:22:38 +0000"  >&lt;p&gt;IMO, this is such an obscure usecase that we shouldn&apos;t introduce any extra complexity to implement it.&lt;br/&gt;
For example, we should not guarantee exactly &lt;b&gt;when&lt;/b&gt; a change to setRAMBufferSizeMB will be seen... that could introduce the need for extra synchronization / memory barriers.&lt;/p&gt;</comment>
                    <comment id="13005317" author="rcmuir" created="Thu, 10 Mar 2011 20:32:40 +0000"  >&lt;p&gt;my opinion (thanks for setting to 3.1) is solely based on how we do releases:&lt;/p&gt;

&lt;p&gt;I just don&apos;t think we should deprecate things in 3.1, then un-deprecate in 3.2... &lt;/p&gt;

&lt;p&gt;Really this is our mistake, we shouldn&apos;t have committed IWC and left TestIndexWriter.testChangingRamBufferSize or whatever using the deprecated setter without hashing this out further: because this test would fail if it tried to use IWC.&lt;/p&gt;</comment>
                    <comment id="13005322" author="mikemccand" created="Thu, 10 Mar 2011 20:41:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;IMO, this is such an obscure usecase that we shouldn&apos;t introduce any extra complexity to implement it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That this comes from Shay makes it not an &quot;obscure&quot; use case, IMO.&lt;/p&gt;

&lt;p&gt;Ie, Shay (Elastic Search) is doing awesome things with Lucene, so if some change in Lucene is adversely impacting Elastic Search, we should listen.&lt;/p&gt;

&lt;p&gt;We already don&apos;t hear from Shay nearly as often as we should &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For example, we should not guarantee exactly when a change to setRAMBufferSizeMB will be seen... that could introduce the need for extra synchronization / memory barriers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s really an impl. detail.  Ie, what really matters is whether or not this change results in any real change to index throughput.  If a volatile read per indexed doc (w/ rare volatile write) really costs too much (unlikely) then we can make this &quot;best effort&quot;.&lt;/p&gt;</comment>
                    <comment id="13005323" author="mikemccand" created="Thu, 10 Mar 2011 20:44:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;Really this is our mistake, we shouldn&apos;t have committed IWC and left TestIndexWriter.testChangingRamBufferSize or whatever using the deprecated setter without hashing this out further: because this test would fail if it tried to use IWC.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.  Really we should not commit API changes w/o also cutting over all but a few (so we still test the deprecated path) usages of the deprecated API to the new one (and addressing whatever issues that uncovers).&lt;/p&gt;</comment>
                    <comment id="13005328" author="thetaphi" created="Thu, 10 Mar 2011 20:51:25 +0000"  >&lt;p&gt;For the depreciated path we should have backwards tests...&lt;/p&gt;</comment>
                    <comment id="13005617" author="earwin" created="Fri, 11 Mar 2011 12:34:21 +0000"  >&lt;p&gt;As I said on the list - if one needs to change IW config, he can always recreate IW with new settings.&lt;br/&gt;
Such changes cannot happen often enough for recreation to affect indexing performance.&lt;/p&gt;

&lt;p&gt;The fact that you can change IW&apos;s behaviour post-construction by modifying unrelated IWC instance is frightening. IW should either make a private copy of IWC when constructing, or IWC should be made immutable.&lt;/p&gt;</comment>
                    <comment id="13005641" author="mikemccand" created="Fri, 11 Mar 2011 14:07:13 +0000"  >
&lt;blockquote&gt;&lt;p&gt;As I said on the list - if one needs to change IW config, he can always recreate IW with new settings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s not really true, in general.  If you have a large merge running&lt;br/&gt;
then closing the IW can take an unpredictable amount of time.  You&lt;br/&gt;
could abort the merges on close, but that&apos;s obviously not great.&lt;/p&gt;

&lt;p&gt;Furthermore, closing the IW also forces you to commit, and I don&apos;t&lt;br/&gt;
like tying changing of configuration to forcing a commit.&lt;/p&gt;

&lt;p&gt;In fact, it doesn&apos;t make sense to me to arbitrarily prevent settings&lt;br/&gt;
from being live, just because we&apos;ve factored out IWC as a separate&lt;br/&gt;
class.  Many of these settings were &quot;naturally&quot; live before the IWC&lt;br/&gt;
cutover, and have no particular reason not to be (besides this API&lt;br/&gt;
change).&lt;/p&gt;

&lt;p&gt;We could also rollback the IWC change.  I&apos;m not saying that&apos;s a great&lt;br/&gt;
option, but, it should be on the table.&lt;/p&gt;

&lt;p&gt;InfoStream, for example, should remain live: eg, maybe I&apos;m having&lt;br/&gt;
trouble w/ optimize, so, I turn on infoStream and then call optimize.&lt;/p&gt;

&lt;p&gt;The flushing params (maxBufferedDocs/Deletes/RAM) should also remain&lt;br/&gt;
live, since we have a very real user/data point (Shay) relying on&lt;br/&gt;
this.&lt;/p&gt;

&lt;p&gt;But take MergedSegmentWarmer (used to be live but is now unchangeable).&lt;br/&gt;
This is a setting that obviously can easily remain live; there&apos;s no&lt;br/&gt;
technical reason for it not to be.  So why should we force it to be&lt;br/&gt;
unchangeable?  That can only remove freedom, freedom that is perhaps&lt;br/&gt;
valuable to an app somewhere.&lt;/p&gt;</comment>
                    <comment id="13005646" author="yseeley@gmail.com" created="Fri, 11 Mar 2011 14:14:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;InfoStream, for example, should remain live&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree - it&apos;s logging.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But take MergedSegmentWarmer (used to be live but is now unchangeable). This is a setting that obviously can easily remain live; there&apos;s no technical reason for it not to be.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Anyone&apos;s implementation can be live (i.e. the impl could change it&apos;s behavior over time for whatever reason).&lt;/p&gt;</comment>
                    <comment id="13005696" author="mikemccand" created="Fri, 11 Mar 2011 16:12:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;Anyone&apos;s implementation can be live (i.e. the impl could change it&apos;s behavior over time for whatever reason).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, that&apos;s really cheating.  I mean, yes, technically it&apos;s an out, so&lt;br/&gt;
it&apos;s certainly possible that an app can do the switching inside its&lt;br/&gt;
class... but that&apos;s not nice &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;EG if an app has LoadsAllDocsWarmer and VisitsAllPostingsWarmer (say)&lt;br/&gt;
and they want to switch between (for some reason)... they&apos;d like have&lt;br/&gt;
to make a SegmentWarmerSwitcher class or something.&lt;/p&gt;

&lt;p&gt;Seems silly because IW could care less if you switch up your warmer.&lt;br/&gt;
It just needs to get the current warmer every time it goes and warms&lt;br/&gt;
a segment...&lt;/p&gt;
</comment>
                    <comment id="13005891" author="earwin" created="Fri, 11 Mar 2011 23:13:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;Furthermore, closing the IW also forces you to commit, and I don&apos;t like tying changing of configuration to forcing a commit.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Like I said, one isn&apos;t going to change his configuration five times a second. It&apos;s ok to commit from time to time?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So why should we force it to be unchangeable? That can only remove freedom, freedom that is perhaps valuable to an app somewhere.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Each and every live reconfigurable setting adds to complexity.&lt;br/&gt;
At the very least it requires proper synchronization. Take your SegmentWarmer example - you should make the field volatile.&lt;br/&gt;
While it&apos;s possible to chicken out on primitive fields (&lt;a href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.7&quot; class=&quot;external-link&quot;&gt;except long/double&lt;/a&gt;), as Yonik mentioned earlier, making nonvolatile mutable references introduces you to a world of hard-to-catch unsafe publication bugs (yes, infoStream is currently broken!).&lt;br/&gt;
For more complex cases, certain on-change logic is required. And then you have to support this logic across all possible code rewrites and refactorings.&lt;/p&gt;</comment>
                    <comment id="13006049" author="kimchy" created="Sat, 12 Mar 2011 14:54:04 +0000"  >&lt;p&gt;Heya,&lt;/p&gt;

&lt;p&gt;   If I had to choose between being able to change things in real time to better concurrency thanks to immutability, I would definitely go with better concurrency. I have no problems with closing the writers and reopening them, though, as Mike said, this can come with a big cost.&lt;/p&gt;

&lt;p&gt;   The funny thing is that a lot of the setters that were already there on the IndexWriter are still exposed, basically, through settings on the relevant MergePolicy, so I don&apos;t think we are talking about that many setter to begin with (I don&apos;t think we should bring those back to the IndexWriter).&lt;/p&gt;

&lt;p&gt;   I think that the notion of IWC is a good one, and should remain, but only to provide construction time parameters to IW. It should not be consulted once the construction phase of IW is done. If explicit real time parameters are to be set, then IW should expose it as a setter. Now, the question is which, if any, setters should be exposed.&lt;/p&gt;

&lt;p&gt;   Going through the list of current setters on IW, my vote is for the setRAMBufferSizeMB one. I am not sure that its that obscure use case. I believe Solr for example has a notion of cores (or something like that), so it can also be adaptive in terms of indexing buffer size dependent on the number of cores running in the VM. Also, one can easily run a system where it does bulk indexing, and then lowers the indexing buffer size for more &quot;streamline&quot; work. Its just a shame to close the writer for that (and having to pause all indexing work while this happens).&lt;/p&gt;

&lt;p&gt;   The term interval and divisor, I agree, are such obscure (funnily, I use the divisor quite a lot), that closing the writer and opening it again make sense.&lt;/p&gt;</comment>
                    <comment id="13006105" author="mikemccand" created="Sat, 12 Mar 2011 22:56:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;If I had to choose between being able to change things in real time to better concurrency thanks to immutability, I would definitely go with better concurrency.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;re not talking about better concurrency here &amp;#8211; making these fields&lt;br/&gt;
volatile will be in the noise.&lt;/p&gt;

&lt;p&gt;If ever it were not in the noise, I agree better concurrency should&lt;br/&gt;
win.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t think we are talking about that many setter to begin with (I don&apos;t think we should bring those back to the IndexWriter).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, but we are setting a precedent here.  Ie this will apply to&lt;br/&gt;
further settings we add to IWC, apply to any other classes that we&lt;br/&gt;
pull config out of (eg IR), etc.  I don&apos;t like that factoring out&lt;br/&gt;
config means loss of functionality.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It should not be consulted once the construction phase of IW is done.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why such purity?  What do we gain?&lt;/p&gt;

&lt;p&gt;I&apos;m all for purity, but only if it doesn&apos;t interfere w/ functionality.&lt;br/&gt;
Here, it&apos;s taking away freedom...&lt;/p&gt;

&lt;p&gt;I would prefer to have the config you passed into IW remain &quot;live&quot;.&lt;br/&gt;
You can also do IW.getConfig().setXXX later too.&lt;/p&gt;

&lt;p&gt;In fact it should be fine to share an IWC across multiple writers; you&lt;br/&gt;
can change the RAM buffer for all of them at once.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If explicit real time parameters are to be set, then IW should expose it as a setter.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But then whenever we change our mind about liveness, we have to change&lt;br/&gt;
the API?  I&apos;d like to decouple liveness of a setter (really a semantic&lt;br/&gt;
aspect of that API, documented in the jdocs) from which API is used to&lt;br/&gt;
set it.&lt;/p&gt;

&lt;p&gt;I think a config param should be live by default and only if there&apos;s&lt;br/&gt;
some hardship / reason to not have it so, should we make an&lt;br/&gt;
exception.  Most of these params are trivial to be live (they were&lt;br/&gt;
before the IWC change).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;making nonvolatile mutable references introduces you to a world of hard-to-catch unsafe publication bugs (yes, infoStream is currently broken!).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, in theory, yes, in practice, no.  This is like stating your HTML is&lt;br/&gt;
buggy because it fails to put a closing &amp;lt;/html&amp;gt; tag and so some&lt;br/&gt;
browser could fail to render it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I doubt there&apos;s any JVM out there where our lack-of-volatile&lt;br/&gt;
infoStream causes any problems.&lt;/p&gt;

&lt;p&gt;But, of course, we should make them volatile to be safe...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Each and every live reconfigurable setting adds to complexity.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s the exception not the rule.  Most of these settings are used at&lt;br/&gt;
certain times &amp;#8211; on flushing a new seg, on warming a seg, etc. &amp;#8211; and&lt;br/&gt;
there&apos;s no added complexity to simply pulling their current value from&lt;br/&gt;
the config.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For more complex cases, certain on-change logic is required.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For such cases we can state that changes to the config do not take&lt;br/&gt;
effect; eg IndexingChain is a good example I think.  But I think the&lt;br/&gt;
default should be that changes are live, unless otherwise stated&lt;/p&gt;

&lt;p&gt;I don&apos;t think we should go out of our way to be making settings live,&lt;br/&gt;
if there&apos;s any hair involved.  But for the settings where there&apos;s no&lt;br/&gt;
hair involved, they should be live.&lt;/p&gt;</comment>
                    <comment id="13006214" author="kimchy" created="Sun, 13 Mar 2011 16:03:55 +0000"  >&lt;p&gt;Just a note regarding the IWC and being able to consult it for live changes, it feels strange to me that settings something on the config will affect the IW in real time. Maybe its just me, but it feels nicer to have the &quot;live&quot; setters on IW compared to IWC.&lt;/p&gt;

&lt;p&gt;I also like the ability to decouple construction time configuration through IWC, and live settings through setters on IW. It is then very clear what can be set on construction time, and what can be set on a live IW. It also allows for compile time / static check for the code what can be changed at what lifecycle phase.&lt;/p&gt;</comment>
                    <comment id="13006227" author="earwin" created="Sun, 13 Mar 2011 17:46:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Why such purity? What do we gain?&lt;/p&gt;

&lt;p&gt;I&apos;m all for purity, but only if it doesn&apos;t interfere w/ functionality.&lt;br/&gt;
Here, it&apos;s taking away freedom...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We gain consistency and predictability. And there are a lot of freedoms dangerous for developers.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In fact it should be fine to share an IWC across multiple writers; you&lt;br/&gt;
can change the RAM buffer for all of them at once.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;ve brought up a purrfect example of how NOT to do things.&lt;br/&gt;
This is called &apos;action at a distance&apos; and is a damn bug. Very annoying one.&lt;br/&gt;
I&apos;ve thoroughly experienced it with previous major version of Apache HTTPClient - they had an API that suggested you can set per-request timeouts, while these were actually global for a single Client instance.&lt;br/&gt;
I fried my brain trying to understand why the hell random user requests timeout at hundred times their intended duration.&lt;br/&gt;
Oh! It was an occasional admin request changing the global.&lt;/p&gt;

&lt;p&gt;&amp;lt;irony&amp;gt; You know, you can actually instantiate some DateRangeFilter with a couple of Dates, and then change these Dates (they are writeable) before each request. Isn&apos;t it an exciting kind of programming freedom?&lt;br/&gt;
Or, back to our current discussion - we can pass RAMBufferSizeMB as an AtomicDouble, instead of current double, then we can use .set() on an instance we passed, and have our live reconfigurability. What&apos;s more - AtomicDouble protects us from word tearing! &amp;lt;/irony&amp;gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I doubt there&apos;s any JVM out there where our lack-of-volatile infoStream causes any problems.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Er.. While I have never personally witnessed unsynchronized long/double tearing,&lt;br/&gt;
I&apos;ve seen the consequence of unsafely publishing a HashMap - an endless loop on get().&lt;br/&gt;
It happened on your run off the mill Sun 1.6 JVM.&lt;br/&gt;
So the bug is there, lying in wait. Maybe nobody ever actually used the freedom to change infoStream in-flight, or the guy was lucky, or in his particular situation the field was guarded by some unrelated sync.&lt;/p&gt;




&lt;p&gt;While I see banishing live reconfiguration from IW as a lost cause, I ask to make IWC immutable at the very least. As Shay said - this will provide a clear barrier between mutable and immutable properties.&lt;/p&gt;</comment>
                    <comment id="13006287" author="markrmiller@gmail.com" created="Sun, 13 Mar 2011 23:03:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;Maybe its just me, but it feels nicer to have the &quot;live&quot; setters on IW compared to IWC.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1.&lt;/p&gt;

&lt;p&gt;I agree that live settings on IWC feels too much &apos;action at a distance&apos;. It&apos;s not a great pattern.&lt;/p&gt;

&lt;p&gt;FWIW, live config on the IW and a static IWC feels right to me. Earwin makes a strong argument for dropping live altogether - though I&apos;m still liking the idea of allowing it where it&apos;s easy and especially where it has existed.&lt;/p&gt;

&lt;p&gt;And I&apos;ve always felt unsafe publication was scary...&lt;/p&gt;</comment>
                    <comment id="13006533" author="mikemccand" created="Mon, 14 Mar 2011 17:56:27 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Er.. While I have never personally witnessed unsynchronized long/double tearing,&lt;br/&gt;
I&apos;ve seen the consequence of unsafely publishing a HashMap - an endless loop on get().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve also seen JMM strike too &amp;#8211; it caused one of our unit tests to&lt;br/&gt;
spin forever, because a &quot;volatile&quot; was missing.&lt;/p&gt;

&lt;p&gt;But this will never impact rarely used fields (infoStream,&lt;br/&gt;
termIndexInterval, segmentWarmer, etc.), in practice.&lt;/p&gt;

&lt;p&gt;Really we need an anal Java impl. (or, maybe, CPU) that randomly&lt;br/&gt;
asserts its &quot;rights&quot; under JMM, to hold a cached copy of any field&lt;br/&gt;
that&apos;s not volatile for unusual/random lengths of time (basically an&lt;br/&gt;
&quot;adversary&quot; yet still playing by the JMM rules).  Such an impl would&lt;br/&gt;
find TONS of JMM bugs in Lucene (and I imagine any other Java&lt;br/&gt;
app/library tested).&lt;/p&gt;

&lt;p&gt;Yet, no &quot;real&quot; Java impl out there will ever do this since doing so&lt;br/&gt;
will simply make that Java impl appear buggy.  (Well, and, it&apos;d be bad&lt;br/&gt;
for perf. &amp;#8211; obviously the Java impl, CPU cache levels, should cache&lt;br/&gt;
only frequently used things).&lt;/p&gt;

&lt;p&gt;It&apos;s exactly why all web browsers today are tolerant to a missing&lt;br/&gt;
&amp;lt;/html&amp;gt; tag and no browser could afford to suddenly refuse to render&lt;br/&gt;
because you&apos;re missing the &amp;lt;/html&amp;gt; tag.&lt;/p&gt;

&lt;p&gt;I&apos;m not saying we shouldn&apos;t put in our &amp;lt;/html&amp;gt; tags in Lucene; we&lt;br/&gt;
definitely should... we have no choice.  But, in practice, these&lt;br/&gt;
missing &amp;lt;/html&amp;gt; tags all throughout Lucene are not a problem.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I ask to make IWC immutable at the very least&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;IWC cannot be made immutable &amp;#8211; you build it up incrementally (new&lt;br/&gt;
IWC(...).setThis(...).setThat(...)).  Its fields cannot be&lt;br/&gt;
final. (Well, one field can and is: analyzer).&lt;/p&gt;

&lt;p&gt;How about this as a compromise: IW continues cloning the incoming IWC&lt;br/&gt;
on init, as it does today.  This means any changes to the IWC instance&lt;br/&gt;
you passed to IW will have no effect on IW.&lt;/p&gt;

&lt;p&gt;But, if you want to change something live, you can&lt;br/&gt;
IW.getConfig().setFoo(...).  The config instance is a private clone to&lt;br/&gt;
that IW.&lt;/p&gt;</comment>
                    <comment id="13006536" author="yseeley@gmail.com" created="Mon, 14 Mar 2011 17:58:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;How about this as a compromise: IW continues cloning the incoming IWC on init, as it does today. This means any changes to the IWC instance you passed to IW will have no effect on IW.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="13006661" author="mikemccand" created="Mon, 14 Mar 2011 21:56:31 +0000"  >&lt;p&gt;Patch, implementing the proposed compromise.&lt;/p&gt;

&lt;p&gt;I brought back the two prior unit tests, verifying changes to ram buffer take effect live; they pass.&lt;/p&gt;</comment>
                    <comment id="13006742" author="yseeley@gmail.com" created="Tue, 15 Mar 2011 00:27:08 +0000"  >&lt;p&gt;Hmmm, infoStream is just for debugging... should we really make it volatile?&lt;br/&gt;
Although volatile reads are cheap on current x86, they do prevent optimizations/reorderings across them.&lt;br/&gt;
Too many volatile reads in inner loops can add up.&lt;/p&gt;

&lt;p&gt;infoStream is a PrintStream, which synchronizes anyway, so it should be safe to omit the volatile.&lt;/p&gt;</comment>
                    <comment id="13006759" author="earwin" created="Tue, 15 Mar 2011 01:39:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;infoStream is a PrintStream, which synchronizes anyway, so it should be safe to omit the volatile&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You&apos;re absolutely right here.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yet, no &quot;real&quot; Java impl out there will ever do this since doing so will simply make that Java impl appear buggy.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sorry, but &quot;real&quot; Java impls do this. The case with endless get() happened on a map that was never modified after being created and set. Just one of the many JVM instances on many machines got unlucky after restart.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Well, and, it&apos;d be bad for perf. &#8211; obviously the Java impl, CPU cache levels, should cache only frequently used things&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Java impls don&apos;t cache things. They do reorderings, they also keep final fields on registers, omitting reloads that happen for non-final ones, but no caching in JMM-related cases. Caching here is done by CPU, and it caches all data read from memory.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;IWC cannot be made immutable &#8211; you build it up incrementally (new IWC(...).setThis(...).setThat(...)). Its fields cannot be final.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Setters can return modified immutable copy of &apos;this&apos;. So you get both incremental building and immutability.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How about this as a compromise: IW continues cloning the incoming IWC on init, as it does today. This means any changes to the IWC instance you passed to IW will have no effect on IW.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;What about earlier compromise mentioned by Shay, Mark, me? Keep setters for &apos;live&apos; properties on IW.&lt;br/&gt;
This clearly draws the line, and you don&apos;t have to consult Javadocs for each and every setting to know if you can change it live or not.&lt;/p&gt;</comment>
                    <comment id="13007011" author="mikemccand" created="Tue, 15 Mar 2011 16:50:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;Hmmm, infoStream is just for debugging... should we really make it volatile?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll remove its volatile...&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;IWC cannot be made immutable &#8211; you build it up incrementally (new IWC(...).setThis(...).setThat(...)). Its fields cannot be final.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Setters can return modified immutable copy of &apos;this&apos;. So you get both incremental building and immutability.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh yeah.  But then we&apos;d clone the full IWC on every set... this seems&lt;br/&gt;
like overkill in the name of &quot;purity&quot;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What about earlier compromise mentioned by Shay, Mark, me? Keep setters for &apos;live&apos; properties on IW.&lt;br/&gt;
This clearly draws the line, and you don&apos;t have to consult Javadocs for each and every setting to know if you can change it live or not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I really don&apos;t like that this approach would split IW configuration&lt;br/&gt;
into two places.  Like you look at the javadocs for IWC and think that&lt;br/&gt;
you cannot change the RAM buffer size.&lt;/p&gt;

&lt;p&gt;IWC should be the one place you go to see which settings you can&lt;br/&gt;
change about the IW.  That some of these settings take effect &quot;live&quot;&lt;br/&gt;
while others do not is really an orthogonal (and I think, secondary,&lt;br/&gt;
ie handled fine w/ jdocs) aspect/concern.&lt;/p&gt;</comment>
                    <comment id="13007036" author="markrmiller@gmail.com" created="Tue, 15 Mar 2011 17:29:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;I really don&apos;t like that this approach would split IW configuration&lt;br/&gt;
into two places.  Like you look at the javadocs for IWC and think that&lt;br/&gt;
you cannot change the RAM buffer size.&lt;/p&gt;

&lt;p&gt;IWC should be the one place you go to see which settings you can&lt;br/&gt;
change about the IW.  That some of these settings take effect &quot;live&quot;&lt;br/&gt;
while others do not is really an orthogonal (and I think, secondary,&lt;br/&gt;
ie handled fine w/ jdocs) aspect/concern.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You can just as easily argue that the javadocs for IWC could explain that live settings are on the IW.&lt;/p&gt;

&lt;p&gt;That pattern just smells wrong. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But, if you want to change something live, you can&lt;br/&gt;
IW.getConfig().setFoo(...). The config instance is a private clone to&lt;br/&gt;
that IW.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is better than nothing.&lt;/p&gt;

&lt;p&gt;Another thought is to offer all settings on the IWC for init convenience and exposure and then add javadoc about updaters on IW for those settings that can be changed on the fly - or one update method and enums...&lt;/p&gt;</comment>
                    <comment id="13007043" author="steve_rowe" created="Tue, 15 Mar 2011 17:40:12 +0000"  >&lt;p&gt;How about an IWC base class, extended by IWCinit and IWClive.  IWCinit has setters for everything, and IW.getConfig() returns IWClive, which has no setters for things you can&apos;t set on the fly.&lt;/p&gt;</comment>
                    <comment id="13007048" author="earwin" created="Tue, 15 Mar 2011 17:52:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;Oh yeah. But then we&apos;d clone the full IWC on every set... this seems like overkill in the name of &quot;purity&quot;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So what? What exactly is overkill? Few wasted bytes and CPU ns for an object that&apos;s created a couple of times during application lifetime?&lt;br/&gt;
There are also builders, which are very similar to what Steven is proposing.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another thought is to offer all settings on the IWC for init convenience and exposure and then add javadoc about updaters on IW for those settings that can be changed on the fly&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s exactly how I&apos;d like to see it.&lt;/p&gt;</comment>
                    <comment id="13007123" author="rcmuir" created="Tue, 15 Mar 2011 19:40:05 +0000"  >&lt;p&gt;Its exactly the lack of consensus we see here, thats why I am 100% against having the setter approach.&lt;/p&gt;

&lt;p&gt;I&apos;m totally against some deprecation/undeprecation loop because we in future releases another setting&lt;br/&gt;
wants to be &quot;live&quot;.&lt;/p&gt;

&lt;p&gt;It seems the only way we can avoid this, is for javadoc to be the only specification as to whether a setting&lt;br/&gt;
does or does not take effect &quot;live&quot;.&lt;/p&gt;</comment>
                    <comment id="13007136" author="earwin" created="Tue, 15 Mar 2011 20:10:09 +0000"  >&lt;p&gt;You avoid deprecation/undeprecation and binary incompatibility, while incompatibly changing semantics. What do you win?&lt;/p&gt;</comment>
                    <comment id="13007139" author="rcmuir" created="Tue, 15 Mar 2011 20:13:57 +0000"  >&lt;p&gt;You win the fact that this is such an expert thing, and it should not confuse 99% of users who won&apos;t need to change these settings in a live way.&lt;/p&gt;

&lt;p&gt;This is a central API to using lucene, sorry i would rather see IWConfig be reverted completely than see this deprecation/undeprecation loop, it would just cause too much confusion.&lt;/p&gt;</comment>
                    <comment id="13007205" author="steve_rowe" created="Tue, 15 Mar 2011 21:32:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;How about an IWC base class, extended by IWCinit and IWClive. IWCinit has setters for everything, and IW.getConfig() returns IWClive, which has no setters for things you can&apos;t set on the fly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I tried to implement this, but couldn&apos;t figure out a way to avoid code and javadoc duplication and/or separation for the live setters, which need to be on both the init and live versions.  Duplication/separation of this sort would be begging for trouble.  (The live setters can&apos;t be on the base class because the init and live versions would have to return different types to allow for proper chaining.)&lt;/p&gt;</comment>
                    <comment id="13007482" author="steve_rowe" created="Wed, 16 Mar 2011 14:16:00 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;How about an IWC base class, extended by IWCinit and IWClive. IWCinit has setters for everything, and IW.getConfig() returns IWClive, which has no setters for things you can&apos;t set on the fly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I tried to implement this, but couldn&apos;t figure out a way to avoid code and javadoc duplication and/or separation for the live setters, which need to be on both the init and live versions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;An annotation processor that looks for @Live annotations on setters, then generates source for a LiveIWC class, an instance of which would be returned by IW.getConfig(), would solve the duplication/separation problem.  No extension required: LiveIWC could forward all getters and the live setters to a cloned IWC.&lt;/p&gt;</comment>
                    <comment id="13007528" author="mikemccand" created="Wed, 16 Mar 2011 16:03:58 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Oh yeah. But then we&apos;d clone the full IWC on every set... this seems like overkill in the name of &quot;purity&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So what? What exactly is overkill? Few wasted bytes and CPU ns for an object that&apos;s created a couple of times during application lifetime?&lt;br/&gt;
There are also builders, which are very similar to what Steven is proposing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t like that this&apos;d be an O(N*M) cost API when you use it.  Sure,&lt;br/&gt;
N and M are tiny, and you use this API very rarely, but I still don&apos;t&lt;br/&gt;
like it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In addition, because this is all in the name of &quot;purity&quot; which as far&lt;br/&gt;
as I can see has no real value besides &quot;purity&quot;.  It&apos;s... incestuous.&lt;br/&gt;
And, I&apos;m a pragmatist, I guess.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An annotation processor that looks for @Live annotations on setters, then generates source for a LiveIWC class, an instance of which would be returned by IW.getConfig(), would solve the duplication/separation problem. No extension required: LiveIWC could forward all getters and the live setters to a cloned IWC.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is overkill?  (Ie to have @Live compile to LiveIWC vs&lt;br/&gt;
InitIWC).  Though, @Live would be nice for jdocs?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You win the fact that this is such an expert thing, and it should not confuse 99% of users who won&apos;t need to change these settings in a live way.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right &amp;#8211; simple things should be simple and complex things should be&lt;br/&gt;
possible.&lt;/p&gt;

&lt;p&gt;The current patch achieves this &amp;#8211; the 99% of &quot;simple&quot; users that just&lt;br/&gt;
want to config IW and create it find all of the config in one place.&lt;br/&gt;
The 1% complex cases (need to change live settings) are able to do so,&lt;br/&gt;
but must read the jdocs for each setter to verify it&apos;s supported.  The&lt;br/&gt;
API should be designed around the simple users not the complex ones,&lt;br/&gt;
as the current patch does.&lt;/p&gt;

&lt;p&gt;So... I think the current patch is ready to commit (except, I&apos;ll&lt;br/&gt;
remove the &amp;lt;/html&amp;gt; tag for infoStream &amp;amp; defaultInfoStream).&lt;/p&gt;</comment>
                    <comment id="13007537" author="markrmiller@gmail.com" created="Wed, 16 Mar 2011 16:33:57 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The current patch achieves this &#8211; the 99% of &quot;simple&quot; users that just&lt;br/&gt;
want to config IW and create it find all of the config in one place.&lt;br/&gt;
The 1% complex cases (need to change live settings) are able to do so,&lt;br/&gt;
but must read the jdocs for each setter to verify it&apos;s supported. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The proposed alternatives sound just as good as this? In the proposed compromises, the 99% of simple users will see have one place to config IW as well for the avg &apos;set up front&apos; use case. Perhaps the complex users could also have an API with a better pattern and it doesn&apos;t have to be either or as you seem to lead...&lt;/p&gt;

&lt;p&gt;An IWC that is &apos;partially&apos; live and can be changed externally after passing to the IW is just an inferior pattern plain and simple, and doesn&apos;t gain you much.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; The&lt;br/&gt;
API should be designed around the simple users not the complex ones,&lt;br/&gt;
as the current patch does.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This really depends. If the simple users can be satisfied, and the API can also be decent for complex users, win/win.&lt;/p&gt;

&lt;p&gt;I guess I would place my bets that there will not be a ton of deprecations loops of settings wanting to be live.&lt;/p&gt;
</comment>
                    <comment id="13007543" author="markrmiller@gmail.com" created="Wed, 16 Mar 2011 16:44:21 +0000"  >&lt;p&gt;Though don&apos;t take that I don&apos;t agree as a hold up to finishing 3.1.&lt;/p&gt;</comment>
                    <comment id="13007671" author="steve_rowe" created="Wed, 16 Mar 2011 20:02:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;Though don&apos;t take that I don&apos;t agree as a hold up to finishing 3.1.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="13013285" author="gsingers" created="Wed, 30 Mar 2011 16:49:52 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12473617" name="LUCENE-2960.patch" size="28339" author="mikemccand" created="Mon, 14 Mar 2011 21:56:31 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 10 Mar 2011 20:08:49 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>10917</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24732</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>