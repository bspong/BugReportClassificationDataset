<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:19:28 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3867/LUCENE-3867.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3867] RamUsageEstimator.NUM_BYTES_ARRAY_HEADER and other constants are incorrect</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3867</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;RamUsageEstimator.NUM_BYTES_ARRAY_HEADER is computed like that: NUM_BYTES_OBJECT_HEADER + NUM_BYTES_INT + NUM_BYTES_OBJECT_REF. The NUM_BYTES_OBJECT_REF part should not be included, at least not according to this page: &lt;a href=&quot;http://www.javamex.com/tutorials/memory/array_memory_usage.shtml&quot; class=&quot;external-link&quot;&gt;http://www.javamex.com/tutorials/memory/array_memory_usage.shtml&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A single-dimension array is a single object. As expected, the array has the usual object header. However, this object head is 12 bytes to accommodate a four-byte array length. Then comes the actual array data which, as you might expect, consists of the number of elements multiplied by the number of bytes required for one element, depending on its type. The memory usage for one element is 4 bytes for an object reference ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;While on it, I wrote a sizeOf(String) impl, and I wonder how do people feel about including such helper methods in RUE, as static, stateless, methods? It&apos;s not perfect, there&apos;s some room for improvement I&apos;m sure, here it is:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
	/**
	 * Computes the approximate size of a &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object. Note that &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; object
	 * is also referenced by another object, you should add
	 * {@link RamUsageEstimator#NUM_BYTES_OBJECT_REF} to the result of &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;
	 * method.
	 */
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; sizeOf(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; str) {
		&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 2 * str.length() + 6 &lt;span class=&quot;code-comment&quot;&gt;// chars + additional safeness &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; arrays alignment
&lt;/span&gt;				+ 3 * RamUsageEstimator.NUM_BYTES_INT &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; maintains 3 integers
&lt;/span&gt;				+ RamUsageEstimator.NUM_BYTES_ARRAY_HEADER &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;char&lt;/span&gt;[] array
&lt;/span&gt;				+ RamUsageEstimator.NUM_BYTES_OBJECT_HEADER; &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object
&lt;/span&gt;	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If people are not against it, I&apos;d like to also add sizeOf(int[] / byte[] / long[] / double[] ... and String[]).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12546359">LUCENE-3867</key>
            <summary>RamUsageEstimator.NUM_BYTES_ARRAY_HEADER and other constants are incorrect</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.png">Trivial</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Mar 2012 06:22:13 +0000</created>
                <updated>Fri, 10 May 2013 11:43:19 +0100</updated>
                    <resolved>Fri, 23 Mar 2012 19:17:44 +0000</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13229061" author="dweiss" created="Wed, 14 Mar 2012 07:42:03 +0000"  >&lt;p&gt;One can provide exact object allocation size (including alignments) by running with an agent (acquired from Instrumentation). This is shown here, for example:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue142.html&quot; class=&quot;external-link&quot;&gt;http://www.javaspecialists.eu/archive/Issue142.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I don&apos;t think it makes sense to be &quot;perfect&quot; here because there is a tradeoff between being accurate and being fast. One thing to possibly improve would be to handle reference size (4 vs. 8 bytes; in particular with compact references while running under 64 bit jvms).&lt;/p&gt;</comment>
                    <comment id="13229062" author="dweiss" created="Wed, 14 Mar 2012 07:43:33 +0000"  >&lt;p&gt;Oh, one thing that I had in the back of my mind was to run a side-by-side comparison of Lucene&apos;s memory estimator and &quot;exact&quot; memory occupation via agent and see what the real difference is (on various vms and with compact vs. non-compact refs).&lt;/p&gt;

&lt;p&gt;This would be a 2 hour effort I guess, fun, but I don&apos;t have the time for it.&lt;/p&gt;</comment>
                    <comment id="13229066" author="thetaphi" created="Wed, 14 Mar 2012 08:02:03 +0000"  >&lt;p&gt;I was talking with Shai already about the OBJECT_REF size of 8, in RamUsageEstimator it is:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; NUM_BYTES_OBJECT_REF = Constants.JRE_IS_64BIT ? 8 : 4;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...which does not take the CompressedOops into account. Can we detect those oops, so we can change the above ternary to return 4 on newer JVMs with compressed oops enabled?&lt;/p&gt;</comment>
                    <comment id="13229067" author="dweiss" created="Wed, 14 Mar 2012 08:06:58 +0000"  >&lt;p&gt;If you&apos;re running with an agent then it will tell you many bytes a reference is, so this would fix the issue. I don&apos;t think you can test this from within Java VM itself, but this is an interesting question. What you could do is spawn a child VM process with identical arguments (and an agent) and check it there, but this is quite awful... &lt;/p&gt;

&lt;p&gt;I&apos;ll ask on hotspot mailing list, maybe they know how to do this.&lt;/p&gt;</comment>
                    <comment id="13229093" author="shaie" created="Wed, 14 Mar 2012 09:26:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t think it makes sense to be &quot;perfect&quot; here because there is a tradeoff between being accurate and being fast.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. We should be fast, and &quot;as accurate as we can get while preserving speed&quot;.&lt;/p&gt;

&lt;p&gt;I will fix the constant&apos;s value as it&apos;s wrong. The helper methods are just that - helper. Someone can use other techniques to compute the size of objects.&lt;/p&gt;

&lt;p&gt;Will post a patch shortly.&lt;/p&gt;</comment>
                    <comment id="13229125" author="mikemccand" created="Wed, 14 Mar 2012 10:42:47 +0000"  >&lt;p&gt;Nice catch on the overcounting of array&apos;s RAM usage!&lt;/p&gt;

&lt;p&gt;And +1 for additional sizeOf(...) methods.&lt;/p&gt;</comment>
                    <comment id="13229127" author="thetaphi" created="Wed, 14 Mar 2012 10:51:54 +0000"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;Dawid and I were already contacting Hotspot list. There is an easy way to get the compressedOoooooops setting from inside the JVM using MXBeans from the ManagementFactory. I think we will provide a patch later! I think by that we could also optimize the check for 64 bit, because that one should also be reported by the MXBean without looking into strange sysprops (see the TODO in the code for JRE_IS_64BIT).&lt;/p&gt;

&lt;p&gt;Uwe&lt;/p&gt;</comment>
                    <comment id="13229128" author="dweiss" created="Wed, 14 Mar 2012 10:56:28 +0000"  >&lt;p&gt;Sysprops should be a fallback though because (to be verified) they&apos;re supported by other vendors whereas the mx bean may not be.&lt;/p&gt;

&lt;p&gt;It needs to be verified by running under j9, jrockit, etc.&lt;/p&gt;</comment>
                    <comment id="13229160" author="mikemccand" created="Wed, 14 Mar 2012 12:52:23 +0000"  >&lt;p&gt;Consulting MXBean sounds great?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Sysprops should be a fallback though &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="13229163" author="thetaphi" created="Wed, 14 Mar 2012 13:04:44 +0000"  >&lt;p&gt;Here the patch for detecting compressesOops in Sun JVMs. For other JVMs it will simply use false, so the object refs will be guessed to have 64 bits, which is fine as upper memory limit.&lt;/p&gt;

&lt;p&gt;The code does only use public Java APIs and falls back if anything fails to false.&lt;/p&gt;</comment>
                    <comment id="13229176" author="shaie" created="Wed, 14 Mar 2012 13:27:11 +0000"  >&lt;p&gt;Patch adds RUE.sizeOf(String) and various sizeOf(arr[]) methods. Also fixes the ARRAY_HEADER.&lt;/p&gt;

&lt;p&gt;Uwe, I merged with your patch, with one difference &amp;#8211; the System.out prints in the test are printed only if VERBOSE.&lt;/p&gt;</comment>
                    <comment id="13229182" author="thetaphi" created="Wed, 14 Mar 2012 13:34:54 +0000"  >&lt;p&gt;Shai: Thanks! I am in a train at the moment, so internet is slow/not working. I will later find out what MXBeans we can use to detect 64bit without looking at strange sysprops (which may have been modified by user code, so not really secure to use...).&lt;/p&gt;

&lt;p&gt;I left the non-verbose printlns in it, so people reviewing the patch can quickly see by running that test what happens on their JVM. It would be interesting to see what your jRockit does... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13229188" author="shaie" created="Wed, 14 Mar 2012 13:45:01 +0000"  >&lt;p&gt;I tried IBM and Oracle 1.6 JVMs, and both printed the same:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit] ------------- Standard Output ---------------
    [junit] NOTE: This JVM is 64bit: &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
    [junit] NOTE: This JVM uses CompressedOops: &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
    [junit] ------------- ---------------- ---------------
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So no CompressedOops for me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I will later find out what MXBeans we can use to detect 64bit without looking at strange sysprops&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok. If you&apos;ll make it, we can add these changes to that patch, otherwise we can also do them in a separate issue.&lt;/p&gt;</comment>
                    <comment id="13229191" author="thetaphi" created="Wed, 14 Mar 2012 13:46:19 +0000"  >&lt;p&gt;Hm, for me (1.6.0_31, 7u3) it prints true. What JVMs are you using and what settings?&lt;/p&gt;</comment>
                    <comment id="13229200" author="thetaphi" created="Wed, 14 Mar 2012 13:54:17 +0000"  >&lt;p&gt;Here my results:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;*****************************************************
JAVA_HOME = C:\Program Files\Java\jdk1.7.0_03
java version &quot;1.7.0_03&quot;
Java(TM) SE Runtime Environment (build 1.7.0_03-b05)
Java HotSpot(TM) 64-Bit Server VM (build 22.1-b02, mixed mode)
*****************************************************

C:\Users\Uwe Schindler\Projects\lucene\trunk-lusolr1\lucene\core&amp;gt;ant test -Dtestcase=TestRam*
[junit] Testsuite: org.apache.lucene.util.TestRamUsageEstimator
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0,561 sec
[junit]
[junit] ------------- Standard Output ---------------
[junit] NOTE: This JVM is 64bit: true
[junit] NOTE: This JVM uses CompressedOops: true
[junit] ------------- ---------------- ---------------

C:\Users\Uwe Schindler\Projects\lucene\trunk-lusolr1\lucene\core&amp;gt;ant test -Dtestcase=TestRam* -Dargs=-XX:-UseCompressedOops
[junit] Testsuite: org.apache.lucene.util.TestRamUsageEstimator
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0,5 sec
[junit]
[junit] ------------- Standard Output ---------------
[junit] NOTE: This JVM is 64bit: true
[junit] NOTE: This JVM uses CompressedOops: false
[junit] ------------- ---------------- ---------------

*****************************************************
JAVA_HOME = C:\Program Files\Java\jdk1.6.0_31
java version &quot;1.6.0_31&quot;
Java(TM) SE Runtime Environment (build 1.6.0_31-b05)
Java HotSpot(TM) 64-Bit Server VM (build 20.6-b01, mixed mode)
*****************************************************

C:\Users\Uwe Schindler\Projects\lucene\trunk-lusolr1\lucene\core&amp;gt;ant test -Dtestcase=TestRam*
[junit] Testsuite: org.apache.lucene.util.TestRamUsageEstimator
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0,453 sec
[junit]
[junit] ------------- Standard Output ---------------
[junit] NOTE: This JVM is 64bit: true
[junit] NOTE: This JVM uses CompressedOops: true
[junit] ------------- ---------------- ---------------

C:\Users\Uwe Schindler\Projects\lucene\trunk-lusolr1\lucene\core&amp;gt;ant test -Dtestcase=TestRam* -Dargs=-XX:-UseCompressedOops
[junit] Testsuite: org.apache.lucene.util.TestRamUsageEstimator
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0,421 sec
[junit]
[junit] ------------- Standard Output ---------------
[junit] NOTE: This JVM is 64bit: true
[junit] NOTE: This JVM uses CompressedOops: false
[junit] ------------- ---------------- ---------------

C:\Users\Uwe Schindler\Projects\lucene\trunk-lusolr1\lucene\core&amp;gt;ant test -Dtestcase=TestRam* -Dargs=-XX:+UseCompressedOops
[junit] Testsuite: org.apache.lucene.util.TestRamUsageEstimator
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0,422 sec
[junit]
[junit] ------------- Standard Output ---------------
[junit] NOTE: This JVM is 64bit: true
[junit] NOTE: This JVM uses CompressedOops: true
[junit] ------------- ---------------- ---------------
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13229211" author="shaie" created="Wed, 14 Mar 2012 14:05:56 +0000"  >&lt;p&gt;Oracle:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java version &lt;span class=&quot;code-quote&quot;&gt;&quot;1.6.0_21&quot;&lt;/span&gt;
Java(TM) SE &lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt; Environment (build 1.6.0_21-b07)
Java HotSpot(TM) 64-Bit Server VM (build 17.0-b17, mixed mode)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IBM:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java version &lt;span class=&quot;code-quote&quot;&gt;&quot;1.6.0&quot;&lt;/span&gt;
Java(TM) SE &lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt; Environment (build pwa6460sr9fp3-20111122_05(SR9 FP3))
IBM J9 VM (build 2.4, JRE 1.6.0 IBM J9 2.4 Windows 7 amd64-64 jvmwa6460sr9-20111111_94827 (JIT enabled, AOT enabled)
J9VM - 20111111_094827
JIT  - r9_20101028_17488ifx45
GC   - 20101027_AA)
JCL  - 20110727_07
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13229215" author="shaie" created="Wed, 14 Mar 2012 14:09:03 +0000"  >&lt;p&gt;I ran &quot;ant test-core -Dtestcase=TestRam* -Dtests.verbose=true -Dargs=-XX:+UseCompressedOops&quot; and with the Oracle JVM I get &quot;Compressed Oops: true&quot; but with IBM JVM I still get &apos;false&apos;.&lt;/p&gt;</comment>
                    <comment id="13229217" author="thetaphi" created="Wed, 14 Mar 2012 14:15:26 +0000"  >&lt;p&gt;OK, that is expected. 1.6.0_21 does not enable compressedOops by default, so false is correct. If you manually enable, it gets true.&lt;/p&gt;

&lt;p&gt;jRockit is jRockit and not Sun/Oracle, so the result is somehow expected. It seems to nor have that MXBrean. But the code does not produce strange exceptions, so at least in the Sun VM we can detect compressed Oops and guess the reference size better. 8 is still not bad as it gives an upper limit.&lt;/p&gt;</comment>
                    <comment id="13229218" author="thetaphi" created="Wed, 14 Mar 2012 14:18:28 +0000"  >&lt;p&gt;By the way, here is the code from the hotspot mailing list member (my code is based on it), it also shows the outputs for different JVMs:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/1333043&quot; class=&quot;external-link&quot;&gt;https://gist.github.com/1333043&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(I just removed the com.sun.* imports and replaced by reflection)&lt;/p&gt;</comment>
                    <comment id="13229226" author="shaie" created="Wed, 14 Mar 2012 14:25:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;8 is still not bad as it gives an upper limit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. Better to over-estimate here, than under-estimate.&lt;/p&gt;

&lt;p&gt;Would appreciate if someone can take a look at the sizeOf() impls before I commit.&lt;/p&gt;</comment>
                    <comment id="13229244" author="thetaphi" created="Wed, 14 Mar 2012 15:01:08 +0000"  >&lt;p&gt;On Hotspot Mailing list some people also seem to have an idea about jRockit and IBM J9:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;From: Krystal Mok&lt;br/&gt;
Sent: Wednesday, March 14, 2012 3:46 PM&lt;br/&gt;
To: Uwe Schindler&lt;br/&gt;
Cc: Dawid Weiss; hotspot compiler&lt;br/&gt;
Subject: Re: How to detect if the VM is running with compact refs from within the VM (no agent)?&lt;/p&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Just in case you&apos;d care, the same MXBean could be used to detect compressed references on JRockit, too. It&apos;s probably available starting from JRockit R28.&lt;/p&gt;

&lt;p&gt;Instead of &quot;UseCompressedOops&quot;, use &quot;CompressedRefs&quot; as the VM option name on JRockit.&lt;/p&gt;

&lt;p&gt;Don&apos;t know how to extract this information for J9 without another whole bunch of hackeries...well, you could try this, on a &quot;best-effort&quot; basis for platform detection:&lt;br/&gt;
IBM J9&apos;s VM version string contains the compressed reference information. Example:&lt;/p&gt;

&lt;p&gt;$ export JAVA_OPTS=&apos;-Xcompressedrefs&apos;&lt;br/&gt;
$ groovysh&lt;br/&gt;
Groovy Shell (1.7.7, JVM: 1.7.0)&lt;br/&gt;
Type &apos;help&apos; or &apos;\h&apos; for help.&lt;br/&gt;
----------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;
groovy:000&amp;gt; System.getProperty &apos;java.vm.info&apos;&lt;br/&gt;
===&amp;gt; JRE 1.7.0 Linux amd64-64 Compressed References 20110810_88604 (JIT enabled, AOT enabled)&lt;br/&gt;
J9VM - R26_Java726_GA_20110810_1208_B88592&lt;br/&gt;
JIT  - r11_20110810_20466&lt;br/&gt;
GC   - R26_Java726_GA_20110810_1208_B88592_CMPRSS&lt;br/&gt;
J9CL - 20110810_88604&lt;br/&gt;
groovy:000&amp;gt; quit&lt;/p&gt;

&lt;p&gt;So grepping for &quot;Compressed References&quot; in the &quot;java.vm.info&quot; system property gives you the clue.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Kris&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</comment>
                    <comment id="13229264" author="mikemccand" created="Wed, 14 Mar 2012 15:37:56 +0000"  >&lt;p&gt;Patch looks good!&lt;/p&gt;

&lt;p&gt;Maybe just explain in sizeOf(String) javadoc that this method assumes the String is &quot;standalone&quot; (ie, does not reference a larger char[] than itself)?&lt;/p&gt;

&lt;p&gt;Because... if you call String.substring, the returned string references a slice the char[] of the original one... and so technically the RAM it&apos;s tying up could be (much) larger than expected.  (At least, this used to be the case... not sure if it&apos;s changed...).&lt;/p&gt;</comment>
                    <comment id="13229273" author="shaie" created="Wed, 14 Mar 2012 15:50:51 +0000"  >&lt;p&gt;Good point. I clarified the jdocs with this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * Returns the approximate size of a &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object. This computation relies on
   * {@link &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;#length()} to compute the number of bytes held by the &lt;span class=&quot;code-object&quot;&gt;char&lt;/span&gt;[].
   * However, &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object passed to &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method is the result of e.g.
   * {@link &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;#substring}, the computation may be entirely inaccurate
   * (depending on the difference between length() and the actual &lt;span class=&quot;code-object&quot;&gt;char&lt;/span&gt;[]
   * length).
   */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If there are no objections, I&apos;d like to commit this.&lt;/p&gt;</comment>
                    <comment id="13229275" author="dweiss" created="Wed, 14 Mar 2012 15:52:51 +0000"  >&lt;p&gt;I would opt for sizeOf to return the actual size of the object, including underlying string buffers... We can take into account interning buffers but other than that I wouldn&apos;t skew the result because it can be misleading.&lt;/p&gt;</comment>
                    <comment id="13229279" author="dweiss" created="Wed, 14 Mar 2012 15:56:01 +0000"  >&lt;p&gt;I don&apos;t like this special handling of Strings, to be honest. Why do we need/do it?&lt;/p&gt;</comment>
                    <comment id="13229286" author="shaie" created="Wed, 14 Mar 2012 16:02:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t like this special handling of Strings, to be honest. Why do we need/do it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because I wrote it, and it seemed useful to me, so why not? We know how Strings look like, at least in their worse case. If there will be a better implementation, we can fix it in RUE, rather than having many impls try to do it on their own?&lt;/p&gt;</comment>
                    <comment id="13229296" author="mikemccand" created="Wed, 14 Mar 2012 16:18:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t like this special handling of Strings, to be honest. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m confused: what special handling of Strings are we talking about...?&lt;/p&gt;

&lt;p&gt;You mean that sizeOf(String) doesn&apos;t return the correct answer if the string came from a previous .substring (.split too) call...?&lt;/p&gt;

&lt;p&gt;If so, how can we actually fix that?  Is there some way to ask a string for the true length of its char[]?&lt;/p&gt;</comment>
                    <comment id="13229311" author="dweiss" created="Wed, 14 Mar 2012 16:32:47 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+  /** Returns the size in bytes of the &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] object. */
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; sizeOf(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] arr) {
+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; size = alignObjectSize(NUM_BYTES_ARRAY_HEADER + NUM_BYTES_OBJECT_REF * arr.length);
+    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s : arr) {
+      size += sizeOf(s);
+    }
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; size;
+  }
+
+  /** Returns the approximate size of a &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object. */
+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; sizeOf(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; str) {
+    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&apos;s &lt;span class=&quot;code-object&quot;&gt;char&lt;/span&gt;[] size
&lt;/span&gt;+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; arraySize = alignObjectSize(NUM_BYTES_ARRAY_HEADER + NUM_BYTES_CHAR * str.length());
+
+    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&apos;s row object size    
&lt;/span&gt;+    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; objectSize = alignObjectSize(NUM_BYTES_OBJECT_REF /* array reference */
+        + 3 * NUM_BYTES_INT /* &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; holds 3 integers */
+        + NUM_BYTES_OBJECT_HEADER /* &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; object header */);
+    
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; objectSize + arraySize;
+  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What I mean is that without looking at the code I would expect sizeOf(String[] N) to return the actual memory taken by an array of strings. If they point to a single char[], this should simple count the object overhead, not count every character N times as it would do now. This isn&apos;t sizeOf(), this is sum(string lengths * 2) + epsilon to me.&lt;/p&gt;

&lt;p&gt;I&apos;d keep RamUsageEstimator exactly what the name says &amp;#8211; an estimation of the actual memory taken by a given object. A string can point to a char[] and if so this should be traversed as an object and counted once.&lt;/p&gt;</comment>
                    <comment id="13229313" author="dweiss" created="Wed, 14 Mar 2012 16:34:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;If so, how can we actually fix that? Is there some way to ask a string for the true length of its char[]?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Same as with other objects &amp;#8211; traverse its fields and count them (once, building an identity set for all objects reachable from the root)?&lt;/p&gt;</comment>
                    <comment id="13229332" author="shaie" created="Wed, 14 Mar 2012 16:46:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;What I mean is that without looking at the code I would expect sizeOf(String[] N) to return the actual memory taken by an array of strings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you mean you&apos;d want sizeOf(String[]) be just that?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; alignObjectSize(NUM_BYTES_ARRAY_HEADER + NUM_BYTES_OBJECT_REF * arr.length);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t mind. I just thought that since we know how to compute sizeOf(String), we can use that. It&apos;s an extreme case, I think, that someone will want to compute the size of String[] which share same char[] instance ... but I don&apos;t mind if it bothers you that much, to simplify it and document that it computes the raw size of the String[].&lt;/p&gt;

&lt;p&gt;But I don&apos;t think that we should change sizeOf(String) to not count the char[] size. It&apos;s part of the object, and really it&apos;s String, not like we&apos;re trying to compute the size of a general object.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Same as with other objects &#8211; traverse its fields and count them&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;RUE already has .estimateRamUsage(Object) which does that through reflection. I think that sizeOf(String) can remain fast as it is now, with the comment that it my over-estimate if the String is actually a sub-string of one original larger string. In the worse case, we&apos;ll just be over-estimating.&lt;/p&gt;</comment>
                    <comment id="13229336" author="thetaphi" created="Wed, 14 Mar 2012 16:53:17 +0000"  >&lt;p&gt;Hi Shai,&lt;/p&gt;

&lt;p&gt;can ypou try this patch with J9 or maybe JRockit (Robert)? If yozu use one of those JVMs you may have to explicitely enable  compressed Oops/refs!&lt;/p&gt;</comment>
                    <comment id="13229339" author="dweiss" created="Wed, 14 Mar 2012 16:56:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;RUE already has .estimateRamUsage(Object) which does that through reflection. I think that sizeOf(String) can remain fast as it is now, with the comment that it my over-estimate if the String is actually a sub-string of one original larger string. In the worse case, we&apos;ll just be over-estimating.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, that&apos;s exactly what I didn&apos;t like. All the primitive/ primitive array methods are fine, but why make things inconsistent with sizeOf(String)? I&apos;d rather have the reflection-based method estimate the size of a String/String[]. Like we mentioned it&apos;s always a matter of speed/accuracy but here I&apos;d opt for accuracy because the output can be off by a lot if you make substrings along the way (not to mention it assumes details about String internal implementation which may or may not be true, depending on the vendor).&lt;/p&gt;

&lt;p&gt;Do you have a need for this method, Shai? If you don&apos;t then why not wait (with this part) until such a need arises?&lt;/p&gt;</comment>
                    <comment id="13229344" author="shaie" created="Wed, 14 Mar 2012 17:01:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;Do you have a need for this method, Shai?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I actually started this issue because of this method &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I wrote the method for my own code, then spotted the bug in the ARRAY_HEADER, and on the go thought that it will be good if RUE would offer it for me / other people can benefit from it. Because from my experience, after I put code in Lucene, very smart people improve and optimize it, and I benefit from it in new releases.&lt;/p&gt;

&lt;p&gt;So while I could keep sizeOf(String) in my own code, I know that Uwe/Robert/Mike/You will make it more efficient when Java 7/8/9 will be out, while I&apos;ll totally forget about it ! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="13229363" author="dweiss" created="Wed, 14 Mar 2012 17:10:22 +0000"  >&lt;p&gt;Yeah... well... I&apos;m flattered &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I&apos;m still -1 for adding this particular method because I don&apos;t like being surprised at how a method works and this is surprising behavior to me, especially in this class (even if it&apos;s documented in the javadoc, but who reads it anyway, right?).&lt;/p&gt;

&lt;p&gt;If others don&apos;t share my opinion then can we at least rename this method to sizeOfBlah(..) where Blah is something that would indicate it&apos;s not actually taking into account char buffer sharing or sub-slicing (suggestions for Blah welcome)?&lt;/p&gt;</comment>
                    <comment id="13229400" author="markrmiller@gmail.com" created="Wed, 14 Mar 2012 17:23:50 +0000"  >&lt;p&gt;estimateSizeOf(..)&lt;br/&gt;
guessSizeOf(..)&lt;br/&gt;
wildGuessSizeOf(..)&lt;br/&gt;
incorrectSizeOf(..)&lt;br/&gt;
sizeOfWeiss(..)&lt;br/&gt;
weissSize(..)&lt;br/&gt;
sizeOfButWithoutTakingIntoAccountCharBufferSharingOrSubSlicingSeeJavaDoc(..)&lt;/p&gt;</comment>
                    <comment id="13229410" author="mikemccand" created="Wed, 14 Mar 2012 17:35:10 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If so, how can we actually fix that? Is there some way to ask a string for the true length of its char[]?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Same as with other objects &#8211; traverse its fields and count them (once, building an identity set for all objects reachable from the root)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Aha, cool!  I hadn&apos;t realized RUE can crawl into the private char[] inside string and count up the RAM usage correctly.  That&apos;s nice.&lt;/p&gt;

&lt;p&gt;Maybe lowerBoundSizeOf(...)?&lt;/p&gt;

&lt;p&gt;Or maybe we don&apos;t add the new string methods (sizeOf(String), sizeOf(String[])) and somewhere document that you should do new RUE().size(String/String[]) instead...?  Hmm or maybe we do add the methods, but implement them under-the-hood w/ that?&lt;/p&gt;</comment>
                    <comment id="13229440" author="dweiss" created="Wed, 14 Mar 2012 18:02:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;sizeOfWeiss(..)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;re talking some serious dimensions here, beware of buffer overflows!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or maybe we don&apos;t add the new string methods (sizeOf(String), sizeOf(String[])) and somewhere document that you should do new RUE().size(String/String[]) instead..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is something I would go for &amp;#8211; it&apos;s consistent with what I would consider this class&apos;s logic. I would even change it to sizeOf(Object) &amp;#8211; this would be a static shortcut to just measure an object&apos;s size, no strings attached?&lt;/p&gt;

&lt;p&gt;Kabutz&apos;s code also distinguishes interned strings/ cached boxed integers and enums. This could be a switch much like it is now with interned Strings. Then this would really be either an upper (why lower, Mike?) bound or something that would try to be close to the exact memory consumption.&lt;/p&gt;

&lt;p&gt;A fun way to determine if we&apos;re right would be to run a benchmark with -Xmx20mb and test how close we can get to the main memory pool&apos;s maximum value before OOM is thrown. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13229456" author="mikemccand" created="Wed, 14 Mar 2012 18:13:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;(why lower, Mike?)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh I just meant the sizeOf(String) impl in the current patch is a lower bound (since it &quot;guesses&quot; the private char[] length by calling String.length(), which is a lower bound on the actual char[] length).&lt;/p&gt;</comment>
                    <comment id="13229460" author="dweiss" created="Wed, 14 Mar 2012 18:18:51 +0000"  >&lt;p&gt;John Rose just replied to my question &amp;#8211; there are fields in Unsafe that allow array scaling (1.7). Check these out:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;        ARRAY_BOOLEAN_INDEX_SCALE = theUnsafe.arrayIndexScale([Z);
        ARRAY_BYTE_INDEX_SCALE = theUnsafe.arrayIndexScale([B);
        ARRAY_SHORT_INDEX_SCALE = theUnsafe.arrayIndexScale([S);
        ARRAY_CHAR_INDEX_SCALE = theUnsafe.arrayIndexScale([C);
        ARRAY_INT_INDEX_SCALE = theUnsafe.arrayIndexScale([I);
        ARRAY_LONG_INDEX_SCALE = theUnsafe.arrayIndexScale([J);
        ARRAY_FLOAT_INDEX_SCALE = theUnsafe.arrayIndexScale([F);
        ARRAY_DOUBLE_INDEX_SCALE = theUnsafe.arrayIndexScale([D);
        ARRAY_OBJECT_INDEX_SCALE = theUnsafe.arrayIndexScale([Ljava/lang/Object;);
        ADDRESS_SIZE = theUnsafe.addressSize();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So... there is a (theoretical?) possibility that, say, byte[] is machine word-aligned &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I bet any RAM estimator written so far will be screwed if this happens &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13229579" author="thetaphi" created="Wed, 14 Mar 2012 20:19:25 +0000"  >&lt;p&gt;So the whole Oops MBean magic is obsolete... ADDRESS_SIZE = theUnsafe.addressSize(); woooah, so simple - works on more platforms for guessing!&lt;/p&gt;

&lt;p&gt;I will check this out with the usual reflection magic &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13230023" author="thetaphi" created="Thu, 15 Mar 2012 09:40:47 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
here new patch using Unsafe to get the bitness (with the well-known fallback) and for compressedOops detection. Looks much cleaner.&lt;br/&gt;
I also like it more, that the addressSize is now detected natively and not from sysprops.&lt;/p&gt;

&lt;p&gt;The constants mentioned by Dawid are only availabe in Java 7, so i reflected the underlying methods from theUnsafe. I also changed the boolean JRE_USES_COMPRESSED_OOPS to an integer JRE_REFERENCE_SIZE that is used by RamUsageEstimator. We might do the same for all other native types... (this is just a start).&lt;/p&gt;

&lt;p&gt;Shai: Can you test with your JVMs and also enable/disable compressed oops/refs?&lt;/p&gt;</comment>
                    <comment id="13230126" author="shaie" created="Thu, 15 Mar 2012 12:56:35 +0000"  >&lt;p&gt;Thanks Uwe !&lt;/p&gt;

&lt;p&gt;I ran the test, and now with both J9 (IBM) and Oracle, I get this print (without enabling any flag):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit] NOTE: running test testReferenceSize
    [junit] NOTE: This JVM is 64bit: &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
    [junit] NOTE: Reference size in &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; JVM: 8
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
	&lt;li&gt;I modified the test name to testReferenceSize (was testCompressedOops).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I wrote this small test to print the differences between sizeOf(String) and estimateRamUsage(String):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testSizeOfString() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s = &lt;span class=&quot;code-quote&quot;&gt;&quot;abcdefgkjdfkdsjdskljfdskfjdsf&quot;&lt;/span&gt;;
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; sub = s.substring(0, 4);
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;original=&quot;&lt;/span&gt; + RamUsageEstimator.sizeOf(s));
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;sub=&quot;&lt;/span&gt; + RamUsageEstimator.sizeOf(sub));
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;(orig): &quot;&lt;/span&gt; + &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RamUsageEstimator().estimateRamUsage(s));
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;(orig): &quot;&lt;/span&gt; + &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RamUsageEstimator(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;).estimateRamUsage(s));
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;(sub): &quot;&lt;/span&gt; + &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RamUsageEstimator(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;).estimateRamUsage(sub));
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It prints:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
original=104
sub=56
checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;(orig): 0
checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;(orig): 98
checkInterned=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;(sub): 98
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So clearly estimateRamUsage factors in the sub-string&apos;s larger char[]. The difference in sizes of &apos;orig&apos; stem from AverageGuessMemoryModel which computes the reference size to be 4 (hardcoded), and array size to be 16 (hardcoded). I modified AverageGuess to use constants from RUE (they are best guesses themselves). Still the test prints a difference, but now I think it&apos;s because sizeOf(String) aligns the size to mod 8, while estimateRamUsage isn&apos;t. I fixed that in size(Object), and now the prints are the same.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I also fixed sizeOfArray &amp;#8211; if the array.length == 0, it returned 0, but it should return its header, and aligned to mod 8 as well.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I modified sizeOf(String[]) to sizeOf(Object[]) and compute its raw size only. I started to add sizeOf(String), fastSizeOf(String) and deepSizeOf(String[]), but reverted to avoid the hassle &amp;#8211; the documentation confuses even me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed all sizeOf() to return long, and align() to take and return long.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this is ready to commit, though I&apos;d appreciate a second look on the MemoryModel and size(Obj) changes.&lt;/p&gt;

&lt;p&gt;Also, how about renaming MemoryModel methods to: arrayHeaderSize(), classHeaderSize(), objReferenceSize() to make them more clear and accurate? For instance, getArraySize does not return the size of an array, but its object header ...&lt;/p&gt;</comment>
                    <comment id="13230171" author="dweiss" created="Thu, 15 Mar 2012 13:56:57 +0000"  >&lt;p&gt;-1 to mixing shallow and deep sizeofs &amp;#8211; sizeOf(Object[] arr) is shallow and just feels wrong to me. All the other methods yield the deep total, why make an exception? If anything, make it explicit and then do it for any type of object &amp;#8211; &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
shallowSizeOf(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; t);
sizeOf(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; t);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;m not complaining just because my sense of taste is feeling bad. I am actually using this class in my own projects and I would hate to look into the JavaDoc every time to make sure what a given method does (especially with multiple overloads). In other words, I would hate to see this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; [] o1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; [] {1, 2, 3};
&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o2 = o1;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (sizeOf(o1) != sizeOf(o2)) &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WtfException();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


</comment>
                    <comment id="13230181" author="thetaphi" created="Thu, 15 Mar 2012 14:02:43 +0000"  >&lt;blockquote&gt;

&lt;p&gt;I ran the test, and now with both J9 (IBM) and Oracle, I get this print (without enabling any flag):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit] NOTE: running test testReferenceSize
    [junit] NOTE: This JVM is 64bit: &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
    [junit] NOTE: Reference size in &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; JVM: 8
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;I hope with compressedOops explicitely enabled (or however they call them), you get a reference size of 4 in J9 and pre-1.6.0_23 Oracle?&lt;/p&gt;</comment>
                    <comment id="13230184" author="shaie" created="Thu, 15 Mar 2012 14:07:32 +0000"  >&lt;p&gt;Ok removed sizeOf(Object[]). One can compute it by using RUE.estimateRamSize to do a deep calculation.&lt;/p&gt;

&lt;p&gt;Geez Dawid, you took away all the reasons I originally opened the issue for &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;But at least AvgGuessMemoryModel and RUE.size() are more accurate now. And we have some useful utility methods.&lt;/p&gt;</comment>
                    <comment id="13230187" author="shaie" created="Thu, 15 Mar 2012 14:12:46 +0000"  >&lt;p&gt;I ran &quot;ant test-core -Dtestcase=TestRam* -Dtests.verbose=true -Dargs=-XX:+UseCompressedOops&quot; and &quot;ant test-core -Dtestcase=TestRam* -Dtests.verbose=true -Dargs=-XX:-UseCompressedOops&quot; and get 8 and 4 (with CompressedOops).&lt;/p&gt;</comment>
                    <comment id="13230202" author="markrmiller@gmail.com" created="Thu, 15 Mar 2012 14:36:37 +0000"  >&lt;p&gt;Oh, bummer - looks like we lost the whole history of this class...such a bummer. I really wanted to take a look at how this class had evolved since I last looked at it. I&apos;ve missed the conversations around the history loss - is that gone, gone, gone, or is there still some way to find it?&lt;/p&gt;</comment>
                    <comment id="13230206" author="markrmiller@gmail.com" created="Thu, 15 Mar 2012 14:40:53 +0000"  >&lt;p&gt;Scratch that - I was trying to look back from the apache git clone using git - assumed it&apos;s history matched svn - but I get a clean full history using svn.&lt;/p&gt;</comment>
                    <comment id="13230208" author="thetaphi" created="Thu, 15 Mar 2012 14:42:08 +0000"  >&lt;p&gt;Die, GIT, die! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; (as usual)&lt;/p&gt;</comment>
                    <comment id="13230214" author="thetaphi" created="Thu, 15 Mar 2012 14:53:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;I ran &quot;ant test-core -Dtestcase=TestRam* -Dtests.verbose=true -Dargs=-XX:+UseCompressedOops&quot; and &quot;ant test-core -Dtestcase=TestRam* -Dtests.verbose=true -Dargs=-XX:-UseCompressedOops&quot; and get 8 and 4 (with CompressedOops).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, thanks. So it seems to work at least with Oracle/Sun and IBM J9. I have no other updates to this detection code.&lt;/p&gt;</comment>
                    <comment id="13230219" author="dweiss" created="Thu, 15 Mar 2012 15:00:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;Geez Dawid, you took away all the reasons I originally opened the issue for &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is by no means wasted time. I think the improvements are clear?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Die, GIT, die!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree here &amp;#8211; git is a great tool, even if the learning curve may be steep at first. git-svn is a whole different story (it&apos;s a great hack but just a hack).&lt;/p&gt;</comment>
                    <comment id="13230222" author="thetaphi" created="Thu, 15 Mar 2012 15:05:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;I disagree here&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Calm down, was just my well-known standard answer &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13230228" author="dweiss" created="Thu, 15 Mar 2012 15:08:21 +0000"  >&lt;p&gt;Oh, I am calm, I just know people do hate git (and I used to as well, until I started using it frequently). Robert has a strong opinion about git, for example. &lt;/p&gt;

&lt;p&gt;Besides, there&apos;s nothing wrong in having a strong opinion &amp;#8211; it&apos;s great people can choose what they like and still collaborate via patches (and this seems to be the common ground between all vcs&apos;s).&lt;/p&gt;</comment>
                    <comment id="13230229" author="shaie" created="Thu, 15 Mar 2012 15:09:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is by no means wasted time. I think the improvements are clear?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, yes. It was a joke.&lt;/p&gt;

&lt;p&gt;Ok so can I proceed with the commit, or does someone intend to review the patch later?&lt;/p&gt;</comment>
                    <comment id="13230230" author="thetaphi" created="Thu, 15 Mar 2012 15:09:09 +0000"  >&lt;p&gt;With unsafe we also get all those information like size of array header we have hardcoded. Should we not try to get these in the same way like I did for bitness and reference size - using Unsafe.theUnsafe.arrayBaseOffset()? And fallback to our hardcoded defaults?&lt;/p&gt;</comment>
                    <comment id="13230235" author="dweiss" created="Thu, 15 Mar 2012 15:16:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;using Unsafe.theUnsafe.arrayBaseOffset()? And fallback to our hardcoded defaults?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1. &lt;/p&gt;

&lt;p&gt;I will also try on OpenJDK with various jits but I&apos;ll do it in the evening.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes, yes. It was a joke.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Joke or no joke the truth is I did complain a lot. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13230503" author="dweiss" created="Thu, 15 Mar 2012 20:14:32 +0000"  >&lt;p&gt;I just peeked at OpenJDK sources and addressSize() is defined as this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// See comment at file start about UNSAFE_LEAF
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//UNSAFE_LEAF(jint, Unsafe_AddressSize())
&lt;/span&gt;UNSAFE_ENTRY(jint, Unsafe_AddressSize(JNIEnv *env, jobject unsafe))
  UnsafeWrapper(&lt;span class=&quot;code-quote&quot;&gt;&quot;Unsafe_AddressSize&quot;&lt;/span&gt;);
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; sizeof(void*);
UNSAFE_END
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this light this switch:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;switch&lt;/span&gt; (addressSize) {
  &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; 4:
    is64Bit = &lt;span class=&quot;code-object&quot;&gt;Boolean&lt;/span&gt;.FALSE;
    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
  &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; 8:
    is64Bit = &lt;span class=&quot;code-object&quot;&gt;Boolean&lt;/span&gt;.TRUE;
    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Becomes interesting. Do you know of any architecture with pointers different than 4 or 8 bytes? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13230529" author="dweiss" created="Thu, 15 Mar 2012 20:49:45 +0000"  >&lt;p&gt;A few more exotic jits from OpenJDK (all seem to be using explicit 8 byte ref size on 64-bit:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-jamvm&quot;
    [junit] JVM: OpenJDK Runtime Environment, JamVM, Robert Lougher, 1.6.0-devel, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_23, Sun Microsystems Inc., null,
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 8

&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-jamvm -XX:+UseCompressedOops&quot;
    [junit] JVM: OpenJDK Runtime Environment, JamVM, Robert Lougher, 1.6.0-devel, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_23, Sun Microsystems Inc., null,
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 8

&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-cacao&quot;
    [junit] JVM: OpenJDK Runtime Environment, CACAO, CACAOVM - Verein zur Foerderung der freien virtuellen Maschine CACAO, 1.1.0pre2, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_23, Sun Microsystems Inc., null,
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 8

&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-server&quot;
    [junit] JVM: OpenJDK Runtime Environment, OpenJDK 64-Bit Server VM, Sun Microsystems Inc., 20.0-b11, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_23, Sun Microsystems Inc., null,
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 4

&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-server -XX:-UseCompressedOops&quot;
    [junit] JVM: OpenJDK Runtime Environment, OpenJDK 64-Bit Server VM, Sun Microsystems Inc., 20.0-b11, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_23, Sun Microsystems Inc., null,
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 8
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13230535" author="dweiss" created="Thu, 15 Mar 2012 20:57:49 +0000"  >&lt;p&gt;Mac:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true
    [junit] JVM: Java(TM) SE Runtime Environment, Java HotSpot(TM) 64-Bit Server VM, Apple Inc., 20.4-b02-402, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_29, Apple Inc., null, 
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 4

&amp;gt; ant test-core -Dtestcase=TestRam* -Dtests.verbose=true &quot;-Dargs=-server -XX:-UseCompressedOops&quot;
    [junit] JVM: Java(TM) SE Runtime Environment, Java HotSpot(TM) 64-Bit Server VM, Apple Inc., 20.4-b02-402, Java Virtual Machine Specification, Sun Microsystems Inc., 1.6.0_29, Apple Inc., null, 
    [junit] NOTE: This JVM is 64bit: true
    [junit] NOTE: Reference size in this JVM: 8
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13230543" author="markrmiller@gmail.com" created="Thu, 15 Mar 2012 21:05:17 +0000"  >&lt;p&gt;Nooo!!! My eyes!!!! I&apos;m pretty sure my liver has just been virally licensed!&lt;/p&gt;</comment>
                    <comment id="13230572" author="dweiss" created="Thu, 15 Mar 2012 21:27:02 +0000"  >&lt;p&gt;Ok, right, sorry, let me scramble for intellectual property protection reasons:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;// See cemnmot at flie sratt abuot U_ANEESAFLF 
/
/ ULAAFEN_SEF (jnit, UfdAsnerS_zsiaedse ())
UEATERSNFN_Y (jint, UnidsdserSAasfe_ze (JNnEIv * env, jcbjeot unfsae))
UesWrpfapaner (&quot; UdenfsSseAazs_drie &quot;); 
rreutn seiozf (void *
;)
UNEF_SNEAD
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13230631" author="thetaphi" created="Thu, 15 Mar 2012 22:13:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;Becomes interesting. Do you know of any architecture with pointers different than 4 or 8 bytes? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When I was writing that code, I was thinking a very long time about: Hm, should I add a &quot;default&quot; case saying:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;default:
  throw new Error(&quot;Lucene does not like architectures with pointer size &quot; + addressSize)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But then I decided: If there is an architecture with a pointer size of 6, does this break Lucene really? Hm, maybe I should have added a comment there:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;default:
  // this is the philosophical case of Lucene reaching an architecture returning something different here
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13230644" author="thetaphi" created="Thu, 15 Mar 2012 22:28:53 +0000"  >&lt;p&gt;Maybe this for @UweSays:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;default:
  throw new Error(&quot;Your processor(*) hit me with his &quot; + addressSize + &quot; inch dick&quot;);
  // (*)Dawid
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13230647" author="dweiss" created="Thu, 15 Mar 2012 22:32:18 +0000"  >&lt;p&gt;I would throw an exception just so that we can hear about those architectures nobody has ever heard of &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13230652" author="dweiss" created="Thu, 15 Mar 2012 22:33:24 +0000"  >&lt;p&gt;fyi. &lt;a href=&quot;http://en.wikipedia.org/wiki/48-bit&quot; class=&quot;external-link&quot;&gt;http://en.wikipedia.org/wiki/48-bit&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13230655" author="thetaphi" created="Thu, 15 Mar 2012 22:37:09 +0000"  >&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Quadruple_precision_floating-point_format&quot; class=&quot;external-link&quot;&gt;http://en.wikipedia.org/wiki/Quadruple_precision_floating-point_format&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13230950" author="dweiss" created="Fri, 16 Mar 2012 07:46:49 +0000"  >&lt;p&gt;Yep, but I&apos;m talking about address registers and addressing in general. 48 bit addressing aligning would be inconvenient if you take into account that any index scaling addressing modes would have to do a shift and an addition (*3) instead of just a shift. Interesting stuff.&lt;/p&gt;</comment>
                    <comment id="13230956" author="thetaphi" created="Fri, 16 Mar 2012 07:55:51 +0000"  >&lt;p&gt;I agree, was just a joke. The comment before was more about suddenly appearing 128 bit architectures. That ones would have an addressSize of 16, still a power of 2 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I will now look into the unsafe array offsets...&lt;/p&gt;</comment>
                    <comment id="13230959" author="dweiss" created="Fri, 16 Mar 2012 08:01:31 +0000"  >&lt;p&gt;Nice. All of a sudden you could enumerate all the atoms in the universe &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I love Wolfram Alpha...&lt;br/&gt;
&lt;a href=&quot;http://www.wolframalpha.com/input/?i=is+number+of+atoms+in+the+universe+greater+than+2%5E128%3F&quot; class=&quot;external-link&quot;&gt;http://www.wolframalpha.com/input/?i=is+number+of+atoms+in+the+universe+greater+than+2%5E128%3F&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13230977" author="thetaphi" created="Fri, 16 Mar 2012 08:48:13 +0000"  >&lt;p&gt;I played around: Unsafe.arrayBaseOffset always returns 16 on my 64bit JVM, so it seems that NUM_BYTES_ARRAY_HEADER is wrong in our case (we have it as 12). It seems that the JVM aligns the array data to be multiple of 8 bytes on 64 bit machines?&lt;/p&gt;

&lt;p&gt;For normal objects, is there a way with unsafe to get the NUM_BYTES_OBJECT_HEADER?&lt;/p&gt;</comment>
                    <comment id="13230979" author="dweiss" created="Fri, 16 Mar 2012 09:03:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;For normal objects, is there a way with unsafe to get the NUM_BYTES_OBJECT_HEADER?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know and I don&apos;t know if it varies between vendors. As for aligning &amp;#8211; I bet this holds for anything, not only arrays. So fields of an object will be reordered and packed on their own boundary but entire themselves will be aligned on machine word boundaries for efficiency. Did you try running with Instrumentation (an agent)? What does it say about object/ array sizes?&lt;/p&gt;</comment>
                    <comment id="13230994" author="thetaphi" created="Fri, 16 Mar 2012 09:33:51 +0000"  >&lt;p&gt;Interestingly the ARRAY header seems to be much bigger on 64 bit platforms without compact refs, so I have the feeling that somehow thre is still some space needed for an object ref, so the original definition of the size was more correct? &lt;a href=&quot;https://gist.github.com/2038305&quot; class=&quot;external-link&quot;&gt;https://gist.github.com/2038305&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Using the original definition:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; NUM_BYTES_ARRAY_HEADER = NUM_BYTES_OBJECT_HEADER + NUM_BYTES_INT + NUM_BYTES_OBJECT_REF;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This looks much more like the above size, aligned to 8 bytes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Did you try running with Instrumentation (an agent)? What does it say about object/ array sizes?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Have to try out and set this up first.&lt;/p&gt;</comment>
                    <comment id="13231001" author="thetaphi" created="Fri, 16 Mar 2012 09:43:20 +0000"  >&lt;p&gt;This is also in line with this instumentation page:&lt;br/&gt;
&lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue142.html&quot; class=&quot;external-link&quot;&gt;http://www.javaspecialists.eu/archive/Issue142.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Which prints:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;measureSize(new byte[1000]);
byte[], shallow=1016, deep=1016
measureSize(new boolean[1000]);
boolean[], shallow=1016, deep=1016
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13231002" author="dweiss" created="Fri, 16 Mar 2012 09:45:49 +0000"  >&lt;p&gt;Array header is still 12 bytes but it is aligned to the next multiple-8 boundary? Looks like it.&lt;/p&gt;</comment>
                    <comment id="13231003" author="thetaphi" created="Fri, 16 Mar 2012 09:48:55 +0000"  >&lt;p&gt;But how does that explain that with non-compact refs the arrayBaseOffset is 24?&lt;/p&gt;</comment>
                    <comment id="13231017" author="dweiss" created="Fri, 16 Mar 2012 10:02:54 +0000"  >&lt;p&gt;Can you check what size does Object[] report vs. for example Integer[]? I think the difference may be because typed arrays need to know the type of their component.&lt;/p&gt;</comment>
                    <comment id="13231045" author="dweiss" created="Fri, 16 Mar 2012 10:42:49 +0000"  >&lt;p&gt;We peeked at the forbidden a bit again. The difference 12 vs. 16 bytes is a result of how ordinary object pointers (OOPs) are defined &amp;#8211; they are a combination of object header information (oopMark) and class pointer. The class pointer is a compile time union of either a regular pointer or a compact pointer. oopMark is either 4 bytes (32 bit jvms) or 8 bytes (64 bit jvms). So:&lt;/p&gt;

&lt;p&gt;64 bit jvm, full oops: 8 + 8 = 16&lt;br/&gt;
64 bit jvm, compact oops: 8 + 4 = 12&lt;br/&gt;
32 bit jvm: 4 + 4 = 8&lt;/p&gt;</comment>
                    <comment id="13231096" author="thetaphi" created="Fri, 16 Mar 2012 12:07:46 +0000"  >&lt;p&gt;With the help of Dawid (inspecting forbidden C code &lt;b&gt;g&lt;/b&gt;), we checked the actual size and how they are calculated. Based on that I changed the defaults depending on bitness (Object header is 16 on 64 bit without compact refs, array header is 24 on 64 bit).&lt;/p&gt;

&lt;p&gt;The attached patch will use the above defaults, but tries to update them using sun.misc.Unsafe. The trick to get the object header from usafe is by declaring a dummy class extending Object with one single field. We are then using unsafe to get the fieldOffset of that field. As Dawid pointed out, the return value is identical to his investigations (8 bytes on 32 bit archs, 16 bytes on 64 bit archs and 12 bytes on compact ref 64bit archs). So RamUsageEstimator was completely wrong in the past for 64 bit architectures.&lt;/p&gt;

&lt;p&gt;I also changed the funny switch statement (&quot;the &quot; + adressSize + &quot; inch dick&quot;) to assume 64 bits architecture, if addressSize &amp;gt;= 8.&lt;/p&gt;</comment>
                    <comment id="13231097" author="thetaphi" created="Fri, 16 Mar 2012 12:09:27 +0000"  >&lt;p&gt;I would like to remove the AverageBlabla memotry model. The code inside is simply no longer useful. RamUsageEstimator simply uses the sizes returned by the JVM.&lt;/p&gt;</comment>
                    <comment id="13231119" author="thetaphi" created="Fri, 16 Mar 2012 12:54:01 +0000"  >&lt;p&gt;Updated patch with the abstract and now useless MemoryModel removed.&lt;/p&gt;</comment>
                    <comment id="13231134" author="thetaphi" created="Fri, 16 Mar 2012 13:04:34 +0000"  >&lt;p&gt;Robert reminded me that there is also a heavily broken custom memory estimator in MemoryIndex, too. I will look into it, too.&lt;/p&gt;</comment>
                    <comment id="13231379" author="thetaphi" created="Fri, 16 Mar 2012 16:53:53 +0000"  >&lt;p&gt;Attached is a patch fixing several bugs and more:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed the MemoryIndex VM class and the completely outdated and incorrect estimation there.&lt;/li&gt;
	&lt;li&gt;Used Shai&apos;s new added methods also in Lucene&apos;s PackedInt classes&lt;/li&gt;
	&lt;li&gt;Fixes overflows in Shai&apos;s new methods, as they can overflow if arrays are greater than 2 GB (casts to long missing)&lt;/li&gt;
	&lt;li&gt;Fixed the up-rounding to multiples of 8 to work with longs&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What&apos;s the reason why this rounding up to 8 bytes was added? I assume this information comes from somewhere, but it was added by Shai without any explanation. Is this not also dependent on the 64bitness if its 8 or 4?&lt;/p&gt;

&lt;p&gt;Otherwise patch is ready.&lt;/p&gt;</comment>
                    <comment id="13231388" author="rcmuir" created="Fri, 16 Mar 2012 17:00:05 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Removed the MemoryIndex VM class and the completely outdated and incorrect estimation there.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;thank you!!!&lt;/p&gt;</comment>
                    <comment id="13231413" author="dweiss" created="Fri, 16 Mar 2012 17:34:33 +0000"  >&lt;p&gt;Awesome job, Uwe. I think I wasn&apos;t right about that alignment of arrays &amp;#8211; sizeof(int) should&apos;t come up to 8. I will look into this again in the evening, it got me interested. I&apos;ll also check out the alignments, so if this patch can wait until tomorrow then we&apos;ll be more confident we get the estimates right.&lt;/p&gt;</comment>
                    <comment id="13231625" author="dweiss" created="Fri, 16 Mar 2012 21:00:38 +0000"  >&lt;p&gt;This is very interesting indeed. &lt;/p&gt;

&lt;p&gt;So, I used the agent hook into a running VM to dump some of the internal diagnostics, including OOP sizes, heap word alignments, etc. Here&apos;s a scoop of the results (with client-side indicated sizes on the right):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;
# 1.7, 64 bit, OOPS compressed            (client)
getOopSize: 8                             ref size = 4         
Address size: 8                           array header = 16    
Bytes per long: 8                         object header = 12   
CPU: amd64
HeapOopSize: 4
HeapWordSize: 8
IntSize: 4
getMinObjAlignmentInBytes: 8
getObjectAlignmentInBytes: 8
isCompressedOopsEnabled: true
isLP64: true


# 1.7, 64 bit, full
getOopSize: 8                             ref size = 8     
Address size: 8                           array header = 24
Bytes per long: 8                         object header = 16
CPU: amd64
HeapOopSize: 8
HeapWordSize: 8
IntSize: 4
getMinObjAlignmentInBytes: 8
getObjectAlignmentInBytes: 8
isCompressedOopsEnabled: false
isLP64: true

# 1.7, 32 bit  
getOopSize: 4                             ref size = 4     
Address size: 4                           array header = 12
Bytes per long: 8                         object header = 8
CPU: x86
HeapOopSize: 4
HeapWordSize: 4
IntSize: 4
getMinObjAlignmentInBytes: 8
getObjectAlignmentInBytes: 8
isCompressedOopsEnabled: false
isLP64: false
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The question we asked ourselves with Uwe is why an empty array takes 24 bytes without OOP compression (that&apos;s object overhead and an int length, so should be 16 + 4 = 20)? The answer seems to be in how base offsets are calculated for arrays &amp;#8211; they seem to be enforced on HeapWordSize boundary and this is 8, even with OOP compressed:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  // Returns the offset of the first element.
  static int base_offset_in_bytes(BasicType type) {
    return header_size(type) * HeapWordSize;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I&apos;ll spare you the detailed code but the rounding to next HeapWordSize multiple seems evident in all cases. What&apos;s even more interesting, this &quot;wasted&quot; space is not (and cannot) be used for data so even a single integer pushes the array size to the next available bound:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;int[0] = 24
int[1] = 32   (*)
int[2] = 32
int[3] = 40
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, I could not resist to mention that object alignments... are adjustable, at least to 2^n boundaries. So you can also do this:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&amp;gt; java  -XX:-UseCompressedOops -XX:ObjectAlignmentInBytes=32 ...
Object = 32
int[0] = 32
int[1] = 32
int[2] = 32
int[3] = 64
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Nice, huh? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I don&apos;t think the JVM has been tested heavily for this possibility though because the code hung on me a few times if executed in that mode.&lt;/p&gt;</comment>
                    <comment id="13231668" author="dweiss" created="Fri, 16 Mar 2012 22:07:42 +0000"  >&lt;p&gt;He, he, he... this is fun, haven&apos;t been playing with Unsafe for a while and forgot how enjoyable this can be.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
            Unsafe us = ...;
            &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; [] dummy  = {0x11, 0x22, 0x33, 0x44};
            &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; []  dummy2 = {0}; &lt;span class=&quot;code-comment&quot;&gt;// match length above.
&lt;/span&gt;            &lt;span class=&quot;code-comment&quot;&gt;// Change the class of dummy to &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;[]...
&lt;/span&gt;            &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; klazz = us.getInt(dummy2, 8);
                        us.putInt( dummy, 8, klazz);
            &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; will be ok.
&lt;/span&gt;            dummy2 = (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;[])(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;) dummy;
            &lt;span class=&quot;code-comment&quot;&gt;// and we can run &lt;span class=&quot;code-keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; accessors on a &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] now...
&lt;/span&gt;            &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt; &quot;&lt;/span&gt; + &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.toHexString(dummy2[0]));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13231673" author="dweiss" created="Fri, 16 Mar 2012 22:08:49 +0000"  >&lt;p&gt;I think Yonik once mentioned he wanted a fast hash over byte[] &amp;#8211; this could be it (temporarily cast to a long[] and then revert after computations are over). Go for it, Yonik &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13231679" author="thetaphi" created="Fri, 16 Mar 2012 22:14:32 +0000"  >&lt;p&gt;Thanks for investigation. The 8 byte object size multiplier is fixed, so the round-up method is fine.&lt;/p&gt;

&lt;p&gt;I have been thinking about alignment things. Its a good possibility to get the object size by suming up the field sizes, but it can even be done better.&lt;/p&gt;

&lt;p&gt;If unsafe is available and useable, we can simply get the object size (including all headers), by finding the Math.max(field offset + field type length). So the object size is the offset of the last field (with biggest offset) + its size. This value is finally rounded up to multiples of 8.&lt;/p&gt;

&lt;p&gt;The attached patch does this.&lt;/p&gt;</comment>
                    <comment id="13231682" author="dweiss" created="Fri, 16 Mar 2012 22:19:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;The 8 byte object size multiplier is fixed, so the round-up method is fine.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think it&apos;s &quot;fixed&quot; &amp;#8211; see the -XX:ObjectAlignmentInBytes=32 above. But the defaults seem to be the same on all systems.&lt;/p&gt;</comment>
                    <comment id="13231719" author="thetaphi" created="Fri, 16 Mar 2012 22:57:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t think it&apos;s &quot;fixed&quot; &#8211; see the -XX:ObjectAlignmentInBytes=32 above. But the defaults seem to be the same on all systems.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would like to have the rounding also dynamic, but this is not possible to find out with Unsafe, at least for this I have no idea &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13231889" author="dweiss" created="Sat, 17 Mar 2012 08:04:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;at least for this I have no idea&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The management factory trick mentioned by Kris works for object alignment as well:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; spikes;

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.lang.management.ManagementFactory;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.lang.reflect.Method;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.List;

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.sun.management.HotSpotDiagnosticMXBean;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.sun.management.VMOption;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class ObAlignment
{
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; HOTSPOT_BEAN_NAME = &lt;span class=&quot;code-quote&quot;&gt;&quot;com.sun.management:type=HotSpotDiagnostic&quot;&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; HotSpotDiagnosticMXBean hotspotMBean;
    
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; HotSpotDiagnosticMXBean getHotSpotMBean() {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (hotspotMBean == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
          hotspotMBean = ManagementFactory.newPlatformMXBeanProxy(
            ManagementFactory.getPlatformMBeanServer(),
            HOTSPOT_BEAN_NAME,
            HotSpotDiagnosticMXBean.class);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
          e.printStackTrace();
        }
      }
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hotspotMBean;
    }

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; [] args)
        &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception
    {
        &lt;span class=&quot;code-comment&quot;&gt;// Just the object alignment.
&lt;/span&gt;        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(getHotSpotMBean().getVMOption(&lt;span class=&quot;code-quote&quot;&gt;&quot;ObjectAlignmentInBytes&quot;&lt;/span&gt;));

        &lt;span class=&quot;code-comment&quot;&gt;// Everything.
&lt;/span&gt;        &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; fc = &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;.forName(&lt;span class=&quot;code-quote&quot;&gt;&quot;sun.management.Flag&quot;&lt;/span&gt;);
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(fc);
        Method m = fc.getDeclaredMethod(&lt;span class=&quot;code-quote&quot;&gt;&quot;getAllFlags&quot;&lt;/span&gt;);
        m.setAccessible(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
        List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; flags = (List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt;) m.invoke(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; f : flags) {
            Method dm = f.getClass().getDeclaredMethod(&lt;span class=&quot;code-quote&quot;&gt;&quot;getVMOption&quot;&lt;/span&gt;);
            dm.setAccessible(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
            VMOption option = (VMOption) dm.invoke(f);
            &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(option);
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t think it is of much practical use for now (object alignment seems to be constant everywhere), but we could as well probe it &amp;#8211; if it&apos;s available why not use it.&lt;/p&gt;

&lt;p&gt;I&apos;d also like to add a shallow size method (which wouldn&apos;t follow the fields, just return the aligned object size). I&apos;ll be able to work on it in the evening though, not sooner.&lt;/p&gt;</comment>
                    <comment id="13231893" author="thetaphi" created="Sat, 17 Mar 2012 08:26:29 +0000"  >&lt;p&gt;Too funny,&lt;br/&gt;
I had the same idea while at breakfast and started to implement it when you were writing your comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I will post patch soon (also with other improvements)!&lt;/p&gt;</comment>
                    <comment id="13231894" author="thetaphi" created="Sat, 17 Mar 2012 08:31:08 +0000"  >&lt;p&gt;I will add a shallow parameter to the estimate method, we just dont have to dig into, so it&apos;s a simple if check.&lt;/p&gt;</comment>
                    <comment id="13231901" author="thetaphi" created="Sat, 17 Mar 2012 08:56:32 +0000"  >&lt;p&gt;New patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;retrieve object alignment (default 8, e.g. 32bit JVMs don&apos;t report it)&lt;/li&gt;
	&lt;li&gt;add shallow object size measurement&lt;/li&gt;
	&lt;li&gt;add some security checks to possibly handle the &quot;cookie&quot; warning in Unsafe.objectFieldOffset() (the offsets may be &quot;scaled&quot;). Current JVMs never do this, but the documentation explicitely states that the offsets may not be byte-aligned.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13231916" author="thetaphi" created="Sat, 17 Mar 2012 10:56:42 +0000"  >&lt;p&gt;Minor improvements.&lt;/p&gt;</comment>
                    <comment id="13231981" author="dweiss" created="Sat, 17 Mar 2012 14:11:45 +0000"  >&lt;p&gt;The patch looks good. I don&apos;t know if decorating IdentityHashMap to be a set adds any overhead... I was also thinking about doing a custom set impl. for this so that we know how much memory we allocate during the checking itself, but it seems to be very specific to what I need, so no worries.&lt;/p&gt;

&lt;p&gt;One thing:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
(size % NUM_BYTES_OBJECT_ALIGNMENT);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Byte alignment will be a power of 2 (that option to change it even enforces it when you start the JVM) so you can do a bitmask instead of modulo - should be slighly faster.&lt;/p&gt;</comment>
                    <comment id="13231986" author="thetaphi" created="Sat, 17 Mar 2012 14:53:21 +0000"  >&lt;p&gt;I separated the shallow Object inspection to a static method, which is more cheap (no RamUsageEstimator instance is needed). The static method now only takes a Class&amp;lt;?&amp;gt; parameter and returns the size (an instance is not even needed).&lt;/p&gt;

&lt;p&gt;I also added a diagnostic boolean, so you can query RamUsageEstimator, if the used JVM is supported (supports Hotspot diagnostics, sum.misc.Unsafe). If that is not the case, our testcase will print a warning so users cam report back (if they run the tests).&lt;/p&gt;

&lt;p&gt;I think this is ready to commit.&lt;/p&gt;</comment>
                    <comment id="13231988" author="thetaphi" created="Sat, 17 Mar 2012 14:58:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;One thing:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
(size % NUM_BYTES_OBJECT_ALIGNMENT);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Byte alignment will be a power of 2 (that option to change it even enforces it when you start the JVM) so you can do a bitmask instead of modulo - should be slighly faster.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think thats really needed here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Speed is limited by reflection in most cases and this one calculation should not matter. Also the number is not reported back as power of 2, so I have to calc the log2 first (ok, ntz &amp;amp;co.), but I don&apos;t think we should actually limit that to powers of 2. Maybe another vendor has the ultimate answer of 42 for his objects?&lt;/p&gt;</comment>
                    <comment id="13231989" author="thetaphi" created="Sat, 17 Mar 2012 15:02:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t know if decorating IdentityHashMap to be a set adds any overhead&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The whole problem is more that it might happen that the IdentityHashMap takes horrible amounts of memory while inspecting (think of a boxed numbers array like Byte&lt;span class=&quot;error&quot;&gt;&amp;#91;50000&amp;#93;&lt;/span&gt;). Speed is not important, reflection is slow &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I have no better idea about how to detect duplicates, unfortunately. The old trick from Arrays.deepEquals() to stop when the parameter itsself is seen again, is not enough here.&lt;/p&gt;</comment>
                    <comment id="13231992" author="thetaphi" created="Sat, 17 Mar 2012 15:25:06 +0000"  >&lt;p&gt;One more improvement:&lt;br/&gt;
The shallow Class inspection can ignore superclasses, if Unsafe is in use. As additional fields are always added at the end (otherwise casting of classes and later field access would not work inside the JVM), to find the maximum field offset we don&apos;t need to go to superclasses.&lt;/p&gt;

&lt;p&gt;I want to commit and backport this to 3.x during the weekend.&lt;/p&gt;</comment>
                    <comment id="13232006" author="dweiss" created="Sat, 17 Mar 2012 16:40:52 +0000"  >&lt;p&gt;Reflection don&apos;t need to cost you much if you make a cache along the way. Retrieving an object&apos;s class is virtually zero cost so this would make it very efficient and the number of classes in the system is much smaller than the number of objects so it shouldn&apos;t be a problem.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;to find the maximum field offset we don&apos;t need to go to superclasses.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I can&apos;t imagine a situation where this wouldn&apos;t be the case although an assertion here would be nice just to make sure we&apos;re not assuming something that isn&apos;t true.&lt;/p&gt;


&lt;p&gt;I will take a closer look at the patch again this evening and do some testing/ API flexibility based on what I have in my project. Will report on the results.&lt;/p&gt;</comment>
                    <comment id="13232024" author="thetaphi" created="Sat, 17 Mar 2012 17:30:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;Reflection don&apos;t need to cost you much if you make a cache along the way. Retrieving an object&apos;s class is virtually zero cost so this would make it very efficient and the number of classes in the system is much smaller than the number of objects so it shouldn&apos;t be a problem.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Would be like the reflection  cache in AttributeSource &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But yes I was also thinking about a second IdentityHashMap&amp;lt;Class&amp;lt;?&amp;gt;,Long&amp;gt; along the way.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I can&apos;t imagine a situation where this wouldn&apos;t be the case although an assertion here would be nice just to make sure we&apos;re not assuming something that isn&apos;t true.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thats already checked in the test, who has 2 subclasses, one with no additional fields (size must be identical) and one with 2 more fields (should be &amp;gt;=).&lt;/p&gt;</comment>
                    <comment id="13232030" author="shaie" created="Sat, 17 Mar 2012 17:50:59 +0000"  >&lt;p&gt;Wow, what awesome improvements you guys have added !&lt;/p&gt;

&lt;p&gt;Uwe, +1 to commit. I unassigned myself - you and Dawid definitely deserve the credit!&lt;/p&gt;</comment>
                    <comment id="13232077" author="dweiss" created="Sat, 17 Mar 2012 21:53:22 +0000"  >&lt;p&gt;Modified method naming convention: any sizeOf  is &quot;deep&quot;, shallowSizeOf* is &quot;shallow&quot;. Methods in RUE are now static; didn&apos;t hide the constructor though (maybe we should?).&lt;/p&gt;

&lt;p&gt;More comments in a minute.&lt;/p&gt;</comment>
                    <comment id="13232078" author="thetaphi" created="Sat, 17 Mar 2012 22:06:35 +0000"  >&lt;p&gt;Thanks for cleanup!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;didn&apos;t hide the constructor though (maybe we should?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We must. Class is final and has no instance methods -&amp;gt; useless to have ctor. Also as previous versions in 3.x allowed instances, we should prevent this to fix incorrect usage.&lt;/p&gt;</comment>
                    <comment id="13232079" author="dweiss" created="Sat, 17 Mar 2012 22:07:15 +0000"  >&lt;p&gt;I&apos;ve played with the code a bit and I&apos;ve been trying to figure out a way to determine empirically &quot;how far off&quot; is the estimation from real life usage. It&apos;s not easy because RUE itself allocates memory (and not small quantities in case of complex object graphs!). I left these experiments in StressRamUsageEstimator; it is a test case &amp;#8211; maybe we should add @Ignore and rename it to Test*, don&apos;t know.&lt;/p&gt;

&lt;p&gt;Anyway, the allocation seems to be measured pretty accurately. When tlabs are disabled this is a result of allocating small byte arrays for example:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; committed           max        estimated(allocation)
      2 MB	   48.4 MB	  16 bytes
    1.7 MB	   48.4 MB	  262.4 KB
      2 MB	   48.4 MB	  524.6 KB
    2.2 MB	   48.4 MB	    787 KB
    2.5 MB	   48.4 MB	      1 MB
    2.7 MB	   48.4 MB	    1.3 MB
      3 MB	   48.4 MB	    1.5 MB
    3.3 MB	   48.4 MB	    1.8 MB
....
   46.9 MB	   48.4 MB	   45.6 MB
   47.1 MB	   48.4 MB	   45.9 MB
   47.4 MB	   48.4 MB	   46.1 MB
   47.6 MB	   48.4 MB	   46.4 MB
   47.9 MB	   48.4 MB	   46.6 MB
   48.1 MB	   48.4 MB	   46.9 MB
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So it&apos;s fairly ideal (committed memory is all committed memory so I assume additional data structures, classes, etc. also count in).&lt;/p&gt;

&lt;p&gt;Unfortunately it&apos;s not always so smooth, for example jrockit&apos;s mx beans seem not to return the actual memory allocation state (and if they do, I don&apos;t understand it):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; committed           max        estimated(allocation)
   29.4 MB	     50 MB	  16 bytes
   29.8 MB	     50 MB	  262.5 KB
   30.2 MB	     50 MB	  524.9 KB
   30.4 MB	     50 MB	  787.3 KB
   30.8 MB	     50 MB	      1 MB
   31.1 MB	     50 MB	    1.3 MB
   31.4 MB	     50 MB	    1.5 MB
   31.7 MB	     50 MB	    1.8 MB
     32 MB	     50 MB	      2 MB
   32.4 MB	     50 MB	    2.3 MB
   32.7 MB	     50 MB	    2.6 MB
   33.1 MB	     50 MB	    2.8 MB
   33.5 MB	     50 MB	    3.1 MB
   33.8 MB	     50 MB	    3.3 MB
   34.2 MB	     50 MB	    3.6 MB
   34.5 MB	     50 MB	    3.8 MB
   34.8 MB	     50 MB	    4.1 MB
   35.2 MB	     50 MB	    4.4 MB
   35.5 MB	     50 MB	    4.6 MB
   35.7 MB	     50 MB	    4.9 MB
   36.2 MB	     50 MB	    5.1 MB
   36.4 MB	     50 MB	    5.4 MB
...
   49.6 MB	     50 MB	   47.6 MB
     50 MB	     50 MB	   47.9 MB
   49.6 MB	     50 MB	   48.2 MB
   49.9 MB	     50 MB	   48.4 MB
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A snapshot from 32 bit HotSpot:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;...
   25.5 MB	   48.4 MB	   24.7 MB
   25.7 MB	   48.4 MB	   24.9 MB
   25.9 MB	   48.4 MB	   25.1 MB
   26.1 MB	   48.4 MB	   25.3 MB
   26.3 MB	   48.4 MB	   25.5 MB
   26.5 MB	   48.4 MB	   25.7 MB
   26.7 MB	   48.4 MB	   25.9 MB
   26.8 MB	   48.4 MB	   26.1 MB
     27 MB	   48.4 MB	   26.4 MB
   27.2 MB	   48.4 MB	   26.6 MB
   27.4 MB	   48.4 MB	   26.8 MB
   27.7 MB	   48.4 MB	     27 MB
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I see two problems that remain, but I don&apos;t think they&apos;re urgent enough to be addressed now:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the stack easily overflows if the graph of objects has long chains. This is demonstrated in the test case (uncomment ignore annotation).&lt;/li&gt;
	&lt;li&gt;there is a fair amount of memory allocation going on in the RUE itself. If one &lt;em&gt;knows&lt;/em&gt; the graph of an object&apos;s dependencies is a tree then the memory cost could be decreased to zero (because we wouldn&apos;t need to remember which objects we&apos;ve seen so far).&lt;/li&gt;
	&lt;li&gt;we could make RUE an object again (resign from static methods) and have a cache of classes and class-fields to avoid reflective accesses over and over. If one performed estimations over and over then such a  RUE instance would have an initial cost, but then would be running smoother.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Having said that, I&apos;m +1 for committing this in if you agree with the changes I&apos;ve made (I will be a pain in the arse about that naming convention discriminating between shallow vs. deep sizeOf though &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="13232082" author="dweiss" created="Sat, 17 Mar 2012 22:10:58 +0000"  >&lt;p&gt;Oh, one thing that springs to my mind is that we could have an automatically generated class with nested static classes with a random arrangement of all sorts of fields (in all sorts of configurations) and use a similar empirical benchmark to the one I did on small byte arrays but on these objects. This would show if we&apos;re estimating object field offsets and sizes correctly. &lt;/p&gt;

&lt;p&gt;I wouldn&apos;t go into deep object structures though &amp;#8211; I&apos;ve tried this and it&apos;s hard to tell what the allocation is and what the overhead/ noise of measurement is.&lt;/p&gt;</comment>
                    <comment id="13232090" author="thetaphi" created="Sat, 17 Mar 2012 22:43:51 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I am fine with the patch for now, changed in this patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Hidden ctor&lt;/li&gt;
	&lt;li&gt;Cleaned up test to use static import consequently&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The stress test is an testcase, but not automatically executed (you have to explicitely do that with -Dtestcase=...). I think thats wanted, right? Otherwise we should rename, but its also noisy and slow.&lt;/p&gt;</comment>
                    <comment id="13232252" author="thetaphi" created="Sun, 18 Mar 2012 10:53:13 +0000"  >&lt;p&gt;Final patch: I removed some code duplication and improved exception handling for the reflection while iterating class tree. Simply  suppressing is a bad idea, as the resulting size would be underdetermined.&lt;/p&gt;

&lt;p&gt;I will commit this later this evening and then backport to 3.x.&lt;/p&gt;</comment>
                    <comment id="13232257" author="shaie" created="Sun, 18 Mar 2012 11:15:18 +0000"  >&lt;p&gt;Thanks Uwe !&lt;/p&gt;</comment>
                    <comment id="13232261" author="thetaphi" created="Sun, 18 Mar 2012 11:58:33 +0000"  >&lt;p&gt;Javadocs fixes.&lt;/p&gt;</comment>
                    <comment id="13232279" author="dweiss" created="Sun, 18 Mar 2012 14:28:03 +0000"  >&lt;p&gt;Looks good to me, thanks Uwe.&lt;/p&gt;</comment>
                    <comment id="13232281" author="thetaphi" created="Sun, 18 Mar 2012 14:59:51 +0000"  >&lt;p&gt;Committed trunk revision: 1302133&lt;/p&gt;

&lt;p&gt;I will now backport with deprecations and add CHANGES.txt later!&lt;/p&gt;</comment>
                    <comment id="13232291" author="thetaphi" created="Sun, 18 Mar 2012 15:56:11 +0000"  >&lt;p&gt;Patch for 3.x including backwards layer (deprecated instances of RUE + string interning support). MemoryModels were nuked completely (will add comment to backwards changes).&lt;/p&gt;</comment>
                    <comment id="13232294" author="thetaphi" created="Sun, 18 Mar 2012 16:20:54 +0000"  >&lt;p&gt;Committed 3.x revision: 1302152&lt;/p&gt;

&lt;p&gt;CHANGES.txt committed in revisions: 1302155 (3.x), 1302156 (trunk)&lt;/p&gt;

&lt;p&gt;Thanks Dawid and Shai!&lt;/p&gt;

&lt;p&gt;Dawid and I will now look into donating this masterpiece to maybe Apache Commons Lang or similar, as it&apos;s of general use.&lt;/p&gt;</comment>
                    <comment id="13235494" author="dweiss" created="Thu, 22 Mar 2012 10:29:18 +0000"  >&lt;p&gt;I&apos;ve been experimenting a bit with the new code. Field offsets for three classes in a hierarchy with unalignable fields (byte, long combinations at all levels). Note unaligned reordering of byte field in JRockit - nice.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;JVM: [JVM: HotSpot, Sun Microsystems Inc., 1.6.0_31] (compressed OOPs)
@12  4 Super.superByte
@16  8 Super.subLong
@24  8 Sub.subLong
@32  4 Sub.subByte
@36  4 SubSub.subSubByte
@40  8 SubSub.subSubLong
@48    sizeOf(SubSub.class instance)

JVM: [JVM: HotSpot, Sun Microsystems Inc., 1.6.0_31] (normal OOPs)
@16  8 Super.subLong
@24  8 Super.superByte
@32  8 Sub.subLong
@40  8 Sub.subByte
@48  8 SubSub.subSubLong
@56  8 SubSub.subSubByte
@64    sizeOf(SubSub.class instance)


JVM: [JVM: J9, IBM Corporation, 1.6.0]
@24  8 Super.subLong
@32  4 Super.superByte
@36  4 Sub.subByte
@40  8 Sub.subLong
@48  8 SubSub.subSubLong
@56  8 SubSub.subSubByte
@64    sizeOf(SubSub.class instance)

JVM: [JVM: JRockit, Oracle Corporation, 1.6.0_26] (64-bit JVM!)
@ 8  8 Super.subLong
@16  1 Super.superByte
@17  7 Sub.subByte
@24  8 Sub.subLong
@32  8 SubSub.subSubLong
@40  8 SubSub.subSubByte
@48    sizeOf(SubSub.class instance)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13235500" author="thetaphi" created="Thu, 22 Mar 2012 11:02:33 +0000"  >&lt;p&gt;Thanks for the insight.&lt;/p&gt;

&lt;p&gt;When thinking about the reordering, I am a littel bit afraid about the &quot;optimization&quot; in the shallow sizeOf(Class&amp;lt;?&amp;gt;). This optimiaztion does not recurse to superclasses, as it assumes, that all field offsets are greater than those of the superclass, so finding the maximum does not need to recurse up (so it early exits).&lt;/p&gt;

&lt;p&gt;This is generally true (also in the above printout), but not guaranteed. E.g. JRockit does it partly (it reuses space inside the superclass area to locate the byte from the subclass). In the above example still the order of fields is always Super-Sub-SubSub, but if the ordeing in the JRockit example would be like:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@ 8  1 Super.superByte
@ 9  7 Sub.subByte
@16  8 Super.subLong
@24  8 Sub.subLong
@32  8 SubSub.subSubLong
@40  8 SubSub.subSubByte
@48    sizeOf(SubSub.class instance)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The only thing the JVM cannot change is field offsets between sub classes (so the field offset of the superclass is inherited), but it could happen that &lt;b&gt;new&lt;/b&gt; fields are located between super&apos;s fields (see above - it&apos;s unused space). This would also allow casting and so on (it&apos;s unused space in superclass). Unfortunately with that reordering the maximum field offset in the subclass is no longer guaranteed to be greater.&lt;/p&gt;

&lt;p&gt;I would suggest that we remove the &quot;optimization&quot; in the shallow class size method. It&apos;s too risky in my opinion to underdetermine the size, because the maximum offset in the subclass is &amp;lt; the maximum offset in the superclass.&lt;/p&gt;

&lt;p&gt;I hope my explanation was understandable... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Dawid, what do you thing, should we remove the &quot;optimization&quot;? Patch is easy.&lt;/p&gt;</comment>
                    <comment id="13235501" author="dweiss" created="Thu, 22 Mar 2012 11:09:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;I hope my explanation was understandable... &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perfectly well. Yes, I agree, it&apos;s possible to fill in the &quot;holes&quot; packing them with fields from subclasses. It would be a nice vm-level optimization in fact! &lt;/p&gt;

&lt;p&gt;I&apos;m still experimenting on this code and cleaning/ adding javadocs &amp;#8211; I&apos;ll patch this and provide a complete patch once I&apos;m done, ok?&lt;/p&gt;</comment>
                    <comment id="13235502" author="thetaphi" created="Thu, 22 Mar 2012 11:11:45 +0000"  >&lt;p&gt;OK. All you have to remove is the if (fieldFound &amp;amp;&amp;amp; useUnsafe) check and always recurse. fieldFound itsself can also be removed.&lt;/p&gt;</comment>
                    <comment id="13235505" author="thetaphi" created="Thu, 22 Mar 2012 11:17:35 +0000"  >&lt;p&gt;JRockit could even compress like this, it would still allow casting as all holes are solely used by one sub-class:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@ 8  1 Super.superByte
@ 9  1 Sub.subByte
@10  6 SubSub.subSubByte
@16  8 Super.subLong
@24  8 Sub.subLong
@32  8 SubSub.subSubLong
@40    sizeOf(SubSub.class instance)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13235506" author="dweiss" created="Thu, 22 Mar 2012 11:24:20 +0000"  >&lt;p&gt;Maybe it does such things already. I didn&apos;t check extensively.&lt;/p&gt;</comment>
                    <comment id="13235508" author="thetaphi" created="Thu, 22 Mar 2012 11:26:27 +0000"  >&lt;p&gt;We have to remove the shallow size optimization in 3.x and trunk.&lt;/p&gt;</comment>
                    <comment id="13235570" author="dweiss" created="Thu, 22 Mar 2012 13:20:37 +0000"  >&lt;p&gt;I confirmed that this packing indeed takes place. Wrote a pseudo-random test with lots of classes and fields. Here&apos;s an offender on J9 for example (Wild_&lt;/p&gt;
{inheritance-level}
&lt;p&gt;_&lt;/p&gt;
{field-number}
&lt;p&gt;):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;@24  4 Wild_0_92.fld_0_0_92
@28  4 Wild_0_92.fld_1_0_92
@32  4 Wild_0_92.fld_2_0_92
@36  4 Wild_0_92.fld_3_0_92
@40  4 Wild_0_92.fld_4_0_92
@44  4 Wild_0_92.fld_5_0_92
@48  4 Wild_0_92.fld_6_0_92
@52  4 Wild_2_5.fld_0_2_5
@56  8 Wild_1_85.fld_0_1_85
@64  8 Wild_1_85.fld_1_1_85
@72    sizeOf(Wild_2_5 instance)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HotSpot and JRockit don&apos;t seem to do this (at least it didn&apos;t fail on the example).&lt;/p&gt;</comment>
                    <comment id="13235577" author="thetaphi" created="Thu, 22 Mar 2012 13:45:05 +0000"  >&lt;p&gt;Thanks, in that case shallowSizeOf(Wild_2_5.class) would incorrectly return 56 because of the short-circuit - so let&apos;s fix this.&lt;/p&gt;</comment>
                    <comment id="13235588" author="dweiss" created="Thu, 22 Mar 2012 14:07:34 +0000"  >&lt;p&gt;Yep, that assumption was wrong &amp;#8211; indeed:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;WildClasses.Wild_2_5 wc = new WildClasses.Wild_2_5();
wc.fld_6_0_92 = 0x1122;
wc.fld_0_2_5 = Float.intBitsToFloat(0xa1a2a3a4);
wc.fld_0_1_85 = Double.longBitsToDouble(0xb1b2b3b4b5b6b7L);
System.out.println(ExpMemoryDumper.dumpObjectMem(wc));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;results in:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;0x0000 b0 3d 6f 01 00 00 00 00 0e 80 79 01 00 00 00 00
0x0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0030 22 11 00 00 a4 a3 a2 a1 b7 b6 b5 b4 b3 b2 b1 00
0x0040 00 00 00 00 00 00 00 00
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And you can see they are reordered and longs are aligned.&lt;/p&gt;

&lt;p&gt;I&apos;ll provide a cumulative patch of changes in the evening, there&apos;s one more thing I wanted to add (cache of fields) because this affects processing speed.&lt;/p&gt;</comment>
                    <comment id="13236028" author="dweiss" created="Thu, 22 Mar 2012 20:59:52 +0000"  >&lt;p&gt;Ok, I admit J9 is fascinating... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; How much memory does this take?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class X {
  &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; a = 0x11;
  &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; b = 0x22;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here is the memory layout:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
[JVM: IBM J9 VM, 2.6, IBM Corporation, IBM Corporation, 1.7.0]
0x0000 00 b8 21 c4 5f 7f 00 00 00 00 00 00 00 00 00 00
0x0010 11 00 00 00 22 00 00 00
@16  4 Super.b1
@20  4 Super.b2
@24    sizeOf(Super instance)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t think I screwed up anything. It really is 4 byte alignment &lt;em&gt;on all fields&lt;/em&gt;.&lt;/p&gt;</comment>
                    <comment id="13236504" author="dweiss" created="Fri, 23 Mar 2012 10:40:54 +0000"  >&lt;p&gt;Don&apos;t be scared by the size of this patch &amp;#8211; it contains a lot of generated code in WildClasses.&lt;/p&gt;

&lt;p&gt;Improvements:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;size estimation is not recursive (which led to stack overflows quite easily on more complex object graphs),&lt;/li&gt;
	&lt;li&gt;decreased memory consumption by using a custom impl. of an identity object set.&lt;/li&gt;
	&lt;li&gt;added a cache of resolved class information (ref. fields, shallow size).&lt;/li&gt;
	&lt;li&gt;removed the optimization of counting only subclass field offsets because fields can be packed (J9).&lt;/li&gt;
	&lt;li&gt;added more verbose information about unsupported JVM features. J9 doesn&apos;t have the MX bean for example (and does dump this).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The above changes also speed up the entire processing.&lt;/p&gt;</comment>
                    <comment id="13236537" author="dweiss" created="Fri, 23 Mar 2012 12:24:10 +0000"  >&lt;p&gt;Added a test case for identity has set, removed constants, removed wild classes.&lt;/p&gt;</comment>
                    <comment id="13236557" author="thetaphi" created="Fri, 23 Mar 2012 12:59:29 +0000"  >&lt;p&gt;I think the patch is now fine! I will commit it later and backport to 3.x.&lt;/p&gt;</comment>
                    <comment id="13236626" author="dweiss" created="Fri, 23 Mar 2012 14:29:16 +0000"  >&lt;p&gt;Thanks Uwe. I&apos;ll be working in the evening again but if you&apos;re faster go ahead and commit it in.&lt;/p&gt;</comment>
                    <comment id="13236964" author="thetaphi" created="Fri, 23 Mar 2012 19:17:44 +0000"  >&lt;p&gt;Committed trunk revision: 1304485, 1304513, 1304564&lt;br/&gt;
Committed 3.x revision: 1304565&lt;/p&gt;</comment>
                    <comment id="13237172" author="dweiss" created="Fri, 23 Mar 2012 21:47:32 +0000"  >&lt;p&gt;I&apos;ve been thinking how one can assess the estimation quality of the new code. I came up with this:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I allocate an Object[] half the size of estimated maximum available RAM (just to make sure all objects will fit without the need to reallocate),&lt;/li&gt;
	&lt;li&gt;I precompute shallow sizes for instances of all &quot;wild classes&quot; (classes with random fields, including arrays).&lt;/li&gt;
	&lt;li&gt;I then fill in the &quot;vault&quot; array above with random instances of wild classes, summing up the estimated size UNTIL I HIT OOM.&lt;/li&gt;
	&lt;li&gt;Once I git OOM I know how much we actually allocated vs. how much space we thought we did allocate.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The results are very accurate on HotSpot if one is using serial GC. For example:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;[JVM: Java HotSpot(TM) 64-Bit Server VM, 20.4-b02, Sun Microsystems Inc., Sun Microsystems Inc., 1.6.0_29]
Max: 483.4 MB, Used: 698.9 KB, Committed: 123.8 MB
Expected free: 240.9 MB, Allocated estimation: 240.8 MB, Difference: -0.05% (113.6 KB)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If one runs with a parallel GC things do get out of hand because the GC is not keeping up with allocations (although I&apos;m not sure how I should interpret this because we only allocate; it&apos;s not possible to free any space &amp;#8211; maybe there are different GC pools or something):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;[JVM: Java HotSpot(TM) 64-Bit Server VM, 20.4-b02, Sun Microsystems Inc., Sun Microsystems Inc., 1.6.0_29]
Max: 444.5 MB, Used: 655.4 KB, Committed: 122.7 MB
Expected free: 221.5 MB, Allocated estimation: 174.2 MB, Difference: -21.34% (47.3 MB)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JRockit:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;[JVM: Oracle JRockit(R), R28.1.4-7-144370-1.6.0_26-20110617-2130-windows-x86_64, Oracle Corporation, Oracle Corporation, 1.6.0_26]
Max: 500 MB, Used: 3.5 MB, Committed: 64 MB
Expected free: 247.7 MB, Allocated estimation: 249.5 MB, Difference: 0.74% (1.8 MB)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think we&apos;re good. If somebody wishes to experiment, the spike is here:&lt;br/&gt;
&lt;a href=&quot;https://github.com/dweiss/java-sizeof&quot; class=&quot;external-link&quot;&gt;https://github.com/dweiss/java-sizeof&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;mvn test
mvn dependency:copy-dependencies
java -cp target\classes:target\test-classes:target\dependency\junit-4.10.jar \
  com.carrotsearch.sizeof.TestEstimationQuality
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13238203" author="dweiss" created="Mon, 26 Mar 2012 09:27:51 +0100"  >&lt;p&gt;For historical records: the previous implementation of RamUsageEstimator was off by anything between 3% (random size objects, including arrays) to 20% (objects smaller than 80 bytes). Again &amp;#8211; these are &quot;perfect scenario&quot; measurements with empty heap and max. allocation until OOM, with a serial GC. With a concurrent and parallel GCs the memory consumption estimation is still accurate but it&apos;s nearly impossible to tell when an OOM will occur or how the GC will manage the heap space. &lt;/p&gt;</comment>
                    <comment id="13238206" author="thetaphi" created="Mon, 26 Mar 2012 09:32:43 +0100"  >&lt;p&gt;That&apos;s true. But you can still get the &quot;unreleaseable allocation&quot;, so the size of the non-gc-able object graph. If GC does not free the objects after release fast-enough, it will still do it once memory gets low. But the allocated objects with hard refs are not releaseable.&lt;/p&gt;

&lt;p&gt;So I think it&apos;s fine for memory requirement purposes. If you want real heap allocation, you must use instrumentation.&lt;/p&gt;</comment>
                    <comment id="13238208" author="dweiss" created="Mon, 26 Mar 2012 09:45:41 +0100"  >&lt;p&gt;I didn&apos;t say it&apos;s wrong &amp;#8211; it is fine and accurate. What I&apos;m saying is that it&apos;s not really suitable for predictions; for answering questions like: how many objects of a given type/ types can I allocate before an OOM hits me? It doesn&apos;t really surprise me that much, but it would be nice. For measuring already allocated stuff it&apos;s more than fine of course.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12518837" name="LUCENE-3867-3.x.patch" size="54135" author="thetaphi" created="Sun, 18 Mar 2012 15:56:10 +0000" />
                    <attachment id="12518315" name="LUCENE-3867-compressedOops.patch" size="3765" author="thetaphi" created="Wed, 14 Mar 2012 13:04:44 +0000" />
                    <attachment id="12519612" name="LUCENE-3867.patch" size="40383" author="dweiss" created="Fri, 23 Mar 2012 12:24:10 +0000" />
                    <attachment id="12519603" name="LUCENE-3867.patch" size="321916" author="dweiss" created="Fri, 23 Mar 2012 10:40:54 +0000" />
                    <attachment id="12518835" name="LUCENE-3867.patch" size="50604" author="thetaphi" created="Sun, 18 Mar 2012 11:58:32 +0000" />
                    <attachment id="12518833" name="LUCENE-3867.patch" size="50617" author="thetaphi" created="Sun, 18 Mar 2012 10:53:13 +0000" />
                    <attachment id="12518812" name="LUCENE-3867.patch" size="50233" author="thetaphi" created="Sat, 17 Mar 2012 22:50:07 +0000" />
                    <attachment id="12518810" name="LUCENE-3867.patch" size="50418" author="dweiss" created="Sat, 17 Mar 2012 21:53:22 +0000" />
                    <attachment id="12518795" name="LUCENE-3867.patch" size="36270" author="thetaphi" created="Sat, 17 Mar 2012 15:33:15 +0000" />
                    <attachment id="12518793" name="LUCENE-3867.patch" size="35396" author="thetaphi" created="Sat, 17 Mar 2012 14:53:21 +0000" />
                    <attachment id="12518785" name="LUCENE-3867.patch" size="32787" author="thetaphi" created="Sat, 17 Mar 2012 10:56:42 +0000" />
                    <attachment id="12518782" name="LUCENE-3867.patch" size="32606" author="thetaphi" created="Sat, 17 Mar 2012 08:56:31 +0000" />
                    <attachment id="12518743" name="LUCENE-3867.patch" size="27232" author="thetaphi" created="Fri, 16 Mar 2012 22:14:32 +0000" />
                    <attachment id="12518702" name="LUCENE-3867.patch" size="25791" author="thetaphi" created="Fri, 16 Mar 2012 16:53:53 +0000" />
                    <attachment id="12518661" name="LUCENE-3867.patch" size="17381" author="thetaphi" created="Fri, 16 Mar 2012 12:54:01 +0000" />
                    <attachment id="12518657" name="LUCENE-3867.patch" size="12951" author="thetaphi" created="Fri, 16 Mar 2012 12:07:46 +0000" />
                    <attachment id="12518463" name="LUCENE-3867.patch" size="9991" author="shaie" created="Thu, 15 Mar 2012 14:07:32 +0000" />
                    <attachment id="12518455" name="LUCENE-3867.patch" size="10279" author="shaie" created="Thu, 15 Mar 2012 12:56:35 +0000" />
                    <attachment id="12518439" name="LUCENE-3867.patch" size="7032" author="thetaphi" created="Thu, 15 Mar 2012 09:40:47 +0000" />
                    <attachment id="12518337" name="LUCENE-3867.patch" size="7020" author="thetaphi" created="Wed, 14 Mar 2012 16:53:17 +0000" />
                    <attachment id="12518317" name="LUCENE-3867.patch" size="6284" author="shaie" created="Wed, 14 Mar 2012 13:27:11 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>21.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 14 Mar 2012 07:42:03 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231518</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23834</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>