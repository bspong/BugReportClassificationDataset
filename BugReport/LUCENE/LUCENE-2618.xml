<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:25:16 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2618/LUCENE-2618.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2618] Intermittent failure in TestThreadedOptimize</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2618</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Failure looks like this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    [junit] Testsuite: org.apache.lucene.index.TestThreadedOptimize
    [junit] Testcase: testThreadedOptimize(org.apache.lucene.index.TestThreadedOptimize):	FAILED
    [junit] null
    [junit] junit.framework.AssertionFailedError: null
    [junit] 	at org.apache.lucene.index.TestThreadedOptimize.runTest(TestThreadedOptimize.java:125)
    [junit] 	at org.apache.lucene.index.TestThreadedOptimize.testThreadedOptimize(TestThreadedOptimize.java:149)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.runBare(LuceneTestCase.java:253)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I just committed some verbosity so next time it strikes we&apos;ll have more details.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12472362">LUCENE-2618</key>
            <summary>Intermittent failure in TestThreadedOptimize</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 24 Aug 2010 13:31:22 +0100</created>
                <updated>Wed, 1 Dec 2010 14:49:58 +0000</updated>
                    <resolved>Mon, 15 Nov 2010 10:58:33 +0000</resolved>
                                            <fixVersion>2.9.4</fixVersion>
                <fixVersion>3.0.3</fixVersion>
                <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12902018" author="shaie" created="Tue, 24 Aug 2010 20:03:10 +0100"  >&lt;p&gt;I&apos;m guessing that this line fails (which is 126 in my most recent checkout):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      assertTrue(reader.isOptimized());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is this the one that&apos;s pointed by your code Mike? If so, I suggest we include a message to the assertion, something like &quot;index should be optimized&quot;. It&apos;s annoying that JUnit does not print &quot;should be true but was false&quot;, or something like that, and instead prints &apos;null&apos;, which is more intimidating &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;Perhaps we should also add some more info to the print, like the number of segments in and index and whether there are deletions, so we&apos;d have a better clue why the test failed?&lt;/p&gt;

&lt;p&gt;I&apos;ve tried to run the test a couple of times, but it passed ...&lt;/p&gt;</comment>
                    <comment id="12902023" author="shaie" created="Tue, 24 Aug 2010 20:11:30 +0100"  >&lt;p&gt;Sorry, I&apos;ve missed the part about this happening in backwards tests. The line numbers match for me, and I see the assertion messages. I do think though that additional info such as the number of segments and deleted docs would be useful, since reader.isOptimize() will return false if either of these two is wrong.&lt;/p&gt;

&lt;p&gt;And we can add the same message to the regular test as well ...&lt;/p&gt;</comment>
                    <comment id="12902550" author="markrmiller@gmail.com" created="Wed, 25 Aug 2010 19:13:16 +0100"  >&lt;p&gt;I&apos;m catching something similar on current tests I think:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   [junit] Testsuite: org.apache.lucene.index.TestThreadedOptimize
    [junit] Testcase: testThreadedOptimize(org.apache.lucene.index.TestThreadedOptimize):	FAILED
    [junit] expected:&amp;lt;248&amp;gt; but was:&amp;lt;256&amp;gt;
    [junit] junit.framework.AssertionFailedError: expected:&amp;lt;248&amp;gt; but was:&amp;lt;256&amp;gt;
    [junit] 	at org.apache.lucene.index.TestThreadedOptimize.runTest(TestThreadedOptimize.java:119)
    [junit] 	at org.apache.lucene.index.TestThreadedOptimize.testThreadedOptimize(TestThreadedOptimize.java:142)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.runBare(LuceneTestCase.java:380)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.run(LuceneTestCase.java:372)
    [junit] 
    [junit] 
    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.733 sec
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12923389" author="mikemccand" created="Thu, 21 Oct 2010 11:28:45 +0100"  >&lt;p&gt;I think I found this!&lt;/p&gt;

&lt;p&gt;After a merge completes, IW then checks w/ the merge policy to see if followon merges are now necessary.&lt;/p&gt;

&lt;p&gt;But this check is skipped if IW.close is pending (ie has been called and is waiting for merges to complete).&lt;/p&gt;

&lt;p&gt;However, if that merge is an optimize, then we should in fact consult the merge policy even when a close is pending, which we are not doing today.&lt;/p&gt;

&lt;p&gt;Tiny patch (attached) should fix it.&lt;/p&gt;</comment>
                    <comment id="12923395" author="shaie" created="Thu, 21 Oct 2010 11:50:10 +0100"  >&lt;p&gt;For education purposes - why should we consult the MP if it&apos;s an optimize, even while closing? If close(false) is called after optimize() was called, it means the app would like to abort merges ASAP. If so, why would we consult the MP if we&apos;re instructed to abort?&lt;/p&gt;

&lt;p&gt;Are you talking about a different use case?&lt;/p&gt;</comment>
                    <comment id="12923426" author="mikemccand" created="Thu, 21 Oct 2010 13:52:04 +0100"  >&lt;blockquote&gt;
&lt;p&gt;If close(false) is called after optimize() was called, it means the app would like to abort merges ASAP. If so, why would we consult the MP if we&apos;re instructed to abort?&lt;/p&gt;

&lt;p&gt;Are you talking about a different use case?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, different use case.&lt;/p&gt;

&lt;p&gt;This use case is you call .optimize(doWait=false) then you call a normal .close() (ie, wait for merges).  In this case we wait for all running merges to finish, but don&apos;t start any new ones.  My patch would still allow new ones to start if the merges are due to a running optimize.&lt;/p&gt;

&lt;p&gt;Your use case, where .close(false) is called, will in fact abort all running merges and close quickly.  Ie we will not start new merges, even for optimize, if you pass false to close, with this pattch.&lt;/p&gt;</comment>
                    <comment id="12923428" author="rcmuir" created="Thu, 21 Oct 2010 13:56:11 +0100"  >&lt;p&gt;thanks for tracking this down...! &lt;/p&gt;

&lt;p&gt;I think if we fix this one, then we are really into the long tail of random test fails (at least for now)&lt;/p&gt;</comment>
                    <comment id="12923430" author="shaie" created="Thu, 21 Oct 2010 14:04:53 +0100"  >&lt;p&gt;Ok Mike, that makes sense. You want to allow optimize() to finish all possible merges. Why then not let regular merges finish all the way through, even if we&apos;re closing? I mean, the application wants to wait for all running merges, so why is optimize() different than maybeMerge()?&lt;/p&gt;</comment>
                    <comment id="12923564" author="mikemccand" created="Thu, 21 Oct 2010 19:40:46 +0100"  >&lt;p&gt;We do allow all running merges to run to completion.&lt;/p&gt;

&lt;p&gt;But, we don&apos;t allow new merges to start, unless it&apos;s part of an ongoing optimize (as of this patch).&lt;/p&gt;

&lt;p&gt;I think this distinction makes sense?  Since optimize was an explicit call, it should run until completion.  But merging can simply pick up the next time the index is opened?&lt;/p&gt;

&lt;p&gt;If an app really wants to allow all merges to run before closing (even new ones starting) it can call waitForMerges and then close.&lt;/p&gt;</comment>
                    <comment id="12923579" author="shaie" created="Thu, 21 Oct 2010 20:19:46 +0100"  >&lt;p&gt;I don&apos;t personally mind either way. Just want to point out that calling maybeMerge is as explicit as calling optimize. You can argue for both that if an app wants to wait for merges it can call waitForMerges. In fact, an app calling close() already stated it wants to wait for merges - it&apos;s as if it called waitForMerges followed by close.&lt;/p&gt;

&lt;p&gt;I think you&apos;re trying to distinguish merges that started because the MP decided they should run following a certain commit to those triggered by explicit call to optimize. So IMO maybeMerge and optimize are the same as both were explicitly initiated by the application.&lt;/p&gt;

&lt;p&gt;This test fails because it assumes optimize will run to completion. What if the test assumed maybeMerge runs to completion? Isn&apos;t that a valid expectation from an application calling close()? We&apos;re also distinguishing the first round of merges from subsequent rounds, only when maybeMerge is called, but not optimize...&lt;/p&gt;</comment>
                    <comment id="12923665" author="mikemccand" created="Thu, 21 Oct 2010 23:14:31 +0100"  >&lt;blockquote&gt;&lt;p&gt;Just want to point out that calling maybeMerge is as explicit as calling optimize.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But: apps don&apos;t normally call maybeMerge?  This is typically called within IW, eg on segment flush.&lt;/p&gt;

&lt;p&gt;I mean, it is public so apps can call it, but I expect very few do (vs optimize which apps use alot).  It&apos;s the exception not the rule...&lt;/p&gt;

&lt;p&gt;I guess I feel that close should try to close quickly &amp;#8211; an app would not expect close to randomly take a long time (it&apos;s already bad enough since a large merge could be in process...).   So, allowing other merges to start up, which could easily be large merges since they are follow-on ones, would make that worse.&lt;/p&gt;

&lt;p&gt;Alternatively, we could define the semantics of close as being allowed to prevent a running optimize from actually completing?  Then we&apos;d have to change this test, eg to call .waitForMerges before close.&lt;/p&gt;</comment>
                    <comment id="12923761" author="shaie" created="Fri, 22 Oct 2010 06:38:29 +0100"  >&lt;p&gt;Ok - I agree maybeMerge is probably less frequently called than optimize. And perhaps we can look at it that way: when you call optimize, you know exactly what to expect. You control the # of final segments. When you call maybeMerge lucene does not guarantee the final result. Unless you know exactly the state of all the segments in the index (which except than from unit tests I think it&apos;s very unlikely) and exactly what your MP is doing, you cannot expect any guaranteed outcome from calling maybeMerge, except for it &quot;doing the best effort&quot;.&lt;/p&gt;

&lt;p&gt;What bothered me is that even if maybeMerge and optimize may go through several levels of merging following one call to them, one is guaranteed to complete and the other isn&apos;t. But since optimize is more common in apps than the other, I&apos;m willing to make that exception. Perhaps then add to maybeMerge docs that if you want to guarantee merges finish when close is called, you should wait for merges? Or should we add it to close?&lt;/p&gt;

&lt;p&gt;I&apos;m fine now with this fix. +1 to commit.&lt;/p&gt;</comment>
                    <comment id="12923866" author="mikemccand" created="Fri, 22 Oct 2010 15:13:01 +0100"  >&lt;p&gt;OK thanks Shai... I&apos;ll commit shortly.&lt;/p&gt;</comment>
                    <comment id="12923909" author="thetaphi" created="Fri, 22 Oct 2010 17:55:29 +0100"  >&lt;p&gt;This commit sometimes fails TestBackwards because IndexWriter.close() now also throws IndexFormatTooOldException if the previous call to optimize() have thrown it already.&lt;/p&gt;</comment>
                    <comment id="12923946" author="mikemccand" created="Fri, 22 Oct 2010 18:55:46 +0100"  >&lt;p&gt;Hmm.... indeed you can repro with:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ant test-core -Dtestcase=TestBackwardsCompatibility -Dtestmethod=testUnsupportedOldIndexes -Dtests.seed=-7202471693621265890:9015568443891620555&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;ll revert until I can figure this out... sorry!&lt;/p&gt;</comment>
                    <comment id="12923987" author="mikemccand" created="Fri, 22 Oct 2010 20:36:43 +0100"  >&lt;p&gt;OK so I think we should fix this test to also accept an IndexTooOldExc during close.&lt;/p&gt;

&lt;p&gt;The .optimize() call for only the 29.nocfs case (for some reason) enrolls 2 pending merges to IW.&lt;/p&gt;

&lt;p&gt;The 1st merge hits an exception, throwing up through the .optimize() to the test.  But the 2nd merge remains queued, and in IW.close() we give MS a chance to run any merges it needs to, and that 2nd merge then also hits an exc.&lt;/p&gt;</comment>
                    <comment id="12923989" author="shaie" created="Fri, 22 Oct 2010 20:44:11 +0100"  >&lt;p&gt;Does this mean I&apos;ll need to catch that exception every time I close an IW, or at least prepare to catch it? If so, shouldn&apos;t we document it? Is it only relevant to the test?&lt;/p&gt;

&lt;p&gt;Somehow this change / fix starts to get complicated. Can IW swallow those exceptions internally, and relieve the application from all this? When I close(false), I should be prepared to hit MergeAbortedException, it&apos;s kinda part of the API contract. But when I close(true), why do I need to be prepared to handle any exception, except for real IO ones?&lt;/p&gt;</comment>
                    <comment id="12923995" author="mikemccand" created="Fri, 22 Oct 2010 20:57:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;Does this mean I&apos;ll need to catch that exception every time I close an IW, or at least prepare to catch it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, IndexFormatTooOldExc subclasses IOE... but, yes, if there&apos;s a risk you&apos;ll open a too-old index, you should try to handle this.&lt;/p&gt;

&lt;p&gt;IW.close does alot... flush the last segment, let MS run any pending merges, do commit, delete now-not-need files, etc.  So there&apos;s plenty of chances for interested excs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is it only relevant to the test?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, this test opens an IW on a too-old index... so if your app may do that....&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can IW swallow those exceptions internally, and relieve the application from all this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa no way!&lt;/p&gt;</comment>
                    <comment id="12924002" author="shaie" created="Fri, 22 Oct 2010 21:11:22 +0100"  >&lt;p&gt;I see. It&apos;s just that you describe this exception as being thrown because close is called while optimize was running over an old index - but I don&apos;t understand why it has to be thrown in this case - namely, what&apos;s the connection between optimize + close and an old index? If my app knowingly opened a too old index, would it get this exception always, if it will call optimize followed by close? Or is it a special scenario hit by the test?&lt;/p&gt;</comment>
                    <comment id="12924006" author="mikemccand" created="Fri, 22 Oct 2010 21:21:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;If my app knowingly opened a too old index, would it get this exception always, if it will call optimize followed by close? Or is it a special scenario hit by the test?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not always.  It&apos;s only if the MP registered more than 1 merge for the optimize, and, you&apos;re using SMS.&lt;/p&gt;

&lt;p&gt;But, really if your app has risk of opening a too-old index, it should be prepared for this exc...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;namely, what&apos;s the connection between optimize + close and an old index?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;MP enrolled 2 merges for the optimize... the first one hits exc... then test calls close... and close lets MS run... and MS is SMS... and it runs the 2nd merge, which this the exc.&lt;/p&gt;</comment>
                    <comment id="12924008" author="mikemccand" created="Fri, 22 Oct 2010 21:22:08 +0100"  >&lt;p&gt;I think there&apos;s a separate issue open (Uwe?) to have IW immediately throw this exc on open, instead of during optimize/close.&lt;/p&gt;</comment>
                    <comment id="12924150" author="shaie" created="Sat, 23 Oct 2010 09:12:25 +0100"  >&lt;p&gt;OK Mike .I understood the sequence of operations that led to this exception before. What didn&apos;t add up is why is it thrown during optimize, and not say up front when IW is opened, or when the Directory was added through addIndexes.&lt;/p&gt;

&lt;p&gt;We should fix the code to throw the exception immediately. Is there a way to check a Directory if it&apos;s old or not? If not, such exception could really throw you off your chair, when you hit it at a point in time not remotely related to when it was added to the index.&lt;/p&gt;

&lt;p&gt;I don&apos;t mind if you continue w/ the fix to the test as you did, but IMO it just hides the real problem. I.e., allowing all merges caused by optimize() to finish is a correct fix. But catching that exception upon IW.close() is a bad one IMO - people who read the code learn how to use Lucene, and catching that exception on close() makes absolutely no sense, at least to me. Could you plz add a TODO there to get rid of that code when we fix IW to detect old indexes up front? That way, if someone reads the code, he&apos;ll at least understand that this is a temporary solution.&lt;/p&gt;</comment>
                    <comment id="12924163" author="mikemccand" created="Sat, 23 Oct 2010 10:59:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;We should fix the code to throw the exception immediately. Is there a way to check a Directory if it&apos;s old or not?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree &amp;#8211; IW.open should fail immediately if any of the segments are too old.&lt;/p&gt;

&lt;p&gt;Unfortunately, I don&apos;t see a simple way to do this.  We can&apos;t just look at the version of the segments_N file, for example, because one segment could be from 2.9, and &lt;span class=&quot;error&quot;&gt;&amp;#91;say&amp;#93;&lt;/span&gt; 3.1 had last opened the index and written the 3.x file format for segments_N.  See, IW does not go and open all SegmentReaders on open.  It&apos;s only on merge, applying deletes, or opening an NRT reader, that we go and open segments for reading.&lt;/p&gt;

&lt;p&gt;I think to do this correctly we should modify segments_N format to record the oldest segment in the index?  Then IW can check this easily on open.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t mind if you continue w/ the fix to the test as you did, but IMO it just hides the real problem. I.e., allowing all merges caused by optimize() to finish is a correct fix. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.&lt;/p&gt;

&lt;p&gt;There is already a pre-existing TODO in the test stating that we should fix IW to throw this exc on open.  I&apos;ll also add a TODO to IW&apos;s ctor and go open an issue...&lt;/p&gt;</comment>
                    <comment id="12924164" author="mikemccand" created="Sat, 23 Oct 2010 11:03:50 +0100"  >&lt;p&gt;OK I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2720&quot; title=&quot;IndexWriter should throw IndexFormatTooOldExc on open, not later during optimize/getReader/close&quot;&gt;&lt;del&gt;LUCENE-2720&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12924167" author="shaie" created="Sat, 23 Oct 2010 11:41:41 +0100"  >&lt;p&gt;Thanks Mike.&lt;/p&gt;</comment>
                    <comment id="12924298" author="mikemccand" created="Sun, 24 Oct 2010 10:00:02 +0100"  >&lt;p&gt;Ugh &amp;#8211; last night&apos;s 3.x build just failed again!  So this was not the &lt;span class=&quot;error&quot;&gt;&amp;#91;only&amp;#93;&lt;/span&gt; cause.  Hmm.  I&apos;ll leave this reopened....&lt;/p&gt;</comment>
                    <comment id="12931940" author="mikemccand" created="Mon, 15 Nov 2010 00:38:28 +0000"  >&lt;p&gt;Patch.&lt;/p&gt;

&lt;p&gt;I think I found this &amp;#8211; it&apos;s a thread safety issue, that happens when a &quot;normal&quot; merge is kicking off at the same time that another thread calls optimize.&lt;/p&gt;

&lt;p&gt;In this case it&apos;s possible that merge fails to mark itself as an optimizing merge, which means any merges that cascade from it will also fail to be optimized.&lt;/p&gt;

&lt;p&gt;I also modified MockDirWrapper to randomly call Thread.yield to see if we can tease out any more thread bugs.&lt;/p&gt;</comment>
                    <comment id="12932104" author="jasonrutherglen" created="Mon, 15 Nov 2010 16:09:53 +0000"  >&lt;p&gt;Are we going to fix this in trunk as well?&lt;/p&gt;</comment>
                    <comment id="12932105" author="mikemccand" created="Mon, 15 Nov 2010 16:13:53 +0000"  >&lt;p&gt;Jason, I did commit to trunk (I edited issue summary to remove &quot;3.x backward&quot; since the issue happened everywhere.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12459574" name="LUCENE-2618.patch" size="67315" author="mikemccand" created="Mon, 15 Nov 2010 00:38:28 +0000" />
                    <attachment id="12457864" name="LUCENE-2618.patch" size="1590" author="mikemccand" created="Fri, 22 Oct 2010 20:37:14 +0100" />
                    <attachment id="12457739" name="LUCENE-2618.patch" size="797" author="mikemccand" created="Thu, 21 Oct 2010 11:28:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 24 Aug 2010 19:03:10 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11218</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25074</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>