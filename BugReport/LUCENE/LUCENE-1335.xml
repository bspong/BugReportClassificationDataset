<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:28:04 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1335/LUCENE-1335.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1335] Correctly handle concurrent calls to addIndexes, optimize, commit</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1335</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Spinoff from here:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200807.mbox/%3Cc7b302c50807111018j58b6d08djd56b5889f6b3780d@mail.gmail.com%3E&quot; class=&quot;external-link&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200807.mbox/%3Cc7b302c50807111018j58b6d08djd56b5889f6b3780d@mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12400145">LUCENE-1335</key>
            <summary>Correctly handle concurrent calls to addIndexes, optimize, commit</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Sat, 12 Jul 2008 00:44:13 +0100</created>
                <updated>Sat, 11 Oct 2008 13:49:41 +0100</updated>
                    <resolved>Sat, 30 Aug 2008 18:16:50 +0100</resolved>
                            <version>2.3</version>
                <version>2.3.1</version>
                                <fixVersion>2.4</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12619834" author="mikemccand" created="Tue, 5 Aug 2008 11:08:40 +0100"  >
&lt;p&gt;Attached patch.  Here&apos;re the changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Only one addIndexes can run at once, so call to 2nd or more&lt;br/&gt;
    addIndexes just blocks until the one is done.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;close() and rollback() wait for any running addIndexes to finish&lt;br/&gt;
    and then blocks new addIndexes calls&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;commit() waits for any running addIndexes, or any already running&lt;br/&gt;
    commit, to finish, then quickly takes a snapshot of the segments&lt;br/&gt;
    and syncs the files referenced by that snapshot.  While syncing is&lt;br/&gt;
    happening addIndexes are then allowed to run again.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;optimize() is allowed to run concurrently with addIndexes; the two&lt;br/&gt;
    simply wait for their respective merges to finish.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think we should not make any API promises about what it means when&lt;br/&gt;
these methods (commit, close, rollback, optimize, addIndexes) are&lt;br/&gt;
called concurrently from different threads, except that the methods&lt;br/&gt;
all work correctly, IndexWriter won&apos;t throw an errant exception, and&lt;br/&gt;
your index won&apos;t become corrupt.&lt;/p&gt;

&lt;p&gt;I made one additional change which is technically a break in backwards&lt;br/&gt;
compatibility, but I think &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; a minor acceptable one: I no longer&lt;br/&gt;
allow the same Directory to be passed into addIndexes* more than once.&lt;br/&gt;
This was necessary because we identify a SegmentInfo by its&lt;br/&gt;
Directory/name pair, and passing in the same Directory allowed dup&lt;br/&gt;
SegmentInfo instances to enter SegmentInfos, which is dangerous.&lt;/p&gt;

&lt;p&gt;I&apos;ll wait a few days before committing.&lt;/p&gt;</comment>
                    <comment id="12619890" author="yseeley@gmail.com" created="Tue, 5 Aug 2008 15:14:28 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should not make any API promises about what it means when&lt;br/&gt;
these methods (commit, close, rollback, optimize, addIndexes) are&lt;br/&gt;
called concurrently from different threads, except that the methods&lt;br/&gt;
all work correctly, IndexWriter won&apos;t throw an errant exception, and&lt;br/&gt;
your index won&apos;t become corrupt.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree... higher level synchronization by the user is the right way to ensure/enforce an ordering.&lt;/p&gt;</comment>
                    <comment id="12620713" author="yseeley@gmail.com" created="Thu, 7 Aug 2008 19:41:43 +0100"  >&lt;p&gt;I&apos;ve just started reviewing this patch.&lt;br/&gt;
Since doWait() can return after 1 sec, the pattern is to use a while loop with the condition that caused it to be called.&lt;br/&gt;
But in some cases, it&apos;s hard to tell if the code is correct.... for example copyExternalSegments() is hard because of the other non-trival code code in the loop where  it&apos;s not clear if it&apos;s safe/correct to call that code again.  Perhaps registerMerge() detects the conflict with another merge with the same segments and that&apos;s what keeps things correct?  Comments to the effect of why it&apos;s OK to run certain code more than once would be very welcome.&lt;/p&gt;</comment>
                    <comment id="12620723" author="mikemccand" created="Thu, 7 Aug 2008 20:28:34 +0100"  >&lt;p&gt;Thanks, Yonik.  I&apos;ll add a comment there, and any other places where I call doWait that look similarly confusing...&lt;/p&gt;</comment>
                    <comment id="12620727" author="mikemccand" created="Thu, 7 Aug 2008 20:44:26 +0100"  >&lt;p&gt;Improved comments in expungeDeletes &amp;amp; copyExternalSegments.&lt;/p&gt;</comment>
                    <comment id="12621774" author="mikemccand" created="Tue, 12 Aug 2008 12:14:23 +0100"  >&lt;p&gt;Yonik, any more feedback on this patch?&lt;/p&gt;</comment>
                    <comment id="12623775" author="mikemccand" created="Tue, 19 Aug 2008 21:02:02 +0100"  >&lt;p&gt;I plan to commit this in a day or two.&lt;/p&gt;</comment>
                    <comment id="12624851" author="ningli" created="Fri, 22 Aug 2008 15:40:36 +0100"  >&lt;p&gt;Hi Mike, could you update the patch? I cannot apply it. Thanks!&lt;/p&gt;</comment>
                    <comment id="12624867" author="mikemccand" created="Fri, 22 Aug 2008 16:23:49 +0100"  >&lt;p&gt;OK, attached refreshed patch to trunk.&lt;/p&gt;</comment>
                    <comment id="12624998" author="ningli" created="Sat, 23 Aug 2008 00:15:25 +0100"  >&lt;p&gt;I agree that we should not make any API promises about what&lt;br/&gt;
it means when the methods (commit, close, rollback, optimize,&lt;br/&gt;
addIndexes) are called concurrently from different threads.&lt;br/&gt;
The discussion below is on their current behavior.&lt;/p&gt;

&lt;p&gt;&amp;gt; Only one addIndexes can run at once, so call to 2nd or more&lt;br/&gt;
&amp;gt; addIndexes just blocks until the one is done.&lt;/p&gt;

&lt;p&gt;This is achieved by the read-write lock.&lt;/p&gt;

&lt;p&gt;&amp;gt; close() and rollback() wait for any running addIndexes to finish&lt;br/&gt;
&amp;gt; and then blocks new addIndexes calls&lt;/p&gt;

&lt;p&gt;Just to clarify: close(waitForMerges=false) and rollback() make&lt;br/&gt;
an ongoing addIndexes&lt;span class=&quot;error&quot;&gt;&amp;#91;NoOptimize&amp;#93;&lt;/span&gt;(dirs) abort, but wait for&lt;br/&gt;
addIndexes(readers) to finish. It&apos;d be nice if they make any&lt;br/&gt;
addIndexes* abort for a quick shutdown, but that&apos;s for later.&lt;/p&gt;

&lt;p&gt;&amp;gt; commit() waits for any running addIndexes, or any already running&lt;br/&gt;
&amp;gt; commit, to finish, then quickly takes a snapshot of the segments&lt;br/&gt;
&amp;gt; and syncs the files referenced by that snapshot. While syncing is&lt;br/&gt;
&amp;gt; happening addIndexes are then allowed to run again.&lt;/p&gt;

&lt;p&gt;commit() and commit(long) use the read-write lock to wait for&lt;br/&gt;
a running addIndexes. &quot;committing&quot; is used to serialize commit()&lt;br/&gt;
calls. Why isn&apos;t it also used to serialize commit(long) calls?&lt;/p&gt;

&lt;p&gt;&amp;gt; optimize() is allowed to run concurrently with addIndexes; the two&lt;br/&gt;
&amp;gt; simply wait for their respective merges to finish.&lt;/p&gt;

&lt;p&gt;This is nice.&lt;/p&gt;

&lt;p&gt;More detailed comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In finishMerges, acquireRead and releaseRead are both called.&lt;br/&gt;
  Isn&apos;t addIndexes allowed again?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In copyExternalSegments, merges involving external segments&lt;br/&gt;
  are carried out in foreground. So why the changes? To relax&lt;br/&gt;
  that assumption? But other part still makes the assumption.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;addIndexes(readers) should optimize before startTransaction, no?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The newly added method segString(dir) in SegmentInfos is&lt;br/&gt;
  not used anywhere.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12625048" author="mikemccand" created="Sat, 23 Aug 2008 13:47:11 +0100"  >
&lt;blockquote&gt;
&lt;p&gt;Just to clarify: close(waitForMerges=false) and rollback() make&lt;br/&gt;
an ongoing addIndexes&lt;span class=&quot;error&quot;&gt;&amp;#91;NoOptimize&amp;#93;&lt;/span&gt;(dirs) abort, but wait for&lt;br/&gt;
addIndexes(readers) to finish. It&apos;d be nice if they make any&lt;br/&gt;
addIndexes* abort for a quick shutdown, but that&apos;s for later.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, agreed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;commit() and commit(long) use the read-write lock to wait for&lt;br/&gt;
a running addIndexes. &quot;committing&quot; is used to serialize commit()&lt;br/&gt;
calls. Why isn&apos;t it also used to serialize commit(long) calls?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s because commit() calls prepareCommit(), which throws a&lt;br/&gt;
&quot;prepareCommit was already called&quot; exception if the commit was already&lt;br/&gt;
prepared.  Whereas commit(long) doesn&apos;t call prepareCommit (eg, it&lt;br/&gt;
doesn&apos;t need to flush).  Without this, I was hitting exceptions in one&lt;br/&gt;
of the tests that calls commit() from multiple threads at the same&lt;br/&gt;
time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;In finishMerges, acquireRead and releaseRead are both called.&lt;br/&gt;
      Isn&apos;t addIndexes allowed again?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is to make sure any just-started addIndexes cleanly finish or&lt;br/&gt;
abort before we enter the wait loop.  I was seeing cases where the&lt;br/&gt;
wait loop would think no more merges were pending, but in fact an&lt;br/&gt;
addIndexes was just getting underway and was about to start merging.&lt;br/&gt;
It&apos;s OK if a new addIndexes call starts up, because it&apos;ll be forced to&lt;br/&gt;
check the stop conditions (closing=true or stopMerges=true) and then&lt;br/&gt;
abort the merges.  I&apos;ll add comments to this effect.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;In copyExternalSegments, merges involving external segments&lt;br/&gt;
      are carried out in foreground. So why the changes? To relax&lt;br/&gt;
      that assumption? But other part still makes the assumption.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;This method has always carried out merges in the FG, but it&apos;s in fact&lt;br/&gt;
possible that a BG merge thread on finishing a previous merge may pull&lt;br/&gt;
a merge involving external segments.  So I changed this method to wait&lt;br/&gt;
for all such BG merges to complete, because it&apos;s not allowed to return&lt;br/&gt;
until there are no more external segments in the index.&lt;/p&gt;

&lt;p&gt;It is tempting to fully schedule these external merges (ie allow them&lt;br/&gt;
to run in BG), but there is a problem: if there is some error on doing&lt;br/&gt;
the merge, we need that error to be thrown in the FG thread calling&lt;br/&gt;
copyExternalSegments (so the transcaction above unwinds).  (Ie we&lt;br/&gt;
can&apos;t just stuff these external merges into the merge queue then wait&lt;br/&gt;
for their completely).  So I think we need to leave is as is?&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;addIndexes(readers) should optimize before startTransaction, no?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;I had to move the optimize() inside the transaction because it could&lt;br/&gt;
happen that after the optimize() is finished, some other thread sneaks&lt;br/&gt;
in a call to addIndexes* and gets additional segments added to the&lt;br/&gt;
index such that by the time we start the transaction we now have more&lt;br/&gt;
than one segment.&lt;/p&gt;

&lt;p&gt;But this change will tie up more disk space than addIndexes used to&lt;br/&gt;
(since it will also rollback the optimize on hitting an exception).&lt;br/&gt;
Really I just need to pre-acquire the write lock, then I can leave&lt;br/&gt;
optimize() out of the transaction.  I&apos;ll do that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;The newly added method segString(dir) in SegmentInfos is&lt;br/&gt;
      not used anywhere.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yeah I was using this for internal debugging, and I think it&apos;s&lt;br/&gt;
generally useful for future debugging, so I left it in.&lt;/p&gt;</comment>
                    <comment id="12625052" author="mikemccand" created="Sat, 23 Aug 2008 14:00:25 +0100"  >&lt;p&gt;New patch incorporating Ning&apos;s comments (thanks Ning!).&lt;/p&gt;</comment>
                    <comment id="12625078" author="ningli" created="Sat, 23 Aug 2008 16:49:58 +0100"  >&lt;p&gt;&amp;gt; It&apos;s because commit() calls prepareCommit(), which throws a&lt;br/&gt;
&amp;gt; &quot;prepareCommit was already called&quot; exception if the commit was already&lt;br/&gt;
&amp;gt; prepared.  Whereas commit(long) doesn&apos;t call prepareCommit (eg, it&lt;br/&gt;
&amp;gt; doesn&apos;t need to flush).  Without this, I was hitting exceptions in one&lt;br/&gt;
&amp;gt; of the tests that calls commit() from multiple threads at the same&lt;br/&gt;
&amp;gt; time.&lt;/p&gt;

&lt;p&gt;Is it better to simplify things by serializing all commit()/commit(long) calls?&lt;/p&gt;

&lt;p&gt;&amp;gt; This is to make sure any just-started addIndexes cleanly finish or&lt;br/&gt;
&amp;gt; abort before we enter the wait loop.  I was seeing cases where the&lt;br/&gt;
&amp;gt; wait loop would think no more merges were pending, but in fact an&lt;br/&gt;
&amp;gt; addIndexes was just getting underway and was about to start merging.&lt;br/&gt;
&amp;gt; It&apos;s OK if a new addIndexes call starts up, because it&apos;ll be forced to&lt;br/&gt;
&amp;gt; check the stop conditions (closing=true or stopMerges=true) and then&lt;br/&gt;
&amp;gt; abort the merges.  I&apos;ll add comments to this effect.&lt;/p&gt;

&lt;p&gt;I wonder if we can simplify the logic... Currently in setMergeScheduler,&lt;br/&gt;
merges can start between finishMerges and set the merge scheduler.&lt;br/&gt;
This one can be fixed by making setMergeScheduler synchronized.&lt;/p&gt;

&lt;p&gt;&amp;gt; This method has always carried out merges in the FG, but it&apos;s in fact&lt;br/&gt;
&amp;gt; possible that a BG merge thread on finishing a previous merge may pull&lt;br/&gt;
&amp;gt; a merge involving external segments.  So I changed this method to wait&lt;br/&gt;
&amp;gt; for all such BG merges to complete, because it&apos;s not allowed to return&lt;br/&gt;
&amp;gt; until there are no more external segments in the index.&lt;/p&gt;

&lt;p&gt;Hmm... so merges involving external segments may be in FG or BG?&lt;br/&gt;
So copyExternalSegments not only copies external segments, but also&lt;br/&gt;
waits for BG merges involving external segments to finish. We need&lt;br/&gt;
a better name?&lt;/p&gt;

&lt;p&gt;&amp;gt; It is tempting to fully schedule these external merges (ie allow them&lt;br/&gt;
&amp;gt; to run in BG), but there is a problem: if there is some error on doing&lt;br/&gt;
&amp;gt; the merge, we need that error to be thrown in the FG thread calling&lt;br/&gt;
&amp;gt; copyExternalSegments (so the transcaction above unwinds).  (Ie we&lt;br/&gt;
&amp;gt; can&apos;t just stuff these external merges into the merge queue then wait&lt;br/&gt;
&amp;gt; for their completely).&lt;/p&gt;

&lt;p&gt;Then what about those BG merges involving external segments?&lt;/p&gt;</comment>
                    <comment id="12625079" author="mikemccand" created="Sat, 23 Aug 2008 17:11:39 +0100"  >
&lt;blockquote&gt;

&lt;p&gt;&amp;gt; It&apos;s because commit() calls prepareCommit(), which throws a&lt;br/&gt;
&amp;gt; &quot;prepareCommit was already called&quot; exception if the commit was already&lt;br/&gt;
&amp;gt; prepared. Whereas commit(long) doesn&apos;t call prepareCommit (eg, it&lt;br/&gt;
&amp;gt; doesn&apos;t need to flush). Without this, I was hitting exceptions in one&lt;br/&gt;
&amp;gt; of the tests that calls commit() from multiple threads at the same&lt;br/&gt;
&amp;gt; time.&lt;/p&gt;

&lt;p&gt;Is it better to simplify things by serializing all commit()/commit(long) calls?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think so: with autoCommit=true, the merges calls commit(long)&lt;br/&gt;
after finishing, and I think we want those commit calls to run&lt;br/&gt;
concurrently?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; This is to make sure any just-started addIndexes cleanly finish or&lt;br/&gt;
&amp;gt; abort before we enter the wait loop. I was seeing cases where the&lt;br/&gt;
&amp;gt; wait loop would think no more merges were pending, but in fact an&lt;br/&gt;
&amp;gt; addIndexes was just getting underway and was about to start merging.&lt;br/&gt;
&amp;gt; It&apos;s OK if a new addIndexes call starts up, because it&apos;ll be forced to&lt;br/&gt;
&amp;gt; check the stop conditions (closing=true or stopMerges=true) and then&lt;br/&gt;
&amp;gt; abort the merges. I&apos;ll add comments to this effect.&lt;/p&gt;

&lt;p&gt;I wonder if we can simplify the logic... Currently in setMergeScheduler,&lt;br/&gt;
merges can start between finishMerges and set the merge scheduler.&lt;br/&gt;
This one can be fixed by making setMergeScheduler synchronized.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good catch &amp;#8211; I&apos;ll make setMergeScheduler synchronized.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; This method has always carried out merges in the FG, but it&apos;s in fact&lt;br/&gt;
&amp;gt; possible that a BG merge thread on finishing a previous merge may pull&lt;br/&gt;
&amp;gt; a merge involving external segments. So I changed this method to wait&lt;br/&gt;
&amp;gt; for all such BG merges to complete, because it&apos;s not allowed to return&lt;br/&gt;
&amp;gt; until there are no more external segments in the index.&lt;/p&gt;

&lt;p&gt;Hmm... so merges involving external segments may be in FG or BG?&lt;br/&gt;
So copyExternalSegments not only copies external segments, but also&lt;br/&gt;
waits for BG merges involving external segments to finish. We need&lt;br/&gt;
a better name?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure we can change the name &amp;#8211; do you have one in mind?  Maybe&lt;br/&gt;
&quot;resolveExternalSegments&quot; or &quot;waitForExternalSegments&quot;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; It is tempting to fully schedule these external merges (ie allow them&lt;br/&gt;
&amp;gt; to run in BG), but there is a problem: if there is some error on doing&lt;br/&gt;
&amp;gt; the merge, we need that error to be thrown in the FG thread calling&lt;br/&gt;
&amp;gt; copyExternalSegments (so the transcaction above unwinds). (Ie we&lt;br/&gt;
&amp;gt; can&apos;t just stuff these external merges into the merge queue then wait&lt;br/&gt;
&amp;gt; for their completely).&lt;/p&gt;

&lt;p&gt;Then what about those BG merges involving external segments?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What&apos;ll happen is the BG merge will hit an exception, roll itself&lt;br/&gt;
back, and then the FG thread will pick up the merge and try again.&lt;br/&gt;
Likely it&apos;ll hit the same exception, which is then thrown back to the&lt;br/&gt;
caller.  It may not hit an exception, eg say it was disk full: the BG&lt;br/&gt;
merge was probably trying to merge 10 segments, whereas the FG merge&lt;br/&gt;
is just copying over the 1 segment.  So it may complete successfully&lt;br/&gt;
too.&lt;/p&gt;</comment>
                    <comment id="12625455" author="ningli" created="Mon, 25 Aug 2008 19:36:21 +0100"  >&lt;p&gt;&amp;gt; I don&apos;t think so: with autoCommit=true, the merges calls commit(long)&lt;br/&gt;
&amp;gt; after finishing, and I think we want those commit calls to run&lt;br/&gt;
&amp;gt; concurrently?&lt;/p&gt;

&lt;p&gt;After we disable autoCommit, all commit calls will be serialized, right?&lt;/p&gt;


&lt;p&gt;&amp;gt; What&apos;ll happen is the BG merge will hit an exception, roll itself&lt;br/&gt;
&amp;gt; back, and then the FG thread will pick up the merge and try again.&lt;br/&gt;
&amp;gt; Likely it&apos;ll hit the same exception, which is then thrown back to the&lt;br/&gt;
&amp;gt; caller.  It may not hit an exception, eg say it was disk full: the BG&lt;br/&gt;
&amp;gt; merge was probably trying to merge 10 segments, whereas the FG merge&lt;br/&gt;
&amp;gt; is just copying over the 1 segment.  So it may complete successfully&lt;br/&gt;
&amp;gt; too.&lt;/p&gt;

&lt;p&gt;Back to the issue of running an external merge in BG or FG.&lt;br/&gt;
In ConcurrentMergeScheduler.merge, an external merge is run in FG,&lt;br/&gt;
not in BG. But in ConcurrentMergeScheduler.MergeThread.run,&lt;br/&gt;
whether a merge is external is no longer checked. Why this difference?&lt;/p&gt;</comment>
                    <comment id="12625521" author="mikemccand" created="Mon, 25 Aug 2008 22:30:33 +0100"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I don&apos;t think so: with autoCommit=true, the merges calls commit(long)&lt;br/&gt;
&amp;gt; after finishing, and I think we want those commit calls to run&lt;br/&gt;
&amp;gt; concurrently?&lt;/p&gt;

&lt;p&gt;After we disable autoCommit, all commit calls will be serialized, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Back to the issue of running an external merge in BG or FG.&lt;br/&gt;
In ConcurrentMergeScheduler.merge, an external merge is run in FG,&lt;br/&gt;
not in BG. But in ConcurrentMergeScheduler.MergeThread.run,&lt;br/&gt;
whether a merge is external is no longer checked. Why this difference?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good point!  We no longer need to check for isExternal in CMS&apos;s merge() method &amp;#8211; we can run all merges in the BG.  In fact I think it&apos;s no longer necessary to even compute &amp;amp; record isExternal (this was its only use).  Hmmm, except when I take this out I&apos;m seeing testAddIndexOnDiskFull hang.  I&apos;ll dig.&lt;/p&gt;</comment>
                    <comment id="12625777" author="mikemccand" created="Tue, 26 Aug 2008 17:06:37 +0100"  >&lt;p&gt;OK new patch attached with changes discussed above.&lt;/p&gt;

&lt;p&gt;I did fix CMS to happily perform merges involving external segments&lt;br/&gt;
with its BG threads.  The hang I was seeing before was because as each&lt;br/&gt;
BG thread hit the disk-full exception (in the test), it would abort&lt;br/&gt;
that thread, and eventually no threads were doing merges even though&lt;br/&gt;
merges were still pending.  So copyExternalSegments would then&lt;br/&gt;
wait forever.&lt;/p&gt;

&lt;p&gt;The fix was simple: I changed resolveExternalSegments (renamed from&lt;br/&gt;
copyExternalSegments) to pick up any pending merges that involve&lt;br/&gt;
external segments and run the merge itself, only falling back to the&lt;br/&gt;
&quot;wait&quot; call when all such merges were already in progress in CMS.&lt;br/&gt;
This way the disk full error is hit in the FG and the transaction (in&lt;br/&gt;
addIndexesNoOptimize) unwinds.&lt;/p&gt;</comment>
                    <comment id="12626158" author="ningli" created="Wed, 27 Aug 2008 16:23:24 +0100"  >&lt;p&gt;Maybe this should be a separate JIRA issue. In doWait(), the comment says &quot;as a defense against thread timing hazards where notifyAll() falls to be called, we wait for at most 1 second...&quot; In some cases, it seems that notifyAll() simply isn&apos;t called, such as some of the cases related to runningMerges. Maybe we should take a closer look at and possibly simplify the concurrency control in IndexWriter, especially when autoCommit is disabled?&lt;/p&gt;</comment>
                    <comment id="12626344" author="mikemccand" created="Wed, 27 Aug 2008 23:21:21 +0100"  >&lt;blockquote&gt;&lt;p&gt;Maybe we should take a closer look at and possibly simplify the concurrency control in IndexWriter, especially when autoCommit is disabled?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree &amp;#8211; I&apos;m looking forward to taking autoCommit=true case out in 3.0.  I&apos;ll try to simplify the concurrency control at that point, and test for any deadlocks if doWait is replaced with the &quot;real&quot; wait(), to catch any missing notifyAll()&apos;s.&lt;/p&gt;</comment>
                    <comment id="12626805" author="mikemccand" created="Fri, 29 Aug 2008 01:19:21 +0100"  >&lt;p&gt;Ning (or anyone), any more feedback on this one?  Else I plan to commit soon...&lt;/p&gt;</comment>
                    <comment id="12627222" author="mikemccand" created="Sat, 30 Aug 2008 18:17:04 +0100"  >&lt;p&gt;Committed revision 690537&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12388917" name="LUCENE-1335.patch" size="51298" author="mikemccand" created="Tue, 26 Aug 2008 17:06:37 +0100" />
                    <attachment id="12388793" name="LUCENE-1335.patch" size="47981" author="mikemccand" created="Sat, 23 Aug 2008 14:00:25 +0100" />
                    <attachment id="12388750" name="LUCENE-1335.patch" size="45566" author="mikemccand" created="Fri, 22 Aug 2008 16:23:49 +0100" />
                    <attachment id="12387765" name="LUCENE-1335.patch" size="43308" author="mikemccand" created="Thu, 7 Aug 2008 20:44:26 +0100" />
                    <attachment id="12387553" name="LUCENE-1335.patch" size="42277" author="mikemccand" created="Tue, 5 Aug 2008 11:08:40 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 5 Aug 2008 14:14:28 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12413</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26393</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>