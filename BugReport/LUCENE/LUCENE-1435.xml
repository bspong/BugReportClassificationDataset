<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:57:38 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1435/LUCENE-1435.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1435] CollationKeyFilter: convert tokens into CollationKeys encoded using IndexableBinaryStringTools</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1435</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Converts each token into its CollationKey using the provided collator, and then encodes the CollationKey with IndexableBinaryStringTools, to allow it to be stored as an index term.&lt;/p&gt;

&lt;p&gt;This will allow for efficient range searches and Sorts over fields that need collation for proper ordering.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12407645">LUCENE-1435</key>
            <summary>CollationKeyFilter: convert tokens into CollationKeys encoded using IndexableBinaryStringTools</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="steve_rowe">Steve Rowe</reporter>
                        <labels>
                    </labels>
                <created>Sat, 1 Nov 2008 04:55:23 +0000</created>
                <updated>Thu, 2 May 2013 03:29:17 +0100</updated>
                    <resolved>Thu, 19 Mar 2009 10:52:04 +0000</resolved>
                            <version>2.4</version>
                                <fixVersion>2.9</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12644526" author="hossman" created="Sat, 1 Nov 2008 18:22:44 +0000"  >&lt;p&gt;The one worry i have about an approach like this comes from the fine print of the CollationKey docs...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You can only compare CollationKeys generated from the same Collator object.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&quot;same&quot; tends to have a very specific meaning in Java documentation, .. it&apos;s usually used to indicate refrence equality (ie &quot;==&quot; not .equals) ...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;so the question becomes: did they reall mean &quot;same Collator&quot; or did they mean &quot;a Collator with the same rules&quot; ? &lt;/p&gt;

&lt;p&gt;is it safe to persist a CollationKey from a Collator A and then compare it with a CollationKey from another Collator B where A.equals(B) but A != B (because A and B are from different JVM instances?)&lt;/p&gt;</comment>
                    <comment id="12644541" author="rcmuir" created="Sat, 1 Nov 2008 21:48:43 +0000"  >&lt;p&gt;at least in ICU, its not completely safe.  If the different JVM instances are &quot;different&quot; in version (upgrade, etc) then it would be a shame to find your sorts all busted. &lt;/p&gt;

&lt;p&gt;When comparing keys, it is important to know that both keys were generated by the same algorithms and weightings. Otherwise, identical strings with keys generated on two different dates, for example, might compare as unequal. Sort keys can be affected by new versions of ICU or its data tables, new sort key formats, or changes to the Collator.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html&quot; class=&quot;external-link&quot;&gt;http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12644600" author="steve_rowe" created="Sun, 2 Nov 2008 17:16:43 +0000"  >&lt;p&gt;Three problems I can think of off the top of my head with attempting an automatically managed solution to the problem of CollationKey comparability:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;There doesn&apos;t seem to be any way of ascertaining the RuleBasedCollator version, so one would have to store exact JVM version and Locale used to genenerate the Collator, and the strength used, and then fail any range or sort operations if the indexed CollationKeys were produced with ones different from the current ones.&lt;/li&gt;
	&lt;li&gt;Lucene doesn&apos;t have an index-level per-field place to store arbitrary information.&lt;/li&gt;
	&lt;li&gt;Other implementations of java.text.Collator, besides RuleBasedCollator, are certainly possible.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;So, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can&apos;t use the functionality &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;Would strong warnings in the javadocs be enough to allow people to take appropriate precautions?&lt;/p&gt;</comment>
                    <comment id="12644604" author="rcmuir" created="Sun, 2 Nov 2008 18:32:52 +0000"  >&lt;p&gt;One alternative is that the ICU implementation has versioning specifically for this purpose.&lt;/p&gt;

&lt;p&gt;The version information of Collator is a 32-bit integer. If a new version of ICU has changes affecting the content of collation elements, the version information will be changed. In that case, to use the new version of ICU collator will require regenerating any saved or stored sort keys. However, since ICU 1.8.1. it is possible to build your program so that it uses more than one version of ICU. Therefore, you could use the current version for the features you need and use the older version for collation.&lt;/p&gt;</comment>
                    <comment id="12644773" author="hossman" created="Mon, 3 Nov 2008 18:20:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can&apos;t use the functionality .&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;Would strong warnings in the javadocs be enough to allow people to take appropriate precautions?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree with you on both points ... this is really just an extension of warning people to use compatible analyzers when indexing/querying. &lt;/p&gt;

&lt;p&gt;(I only brought it up in my first comment because i know very little about the internals of &lt;b&gt;any&lt;/b&gt; Collator Implementations out there, and i wasn&apos;t sure if &lt;b&gt;all&lt;/b&gt; Implementations produces keys that were only comparable between &quot;same&quot; instances .. as long as there are &lt;b&gt;some&lt;/b&gt; implementations of Collator that products keys which can be compared between &quot;equivalent&quot; instances, then this feature certainly seems useful.&lt;/p&gt;</comment>
                    <comment id="12644780" author="steve_rowe" created="Mon, 3 Nov 2008 18:59:06 +0000"  >&lt;p&gt;Robert Muir wrote:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One alternative is that the ICU implementation has versioning specifically for this purpose. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll look into using RegexQuery as a model here (it enables use of either java.util.regex or Jakarta Regexp, defaulting to java.util.regex), and try to add CollatorCapable/CollatorCapabilities, so that ICU&apos;s Collator implementation will be usable.&lt;/p&gt;</comment>
                    <comment id="12644782" author="steve_rowe" created="Mon, 3 Nov 2008 19:01:43 +0000"  >&lt;p&gt;Hoss wrote:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can&apos;t use the functionality .&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;Would strong warnings in the javadocs be enough to allow people to take appropriate precautions?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree with you on both points ... this is really just an extension of warning people to use compatible analyzers when indexing/querying. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will add warnings about this issue to the javadocs.&lt;/p&gt;</comment>
                    <comment id="12646470" author="steve_rowe" created="Tue, 11 Nov 2008 05:03:05 +0000"  >&lt;p&gt;Modifications in this patch:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Added dependency on ICU4J 4.0&lt;/li&gt;
	&lt;li&gt;Introduced ICUCollationKeyFilter, which uses ICU collation to produce the collation keys&lt;/li&gt;
	&lt;li&gt;Added Analyzer versions of the Filters, creating IndexableBinaryStringTools-encoded collation keys from the single token produced by KeywordTokenizer.&lt;/li&gt;
	&lt;li&gt;Centralized testing to a base class, which the four test classes extend, to avoid duplication&lt;/li&gt;
	&lt;li&gt;Moved from contrib/analyzers/o/a/l/analysis/miscellaneous/ to a new contrib package: contrib/collation, because it doesn&apos;t make sense to add a dependency to the entire contrib/analyzers package just for ICUCollationKeyFilter/Analyzer&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The external ICU4J dependency, which should be checked into contrib/collation/lib/, can be downloaded here: &lt;a href=&quot;http://download.icu-project.org/files/icu4j/4.0/icu4j-4_0.jar&quot; class=&quot;external-link&quot;&gt;http://download.icu-project.org/files/icu4j/4.0/icu4j-4_0.jar&lt;/a&gt;.  The license for this jar is included in the patch at contrib/collation/lib/ICU-LICENSE.txt.&lt;/p&gt;</comment>
                    <comment id="12646525" author="mikemccand" created="Tue, 11 Nov 2008 10:58:10 +0000"  >&lt;p&gt;Could we, alternatively, push this change into DocumentsWriter, such that on writing a segment it uses a per-field Collator (FieldInfo would be extended to record this) to sort the terms dict?&lt;/p&gt;

&lt;p&gt;I haven&apos;t fully thought through the tradeoffs... but it seems like this&apos;d be simpler to use?  Ie rather than putting a CollationKeyFilter in your analyzer chain, and then doing the reverse of this for all searches at search time, you simply set the Collator on the fields (at indexing &amp;amp; searching time, since I agree we should for now not try to serialize into the index which field has which Collator)?&lt;/p&gt;

&lt;p&gt;I guess there is a performance cost to using the Collator to do live binary search (during searching) and sorting (during indexing) vs doing unicode String comparisions but in practice at search time this is probably a tiny part of the net cost of searching?&lt;/p&gt;</comment>
                    <comment id="12646619" author="steve_rowe" created="Tue, 11 Nov 2008 18:29:15 +0000"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Could we, alternatively, push this change into DocumentsWriter, such that on writing a segment it uses a per-field Collator (FieldInfo would be extended to record this) to sort the terms dict?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are you suggesting to not store collation keys in the index?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I haven&apos;t fully thought through the tradeoffs... but it seems like this&apos;d be simpler to use? Ie rather than putting a CollationKeyFilter in your analyzer chain, and then doing the reverse of this for all searches at search time, you simply set the Collator on the fields (at indexing &amp;amp; searching time, since I agree we should for now not try to serialize into the index which field has which Collator)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The query-time process in this patch is not the reverse - it is exactly the same.  The String-encoded collation keys stored in the index are compared directly with those from query terms.  Neither the String-encoding nor the CollationKey needs to be reversed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I guess there is a performance cost to using the Collator to do live binary search (during searching) and sorting (during indexing) vs doing unicode String comparisions but in practice at search time this is probably a tiny part of the net cost of searching?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the current code base, for range searching on a collated field, every single term has to be collated with the search term.  This patch allows skipTo to function when using collation, potentially providing a significant speedup.&lt;/p&gt;</comment>
                    <comment id="12646667" author="mikemccand" created="Tue, 11 Nov 2008 21:18:25 +0000"  >
&lt;blockquote&gt;&lt;p&gt;Are you suggesting to not store collation keys in the index?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, I&apos;m proposing storing the original Strings, but sorted&lt;br/&gt;
according Collator.compare (for that one field), in the Terms dict.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The query-time process in this patch is not the reverse - it is exactly the same.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK got it.  Where/how would you implement the query time conversion of&lt;br/&gt;
terms?&lt;/p&gt;

&lt;p&gt;And wouldn&apos;t there be times when you also want to reverse the&lt;br/&gt;
encoding?  EG if you enum all terms for presentation (maybe as part of&lt;br/&gt;
faceted search for example)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the current code base, for range searching on a collated field, every single term has to be collated with the search term. This patch allows skipTo to function when using collation, potentially providing a significant speedup.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Both the original proposed approach (external-to-indexing) and this&lt;br/&gt;
internal-to-indexing approach would solve this, right?  Ie, in both&lt;br/&gt;
cases the terms have been sorted according to the Collator, but in the&lt;br/&gt;
internal-to-indexing case it&apos;s the original String term stored in the&lt;br/&gt;
terms dict.&lt;/p&gt;

&lt;p&gt;Here are some pros of internal-to-indexing:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;You don&apos;t have to convert every single term visited during&lt;br/&gt;
    analysis first to a CollationKey then ByteBuffer then encoded&lt;br/&gt;
    binary string.  Indexing throughput should be faster?  (Though,&lt;br/&gt;
    when writing the segment you do need to sort using&lt;br/&gt;
    Collator.compare, which I guess could be slow).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Real terms are stored in the index &amp;#8211; tools like Luke can look at&lt;br/&gt;
    the index and see normal looking terms.  Though... I don&apos;t have a&lt;br/&gt;
    sense of what the encoded term would look like &amp;#8211; maybe it&apos;s not&lt;br/&gt;
    that different from the original in practice?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Querying would just work without term conversion&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And some cons:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It&apos;s obviously a more invasive change to Lucene (and probably&lt;br/&gt;
    should go after the flex-indexing changes).  The&lt;br/&gt;
    external-to-indexing approach is nicely externalized.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Performance &amp;#8211; the binary search of the terms index would be&lt;br/&gt;
    slower using Collator.compare instead of String.compareTo (though&lt;br/&gt;
    I would expect this to be minimal in practice).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m sure there are many pros/cons I&apos;m missing...&lt;/p&gt;</comment>
                    <comment id="12646679" author="steve_rowe" created="Tue, 11 Nov 2008 21:51:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;And wouldn&apos;t there be times when you also want to reverse the encoding? EG if you enum all terms for presentation (maybe as part of faceted search for example)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;AFAIK, CollationKey generation is a one-way operation.  If the original terms are required for presentation, they can be stored, right?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here are some pros of internal-to-indexing:&lt;br/&gt;
      &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Real terms are stored in the index - tools like Luke can look at&lt;br/&gt;
      the index and see normal looking terms. Though... I don&apos;t have a&lt;br/&gt;
      sense of what the encoded term would look like - maybe it&apos;s not&lt;br/&gt;
      that different from the original in practice?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;IndexableBinaryStringTools (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1434&quot; title=&quot;IndexableBinaryStringTools: convert arbitrary byte sequences into Strings that can be used as index terms, and vice versa&quot;&gt;&lt;del&gt;LUCENE-1434&lt;/del&gt;&lt;/a&gt;) implements a base-8000h encoding: the lower 15 bits of each character have 1-7/8 bytes packed into them.  It&apos;s radically different from the original byte array, at least in terms of looking at it with a text viewer like Luke.  And I don&apos;t think CollationKeys themselves are intended for human consumption.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In the current code base, for range searching on a collated field, every single term has to be collated with the search term. This patch allows skipTo to function when using collation, potentially providing a significant speedup.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Both the original proposed approach (external-to-indexing) and this&lt;br/&gt;
internal-to-indexing approach would solve this, right? Ie, in both&lt;br/&gt;
cases the terms have been sorted according to the Collator, but in the&lt;br/&gt;
internal-to-indexing case it&apos;s the original String term stored in the&lt;br/&gt;
terms dict.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perhaps I&apos;m missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(), so regardless of the index term dictionary ordering, skipTo() won&apos;t necessarily stop at the correct location, right?  From TermEnum.java:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; skipTo(Term target) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
     &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!next())
  	        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
     } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (target.compareTo(term()) &amp;gt; 0);
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and here&apos;s o.a.l.index.Term.compareTo(Term):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; compareTo(Term other) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (field == other.field)			  &lt;span class=&quot;code-comment&quot;&gt;// fields are interned
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; text.compareTo(other.text);
    &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; field.compareTo(other.field);
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12646699" author="mikemccand" created="Tue, 11 Nov 2008 22:31:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;IndexableBinaryStringTools (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1434&quot; title=&quot;IndexableBinaryStringTools: convert arbitrary byte sequences into Strings that can be used as index terms, and vice versa&quot;&gt;&lt;del&gt;LUCENE-1434&lt;/del&gt;&lt;/a&gt;) implements a base-8000h encoding: the lower 15 bits of each character have 1-7/8 bytes packed into them. It&apos;s radically different from the original byte array, at least in terms of looking at it with a text viewer like Luke. And I don&apos;t think CollationKeys themselves are intended for human consumption.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh OK.  So having done this term conversion, you can&apos;t really look at / use the resulting terms in the index for human consumption (you&apos;d have to store stuff yourself).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Perhaps I&apos;m missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(),&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But we could just fix that to pay attention to the Collator for that field, if it has one, right?  (Or with flexible indexing I think the impl really should own this method, ie, it should be abstract in TermEnum).&lt;/p&gt;

&lt;p&gt;I think the external approach is fine for starters... I just think long-term it may make sense to have core Lucene respect the Collator, but it really is an invasive change.  We should wait until we make progress on flexible indexing at which point such a change should be far less costly.&lt;/p&gt;</comment>
                    <comment id="12646717" author="steve_rowe" created="Tue, 11 Nov 2008 23:04:50 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Perhaps I&apos;m missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(),&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But we could just fix that to pay attention to the Collator for that field, if it has one, right? (Or with flexible indexing I think the impl really should own this method, ie, it should be abstract in TermEnum).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Um, yes.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think the external approach is fine for starters... I just think long-term it may make sense to have core Lucene respect the Collator, but it really is an invasive change. We should wait until we make progress on flexible indexing at which point such a change should be far less costly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Now that I understand it, I too think the internal-to-indexing approach is cleaner/easier to use/better long-term.  This patch is an attempt to improve on the performance of the range collation facilities introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1279&quot; title=&quot;RangeQuery and RangeFilter should use collation to check for range inclusion&quot;&gt;&lt;del&gt;LUCENE-1279&lt;/del&gt;&lt;/a&gt;.  So I guess the question is whether it&apos;s worth putting in another less-than-optimal workaround.&lt;/p&gt;</comment>
                    <comment id="12649967" author="mikemccand" created="Sat, 22 Nov 2008 19:03:27 +0000"  >&lt;p&gt;Another use-case for allowing per-field custom sorting of Terms would be simpler numeric RangeQuery.  Ie, right now you have to zero-pad numbers to trick Lucene into sorting them numerically (which causes challenges for BigDecimal, being discussed now on java-user).  But if you could have Lucene sort by the number then numeric range queries would be straightforward.&lt;/p&gt;</comment>
                    <comment id="12654655" author="steve_rowe" created="Tue, 9 Dec 2008 00:07:42 +0000"  >&lt;p&gt;Removed accidentally included IndexableBinaryString and its test from the patch (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1434&quot; title=&quot;IndexableBinaryStringTools: convert arbitrary byte sequences into Strings that can be used as index terms, and vice versa&quot;&gt;&lt;del&gt;LUCENE-1434&lt;/del&gt;&lt;/a&gt; for these).&lt;/p&gt;</comment>
                    <comment id="12683155" author="mikemccand" created="Wed, 18 Mar 2009 20:31:06 +0000"  >&lt;p&gt;I think we should commit this to contrib/collation as an &quot;external&quot; way to get faster range filters on fields that require custom Collator; at some future point we can consider allowing a given field to sort its terms in some custom way.&lt;/p&gt;

&lt;p&gt;Marvin: does KS/Lucy give control over sort order of the terms in a field?&lt;/p&gt;</comment>
                    <comment id="12683167" author="mikemccand" created="Wed, 18 Mar 2009 20:57:59 +0000"  >&lt;p&gt;Steven, I&apos;m hitting compilation errors, eg:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [javac] /tango/mike/src/lucene.collation/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java:42: &lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; org.apache.lucene.queryParser.analyzing does not exist
    [javac] &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.lucene.queryParser.analyzing.AnalyzingQueryParser;
    [javac]                                               ^
    [javac] /tango/mike/src/lucene.collation/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java:89: cannot find symbol
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is AnalyzingQueryParser?&lt;/p&gt;</comment>
                    <comment id="12683174" author="steve_rowe" created="Wed, 18 Mar 2009 21:13:13 +0000"  >&lt;p&gt;It&apos;s in contrib/miscellaneous/&lt;/p&gt;

&lt;p&gt;I used AnalyzingQueryParser in the tests to allow CollationKeyFilter to be applied to the terms in the range query - the standard QueryParser doesn&apos;t analyze range terms.&lt;/p&gt;

&lt;p&gt;From:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lucene.apache.org/java/2_4_1/api/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.html&quot; class=&quot;external-link&quot;&gt;http://lucene.apache.org/java/2_4_1/api/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Overrides Lucene&apos;s default QueryParser so that Fuzzy-, Prefix-, Range-, and WildcardQuerys are also passed through the given analyzer, but wild card characters (like *) don&apos;t get removed from the search terms. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a (test-only) cross-contrib dependency.  I&apos;m not sure why I didn&apos;t have trouble with compilation - I haven&apos;t looked at this in months.  I&apos;ll take a look later on tonight.&lt;/p&gt;</comment>
                    <comment id="12683182" author="mikemccand" created="Wed, 18 Mar 2009 21:39:20 +0000"  >&lt;p&gt;OK, thanks for the pointer &amp;#8211; I learn something new every day!&lt;/p&gt;</comment>
                    <comment id="12683342" author="steve_rowe" created="Thu, 19 Mar 2009 06:33:35 +0000"  >&lt;p&gt;New patch that compiles.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure how this ever worked previously - I must somehow have had lucene-misc-X.jar on the classpath or something.&lt;/p&gt;

&lt;p&gt;Anyway, the build.xml in this patch, cribbing from contrib/benchmark/build.xml, first builds contrib/miscellaneous, then adds build/contrib/miscellaneous/classes/java/ to the classpath, so that AnalyzingQueryParser can be linked against.&lt;/p&gt;

&lt;p&gt;Everything now compiles, and all contrib tests pass.&lt;/p&gt;</comment>
                    <comment id="12683388" author="mikemccand" created="Thu, 19 Mar 2009 09:40:16 +0000"  >&lt;p&gt;Super, thanks Steven.  I plan to commit soon.&lt;/p&gt;</comment>
                    <comment id="12683424" author="mikemccand" created="Thu, 19 Mar 2009 10:52:04 +0000"  >&lt;p&gt;Thanks Steven!&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12395210">LUCENE-1279</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12407644">LUCENE-1434</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12402550" name="LUCENE-1435.patch" size="57463" author="steve_rowe" created="Thu, 19 Mar 2009 06:33:35 +0000" />
                    <attachment id="12395607" name="LUCENE-1435.patch" size="56947" author="steve_rowe" created="Tue, 9 Dec 2008 00:07:42 +0000" />
                    <attachment id="12393681" name="LUCENE-1435.patch" size="80584" author="steve_rowe" created="Tue, 11 Nov 2008 05:03:05 +0000" />
                    <attachment id="12393189" name="LUCENE-1435.patch" size="19739" author="steve_rowe" created="Sat, 1 Nov 2008 04:56:52 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 1 Nov 2008 18:22:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12316</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26293</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>