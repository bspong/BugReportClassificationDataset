<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:35:25 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-627/LUCENE-627.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-627] highlighter problems with overlapping tokens</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-627</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The lucene highlighter has problems when tokens that overlap are generated.&lt;/p&gt;

&lt;p&gt;For example, if analysis of iPod generates the tokens &quot;i&quot;, &quot;pod&quot;, &quot;ipod&quot; (with pod and ipod in the same position),&lt;br/&gt;
then the highlighter will output this as iipod, regardless of if any of those tokens are highlighted.&lt;/p&gt;

&lt;p&gt;Discovered via &lt;a href=&quot;http://issues.apache.org/jira/browse/SOLR-24&quot; class=&quot;external-link&quot;&gt;http://issues.apache.org/jira/browse/SOLR-24&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12345948">LUCENE-627</key>
            <summary>highlighter problems with overlapping tokens</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Fri, 14 Jul 2006 01:10:19 +0100</created>
                <updated>Fri, 10 May 2013 11:43:08 +0100</updated>
                    <resolved>Sun, 16 Jul 2006 04:19:47 +0100</resolved>
                            <version>2.1</version>
                                <fixVersion>2.1</fixVersion>
                                <component>core/other</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12420915" author="markh" created="Fri, 14 Jul 2006 03:33:26 +0100"  >&lt;p&gt;Works OK for me - just added this to the Highlighter&apos;s Junit test and all is well.&lt;br/&gt;
Something up with your analyzer?&lt;/p&gt;


&lt;p&gt;	public void testOverlapAnalyzer2() throws Exception&lt;/p&gt;
	{
		HashMap synonyms = new HashMap();
		synonyms.put(&quot;ipod&quot;, &quot;i,pod&quot;);
		Analyzer analyzer = new SynonymAnalyzer(synonyms);
		String srchkey = &quot;ipod&quot;;

		String s = &quot;I want an ipod&quot;;
		QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());
		Query query = parser.parse(srchkey);

		Highlighter highlighter = new Highlighter(new QueryScorer(query));
		TokenStream tokenStream =
			analyzer.tokenStream(null, new StringReader(s));
		// Get 3 best fragments and seperate with a &quot;...&quot;
		String result = highlighter.getBestFragments(tokenStream, s, 3, &quot;...&quot;);
		String expectedResult=&quot;I want an &amp;lt;B&amp;gt;ipod&amp;lt;/B&amp;gt;&quot;;
		assertEquals(expectedResult,result);
	}</comment>
                    <comment id="12420916" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 03:42:57 +0100"  >&lt;p&gt;The start and end offsets also overlap... I wonder if that&apos;s what is different.&lt;/p&gt;

&lt;p&gt;Solr&apos;s analyzer output:&lt;br/&gt;
&lt;a href=&quot;http://localhost:8983/solr/admin/analysis.jsp?name=text&amp;amp;verbose=on&amp;amp;val=iPod&quot; class=&quot;external-link&quot;&gt;http://localhost:8983/solr/admin/analysis.jsp?name=text&amp;amp;verbose=on&amp;amp;val=iPod&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;term position 1, 2&lt;br/&gt;
term text 	i, pod/ipod&lt;br/&gt;
term type    word, word/word&lt;br/&gt;
source start,end (0,1),	(1,4)/(0,4)&lt;/p&gt;

&lt;p&gt;I&apos;ll try and come up with a junit test that demonstrates it.&lt;/p&gt;</comment>
                    <comment id="12420919" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 04:05:29 +0100"  >&lt;p&gt;OK, here we go... the following test fails with&lt;br/&gt;
Expected :ipod &amp;lt;B&amp;gt;foo&amp;lt;/B&amp;gt;&lt;br/&gt;
Actual  :iiPod &amp;lt;B&amp;gt;foo&amp;lt;/B&amp;gt;&lt;/p&gt;


&lt;p&gt;  public void testOverlapAnalyzer2() throws Exception&lt;br/&gt;
  {&lt;/p&gt;

&lt;p&gt;    String s = &quot;iPod foo&quot;;&lt;br/&gt;
    // the token stream for the string above:&lt;br/&gt;
    TokenStream ts = new TokenStream() {&lt;br/&gt;
      Iterator iter;&lt;/p&gt;
      {
        List lst = new ArrayList();
        Token t;
        t = new Token(&quot;i&quot;,0,1);
        lst.add(t);
        t = new Token(&quot;pod&quot;,1,4);
        t.setPositionIncrement(0);
        lst.add(t);
        t = new Token(&quot;ipod&quot;,0,4);
        lst.add(t);
        t = new Token(&quot;foo&quot;,5,8);
        lst.add(t);
        iter = lst.iterator();
      }
&lt;p&gt;      public Token next() throws IOException &lt;/p&gt;
{
        return iter.hasNext() ? (Token)iter.next() : null;
      }
&lt;p&gt;    };&lt;/p&gt;

&lt;p&gt;    String srchkey = &quot;foo&quot;;&lt;/p&gt;

&lt;p&gt;    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());&lt;br/&gt;
    Query query = parser.parse(srchkey);&lt;/p&gt;

&lt;p&gt;    Highlighter highlighter = new Highlighter(new QueryScorer(query));&lt;/p&gt;

&lt;p&gt;// Get 3 best fragments and seperate with a &quot;...&quot;&lt;br/&gt;
    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;);&lt;br/&gt;
    String expectedResult=&quot;ipod &amp;lt;B&amp;gt;foo&amp;lt;/B&amp;gt;&quot;;&lt;br/&gt;
    assertEquals(expectedResult,result);&lt;br/&gt;
  }&lt;/p&gt;</comment>
                    <comment id="12420920" author="markh" created="Fri, 14 Jul 2006 04:22:02 +0100"  >&lt;p&gt;The problem appears to be because the &quot;pod&quot; token advances the start position to 1 while the next token &quot;ipod&quot; takes a step back (to 0)&lt;/p&gt;

&lt;p&gt;I&apos;ve found if you just arrange the tokens to be emitted in start pos order all is fine - see below&lt;/p&gt;


&lt;p&gt;	  public void testOverlapAnalyzer2() throws Exception&lt;br/&gt;
	  {&lt;/p&gt;

&lt;p&gt;	    String s = &quot;iPod foo&quot;;&lt;br/&gt;
	    // the token stream for the string above:&lt;br/&gt;
	    TokenStream ts = new TokenStream() {&lt;br/&gt;
	      Iterator iter;&lt;/p&gt;
	      {
	        List lst = new ArrayList();
	        Token t;
                             //moved this token to start
	        t = new Token(&quot;ipod&quot;,0,4);
	        lst.add(t);
	        t = new Token(&quot;i&quot;,0,1);
	        lst.add(t);
	        t = new Token(&quot;pod&quot;,1,4);
	        t.setPositionIncrement(0);
	        lst.add(t);
	        t = new Token(&quot;foo&quot;,5,8);
	        lst.add(t);
	        iter = lst.iterator();
	      }
&lt;p&gt;	      public Token next() throws IOException &lt;/p&gt;
{
	        return iter.hasNext() ? (Token)iter.next() : null;
	      }
&lt;p&gt;	    };&lt;/p&gt;

&lt;p&gt;	    String srchkey = &quot;foo&quot;;&lt;/p&gt;

&lt;p&gt;	    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());&lt;br/&gt;
	    Query query = parser.parse(srchkey);&lt;/p&gt;

&lt;p&gt;	    Highlighter highlighter = new Highlighter(new QueryScorer(query));&lt;/p&gt;

&lt;p&gt;//	 Get 3 best fragments and seperate with a &quot;...&quot;&lt;br/&gt;
	    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;);&lt;br/&gt;
                         //had to upper case the P in the test here&lt;br/&gt;
	    String expectedResult=&quot;iPod &amp;lt;B&amp;gt;foo&amp;lt;/B&amp;gt;&quot;;&lt;br/&gt;
	    assertEquals(expectedResult,result);&lt;br/&gt;
	  }&lt;/p&gt;</comment>
                    <comment id="12420923" author="markh" created="Fri, 14 Jul 2006 04:26:01 +0100"  >&lt;p&gt;Position increments wrong in my  above code but the solution of sequencing start offsets correctly still holds true:&lt;/p&gt;

&lt;p&gt;	        t = new Token(&quot;ipod&quot;,0,4);&lt;br/&gt;
	        t.setPositionIncrement(0);&lt;br/&gt;
	        lst.add(t);&lt;br/&gt;
	        t = new Token(&quot;i&quot;,0,1);&lt;br/&gt;
	        t.setPositionIncrement(0);&lt;br/&gt;
	        lst.add(t);&lt;br/&gt;
	        t = new Token(&quot;pod&quot;,1,4);&lt;br/&gt;
	        lst.add(t);&lt;br/&gt;
	        t = new Token(&quot;foo&quot;,5,8);&lt;br/&gt;
	        lst.add(t);&lt;/p&gt;</comment>
                    <comment id="12420924" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 04:31:22 +0100"  >&lt;p&gt;The original token stream is a valid one though right?  If so, it seems like the fix should be in the highlighter module.&lt;/p&gt;</comment>
                    <comment id="12420950" author="markh" created="Fri, 14 Jul 2006 06:10:04 +0100"  >&lt;p&gt;&amp;gt;&amp;gt;The original token stream is a valid one though right? &lt;/p&gt;

&lt;p&gt;I don&apos;t think so, see below...&lt;/p&gt;

&lt;p&gt;       List lst = new ArrayList(); &lt;br/&gt;
        Token t; &lt;br/&gt;
        t = new Token(&quot;i&quot;,0,1); &lt;br/&gt;
        lst.add(t); &lt;br/&gt;
        t = new Token(&quot;pod&quot;,1,4); &lt;br/&gt;
        t.setPositionIncrement(0); &lt;br/&gt;
        lst.add(t); &lt;br/&gt;
        t = new Token(&quot;ipod&quot;,0,4); &lt;br/&gt;
!! Missing a t.setPositionIncrement(0) here.&lt;br/&gt;
        lst.add(t); &lt;br/&gt;
        t = new Token(&quot;foo&quot;,5,8); &lt;br/&gt;
        lst.add(t); &lt;br/&gt;
        iter = lst.iterator(); &lt;/p&gt;

&lt;p&gt;Having fixed the above I believe this change below is all that is required to fix the highlighter:&lt;/p&gt;

&lt;p&gt;TokenGroup.java&lt;/p&gt;

&lt;p&gt;	boolean isDistinct(Token token)&lt;/p&gt;
	{
//		return token.startOffset()&amp;gt;=endOffset;
		return token.getPositionIncrement()&amp;gt;0;
	}

&lt;p&gt;All my Junit  tests pass with this change - can you verify this is true for you too?&lt;br/&gt;
This change would break highlighting for any analyzers that had position increments but whose offsets somehow overlapped - text would potentially be duplicated in the same way you originally reported your problem. I can&apos;t verify this to be true for CJK analyzers etc so feel a little uneasy about committing this. &lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12420954" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 06:25:06 +0100"  >&lt;p&gt;&amp;gt;&amp;gt;The original token stream is a valid one though right?&lt;br/&gt;
&amp;gt; I don&apos;t think so, see below...&lt;/p&gt;

&lt;p&gt;Ah, right... I constructed the wrong one first.  I wanted pod and ipod in the same position... so the token stream looks like &quot;i&quot; (&quot;pod&quot;|&quot;ipod&quot;) &quot;foo&quot;.&lt;br/&gt;
Now this token-stream is correct, I believe, but the same problem happens.&lt;/p&gt;

&lt;p&gt;A work-around is to swap the order that &quot;pod&quot; and &quot;ipod&quot; tokens appear, but it seems like any such workaround should be put into the highlighter rather than external to it.&lt;/p&gt;


&lt;p&gt;  public void testOverlapAnalyzer2() throws Exception&lt;br/&gt;
  {&lt;/p&gt;

&lt;p&gt;    String s = &quot;iPod foo&quot;;&lt;br/&gt;
    // the token stream for the string above:&lt;br/&gt;
    TokenStream ts = new TokenStream() {&lt;br/&gt;
      Iterator iter;&lt;/p&gt;
      {
        List lst = new ArrayList();
        Token t;
        t = new Token(&quot;i&quot;,0,1);
        lst.add(t);
        t = new Token(&quot;pod&quot;,1,4);
        lst.add(t);
        t = new Token(&quot;ipod&quot;,0,4);
        t.setPositionIncrement(0);   // pod and ipod occupy the same token position.
        lst.add(t);
        t = new Token(&quot;foo&quot;,5,8);
        lst.add(t);
        iter = lst.iterator();
      }
&lt;p&gt;      public Token next() throws IOException &lt;/p&gt;
{
        return iter.hasNext() ? (Token)iter.next() : null;
      }
&lt;p&gt;    };&lt;/p&gt;

&lt;p&gt;    String srchkey = &quot;foo&quot;;&lt;/p&gt;

&lt;p&gt;    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());&lt;br/&gt;
    Query query = parser.parse(srchkey);&lt;/p&gt;

&lt;p&gt;    Highlighter highlighter = new Highlighter(new QueryScorer(query));&lt;/p&gt;

&lt;p&gt;// Get 3 best fragments and seperate with a &quot;...&quot;&lt;br/&gt;
    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;);&lt;br/&gt;
    String expectedResult=&quot;iPod &amp;lt;B&amp;gt;foo&amp;lt;/B&amp;gt;&quot;;&lt;br/&gt;
    assertEquals(expectedResult,result);&lt;br/&gt;
  }&lt;/p&gt;</comment>
                    <comment id="12420971" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 08:40:51 +0100"  >&lt;p&gt;I just tried the change to isDistinct, and it didn&apos;t work for the corrected tokenstream I posted.&lt;br/&gt;
I agree that it doesn&apos;t seem like the right fix anyway.   It seems like things should be based on startOffset and endOffset.&lt;/p&gt;</comment>
                    <comment id="12420972" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 08:58:17 +0100"  >&lt;p&gt;Here&apos;s another fun one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;junit.framework.ComparisonFailure: &lt;br/&gt;
Expected :zooPod&amp;lt;B&amp;gt;Foo&amp;lt;/B&amp;gt;&lt;br/&gt;
Actual  :zoozooPod&amp;lt;B&amp;gt;zooPodFoo&amp;lt;/B&amp;gt;&lt;/p&gt;


&lt;p&gt;  public void testOverlapAnalyzer3() throws Exception&lt;br/&gt;
  {&lt;/p&gt;

&lt;p&gt;    String s = &quot;zooPodFoo&quot;;&lt;br/&gt;
    // the token stream for the string above:&lt;br/&gt;
    TokenStream ts = new TokenStream() {&lt;br/&gt;
      Iterator iter;&lt;/p&gt;
      {
        List lst = new ArrayList();
        Token t;
        t = new Token(&quot;zoo&quot;,0,3);
        lst.add(t);
        t = new Token(&quot;pod&quot;,3,6);
        lst.add(t);
        t = new Token(&quot;zoopod&quot;,0,6);
        t.setPositionIncrement(0);
        lst.add(t);
        t = new Token(&quot;foo&quot;,6,9);
        lst.add(t);
        t = new Token(&quot;zoopodfoo&quot;,0,9);
        t.setPositionIncrement(0);        
        lst.add(t);
        iter = lst.iterator();
      }
&lt;p&gt;      public Token next() throws IOException &lt;/p&gt;
{
        return iter.hasNext() ? (Token)iter.next() : null;
      }
&lt;p&gt;    };&lt;/p&gt;

&lt;p&gt;    String srchkey = &quot;foo&quot;;&lt;/p&gt;

&lt;p&gt;    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());&lt;br/&gt;
    Query query = parser.parse(srchkey);&lt;/p&gt;

&lt;p&gt;    Highlighter highlighter = new Highlighter(new QueryScorer(query));&lt;/p&gt;

&lt;p&gt;// Get 3 best fragments and seperate with a &quot;...&quot;&lt;br/&gt;
    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;);&lt;br/&gt;
    String expectedResult=&quot;zooPod&amp;lt;B&amp;gt;Foo&amp;lt;/B&amp;gt;&quot;;&lt;br/&gt;
    assertEquals(expectedResult,result);&lt;br/&gt;
  }&lt;/p&gt;
</comment>
                    <comment id="12420978" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 10:04:05 +0100"  >&lt;p&gt;It seems like maybe the only way to handle some of this stuff is two passes... one to collect the scores &amp;amp; offsets of matches, and then a second pass to generate the fragments.&lt;/p&gt;</comment>
                    <comment id="12421024" author="markh" created="Fri, 14 Jul 2006 14:53:51 +0100"  >&lt;p&gt;&amp;gt;&amp;gt;It seems like maybe the only way to handle some of this stuff is two passes&lt;/p&gt;

&lt;p&gt;The highlighter does not expect token positions to &quot;rewind&quot; in this manner. I&apos;m not sure where this ends. Imagine an analyzer, which having considered and emitted tokens for a whole document, chooses to append some  tokens positioned which  has offsets referencing much earlier sections of the document. (Why, I&apos;m not sure but there&apos;s nothing to say this couldn&apos;t happen).&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;It seems like maybe the only way to handle some of this stuff is two passes&lt;/p&gt;

&lt;p&gt;Maybe a special &quot;OrderFixer&quot; TokenStream could be used by to wrap &quot;rewinding&quot; token streams such as yours and then accumulate all tokens in a  buffer before then sorting and outputting them in ascending start offset order. If the Highlighter ignored position increment and just used offsets (as it does currently) I suspect all would be OK&lt;/p&gt;
</comment>
                    <comment id="12421128" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 15:51:19 +0100"  >&lt;p&gt;Right... I&apos;m not sure the highlighter should be expected to handle all cases, but WordDelimiterFilter doesn&apos;t seem &lt;b&gt;that&lt;/b&gt; complex or atypical.&lt;/p&gt;

&lt;p&gt;&quot;a-b-c&quot; would be indexed as &quot;a&quot;,&quot;b&quot;,&quot;c&quot;/&quot;abc&quot;&lt;br/&gt;
(c and abc occupy the same token position)&lt;/p&gt;

&lt;p&gt;Another thing I ran across is the addition of non-scoring tokens to a TokenGroup... this ends up highlighting the widest token in the token group, rather than the widest that matched.  I was able to get around this by checking that score&amp;gt;0 in TokenGroup, but was this indended?&lt;/p&gt;</comment>
                    <comment id="12421162" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 17:58:06 +0100"  >&lt;p&gt;I&apos;m going with the OrderFixer approach for now... if startOffsets are equal, but endOffsets are not, does it matter which comes first?&lt;/p&gt;</comment>
                    <comment id="12421220" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 21:41:32 +0100"  >&lt;p&gt;Here is a patch that makes the tests work after tokens are re-ordered.&lt;br/&gt;
I basically keep track of the start and end offsets of what matches, not just of the TokenGroup, so highlighting is more specific.&lt;/p&gt;

&lt;p&gt;Sorry about the messy patch - my IDE collapses the tabs so I don&apos;t even see them (I only realize there are tabs after I do a diff).&lt;/p&gt;</comment>
                    <comment id="12421332" author="yseeley@gmail.com" created="Sat, 15 Jul 2006 20:40:18 +0100"  >&lt;p&gt;So Mark, does this patch look OK?&lt;br/&gt;
Without it, even if I order the tokens by startOffset, I get things like&lt;br/&gt;
HiHi-Speed &amp;lt;em&amp;gt;USB&amp;lt;/em&amp;gt;&lt;/p&gt;

&lt;p&gt;WordDelimiterFilter (that&apos;s what is producing these types of tokens) is widely used in Solr-land, so I&apos;m eager to get this fixed.&lt;/p&gt;</comment>
                    <comment id="12421342" author="markh" created="Sat, 15 Jul 2006 21:52:04 +0100"  >&lt;p&gt;Hi Yonik,&lt;br/&gt;
Been away for a little while and just managed to catch up with your changes. Thanks for this.&lt;/p&gt;

&lt;p&gt;Looking at the patch all seems good. I would just change a couple of things:&lt;/p&gt;

&lt;p&gt;1) TokenGroup.getTotalScore should just return your new &quot;tot&quot; variable&lt;br/&gt;
2) TokenGroup.clear() needs to reinitialize &quot;tot&quot; to zero.&lt;/p&gt;


&lt;p&gt;Other than that all looks good to me. Let me know if you&apos;re happy and I&apos;ll commit it.&lt;/p&gt;

&lt;p&gt;Thanks again&lt;/p&gt;</comment>
                    <comment id="12421347" author="yseeley@gmail.com" created="Sat, 15 Jul 2006 22:14:26 +0100"  >&lt;p&gt;&amp;gt; 1) TokenGroup.getTotalScore should just return your new &quot;tot&quot; variable&lt;/p&gt;

&lt;p&gt;OK, I had considered that change before, but because all the vars were package protected rather than private, I wasn&apos;t sure if it was safe.&lt;/p&gt;

&lt;p&gt;&amp;gt; 2) TokenGroup.clear() needs to reinitialize &quot;tot&quot; to zero.&lt;/p&gt;

&lt;p&gt;Oops... that one I missed.&lt;/p&gt;

&lt;p&gt;&amp;gt; Other than that all looks good to me. Let me know if you&apos;re happy and I&apos;ll commit it.&lt;/p&gt;

&lt;p&gt;Looks fine to me... please do!&lt;/p&gt;</comment>
                    <comment id="12421372" author="yseeley@gmail.com" created="Sun, 16 Jul 2006 04:19:47 +0100"  >&lt;p&gt;Closing... works fine for me now.&lt;br/&gt;
Thanks!&lt;/p&gt;</comment>
                    <comment id="12434087" author="lhelper" created="Tue, 12 Sep 2006 09:12:52 +0100"  >&lt;p&gt;Hi Yonik, &lt;br/&gt;
I&apos;m trying to add support for some overlapping bigram analyzer, e.g. the CJKAnalyzer(&lt;a href=&quot;http://svn.apache.org/repos/asf/lucene/java/trunk/contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org/repos/asf/lucene/java/trunk/contrib/analyzers/src/java/org/apache/lucene/analysis/cjk/&lt;/a&gt;) onto your patch.&lt;/p&gt;

&lt;p&gt;With your patch, the following test fails with:&lt;br/&gt;
Expected :?&amp;lt;B&amp;gt;&lt;cite&gt;&amp;lt;/B&amp;gt;&lt;/cite&gt;&amp;lt;B&amp;gt;&lt;cite&gt;&amp;lt;/B&amp;gt;&lt;/cite&gt;?&lt;br/&gt;
Actual :?&amp;lt;B&amp;gt;??????&amp;lt;/B&amp;gt;&lt;/p&gt;

&lt;p&gt;public void testOverlapAnalyzer4() throws Exception&lt;br/&gt;
{&lt;br/&gt;
    String s = &quot;??????????&quot;;&lt;br/&gt;
    // the token stream for the string above:&lt;br/&gt;
    TokenStream ts = new TokenStream() {&lt;br/&gt;
      Iterator iter;&lt;/p&gt;
      {
        List lst = new ArrayList();
        Token t;
        t = new Token(&quot;??&quot;,0,2);
        lst.add(t);
        t = new Token(&quot;??&quot;,1,3);
        lst.add(t);
        t = new Token(&quot;??&quot;,2,4);
        lst.add(t);
        t = new Token(&quot;??&quot;,3,5);
        lst.add(t);
        t = new Token(&quot;??&quot;,4,6);
        lst.add(t);
        t = new Token(&quot;??&quot;,5,7);
        lst.add(t);
        t = new Token(&quot;??&quot;,6,8);
        lst.add(t);
        t = new Token(&quot;??&quot;,7,9);
        lst.add(t);
        t = new Token(&quot;??&quot;,8,10);
        lst.add(t);
        iter = lst.iterator();
      }
&lt;p&gt;      public Token next() throws IOException &lt;/p&gt;
{
        return iter.hasNext() ? (Token)iter.next() : null;
      }
&lt;p&gt;    };&lt;/p&gt;

&lt;p&gt;    String srchkey = &quot;?? ??&quot;;&lt;/p&gt;

&lt;p&gt;    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer());&lt;br/&gt;
    Query query = parser.parse(srchkey);&lt;/p&gt;

&lt;p&gt;    Highlighter highlighter = new Highlighter(new QueryScorer(query));&lt;/p&gt;

&lt;p&gt;    // Get 3 best fragments and seperate with a &quot;...&quot;&lt;br/&gt;
    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;);&lt;br/&gt;
    String expectedResult=&quot;?&amp;lt;B&amp;gt;&lt;cite&gt;&amp;lt;/B&amp;gt;&lt;/cite&gt;&amp;lt;B&amp;gt;&lt;cite&gt;&amp;lt;/B&amp;gt;&lt;/cite&gt;?&quot;;&lt;br/&gt;
    assertEquals(expectedResult,result);&lt;br/&gt;
} &lt;/p&gt;

&lt;p&gt;With some overlapping bigram analyzer, the current token&apos;s startOffset is the previous token&apos;s endOffset - 1, so the TokenGroup.isDistinct(token) returns false the most time, which lead to bad range tokenText.&lt;/p&gt;

&lt;p&gt;Here is a patch that makes the tests work.&lt;/p&gt;</comment>
                    <comment id="12434291" author="markh" created="Tue, 12 Sep 2006 22:57:00 +0100"  >&lt;p&gt;Hi Kerang, can you supply a patch/tests against the latest version?&lt;/p&gt;

&lt;p&gt;I committed a change to highlighter on the 16th August with what I beleived to be a fix for  this problem:   &lt;a href=&quot;http://issues.apache.org/jira/browse/LUCENE-645&quot; class=&quot;external-link&quot;&gt;http://issues.apache.org/jira/browse/LUCENE-645&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Looking at the patch you provided it seems to be old code which is missing support for this fix.&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12438333" author="lhelper" created="Thu, 28 Sep 2006 07:57:47 +0100"  >&lt;p&gt;Hi Mark, sorry for the long time missing!&lt;/p&gt;

&lt;p&gt;Here is the test, it fails again with the lastest version (Revision 450719):&lt;/p&gt;

&lt;p&gt;Expected :A&amp;lt;B&amp;gt;BC&amp;lt;/B&amp;gt;DE&amp;lt;B&amp;gt;FG&amp;lt;/B&amp;gt;HIJ&lt;br/&gt;
Actual:A&amp;lt;B&amp;gt;BCDEFG&amp;lt;/B&amp;gt;HIJ&lt;/p&gt;

&lt;p&gt;public void testOverlapAnalyzer4() throws Exception &lt;br/&gt;
{ &lt;br/&gt;
    String s = &quot;ABCDEFGHIJ&quot;; &lt;br/&gt;
    // the token stream for the string above: &lt;br/&gt;
    TokenStream ts = new TokenStream() { &lt;br/&gt;
      Iterator iter; &lt;/p&gt;
      { 
        List lst = new ArrayList(); 
        Token t; 
        t = new Token(&quot;AB&quot;,0,2); 
        lst.add(t); 
        t = new Token(&quot;BC&quot;,1,3); 
        lst.add(t); 
        t = new Token(&quot;CD&quot;,2,4); 
        lst.add(t); 
        t = new Token(&quot;DE&quot;,3,5); 
        lst.add(t); 
        t = new Token(&quot;EF&quot;,4,6); 
        lst.add(t); 
        t = new Token(&quot;FG&quot;,5,7); 
        lst.add(t); 
        t = new Token(&quot;GH&quot;,6,8); 
        lst.add(t); 
        t = new Token(&quot;HI&quot;,7,9); 
        lst.add(t); 
        t = new Token(&quot;IJ&quot;,8,10); 
        lst.add(t); 
        iter = lst.iterator(); 
      } 
&lt;p&gt;      public Token next() throws IOException &lt;/p&gt;
{ 
        return iter.hasNext() ? (Token)iter.next() : null; 
      }
&lt;p&gt; &lt;br/&gt;
    }; &lt;/p&gt;

&lt;p&gt;    String srchkey = &quot;BC FG&quot;; &lt;/p&gt;

&lt;p&gt;    QueryParser parser=new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer()); &lt;br/&gt;
    Query query = parser.parse(srchkey); &lt;/p&gt;

&lt;p&gt;    Highlighter highlighter = new Highlighter(new QueryScorer(query)); &lt;/p&gt;

&lt;p&gt;    // Get 3 best fragments and seperate with a &quot;...&quot; &lt;br/&gt;
    String result = highlighter.getBestFragments(ts, s, 3, &quot;...&quot;); &lt;br/&gt;
    String expectedResult=&quot;A&amp;lt;B&amp;gt;BC&amp;lt;/B&amp;gt;DE&amp;lt;B&amp;gt;FG&amp;lt;/B&amp;gt;HIJ&quot;; &lt;br/&gt;
    assertEquals(expectedResult,result); &lt;br/&gt;
} &lt;/p&gt;</comment>
                    <comment id="12438531" author="markh" created="Thu, 28 Sep 2006 20:17:00 +0100"  >&lt;p&gt;Thanks for the test Kerang.&lt;/p&gt;

&lt;p&gt;I no longer have a clear view as to what is expected behaviour here and whether this is a test that needs to pass.&lt;/p&gt;

&lt;p&gt;It seems to conflict with the expected results for Yonik&apos;s test method &quot;testOverlapAnalyzer2&quot;.&lt;br/&gt;
In that test, (like yours) for a cluster of overlapping tokens with search terms identified at the beginning and end, Yonik expects the whole cluster from search term 1&apos;s start offset to search term 2&apos;s end offset to be surrounded by one highlight tag. Your test expected 2 tags.&lt;/p&gt;

&lt;p&gt;Who is right?&lt;/p&gt;

&lt;p&gt;This is a snippet from Yonik&apos;s test:&lt;br/&gt;
    query = new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer()).parse(&quot;hi speed&quot;);&lt;br/&gt;
    highlighter = new Highlighter(new QueryScorer(query));&lt;br/&gt;
    result = highlighter.getBestFragments(getTS2(), s, 3, &quot;...&quot;);&lt;br/&gt;
    assertEquals(&quot;&amp;lt;B&amp;gt;Hi-Speed&amp;lt;/B&amp;gt;10 foo&quot;,result);&lt;/p&gt;

&lt;p&gt;and yours:&lt;/p&gt;

&lt;p&gt;      String srchkey = &quot;BC FG&quot;; &lt;br/&gt;
      String expectedResult=&quot;A&amp;lt;B&amp;gt;BC&amp;lt;/B&amp;gt;DE&amp;lt;B&amp;gt;FG&amp;lt;/B&amp;gt;HIJ&quot;; &lt;/p&gt;

&lt;p&gt;I don&apos;t really have an opinion either way so I&apos;ll turn it over to you&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;

</comment>
                    <comment id="12438553" author="yseeley@gmail.com" created="Thu, 28 Sep 2006 22:11:08 +0100"  >&lt;p&gt;I agree with Kerang about the expected behavior (of this specific case at least).&lt;br/&gt;
The test case of mine quoted above was not what I was shooting for, but was an acceptable unintended side-effect of fixing the other cases.&lt;/p&gt;

&lt;p&gt;So I&apos;m fine with this case being changed to&lt;br/&gt;
    query = new QueryParser(&quot;text&quot;,new WhitespaceAnalyzer()).parse(&quot;hi speed&quot;);&lt;br/&gt;
    highlighter = new Highlighter(new QueryScorer(query));&lt;br/&gt;
    result = highlighter.getBestFragments(getTS2(), s, 3, &quot;...&quot;);&lt;br/&gt;
    assertEquals(&quot;&amp;lt;B&amp;gt;Hi&amp;lt;/B&amp;gt;-&amp;lt;B&amp;gt;Speed&amp;lt;/B&amp;gt;10 foo&quot;,result);&lt;/p&gt;</comment>
                    <comment id="12662579" author="ryguasu" created="Sat, 10 Jan 2009 00:35:44 +0000"  >&lt;p&gt;I&apos;m here two years after the last comment, trying to create a sense of closure for myself regarding the above conversation:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;It appears that Mark Harwood committed a slightly modified version of Yonik&apos;s 2006-07-14 01:41 PM patch in r422031 and r422302.&lt;/li&gt;
	&lt;li&gt;It&apos;s not clear to me whether there was any actual code or test suite changes that eventually resulted from Mark, Yonik and Kerang&apos;s subsequent discussion about what, exactly, should be considered correct highlighting of multiple tokens.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12340628" name="Highlighter.java.diff" size="2181" author="lhelper" created="Tue, 12 Sep 2006 09:16:15 +0100" />
                    <attachment id="12336906" name="highlight_overlap.diff" size="18631" author="yseeley@gmail.com" created="Fri, 14 Jul 2006 21:41:32 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 14 Jul 2006 02:33:26 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13126</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27103</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>