<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:18:42 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1494/LUCENE-1494.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1494] masking field of span for cross searching across multiple fields (many-to-one style)</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1494</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This issue is to cover the changes required to do a search across multiple fields with the same name in a fashion similar to a many-to-one database. Below is my post on java-dev on the topic, which details the changes we need:&lt;/p&gt;

&lt;p&gt;&amp;#8212;&lt;/p&gt;

&lt;p&gt;We have an interesting situation where we are effectively indexing two &apos;entities&apos; in our system, which share a one-to-many relationship (imagine &apos;User&apos; and &apos;Delivery Address&apos; for demonstration purposes). At the moment, we index one Lucene Document per &apos;many&apos; end, duplicating the &apos;one&apos; end data, like so:&lt;/p&gt;

&lt;p&gt;    userid: 1&lt;br/&gt;
    userfirstname: fred&lt;br/&gt;
    addresscountry: au&lt;br/&gt;
    addressphone: 1234&lt;/p&gt;

&lt;p&gt;    userid: 1&lt;br/&gt;
    userfirstname: fred&lt;br/&gt;
    addresscountry: nz&lt;br/&gt;
    addressphone: 5678&lt;/p&gt;

&lt;p&gt;    userid: 2&lt;br/&gt;
    userfirstname: mary&lt;br/&gt;
    addresscountry: au&lt;br/&gt;
    addressphone: 5678&lt;/p&gt;

&lt;p&gt;(note: 2 Documents indexed for user 1). This is somewhat annoying for us, because when we search in Lucene the results we want back (conceptually) are at the &apos;user&apos; level, so we have to collapse the results by distinct user id, etc. etc (let alone that it blows out the size of our index enormously). So why do we do it? It would make more sense to use multiple fields:&lt;br/&gt;
    userid: 1&lt;br/&gt;
    userfirstname: fred&lt;br/&gt;
    addresscountry: au&lt;br/&gt;
    addressphone: 1234&lt;br/&gt;
    addresscountry: nz&lt;br/&gt;
    addressphone: 5678&lt;/p&gt;

&lt;p&gt;    userid: 2&lt;br/&gt;
    userfirstname: mary&lt;br/&gt;
    addresscountry: au&lt;br/&gt;
    addressphone: 5678&lt;/p&gt;

&lt;p&gt;But imagine the search &quot;+addresscountry:au +addressphone:5678&quot;. We&apos;d like this to match ONLY Mary, but of course it matches Fred also because he matches both those terms (just for different addresses).&lt;/p&gt;

&lt;p&gt;There are two aspects to the approach we&apos;ve (more or less) got working but I&apos;d like to run them past the group and see if they&apos;re worth trying to get them into Lucene proper (if so, I&apos;ll create a JIRA issue for them)&lt;/p&gt;

&lt;p&gt;1) Use a modified SpanNearQuery. If we assume that country + phone will always be one token, we can rely on the fact that the positions of &apos;au&apos; and &apos;5678&apos; in Fred&apos;s document will be different.&lt;/p&gt;

&lt;p&gt;   SpanQuery q1 = new SpanTermQuery(new Term(&quot;addresscountry&quot;, &quot;au&quot;));&lt;br/&gt;
   SpanQuery q2 = new SpanTermQuery(new Term(&quot;addressphone&quot;, &quot;5678&quot;));&lt;br/&gt;
   SpanQuery snq = new SpanNearQuery(new SpanQuery[]&lt;/p&gt;
{q1, q2}
&lt;p&gt;, 0, false);&lt;/p&gt;

&lt;p&gt;the slop of 0 means that we&apos;ll only return those where the two terms are in the same position in their respective fields. This works brilliantly, BUT requires a change to SpanNearQuery&apos;s constructor (which checks that all the clauses are against the same field). Are people amenable to perhaps adding another constructor to SNQ which doesn&apos;t do the check, or subclassing it to do the same (give it a protected non-checking constructor for the subclass to call)?&lt;/p&gt;

&lt;p&gt;2) (snipped ... see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1626&quot; title=&quot;getPositionIncrementGap(String fieldname, int currentPos)&quot;&gt;&lt;del&gt;LUCENE-1626&lt;/del&gt;&lt;/a&gt; for second idea)&lt;/p&gt;</description>
                <environment></environment>
            <key id="12410865">LUCENE-1494</key>
            <summary>masking field of span for cross searching across multiple fields (many-to-one style)</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="hossman">Hoss Man</assignee>
                                <reporter username="pcowan">Paul Cowan</reporter>
                        <labels>
                    </labels>
                <created>Wed, 17 Dec 2008 02:32:38 +0000</created>
                <updated>Fri, 1 May 2009 20:17:33 +0100</updated>
                    <resolved>Fri, 1 May 2009 20:17:33 +0100</resolved>
                            <version>2.4</version>
                                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12657271" author="pcowan" created="Wed, 17 Dec 2008 03:07:56 +0000"  >&lt;p&gt;Patch for part 1. Introduces a new sublcass of SpanNearQuery, which might be overkill, but the semantics here are quite different (and it interacts oddly with some other classes &amp;#8211; getField(), for instance, can&apos;t be meaningfully implemented &amp;#8211; so having a separate class here made sense to me. Includes test cases.&lt;/p&gt;</comment>
                    <comment id="12657272" author="pcowan" created="Wed, 17 Dec 2008 03:10:48 +0000"  >&lt;p&gt;Patch for part 2). This follows the my original idea suggested above; Chris Hostetter suggested another approach:&lt;/p&gt;

&lt;p&gt;&quot;couldn&apos;t this be solved by an Analyzer that counts the token per fieldname and implements getPositionIncrementGap as..&lt;br/&gt;
	int result - SOME_BIG_NUM - tokensSeenMap.get(fieldname);&lt;br/&gt;
	tokensSeenMap.put(fieldname, 0);&lt;br/&gt;
	return result;&quot;&lt;/p&gt;

&lt;p&gt;but I think this seems much lower overhead and, while it affects the Analyzer base class (and so is potentially high-impact) the way it&apos;s implemented won&apos;t affect existing implementations and gently deprecates the old way, while still letting implementing subclasses work as they did before, so I think this is low impact. Interested to see what people think.&lt;/p&gt;</comment>
                    <comment id="12657295" author="pcowan" created="Wed, 17 Dec 2008 05:48:30 +0000"  >&lt;p&gt;2 things about those patches:&lt;/p&gt;

&lt;p&gt;1) I did them against 2.4, not trunk. This is because I didn&apos;t because Luke isn&apos;t working against trunk and I wanted to double-check the index state during tests&lt;br/&gt;
2) I don&apos;t know WHY I put the changes in &apos;CHANGES.txt&apos; where I did (under the 2.4.0 release, which is already out). I&apos;m not drunk, I swear. If this lands, those will obviously have to be put in the right spot.&lt;/p&gt;</comment>
                    <comment id="12657353" author="ab" created="Wed, 17 Dec 2008 11:36:34 +0000"  >&lt;p&gt;Luke should work with trunk, possibly with only minor patches. Just grab the luke-0.9.jar and add jars from Lucene trunk on the classpath.&lt;/p&gt;</comment>
                    <comment id="12658318" author="hossman" created="Sat, 20 Dec 2008 19:58:01 +0000"  >&lt;p&gt;i&apos;ve only looked at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1494&quot; title=&quot;masking field of span for cross searching across multiple fields (many-to-one style)&quot;&gt;&lt;del&gt;LUCENE-1494&lt;/del&gt;&lt;/a&gt;-multifield.patch ... one problem i see is that SpanNearQuery stores and utilizes the field name in ways that don&apos;t make sense for the new MultiFieldSpanNearQuery subclass (ie: getField, .&lt;/p&gt;

&lt;p&gt;I would suggest that instead you invert the inheritence: move the guts of SpanNearQuery into MultiFieldSpanNearQuery and make it a superclass of SpanNearQuery.  This also eliminates the need for the mustBeSameField param...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class SpanNearQuery &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; MultiFieldSpanNearQuery {
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; getField() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; field; }
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; SpanNearQuery(SpanQuery[] clauses, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; slop, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; inOrder) {
    &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(clauses, slop, inOrder, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; clauses.length; i++) {
      SpanQuery clause = clauses[i];
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i == 0) { field = clause[i].getField(); }
      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!clause[i[.getField().equals(field)) {
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Clauses must have same field.&quot;&lt;/span&gt;);
      }
  }
  &lt;span class=&quot;code-comment&quot;&gt;// :TODO: need to override equals from &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt; ... maybe hashCode too
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12662244" author="pcowan" created="Fri, 9 Jan 2009 05:14:36 +0000"  >&lt;p&gt;Hi Hoss,&lt;/p&gt;

&lt;p&gt;I don&apos;t disagree that an inverted inheritance hierarchy would make more sense, but the problem with that is that getField (which I &lt;em&gt;think&lt;/em&gt; is the only thing on SpanNearQuery that doesn&apos;t really make sense for a MultiField one) is mandated by the abstract method declaration of same in SpanQuery, which the inverted parent class would still extend. Looking at where getField() is used (primarily in SpanWeight.explain() and SpanWeight and BoostingTermWeight&apos;s .scorer() methods) I&apos;m not sure how I can meaningfully deal with those in the case of a multifield span query.&lt;/p&gt;

&lt;p&gt;If you (or anyone else) have any suggestions for that then I&apos;m all ears, this would be really useful for us (and a lot of other people I think, it&apos;s not an uncommon query on the lists etc).&lt;/p&gt;

&lt;p&gt;Personally I&apos;d be equally happy with just eliminating the same-field requirement (as you mentioned, I think, that Doug suggested) but those explain()s and scorer() methods would still need to be changed. Any ideas?&lt;/p&gt;

&lt;p&gt;Paul&lt;/p&gt;</comment>
                    <comment id="12665961" author="hossman" created="Wed, 21 Jan 2009 20:33:25 +0000"  >

&lt;blockquote&gt;&lt;p&gt;I don&apos;t disagree that an inverted inheritance hierarchy would make more sense, but the problem with that is that getField (which I think is the only thing on SpanNearQuery that doesn&apos;t really make sense for a MultiField one) is mandated by the abstract method declaration of same in SpanQuery.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah, right right ... of course.  I was thinking getField was just a SpanNearQuery concept, but it&apos;s actually central to the whole concept of SpanQuery.&lt;/p&gt;

&lt;p&gt;This actually raises some interesting questions about the behavior of all of this...&lt;/p&gt;

&lt;p&gt;Beyond just the explain methods, SpanQuery.getField plays two important roles:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;it determines what norms get used by SpanScorer&lt;/li&gt;
	&lt;li&gt;it dictates what other SpanQueries this query can be nested in &amp;#8211; so far we&apos;ve really only discussed directly executing a MultiFieldSpanNearQuery, but we also have to consider what it means to combine a MultiFieldSpanNearQuery in another SpanQuery&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;At the moment, your patch treats the first element of the SpanQuery[] used to construct the MultiFieldSpanNearQuery as &quot;special&quot; &amp;#8211; it specifies the field which determines the norms used and what oher SpanQueries it can be combined with.  At a minimum that special case behavior needs to be documented, but we may also want to consider tweaking the API to make it more explicit (ie: perhaps when constructing a MultiFieldSpanNearQuery you should be required to explicitly state the field name you want to use).  It may also be worth considering whether or not MultiFieldSpanNearQuery should use a custom Scorer that takes into account the norms of all the fields (averaging them maybe?)&lt;/p&gt;


&lt;p&gt;(FWIW: this highlights one of the reasons why a multi-field PhraseQuery would be much simpler to implement then a multi-field SpanNearQuery ... the super class of PhraseQuery (Query) has no inherent concept of a field, so it would be easy to inject a new superclass in the middle there)&lt;/p&gt;


&lt;p&gt;The more i think about this, the more i wonder if a simpler solution would be a SpanQuery that wrapped another SpanQuery and proxied all of hte method except for the getField() method, ie...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class MaskFieldSpanQuery &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; SpanQuery {
  SpanQuery &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt;;
  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; MaskFieldSpanQuery(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, SpanQuery &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt;) { ... }
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; getField() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; field; }
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Spans getSpans(IndexReader r) { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt;.getSpans(reader); }
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; PayloadSpans getPayloadSpans(IndexReader reader) { ...
  ...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I haven&apos;t tested this out, but it seems that wrapping a bunch of SpanQueries in something like this and then building up a SpanNearQuery should be functionally equivalent to the existing MultiFieldSpanNearQuery in the patch, but would also allow for other interesting things (like a SpanNotQuery where you want to find all docs that match on rating_year:2004 but &lt;b&gt;not&lt;/b&gt; if rating_score:POOR matches in the same position.&lt;/p&gt;


&lt;p&gt;what do people think?&lt;/p&gt;

</comment>
                    <comment id="12667573" author="pcowan" created="Tue, 27 Jan 2009 03:16:18 +0000"  >&lt;p&gt;Hoss, I think you&apos;re right. I think the MaskFieldSpanQuery is a much nicer and cleaner implementation &amp;#8211; and a lot easier to explain in Javadoc. &apos;Note that if you use this, the norms of the &apos;impersonated&apos; field will be used for scoring&apos;. That makes it completely clear what&apos;s happening and that if you use norms (we don&apos;t use them at all, which is why it doesn&apos;t bother us and we didn&apos;t pick up on that) and means that we don&apos;t have to have MultiFieldSpanOrQuery etc... it will all just work, and I think it&apos;s conceptually a lot clearer.&lt;/p&gt;

&lt;p&gt;Your other idea is a good one... all the SpanQueries could take in a strategy for dealing with multiple fields&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; MultiFieldStrategy {
   SAME_FIELD_ONLY, &lt;span class=&quot;code-comment&quot;&gt;// Current behaviour
&lt;/span&gt;   FIRST_FIELD_ADDED,
   AVERAGE_NORMS,
   DO_SOMETHING_ELSE_WITH_NORMS &lt;span class=&quot;code-comment&quot;&gt;// ... or whatever
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but I think that&apos;s overkill for now &amp;#8211; at least for us &amp;#8211; and the &apos;masking&apos; span query is much much nicer. I&apos;ll look at coming up with a patch that incorporates this instead (but still includes the getPositionIncrementGap() change, as that&apos;s still needed per the above)&lt;/p&gt;</comment>
                    <comment id="12669512" author="pcowan" created="Mon, 2 Feb 2009 05:51:55 +0000"  >&lt;p&gt;A patch to use Hoss&apos; &quot;masking&quot; idea to support this query. I think this is relatively clean and much easier to explain in the Javadoc.&lt;/p&gt;</comment>
                    <comment id="12704850" author="hossman" created="Fri, 1 May 2009 00:41:57 +0100"  >&lt;p&gt;some things looked like they wouldn&apos;t work with the masking patch, so i wrote some test cases to convince myself they were broken (and because new code should always have test cases).  In particular i was worried about the lack of equals/hashCode methods, and the broken rewrite method&lt;/p&gt;

&lt;p&gt;one interesting thing I discovered was that the code worked in many cases even though rewrite was constantly just returning the masked inner query &amp;#8211; digging into it i realized the reason was because none of the other SpanQuery classes pay any attention to what their nested clauses return when they recursively rewrite, so a SpanNearQuery whose constructor freaks out if the fields of all the clauses don&apos;t match, happily generates spans if one of those clauses returns a complteley different SpanQuery on rewrite.&lt;/p&gt;

&lt;p&gt;I also removed the proxying of getBoost and setBoost ... it was causing problems with some stock testing framework code that expects a q1.equals(q1.clone().setBoost(newBoost)) to be false (this was evaluating to true because it&apos;s a shallow clone and setBoost was proxying and modifying the original inner query&apos;s boost value) ... this means that FieldMaskingSpanQuery is consistent with how other SpanQueries deal with boost (they ignore the boosts of their nested clauses)&lt;/p&gt;

&lt;p&gt;new patch (with tests) attached ... i&apos;d like to have some more tests before committing (spans is deep voodoo, we&apos;re doing funky stuff with spans, all the more reason to test thoroughly)&lt;/p&gt;</comment>
                    <comment id="12705092" author="hossman" created="Fri, 1 May 2009 20:05:10 +0100"  >&lt;p&gt;trimming description due to forking of second idea to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1626&quot; title=&quot;getPositionIncrementGap(String fieldname, int currentPos)&quot;&gt;&lt;del&gt;LUCENE-1626&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12705095" author="hossman" created="Fri, 1 May 2009 20:17:33 +0100"  >&lt;p&gt;Committed revision 770794.&lt;/p&gt;

&lt;p&gt;Thanks for your patch Paul.&lt;/p&gt;

&lt;p&gt;The committed version is near-identical to my last revised patch, but with more tests (100% coverage ... woot!)&lt;/p&gt;

&lt;p&gt;Note: I cloned this issue so the positionIncrementGap patch changes could be addressed separately in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1626&quot; title=&quot;getPositionIncrementGap(String fieldname, int currentPos)&quot;&gt;&lt;del&gt;LUCENE-1626&lt;/del&gt;&lt;/a&gt; since it hasn&apos;t had any discussion in this issue so far, and constitute a fundamentally different type of change (even if the two ideas ultimately aid in a single larger use case)&lt;/p&gt;
</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10020">
                <name>Cloners</name>
                                <outwardlinks description="is cloned as">
                            <issuelink>
            <issuekey id="12424416">LUCENE-1626</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12406978" name="LUCENE-1494-masking.patch" size="17245" author="hossman" created="Fri, 1 May 2009 00:41:57 +0100" />
                    <attachment id="12399259" name="LUCENE-1494-masking.patch" size="5270" author="pcowan" created="Mon, 2 Feb 2009 05:51:55 +0000" />
                    <attachment id="12396272" name="LUCENE-1494-multifield.patch" size="8942" author="pcowan" created="Wed, 17 Dec 2008 03:07:56 +0000" />
                    <attachment id="12396273" name="LUCENE-1494-positionincrement.patch" size="6618" author="pcowan" created="Wed, 17 Dec 2008 03:10:48 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 17 Dec 2008 11:36:34 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12257</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26233</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>