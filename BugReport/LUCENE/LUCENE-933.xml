<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:26:43 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-933/LUCENE-933.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-933] QueryParser can produce empty sub BooleanQueries when Analyzer proudces no tokens for input</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-933</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;as triggered by &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-261&quot; title=&quot;Search query with any  stop words can invalidate whole query&quot;&gt;&lt;del&gt;SOLR-261&lt;/del&gt;&lt;/a&gt;, if you have a query like this...&lt;/p&gt;

&lt;p&gt;   +foo:BBB  +(yak:AAA  baz:CCC)&lt;/p&gt;

&lt;p&gt;...where the analyzer produces no tokens for the &quot;yak:AAA&quot; or &quot;baz:CCC&quot; portions of the query (posisbly because they are stop words) the resulting query produced by the QueryParser will be...&lt;/p&gt;

&lt;p&gt;  +foo:BBB +()&lt;/p&gt;

&lt;p&gt;...that is a BooleanQuery with two required clauses, one of which is an empty BooleanQuery with no clauses.&lt;/p&gt;

&lt;p&gt;this does not appear to be &quot;good&quot; behavior.&lt;/p&gt;

&lt;p&gt;In general, QueryParser should be smarter about what it does when parsing encountering parens whose contents result in an empty BooleanQuery &amp;#8211; but what exactly it should do in the following situations...&lt;/p&gt;

&lt;p&gt; a)  +foo:BBB +()&lt;br/&gt;
 b)  +foo:BBB ()&lt;br/&gt;
 c)  +foo:BBB -()&lt;/p&gt;

&lt;p&gt;...is up for interpretation.  I would think situation (b) clearly lends itself to dropping the sub-BooleanQuery completely.  situation (c) may also lend itself to that solution, since semanticly it means &quot;don&apos;t allow a match on any queries in the empty set of queries&quot;.  .... I have no idea what the &quot;right&quot; thing to do for situation (a) is.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12371795">LUCENE-933</key>
            <summary>QueryParser can produce empty sub BooleanQueries when Analyzer proudces no tokens for input</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="doronc">Doron Cohen</assignee>
                                <reporter username="hossman">Hoss Man</reporter>
                        <labels>
                    </labels>
                <created>Sat, 16 Jun 2007 08:27:57 +0100</created>
                <updated>Tue, 26 Jun 2007 06:18:50 +0100</updated>
                    <resolved>Tue, 26 Jun 2007 01:44:50 +0100</resolved>
                                                                    <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12505438" author="hossman" created="Sat, 16 Jun 2007 08:28:26 +0100"  >&lt;p&gt;linking to origin of report from SOLR&lt;/p&gt;</comment>
                    <comment id="12506342" author="doronc" created="Wed, 20 Jun 2007 01:09:24 +0100"  >&lt;p&gt;&amp;gt;  a) +foo:BBB +() &lt;br/&gt;
&amp;gt;  I have no idea what the &quot;right&quot; thing to do for situation (a) is.&lt;/p&gt;

&lt;p&gt;Interestingly, see TestQueryParser.testQPA():&lt;br/&gt;
      assertQueryEquals(&quot;term +stop term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;br/&gt;
      assertQueryEquals(&quot;term -stop term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;/p&gt;

&lt;p&gt;So today already requiring word W to not/appear become a non-requirement in case W is a stopword. &lt;/p&gt;

&lt;p&gt;Currently adding  any of these would cause failure:&lt;br/&gt;
    assertQueryEquals(&quot;term +(stop) term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;br/&gt;
    assertQueryEquals(&quot;term -(stop) term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;br/&gt;
    assertQueryEquals(&quot;term +(stop stop) term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;br/&gt;
    assertQueryEquals(&quot;term -(stop stop) term&quot;, qpAnalyzer, &quot;term term&quot;);&lt;/p&gt;

&lt;p&gt;I feel comfortable with applying the logic we have for a single (stop)word on a group of (stop)words, i.e. making the added lines pass.&lt;/p&gt;

&lt;p&gt;Interestingly, consider this query: &lt;br/&gt;
      A  B +(+C -C)&lt;br/&gt;
Regularly it would have no match, because  &lt;br/&gt;
     X AND NOT X == FALSE&lt;br/&gt;
but if C is a stopword, with the fixed&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; logic the query would become:&lt;br/&gt;
     A  B &lt;br/&gt;
and might have matches.&lt;br/&gt;
Now is that a glitch? I&apos;d like to think not.&lt;/p&gt;</comment>
                    <comment id="12506351" author="hossman" created="Wed, 20 Jun 2007 02:10:09 +0100"  >&lt;p&gt;&amp;gt; I feel comfortable with applying the logic we have for a single (stop)word on a group of&lt;br/&gt;
&amp;gt; (stop)words, i.e. making the added lines pass.&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; Interestingly, consider this query:&lt;br/&gt;
&amp;gt;       A  B +(+C -C)&lt;/p&gt;

&lt;p&gt;perhaps an alternate way to view this problem would be to ask:  what should QueryParser do, if asked to parse this string...&lt;br/&gt;
        A B +()&lt;/p&gt;

&lt;p&gt;...if the answer is &quot;treat it like &apos;A B&apos;&quot; then i think we&apos;re okay with the approach you described above.  if the answer is &quot;an empty query doesn&apos;t match anything, so requiring a match on a clause which is an empty query should result in the outer query matching nothing&quot;  then we&apos;ve got a problem ... mainly that it contradicts the example you cited from TestQueryParser.testQPA() if you replace &quot;an empty query&quot; in the previous statement with &quot;a query on a stop word&quot;&lt;/p&gt;

&lt;p&gt;personally, i think it&apos;s okay to say &quot;A  B +(+C -C)&quot; == &quot;A B&quot; if the analyzer doesn&apos;t produce any tokens for C.&lt;/p&gt;</comment>
                    <comment id="12506703" author="doronc" created="Wed, 20 Jun 2007 23:20:51 +0100"  >&lt;p&gt;So an acceptable solution is:&lt;br/&gt;
  Query parser will ignore empty clauses (e.g. &apos; ( ) &apos; ) resulted from words filtering, the same as it already does for single words. &lt;/p&gt;

&lt;p&gt;A straightforward fix is for QueryParser to avoid adding null (inner) queries into (outer) clauses sets. (It makes sense, too.)&lt;/p&gt;

&lt;p&gt;However this has a side effect: &lt;br/&gt;
  For queries that became &quot;empty&quot; as result of filtering (stopping), QueryParser would now return null. &lt;/p&gt;

&lt;p&gt;This is an API semantics change, because applications that used to get a BooleanQuery with 0 clauses as parse result, would now get a null query. &lt;/p&gt;

&lt;p&gt;Here is a closer look on the behavior change:&lt;/p&gt;

&lt;p&gt;Original behavior:&lt;br/&gt;
   (1)  parse(&quot; &quot;)  == ParseException&lt;br/&gt;
   (2)  parse(&quot;( )&quot;)  == ParseException&lt;br/&gt;
   (3)  parse(&quot;stop&quot;) == &quot; &quot;    &lt;br/&gt;
        (actually a boolean query with 0 clauses)&lt;br/&gt;
   (4)  parse(&quot;(stop)&quot;)  == &quot; &quot;    &lt;br/&gt;
        (actually a boolean query with 0 clauses)&lt;br/&gt;
   (5)  parse(&quot;a stop b&quot;) == &quot;a b&quot;&lt;br/&gt;
   (6)  parse(&quot;a (stop) b&quot;) == &quot;a () b&quot;   &lt;br/&gt;
        (middle part is a boolean query with 0 clauses)&lt;br/&gt;
   (7)  parse(&quot;a ((stop)) b&quot;) == &quot;a () b&quot; &lt;br/&gt;
        (again middle part is a boolean query with 0 clauses)&lt;/p&gt;

&lt;p&gt;Modified behavior:   &lt;br/&gt;
   (3)  parse(&quot;stop&quot;) == null&lt;br/&gt;
   (4)  parse(&quot;(stop)&quot;)  == null    &lt;br/&gt;
   (6)  parse(&quot;a (stop) b&quot;) == &quot;a b&quot;   &lt;br/&gt;
   (7)  parse(&quot;a ((stop)) b&quot;) == &quot;a b&quot; &lt;/p&gt;

&lt;p&gt;I think the modified behavior is the right one - applications can test a query for being null and realize that it is a no-op. &lt;/p&gt;

&lt;p&gt;However backwards compatibility is important - would this change break existing applications with annoying new NPEs?&lt;/p&gt;

&lt;p&gt;As an alternative, QueryParser parse() methods can be modified to return a phony empty BQ instead of returning null, for the sake of backwards compatibility.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12506737" author="doronc" created="Thu, 21 Jun 2007 02:35:24 +0100"  >&lt;p&gt;Ok attaching two different fixes (as discussed above) &lt;br/&gt;
  (1)  lucene-933_backwards_comapatible.patch &lt;br/&gt;
  (2)  lucene-933_nullify.patch&lt;/p&gt;

&lt;p&gt;All tests pass with either of these.&lt;/p&gt;

&lt;p&gt;The &quot;nullify&quot; approach requires more changes especially tests as well as in MemoryIndex, so, after while fixing as required for tests to pass in this (nullifying) approach I cane to conclusion that it is better to continue to not return null queries as result of parsing, otherwise there&apos;ll be lots of &quot;noise&quot;. &lt;/p&gt;

&lt;p&gt;So I would like to commit patch (1) - unless someone points a problem that I missed.&lt;/p&gt;</comment>
                    <comment id="12508024" author="doronc" created="Tue, 26 Jun 2007 01:44:50 +0100"  >&lt;p&gt;committed the bakwards-compatible patch (parsed query is not null).&lt;/p&gt;</comment>
                    <comment id="12508054" author="hossman" created="Tue, 26 Jun 2007 05:44:17 +0100"  >&lt;p&gt;woops ... sorry doron, i actually reviewed these patches the other day, but aparently i got side tracked and never commented.&lt;/p&gt;

&lt;p&gt;i think you made the right choice with the backwards_comapatible.patch &lt;/p&gt;</comment>
                    <comment id="12508058" author="doronc" created="Tue, 26 Jun 2007 06:18:50 +0100"  >&lt;p&gt;great, thanks Hoss!&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                <outwardlinks description="blocks">
                            <issuelink>
            <issuekey id="12371564">SOLR-261</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12360237" name="lucene-933_backwards_comapatible.patch" size="8066" author="doronc" created="Thu, 21 Jun 2007 02:35:24 +0100" />
                    <attachment id="12360238" name="lucene-933_nullify.patch" size="14308" author="doronc" created="Thu, 21 Jun 2007 02:35:24 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 20 Jun 2007 00:09:24 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12809</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26796</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>