<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:59:08 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1427/LUCENE-1427.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1427] QueryWrapperFilter should not do scoring</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1427</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The purpose of QueryWrapperFilter is to simply filter to include the docIDs that match the query.&lt;/p&gt;

&lt;p&gt;Its implementation is wasteful now because it computes scores for those matching docs even though the score is unused.  We could fix this by getting a Scorer and iterating through the docs without asking for the score:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Index: src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 707060)
+++ src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -62,11 +62,9 @@
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DocIdSet getDocIdSet(IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
     &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; OpenBitSet bits = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OpenBitSet(reader.maxDoc());
 
-    &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(reader).search(query, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HitCollector() {
-      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; void collect(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc, &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; score) {
-        bits.set(doc);  &lt;span class=&quot;code-comment&quot;&gt;// set bit &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; hit
&lt;/span&gt;-      }
-    });
+    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Scorer scorer = query.weight(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(reader)).scorer(reader);
+    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;(scorer.next())
+      bits.set(scorer.doc());
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; bits;
   }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maybe I&apos;m missing something, but this seams like a simple win?&lt;/p&gt;</description>
                <environment></environment>
            <key id="12406996">LUCENE-1427</key>
            <summary>QueryWrapperFilter should not do scoring</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Wed, 22 Oct 2008 14:19:27 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:09 +0100</updated>
                    <resolved>Fri, 31 Oct 2008 16:18:33 +0000</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12641930" author="paul.elschot@xs4all.nl" created="Wed, 22 Oct 2008 19:32:59 +0100"  >&lt;p&gt;Indeed a simple win, but it can be even simpler (untested):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DocIdSet() {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DocIdSetIterator iterator() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; scorer;
    }
  };
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This DocIdSetIterator should be used only once, so it&apos;s best to cache it in a CachingWrapperFilter, and the javadocs could indicate that.&lt;/p&gt;

&lt;p&gt;See also &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1296&quot; title=&quot;Allow use of compact DocIdSet in CachingWrapperFilter&quot;&gt;&lt;del&gt;LUCENE-1296&lt;/del&gt;&lt;/a&gt;, which allows the choice of a supporting data structure other than OpenBitSet.&lt;/p&gt;</comment>
                    <comment id="12641963" author="mikemccand" created="Wed, 22 Oct 2008 21:44:43 +0100"  >&lt;p&gt;Excellent!  That&apos;s about as simple as it can get &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;But, I don&apos;t really like forcefully wrapping CachingWrapperFilter inside &amp;#8211; that should be up to the caller to decide?&lt;/p&gt;</comment>
                    <comment id="12642827" author="paul.elschot@xs4all.nl" created="Sun, 26 Oct 2008 22:50:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;But, I don&apos;t really like forcefully wrapping CachingWrapperFilter inside - that should be up to the caller to decide?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree. Perhaps we should have a OneTimeDocIdSet for cases like this one, and leave the possibility to repeatedly generate a DocIdSetIterator to caching filters. Just thinking out loud.&lt;/p&gt;

&lt;p&gt;A OneTimeDocIdSet would throw an for example an IllegalStateException when its iterator() method is called more than once.&lt;/p&gt;</comment>
                    <comment id="12643221" author="mikemccand" created="Tue, 28 Oct 2008 14:22:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;Perhaps we should have a OneTimeDocIdSet for cases like this one, and leave the possibility to repeatedly generate a DocIdSetIterator to caching filters&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m torn on this. It&apos;s nice in that it&apos;d &quot;forcefully&quot; remind you that if you are re-using a filter you really should cache it.  But, then, there are legitimate cases where you don&apos;t want to cache it (eg you know you will use it rarely, it&apos;s fast enough, and you don&apos;t want to spend the RAM).&lt;/p&gt;

&lt;p&gt;Also, for this instance it&apos;d be a break in back compatibility since you can currently re-use a QueryWrapperFilter instance.&lt;/p&gt;

&lt;p&gt;So I guess I&apos;m leaning back towards my original patch, which still allows re-use, but does not waste CPU computing scores which are just discarded.&lt;/p&gt;</comment>
                    <comment id="12643252" author="paul.elschot@xs4all.nl" created="Tue, 28 Oct 2008 16:41:32 +0000"  >&lt;p&gt;The new Filter api allows to split the concerns of which data structure to use for collecting the  docs in the DocIdSet and the cached data structure used to iterate over this set, and this is what shows up here.&lt;/p&gt;

&lt;p&gt;For backward compatibility QueryWrapperFilter could use an OpenBitSet that is good for collecting the docids, but the new Filter api leaves it not really necessary to use a data structure at all (see my initial suggestion).&lt;/p&gt;

&lt;p&gt;So the question is how we want to deal with the split between initial collecting and later repeated iterations. OpenBitSet is certainly good for collecting, so a good and backward compatible way would be to document the use of OpenBitSet in the javadocs of QueryWrapperFilter, and let CachingWrapperFilter decide later which data structure to cache.&lt;br/&gt;
The alternative would be to let CachingWrapperFilter always do the initial collecting , but that would not be backward compatible.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;instanceof&lt;/tt&gt; could be used to decide at CachingWrapperFilter to do this initial collecting when it&apos;s not sure that the given data structure allows repeated iteration, but it may be better to add a boolean method to DocIdSet that indicates whether the iterator can be used more than once or not. However, that is better left to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1296&quot; title=&quot;Allow use of compact DocIdSet in CachingWrapperFilter&quot;&gt;&lt;del&gt;LUCENE-1296&lt;/del&gt;&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;In short, I&apos;d like to have a javadoc remark added to the original patch on the use of OpenBitSet, and leave the rest to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1296&quot; title=&quot;Allow use of compact DocIdSet in CachingWrapperFilter&quot;&gt;&lt;del&gt;LUCENE-1296&lt;/del&gt;&lt;/a&gt; .&lt;/p&gt;</comment>
                    <comment id="12643310" author="mikemccand" created="Tue, 28 Oct 2008 19:12:03 +0000"  >&lt;p&gt;Actually, can&apos;t we simply instantiate a new scorer each time iterator() is called?  Then we don&apos;t need an intermediate OpenBitSet and we can simply return the scorer (your original suggestion).&lt;/p&gt;

&lt;p&gt;The only problem is... we then need to add &quot;throws IOException&quot; to DocIdSet.iterator().  While that is technically a non-back-compatible change (places that call DocIdSet.iterator() may suddenly have to add &quot;throws IOException&quot; to their method signatures, up the chain), I think it&apos;s likely very rare in practice that a code change would be needed, since the next() method of the iterator throws IOException and presumably almost all code that gets an iterator then next()&apos;s through it.  There were no changes in Lucene&apos;s core or contrib sources necessary on adding this.  I think it&apos;s an acceptable change.&lt;/p&gt;

&lt;p&gt;Then the patch looks like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Index: src/java/org/apache/lucene/search/DocIdSet.java
===================================================================
--- src/java/org/apache/lucene/search/DocIdSet.java	(revision 708628)
+++ src/java/org/apache/lucene/search/DocIdSet.java	(working copy)
@@ -17,11 +17,12 @@
  * limitations under the License.
  */
 
+&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;
 
 /**
  * A DocIdSet contains a set of doc ids. Implementing classes must provide
  * a {@link DocIdSetIterator} to access the set. 
  */
 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class DocIdSet {
-	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; DocIdSetIterator iterator();
+	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; DocIdSetIterator iterator() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
 }
Index: src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 708628)
+++ src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -59,15 +59,13 @@
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; bits;
   }
   
-  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DocIdSet getDocIdSet(IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
-    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; OpenBitSet bits = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OpenBitSet(reader.maxDoc());
-
-    &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(reader).search(query, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HitCollector() {
-      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; void collect(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc, &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; score) {
-        bits.set(doc);  &lt;span class=&quot;code-comment&quot;&gt;// set bit &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; hit
&lt;/span&gt;+  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DocIdSet getDocIdSet(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
+    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Weight weight = query.weight(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(reader));
+    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DocIdSet() {
+      &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DocIdSetIterator iterator() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; weight.scorer(reader);
       }
-    });
-    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; bits;
+    };
   }
 
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString() {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I do agree, longer term, that clarifying the semantics to allow some DocIDSets that do not allow more than one call to iterator(), and then requiring something like CachingWrapperFilter to &quot;translate&quot; between different DocIdSets (compact or not, re-iterable, etc) is worth thinking about.  Though, besides this case, which seems easy to fix by just getting another scorer in iterator(), are there other places where not having to provide a repeatable iterator buys us some compelling freedom?&lt;/p&gt;</comment>
                    <comment id="12643337" author="paul.elschot@xs4all.nl" created="Tue, 28 Oct 2008 21:00:00 +0000"  >&lt;blockquote&gt;&lt;p&gt;... are there other places where not having to provide a repeatable iterator buys us some compelling freedom?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One might want to cache the Filter based on the version (last mod time) of the index, and not based on the actual index reader. In that case the original reader could not be available when the Filter is used.&lt;/p&gt;

&lt;p&gt;I don&apos;t know whether that is compelling given the current cost of (re)opening an index.&lt;/p&gt;</comment>
                    <comment id="12643590" author="mikemccand" created="Wed, 29 Oct 2008 18:37:13 +0000"  >&lt;p&gt;OK I plan to commit the above patch in a day or two.&lt;/p&gt;</comment>
                    <comment id="12644329" author="mikemccand" created="Fri, 31 Oct 2008 16:18:33 +0000"  >&lt;p&gt;Committed revision 709459.&lt;/p&gt;

&lt;p&gt;Thanks Paul!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 22 Oct 2008 18:32:59 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12324</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26301</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>