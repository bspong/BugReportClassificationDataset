<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:59:28 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1383/LUCENE-1383.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1383] Work around ThreadLocal&apos;s &quot;leak&quot;</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1383</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Java&apos;s ThreadLocal is dangerous to use because it is able to take a&lt;br/&gt;
surprisingly very long time to release references to the values you&lt;br/&gt;
store in it.  Even when a ThreadLocal instance itself is GC&apos;d, hard&lt;br/&gt;
references to the values you had stored in it are easily kept for&lt;br/&gt;
quite some time later.&lt;/p&gt;

&lt;p&gt;While this is not technically a &quot;memory leak&quot;, because eventually&lt;br/&gt;
(when the underlying Map that stores the values cleans up its &quot;stale&quot;&lt;br/&gt;
references) the hard reference will be cleared, and GC can proceed,&lt;br/&gt;
its end behavior is not different from a memory leak in that under the&lt;br/&gt;
right situation you can easily tie up far more memory than you&apos;d&lt;br/&gt;
expect, and then hit unexpected OOM error despite allocating an&lt;br/&gt;
extremely large heap to your JVM.&lt;/p&gt;

&lt;p&gt;Lucene users have hit this many times.  Here&apos;s the most recent thread:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200809.mbox/%3C6e3ae6310809091157j7a9fe46bxcc31f6e63305fcdc%40mail.gmail.com%3E&quot; class=&quot;external-link&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200809.mbox/%3C6e3ae6310809091157j7a9fe46bxcc31f6e63305fcdc%40mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And here&apos;s another:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200807.mbox/%3CF5FC94B2-E5C7-40C0-8B73-E12245B91CEE%40mikemccandless.com%3E&quot; class=&quot;external-link&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200807.mbox/%3CF5FC94B2-E5C7-40C0-8B73-E12245B91CEE%40mikemccandless.com%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And then there&apos;s &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-436&quot; title=&quot;[PATCH] TermInfosReader, SegmentTermEnum Out Of Memory Exception&quot;&gt;&lt;del&gt;LUCENE-436&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-529&quot; title=&quot;TermInfosReader and other + instance ThreadLocal =&amp;gt; transient/odd memory leaks =&amp;gt;  OutOfMemoryException&quot;&gt;&lt;del&gt;LUCENE-529&lt;/del&gt;&lt;/a&gt; at least.&lt;/p&gt;

&lt;p&gt;A google search for &quot;ThreadLocal leak&quot; yields many compelling hits.&lt;/p&gt;

&lt;p&gt;Sun does this for performance reasons, but I think it&apos;s a terrible&lt;br/&gt;
trap and we should work around it with Lucene.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12404207">LUCENE-1383</key>
            <summary>Work around ThreadLocal&apos;s &quot;leak&quot;</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Sep 2008 21:50:44 +0100</created>
                <updated>Sat, 11 Oct 2008 13:49:42 +0100</updated>
                    <resolved>Sun, 14 Sep 2008 11:33:51 +0100</resolved>
                            <version>1.9</version>
                <version>2.0.0</version>
                <version>2.1</version>
                <version>2.2</version>
                <version>2.3</version>
                <version>2.3.1</version>
                <version>2.3.2</version>
                                <fixVersion>2.4</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12630367" author="mikemccand" created="Thu, 11 Sep 2008 22:04:18 +0100"  >&lt;p&gt;Attached patch.  All tests pass.&lt;/p&gt;

&lt;p&gt;The patch adds o.a.l.util.CloseableThreadLocal.  It&apos;s a wrapper around ThreadLocal that wraps the values inside a WeakReference, but then also holds a strong reference to the value (to ensure GC doesn&apos;t reclaim it) until you call the close method.  On calling close, GC is then free to reclaim all values you had stored, regardless of how long it takes ThreadLocal&apos;s implementation to actually release its references.&lt;/p&gt;

&lt;p&gt;There are a couple places in Lucene where I left the current usage of ThreadLocal.&lt;/p&gt;

&lt;p&gt;First, Analyzer.java uses ThreadLocal to hold reusable token streams.  There is no &quot;close&quot; called for Analyzer, so unless we are willing to add a finalizer to call CloseableThreadLocal.close() I think we can leave it.&lt;/p&gt;

&lt;p&gt;Second, some of the contrib/benchmark tasks use ThreadLocal to store per-thread DateFormat which should use tiny memory.&lt;/p&gt;</comment>
                    <comment id="12630784" author="chrislusf" created="Sat, 13 Sep 2008 16:46:51 +0100"  >&lt;p&gt;I can confirm this patch fixed the memory problem, in general. Thanks!&lt;/p&gt;

&lt;p&gt;However, if not nitpicking, I did noticed in this patch, during the transition time between the previous index searcher/reader close and the new index searcher/reader open, there is a bump in the memory graph.&lt;br/&gt;
  ___&lt;em&gt;/&amp;#95;&lt;/em&gt;__&lt;br/&gt;
There are 2 RAMDirectory instances in the memory for a short period of time.&lt;/p&gt;

&lt;p&gt;In previous Lucene version without Lucene-1195, the memory graph looks more clean, with a V dip.&lt;br/&gt;
____  ____&lt;br/&gt;
         \/&lt;/p&gt;

&lt;p&gt;And in one index refresh during the same index run, there were 2 RAMDirectory in the memory for a fairly long time. But not repeatable.&lt;/p&gt;

&lt;p&gt;So I suspect the closing is kind of delayed. And sometimes it could be missed.&lt;/p&gt;

&lt;p&gt;Attaching the screenshot for the memory bump, and 2 the memory graphs of the begin and after of 2RAMDirecory in the memory(needed 2 because the time is fairly long)&lt;/p&gt;</comment>
                    <comment id="12630785" author="chrislusf" created="Sat, 13 Sep 2008 16:48:09 +0100"  >&lt;p&gt;A little bump when closing and opening the index. The test did the closing first, then opening.&lt;/p&gt;</comment>
                    <comment id="12630786" author="chrislusf" created="Sat, 13 Sep 2008 16:50:46 +0100"  >&lt;p&gt;Beginning of a memory increase of 2 RAMDirectory in the memory. This is also during a index closing, then opening.&lt;/p&gt;</comment>
                    <comment id="12630787" author="chrislusf" created="Sat, 13 Sep 2008 16:51:36 +0100"  >&lt;p&gt;Endding of a memory increase of 2 RAMDirectory in the memory. This is also during a index closing, then opening. No particular reason, but the RAMDirectory dropped back to 1.&lt;/p&gt;</comment>
                    <comment id="12630789" author="chrislusf" created="Sat, 13 Sep 2008 17:05:04 +0100"  >&lt;p&gt;The test is repeatedly close and open the index. &lt;/p&gt;

&lt;p&gt;After the repeat close/open test run finished, I closed the RAMDirectory based searcher/reader, and switched to FSDirectory, the RAMDirectory(which is fairly large) was left in the memory. I did several rounds of GC, but the RAMDirectory was not cleaned. At this time, I tried to do a memory dump, but an OOM occured.&lt;/p&gt;
</comment>
                    <comment id="12630811" author="mikemccand" created="Sat, 13 Sep 2008 19:23:23 +0100"  >&lt;p&gt;Hmm, the sometimes long-lasting bump in Used memory is odd.&lt;/p&gt;

&lt;p&gt;When you close the old IndexSearcher &amp;amp; RAMDirectory do you forcefully dereference them (set all variables that point to them to null) before then reopening the new ones?  (Seems like you must, since you saw the V shape before &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1195&quot; title=&quot;Performance improvement for TermInfosReader&quot;&gt;&lt;del&gt;LUCENE-1195&lt;/del&gt;&lt;/a&gt;, but I just want to verify).  If you simply re-assign the variable from old to new then two objects will exist at once until the opening of the new one finishes.&lt;/p&gt;

&lt;p&gt;I think the bump may just be GC taking its time collecting the objects, which should be harmless.  Maybe using a WeakReference to a long-lived object causes GC to take longer to collect?&lt;/p&gt;

&lt;p&gt;Is it possible to use the profiler to look for a reference to the old RAMDirectory while the bump is &quot;up&quot;?  That would be a smoking gun that we do still have a reference, unless it&apos;s only via the WeakReference.&lt;/p&gt;

&lt;p&gt;Or, could you try lowering the heap size in your JRE to something slightly less than 2X one RAMDirectory (but not so low that the &quot;other stuff&quot; you have in the JRE can&apos;t fit).  This would force GC to work harder / more immediately in reclaiming the unreachable objects.&lt;/p&gt;</comment>
                    <comment id="12630845" author="chrislusf" created="Sun, 14 Sep 2008 02:26:50 +0100"  >&lt;p&gt;On second thought, I think this is normal behavior. Like you said, the GC may take a while before really cleaning up stuff. So if I did not wait a while between the close and open, the little bump should be normal.&lt;/p&gt;

&lt;p&gt;So I would say this bug is fixed. Thanks!&lt;/p&gt;</comment>
                    <comment id="12630846" author="chrislusf" created="Sun, 14 Sep 2008 03:14:54 +0100"  >&lt;p&gt;this is the V shape memory graph using the patch. This also confirms the leak is fixed.&lt;/p&gt;</comment>
                    <comment id="12630872" author="mikemccand" created="Sun, 14 Sep 2008 11:14:43 +0100"  >&lt;p&gt;OK super!  Thanks for testing Chris.  I&apos;ll commit shortly.&lt;/p&gt;</comment>
                    <comment id="12630875" author="mikemccand" created="Sun, 14 Sep 2008 11:33:51 +0100"  >&lt;p&gt;Thanks Chris!&lt;/p&gt;</comment>
                    <comment id="12630876" author="mikemccand" created="Sun, 14 Sep 2008 11:34:02 +0100"  >&lt;p&gt;Committed revision 695184.&lt;/p&gt;</comment>
                    <comment id="12636063" author="adrian.tarau" created="Wed, 1 Oct 2008 16:32:23 +0100"  >&lt;p&gt;Even if the issue is closed, for those who want to know why ThreadLocal had to be fixed : &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue164.html&quot; class=&quot;external-link&quot;&gt;http://www.javaspecialists.eu/archive/Issue164.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&quot;Best Practices&lt;/p&gt;

&lt;p&gt;If you must use ThreadLocal, make sure that you remove the value as soon as you are done with it and preferably before you return your thread to a thread pool. Best practice is to use remove() rather than set(null), since that would cause the WeakReference to be removed immediately, together with the value.&lt;/p&gt;

&lt;p&gt;Kind regards&lt;/p&gt;

&lt;p&gt;Heinz&quot;&lt;/p&gt;</comment>
                    <comment id="12636075" author="rengels@ix.netcom.com" created="Wed, 1 Oct 2008 17:03:56 +0100"  >&lt;p&gt;It doesn&apos;t need to be &quot;fixed&quot;.&lt;/p&gt;

&lt;p&gt;It works fine, you need to understand how to use it properly which may require calling remove() if your threads are long-lived.&lt;/p&gt;

&lt;p&gt;Also, remove() was only added in 1.5, and that is why that technique is not valid for Lucene. It is also not valid, since you need to clear all values across all threads, remove() only clears the entry for the calling thread.&lt;/p&gt;

&lt;p&gt;The current patch solves the problem suitably for Lucene, at the expense of some performance degradation.&lt;/p&gt;
</comment>
                    <comment id="12636082" author="mikemccand" created="Wed, 1 Oct 2008 17:21:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;The current patch solves the problem suitably for Lucene, at the expense of some performance degradation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The performance degradation should be negligible in the case of long-lived threads.  No synchronized code was added in the get() path.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It is also not valid, since you need to clear all values across all threads, remove() only clears the entry for the calling thread.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This best practice does work correctly: you&apos;re supposed to call remove() from the very thread that had inserted something into the ThreadLocal.&lt;/p&gt;

&lt;p&gt;Besides the 1.5 issue, this is also difficult for Lucene because we don&apos;t have a clean point to &quot;know&quot; when the thread has finished interacting with Lucene.  A thread comes out of the pool, runs a search, gathers docIDs from in a collector, returns from the search, one by one looks up stored docs / term vectors for these docIDs, maybe does secondary search up front to build up filters, etc., finishes rendering the result and returns to the pool.  Unless we create a new method &quot;detachThread(...)&quot; somewhere in Lucene, there is no natural point now to do the remove().  And I don&apos;t like creating such a method because nobody will ever know they need to call it in their App server until they start hitting cryptic OOMs.&lt;/p&gt;</comment>
                    <comment id="12636085" author="adrian.tarau" created="Wed, 1 Oct 2008 17:30:18 +0100"  >&lt;p&gt;Ok, maybe &quot;fixed&quot; was too much and it sounded like ThreadLocal has a problem. ThreadLocal works fine except that it is tricky with long-lived threads.&lt;/p&gt;

&lt;p&gt;Anyway, it is a good article in case somebody wants to understand why this change in Lucene.&lt;/p&gt;</comment>
                    <comment id="12636089" author="adrian.tarau" created="Wed, 1 Oct 2008 17:41:15 +0100"  >&lt;p&gt;Michael,&lt;/p&gt;

&lt;p&gt;Maybe some sort of cleanup method should be created even if regular users will not call it. &lt;/p&gt;

&lt;p&gt;I presume it can be highlighted somewhere in the documentation, like in &quot;Best practices&quot; : &lt;a href=&quot;http://wiki.apache.org/lucene-java/BestPractices&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/BestPractices&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;I would really like to be able to control this, to be able to clean thread(s) storage programmatically.&lt;/p&gt;</comment>
                    <comment id="12636095" author="rengels@ix.netcom.com" created="Wed, 1 Oct 2008 17:56:05 +0100"  >&lt;p&gt;You cannot control this &apos;externally&quot;, since there is no way to force the cleaning of the stale entries (no API method).&lt;/p&gt;

&lt;p&gt;The current patch sort of allows this - the entries are not cleared but the weak references in them are - via the close(), but if this method is called at the wrong time, everything will break (since the stream needs to be cached), thus it is not exposed to the outside world.&lt;/p&gt;

&lt;p&gt;If you want to cleanup programatically, close the index readers and writers.&lt;/p&gt;
</comment>
                    <comment id="12636097" author="adrian.tarau" created="Wed, 1 Oct 2008 18:05:32 +0100"  >&lt;p&gt;If closing all index readers and writers releases all Lucene  thread locals it&apos;s great.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12389971" name="LUCENE-1383.patch" size="7122" author="mikemccand" created="Thu, 11 Sep 2008 22:04:18 +0100" />
                    <attachment id="12390055" name="ScreenHunter_01 Sep. 13 08.40.jpg" size="15857" author="chrislusf" created="Sat, 13 Sep 2008 16:48:09 +0100" />
                    <attachment id="12390056" name="ScreenHunter_02 Sep. 13 08.42.jpg" size="16418" author="chrislusf" created="Sat, 13 Sep 2008 16:50:46 +0100" />
                    <attachment id="12390057" name="ScreenHunter_03 Sep. 13 08.43.jpg" size="16573" author="chrislusf" created="Sat, 13 Sep 2008 16:51:36 +0100" />
                    <attachment id="12390072" name="ScreenHunter_07 Sep. 13 19.13.jpg" size="17821" author="chrislusf" created="Sun, 14 Sep 2008 03:14:54 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 13 Sep 2008 15:46:51 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12368</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26348</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>