<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:13:13 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1044/LUCENE-1044.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1044] Behavior on hard power shutdown</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1044</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;When indexing a large number of documents, upon a hard power failure  (e.g. pull the power cord), the index seems to get corrupted. We start a Java application as an Windows Service, and feed it documents. In some cases (after an index size of 1.7GB, with 30-40 index segment .cfs files) , the following is observed.&lt;/p&gt;

&lt;p&gt;The &apos;segments&apos; file contains only zeros. Its size is 265 bytes - all bytes are zeros.&lt;br/&gt;
The &apos;deleted&apos; file also contains only zeros. Its size is 85 bytes - all bytes are zeros.&lt;/p&gt;

&lt;p&gt;Before corruption, the segments file and deleted file appear to be correct. After this corruption, the index is corrupted and lost.&lt;/p&gt;

&lt;p&gt;This is a problem observed in Lucene 1.4.3. We are not able to upgrade our customer deployments to 1.9 or later version, but would be happy to back-port a patch, if the patch is small enough and if this problem is already solved.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Windows Server 2003, Standard Edition, Sun Hotspot Java 1.5&lt;/p&gt;</environment>
            <key id="12381729">LUCENE-1044</key>
            <summary>Behavior on hard power shutdown</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="ts01">venkat rangan</reporter>
                        <labels>
                    </labels>
                <created>Fri, 2 Nov 2007 19:07:15 +0000</created>
                <updated>Mon, 23 Feb 2009 17:15:03 +0000</updated>
                    <resolved>Mon, 11 Feb 2008 18:59:51 +0000</resolved>
                                            <fixVersion>2.4</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>4</watches>
                                                    <comments>
                    <comment id="12539787" author="hossman" created="Sat, 3 Nov 2007 05:22:50 +0000"  >&lt;p&gt;first off: there have been &lt;b&gt;numerous&lt;/b&gt; changes to the way lucene writes to files (particularly relating to segment files, write locks, and fault tollerance) between 2.0 and 2.2 (not to mention differences between 1.4.3 and 2.0 that i may not be aware of) &amp;#8211; so you may see many differences in behavior if you upgrade.&lt;/p&gt;

&lt;p&gt;second: to quote myself from a recent thread regarding lucene and &quot;kill -9&quot; ...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nabble.com/Help-with-Lucene-Indexer-crash-recovery-tf4572570.html#a13068939&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/Help-with-Lucene-Indexer-crash-recovery-tf4572570.html#a13068939&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;: That said, it should never in fact cause index corruption, as far as I&lt;br/&gt;
: know.  Lucene is &quot;semi-transactional&quot;: at any &amp;amp; all moments you should&lt;br/&gt;
: be able to destroy the JVM and the index will be unharmed. I would&lt;br/&gt;
: really like to get to the bottom of why this is not the case here.&lt;/p&gt;

&lt;p&gt;At any point you can shutdown the JVM and the index will be unharmed, but&lt;br/&gt;
&quot;destroying&quot; it with &quot;kill -9&quot; goes a little farther then that.  &lt;/p&gt;

&lt;p&gt;Lucene can&apos;t make that claim because the JVM can&apos;t even garuntee that&lt;br/&gt;
bytes are written to physical disk when we close() an OutputStream &amp;#8211; all&lt;br/&gt;
it garuntees is that the bytes have been handed to the OS.  When you &quot;kill&lt;br/&gt;
-9&quot; a process the OS is free to make &lt;b&gt;EVERYTHING&lt;/b&gt; about that process&lt;br/&gt;
vanish without cleaning up after it ... i&apos;m pretty sure even pending IO&lt;br/&gt;
operations are fair game for disappearing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;...what&apos;s true for &quot;kill -9&quot; is true for hanking the power cord ... if the JVM isn&apos;t shut down cleanly, there is nothing Lucene or the JVM can do to guarantee that your index is in a consistent state.&lt;/p&gt;</comment>
                    <comment id="12539891" author="rengels@ix.netcom.com" created="Sat, 3 Nov 2007 07:13:30 +0000"  >&lt;p&gt;The last comment is not correct, in that, there are many Java based applications (and non-java) that offer true transactional integrity.&lt;/p&gt;

&lt;p&gt;It usually involves a log file, and using sync to ensure data is written to disk.&lt;/p&gt;

&lt;p&gt;The Lucene structure allows for this VERY easily, as the &apos;segments&apos; file controls everything.&lt;/p&gt;

&lt;p&gt;If all previous files are &quot;synced&quot;, and then the &apos;segments.new&apos; file written, and synced (with a marker/checksum). Then the old &apos;segments&apos; deleted, and &apos;segments.new&apos; &apos;renamed to &apos;segments&apos;. It is trivial to ensure transactional integrity.&lt;/p&gt;

&lt;p&gt;Upon index open, check for segments.new - if doesn&apos;t exist, or does not have a valid checksum, delete all segments not in &apos;segments&apos;, if it is valid, then reattempt the rename. Then open the index.&lt;/p&gt;</comment>
                    <comment id="12540013" author="ts01" created="Sat, 3 Nov 2007 21:52:51 +0000"  >&lt;p&gt;Robert,&lt;br/&gt;
Are your comments applicable for version 1.4.3? The behavior of an all-zero &apos;segments&apos; and &apos;deleted&apos; files is very easily reproduced. Also, there is no left over &apos;segments.new&apos; after a power-cord yank.&lt;br/&gt;
Thanks.&lt;/p&gt;</comment>
                    <comment id="12540056" author="mikemccand" created="Sun, 4 Nov 2007 10:34:31 +0000"  >&lt;p&gt;See the healthy follow-on discussion here:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/54300&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/54300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I plan to add optional argument when calling FSDirectory.getDirectory() to ask all created FSIndexOutputs to always call sync() on the file descriptor before closing it.&lt;/p&gt;</comment>
                    <comment id="12540071" author="mikemccand" created="Sun, 4 Nov 2007 14:34:20 +0000"  >&lt;p&gt;This recent thread is also relevant here:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/39898&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/39898&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12540073" author="mikemccand" created="Sun, 4 Nov 2007 15:28:33 +0000"  >&lt;p&gt;Attached patch that adds optional &quot;doSync&quot; boolean to&lt;br/&gt;
FSDirectory.getDirectory(...).  It defaults to &quot;false&quot;.  When true, I&lt;br/&gt;
call file.getFD().sync() just before file.close() in&lt;br/&gt;
FSIndexOutput.close().&lt;/p&gt;

&lt;p&gt;However, I can&apos;t figure out how to also sync the directory.  Does&lt;br/&gt;
anyone know how to do this in Java?&lt;/p&gt;

&lt;p&gt;All tests pass if I default it to true or to false.&lt;/p&gt;</comment>
                    <comment id="12540088" author="mikemccand" created="Sun, 4 Nov 2007 18:29:22 +0000"  >
&lt;p&gt;Attached another rev of the patch, that adds &quot;fsdirectory.dosync&quot;&lt;br/&gt;
boolean config option to contrib/benchmark.&lt;/p&gt;

&lt;p&gt;I ran a quick perf test of sync vs no sync.  I indexed all of&lt;br/&gt;
Wikipedia using this alg:&lt;/p&gt;

&lt;p&gt;  analyzer=org.apache.lucene.analysis.SimpleAnalyzer&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Feed that knows how to process the line file format:&lt;br/&gt;
  doc.maker=org.apache.lucene.benchmark.byTask.feeds.LineDocMaker&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;  docs.file=/lucene/wikifull.txt&lt;/p&gt;

&lt;p&gt;  doc.maker.forever=false&lt;br/&gt;
  ram.flush.mb = 8&lt;br/&gt;
  max.buffered = 0&lt;br/&gt;
  directory = FSDirectory&lt;br/&gt;
  max.field.length = 2147483647&lt;br/&gt;
  doc.term.vector=false&lt;br/&gt;
  doc.stored=false&lt;br/&gt;
  fsdirectory.dosync = true&lt;/p&gt;

&lt;p&gt;  ResetSystemErase&lt;br/&gt;
  CreateIndex&lt;br/&gt;
  {AddDoc &amp;gt;: *&lt;br/&gt;
  CloseIndex&lt;/p&gt;

&lt;p&gt;  RepSumByName&lt;/p&gt;

&lt;p&gt;This is on a quad core Mac OS X (Mac Pro) with a 4-drive RAID 0 IO&lt;br/&gt;
system.  The baseline (non-sync) test took 19:54 and the sync test&lt;br/&gt;
took 20:21, which I think is a fairly minor slowdown.&lt;/p&gt;

&lt;p&gt;I also tried opening the file descriptor with &quot;rws&quot;, which I think is&lt;br/&gt;
overkill for us (we don&apos;t need every IO operation to be sync&apos;d) and it&lt;br/&gt;
took 31:11, which is a major slowdown &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Maybe we should actually make doSync=true the default?  It seems like&lt;br/&gt;
a small price to pay for the added safety.  The option would still be&lt;br/&gt;
there to turn off if people wanted to made the opposite tradeoff.&lt;/p&gt;</comment>
                    <comment id="12540612" author="mikemccand" created="Tue, 6 Nov 2007 22:38:47 +0000"  >&lt;p&gt;Attached another rev of the patch.&lt;/p&gt;

&lt;p&gt;I changed the default to &quot;true&quot;: I think the small performance hit is&lt;br/&gt;
worth the added safety.&lt;/p&gt;

&lt;p&gt;Also put a try/finally around the the call to sync to make sure we&lt;br/&gt;
close even if we hit exception during sync(), and improved the&lt;br/&gt;
javadocs.  I plan to commit in a day or two.&lt;/p&gt;</comment>
                    <comment id="12541566" author="mikemccand" created="Sat, 10 Nov 2007 17:51:55 +0000"  >&lt;p&gt;I just committed this.  Thanks Venkat!&lt;/p&gt;</comment>
                    <comment id="12541569" author="yseeley@gmail.com" created="Sat, 10 Nov 2007 18:10:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is on a quad core Mac OS X (Mac Pro) with a 4-drive RAID 0 IO&lt;br/&gt;
system. The baseline (non-sync) test took 19:54 and the sync test&lt;br/&gt;
took 20:21, which I think is a fairly minor slowdown.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Was that compound or non-compound index format?  I imagine non-compound will take a bigger hit since each file will be synchronized separately and in a serialized fashion.  I also imagine that the hit will be larger for a weaker disk subsystem, and for usage patterns that continually add a few docs and close?&lt;/p&gt;

&lt;p&gt;Is a sync before every file close really needed, or can some of them be avoided when autocommit==false?&lt;/p&gt;</comment>
                    <comment id="12541570" author="rengels@ix.netcom.com" created="Sat, 10 Nov 2007 18:17:25 +0000"  >&lt;p&gt;I agree. Just for a baseline, I think the test needs to be done on a single drive system.&lt;/p&gt;

&lt;p&gt;Also, the &apos;sync&apos; should be optional. BerkleyDB offers similar functionality.&lt;/p&gt;

&lt;p&gt;The reason being, if the index can be completely recreated from other sources, you might not want to pay the performance hit, instead recreate the index if corruption/hard failure occurs.&lt;/p&gt;
</comment>
                    <comment id="12541576" author="mikemccand" created="Sat, 10 Nov 2007 19:04:20 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;Was that compound or non-compound index format?  I imagine&lt;br/&gt;
non-compound will take a bigger hit since each file will be&lt;br/&gt;
synchronized separately and in a serialized fashion.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The test was with compound file.&lt;/p&gt;

&lt;p&gt;But, the close() on each component file that goes into the compound&lt;br/&gt;
file also does a sync, so compound file would be a slightly bigger hit&lt;br/&gt;
because it has one additional sync()?&lt;/p&gt;

&lt;p&gt;We can&apos;t safely remove the sync() on each component file before&lt;br/&gt;
building the compound file because we currently do a commit of the new&lt;br/&gt;
segments file before building the compound file.&lt;/p&gt;

&lt;p&gt;I guess we could revisit whether that commit (before building the&lt;br/&gt;
compound file) is really necessary?  I think it&apos;s there from when&lt;br/&gt;
flushing &amp;amp; merging were the same thing, and you do want to do this&lt;br/&gt;
when merging to save 1X extra peak on the disk usage, but now that&lt;br/&gt;
flushing is separate from merging we could remove that intermediate&lt;br/&gt;
commit?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I also imagine that the hit will be larger for a weaker disk&lt;br/&gt;
subsystem, and for usage patterns that continually add a few docs and&lt;br/&gt;
close?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I&apos;ll run the same test, but once on a laptop and once over NFS to&lt;br/&gt;
see what the cost is for those cases.&lt;/p&gt;

&lt;p&gt;Yes, continually adding docs &amp;amp; flushing/closing your writer will in&lt;br/&gt;
theory be most affected here.  I think for such apps performance is&lt;br/&gt;
not usually top priority (indexing latency is)?  Ie if you wanted&lt;br/&gt;
performance you would batch up the added docs more?  Anyway, for such&lt;br/&gt;
cases users can turn off sync() if they want to risk it?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is a sync before every file close really needed, or can some of them&lt;br/&gt;
be avoided when autocommit==false?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s somewhat tricky to safely remove sync() even when&lt;br/&gt;
autoCommit=false, because you don&apos;t know at close() whether this file&lt;br/&gt;
you are closing will be referenced (and not merged away) when the&lt;br/&gt;
commit is finally done (when IndexWriter is closed).&lt;/p&gt;

&lt;p&gt;If there were a way to sync a file after having closed it (is there?)&lt;br/&gt;
then we could go and sync() all new files we had created that are now&lt;br/&gt;
referenced by the segments file we are writing.&lt;/p&gt;

&lt;p&gt;Also, I was thinking we could start simple (call sync() before every&lt;br/&gt;
close()) and then with time, and if necessary, work out smarter ways&lt;br/&gt;
to safely remove some of those sync()&apos;s.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Also, the &apos;sync&apos; should be optional. BerkleyDB offers similar&lt;br/&gt;
functionality.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is optional: I added doSync boolean to&lt;br/&gt;
FSDirectory.getDirectory(...).&lt;/p&gt;

&lt;p&gt;And, I agree: for cases where there is very low cost to regenerate the&lt;br/&gt;
index, and you want absolute best performance, you can turn off&lt;br/&gt;
syncing.&lt;/p&gt;</comment>
                    <comment id="12541874" author="cutting" created="Mon, 12 Nov 2007 18:14:06 +0000"  >&lt;p&gt;&amp;gt; Is a sync before every file close really needed &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; ?&lt;/p&gt;

&lt;p&gt;It might be nice if we could use the Linux sync() system call, instead of fsync().  Then we could call that only when the new segments file is moved into place rather than as each file is closed.  We could exec the sync shell command when running on Unix, but I don&apos;t know whether there&apos;s an equivalent command for Windows, and it wouldn&apos;t be Java...&lt;/p&gt;</comment>
                    <comment id="12542244" author="mikemccand" created="Tue, 13 Nov 2007 21:53:52 +0000"  >&lt;p&gt;OK I ran sync/nosync tests across various platforms/IO system.  In&lt;br/&gt;
each case I ran the test once with doSync=true and once with&lt;br/&gt;
doSync=false, using this alg:&lt;/p&gt;

&lt;p&gt;  analyzer=org.apache.lucene.analysis.SimpleAnalyzer&lt;br/&gt;
  doc.maker=org.apache.lucene.benchmark.byTask.feeds.LineDocMaker&lt;br/&gt;
  docs.file=/lucene/wikifull.txt&lt;/p&gt;

&lt;p&gt;  doc.maker.forever=false&lt;br/&gt;
  ram.flush.mb = 8&lt;br/&gt;
  max.buffered = 0&lt;br/&gt;
  directory = FSDirectory&lt;br/&gt;
  max.field.length = 2147483647&lt;br/&gt;
  doc.term.vector=false&lt;br/&gt;
  doc.stored=false&lt;br/&gt;
  work.dir = /tmp/lucene&lt;br/&gt;
  fsdirectory.dosync = false&lt;/p&gt;

&lt;p&gt;  ResetSystemErase&lt;br/&gt;
  CreateIndex&lt;br/&gt;
  {AddDoc &amp;gt;: 150000&lt;br/&gt;
  CloseIndex&lt;/p&gt;

&lt;p&gt;  RepSumByName&lt;/p&gt;

&lt;p&gt;Ie, time to index the first 150K docs from Wikipedia.&lt;/p&gt;


&lt;p&gt;Results for single hard drive:&lt;/p&gt;

&lt;p&gt;  Mac mini (10.5 Leopard) single 4200 RPM &quot;notebook&quot; (2.5&quot;) drive &amp;#8211; 2.3% slower:&lt;/p&gt;

&lt;p&gt;      sync - 296.80 sec&lt;br/&gt;
    nosync - 290.06 sec&lt;/p&gt;

&lt;p&gt;  Mac pro (10.4 Tiger), single external drive &amp;#8211; 35.5% slower:&lt;/p&gt;

&lt;p&gt;      sync - 259.61 sec&lt;br/&gt;
    nosync - 191.53 sec&lt;/p&gt;

&lt;p&gt;  Win XP Pro laptop, single drive &amp;#8211; 38.2% slower&lt;/p&gt;

&lt;p&gt;      sync - 536.00 sec&lt;br/&gt;
    nosync - 387.90 sec&lt;/p&gt;

&lt;p&gt;  Linux (2.6.22.1), ext3 single drive &amp;#8211; 23% slower&lt;/p&gt;

&lt;p&gt;      sync - 185.42 sec&lt;br/&gt;
    nosync - 150.56 sec&lt;/p&gt;

&lt;p&gt;Results for multiple hard drives (RAID arrays):&lt;/p&gt;

&lt;p&gt;  Linux (2.6.22.1), reiserfs 6 drive RAID5 array &amp;#8211; 49% slower (!!)&lt;/p&gt;

&lt;p&gt;      sync - 239.32 sec&lt;br/&gt;
    nosync - 160.56 sec&lt;/p&gt;

&lt;p&gt;  Mac Pro (10.4 Tiger), 4 drive RAID0 array &amp;#8211; 1% faster&lt;/p&gt;

&lt;p&gt;      sync - 157.26 sec&lt;br/&gt;
    nosync - 158.93 sec&lt;/p&gt;


&lt;p&gt;So at this point I&apos;m torn...&lt;/p&gt;

&lt;p&gt;The performance cost of the simplest approach (sync() before close())&lt;br/&gt;
is very costly in many cases (not just laptop IO subsystems).  The&lt;br/&gt;
reiserfs test was rather shocking.  Then, it&apos;s oddly very lost cost in&lt;br/&gt;
other cases: the Mac Mini test I find amazing.&lt;/p&gt;

&lt;p&gt;It&apos;s frustrating to lose such performance &quot;out of the box&quot; for the&lt;br/&gt;
presumably extremely rare event of OS/machine crash/power cut.&lt;/p&gt;

&lt;p&gt;Maybe we should leave the default as false for now?&lt;/p&gt;</comment>
                    <comment id="12542261" author="cutting" created="Tue, 13 Nov 2007 22:47:05 +0000"  >&lt;p&gt;&amp;gt; Maybe we should leave the default as false for now?&lt;/p&gt;

&lt;p&gt;Perhaps for the short-term, but long-term it would be better to find a solution that&apos;s both reliable and doesn&apos;t have such a big performance impact.&lt;/p&gt;

&lt;p&gt;We really don&apos;t need to sync until we commit.  It would be interesting to know how much it slows things to do that.  As a quick hack we could try running the &apos;sync&apos; command line program at each commit.  If performance looks good, then we might look into implementing this in pure Java, changing FSDirectory.close() to queue FileDescriptors, add a background thread that syncs queued files, and add a Directory.sync() method that blocks until the queue is empty.&lt;/p&gt;</comment>
                    <comment id="12542397" author="mikemccand" created="Wed, 14 Nov 2007 10:24:19 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Perhaps for the short-term, but long-term it would be better to find a solution that&apos;s both reliable and doesn&apos;t have such a big performance impact.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.  I will default doSync back to false, for now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We really don&apos;t need to sync until we commit. It would be interesting to know how much it slows things to do that. As a quick hack we could try running the &apos;sync&apos; command line program at each commit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will test this as a hack first just to see how performance compares&lt;br/&gt;
to the current approach.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If performance looks good, then we might look into implementing this in pure Java, changing FSDirectory.close() to queue FileDescriptors, add a background thread that syncs queued files, and add a Directory.sync() method that blocks until the queue is empty.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will do!&lt;/p&gt;</comment>
                    <comment id="12544115" author="mikemccand" created="Tue, 20 Nov 2007 23:19:56 +0000"  >&lt;p&gt;OK, I tested calling command-line &quot;sync&quot;, after writing each segments&lt;br/&gt;
file.  It&apos;s in fact even slower than fsync on each file for these 3&lt;br/&gt;
cases:&lt;/p&gt;

&lt;p&gt;Linux (2.6.22.1), reiserfs 6 drive RAID5 array 93% slower&lt;br/&gt;
      sync - 330.74&lt;br/&gt;
    nosync - 171.24&lt;/p&gt;

&lt;p&gt;Linux (2.6.22.1), ext3 single drive 60% slower&lt;br/&gt;
      sync - 242.02&lt;br/&gt;
    nosync - 150.91&lt;/p&gt;

&lt;p&gt;Mac Pro (10.4 Tiger), 4 drive RAID0 array 28% slower&lt;br/&gt;
      sync - 204.77&lt;br/&gt;
    nosync - 159.90&lt;/p&gt;

&lt;p&gt;I&apos;ll look into the separate thread to sync/close files in the&lt;br/&gt;
background next...&lt;/p&gt;</comment>
                    <comment id="12544730" author="michaelbusch" created="Thu, 22 Nov 2007 08:38:43 +0000"  >&lt;p&gt;I think changing the only constructor in FSDirectory.FSIndexOutput is&lt;br/&gt;
an API change. I have a class that extends FSIndexOutput and it &lt;br/&gt;
doesn&apos;t compile anymore after switching to the 2.3-dev jar.&lt;/p&gt;

&lt;p&gt;I think we should put this ctr back:&lt;br/&gt;
public FSIndexOutput(File path) throws IOException {&lt;br/&gt;
  this(path, DEFAULT_DO_SYNC);&lt;br/&gt;
}&lt;/p&gt;</comment>
                    <comment id="12544758" author="mikemccand" created="Thu, 22 Nov 2007 10:32:48 +0000"  >&lt;p&gt;Woops, OK I will put it back ...&lt;/p&gt;</comment>
                    <comment id="12544803" author="doronc" created="Thu, 22 Nov 2007 13:27:23 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;ll look into the separate thread to sync/close files in the&lt;br/&gt;
background next...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was wondering if delaying sync to actual commit point would run faster&lt;br/&gt;
than a background thread. I thought it would, because the background&lt;br/&gt;
thread, though not holding current thread from continue with indexing, &lt;br/&gt;
does force the sync &lt;b&gt;now&lt;/b&gt; rather than letting the IO subsystem actually &lt;br/&gt;
write stuff on its time. I was also hoping that by doing them later, &lt;br/&gt;
some of the syncs would become no-ops, and hence faster. I found&lt;br/&gt;
out however that delaying the syncs (but intending to sync) also &lt;br/&gt;
means keeping the file handles open, and therefore  this is not &lt;br/&gt;
a practical approach. Still it was interesting to compare. &lt;/p&gt;

&lt;p&gt;So... my small test sequentially writes M characters to N files &lt;br/&gt;
and either do not sync (just close), or does sync in one of three &lt;br/&gt;
ways: (1) at the end, (2) immediately, (3) in a background thread. &lt;br/&gt;
The results (in millis) on my Windows XP were:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; num files &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; num chars per file &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; No Sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Sync At End &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Background Sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Immediate Sync &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   631 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   5778 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   5729 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   5828 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   581 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   4486 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   4117 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   4687 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1612 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  38996 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  34900 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  35852 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1432 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  37153 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  35051 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  37263 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10335 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 154262 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 162103 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 174251 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 11276 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 147752 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 159480 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 222450 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Each configuration ran twice and there are fluctuations, &lt;br/&gt;
but it is obvious (as Mike noticed) that no-sync is much faster&lt;br/&gt;
then sync. In fact in my test no-sync is at least 10 times faster&lt;br/&gt;
than any sync approach, while in Mike&apos;s test which is using &lt;br/&gt;
Lucene the penalty is smaller. Difference might be because &lt;br/&gt;
in my test there is no CPU work involved, just IO. &lt;/p&gt;

&lt;p&gt;Comparing &quot;immediate&quot; to &quot;background&quot; I it is not clearly worth it &lt;br/&gt;
to add a background thread (unless Mike&apos;s test proves otherwise..)&lt;/p&gt;</comment>
                    <comment id="12544811" author="doronc" created="Thu, 22 Nov 2007 14:11:59 +0000"  >&lt;p&gt;With some artificial CPU activity added to the test program:&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; num files &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; num chars per file &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; No Sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Sync At End &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Background Sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; Immediate Sync &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  6690  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11516 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  10706 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11216 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  7200  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11006 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  10575 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  10846 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  8002  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  48570 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  48479 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  51825 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  7801  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  43142 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  43693 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  43342 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 16303  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 152730 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 326810 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 207939 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10000 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   100 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 17805  &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 156375 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 160040 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 165398 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

</comment>
                    <comment id="12544812" author="doronc" created="Thu, 22 Nov 2007 14:16:10 +0000"  >&lt;p&gt;Attached FSyncPerfTest.java is the standalone (non Lucene) perf test that I used.&lt;/p&gt;</comment>
                    <comment id="12545535" author="cutting" created="Mon, 26 Nov 2007 18:13:03 +0000"  >&lt;p&gt;&amp;gt; I found out however that delaying the syncs (but intending to sync) also&lt;br/&gt;
means keeping the file handles open &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Not necessarily.  You could just queue the file names for sync, close them, and then have the background thread open, sync and close them.  The close could trigger the OS to sync things faster in the background.  Then the open/sync/close could mostly be a no-op.  Might be worth a try.&lt;/p&gt;</comment>
                    <comment id="12545993" author="mikemccand" created="Tue, 27 Nov 2007 20:14:17 +0000"  >&lt;p&gt;OK I did a simplistic patch (attached) whereby FSDirectory has a&lt;br/&gt;
background thread that re-opens, syncs, and closes those files that&lt;br/&gt;
Lucene has written.  (I&apos;m using a modified version of the class from&lt;br/&gt;
Doron&apos;s test).&lt;/p&gt;

&lt;p&gt;This patch is nowhere near ready to commit; I just coded up enough so&lt;br/&gt;
we could get a rough measure of performance cost of syncing.  EG we&lt;br/&gt;
must prevent deletion of a commit point until a future commit point is&lt;br/&gt;
fully sync&apos;d to stable storage; we must also take care not to sync a&lt;br/&gt;
file that has been deleted before we sync&apos;d it; don&apos;t sync until the&lt;br/&gt;
end when running with autoCommit=false; merges if run by&lt;br/&gt;
ConcurrentMergeScheduler should &lt;span class=&quot;error&quot;&gt;&amp;#91;maybe&amp;#93;&lt;/span&gt; sync in the foreground; maybe&lt;br/&gt;
forcefully throttle back updates if syncing is falling too far behind;&lt;br/&gt;
etc.&lt;/p&gt;

&lt;p&gt;I ran the same alg as the tests above (index first 150K docs of&lt;br/&gt;
Wikipedia).  I ran CFS and no CFS X sync and nosync (4 tests) for each&lt;br/&gt;
IO system.  Time is the fastest of 2 runs:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; IO System &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; CFS sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; CFS nosync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; CFS % slower &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; non-CFS sync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; non-CFS nosync &lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; non-CFS % slower &lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; ReiserFS 6-drive RAID5 array Linux (2.6.22.1) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 188 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 19.7% &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 143 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 147 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.7% &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; EXT3 single internal drive Linux (2.6.22.1) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 173 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 10.2% &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 136 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 132 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 3.0% &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 4 drive RAID0 array Mac Pro (10.4 Tiger) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 153 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 152 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0.7% &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 150 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 149 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 0.7% &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Win XP Pro laptop, single drive &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 463 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 352 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 31.5% &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 343 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 335 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 2.4% &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; Mac Pro single external drive &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 463 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 352 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 31.5% &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 343 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 335 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 2.4% &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;The good news is, the non-CFS case shows very little cost when we do&lt;br/&gt;
BG sync&apos;ing!&lt;/p&gt;

&lt;p&gt;The bad news is, the CFS case still shows a high cost.  However, by&lt;br/&gt;
not sync&apos;ing the files that go into the CFS (and also not committing a&lt;br/&gt;
new segments_N file until after the CFS is written) I expect that cost&lt;br/&gt;
to go way down.&lt;/p&gt;

&lt;p&gt;One caveat: I&apos;m using a 8 MB RAM buffer for all of these tests.  As&lt;br/&gt;
Yonik pointed out, if you have a smaller buffer, or, you add just a&lt;br/&gt;
few docs and then close your writer, the sync cost as a pctg of net&lt;br/&gt;
indexing time will be quite a bit higher.&lt;/p&gt;</comment>
                    <comment id="12546039" author="mikemccand" created="Tue, 27 Nov 2007 22:56:33 +0000"  >&lt;p&gt;Woops, the last line in the table above is wrong (it&apos;s a copy of the line before it).  I&apos;ll re-run the test.&lt;/p&gt;</comment>
                    <comment id="12546042" author="mikemccand" created="Tue, 27 Nov 2007 23:06:08 +0000"  >
&lt;p&gt;How about if we don&apos;t sync every single commit point?&lt;/p&gt;

&lt;p&gt;I think on a crash what&apos;s important when you come back up is 1) index&lt;br/&gt;
is consistent and 2) you have not lost that many docs from your index.&lt;br/&gt;
Losing the last N (up to mergeFactor) flushes might be acceptable?&lt;/p&gt;

&lt;p&gt;EG we could force a full sync only when we commit the merge, before we&lt;br/&gt;
remove the merged segments.  This would mean on a crash that you&apos;re&lt;br/&gt;
&quot;guaranteed&quot; to have the last successfully committed &amp;amp; sync&apos;d merge to&lt;br/&gt;
fall back to, and possibly a newer commit point if the OS had sync&apos;d&lt;br/&gt;
those files on its own?&lt;/p&gt;

&lt;p&gt;That would be a big simplification because I think we could just do&lt;br/&gt;
the sync() in the foreground since ConcurrentMergeScheduler is already&lt;br/&gt;
using BG threads to do merges.&lt;/p&gt;

&lt;p&gt;This would also mean we cannot delete the commit points that were not&lt;br/&gt;
sync&apos;d.  So the first 10 flushes would result in 10 segments_N files.&lt;br/&gt;
But then when the merge of these segments completes, and the result is&lt;br/&gt;
sync&apos;d, those files could all be deleted.&lt;/p&gt;

&lt;p&gt;Plus we would have to fix retry logic on loading the segments file to&lt;br/&gt;
try more than just the 2 most recent commit points but that&apos;s a pretty&lt;br/&gt;
minor change.&lt;/p&gt;

&lt;p&gt;I think it should mean better performance, because the longer you wait&lt;br/&gt;
to call sync() presumably the more likely it is a no-op if the OS has&lt;br/&gt;
already sync&apos;d the file.&lt;/p&gt;</comment>
                    <comment id="12546051" author="cutting" created="Tue, 27 Nov 2007 23:58:03 +0000"  >&lt;p&gt;&amp;gt; How about if we don&apos;t sync every single commit point?&lt;/p&gt;

&lt;p&gt;I&apos;m confused.  The semantics of commit should be that all changes prior are made permanent, and no subsequent changes are permanent until the next commit.  So syncs, if any, should map 1:1 to commits, no?  Folks can make indexing faster by committing/syncing less often.&lt;/p&gt;</comment>
                    <comment id="12546277" author="mikemccand" created="Wed, 28 Nov 2007 15:39:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;m confused. The semantics of commit should be that all changes prior are made permanent, and no subsequent changes are permanent until the next commit. So syncs, if any, should map 1:1 to commits, no? Folks can make indexing faster by committing/syncing less often.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But must every &quot;automatic buffer flush&quot; by IndexWriter really be a&lt;br/&gt;
&quot;permanent commit&quot;?  I do agree that when you close an IndexWriter, we&lt;br/&gt;
should should do a &quot;permanent commit&quot; (and block until it&apos;s done).&lt;/p&gt;

&lt;p&gt;Even if we use that policy, the BG sync thread can still fall behind&lt;br/&gt;
such that the last few/many flushes are still in-process of being made&lt;br/&gt;
permanent (eg I see this happening while a merge is running).  In fact&lt;br/&gt;
I&apos;ll have to block further flushes if syncing falls &quot;too far&quot; behind,&lt;br/&gt;
by some metric.  So, we already won&apos;t have any &quot;guarantee&quot; on when a&lt;br/&gt;
given flush actually becomes permanent even if we adopt this policy.&lt;/p&gt;

&lt;p&gt;I think &quot;merge finished&quot; should be made a &quot;permanent commit&quot; because&lt;br/&gt;
otherwise we are tying up potentially alot of disk space,&lt;br/&gt;
temporarily.  But for a flush there&apos;s only a tiny amount of space (the&lt;br/&gt;
old segments_N files) being tied up.&lt;/p&gt;

&lt;p&gt;Maybe we could make some flushes permanent but not all, depending on&lt;br/&gt;
how far behind the sync thread is.  EG if you do a flush, but, the&lt;br/&gt;
sync thread is still trying to make the last flush permanent, don&apos;t&lt;br/&gt;
force the new flush to be permanent?&lt;/p&gt;

&lt;p&gt;In general, I think the longer we can wait after flushing before&lt;br/&gt;
forcing the OS to make those writes &quot;permanent&quot;, the better the&lt;br/&gt;
chances that the OS has in fact already sync&apos;d those files anyway, and&lt;br/&gt;
so the sync cost should be lower.  So maybe we could make every flush&lt;br/&gt;
permanent, but wait a little while before doing so?&lt;/p&gt;

&lt;p&gt;Regardless of what policy we choose here (which commits must be made&lt;br/&gt;
&quot;permanent&quot;, and, when) I think the approach requires that&lt;br/&gt;
IndexFileDeleter query the Directory so that it&apos;s only allowed to&lt;br/&gt;
delete older commit points once a newer commit point has successfully&lt;br/&gt;
become permanent.&lt;/p&gt;

&lt;p&gt;I also worry about those applications that are accidentally flushing&lt;br/&gt;
too often now.  Say your app now sets maxBufferedDocs=100.  Right now,&lt;br/&gt;
that gives you poor performance but not disastrous, but I fear if we&lt;br/&gt;
do the &quot;every commit is permanent&quot; policy then performance could&lt;br/&gt;
easily become disastrous.  People who upgrade will suddenly get much&lt;br/&gt;
worse performance.&lt;/p&gt;</comment>
                    <comment id="12546306" author="cutting" created="Wed, 28 Nov 2007 17:20:20 +0000"  >&lt;p&gt;&amp;gt; But must every &quot;automatic buffer flush&quot; by IndexWriter really be a&lt;br/&gt;
&quot;permanent commit&quot;?&lt;/p&gt;

&lt;p&gt;When autoCommit is true, then we should periodically commit automatically.  When autoCommit is false, then nothing should be committed until the IndexWriter is closed.  The ambiguous case is flush().  I think the reason for exposing flush() was to permit folks to commit without closing, so I think flush() should commit too, but we could add a separate commit() method that flushes and commits.&lt;/p&gt;

&lt;p&gt;&amp;gt; People who upgrade will suddenly get much worse performance.&lt;/p&gt;

&lt;p&gt;Yes, that would be bad.  Perhaps the semantics of autoCommit=true should be altered so that it commits less than every flush.  Is that what you were proposing?  If so, then I think it&apos;s a good solution.  Prior to 2.2 the commit semantics were poorly defined.  Folks were encouraged to close() their IndexWriter to persist changes, and that&apos;s about all we said.  2.2&apos;s docs say that things are committed at every flush, but there was no sync, so I don&apos;t think changing this could break any applications.&lt;/p&gt;

&lt;p&gt;So I&apos;m +1 for changing autoCommit=true to sync less than every flush, e.g., only after merges.  I&apos;d also argue that we should be vague in the documentation about precisely when autoCommit=true commits.  If someone needs to know exactly when things are committed then they should be encouraged to explicitly flush(), not to rely on autoCommit.&lt;/p&gt;</comment>
                    <comment id="12546309" author="mikemccand" created="Wed, 28 Nov 2007 17:33:44 +0000"  >
&lt;p&gt;I modified the CFS sync case to NOT bother syncing the files that go&lt;br/&gt;
into the CFS.  I also turned off syncing of segments.gen.  I also&lt;br/&gt;
tested on a Windows Server 2003 box.&lt;/p&gt;

&lt;p&gt;New patched attached (still a hack just to test performance!) and new&lt;br/&gt;
results.  All tests are with the &quot;sync every commit&quot; policy:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;IO System&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CFS sync&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CFS nosync&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;CFS % slower&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;non-CFS sync&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;non-CFS nosync&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;non-CFS % slower&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2 drive RAID0 Windows 2003 Server R2 Enterprise x64&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;250&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;244&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2.6%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;241&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;241&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;ReiserFS 6-drive RAID5 array Linux (2.6.22.1)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;186&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;166&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;11.9%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;145&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;142&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;EXT3 single internal drive Linux (2.6.22.1)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;160&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;158&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0.9%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;142&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;135&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;4.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;4 drive RAID0 array Mac Pro (10.4 Tiger)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;152&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;155&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-2.4%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;149&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Win XP Pro laptop, single drive&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;408&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;398&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2.6%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;343&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;346&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-1.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Mac Pro single external drive&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;211&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;209&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.0%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;167&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;149&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;12.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</comment>
                    <comment id="12546312" author="mikemccand" created="Wed, 28 Nov 2007 17:46:08 +0000"  >&lt;blockquote&gt;
&lt;p&gt;When autoCommit is true, then we should periodically commit automatically. When autoCommit is false, then nothing should be committed until the IndexWriter is closed. The ambiguous case is flush(). I think the reason for exposing flush() was to permit folks to commit without closing, so I think flush() should commit too, but we could add a separate commit() method that flushes and commits.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think deprecating flush(), renaming it to commit(), and clarifying&lt;br/&gt;
the semantics to mean that commit() flushes pending docs/deletes,&lt;br/&gt;
commits a new segments_N, syncs all files referenced by this commit,&lt;br/&gt;
and blocks until the sync is complete, would make sense?  And,&lt;br/&gt;
commit() would in fact commit even when autoCommit is false (flush()&lt;br/&gt;
doesn&apos;t commit now when autoCommit=false, which is indeed confusing).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Perhaps the semantics of autoCommit=true should be altered so that it commits less than every flush. Is that what you were proposing? If so, then I think it&apos;s a good solution. Prior to 2.2 the commit semantics were poorly defined. Folks were encouraged to close() their IndexWriter to persist changes, and that&apos;s about all we said. 2.2&apos;s docs say that things are committed at every flush, but there was no sync, so I don&apos;t think changing this could break any applications.&lt;/p&gt;

&lt;p&gt;So I&apos;m +1 for changing autoCommit=true to sync less than every flush, e.g., only after merges. I&apos;d also argue that we should be vague in the documentation about precisely when autoCommit=true commits. If someone needs to know exactly when things are committed then they should be encouraged to explicitly flush(), not to rely on autoCommit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, I will test the &quot;sync only when committing a merge&quot; approach for&lt;br/&gt;
performance.  Hopefully a foreground sync() is fine given that with&lt;br/&gt;
ConcurrentMergePolicy that&apos;s already in a background thread.  This&lt;br/&gt;
would be a nice simplification.&lt;/p&gt;

&lt;p&gt;And I agree we should be vague about, and users should never rely on,&lt;br/&gt;
precisely when Lucene has really committed (sync&apos;d) the changes to&lt;br/&gt;
disk.  I&apos;ll fix the javadocs.&lt;/p&gt;</comment>
                    <comment id="12546352" author="cutting" created="Wed, 28 Nov 2007 18:55:17 +0000"  >&lt;p&gt;&amp;gt; I think deprecating flush(), renaming it to commit()&lt;/p&gt;

&lt;p&gt;+1  That&apos;s clearer, since flushes are internal optimizations, while commits are important events to clients.&lt;/p&gt;</comment>
                    <comment id="12547122" author="mikemccand" created="Fri, 30 Nov 2007 13:10:40 +0000"  >&lt;blockquote&gt;
&lt;p&gt;You could just queue the file names for sync, close them, and then have the background thread open, sync and close them. The close could trigger the OS to sync things faster in the background. Then the open/sync/close could mostly be a no-op. Might be worth a try.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am taking this approach now, but one nagging question I have is: do&lt;br/&gt;
we know with some certainty that re-opening a file and then sync&apos;ing&lt;br/&gt;
it in fact syncs all writes that were ever done to this file in this&lt;br/&gt;
JVM, even with previously opened and now closed descriptors?  VS, eg,&lt;br/&gt;
only sync&apos;ing any new writes done with that particular descriptor?&lt;/p&gt;

&lt;p&gt;In code:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;file = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RandomAccess(path, &lt;span class=&quot;code-quote&quot;&gt;&quot;rw&quot;&lt;/span&gt;);
&amp;lt;&lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; many writes to file&amp;gt;
file.close();
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RandomAccess(path, &lt;span class=&quot;code-quote&quot;&gt;&quot;rw&quot;&lt;/span&gt;).getFD().sync();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;	

&lt;p&gt;Are we pretty sure that all of the &quot;many writes&quot; will in fact be&lt;br/&gt;
sync&apos;d by that sync call, on all OSs?&lt;/p&gt;

&lt;p&gt;I haven&apos;t been able to find convincing evidence one way or another.  I&lt;br/&gt;
did run a timing test comparing overall time if you sync with the same&lt;br/&gt;
descriptor you used for writing vs closing it, opening a new one, and&lt;br/&gt;
syncing with that one, and on Linux at least it seems both approaches&lt;br/&gt;
seem to be syncing because the total elapsed time is roughly the&lt;br/&gt;
same.&lt;/p&gt;

&lt;p&gt;Robert do you know?&lt;/p&gt;

&lt;p&gt;I sure hope the answer is yes ... because if not, the alternative is&lt;br/&gt;
we must sync() before closing the original descriptor, which makes&lt;br/&gt;
things less flexible because eg we cannot cleanly implement&lt;br/&gt;
IndexWriter.commit().&lt;/p&gt;</comment>
                    <comment id="12547168" author="mikemccand" created="Fri, 30 Nov 2007 15:00:40 +0000"  >&lt;p&gt;Another nuance here is ... say we do a &quot;soft commit&quot; (write a new&lt;br/&gt;
segment &amp;amp; segments_N but do not sync the files), and, the machine&lt;br/&gt;
crashes.  This is fine because there will always be an earlier commit&lt;br/&gt;
point (segments_M) that was a &quot;hard commit&quot; (sync was done).&lt;/p&gt;

&lt;p&gt;Then, machine comes back up and we open a reader.  The reader sees&lt;br/&gt;
both segments_M (the hard commit) and segments_N (the soft commit) and&lt;br/&gt;
chooses segments_N because it&apos;s more recent.&lt;/p&gt;

&lt;p&gt;We have retry logic in SegmentInfos to fallback to segments_M if we&lt;br/&gt;
hit an IOException on opening the index described by segments_N.&lt;/p&gt;

&lt;p&gt;But, the problem is: the extent of the &quot;corruption&quot; caused by the&lt;br/&gt;
crash could be somewhat subtle.  EG a given file might be the right&lt;br/&gt;
length, but, filled w/ zeroes.  This is a problem because we may not&lt;br/&gt;
then hit an IOException while opening the reader, but only later hit&lt;br/&gt;
some exception while searching.&lt;/p&gt;

&lt;p&gt;I think this means when we do a &quot;soft commit&quot; we should not in fact&lt;br/&gt;
write a new segments_N file (as we do today).  When we do a &quot;hard&lt;br/&gt;
commit&quot; we should first sync all files except the new segments_N file,&lt;br/&gt;
then write the segments_N file, then sync it.&lt;/p&gt;

&lt;p&gt;The thing is, while we have been (and want to continue to be) vague&lt;br/&gt;
about exactly when a &quot;commit&quot; takes place as you add docs to&lt;br/&gt;
IndexWriter, users have presumably gotten used to every flush (when&lt;br/&gt;
autoCommit=true) committing a new segments_N file that an IndexReader&lt;br/&gt;
can then see.  So, this change (do not write segments_N file except&lt;br/&gt;
for a hard commit) will break that behavior.  Maybe, with the addition&lt;br/&gt;
of the explicit commit() method, this is OK?&lt;/p&gt;</comment>
                    <comment id="12547217" author="mikemccand" created="Fri, 30 Nov 2007 17:34:52 +0000"  >&lt;p&gt;From java-dev, Robert Engels wrote:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My reading of the Unix specification shows it should work (the _commit under Windows is less clear, and since Windows is not inode based, there may be different issues).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.opengroup.org/onlinepubs/007908799/xsh/fsync.html&quot; class=&quot;external-link&quot;&gt;http://www.opengroup.org/onlinepubs/007908799/xsh/fsync.html&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK thanks Robert.&lt;/p&gt;

&lt;p&gt;I think very likely this approach (let&apos;s call it &quot;sync after close&quot;)&lt;br/&gt;
will work.  The _commit docs (for WIN32) also seems to indicate that&lt;br/&gt;
the file referenced by the descriptor is fully flushed (as we want):&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://msdn2.microsoft.com/en-us/library/17618685&quot; class=&quot;external-link&quot;&gt;http://msdn2.microsoft.com/en-us/library/17618685&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Also at least PostgreSQL and Berkeley DB &quot;trust&quot; _commit as the&lt;br/&gt;
equivalent of fsync (though I have no idea if they use it the same way&lt;br/&gt;
we want to).&lt;/p&gt;

&lt;p&gt;Though ... I am also a bit concerned about opening files for writing&lt;br/&gt;
that we had already previously closed.  It arguably makes Lucene &quot;not&lt;br/&gt;
quite&quot; write-once.  And, we may need a retry loop on syncing because&lt;br/&gt;
on Windows, various tools might wake up and peek into a file right&lt;br/&gt;
after we close them, possibly interfering w/ our reopening/syncing.&lt;/p&gt;

&lt;p&gt;I think the alternative (&quot;sync before close&quot;) is something like:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Add a new method IndexOutput.close(boolean doSync)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;When a merge finishes, it must close all of its files with&lt;br/&gt;
    doSync=true; and write the new segments_N with doSync=true.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;To implement commit() ... I think we&apos;d have to force a merge of&lt;br/&gt;
    all written segments that were not sync&apos;d.  And on closing the&lt;br/&gt;
    writer we&apos;d call commit().  This is obviously non-ideal because&lt;br/&gt;
    you can get very different sized level 1 segments out.  Although&lt;br/&gt;
    the cost would be contained since it&apos;s only up to mergeFactor&lt;br/&gt;
    level 0 segments that we will merge.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;OK ... I&apos;m leaning towards sticking with &quot;sync after close&quot;, so I&apos;ll&lt;br/&gt;
keep coding up this approach for now.&lt;/p&gt;</comment>
                    <comment id="12547351" author="cutting" created="Sat, 1 Dec 2007 00:28:00 +0000"  >&lt;p&gt;&amp;gt; I think this means when we do a &quot;soft commit&quot; we should not in fact&lt;br/&gt;
&amp;gt; write a new segments_N file (as we do today).&lt;/p&gt;

&lt;p&gt;+1  As long as we commit periodically when autoCommit=true I don&apos;t think we&apos;re breaking any previously advertised contract.&lt;/p&gt;</comment>
                    <comment id="12549104" author="mikemccand" created="Thu, 6 Dec 2007 17:33:50 +0000"  >&lt;p&gt;I&apos;ve moved this issue to 2.4.  I think it&apos;s too risky to rush it in&lt;br/&gt;
just before 2.3 is released vs committing just after 2.3 and&lt;br/&gt;
giving it more time on the trunk.&lt;/p&gt;

&lt;p&gt;But, I think for 2.3 we should revert the optional &quot;doSync&quot; argument&lt;br/&gt;
to FSDirectory: I believe the performance impact of syncing is low enough&lt;br/&gt;
with the approach we&apos;re now taking, so I don&apos;t think we should make it&lt;br/&gt;
so trivial to turn it off.  I&apos;ve added a sync() method to Directory,&lt;br/&gt;
so if someone really wants to prevent syncing they will be able to&lt;br/&gt;
subclass FSDirectory and make that method a noop.&lt;/p&gt;</comment>
                    <comment id="12549203" author="doronc" created="Thu, 6 Dec 2007 21:54:08 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Though ... I am also a bit concerned about opening files for writing&lt;br/&gt;
that we had already previously closed. It arguably makes Lucene &quot;not&lt;br/&gt;
quite&quot; write-once. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think this would work too?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;FileInputStream fis = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FileInputStream(path);
fis.getFD().sync();
fis.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12549213" author="mikemccand" created="Thu, 6 Dec 2007 22:21:16 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think this would work too?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;FileInputStream fis = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FileInputStream(path);
fis.getFD().sync();
fis.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;This was suggested &amp;amp; debated on the java-dev list. But, the man page&lt;br/&gt;
for &quot;fsync&quot; on Linux lists this as one of the errors:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;ERRORS
       EBADF  fd is not a valid file descriptor open &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; writing.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And Yonik found at least one JVM implementation (I think Harmony) that&lt;br/&gt;
simply skipped if the descriptor was not open for write.&lt;/p&gt;

&lt;p&gt;I think we&apos;re walking on thin ice if we do that...&lt;/p&gt;
</comment>
                    <comment id="12549221" author="doronc" created="Thu, 6 Dec 2007 22:42:24 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think we&apos;re walking on thin ice if we do that...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Oh, I skimmed too fast that part of the discussion in the &lt;br/&gt;
dev list.  I agree with &quot;thin ice&quot; now.&lt;/p&gt;</comment>
                    <comment id="12550704" author="mikemccand" created="Tue, 11 Dec 2007 20:20:57 +0000"  >
&lt;p&gt;Initial patch attached:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Created new commit() method; deprecated public flush() method&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed IndexWriter to not write segments_N when flushing, only&lt;br/&gt;
    when syncing (added new private sync() for this).  The current&lt;br/&gt;
    &quot;policy&quot; is to sync only after merges are committed.  When&lt;br/&gt;
    autoCommit=false we do not sync until close() or commit() is&lt;br/&gt;
    called&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added MockRAMDirectory.crash() to simulate a machine crash.  It&lt;br/&gt;
    keeps track of un-synced files, and then in crash() it goes and&lt;br/&gt;
    corrupts any unsynced files rather aggressively.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added a new unit test, TestCrash, to crash the MockRAMDirectory at&lt;br/&gt;
    various interesting times &amp;amp; make sure we can still load the&lt;br/&gt;
    resulting index.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added new Directory.sync() method.  In FSDirectory.sync, if I hit&lt;br/&gt;
    an IOException when opening or sync&apos;ing, I retry (currently after&lt;br/&gt;
    waiting 5 msec, and retrying up to 5 times).  If it still fails&lt;br/&gt;
    after that, the original exception is thrown and the new&lt;br/&gt;
    segments_N will not be written (and, the previous commit will also&lt;br/&gt;
    not be deleted).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All tests now pass, but there is still alot to do, eg at least:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Javadocs&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Refactor syncing code so DirectoryIndexReader.doCommit can use it&lt;br/&gt;
    as well.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Change format of segments_N to include a hash of its contents, at&lt;br/&gt;
    the end.  I think this is now necessary in case we crash after&lt;br/&gt;
    writing segments_N but before we can sync it, to ensure that&lt;br/&gt;
    whoever next opens the reader can detect corruption in this&lt;br/&gt;
    segments_N file.&lt;/li&gt;
&lt;/ul&gt;

</comment>
                    <comment id="12560789" author="zhanghuangzhu" created="Sun, 20 Jan 2008 09:56:39 +0000"  >&lt;p&gt;Hi, Any progress on this issue? &lt;/p&gt;

&lt;p&gt;I found sync call was removed from the source code. Is there an alternative to solve this problem? Thanks a lot!&lt;/p&gt;</comment>
                    <comment id="12560790" author="mikemccand" created="Sun, 20 Jan 2008 10:27:23 +0000"  >&lt;p&gt;This is still in progress.  It&apos;s clearly a serious bug since it&apos;s something out of your control that can easily cause index corruption.&lt;/p&gt;

&lt;p&gt;sync was removed because the simple approach is far too costly on some IO systems.  The new approach (sync only on committing a merge) has more reasonable performance, but is not quite done yet.&lt;/p&gt;</comment>
                    <comment id="12565698" author="mikemccand" created="Tue, 5 Feb 2008 10:52:57 +0000"  >&lt;p&gt;New rev of this patch.  All tests pass.  I think it&apos;s ready to&lt;br/&gt;
commit, but I&apos;ll wait a few days for comments.&lt;/p&gt;

&lt;p&gt;This patch has a small change to the segments_N file: it adds a&lt;br/&gt;
checksum to the end.  I added ChecksumIndexInput/Output that wrap an&lt;br/&gt;
existing IndexInput/Output for this.  This is used to verify the file&lt;br/&gt;
is &quot;intact&quot; before trusting its contents when opening the index.  We&lt;br/&gt;
need this to guard against the machine crashing after we&apos;ve written&lt;br/&gt;
segments_N and before we&apos;ve succeeded in syncing it.&lt;/p&gt;

&lt;p&gt;Unfortunately, in testing performance, I still see a sizable (~30-50%)&lt;br/&gt;
performance hit to indexing throughput, on windows computers (XP Pro&lt;br/&gt;
laptop &amp;amp; Win 2003 Server R64 computer).  It seems that calling sync&lt;br/&gt;
was causing IO in other threads (ie flushing a new segment) to&lt;br/&gt;
drasically slow down.  Note that this is only when autoCommit=true; if&lt;br/&gt;
it&apos;s false then performance is only slightly worse (because only on&lt;br/&gt;
closing the writer do we sync)&lt;/p&gt;

&lt;p&gt;So I tried sleeping, after writing and before syncing.  I sleep based&lt;br/&gt;
on number of bytes written, for up to 10 seconds, and amazingly, this&lt;br/&gt;
greadly reduces the performance loss on the windows computers, and&lt;br/&gt;
doesn&apos;t hurt performance on Linux/OS X computers.&lt;/p&gt;

&lt;p&gt;I think this must be because calling sync immediately forces the OS to&lt;br/&gt;
write dirty buffers to disk &quot;in a rush&quot; (severely impacting IO writes&lt;br/&gt;
from other threads), whereas if you wait first, you let the OS&lt;br/&gt;
schedule those writes on its own, at good times (maybe when IO system&lt;br/&gt;
is &quot;relatively&quot; idle).&lt;/p&gt;

&lt;p&gt;It&apos;s disappointing to have to &quot;game&quot; the OS to gain back this&lt;br/&gt;
performance.  I wish Java had a &quot;waitUntilSync&apos;d&quot; to do the same&lt;br/&gt;
things as fsync, but without &quot;rushing&quot; the OS.&lt;/p&gt;

&lt;p&gt;On Linux 2.6.22 on a RAID5 array I still see a net performance cost of&lt;br/&gt;
~12%, sleeping or no sleeping.  On Mac OS X it&apos;s ~3% loss.&lt;/p&gt;

&lt;p&gt;Other fixes:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;DirectoryIndexReader&apos;s doCommit now also syncs&lt;/li&gt;
	&lt;li&gt;Improved logic on when we must sync-before-CFS: it&apos;s not necessary&lt;br/&gt;
    if the just-merged segments are not referenced by the last commit&lt;br/&gt;
    point (ie if they were all flushed during this writer session)&lt;/li&gt;
	&lt;li&gt;Created SegmentInfos.commit() method, which writes and then syncs&lt;br/&gt;
    the next segments_N file&lt;/li&gt;
	&lt;li&gt;Simplified sync() logic now that merge threads are stopped before&lt;br/&gt;
    writer is closed&lt;/li&gt;
	&lt;li&gt;Changed CMS.newMergeThread to name its threads&lt;/li&gt;
	&lt;li&gt;More test cases&lt;/li&gt;
	&lt;li&gt;Various other small fixes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Here are test details.  I index first 200K Wikipedia docs with this&lt;br/&gt;
alg:&lt;/p&gt;

&lt;p&gt;  analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer&lt;br/&gt;
  doc.maker=org.apache.lucene.benchmark.byTask.feeds.LineDocMaker&lt;br/&gt;
  docs.file=/Volumes/External/lucene/wiki.txt&lt;br/&gt;
  doc.stored = true&lt;br/&gt;
  doc.term.vector = true&lt;br/&gt;
  doc.term.vector.offsets = true&lt;br/&gt;
  doc.term.vector.positions = true&lt;/p&gt;

&lt;p&gt;  doc.maker.forever = false&lt;br/&gt;
  directory=FSDirectory&lt;/p&gt;

&lt;p&gt;  { &quot;BuildIndex&quot;&lt;br/&gt;
    CreateIndex&lt;/p&gt;
    { &quot;AddDocs&quot; AddDoc &amp;gt; : 200000
    CloseIndex
  }

&lt;p&gt;  RepSumByPref BuildIndex&lt;/p&gt;

&lt;p&gt;Win2003 R64, JVM 1.6.0_03&lt;br/&gt;
  trunk: 523 sec&lt;br/&gt;
  patch: 547 sec (5% slower)&lt;/p&gt;

&lt;p&gt;Win XP Pro, laptop hard drive, JVM 1.4.2_15-b02&lt;br/&gt;
  trunk: 1237 sec&lt;br/&gt;
  patch: 1278 sec (3% slower)&lt;/p&gt;

&lt;p&gt;Linux ReiserFS on 6 drive RAID 5 array, JVM 1.5.0_08&lt;br/&gt;
  trunk: 483 sec&lt;br/&gt;
  patch: 539 sec (12% slower)&lt;/p&gt;

&lt;p&gt;Mac OS X 10.4 4-drive RAID 0 array, JVM 1.5.0_13&lt;br/&gt;
  trunk: 268 sec&lt;br/&gt;
  patch: 276 sec (3% slower)&lt;/p&gt;</comment>
                    <comment id="12565701" author="mikemccand" created="Tue, 5 Feb 2008 10:59:38 +0000"  >&lt;p&gt;On thinking through the above costs of committing, I now think we&lt;br/&gt;
should deprecate autoCommit=true entirely, making autocommit=false the&lt;br/&gt;
only choice in 3.0.&lt;/p&gt;

&lt;p&gt;With that change, when you use an IndexWriter, its changes are never&lt;br/&gt;
visible to a reader until you call commit() or close().  I think this&lt;br/&gt;
is how KinoSearch and Ferret work, for example.&lt;/p&gt;

&lt;p&gt;Here are some reasons:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Commit has now become a costly event, because sync() is costly,&lt;br/&gt;
    and is forcing us to use this &quot;syncPause&quot; logic (hack) to game the&lt;br/&gt;
    OS, which really is ugly, dependent on OS/IO particulars, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Since we make no guarantee on when a commit specifically happens,&lt;br/&gt;
    and this fix in particular will reduce its frequency from &quot;every&lt;br/&gt;
    flush&quot; to &quot;every merge&quot;, autoCommit=true really is not that useful&lt;br/&gt;
    for applications (ie, they will have to call commit() on their&lt;br/&gt;
    anyway if they need to rely on its frequency).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;s always possible to build an autocommit layer above&lt;br/&gt;
    IndexWriter by calling commit on your own schedule, to tradeoff&lt;br/&gt;
    performance for commit frequency (but not vice/versa).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Not autocommitting by default opens up some good future&lt;br/&gt;
    optimizations on merging since we don&apos;t have to flush real&lt;br/&gt;
    segments to disk until commit.  One simple example is we could&lt;br/&gt;
    skip building CFS files as we flush, and only merge &amp;amp; build CFS on&lt;br/&gt;
    commit/close.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What do people think?&lt;/p&gt;

&lt;p&gt;If we do this, I would right now deprecate all ctors that take&lt;br/&gt;
autoCommit and add comment explaining that in 3.0 autoCommit is wired&lt;br/&gt;
to &quot;false&quot;.  I would leave the &quot;syncPause&quot; logic in there for now,&lt;br/&gt;
because it&apos;s such a sizable performance gain on windows, but deprecate&lt;br/&gt;
it, stating that with it will be removed when we switch to&lt;br/&gt;
autoCommit=false in 3.0.&lt;/p&gt;</comment>
                    <comment id="12565815" author="cutting" created="Tue, 5 Feb 2008 17:03:17 +0000"  >&lt;p&gt;&amp;gt; deprecate autoCommit=true entirely&lt;/p&gt;

&lt;p&gt;+1  This sounds like a good plan.&lt;/p&gt;

&lt;p&gt;Are your performance numbers above with autoCommit true or false?&lt;/p&gt;

&lt;p&gt;Also, why not only sleep if Constants.WINDOWS?&lt;/p&gt;</comment>
                    <comment id="12565830" author="mikemccand" created="Tue, 5 Feb 2008 17:38:02 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; deprecate autoCommit=true entirely&lt;/p&gt;

&lt;p&gt;+1 This sounds like a good plan.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;OK I&apos;ll work out a new patch with this approach.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Are your performance numbers above with autoCommit true or false?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;They were all with autoCommit=true.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Also, why not only sleep if Constants.WINDOWS?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good, I&apos;ll take that approach!&lt;/p&gt;</comment>
                    <comment id="12565894" author="mikemccand" created="Tue, 5 Feb 2008 21:19:00 +0000"  >&lt;p&gt;OK I updated the patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Deprecate all IW ctors that take autoCommit param, and updated javadocs stating that autoCommit will be hardwired to false starting in 3.0&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Default maxSyncPause to 10 seconds when Constant.WINDOWS; else, to 0&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll wait until end of week to commit!&lt;/p&gt;</comment>
                    <comment id="12567190" author="mikemccand" created="Fri, 8 Feb 2008 20:31:59 +0000"  >&lt;p&gt;Attached new rev of the patch.  Only changes were to add caveats in javadcos about IO devices that ignore fsync, and, updated patch to apply cleanly on current trunk.&lt;/p&gt;

&lt;p&gt;I plan to commit in a day or two.&lt;/p&gt;</comment>
                    <comment id="12675759" author="yeliz" created="Mon, 23 Feb 2009 04:22:34 +0000"  >&lt;p&gt;I had been following this thread. Just curious if the patch was committed.&lt;/p&gt;</comment>
                    <comment id="12675841" author="mikemccand" created="Mon, 23 Feb 2009 10:22:24 +0000"  >&lt;p&gt;Yes, this is committed and available as of 2.4.0.&lt;/p&gt;</comment>
                    <comment id="12675983" author="yeliz" created="Mon, 23 Feb 2009 17:15:03 +0000"  >&lt;p&gt;Thanks Michael!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12370069" name="FSyncPerfTest.java" size="5999" author="doronc" created="Thu, 22 Nov 2007 14:16:10 +0000" />
                    <attachment id="12368942" name="LUCENE-1044.patch" size="5823" author="mikemccand" created="Sun, 4 Nov 2007 15:28:33 +0000" />
                    <attachment id="12368948" name="LUCENE-1044.take2.patch" size="7573" author="mikemccand" created="Sun, 4 Nov 2007 18:29:22 +0000" />
                    <attachment id="12369061" name="LUCENE-1044.take3.patch" size="16750" author="mikemccand" created="Tue, 6 Nov 2007 22:38:47 +0000" />
                    <attachment id="12370344" name="LUCENE-1044.take4.patch" size="7648" author="mikemccand" created="Tue, 27 Nov 2007 20:14:17 +0000" />
                    <attachment id="12371455" name="LUCENE-1044.take5.patch" size="87961" author="mikemccand" created="Tue, 11 Dec 2007 20:20:57 +0000" />
                    <attachment id="12374759" name="LUCENE-1044.take6.patch" size="198188" author="mikemccand" created="Tue, 5 Feb 2008 10:52:56 +0000" />
                    <attachment id="12374819" name="LUCENE-1044.take7.patch" size="210132" author="mikemccand" created="Tue, 5 Feb 2008 21:19:00 +0000" />
                    <attachment id="12375106" name="LUCENE-1044.take8.patch" size="211091" author="mikemccand" created="Fri, 8 Feb 2008 20:31:59 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>9.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 3 Nov 2007 05:22:50 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12701</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26685</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>