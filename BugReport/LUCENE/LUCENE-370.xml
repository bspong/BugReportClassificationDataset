<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:01:57 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-370/LUCENE-370.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-370] BooleanQuery assumes everything else implements skipTo</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-370</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;skipTo seems to be optional functionality on the Scorer class (BooleanScorer&lt;br/&gt;
doesn&apos;t implement it).  BooleanQuery.scorer() tests all subclauses using&lt;br/&gt;
&quot;instanceof BooleanQuery&quot; to determine if it can use a ConjunctionScorer that&lt;br/&gt;
requires skipTo functionality.&lt;/p&gt;

&lt;p&gt;This means that any other new Query/Scorer that don&apos;t implement skipTo will get&lt;br/&gt;
into trouble when included in a BooleanQuery.&lt;/p&gt;

&lt;p&gt;If skipTo is really optional, then there should be some way of telling by the&lt;br/&gt;
Scorer or the Query in a more generic manner.&lt;/p&gt;

&lt;p&gt;Some options:&lt;br/&gt;
1) have a &quot;boolean Scorer.hasSkipTo()&quot; method&lt;br/&gt;
2) have a &quot;boolean Query.hasSkipTo()&quot; method&lt;br/&gt;
3) remove Scorer.skipTo and have a &quot;public interface ScorerSkipTo&lt;/p&gt;
{boolean
skipTo(int doc)}
&lt;p&gt;&quot; that scorers may implement&lt;/p&gt;</description>
                <environment>&lt;p&gt;Operating System: other&lt;br/&gt;
Platform: All&lt;/p&gt;</environment>
            <key id="12314520">LUCENE-370</key>
            <summary>BooleanQuery assumes everything else implements skipTo</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Tue, 12 Apr 2005 08:24:53 +0100</created>
                <updated>Thu, 27 Oct 2005 06:45:50 +0100</updated>
                    <resolved>Thu, 27 Oct 2005 06:45:50 +0100</resolved>
                            <version>1.4</version>
                                <fixVersion>1.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12322278" author="paul.elschot@xs4all.nl" created="Tue, 12 Apr 2005 17:00:19 +0100"  >&lt;p&gt;Yonik, &lt;/p&gt;

&lt;p&gt;Please have a look at bug 33019. &lt;/p&gt;

&lt;p&gt;The point you make here is not mentioned there. &lt;br/&gt;
With term doc enumerator implementing skipTo, all scorers &lt;br/&gt;
can implement skipTo efficiently. &lt;br/&gt;
During development of a new scorer one can temporarily use the code &lt;br/&gt;
shown in the javadocs of Scorer that implements skipTo with &lt;br/&gt;
next() and doc(). &lt;br/&gt;
Btw. it also possible to implement next() as skipTo(doc() + 1). &lt;/p&gt;

&lt;p&gt;A bit of history: &lt;br/&gt;
The early versions of Lucene did not have skipTo on term doc enumerators. &lt;br/&gt;
At some point (1.2 ?) Doug added this and used it in ConjunctionScorer, which &lt;br/&gt;
proved to be a great speedup for a BooleanQuery that requires all terms. &lt;/p&gt;

&lt;p&gt;For a smooth transition of adding skipTo on the remaining scorers it &lt;br/&gt;
might be worthwhile to add the code mentioned in the javadocs of Scorer &lt;br/&gt;
as the default implementation of skipTo. &lt;br/&gt;
This needs to be investigated, so I&apos;m making bug 33019 dependent on this &lt;br/&gt;
one. &lt;/p&gt;

&lt;p&gt;Thanks for bringing this up, &lt;/p&gt;

&lt;p&gt;Regards, &lt;br/&gt;
Paul Elschot &lt;/p&gt;
</comment>
                    <comment id="12322279" author="yseeley@gmail.com" created="Wed, 13 Apr 2005 01:32:16 +0100"  >&lt;p&gt;Thanks for the reference Paul, looks like some pretty cool stuff!&lt;/p&gt;

&lt;p&gt;&amp;gt; With term doc enumerator implementing skipTo, all scorers &lt;br/&gt;
&amp;gt; can implement skipTo efficiently. &lt;br/&gt;
Well, maybe all scorers currently in Lucene that is.  The Scorer hierarchy looks&lt;br/&gt;
like it means to be open (users can implement their own).  Requiring all scorers&lt;br/&gt;
to implement skipTo is a pretty high hurdle, esp when there is a backup&lt;br/&gt;
execution plan already implemented that works without it.&lt;/p&gt;

&lt;p&gt;&amp;gt; During development of a new scorer one can temporarily use the code &lt;br/&gt;
&amp;gt; shown in the javadocs of Scorer that implements skipTo with &lt;br/&gt;
&amp;gt; next() and doc(). &lt;/p&gt;

&lt;p&gt;I&apos;m not sure I can do that.&lt;br/&gt;
What I&apos;m trying to do is develop a replacement for RangeQuery that is fast and&lt;br/&gt;
&lt;b&gt;always&lt;/b&gt; works (no expanding to BooleanQuery).  I don&apos;t even care about scoring&lt;br/&gt;
since it almost never makes sense for a RangeQuery.  Using the same techniques&lt;br/&gt;
as RangeFilter, I think it should be pretty easy to do, except for implementing&lt;br/&gt;
skipTo.&lt;/p&gt;

&lt;p&gt;It seems like skipTo for UnscoredRangeQuery would require either enumerating&lt;br/&gt;
&lt;b&gt;all&lt;/b&gt; docs beforehand (store in a BitSet or whatever), or keeping a termdoc&lt;br/&gt;
enumerator open for every term in the range.  Neither option seems attractive.&lt;/p&gt;

&lt;p&gt;-Yonik&lt;/p&gt;
</comment>
                    <comment id="12322280" author="paul.elschot@xs4all.nl" created="Wed, 13 Apr 2005 04:46:02 +0100"  >&lt;p&gt;(In reply to comment #2) &lt;br/&gt;
... &lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; &amp;gt; During development of a new scorer one can temporarily use the code  &lt;br/&gt;
&amp;gt; &amp;gt; shown in the javadocs of Scorer that implements skipTo with  &lt;br/&gt;
&amp;gt; &amp;gt; next() and doc().  &lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; I&apos;m not sure I can do that. &lt;br/&gt;
&amp;gt; What I&apos;m trying to do is develop a replacement for RangeQuery that is fast &lt;br/&gt;
and &lt;br/&gt;
&amp;gt; &lt;b&gt;always&lt;/b&gt; works (no expanding to BooleanQuery).  I don&apos;t even care about &lt;br/&gt;
scoring &lt;br/&gt;
&amp;gt; since it almost never makes sense for a RangeQuery.  Using the same &lt;br/&gt;
techniques &lt;br/&gt;
&amp;gt; as RangeFilter, I think it should be pretty easy to do, except for &lt;br/&gt;
implementing &lt;br/&gt;
&amp;gt; skipTo. &lt;/p&gt;

&lt;p&gt;A scorer that is only used in isolation or on the top level &lt;br/&gt;
will only have next() called. &lt;br/&gt;
For these it is safe to throw an UnsupportedOperationException &lt;br/&gt;
from skipTo(). &lt;/p&gt;

&lt;p&gt;For an OR like query one could use the same technique as RangeFilter &lt;br/&gt;
by using the scorers of the clauses separately. You might call this &lt;br/&gt;
a DisjunctionFilter. &lt;/p&gt;

&lt;p&gt;Each of the separate scorers could implement skipTo(), but it wouldn&apos;t &lt;br/&gt;
normally be used. &lt;br/&gt;
Using skipTo would be only useful for very dense results to skip to &lt;br/&gt;
the doc corresponding to the next unset bit in the BitSet. &lt;br/&gt;
However, such dense results are not normal for text searching. &lt;/p&gt;

&lt;p&gt;Once a BitSet filter is available bug 32965 can also be useful. &lt;br/&gt;
This uses skipTo on the scorer of the filtered query &lt;br/&gt;
to skip over documents not present in the filter. &lt;/p&gt;

&lt;p&gt;&amp;gt;  &lt;br/&gt;
&amp;gt; It seems like skipTo for UnscoredRangeQuery would require either enumerating &lt;br/&gt;
&amp;gt; &lt;b&gt;all&lt;/b&gt; docs beforehand (store in a BitSet or whatever), or keeping a termdoc &lt;br/&gt;
&amp;gt; enumerator open for every term in the range.  Neither option seems &lt;br/&gt;
attractive. &lt;/p&gt;

&lt;p&gt;skipTo() requires that the documents are accessed in order. That means some &lt;br/&gt;
form of sorting is needed: for example a PriorityQueue with all termdoc &lt;br/&gt;
enumerators open, or a BitSet for distribution sort. &lt;br/&gt;
BooleanScorer with skipTo allowed uses a form of distribution sort &lt;br/&gt;
(the buckets) combined with local sorting. &lt;br/&gt;
Other methods are also  possible, eg. merge sort, but these are currently &lt;br/&gt;
not used in Lucene scorers. &lt;/p&gt;

&lt;p&gt;BooleanScorer without skipTo uses distribution and an incomplete form &lt;br/&gt;
of sorting by working over intervals of document numbers. &lt;br/&gt;
I don&apos;t think scoring disjunctions can be made faster than that. &lt;br/&gt;
Since the sorting is not complete, the next() method does not guarantee &lt;br/&gt;
that documents are accessed in order. BooleanScorers without skipTo &lt;br/&gt;
using the same interval can be nested nicely, though. &lt;/p&gt;

&lt;p&gt;Regards, &lt;br/&gt;
Paul Elschot &lt;/p&gt;
</comment>
                    <comment id="12322281" author="yseeley@gmail.com" created="Wed, 13 Apr 2005 06:57:13 +0100"  >&lt;p&gt;Paul, thanks for the reference to 32965... more very interesting stuff.  I&apos;m new&lt;br/&gt;
at this scorer stuff - trying to wrap my mind around it all...&lt;/p&gt;

&lt;p&gt;My motivation for a RangeQuery is not making it faster for the average case,&lt;br/&gt;
it&apos;s making it possible in any scenario (any place in a query, any number of&lt;br/&gt;
terms, etc).&lt;/p&gt;

&lt;p&gt;We have some search collections with over 100M documents.  Now imagine a range&lt;br/&gt;
query on a unique id field... I don&apos;t think any method utilizing 100M termdoc&lt;br/&gt;
enumerators is really feasible (am I understanding correctly?)&lt;/p&gt;

&lt;p&gt;As for speed, I guess I could have my planned UnscoredRangeQuery.rewrite()&lt;br/&gt;
return a BooleanQuery if the number of terms are small enough, otherwise use&lt;br/&gt;
another method such as a simple scorer that doesn&apos;t implement skipTo().&lt;/p&gt;

&lt;p&gt;-Yonik&lt;/p&gt;</comment>
                    <comment id="12322282" author="paul.elschot@xs4all.nl" created="Wed, 13 Apr 2005 17:03:37 +0100"  >&lt;p&gt;(In reply to comment #4) &lt;br/&gt;
.. &lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; My motivation for a RangeQuery is not making it faster for the average case, &lt;br/&gt;
&amp;gt; it&apos;s making it possible in any scenario (any place in a query, any number of &lt;br/&gt;
&amp;gt; terms, etc). &lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; We have some search collections with over 100M documents.  Now imagine a &lt;br/&gt;
range &lt;br/&gt;
&amp;gt; query on a unique id field... I don&apos;t think any method utilizing 100M termdoc &lt;br/&gt;
&amp;gt; enumerators is really feasible (am I understanding correctly?) &lt;/p&gt;

&lt;p&gt;This is very similar to a date range. Try searching for this on the web: &lt;/p&gt;

&lt;p&gt;yyyy yyyymm yyyymmdd lucene &lt;/p&gt;

&lt;p&gt;The results are getting dense in this way, and for performance &lt;br/&gt;
you might consider caching (intermediate) results in (BitSet) filters. &lt;br/&gt;
Lucene itself is meant for smaller numbers of results. &lt;/p&gt;

&lt;p&gt;100M docs means about 12Mbyte per BitSet filter. When your filters  &lt;br/&gt;
contain fewer docs than 12M and you need many filters you might &lt;br/&gt;
consider the sparse filters of bug 32921 . However, these filters &lt;br/&gt;
require skipTo on all their filtered scorers, meaning that they require &lt;br/&gt;
the development version of BooleanQuery at the moment. &lt;/p&gt;

&lt;p&gt;Regards, &lt;br/&gt;
Paul Elschot &lt;/p&gt;

&lt;p&gt;P.S. Perhaps someone is interested in writing a story about &lt;br/&gt;
Lucene and the ordered document skippers. It&apos;s getting a bit involved. &lt;/p&gt;
</comment>
                    <comment id="12332149" author="paul.elschot@xs4all.nl" created="Sun, 16 Oct 2005 00:51:54 +0100"  >&lt;p&gt;I think all scorers in the trunk implement skipTo() now, so this can be closed.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                <customfieldname>Bugzilla Id</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>34407</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 12 Apr 2005 16:00:19 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13379</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27361</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>