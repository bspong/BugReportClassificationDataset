<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:03:15 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1634/LUCENE-1634.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1634] LogMergePolicy should use the number of deleted docs when deciding which segments to merge</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1634</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I found that IndexWriter.optimize(int) method does not pick up large segments with a lot of deletes even when most of the docs are deleted. And the existence of such segments affected the query performance significantly.&lt;/p&gt;

&lt;p&gt;I created an index with 1 million docs, then went over all docs and updated a few thousand at a time.  I ran optimize(20) occasionally. What saw were large segments with most of docs deleted. Although these segments did not have valid docs they remained in the directory for a very long time until more segments with comparable or bigger sizes were created.&lt;/p&gt;

&lt;p&gt;This is because LogMergePolicy.findMergeForOptimize uses the size of segments but does not take the number of deleted documents into consideration when it decides which segments to merge. So, a simple fix is to use the delete count to calibrate the segment size. I can create a patch for this.&lt;/p&gt;
</description>
                <environment></environment>
            <key id="12425234">LUCENE-1634</key>
            <summary>LogMergePolicy should use the number of deleted docs when deciding which segments to merge</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="ymatsuda">Yasuhiro Matsuda</reporter>
                        <labels>
                    </labels>
                <created>Tue, 12 May 2009 17:32:39 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:24 +0100</updated>
                    <resolved>Sat, 16 May 2009 16:59:22 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12708496" author="ymatsuda" created="Tue, 12 May 2009 17:40:41 +0100"  >&lt;p&gt;I posted a patch.&lt;/p&gt;</comment>
                    <comment id="12708898" author="mikemccand" created="Wed, 13 May 2009 13:24:49 +0100"  >&lt;p&gt;Actually, optimize() always merges all segments down to 1,&lt;br/&gt;
irrespective of deletes.  I think you&apos;re referring to &quot;normal&quot; merges?&lt;/p&gt;

&lt;p&gt;I think this approach is reasonable and a good step forward.  Can you&lt;br/&gt;
make this behaviour get/settable?  I think we should default to the&lt;br/&gt;
old behaviour until 3.0, and then switch it to default to the new one&lt;br/&gt;
at 3.0 (to preserve back compat).&lt;/p&gt;

&lt;p&gt;Thinking more about this... I think we can further improve how&lt;br/&gt;
Log*MergePolicy takes deletes into account.  Ie, why not explicitly&lt;br/&gt;
measure the deletions and bias merge selection to favor merging away&lt;br/&gt;
segments that have the most deletions?&lt;/p&gt;

&lt;p&gt;This might require relaxing the merge policy so that it&apos;s allowed to&lt;br/&gt;
pick fewer than mergeFactor segments to merge at once; perhaps it&apos;s&lt;br/&gt;
given a min/max mergeFactor.&lt;/p&gt;

&lt;p&gt;Likely such a change should be a new merge policy...&lt;/p&gt;</comment>
                    <comment id="12708986" author="john.wang@gmail.com" created="Wed, 13 May 2009 17:12:03 +0100"  >&lt;p&gt;This is actually referring to the optimize(int) call, which selectively merges segments to make sure the total segments in the index is less or equal to the specified number.&lt;/p&gt;</comment>
                    <comment id="12708989" author="john.wang@gmail.com" created="Wed, 13 May 2009 17:16:35 +0100"  >&lt;p&gt;Comment on implementing a custom merge policy:&lt;br/&gt;
As the API current stands, I think the behavior is to assume a subclass of LogMergePolicy. And one cannot subclass LogMergePolicy without injecting the class into the org.apache.lucene.index package, (because the api signature: size(org.apache.lucene.index.SegmentInfo info), SegmentInfo is not an exposed API.&lt;/p&gt;</comment>
                    <comment id="12708991" author="mikemccand" created="Wed, 13 May 2009 17:20:32 +0100"  >&lt;blockquote&gt;&lt;p&gt;This is actually referring to the optimize(int) call&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh, woops &amp;#8211; sorry, I missed that the first time around.  But I don&apos;t think the patch addresses how optimize(int) selects its merges?&lt;/p&gt;</comment>
                    <comment id="12708993" author="mikemccand" created="Wed, 13 May 2009 17:23:16 +0100"  >&lt;blockquote&gt;&lt;p&gt;As the API current stands, I think the behavior is to assume a subclass of LogMergePolicy.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm &amp;#8211; that&apos;s not intended.  What goes wrong if you use a custom MergePolicy that&apos;s not a LogMergePolicy?&lt;/p&gt;

&lt;p&gt;(There are utility methods on IndexWriter, eg set/getUseCompoundFile, etc., that will only work if your MergePolicy is a LogMergePolicy, but that shouldn&apos;t prevent you from using a non-LogMergePolicy as long as you don&apos;t use these utility methods).&lt;/p&gt;</comment>
                    <comment id="12708995" author="john.wang@gmail.com" created="Wed, 13 May 2009 17:29:36 +0100"  >&lt;p&gt;The current lucene implementation, optimize(int) selects segments to merge based on the file size of the segment file: say the index has 10 segments, and optmize(6) is called,  Lucene finds 4 smallest segments by number of bytes in the segment files. &lt;/p&gt;

&lt;p&gt;This selection criteria is flawed because you can have a very large segment in terms of bytes but very small in terms of numDocs (if many deleted docs). Having these segment files around impacts performance considerably. &lt;/p&gt;

&lt;p&gt;This is what this patch is trying to fix this in a non-intrusive manner by extending the LogMergePolicy and by normalizing the calculation of the segment size including the delete count.&lt;/p&gt;</comment>
                    <comment id="12708999" author="mikemccand" created="Wed, 13 May 2009 17:42:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;say the index has 10 segments, and optmize(6) is called, Lucene finds 4 smallest segments by number of bytes in the segment files.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh yeah, you&apos;re right: for the last (partial) merge, it uses the size() of the segments to pick the merge that&apos;s minimal total size.&lt;/p&gt;

&lt;p&gt;So let&apos;s proceed with this patch, once you&apos;ve added setter/getter.&lt;/p&gt;

&lt;p&gt;I&apos;d still love to see a merge policy that does a better job explicitly &quot;targeting&quot; segments with lots of deletions.&lt;/p&gt;</comment>
                    <comment id="12709002" author="john.wang@gmail.com" created="Wed, 13 May 2009 17:49:07 +0100"  >&lt;p&gt;RE: implementing custom MergePolicy&lt;br/&gt;
Let me describe in detail on problems of implementing a custom MergePolicy:&lt;/p&gt;

&lt;p&gt;1) In IndexWriter code, such methods on MergePolicy is called, e.g. findMergesForOptimize. I believe that is the contract for implementing your own MergePolicy. However, it is &quot;hidden&quot; by the javadoc in terms of documentation, and furthermore, it is hidden because these methods are package protected. So to implement your own MergePolicy, you have to resort back to sneaking the class into the package.&lt;/p&gt;

&lt;p&gt;2) Not only seg/getUseCompoundFile is no longer applicable if LogMergePolicy is not used, also popular methods such as set/getMergeFactor etc. are only applicable to LogMergePolicy. (Just to clarify, useCompoundFile is a package-level protected method on the base MergePolicy class, so my guess is that set/getCompoundFile should be applicable to all implementations of MergePolicy.&lt;/p&gt;

&lt;p&gt;This brings up another issue about the practice of having to &quot;sneak&quot; classes into a package. We are looking at making our Lucene code, OSGI compliant, and this becomes an issue because we cannot have multiple &quot;bundles&quot; exporting the same package. Which means, I would have to repackage lucene to include my classes that I have snuck into some lucene packages. I would like to use a standard distribution of  a lucene jar (as suggested/echoed by some luceners).&lt;/p&gt;</comment>
                    <comment id="12709003" author="john.wang@gmail.com" created="Wed, 13 May 2009 17:54:03 +0100"  >&lt;p&gt;&amp;gt;&amp;gt; So let&apos;s proceed with this patch, once you&apos;ve added setter/getter.&lt;br/&gt;
Can you please elaborate on this? Add setter/getter on what? The number of target segment is already an input parameter? do you mean some sort of normalization factor on the how much to &quot;punish&quot; segments with high deleted docs?&lt;/p&gt;</comment>
                    <comment id="12709004" author="mikemccand" created="Wed, 13 May 2009 18:01:22 +0100"  >&lt;p&gt;I mean a setter/getter to turn on/off &quot;taking deletions into account&quot; in Log*MergePolicy.&lt;/p&gt;</comment>
                    <comment id="12709015" author="mikemccand" created="Wed, 13 May 2009 18:22:44 +0100"  >&lt;blockquote&gt;&lt;p&gt;So to implement your own MergePolicy, you have to resort back to sneaking the class into the package.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, this is currently necessary for a custom MergePolicy/Scheduler.  It&apos;s been discussed before:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://www.nabble.com/MergePolicy-public-but-SegmentInfos-package-protected--tt22687527.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/MergePolicy-public-but-SegmentInfos-package-protected--tt22687527.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I suppose since merge selection needs so little info about a segment, we could make a public thine wrapper/veneer that exposes a limited number of things.  Or maybe we go whole hog and simply make SegmentInfos/SegmentInfo public.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;it is hidden because these methods are package protected&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we could javadoc certain package protected classes, that&apos;d give you the javadocs at least.  Or we should simply make these methods public?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Not only seg/getUseCompoundFile is no longer applicable if LogMergePolicy is not used, also popular methods such as set/getMergeFactor etc. are only applicable to LogMergePolicy.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But the notion of a mergeFactor is very much a LogMergePolicy specific thing.  Other merge policies might not limit themselves to always merging mergeFactor segments at once.  These are convenience methods on IndexWriter (that simply forward the request to the MergePolicy).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;my guess is that set/getCompoundFile should be applicable to all implementations of MergePolicy&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;d make sense.  (I can&apos;t remember exactly why, but way back when, I think there was some reason for not doing so...)&lt;/p&gt;</comment>
                    <comment id="12709024" author="john.wang@gmail.com" created="Wed, 13 May 2009 18:41:40 +0100"  >&lt;p&gt;&amp;gt;&amp;gt;I mean a setter/getter to turn on/off &quot;taking deletions into account&quot; in Log*MergePolicy.&lt;br/&gt;
Makes sense. What do you suggest the default behavior to be?&lt;br/&gt;
Also, do you think setter/getter is the right approach, since this is very much hidden to the API, e.g. one would have to do this:&lt;/p&gt;

&lt;p&gt;LogMergePolicy policy = (LogMergePolicy)idxWriter.getMergePolicy();&lt;br/&gt;
policy.setTurnOnSegmentCalcWithDeletes(true);&lt;/p&gt;

&lt;p&gt;DO you think instead, we can just add static setter/getter on LogMergePolicy class?&lt;/p&gt;</comment>
                    <comment id="12709080" author="mikemccand" created="Wed, 13 May 2009 20:19:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;What do you suggest the default behavior to be?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think default to no change, and in 3.0 we flip it?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;DO you think instead, we can just add static setter/getter on LogMergePolicy class?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d lean towards non-static setter/getters.&lt;/p&gt;</comment>
                    <comment id="12709210" author="ymatsuda" created="Thu, 14 May 2009 00:26:24 +0100"  >&lt;p&gt;I added setCalibrateSizeByDeletes/getCalibrateSizeByDeletes. Sorry that the method names are a bit too wordy.&lt;/p&gt;</comment>
                    <comment id="12709441" author="mikemccand" created="Thu, 14 May 2009 16:44:24 +0100"  >&lt;p&gt;Patch looks good, thanks Yasuhiro.  I plan to commit in a day or two.&lt;/p&gt;</comment>
                    <comment id="12710123" author="mikemccand" created="Sat, 16 May 2009 16:59:22 +0100"  >&lt;p&gt;Thanks Yasuhiro!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12408065" name="LUCENE-1634.patch" size="3802" author="ymatsuda" created="Thu, 14 May 2009 00:26:24 +0100" />
                    <attachment id="12407891" name="LUCENE-1634.patch" size="2318" author="ymatsuda" created="Tue, 12 May 2009 17:40:41 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 13 May 2009 12:24:49 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12124</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26094</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>