<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:33:06 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1426/LUCENE-1426.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1426] Next steps towards flexible indexing</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1426</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;In working on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1410&quot; title=&quot;PFOR implementation&quot;&gt;&lt;del&gt;LUCENE-1410&lt;/del&gt;&lt;/a&gt; (PFOR compression) I tried to prototype&lt;br/&gt;
switching the postings files to use PFOR instead of vInts for&lt;br/&gt;
encoding.&lt;/p&gt;

&lt;p&gt;But it quickly became difficult.  EG we currently mux the skip data&lt;br/&gt;
into the .frq file, which messes up the int blocks.  We inline&lt;br/&gt;
payloads with positions which would also mess up the int blocks.&lt;br/&gt;
Skipping offsets and TermInfo offsets hardwire the file pointers of&lt;br/&gt;
frq &amp;amp; prox files yet I need to change these to block + offset, etc.&lt;/p&gt;

&lt;p&gt;Separately this thread also started up, on how to customize how Lucene&lt;br/&gt;
stores positional information in the index:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-user/66264&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-user/66264&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So I decided to make a bit more progress towards &quot;flexible indexing&quot;&lt;br/&gt;
by first modularizing/isolating the classes that actually write the&lt;br/&gt;
index format.  The idea is to capture the logic of each (terms, freq,&lt;br/&gt;
positions/payloads) into separate interfaces and switch the flushing&lt;br/&gt;
of a new segment as well as writing the segment during merging to use&lt;br/&gt;
the same APIs.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12406798">LUCENE-1426</key>
            <summary>Next steps towards flexible indexing</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Mon, 20 Oct 2008 13:38:16 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:09 +0100</updated>
                    <resolved>Sat, 25 Oct 2008 11:40:06 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12640995" author="mikemccand" created="Mon, 20 Oct 2008 13:41:00 +0100"  >&lt;p&gt;Attached patch.  I think it&apos;s ready to commit... I&apos;ll wait a few days.&lt;/p&gt;

&lt;p&gt;This factors the writing of postings into separate Format* classes.&lt;br/&gt;
The approach I took is similar to what I did for DocumentsWriter,&lt;br/&gt;
where there is a hierarchical consumer interface (abstract class) for&lt;br/&gt;
each of fields, terms, docs, and positions writing.  Then there&apos;s a&lt;br/&gt;
corresponding set of concrete classes (the &quot;codec chain&quot;) that write&lt;br/&gt;
today&apos;s index format.  There is no change to the index format.&lt;/p&gt;

&lt;p&gt;Here are the details:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;This only applies to postings (not stored fields, term vectors,&lt;br/&gt;
    norms, field infos)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Both SegmentMerger &amp;amp; FreqProxTermsWriter now use the same codec&lt;br/&gt;
    API to write postings.  I think this is a big step forward: we now&lt;br/&gt;
    have a single set of classes that ever write the postings.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You can&apos;t yet customize this codec chain; we can add that at some&lt;br/&gt;
    point.  It&apos;s all package private.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I don&apos;t yet allow the codec to override SegmentInfo.files(); at&lt;br/&gt;
    some point (when I first try to make a codec that uses different&lt;br/&gt;
    files) I will add this.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I ran a quick performance test, indexing wikipedia, and found&lt;br/&gt;
negligible performance cost of this.&lt;/p&gt;

&lt;p&gt;The next step, which is trickier, is to modularize/genericize the&lt;br/&gt;
classes the read from the index, and then refactor&lt;br/&gt;
SegmentTerm&lt;/p&gt;
{Enum,Docs,Positions}
&lt;p&gt; to use that codec API.&lt;/p&gt;

&lt;p&gt;Then, finally, I want to make a codec that uses PFOR to encode&lt;br/&gt;
postings.&lt;/p&gt;</comment>
                    <comment id="12641121" author="paul.elschot@xs4all.nl" created="Mon, 20 Oct 2008 19:58:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;We inline payloads with positions which would also mess up the int blocks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which begs the question whether we should also allow compression of these payloads.&lt;br/&gt;
I think we should do that because normally only one or two bytes will be used as payload per position.&lt;br/&gt;
Thinking about this: position+payload actually looks a lot like docId+freq, could that&lt;br/&gt;
be used to simplify future index formats for inverted terms?&lt;br/&gt;
Btw. allowing a payload to accompany the field norms would allow to store a kind of&lt;br/&gt;
dictionary for the position payloads. This could help to keep the position payloads small&lt;br/&gt;
so they would compress nicely.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Both SegmentMerger &amp;amp; FreqProxTermsWriter now use the same codec API to write postings.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is indeed a big step.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s all package private.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good for now, making it public might actually reduce flexibility for new index formats.&lt;/p&gt;
</comment>
                    <comment id="12641125" author="paul.elschot@xs4all.nl" created="Mon, 20 Oct 2008 20:07:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;Skipping offsets and TermInfo offsets hardwire the file pointers of  frq &amp;amp; prox files yet I need to change these to block + offset, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Does the offset imply that there is also a need for random access into each block?&lt;br/&gt;
For such blocks PFOR patching might better be avoided.&lt;br/&gt;
Even with patching random access is possible, but it is not available yet at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1410&quot; title=&quot;PFOR implementation&quot;&gt;&lt;del&gt;LUCENE-1410&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12641128" author="eksdev" created="Mon, 20 Oct 2008 20:27:48 +0100"  >&lt;p&gt;Just a few random thoughts on this topic&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I am sure I read somewhere in these pdfs that were floating around that it would make sense to use VInts for very short postings and PFOR for the rest. I just do not remember rationale behind it.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;During omitTf() discussion, we came up with cool idea to actually inline very short postings into term dict instead of storing offset. This way we spare one seek per term in many cases, as well as some space for storing offset. I do not know if this is a problem, but sounds reasonable. With standard Zipfian distribution, a lot of postings should get inlined. Use cases where we have query expansion on many terms (think spell checker, synonyms ...) should benefit from that heavily. These postings are small but there is a lot of them, so it adds up... seek is deadly &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I am sorry to miss the party here with PFOR, but let us hope this credit crunch gets over soon so I that I could dedicate some time to fun things like this &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;cheers, eks &lt;/p&gt;


</comment>
                    <comment id="12641132" author="cutting" created="Mon, 20 Oct 2008 20:51:11 +0100"  >&lt;p&gt;+1 This sounds like a great way to approach flexible indexing: incrementally.&lt;/p&gt;</comment>
                    <comment id="12641137" author="mikemccand" created="Mon, 20 Oct 2008 20:57:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;During omitTf() discussion, we came up with cool idea to actually inline very short postings into term dict instead of storing offset.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, there&apos;s this issue:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1278&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-1278&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And you had found this one:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://www.siam.org/proceedings/alenex/2008/alx08_01transierf.pdf&quot; class=&quot;external-link&quot;&gt;http://www.siam.org/proceedings/alenex/2008/alx08_01transierf.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And then Doug referenced this:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://citeseer.ist.psu.edu/cutting90optimizations.html&quot; class=&quot;external-link&quot;&gt;http://citeseer.ist.psu.edu/cutting90optimizations.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I think the idea makes tons of sense (saving a seek) and one of my&lt;br/&gt;
goals in phase 2 (genericizing the reading of an index) is to make&lt;br/&gt;
pulsing a drop-in codec as an example &amp;amp; litmus test.  Terms iteration&lt;br/&gt;
may suffer, though, unless we put this in a separate file.&lt;/p&gt;

&lt;p&gt;I also think, at the opposite end of the spectrum, it would make sense&lt;br/&gt;
for very common terms to use simple n-bit packing (PFOR minus the&lt;br/&gt;
exceptions).  For massive terms we need the fastest search we can&lt;br/&gt;
get, since that gates when you have to start sharding.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I am sorry to miss the party here with PFOR, but let us hope this credit crunch gets over soon so I that I could dedicate some time to fun things like this&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well the stock market seems to think the credit crunch is improving,&lt;br/&gt;
today... of course who knows what&apos;ll happen tomorrow!  Good luck &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Also, I&apos;d like to explore improving the terms dict indexing &amp;#8211; I don&apos;t&lt;br/&gt;
think we need to load a TermInfo instance for every indexed term, into&lt;br/&gt;
RAM.  I think we just need the term &amp;amp; seek data (into the tis file),&lt;br/&gt;
then you seek there and skip to the TermInfo you need.  This should&lt;br/&gt;
save a good amount of RAM for large indices with odd terms, sicne each&lt;br/&gt;
TermInfo instance requires a pointer to it (4 or 8 bytes), an object&lt;br/&gt;
header (8 bytes at least) then 20 bytes for the members.&lt;/p&gt;

&lt;p&gt;All these explorations should become simple drop-in codecs, once I can&lt;br/&gt;
finish phase 2.&lt;/p&gt;</comment>
                    <comment id="12641139" author="mikemccand" created="Mon, 20 Oct 2008 21:07:15 +0100"  >
&lt;blockquote&gt;
&lt;p&gt;Does the offset imply that there is also a need for random access into each block?&lt;br/&gt;
For such blocks PFOR patching might better be avoided.&lt;br/&gt;
Even with patching random access is possible, but it is not available yet at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1410&quot; title=&quot;PFOR implementation&quot;&gt;&lt;del&gt;LUCENE-1410&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah this is one of the reasons why I&apos;m thinking for frequent terms we&lt;br/&gt;
may want to fallback to pure nbit packing (which would make random&lt;br/&gt;
access simple).&lt;/p&gt;

&lt;p&gt;But, for starters would could simply implement random access as &quot;load&lt;br/&gt;
&amp;amp; decode the entire block, then look at the part you want&quot; and then&lt;br/&gt;
assess the cost.  While it will clearly increase the cost of queries&lt;br/&gt;
that do alot of skipping (eg AND query of N terms), it may not matter&lt;br/&gt;
so much since these queries should be fairly fast now.  It&apos;s the OR of&lt;br/&gt;
frequent term queries that we need to improve since that limits how&lt;br/&gt;
big an index you can put on one box.&lt;/p&gt;</comment>
                    <comment id="12641140" author="mikemccand" created="Mon, 20 Oct 2008 21:11:18 +0100"  >
&lt;blockquote&gt;&lt;p&gt;Which begs the question whether we should also allow compression of these payloads.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s interesting, but would probably be rather application dependent.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Btw. allowing a payload to accompany the field norms would allow to store a kind of&lt;br/&gt;
dictionary for the position payloads. This could help to keep the position payloads small&lt;br/&gt;
so they would compress nicely.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Couldn&apos;t stored fields, once they are faster (with column-stride&lt;br/&gt;
fields, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1231&quot; title=&quot;Column-stride fields (aka per-document Payloads)&quot;&gt;&lt;del&gt;LUCENE-1231&lt;/del&gt;&lt;/a&gt;) solve this?&lt;/p&gt;</comment>
                    <comment id="12641574" author="michaelbusch" created="Tue, 21 Oct 2008 21:26:36 +0100"  >&lt;blockquote&gt;
&lt;p&gt;+1 This sounds like a great way to approach flexible indexing: incrementally. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Couldn&apos;t agree more. This is great!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The next step, which is trickier, is to modularize/genericize the&lt;br/&gt;
classes the read from the index, and then refactor&lt;br/&gt;
SegmentTerm(Enum,Docs,Positions) to use that codec API.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes this is definitely the tricky part. I&apos;ve been thinking a bit about this and was wondering if for the read APIs we could do something similar as with the new Token API (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1422&quot; title=&quot;New TokenStream API&quot;&gt;&lt;del&gt;LUCENE-1422&lt;/del&gt;&lt;/a&gt;)? TermDocs could have a list of Attributes that the posting list offers. If for example no payloads are stored in the posting list, then TermDocs should not offer that corresponding Attribute.&lt;br/&gt;
This approach should be just as fast as the current API. When the application opens a TermDocs, it could check for the offered Attributes before it starts iterating the postinglist, and keep references to the Attribute. (in fact that&apos;s exactly the same approach as the TokenStream/Token/Consumer approach in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1422&quot; title=&quot;New TokenStream API&quot;&gt;&lt;del&gt;LUCENE-1422&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12641599" author="paul.elschot@xs4all.nl" created="Tue, 21 Oct 2008 22:17:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;... it would make sense to use VInts for very short postings and PFOR for the rest. I just do not remember rationale behind it.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;... cool idea to actually inline very short postings into term dict instead of storing offset.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Iirc the rationale was that PFOR has most performance benefits on integer arrays of more than 100 elements.&lt;br/&gt;
Shorter lists of numbers might also benefit from using (P)FOR instead of VInt, I don&apos;t know how big the break even size is.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;for starters (we) could simply implement random access as &quot;load &amp;amp; decode the entire block, then look at the part you want&quot; and then assess the cost.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve just started some performance tests on PFOR patching (i.e. filling in the exceptions), and I&apos;m not happy with what I&apos;m seeing. More on this later at 1410.&lt;/p&gt;


&lt;p&gt;On allowing a payload to accompany the field norms:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Couldn&apos;t stored fields, once they are faster (with column-stride fields, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1231&quot; title=&quot;Column-stride fields (aka per-document Payloads)&quot;&gt;&lt;del&gt;LUCENE-1231&lt;/del&gt;&lt;/a&gt;) solve this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;</comment>
                    <comment id="12641747" author="mikemccand" created="Wed, 22 Oct 2008 10:18:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;TermDocs could have a list of Attributes that the posting list offers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this approach.&lt;/p&gt;

&lt;p&gt;Though unlike &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1422&quot; title=&quot;New TokenStream API&quot;&gt;&lt;del&gt;LUCENE-1422&lt;/del&gt;&lt;/a&gt;, where Token remains separate from&lt;br/&gt;
TokenStream (and I&apos;m still not sure it should be...?), I think for&lt;br/&gt;
TermDocs there would not be the analog of a separate Token.&lt;br/&gt;
Ie, it would look something like this:&lt;/p&gt;

&lt;p&gt;  myPerDocAttr = termDocs.getAttribute(MyPerDoc.class);&lt;/p&gt;

&lt;p&gt;  while(termDocs.next()) &lt;/p&gt;
{
    x = myPerDocAttr.getValue(...);
  }

&lt;p&gt;However, this form of flexibility is actually beyond what I&apos;m aiming&lt;br/&gt;
for, for the first step of reader flexibility (there are so many&lt;br/&gt;
facets of &quot;flexible indexing&quot;!).&lt;/p&gt;

&lt;p&gt;For starters I&apos;d like to allow flexibility on how you encode the&lt;br/&gt;
existing postings (doc/freq/positions/payloads).  Whereas this&lt;br/&gt;
flexibility is in extending what stuff is actually stored into &amp;amp; read&lt;br/&gt;
from the index.  I think we should do both, but my focus now is on the&lt;br/&gt;
first one, specifically to be able to drop in a codec that uses&lt;br/&gt;
pulsing, a less RAM-intestive terms dict indexing, and/or PFOR, etc.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12348413">LUCENE-662</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12392474" name="LUCENE-1426.patch" size="62569" author="mikemccand" created="Mon, 20 Oct 2008 13:41:00 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 20 Oct 2008 18:58:53 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12325</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26302</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>