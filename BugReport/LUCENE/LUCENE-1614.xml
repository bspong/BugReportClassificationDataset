<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:29:22 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1614/LUCENE-1614.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1614] Add next() and skipTo() variants to DocIdSetIterator that return the current doc, instead of boolean</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1614</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;See &lt;a href=&quot;http://www.nabble.com/Another-possible-optimization---now-in-DocIdSetIterator-p23223319.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/Another-possible-optimization---now-in-DocIdSetIterator-p23223319.html&lt;/a&gt; for the full discussion. The basic idea is to add variants to those two methods that return the current doc they are at, to save successive calls to doc(). If there are no more docs, return -1. A summary of what was discussed so far:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Deprecate those two methods.&lt;/li&gt;
	&lt;li&gt;Add nextDoc() and skipToDoc(int) that return doc, with default impl in DISI (calls next() and skipTo() respectively, and will be changed to abstract in 3.0).
	&lt;ul&gt;
		&lt;li&gt;I actually would like to propose an alternative to the names: advance() and advance(int) - the first advances by one, the second advances to target.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Wherever these are used, do something like &apos;(doc = advance()) &amp;gt;= 0&apos; instead of comparing to -1 for improved performance.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I will post a patch shortly&lt;/p&gt;</description>
                <environment></environment>
            <key id="12423757">LUCENE-1614</key>
            <summary>Add next() and skipTo() variants to DocIdSetIterator that return the current doc, instead of boolean</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Sat, 25 Apr 2009 05:47:52 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:22 +0100</updated>
                    <resolved>Wed, 15 Jul 2009 21:22:09 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12703228" author="mikemccand" created="Mon, 27 Apr 2009 18:34:05 +0100"  >&lt;p&gt;Shai did you forget to attach patch here?  Or maybe you&apos;re just busy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12703233" author="shaie" created="Mon, 27 Apr 2009 18:40:36 +0100"  >&lt;p&gt;No I did not forget - I need to work on it (trying to juggle all the issues I opened &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) ... in general I don&apos;t like to work on overlapping issues and this overlaps with 1593 (it will touch some of the same files). But I can start working on the patch - it looks much simpler than 1593 ...&lt;/p&gt;

&lt;p&gt;One thing I wanted to get feedback on is the proposal to use advance() and advance(target). Let&apos;s decide on that now, so that I don&apos;t need to &quot;refactor&quot; everything afterwards &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12703251" author="creamyg" created="Mon, 27 Apr 2009 19:07:24 +0100"  >&lt;p&gt;&amp;gt; advance() and advance(int)&lt;/p&gt;

&lt;p&gt;In the interest of coherent email exchanges, I think it would be best to give&lt;br/&gt;
these methods distinct names, e.g. &quot;nudge&quot; and &quot;advance&quot;.&lt;/p&gt;</comment>
                    <comment id="12703291" author="shaie" created="Mon, 27 Apr 2009 19:53:02 +0100"  >&lt;p&gt;nudge doesn&apos;t sound like it changes anything, but just &quot;touches&quot;. So if distinct method names is what we&apos;re after, I prefer nextDoc() and skipToDoc() or advance() for the latter.&lt;/p&gt;</comment>
                    <comment id="12703660" author="creamyg" created="Tue, 28 Apr 2009 15:42:33 +0100"  >&lt;p&gt;&amp;gt; nudge doesn&apos;t sound like it changes anything, but just &quot;touches&quot;.&lt;/p&gt;

&lt;p&gt;If you say so.  In Lucy, I expect we&apos;ll use &quot;next&quot; and &quot;advance&quot;.  &lt;/p&gt;

&lt;p&gt;&amp;gt; if distinct method names is what we&apos;re after&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s the idea.  These two methods are very different from each other.&lt;br/&gt;
The official definition of skipTo() has many subtle gotchas.  Just because&lt;br/&gt;
they both move the iterator forward doesn&apos;t mean they do the same thing, and&lt;br/&gt;
it is cumbersome and taxing to have to differentiate between methods using&lt;br/&gt;
long-form signatures in the midst of standard prose.&lt;/p&gt;

&lt;p&gt;There&apos;s no good reason to conflate these two methods, just as there&apos;s no &lt;br/&gt;
good reason why we should be forced to write &quot;search(Collector)&quot; instead&lt;br/&gt;
of &quot;collect()&quot; or &quot;collectHits()&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; I prefer nextDoc() and skipToDoc() or advance() for the latter. &lt;/p&gt;

&lt;p&gt;IMO, &quot;advance&quot; more accurately describes what that method does than either&lt;br/&gt;
&quot;skipTo&quot; or &quot;skipToDoc&quot;.  The problem is that if you&apos;re on doc 10, then&lt;br/&gt;
skipToDoc(10) doesn&apos;t, in fact, skip to doc 10 as the method name implies &amp;#8211;&lt;br/&gt;
it takes you to at least doc 11.  Furthermore, &quot;advance&quot; reinforces that you&lt;br/&gt;
can only seek forwards.&lt;/p&gt;</comment>
                    <comment id="12703677" author="creamyg" created="Tue, 28 Apr 2009 16:29:54 +0100"  >&lt;p&gt;Further illustration...&lt;/p&gt;

&lt;p&gt;Good method signature overloading, from IndexReader.java:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  public static boolean indexExists(String directory)

  public static boolean indexExists(File directory)

  public static boolean indexExists(Directory directory);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bad method signature overloading, from Searcher.java:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  public Hits search(Query query, Filter filter, Sort sort)

  public TopFieldDocs search(Query query, Filter filter, int n, Sort sort)

  public void search(Query query, HitCollector results)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IMO, those three methods on Searcher should be named hits(), topFieldDocs(),&lt;br/&gt;
and collect(), rather than search(), search(), and search(), making code that&lt;br/&gt;
uses those methods more self documenting, and making it easier to discuss them&lt;br/&gt;
out of context.&lt;/p&gt;

&lt;p&gt;For the same reasons, we should have different names for nextDoc() and&lt;br/&gt;
advance().&lt;/p&gt;</comment>
                    <comment id="12704223" author="mikemccand" created="Wed, 29 Apr 2009 18:44:13 +0100"  >&lt;p&gt;Maybe nextDoc and advanceToDoc?&lt;/p&gt;

&lt;p&gt;Re: skipTo doing alot.... one thing that&apos;s missing from&lt;br/&gt;
DISI is method &quot;advance to doc X then return a boolean&lt;br/&gt;
telling me if you accept that doc, but do not do a next()&quot;.  In&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1536&quot; title=&quot;if a filter can support random access API, we should use it&quot;&gt;&lt;del&gt;LUCENE-1536&lt;/del&gt;&lt;/a&gt; in some cases we gain sizable performance by using such an&lt;br/&gt;
API with a relatively sparse filter against a relatively expensive&lt;br/&gt;
(BooleanScorer2) scorer.  Though &quot;filter as BooleanClause&quot; may undo&lt;br/&gt;
these performance gains.&lt;/p&gt;
</comment>
                    <comment id="12704229" author="shaie" created="Wed, 29 Apr 2009 19:15:39 +0100"  >&lt;p&gt;Whoa ! so many emails on this list that I completely missed the last two posts by Marvin (sorry about that Marvin).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe nextDoc and advanceToDoc? (or Matvin&apos;s nextDoc() and advance())&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m fine with nextDoc(). About advance, I think I prefer advance(int target) for the sake of not repeating the same information twice (i.e., advance*ToDoc*(int &lt;b&gt;target&lt;/b&gt;)). So if I see a line like this: &lt;b&gt;disi.advance(15)&lt;/b&gt; I think it&apos;s understood exactly as &lt;b&gt;disi.advanceToDoc(15)&lt;/b&gt;, only the latter is longer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;advance to doc X then return a boolean telling me if you accept that doc, but do not do a next()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What do you mean &quot;do not do a next()&quot;? Let&apos;s say I have a DISI that can return docs 1, 3, 7, 10 but it doesn&apos;t know so in advance. When you call skipTo(8), it must reach 7, then figure it&apos;s less than 8 and do a next() to land on 10. Do you mean that it should return false in that case, and not move from 7 to 10? Since it already moved, and let&apos;s assume it cannot go back (at least efficiently), that means it should remember the last skipTo called was 8 and it is on 10, so if it is requested to skip to 9, it should return false again ... is that what you meant?&lt;/p&gt;</comment>
                    <comment id="12704302" author="mikemccand" created="Wed, 29 Apr 2009 21:04:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think I prefer advance(int target)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK +1.  Nice and succinct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What do you mean &quot;do not do a next()&quot;? Let&apos;s say I have a DISI that can return docs 1, 3, 7, 10 but it doesn&apos;t know so in advance. When you call skipTo(8), it must reach 7, then figure it&apos;s less than 8 and do a next() to land on 10. Do you mean that it should return false in that case, and not move from 7 to 10? Since it already moved, and let&apos;s assume it cannot go back (at least efficiently), that means it should remember the last skipTo called was 8 and it is on 10, so if it is requested to skip to 9, it should return false again ... is that what you meant?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I mean the scorer should go straight to the doc I asked for and test whether it accepts that doc and do nothing else.  Call this api &quot;boolean check(int doc)&quot; for now.&lt;/p&gt;

&lt;p&gt;It&apos;d be useful for more interesting scorers.  EG ConjunctionScorer.check would simply call check on each sub-scorer, stopping early if any return false; this is less work than what it does today.&lt;/p&gt;

&lt;p&gt;You&apos;re right, for the TermScorer case nothing is saved since it uses next internally to determine if a doc matches.&lt;/p&gt;</comment>
                    <comment id="12704462" author="shaie" created="Thu, 30 Apr 2009 04:35:21 +0100"  >&lt;blockquote&gt;&lt;p&gt;I mean the scorer should go straight to the doc I asked for and test whether it accepts that doc and do nothing else.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Just to clarify for myself, in the example I gave above, suppose thar the scorer is on &quot;3&quot; and you call check(8). Do you expect it to go to 10, realize that 8 is not supported and go back to 3? Can it be called with check(7) afterwards? If not, then why not use advance(8), get back 10 and realize 8 is not supported? You should be able to call advance(9) without it advancing beyond 10 (which it&apos;s currently on).&lt;/p&gt;

&lt;p&gt;Your comment on TermScorer just reinforces my confusion - what is this API good for, and what&apos;s missing in advance(target) today? Can&apos;t ConjunctionScorer call advance until it gets a response which is not what was asked for?&lt;/p&gt;</comment>
                    <comment id="12704522" author="shaie" created="Thu, 30 Apr 2009 09:03:38 +0100"  >&lt;p&gt;I think I understand what you mean, but please correct me if I&apos;m wrong. You propose this check() so that in case a DISI can save any extra operations it does in next() (such as reading a payload for example) it will do so. Therefore in the example you give above with CS, next()&apos;s contract forces it to advance all the sub-scorers, but with check() it could stop in the middle.&lt;/p&gt;

&lt;p&gt;This warrants an explicit documentation and implementation by current DISIs ... I don&apos;t think that if you call a DISI today with next(10) and next(10) it will not move to 11 in the second call. But calling check(10) and next(10) MUST not advance the DISI further than 10. If the default impl in DISI just uses nextDoc() and returns true if the return value is the requested, we should be safe back-compat-wise, but this is still dangerous and we need clear documentation.&lt;/p&gt;

&lt;p&gt;BTW, perhaps a testAndSet-like version can save check(10) followed by a next(10), and will fit nicer?&lt;/p&gt;</comment>
                    <comment id="12704556" author="mikemccand" created="Thu, 30 Apr 2009 11:03:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;Just to clarify for myself, in the example I gave above, suppose thar the scorer is on &quot;3&quot; and you call check(8).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;On check(8), TermScorer would go to 10, stop there, and return false.  (It would not &quot;rewind&quot; to 3).  Check can only be called on increasing arguments, so it&apos;s not truly &quot;random access&quot;.  It&apos;s &quot;forward only random access&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You propose this check() so that in case a DISI can save any extra operations it does in next() (such as reading a payload for example) it will do so. Therefore in the example you give above with CS, next()&apos;s contract forces it to advance all the sub-scorers, but with check() it could stop in the middle.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Precisely.&lt;/p&gt;

&lt;p&gt;This is important when you have a super-cheap iterator (say a somewhat sparse (&amp;lt;=10%?) in-memory filter that&apos;s represented as list-of-docIDs).  It&apos;s very fast for such a filter to iterate over its docIDs.  But when that iterator is AND&apos;d with a Scorer, as is done today by IndexSearcher, they effectively play &quot;leap frog&quot;, where first it&apos;s the filter&apos;s turn to next(), then it&apos;s the Scorer&apos;s turn, etc.  But for the Scorer, next() can be extremely costly, only to find the filter doesn&apos;t accept it.  So for such situations it&apos;s better to let the filter drive the search, calling Scorer.check() on the docs.&lt;/p&gt;

&lt;p&gt;But... once we switch to filter-as-BooleanClause, it&apos;s less clear whether check() is worthwhile, because I think the filter&apos;s constraint is more efficiently taken into account.&lt;/p&gt;

&lt;p&gt;For filters that support random access (if they are less sparse, say &amp;gt;= 25% or so), we should push them all the way down to the TermScorers and factor them in just like deletedDocs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;. If the default impl in DISI just uses nextDoc() and returns true if the return value is the requested, we should be safe back-compat-wise, but this is still dangerous and we need clear documentation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes it does have a good default impl, I think.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, perhaps a testAndSet-like version can save check(10) followed by a next(10), and will fit nicer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure what you mean by &quot;testAndSet-like version&quot;?&lt;/p&gt;</comment>
                    <comment id="12704566" author="shaie" created="Thu, 30 Apr 2009 11:39:31 +0100"  >&lt;blockquote&gt;&lt;p&gt;Not sure what you mean by &quot;testAndSet-like version&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I mean, instead of having the code call check(8), get true and then advance(8), just call checkAndAdvance(8) which returns true if 8 is supported and false otherwise, AND moves to 8. I don&apos;t propose to replace check() with it as sometimes you might want to check a couple of DISIs before making a decision to which doc to advance, but it could save calling advance() in case check() returns true.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes it does have a good default impl, I think.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It &lt;em&gt;will&lt;/em&gt; have a good default impl, I can guarantee to try &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. What I meant is that we should have clear documentation about check() and nextDoc() and the possibility that check will be called for doc Id &apos;X&apos; and later nextDoc or advance will be called with &apos;X&apos;, in that case the impl must ensure &apos;X&apos; is not skipped, as is done today by TermScorer for example.&lt;/p&gt;

&lt;p&gt;So should I add this check()?&lt;/p&gt;</comment>
                    <comment id="12704631" author="mikemccand" created="Thu, 30 Apr 2009 14:30:04 +0100"  >&lt;blockquote&gt;&lt;p&gt;I mean, instead of having the code call check(8), get true and then advance(8), just call checkAndAdvance(8) which returns true if 8 is supported and false otherwise, AND moves to 8.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh, sorry: that&apos;s in fact what I intended check to do.  But by &quot;moves to 8&quot; what it really means is &quot;you now cannot call check on anything &amp;lt; 8 (maybe 9)&quot;&lt;/p&gt;

&lt;p&gt;I think after check(N) is called, one cannot call doc() &amp;#8211; the results are not defined.  So check(N) logically puts the iterator at N, and you may at that point call next if you want, or call another check(M) but you cannot call doc() right after check.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So should I add this check()?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think so?  We can then do perf tests of that vs filter-as-BooleanClause?&lt;/p&gt;</comment>
                    <comment id="12704632" author="mikemccand" created="Thu, 30 Apr 2009 14:30:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;So should I add this check()?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Though, in order to run perf tests, we&apos;d need the AND/OR scorers to efficiently implement check().&lt;/p&gt;</comment>
                    <comment id="12704633" author="shaie" created="Thu, 30 Apr 2009 14:38:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think after check(N) is called, one cannot call doc()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think one cannot even call next(). If check(8) returns true, then you know that doc() will return 8 (otherwise it&apos;s a bug?). But if it returns false, it might be in 10 already, so calling next() will move it to 11 or something. So to be on the safe side, we should document that doc()&apos;s result is unspecified if check() returns false, and next() is not recommended in that case, but skipTo() or check(M).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Though, in order to run perf tests, we&apos;d need the AND/OR scorers to efficiently implement check().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I plan to, as much as I can, efficiently implement nextDoc() and advance() in all Scorers/DISIs. So I can include check() in the list as well. Or .. maybe you know something I don&apos;t and you think this should deserve its own issue?&lt;/p&gt;</comment>
                    <comment id="12704665" author="mikemccand" created="Thu, 30 Apr 2009 16:24:35 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think one cannot even call next().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, yeah I think you&apos;re right.  We could perhaps make this an entirely different interface (abstract class).  Ie, one should not mix and match &quot;checking&quot; with &quot;next/advance&quot;ing.  In the case I can think of, at least, it&apos;s an up-front decision as to which scorer does next vs check.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So I can include check() in the list as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think including it in this issue is fine.&lt;/p&gt;</comment>
                    <comment id="12704760" author="shaie" created="Thu, 30 Apr 2009 20:48:29 +0100"  >&lt;p&gt;Ok I&apos;ll start with just adding nextDoc and advance, deprecate the old ones, implement in all extending classes and modify current code which uses DISI. Then, we can see how to proceed with check() and whether it should be part of this issue or another one.&lt;/p&gt;

&lt;p&gt;I have a feeling my last couple of issues just grew larger the more we discussed them, so I hope to keep this one containable &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12705003" author="mikemccand" created="Fri, 1 May 2009 15:33:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;Then, we can see how to proceed with check() and whether it should be part of this issue or another one.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fair enough!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I have a feeling my last couple of issues just grew larger the more we discussed them, so I hope to keep this one containable &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Alas this is what happens when you tackle tricky issues... sort of like pulling out that innocent looking thread sticking out on the bottom of your shirt &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12710365" author="shaie" created="Mon, 18 May 2009 14:36:34 +0100"  >&lt;p&gt;I started to work on that issue and noticed the javadoc of skipTo: &quot;Skips entries to the first &lt;b&gt;beyond&lt;/b&gt; the current whose document number is greater than or equal to target&quot;. That together with the code example implies that if a set has docs 9, 10, 11 and I call skipTo(10) and then doc() I&apos;ll get 10 the first time and 11 the second time (meaning two consecutive calls to skipTo with the same target return different results).&lt;/p&gt;

&lt;p&gt;I was wondering if we want to change it, i.e., have advance do something like that:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (doc() &amp;lt; target) {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!next()) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; -1;
}
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; doc();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think this behavior is more accurate, at least in terms of semantics.&lt;/p&gt;</comment>
                    <comment id="12710381" author="mikemccand" created="Mon, 18 May 2009 16:18:53 +0100"  >&lt;p&gt;I would tentatively prefer that change in semantics.&lt;/p&gt;</comment>
                    <comment id="12710384" author="yseeley@gmail.com" created="Mon, 18 May 2009 16:38:26 +0100"  >&lt;p&gt;An implementation certainly shouldn&apos;t be required to carry state such that skipTo(10) called twice will yield different results.&lt;br/&gt;
A bigger question though, is if we should support skipTo(doc) where doc&amp;lt;=current at all. That&apos;s sort of how I read &quot;Skips entries to the first beyond the current&quot;... that you shouldn&apos;t be calling skipTo(doc) unless doc&amp;gt;current.&lt;/p&gt;

&lt;p&gt;If we do want to define skipTo(doc) whendoc&amp;lt;=current, then I agree it should be as you describe.&lt;/p&gt;

&lt;p&gt;(edited to avoid JIRA markup &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;</comment>
                    <comment id="12710386" author="creamyg" created="Mon, 18 May 2009 16:38:57 +0100"  >&lt;p&gt;&amp;gt; if a set has docs 9, 10, 11 and I call skipTo(10) and then doc() I&apos;ll get 10 &lt;br/&gt;
&amp;gt; the first time and 11 the second time &lt;/p&gt;

&lt;p&gt;&amp;gt; I was wondering if we want to change it,&lt;/p&gt;

&lt;p&gt;I agree that your proposed definition is more intuitive.  I think it &lt;br/&gt;
might make TermScorer.advance() a tad less efficient, though,&lt;br/&gt;
because it would be necessary to check the current doc first.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; skipTo(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; target) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-comment&quot;&gt;// first scan in cache
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (pointer++; pointer &amp;lt; pointerMax; pointer++) {
       &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (docs[pointer] &amp;gt;= target) {
         doc = docs[pointer];
         &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
       }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There might be others, as well. I&apos;d be concerned if something&lt;br/&gt;
low-level like TermDocs or TermPositions was affected &lt;br/&gt;
negatively.  It seems likely, because we&apos;d be changing from&lt;br/&gt;
&quot;advance, then check state&quot; to &quot;check state, then advance, &lt;br/&gt;
then check state&quot;. &lt;/p&gt;

&lt;p&gt;Funny, but this is actually closer to &quot;skip to&quot; than &quot;advance&quot;, since&lt;br/&gt;
under this proposal, the iterator would not always advance.  &lt;/p&gt;</comment>
                    <comment id="12710646" author="shaie" created="Tue, 19 May 2009 08:07:56 +0100"  >&lt;blockquote&gt;&lt;p&gt;A bigger question though, is if we should support skipTo(doc) where doc&amp;lt;=current at all&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we should support it and it wasn&apos;t the intention in the first place. If we do want to support it than a different name for the method is required, such as seek(target) or moveTo(target).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Funny, but this is actually closer to &quot;skip to&quot; than &quot;advance&quot;, since under this proposal, the iterator would not always advance.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I actually don&apos;t see it like that. skipTo and advance both imply that the iterator moves forward (as opposed to seek). However I don&apos;t think that when you say &quot;advance to X&quot; it means the iterator should move. The result of that command should put the iterator on X or beyond (if X does not exist). If the iterator is already on X, I don&apos;t think it should do anything.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;An implementation certainly shouldn&apos;t be required to carry state such that skipTo(10) called twice will yield different results.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure if by that you agree with me or disagree (maybe I&apos;m misreading it). From the iterators I&apos;ve modified already, calling skipTo(10) multiple times always yields the same result. Those are the ones that operate on BitSet. They never check their state, but just skip to wherever they&apos;re requested.&lt;/p&gt;

&lt;p&gt;In case you disagree, I&apos;d like to ask why is it bad to request the implementation to remember its state? I think that all implementations already store the doc Id in case doc() will be called following skipTo, so in a sense they already remember their state. In addition, checking if the current doc Id is not the target is something I believe most will do - if they don&apos;t need to, like the bit-set variants, then they don&apos;t do it. If they cannot really skip to a target, but are forced to call next() until target is reached, they already check their state and so it does not add any overhead.&lt;/p&gt;

&lt;p&gt;To me, calling skipTo or advance with the same target multiple times and get different result every time is weird. I&apos;d like to change that semantic, but if you strongly disagree, then we should at least document it.&lt;/p&gt;</comment>
                    <comment id="12710744" author="shaie" created="Tue, 19 May 2009 15:34:16 +0100"  >&lt;p&gt;Patch introduces the two added methods, as well as changes to our tests and code to utilize the new versions. All tests pass.&lt;/p&gt;

&lt;p&gt;I did not add check() yet, since I&apos;d like to have this patch reviewed first, and then decide whether check() should be handled in that issue or not, and to get a hint of which Scorers / DISIs it should actually affect.&lt;/p&gt;</comment>
                    <comment id="12710826" author="shaie" created="Tue, 19 May 2009 19:31:28 +0100"  >&lt;p&gt;BTW, as I prepared that patch, I noticed the same improvement can be applied to TermDocs. However it&apos;s an interface and so we&apos;re stuck with back-compat, and replacing it with an abstract class means spending too much energy, at least on finding a better name &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. What do you think?&lt;/p&gt;</comment>
                    <comment id="12710827" author="mikemccand" created="Tue, 19 May 2009 19:31:49 +0100"  >&lt;p&gt;I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?&lt;/p&gt;

&lt;p&gt;This would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.  It&apos;d be one fewer if to check, per sub-scorer per nextDoc/advance call, which would be a nice savings.&lt;/p&gt;

&lt;p&gt;This is what I&apos;m doing on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1594&quot; title=&quot;Use source code specialization to maximize search performance&quot;&gt;&lt;del&gt;LUCENE-1594&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12710838" author="yseeley@gmail.com" created="Tue, 19 May 2009 20:26:45 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; A bigger question though, is if we should support skipTo(doc) where doc&amp;lt;=current at all&lt;br/&gt;
&amp;gt; I don&apos;t think we should support it and it wasn&apos;t the intention in the first place. &lt;/p&gt;

&lt;p&gt;OK... I had read your proposal as saying you wanted skipTo(10) twice in a row to return 10 both times (assuming it matched).&lt;br/&gt;
Marvin seemed to believe the same thing.&lt;/p&gt;

&lt;p&gt;&amp;gt;  In case you disagree, I&apos;d like to ask why is it bad to request the implementation to remember its state?&lt;/p&gt;

&lt;p&gt;I don&apos;t disagree, but requiring some implementations to keep and check state would mean less efficient implementations.&lt;/p&gt;

&lt;p&gt;&amp;gt; To me, calling skipTo or advance with the same target multiple times and get different result every time is weird. I&apos;d like to change that semantic&lt;/p&gt;

&lt;p&gt;But I thought we had just agreed that skipTo(doc) is well defined only for doc&amp;gt;current? (see &quot;bigger question&quot; point above).&lt;br/&gt;
If we all agree that , then we don&apos;t need to worry about skipTo(10) being called twice in a row.&lt;/p&gt;</comment>
                    <comment id="12710841" author="shaie" created="Tue, 19 May 2009 20:37:19 +0100"  >&lt;blockquote&gt;&lt;p&gt;I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The idea was to return a negative value and then compare the returned value to &amp;gt;= 0 for better performance. If we return MAX_VAL we&apos;ll need to compare to MAX_VAL, which is less efficient, CPU wise.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I thought we had just agreed that skipTo(doc) is well defined only for doc&amp;gt;current?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure - didn&apos;t we agree for &amp;gt;= current? An example are two iterators, one over 1, 3, 8, 11 and another on 2, 5, 9, 11. Let&apos;s say that you ask both for advance(9). The first one lands on 11 and the second on 9. Then you ask both to advance to 11 again - the first one returns &quot;no more results&quot; and the second one lands on 11.&lt;/p&gt;

&lt;p&gt;I have to be honest though that I&apos;m not sure to which scenario that matches, I just had a feeling that calling advance(X) while the iterator is on X is something we may run in to and therefore we should make sure to return X. BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I had read your proposal as saying you wanted skipTo(10) twice in a row to return 10 both times (assuming it matched)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s exactly what I meant &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12710844" author="yseeley@gmail.com" created="Tue, 19 May 2009 20:39:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;This would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But for scorers that use a priority queue, does checking and immediately removing from the queue (hence making the heap smaller) offer any advantages?  I had assumed so since this is what current scorers do.  Immediately removing scorers also causes early termination for minimumNrMatchers&amp;gt;1 in DisjunctionSumScorer.&lt;/p&gt;</comment>
                    <comment id="12710846" author="mikemccand" created="Tue, 19 May 2009 20:42:20 +0100"  >&lt;blockquote&gt;&lt;p&gt;BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, TermScorer is now effectively doing an additional check, because you removed the pointer++ from the for loop init.  Ie, you now first check if (docs&lt;span class=&quot;error&quot;&gt;&amp;#91;pointer&amp;#93;&lt;/span&gt; &amp;gt;= target) &lt;b&gt;before&lt;/b&gt; doing the pointer++.&lt;/p&gt;</comment>
                    <comment id="12710848" author="yseeley@gmail.com" created="Tue, 19 May 2009 20:48:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;Not sure - didn&apos;t we agree for &amp;gt;= current?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&quot;A bigger question though, is if we should support skipTo(doc) where doc&amp;lt;=current at all&quot;&lt;br/&gt;
implies well defined behavior only when doc&amp;gt;current, as all of our scorers adhere to.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm... TermScorer.skipTo() does first advance the pointer before checking any state.  If we wanted to support calling skipTo(10) twice in a row, it would require extra code.&lt;/p&gt;</comment>
                    <comment id="12710851" author="mikemccand" created="Tue, 19 May 2009 20:57:31 +0100"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; This would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.&lt;/p&gt;

&lt;p&gt;But for scorers that use a priority queue, does checking and immediately removing from the queue (hence making the heap smaller) offer any advantages? I had assumed so since this is what current scorers do. Immediately removing scorers also causes early termination for minimumNrMatchers&amp;gt;1 in DisjunctionSumScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that only helps at the tail end of the iteration, vs saving an if&lt;br/&gt;
check per-sub-scorer X per-next?&lt;/p&gt;

&lt;p&gt;Ie presumably much more CPU is spent iterating while the PQ is full,&lt;br/&gt;
than while it&apos;s winding down, so saving the if per-sub-scorer-next is&lt;br/&gt;
better?&lt;/p&gt;

&lt;p&gt;Also, I think over time we should migrate away from the PQ (ie, use&lt;br/&gt;
BooleanScorer&apos;s batch approach, not Disjunction*Scorer&apos;s PQ) since the&lt;br/&gt;
batch scoring approach gives better performance.  EG I think we should&lt;br/&gt;
extend BooleanScorer to handle MUST clauses.  BooleanScorer handles&lt;br/&gt;
doc=Integer.MAX_VALUE for a sub-scorer quite efficiently (the chunk is&lt;br/&gt;
always skipped for that sub-scorer, after one if check).&lt;/p&gt;</comment>
                    <comment id="12710855" author="mikemccand" created="Tue, 19 May 2009 21:05:42 +0100"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?&lt;/p&gt;

&lt;p&gt;The idea was to return a negative value and then compare the returned value to &amp;gt;= 0 for better performance. If we return MAX_VAL we&apos;ll need to compare to MAX_VAL, which is less efficient, CPU wise.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you always check the returned result, right.&lt;/p&gt;

&lt;p&gt;But with BooleanScorer/2, and likely any scorer that invokes multiple&lt;br/&gt;
sub-scorers, switching to Integer.MAX_INT as the sentinel would allow&lt;br/&gt;
us to &lt;b&gt;not&lt;/b&gt; test every sub-scorer&apos;s returned result from&lt;br/&gt;
nextDoc/advance.  Ie, because the docID moved forward (vs -1, which&lt;br/&gt;
moved backwards), it&apos;s a &quot;natural&quot; fit for the main scorer&apos;s normal docID&lt;br/&gt;
processing.  So, far fewer if&apos;s (one per subscorer) are in the&lt;br/&gt;
innermost loop.&lt;/p&gt;

&lt;p&gt;Marvin, what&apos;s your plan for Lucy&apos;s sentinel value for DISI/Scorer?&lt;/p&gt;</comment>
                    <comment id="12710860" author="shaie" created="Tue, 19 May 2009 21:18:11 +0100"  >&lt;p&gt;Ok I&apos;ll look into it tomorrow morning when I&apos;ll be near the code again. If it makes sense, then it makes sense &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;You&apos;re also right about TermScorer. I missed the fact that checking the pointer occurs for the &lt;em&gt;next&lt;/em&gt; pointer, and indeed now the code does one extra check than before.&lt;/p&gt;

&lt;p&gt;If you don&apos;t feel advance() should have this contract, then I can change TermScorer&apos;s implementation back and document that calling advance() with the same value several times in a row does not guarantee to return the same value every time ... &lt;/p&gt;

&lt;p&gt;I still think it&apos;s more logical to state that it should return the same value, however since I don&apos;t have a good scenario where that will happen (and perhaps the fact that nobody complained about it until now means it never happens?) and since it may pose a performance hit over some iterators, I&apos;m willing to let go &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12710863" author="mikemccand" created="Tue, 19 May 2009 21:27:36 +0100"  >&lt;blockquote&gt;&lt;p&gt;I still think it&apos;s more logical to state that it should return the same value&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree (hence my original tentative liking of this change), but I agree that this can only hurt performance.&lt;/p&gt;

&lt;p&gt;Ie the caller &lt;b&gt;knows&lt;/b&gt; on calling advance() that the state of the sub-scorer must change.  And so by altering advance to first check, that check is redundant.  So maybe we should switch it back to &quot;advance then check&quot;?&lt;/p&gt;</comment>
                    <comment id="12710868" author="yseeley@gmail.com" created="Tue, 19 May 2009 21:33:23 +0100"  >&lt;p&gt;Scorers previously only had to worry about skipTo(doc) being called for doc&amp;gt;current.  I don&apos;t currently see a use case for changing that.&lt;/p&gt;</comment>
                    <comment id="12710869" author="paul.elschot@xs4all.nl" created="Tue, 19 May 2009 21:33:58 +0100"  >&lt;p&gt;About using Integer.MAX_VALUE as sentinel, did anyone consider what happens when the first index actually reaches that number of documents?&lt;/p&gt;

&lt;p&gt;On moving from the priority queue (DisjunctionSumScorer/BooleanScorer2) to the batch approach (BooleanScorer): I did not find a way to do that while scoring docs in docId order. Basically it&apos;s a priority queue versus a distribution &quot;sort&quot; on the low docId bits into a linked list.&lt;br/&gt;
The priority queue can be made faster by inlining (there is a patch for that, I can&apos;t get to the issue number now), but that&apos;s about the limit as far as I can see.&lt;/p&gt;</comment>
                    <comment id="12710880" author="mikemccand" created="Tue, 19 May 2009 21:51:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;About using Integer.MAX_VALUE as sentinel, did anyone consider what happens when the first index actually reaches that number of documents?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Lucene already uses Integer.MAX_VALUE as a sentinel (eg the score(Collector) methods in Term/BooleanScorer/2), so a Lucene index can already only contain Integer.MAX_VALUE docs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;On moving from the priority queue (DisjunctionSumScorer/BooleanScorer2) to the batch approach (BooleanScorer): I did not find a way to do that while scoring docs in docId order. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What breaks if we allow docs to be collected out-of-order (besides external Hit/Collector)?  As of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1575&quot; title=&quot;Refactoring Lucene collectors (HitCollector and extensions)&quot;&gt;&lt;del&gt;LUCENE-1575&lt;/del&gt;&lt;/a&gt;, the core collectors can gain performance if they know the docs will be collected in order, but they can also handle out-or-order collection just fine.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The priority queue can be made faster by inlining (there is a patch for that, I can&apos;t get to the issue number now), but that&apos;s about the limit as far as I can see.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think PQ is fundamentally not very friendly to modern CPUs, because of the hard-to-predict ifs; I think that&apos;s part of why the batch collection shows such gains.&lt;/p&gt;

&lt;p&gt;This doesn&apos;t hurt us so much during hit collection, which also uses PQ, since the queue typically quickly converges, but for OR scoring the PQ is intensely used the whole time.&lt;/p&gt;</comment>
                    <comment id="12710887" author="creamyg" created="Tue, 19 May 2009 22:24:51 +0100"  >&lt;p&gt;&amp;gt; Marvin, what&apos;s your plan for Lucy&apos;s sentinel value for DISI/Scorer?&lt;/p&gt;

&lt;p&gt;Doc numbers start at 1, and 0 is the sentinel.&lt;/p&gt;

&lt;p&gt;Also, DISI will be named &quot;Matcher&quot;.  Features above and beyond what&apos;s &lt;br/&gt;
currently in Lucene DISI to be determined.&lt;/p&gt;</comment>
                    <comment id="12711027" author="shaie" created="Wed, 20 May 2009 07:19:03 +0100"  >&lt;p&gt;So Mike - I&apos;ve checked BS and BS2, and I don&apos;t see where does the return value can come into play the way you describe. Perhaps I&apos;m missing it, but here&apos;s what I found:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;BS - advance is not supported. In nextDoc the return value is checked only to verify if the sub scorer is done or not, therefore comparing to &amp;gt;= 0 seems the better option here.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;BS2 - delegates advance and nextDoc to its counting scorer, which could have two variants that may be affected:
	&lt;ul&gt;
		&lt;li&gt;DisjunctionSumScorer - I don&apos;t see where the return value of the scorers is even considered.&lt;/li&gt;
		&lt;li&gt;ConjunctionScorer - both nextDoc and advance delegate the call to doNext() which iterates over the scorers. But it only checks the return value of advance to decide whether to continue with the iteration or not. The only thing I changed is using advance() &amp;gt;= 0 instead of skipTo which returned boolean. Is that the one you&apos;re talking about? Maybe you mean that in that scorer (only?) I could drop the &apos;more&apos; member and stop iterating when the first scorer hits MAX_VAL, in which case it will not be less than the last doc, even if the last one is on MAX_VAL also?&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If I didn&apos;t miss anything, than that is just one scorer, which is not always instantiated. The rest do compare the return value of nextDoc and advance to determine what to do, exactly as they did before when the equivalent deprecated methods returned a boolean. It seems like this change will hurt the performance of most Scorers/DISIs more than improve the performance of BS2 in some cases where it instantiates a ConjunctionScorer. But like I said, maybe I&apos;m missing a Scorer, so I&apos;d appreciate if you can refer me to the one you had in mind.&lt;/p&gt;

&lt;p&gt;Also, given Marvin&apos;s response above, using 0 as sentinel is no different than using -1 in terms of &quot;suddenly moving backwards&quot;.&lt;/p&gt;

&lt;p&gt;I fixed the documentation of advance and reinstated the implementation of TermScorer, so I&apos;m ready to post an updated patch. I&apos;d like us to resolve the return value issue before I do that though.&lt;/p&gt;</comment>
                    <comment id="12711082" author="mikemccand" created="Wed, 20 May 2009 11:06:29 +0100"  >&lt;p&gt;I&apos;m not referring to BS/2&apos;s exposure of advance/nextDoc to their&lt;br/&gt;
callers; I&apos;m talking about how BS/2 invoke advance/nextDoc on their&lt;br/&gt;
sub-scorers.&lt;/p&gt;

&lt;p&gt;So, in BooleanScorer, starting on line 239 (w/ your patch), is this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc = sub.done ? -1 : scorer.doc();
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!sub.done &amp;amp;&amp;amp; doc &amp;lt; end) {
  sub.collector.collect(doc);
  doc = scorer.nextDoc();
  sub.done = doc &amp;lt; 0;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;this is the hotspot for BooleanScorer: it&apos;s advancing through a chunk&lt;br/&gt;
(of 2048 docs) at once, for that one sub-scorer.  Note the checks &amp;amp;&lt;br/&gt;
assignments to sub.done that are required....&lt;/p&gt;

&lt;p&gt;If instead we switch to Integer.MAX_VALUE as the sentinel, that loop&lt;br/&gt;
is simplified to this, instead:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc = scorer.doc();
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (doc &amp;lt; end) {
  sub.collector.collect(doc);
  doc = scorer.nextDoc();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;scorer.done is no longer computed nor checked.  What makes this&lt;br/&gt;
possible is the existing &quot;doc &amp;lt; end&quot; check can be &quot;reused&quot; since the&lt;br/&gt;
sentinel moves &quot;forwards&quot;, not backwards.&lt;/p&gt;

&lt;p&gt;With this, we&apos;d also need to change the toplevel collection (starting&lt;br/&gt;
on line 150) to stop processing once all sub-scorers have advanced to&lt;br/&gt;
the sentinel, but this is 1 added if per 2048 docs so the added cost&lt;br/&gt;
(vs savings of not computing/checking scorer.done) is tiny.&lt;/p&gt;

&lt;p&gt;In ConjunctionScorer&apos;s doNext method (its hotspot), it currently does this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (more &amp;amp;&amp;amp; (firstScorer=scorers[first]).doc() &amp;lt; (lastDoc=lastScorer.doc())) {
  more = firstScorer.advance(lastDoc) &amp;gt;= 0;
  lastScorer = firstScorer;
  first = (first == (scorers.length-1)) ? 0 : first+1;
}
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; more;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with the sentinel change, it would do this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; ((firstScorer=scorers[first]).doc() &amp;lt; (lastDoc=lastScorer.doc())) {
  firstScorer.advance(lastDoc);
  lastScorer = firstScorer;
  first = (first == (scorers.length-1)) ? 0 : first+1;
}
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; lastDoc != DOC_SENTINEL;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ie, we no longer assign to, nor check, the more boolean.  What makes&lt;br/&gt;
this possible is we know all sub-scorers will advance to the sentinel,&lt;br/&gt;
so we know that sentinel doc will pass the existing checks in the&lt;br/&gt;
while loop.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, given Marvin&apos;s response above, using 0 as sentinel is no different than using -1 in terms of &quot;suddenly moving backwards&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree that Marvin&apos;s choice of 0 is also &quot;suddenly moving backwards&quot;,&lt;br/&gt;
but it still seems to me to be a poor choice since it costs our&lt;br/&gt;
BooleanScorers more CPU in their hotspots.&lt;/p&gt;</comment>
                    <comment id="12711097" author="shaie" created="Wed, 20 May 2009 12:06:54 +0100"  >&lt;p&gt;Thanks Mike for the clarification. One thing though is the comment I added to BS about not being able to call scorer.doc() since we may hit NPE. I hit it when it used ReqExclScorer. According to the latter, doc will hit NPE if next() or skipTo() returned false (or in our case nextDoc or advance return MAX_VAL).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc() {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; reqScorer.doc(); &lt;span class=&quot;code-comment&quot;&gt;// reqScorer may be &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; when next() or skipTo() already &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
&lt;/span&gt;  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we drop sub.done in BS and more in ConjScorer, calling doc() will hit NPE. I.e. in BS the first line cannot exist, however I&apos;m not sure I can start with nextDoc() before checking the current doc() &amp;lt; end, which may hit NPE. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc = scorer.doc();
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (doc &amp;lt; end) {
  sub.collector.collect(doc);
  doc = scorer.nextDoc();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And similarly in ConjunctionScorer dropping &apos;more&apos; may hit NPE if that Scorer is used.&lt;/p&gt;

&lt;p&gt;There are a couple of ways to handle it:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;In ReqExclScorer.doc() check for reqScorer == null and return MAX_VAL if it is. I count here on doc() not being called very frequently after this patch, since nextDoc() and advance() return the document. However that may not be the case (see ConjunctionScorer which uses doc() in doNext).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In ReqExclScorer make sure that reqScorer is never nullified, but then we&apos;ll need to figure out a different way to mark that there are no more docs (perhaps change the comparison of reqScorer to null to a boolean moreDocs?)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12711120" author="shaie" created="Wed, 20 May 2009 13:37:24 +0100"  >&lt;p&gt;Actually, as I read the &quot;back-compat discussion&quot;, I think that doing what you propose may break back-comapt? I mean, what if someone else&apos;s Scorer&apos;s doc() may throw an exception after its next() or skipTo() return false? So far our code made sure we don&apos;t call doc(), next() or skipTo() after the Scorer &apos;told&apos; us it has no more documents. Now we&apos;re saying we will call doc() even if the scorer told us it has no more documents.&lt;/p&gt;

&lt;p&gt;Even though I believe it&apos;s very unlikely there is a Scorer which behaves that way, there is one for sure in Lucene (ReqExclScorer). So I don&apos;t know ... this whole back-compat is really a pain &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12711121" author="mikemccand" created="Wed, 20 May 2009 13:37:33 +0100"  >&lt;p&gt;I think I&apos;d favor not nulling reqScorer, though that&apos;s a bigger change, so perhaps instead just add the null test in ReqExclScorer.doc() and we can later optimize away the nulling?&lt;/p&gt;

&lt;p&gt;Also, in general, we can decouple the optimizations that become possible with Integer.MAX_VALUE as sentinel, from this issue...&lt;/p&gt;</comment>
                    <comment id="12711128" author="shaie" created="Wed, 20 May 2009 13:50:22 +0100"  >&lt;p&gt;Regarding my previous post on back-compat, maybe we can get away with it by documenting it in CHANGES? If we think it&apos;s not very likely there are many Scorers out there that will be affected by this change?&lt;/p&gt;</comment>
                    <comment id="12711187" author="mikemccand" created="Wed, 20 May 2009 16:27:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think that doing what you propose may break back-comapt?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm.. this is a challenge... as DISI now stands, it&apos;s undefined what doc() will do once next/skipTo has returned false.&lt;/p&gt;

&lt;p&gt;Even if it doesn&apos;t throw an exception,  it won&apos;t return our new sentinel value.&lt;/p&gt;

&lt;p&gt;I fear our only choice is to make a new method to return the doc, whose semantics are defined to reflect this change?  We&apos;d provide a default impl that returns doc() if the iteration hasn&apos;t ended, else the sentinel?  Or.... some sort of wrapper to wrap an old DISI as the new one, but then we&apos;d need a new DISI class to tell the difference.  Hmm.&lt;/p&gt;</comment>
                    <comment id="12711303" author="shaie" created="Wed, 20 May 2009 20:33:14 +0100"  >&lt;p&gt;Maybe there&apos;s a way out of this. In 2.9 we&apos;re already changing the contract of DISI with the new nextDoc and advance. As opposed to before (boolean), we&apos;re now stating what these methods should return when there are no more documents. So what if we do this:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;In 2.9 we document that these methods should return MAX_VAL when there are no more documents.&lt;/li&gt;
	&lt;li&gt;Document doc() that in 3.0 it should return MAX_VAL when there are no more docs. Also put that in CHANGES.&lt;/li&gt;
	&lt;li&gt;I change the patch to return MAX_VAL for all current DISIs/Scorers, but don&apos;t take advantage of that yet in BS and ConjunctionScorer.&lt;/li&gt;
	&lt;li&gt;I open another issue for 3.0 which will take advantage of that, and ensure all current DISIs/Scorers&apos; doc() return MAX_VAL when there are no more docs?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I think that should work. We&apos;ll need to delay with that optimization beyond 2.9, but I don&apos;t think there&apos;s a nice and clean way around it otherwise. If 3.0 should quickly follow 2.9, we won&apos;t wait for long &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="12711311" author="mikemccand" created="Wed, 20 May 2009 21:11:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;Maybe there&apos;s a way out of this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK that sounds like a good plan.  (Though it&apos;s yet another example of how we hurt our new users, by delaying these optimizations, in favor of our back-compat users...)&lt;/p&gt;</comment>
                    <comment id="12711315" author="shaie" created="Wed, 20 May 2009 21:19:56 +0100"  >&lt;blockquote&gt;&lt;p&gt;Though it&apos;s yet another example of how we hurt our new users, by delaying these optimizations, in favor of our back-compat users..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe the thread on back-compat will go our way and we&apos;ll be free to introduce this change in 2.9? Although I doubt it, since for the sake of back-compat, even if the last one, we&apos;ll probably decide to start that after 3.0 is out.&lt;/p&gt;

&lt;p&gt;Oh well ... like I said - hopefully our users will not have to wait long between 2.9 and 3.0.&lt;/p&gt;</comment>
                    <comment id="12711533" author="shaie" created="Thu, 21 May 2009 10:24:37 +0100"  >&lt;p&gt;Hmmm ... there is a problem with MAX_VAL as sentinel:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;OpenBitSetIterator already has a nextDoc() method which returns -1 when exhausted. The current patch used -1 as sentinel, and therefore it was ok. But when I changed it to MAX_VAL, test-tag fail on TestOpenBitSet. We can document this change in &quot;changes to back-compat policy&quot; and fix the test on trunk and tag.&lt;/li&gt;
	&lt;li&gt;SortedVIntList returns an iterator which is a DISI. MAX_VAL is considered a valid value for SortedVIntList (TestSortedVIntList.test03() validates that). So if we use it as sentinel, we declare that MAX_VAL is invalid for SortedVIntList. Not sure if we can do that.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I think the second is the problematic one - how do we handle iterators for which MAX_VAL is a valid value? I tend to say MAX_VAL should not be a valid value since by the name, *DocId*SetIterator, we should return doc Ids, and MAX_VAL is used as sentinel elsewhere and is not even considered a valid doc Id. Therefore those iterators should change their logic, if they rely on MAX_VAL being a valid value.&lt;/p&gt;

&lt;p&gt;BTW, besides the convenience, why should SortedVIntList expose a DocIdSetIterator? Nothing implies the list will hold doc Ids, therefore why commit to an iterator which returns doc Ids? If it&apos;s for convenience only, then maybe wrap that iterator with a true DISI where the Lucene code will need a true DISI?&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12711545" author="mikemccand" created="Thu, 21 May 2009 10:54:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;OpenBitSetIterator already has a nextDoc() method which returns -1 when exhausted. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm &amp;#8211; maybe we need to choose a different name than nextDoc()?  Or... we make a new class (DISI2 or something) so we can strongly differentiate old from new semantics?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I tend to say MAX_VAL should not be a valid value&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, we are saying (have already said, elsewhere in Lucene&apos;s core code) that MAX_VAL is not a valid docID.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;MAX_VAL is considered a valid value for SortedVIntList (TestSortedVIntList.test03() validates that). So if we use it as sentinel, we declare that MAX_VAL is invalid for SortedVIntList. Not sure if we can do that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should remove that test, and decide MAX_VAL is not valid value in the list, because SortedVIntList is a DocIdSet.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, besides the convenience, why should SortedVIntList expose a DocIdSetIterator? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t follow &amp;#8211; SortedVIntList subclasses DocIdSet, which necessarily provides DISI iterator() method.  Why is this not a &quot;true DISI&quot;?&lt;/p&gt;</comment>
                    <comment id="12711553" author="shaie" created="Thu, 21 May 2009 11:21:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;SortedVIntList subclasses DocIdSet&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, did not notice that. It&apos;s just that the test confused me, since I though it just stores VInts with no direct relation to doc Ids.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;maybe we need to choose a different name than nextDoc()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why? just because OBSI declared a method which we wanted anyway? You know .. it&apos;s something we don&apos;t give much thought to when we add methods to abstract classes, but what if someone extended DISI and added his own advance(int) or nextDoc() which don&apos;t behave like we expect them to. When he&apos;ll pass his DISI to the search flow somehow, not knowing these have become the primary methods, something will break.&lt;/p&gt;

&lt;p&gt;I&apos;m not saying we should protect these cases too, because otherwise we won&apos;t be able to make any changes. But just because OBSI had nextDoc() declared doesn&apos;t mean we should go and find a different name. That&apos;s slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.&lt;/p&gt;

&lt;p&gt;Can&apos;t we just document in CHANGES that nextDoc() now returns MAX_VAL when no more docs exist, and we fix the test in tag? I mean, how many users do we think use OBSI directly?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;MAX_VAL is not a valid docID&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll remove the test then (from trunk and tag) and document on DISI this assumption.&lt;/p&gt;</comment>
                    <comment id="12711555" author="shaie" created="Thu, 21 May 2009 11:24:29 +0100"  >&lt;p&gt;BTW, regarding SortedVIntList - even though it extends DocIdSet, its javadocs start with &quot;Store and iterate sorted integers in compressed form in RAM.&quot; - doc Ids are not mentioned. Also, the class is public, so nothing prevents someone from using it for integers that are not Doc Ids.&lt;/p&gt;

&lt;p&gt;I think I&apos;ll emphasize that in the javadocs, documenting the limitation of MAX_VAL so that people won&apos;t assume the wrong things.&lt;/p&gt;</comment>
                    <comment id="12711576" author="mikemccand" created="Thu, 21 May 2009 12:39:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think I&apos;ll emphasize that in the javadocs, documenting the limitation of MAX_VAL so that people won&apos;t assume the wrong things.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;A docID is different from an &quot;int&quot;, because docIDs must be 0 .. MAX_VAL-1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why? just because OBSI declared a method which we wanted anyway? You know .. it&apos;s something we don&apos;t give much thought to when we add methods to abstract classes, but what if someone extended DISI and added his own advance(int) or nextDoc() which don&apos;t behave like we expect them to. When he&apos;ll pass his DISI to the search flow somehow, not knowing these have become the primary methods, something will break.&lt;/p&gt;

&lt;p&gt;I&apos;m not saying we should protect these cases too, because otherwise we won&apos;t be able to make any changes. But just because OBSI had nextDoc() declared doesn&apos;t mean we should go and find a different name. That&apos;s slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right, a random subclass of an abstract class could very well choose the name we are wanting to add, and then their class fails to compile, or (if the sigs turn out to be identical) runs bug possibly causes problems.&lt;/p&gt;

&lt;p&gt;But in this case we know we have just such a class that has done so (OBSI).  And of course it did so for exactly the reasons that we are now wanting to add nextDoc to DISI.  My guess is eg Solr probably relies heavily on OBSI.nextDoc returning -1 when it&apos;s done and we&apos;re gonna cause AIOOB exceptions if we up and change to returning MAX_VAL.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;That&apos;s slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As much as it bothers me having to accept inferior names (so they don&apos;t conflict with the existing names), I think it&apos;s very much the lesser-of-evils here.&lt;/p&gt;</comment>
                    <comment id="12711580" author="shaie" created="Thu, 21 May 2009 12:52:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;My guess is eg Solr probably relies heavily on OBSI.nextDoc returning -1&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perhaps the Solr guys can state then if and how much they mind this change? Before we start the journey of finding a different name for DISI.nextDoc(), just to deprecated OBSI.nextDoc() ...&lt;/p&gt;</comment>
                    <comment id="12711588" author="shalinmangar" created="Thu, 21 May 2009 13:01:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;Perhaps the Solr guys can state then if and how much they mind this change? Before we start the journey of finding a different name for DISI.nextDoc(), just to deprecated OBSI.nextDoc()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t see any calls to OpenBitSetIterator.nextDoc in solr&apos;s source code.&lt;/p&gt;</comment>
                    <comment id="12711597" author="shaie" created="Thu, 21 May 2009 13:26:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t see any calls to OpenBitSetIterator.nextDoc in solr&apos;s source code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So Mike - does that mean I can change nextDoc() behavior in OBSI and document it?&lt;/p&gt;</comment>
                    <comment id="12711605" author="mikemccand" created="Thu, 21 May 2009 13:51:27 +0100"  >&lt;blockquote&gt;&lt;p&gt;So Mike - does that mean I can change nextDoc() behavior in OBSI and document it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK let&apos;s tentatively go forward with that?&lt;/p&gt;</comment>
                    <comment id="12711611" author="yseeley@gmail.com" created="Thu, 21 May 2009 14:00:40 +0100"  >&lt;p&gt;I&apos;m warming to some of the simplifications that a MAX_VAL sentinel can bring.&lt;/p&gt;

&lt;p&gt;On the other end of the scale... getting rid of &quot;if (firstTime)&quot; is another check I&apos;ve long wanted to eliminate.&lt;br/&gt;
if doc() produced -1 the first time, before any calls to next() or skipTo(), we could get rid of the if (firstTime) code in ConjunctionScorer and others I think.  The question is, would this be a burden to any scorers or DISI implementations?&lt;/p&gt;</comment>
                    <comment id="12711615" author="shaie" created="Thu, 21 May 2009 14:09:10 +0100"  >&lt;p&gt;I plan to open another issue for 3.0 to take advantage of MAX_VAL being returned from doc() also (we cannot rely on doc() returning MAX_VAL today when there are no more docs, hence why we need to wait with these changes until 3.0).&lt;/p&gt;

&lt;p&gt;You&apos;re proposing to add another contract to doc() - to return -1 before nextDoc() and advance(int) were called. I can do that, but we can use this contract only in 3.0.&lt;/p&gt;

&lt;p&gt;Unless the community decides to change back-compat policy starting with 2.9, which will give us the opportunity to take advantage of &quot;latest &amp;amp; greatest&quot; right away.&lt;/p&gt;</comment>
                    <comment id="12711630" author="shaie" created="Thu, 21 May 2009 15:08:56 +0100"  >&lt;p&gt;MAX_VAL as sentinel + the documentation changes + a new entry to CHANGES &quot;back-compat change&quot; on OBSI.nextDoc() and next(int) + tag fixes.&lt;/p&gt;

&lt;p&gt;All tests pass&lt;/p&gt;</comment>
                    <comment id="12711653" author="mikemccand" created="Thu, 21 May 2009 16:32:46 +0100"  >&lt;blockquote&gt;
&lt;p&gt;On the other end of the scale... getting rid of &quot;if (firstTime)&quot; is another check I&apos;ve long wanted to eliminate.&lt;br/&gt;
if doc() produced -1 the first time, before any calls to next() or skipTo(), we could get rid of the if (firstTime) code in ConjunctionScorer and others I think. The question is, would this be a burden to any scorers or DISI implementations?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Since we&apos;re changing DISI&apos;s semantics, now seems like a great time to make this change to.  Eliminating the &quot;if (firstTime)&quot; from next() would be great.&lt;/p&gt;

&lt;p&gt;But: wouldn&apos;t ConjunctionScorer still need an init() to sort its sub-scorers?  (Though, really, we ought to do that sort based on more accurate criteria, eg add a DIS.approxCount() (the first docID of each sub-scorer is an approximation that could easily be very wrong).  If we had that, then in the ConjunctionScorer&apos;s ctor we would do the ordering).&lt;/p&gt;</comment>
                    <comment id="12711670" author="mikemccand" created="Thu, 21 May 2009 17:11:56 +0100"  >&lt;p&gt;We could also consider adding DISI.start (we discussed this under another issue).&lt;/p&gt;

&lt;p&gt;And maybe likewise DISI.finish &amp;#8211; there&apos;s a question on the user&apos;s list now &quot;Do TermDocs and TermEnum need to be closed?&quot; that notes that DISI never gives one a chance to close.&lt;/p&gt;</comment>
                    <comment id="12711676" author="yseeley@gmail.com" created="Thu, 21 May 2009 17:27:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;But: wouldn&apos;t ConjunctionScorer still need an init() to sort its sub-scorers?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If they are all on -1 to start with, they are already all sorted.&lt;/p&gt;

&lt;p&gt;We could do some smart sorting in the constructor so that we skip in cheap and fast scorers first (TermScorers first, ordered by df, followed by simple conjunctions of terms, followed by other more expensive stuff like sloppy phrase queries and complex boolean queries.  Perhaps in the future, even a method on Scorer that estimates it&apos;s cost?&lt;/p&gt;
</comment>
                    <comment id="12711682" author="mikemccand" created="Thu, 21 May 2009 17:39:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;If they are all on -1 to start with, they are already all sorted.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right but that defeats the optimization.  I&apos;m talking about this code in ConjunctionScorer:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Arrays.sort(scorers, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Comparator() {         &lt;span class=&quot;code-comment&quot;&gt;// sort the array
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; compare(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o1, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o2) {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; ((Scorer)o1).doc() - ((Scorer)o2).doc();
    }
  });

doNext();

&lt;span class=&quot;code-comment&quot;&gt;// If first-time skip distance is any predictor of
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// scorer sparseness, then we should always &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to skip first on
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// those scorers.
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// Keep last scorer in it&apos;s last place (it will be the first
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// to be skipped on), but reverse all of the others so that
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// they will be skipped on in order of original high skip.
&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; end=(scorers.length-1);
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0; i&amp;lt;(end&amp;gt;&amp;gt;1); i++) {
  Scorer tmp = scorers[i];
  scorers[i] = scorers[end-i-1];
  scorers[end-i-1] = tmp;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ie it sets things up so that &quot;typically&quot; the rarest sub-scorer drives the intersection.  If they are all on -1 then this heuristic won&apos;t work.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We could do some smart sorting in the constructor so that we skip in cheap and fast scorers first (TermScorers first, ordered by df, followed by simple conjunctions of terms, followed by other more expensive stuff like sloppy phrase queries and complex boolean queries. Perhaps in the future, even a method on Scorer that estimates it&apos;s cost?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, we&apos;d need to do something along these lines if we switch DISI to start with doc() = -1.&lt;/p&gt;</comment>
                    <comment id="12711695" author="mikemccand" created="Thu, 21 May 2009 18:08:23 +0100"  >&lt;p&gt;Oh, it turns out OBSI.nextDoc is new in 2.9!  So we are free to change it...&lt;/p&gt;</comment>
                    <comment id="12711773" author="earwin" created="Thu, 21 May 2009 20:52:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Oh, it turns out OBSI.nextDoc is new in 2.9!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The phrase sounds all too familiar &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
There&apos;s one absolutely cool javadoc tag, which I suggest we start using for all user-visible classes and their members. It&apos;s called - @Since. Suddenly, everything that&apos;s not yet released (and that&apos;s a big bunch), is clearly marked as free for changes and amendments.&lt;/p&gt;</comment>
                    <comment id="12711782" author="shaie" created="Thu, 21 May 2009 21:18:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;Oh, it turns out OBSI.nextDoc is new in 2.9!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are you sure about it? If so, then why test-tag failed on it? Notice that there are two methods nextDoc() and next(int). Are both new in 2.9? If so, it means somebody added them to the tag, for some reason ...&lt;/p&gt;

&lt;p&gt;BTW, I&apos;m going to open the follow-up issue to that, so we can discuss whatever improvements we want to make to the Scorers following the MAX_VAL sentinel there. Otherwise, they will get lost in this issue, and when we&apos;ll handle the follow-up one, we might not remember everything.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s called - @Since&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s absolutely a great idea !&lt;/p&gt;</comment>
                    <comment id="12711785" author="mikemccand" created="Thu, 21 May 2009 21:28:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;Are you sure about it? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If so, then why test-tag failed on it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Unfortunately, we came up with the idea of the back-compat branch after 2.4 was released, so we cut the branch at that point (in 2.9), so the back-compat branch does contain tests for early 2.9-only features. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Are both new in 2.9?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BTW, I&apos;m going to open the follow-up issue to that, so we can discuss whatever improvements we want to make to the Scorers following the MAX_VAL sentinel there. Otherwise, they will get lost in this issue, and when we&apos;ll handle the follow-up one, we might not remember everything.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed!&lt;/p&gt;</comment>
                    <comment id="12711791" author="shaie" created="Thu, 21 May 2009 21:47:55 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Are both new in 2.9?&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh that&apos;s great - and here I was deprecating next(int) in favor of the new advance. I&apos;ll just delete it then.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m going to open the follow-up issue to that&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt; and copied what&apos;s relevant from this issue to there. If I missed something, please add it.&lt;/p&gt;</comment>
                    <comment id="12712521" author="shaie" created="Sun, 24 May 2009 08:30:32 +0100"  >&lt;p&gt;Removed next(int) from OBSI and put @since 2.9 on the new methods in DISI.&lt;/p&gt;

&lt;p&gt;I think the patch is ready to be committed. We can add check() as appropriate in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt;, when we utilize MAX_VAL.&lt;/p&gt;</comment>
                    <comment id="12713031" author="shaie" created="Tue, 26 May 2009 15:41:58 +0100"  >&lt;p&gt;A question regarding BS.nextDoc(). I paste the current code (that I&apos;m working on, for reference).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; nextDoc() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-comment&quot;&gt;// TODO: can remove more?
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; more;
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
      &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (bucketTable.first != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {         &lt;span class=&quot;code-comment&quot;&gt;// more queued
&lt;/span&gt;        current = bucketTable.first;
        bucketTable.first = current.next;         &lt;span class=&quot;code-comment&quot;&gt;// pop the queue
&lt;/span&gt;
        &lt;span class=&quot;code-comment&quot;&gt;// check prohibited &amp;amp; required, and minNrShouldMatch
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((current.bits &amp;amp; prohibitedMask) == 0 &amp;amp;&amp;amp;
            (current.bits &amp;amp; requiredMask) == requiredMask &amp;amp;&amp;amp;
            current.coord &amp;gt;= minNrShouldMatch) {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; doc = current.doc;
        }
      }

      &lt;span class=&quot;code-comment&quot;&gt;// refill the queue
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//      more = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
&lt;/span&gt;      end += BucketTable.SIZE;
      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (SubScorer sub = scorers; sub != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;; sub = sub.next) {
        Scorer scorer = sub.scorer;
        sub.collector.setScorer(scorer);
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc = scorer.docID();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doc == -1) {
          doc = scorer.nextDoc();
        }
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (doc &amp;lt; end) {
          sub.collector.collect(doc);
          doc = scorer.nextDoc();
        }
&lt;span class=&quot;code-comment&quot;&gt;//        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doc != NO_MORE_DOCS) {
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//          more = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//        }
&lt;/span&gt;      }
    } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (bucketTable.first != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;/* || more*/);

    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; doc = NO_MORE_DOCS;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I wanted to get rid of &apos;more&apos;, following all the changes I&apos;m doing to DISI. I did it and all tests pass, but I want to double-check my understanding, since I don&apos;t know for sure if there is a test that tests my change.&lt;/p&gt;

&lt;p&gt;As far as I see it, there are two code sections: (1) iterates on bucketTable until it is exhausted (i.e., calls to nextDoc() will first consume bucketTable) and (2) iterate on all sub scorers. The second iteration populates the bucket table from all sub-scorers and reiterates, consuming bucket table again, in calls to nextDoc(). Then, at some point, all sub scorers don&apos;t have anything more to collect, and bucketTable.first is null for the last time, at which point nextDoc() returns NO_MORE_DOCS.&lt;/p&gt;

&lt;p&gt;So it looks like I can indeed get rid of &apos;more&apos;. But what puzzles me is why it was there in the first place. Leaving the code as-is means that someone thought of a case where a sub-scorer will have more documents to collect, but still after the 2nd code segment the bucketTable was empty. That&apos;s why I&apos;m not sure I can remove &apos;more&apos; safely - i.e., is it possible that a sub-scorer will have more documents, however all the docs that were collected by sub.collector will not affect the bucketTable? It doesn&apos;t look like in the code.&lt;/p&gt;

&lt;p&gt;Same question for BS.score(Collector collector, int max).&lt;/p&gt;</comment>
                    <comment id="12713048" author="shaie" created="Tue, 26 May 2009 16:17:11 +0100"  >&lt;p&gt;About ConjunctionScorer.doNext() (this also applies to FilteredQuery.advanceToCommon()). I&apos;ve changed it, following Mike&apos;s proposal to this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; doNext() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; first = 0;
    lastDoc = scorers[scorers.length - 1].docID();
    Scorer firstScorer;
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; ((firstScorer = scorers[first]).docID() &amp;lt; lastDoc) {
      lastDoc = firstScorer.advance(lastDoc);
      first = first == scorers.length - 1 ? 0 : first + 1;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; lastDoc != NO_MORE_DOCS;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This indeed gets rid of &apos;more&apos;, the check for &apos;more&apos; in the while condition and also the assignment to more. But now I think it may introduce a different inefficiency. Let&apos;s say that firstScorer.advance() returns NO_MORE_DOCS. The next scorer&apos;s docID is obviously smaller, and therefore the following call will be (first line in the &apos;while&apos; body): &lt;b&gt;lastDoc = firstScorer.advance(Integer.MAX_VALUE);&lt;/b&gt;. There are Scorers which cannot implement that efficiently.&lt;/p&gt;

&lt;p&gt;With &apos;more&apos; this would not have happened, since the while condition would terminate before that.&lt;/p&gt;

&lt;p&gt;Are we sure that that&apos;s a worthwhile enhancement.&lt;/p&gt;

&lt;p&gt;BTW, the code for FilteredQuery looks like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (scorerDoc != disiDoc) {
              &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (scorerDoc &amp;lt; disiDoc) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((scorerDoc = scorer.advance(disiDoc)) == NO_MORE_DOCS) {
                  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; NO_MORE_DOCS;
                }
              } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((disiDoc = docIdSetIterator.advance(scorerDoc)) == NO_MORE_DOCS) {
                  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; NO_MORE_DOCS;
                }
              }
            }
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; scorerDoc;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And I thought to change it to this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (scorerDoc != disiDoc) {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (scorerDoc &amp;lt; disiDoc) {
    scorerDoc = scorer.advance(disiDoc);
  } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
  disiDoc = docIdSetIterator.advance(scorerDoc);
  }
}
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; scorerDoc;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12713058" author="paul.elschot@xs4all.nl" created="Tue, 26 May 2009 16:34:58 +0100"  >&lt;p&gt;Well, since you asked: could you try and put all conjunctions on doc ids in a single place?&lt;br/&gt;
That would also prepare for things like &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1252&quot; title=&quot;Avoid using positions when not all required terms are present&quot;&gt;LUCENE-1252&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;The tests for boolean queries are quite comprehensive nowadays. So when all tests pass, don&apos;t worry too much.&lt;br/&gt;
In case there is a bug left, it will be so much of corner case that it can be fixed at another issue.&lt;/p&gt;</comment>
                    <comment id="12713067" author="mikemccand" created="Tue, 26 May 2009 16:58:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Leaving the code as-is means that someone thought of a case where a sub-scorer will have more documents to collect, but still after the 2nd code segment the bucketTable was empty.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would happen when none of the sub-scorers had docIDs in the&lt;br/&gt;
current bucket range.&lt;/p&gt;

&lt;p&gt;EG say the first docID of all sub-scorers is 3000,&lt;br/&gt;
and BucketTable.SIZE is 2048.  On the first time through part (2), no&lt;br/&gt;
sub-scorer will add to the bucket, so on finishing part (2),&lt;br/&gt;
bucketTable.first will still be null but more will be true, and so the&lt;br/&gt;
whole loop would (and, should) keep repeating.&lt;/p&gt;

&lt;p&gt;I think?&lt;/p&gt;

&lt;p&gt;So in fact your change should break that case.... can you add a&lt;br/&gt;
breaking unit test showing this?&lt;/p&gt;

&lt;p&gt;Also, I wonder if this can be removed, by init&apos;ing the sub-scorers up&lt;br/&gt;
front:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doc == -1) {
  doc = scorer.nextDoc();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12713068" author="mikemccand" created="Tue, 26 May 2009 17:01:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;There are Scorers which cannot implement that efficiently.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which Scorers do this slowly?&lt;/p&gt;</comment>
                    <comment id="12713070" author="mikemccand" created="Tue, 26 May 2009 17:03:44 +0100"  >&lt;p&gt;The changes to FilteredQuery look good!&lt;/p&gt;</comment>
                    <comment id="12713083" author="shaie" created="Tue, 26 May 2009 17:24:44 +0100"  >&lt;blockquote&gt;&lt;p&gt;Which Scorers do this slowly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;TermScorer, ValueSourceQuery which uses TermDocs.skipTo ... just two examples. I&apos;m not sure how efficient TermDocs is.&lt;/p&gt;

&lt;p&gt;We could state in the javadocs that Integer.MAX_VALUE may be passed and if you think you cannot impl advance(MAX_VAL) efficiently, always check if that&apos;s what was passed?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The changes to FilteredQuery look good! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we agree that calling advance(MAX_VAL) is ok, I&apos;ll enable both fixes.&lt;/p&gt;</comment>
                    <comment id="12713144" author="mikemccand" created="Tue, 26 May 2009 18:34:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure how efficient TermDocs is.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;TermDocs.skipTo(Integer.MAX_VALUE) should be quite fast (it&apos;s using multi-level skipping)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We could state in the javadocs that Integer.MAX_VALUE may be passed and if you think you cannot impl advance(MAX_VAL) efficiently, always check if that&apos;s what was passed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Let&apos;s do that, but I don&apos;t think the scorers that use TermDocs.skipTo need the extra check.&lt;/p&gt;</comment>
                    <comment id="12713147" author="shaie" created="Tue, 26 May 2009 18:39:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;Let&apos;s do that, but I don&apos;t think the scorers that use TermDocs.skipTo need the extra check.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok will do. So it means that none of the current DISIs/Scorers should do this check? I&apos;ll double-check to make sure and post back if I find something suspicious.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So in fact your change should break that case.... can you add a breaking unit test showing this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will look into it. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, I wonder if this can be removed, by init&apos;ing the sub-scorers up front&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will check this too.&lt;/p&gt;</comment>
                    <comment id="12713251" author="shaie" created="Tue, 26 May 2009 21:59:12 +0100"  >&lt;p&gt;I added testEmptyBucketWithMoreDocs in TestBooleanScorer which creates a BooleanScorer that returns 3000 the first time nextDoc is called (or advance with target &amp;lt;= 3000) and then NO_MORE_DOCS. It asserts that calling nextDoc() once returns 3000 and the second time returns NO_MORE_DOCS.&lt;/p&gt;

&lt;p&gt;Indeed, with the change I&apos;ve made above it fails. So it&apos;s good that this test is there now. It makes BS/BS2 one more testcase-proof. That means I cannot remove &apos;more&apos; ...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The tests for boolean queries are quite comprehensive nowadays. So when all tests pass, don&apos;t worry too much.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Paul, I guess we should always worry &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Anyway, now we can say that sentence with a bit more confidence &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, I wonder if this can be removed, by init&apos;ing the sub-scorers up front.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about if I call nextDoc() when addScorer is called? I tried it and all tests pass, which at least means there is no test case that fails (see above comment). If I do this, I can also check if the result is NO_MORE_DOCS and don&apos;t add it to the sub scorers list in the first place.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;BTW, funny thing just happened - turns out we deprecated all of DISIs methods, but not DISI itself. This is actually good since it allows us to keep DISI and not deprecate Scorer and all the public DISIs that extend DISI. And it saves us the effort of finding alternative names ... Just a thought.&lt;/p&gt;

&lt;p&gt;Another thought of an optimization. Somewhere up this issue, we discussed adding start() to DISI, just to get rid of firstTime in DisjunctionMaxScorer and ConjunctionScorer. At least for DMS, I think I can remove add(Scorer) and add to its ctor an array of Scorer[]. DMS is used by DMQ, and the number of scorers is knows in advance.&lt;br/&gt;
Also, DMS can be changed quite a bit, not using ArrayList but an array. ArrayList get/set methods do range checks every time you call them, and we&apos;re calling them quite a lot.&lt;/p&gt;</comment>
                    <comment id="12713258" author="shaie" created="Tue, 26 May 2009 22:08:27 +0100"  >&lt;p&gt;Also, since BS.add() is called by BS2 only, and BS is package-private and instantiated by BS2 only, I can remove add, and pass to BS ctor two iterators (for prohibited and optional). That will allow us to compute coordFactor up front and remove the check from score() and score(Collector, int).&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12713273" author="paul.elschot@xs4all.nl" created="Tue, 26 May 2009 22:46:19 +0100"  >&lt;p&gt;I&apos;d also prefer to have constructors with for example a List argument for the subscorers, and use an array internally. This is easily done when the parser allows postorder query construction, and all reasonable parsers can do that.&lt;br/&gt;
When all subscorers are given in the constructor, most (or even all) of the checks on firstTime private booleans in the various scorers can be removed.&lt;/p&gt;

&lt;p&gt;One minor disadvantage of removing such firstTime booleans is that during scorer construction the index may have to be accessed because some constructors will use the next() method on their subscorers.&lt;br/&gt;
So, when BooleanScorer2 was added, I did not like the really the add() method and firstTime booleans either, but I left them in because in that way the next() method would not be called on subscorers at construction time.&lt;br/&gt;
Iirc I used constructor List arguments in the surround package, and that&apos;s still my preference.&lt;/p&gt;</comment>
                    <comment id="12713410" author="shaie" created="Wed, 27 May 2009 05:40:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;One minor disadvantage of removing such firstTime booleans is that during scorer construction the index may have to be accessed because some constructors will use the next() method on their subscorers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t see any difference between instantiating BS and immediately after that calling add several times to instantiating BS with the scorers. Accessing the index, to me, seems to be identical.&lt;/p&gt;

&lt;p&gt;In fact, by removing add() and passing the scorers in the ctor we can also get rid of redundant code in add(). Currently, it checks if the scorer is required/prohibited/both, but both does not happen in reality and in each add only required or prohibited is set.&lt;/p&gt;

&lt;p&gt;In general I think we should review such scorers and make a decision on a case-by-case basis. For BS, I&apos;d like to change it since I don&apos;t see any back-compat issue, and it should clear the code a bit. I&apos;ll go ahead and do it, and if I run into any obstacles I&apos;ll post back.&lt;/p&gt;</comment>
                    <comment id="12713493" author="mikemccand" created="Wed, 27 May 2009 10:37:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;I added testEmptyBucketWithMoreDocs in TestBooleanScorer which creates a BooleanScorer that returns 3000 the first time nextDoc is called&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Excellent!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How about if I call nextDoc() when addScorer is called? I tried it and all tests pass, which at least means there is no test case that fails (see above comment). If I do this, I can also check if the result is NO_MORE_DOCS and don&apos;t add it to the sub scorers list in the first place.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds reasonable.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another thought of an optimization. Somewhere up this issue, we discussed adding start() to DISI, just to get rid of firstTime in DisjunctionMaxScorer and ConjunctionScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think having doc() return -1 before next/advance have been called&lt;br/&gt;
was also needed (or maybe just helpful?) for this.&lt;/p&gt;

&lt;p&gt;Also, thinking more on this, isn&apos;t DISI.start() redundant?  (Since&lt;br/&gt;
such init&apos;ing could be done in Weight.scorer(), when the Scorer is&lt;br/&gt;
created)?  We&apos;re not allowed to reuse a DISI, so...&lt;/p&gt;

&lt;p&gt;Oh, I see: it&apos;s not redundant for scorers that do incremental&lt;br/&gt;
construction (BS, BS2).  But I think we should fix such cases to&lt;br/&gt;
accept all sub-queries up front, then DISI.start() is redundant?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, DMS can be changed quite a bit, not using ArrayList but an array.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;These sound like good optimizations too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, since BS.add() is called by BS2 only, and BS is package-private and instantiated by BS2 only, I can remove add, and pass to BS ctor two iterators (for prohibited and optional). That will allow us to compute coordFactor up front and remove the check from score() and score(Collector, int).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This sounds good, as well as switching BS2 to take all its sub-queries&lt;br/&gt;
up front.&lt;/p&gt;</comment>
                    <comment id="12713529" author="shaie" created="Wed, 27 May 2009 11:43:52 +0100"  >&lt;p&gt;I prefer to defer DISI.start/finish until it&apos;s actually needed. Maybe even not part of this issue. For now, I&apos;ll finish the optimizations we&apos;ve discussed and post a patch.&lt;/p&gt;

&lt;p&gt;BTW Mike, docID()&apos;s contract states that is should return -1 if nextDoc()/advance() weren&apos;t called.&lt;/p&gt;

&lt;p&gt;Also, I&apos;ve done the changes to BS and the code looks much more simpler. Working on DMS now.&lt;/p&gt;</comment>
                    <comment id="12713543" author="mikemccand" created="Wed, 27 May 2009 12:57:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;I prefer to defer DISI.start/finish until it&apos;s actually needed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.  I&apos;m thinking at this point that neither should be needed.  start() should be done on creating the Scorer, and finish() should not be needed because Scorers ought to be lightweight enough to not need closeable resources.  If one makes a custom Scorer one can always close it outside of Lucene.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW Mike, docID()&apos;s contract states that is should return -1 if nextDoc()/advance() weren&apos;t called.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, so this should mean the &quot;firstTime&quot; logic should be removable from all core Scorers.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, I&apos;ve done the changes to BS and the code looks much more simpler. Working on DMS now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fabulous &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Can&apos;t wait to see it!&lt;/p&gt;</comment>
                    <comment id="12713573" author="shaie" created="Wed, 27 May 2009 14:53:08 +0100"  >&lt;p&gt;Patch includes the new docID on DISI as well as a bunch of improvements to scorers, such as BooleanScorer, DisjunctionMaxScorer and ConjunctionScorer.&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;

&lt;p&gt;BTW, I wasn&apos;t able to completely get rid of firstTime in ConjunctionScorer, even though I moved everything to the ctor. Maybe I&apos;m missing something ...&lt;/p&gt;</comment>
                    <comment id="12713588" author="mikemccand" created="Wed, 27 May 2009 15:30:44 +0100"  >&lt;p&gt;I&apos;m seeing some patch hunks failing &amp;#8211; can you svn up to current trunk &amp;amp; repost the patch?  Thanks.&lt;/p&gt;</comment>
                    <comment id="12713597" author="shaie" created="Wed, 27 May 2009 15:55:28 +0100"  >&lt;p&gt;Can you try now?&lt;/p&gt;</comment>
                    <comment id="12713604" author="mikemccand" created="Wed, 27 May 2009 16:22:56 +0100"  >&lt;p&gt;Much better &amp;#8211; I&apos;ll look at the patch.  Thanks.&lt;/p&gt;</comment>
                    <comment id="12713608" author="mikemccand" created="Wed, 27 May 2009 16:45:09 +0100"  >&lt;p&gt;Shai can I make some small tweaks to the patch &amp;amp; post another iteration?&lt;/p&gt;</comment>
                    <comment id="12713620" author="shaie" created="Wed, 27 May 2009 17:07:11 +0100"  >&lt;p&gt;Did you seriously ask that? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Of course !&lt;/p&gt;</comment>
                    <comment id="12713636" author="mikemccand" created="Wed, 27 May 2009 17:43:06 +0100"  >&lt;p&gt;Well I don&apos;t want to have both of us working on it and then have to merge.... we need a better fast switching/assigned to mechanism...&lt;/p&gt;</comment>
                    <comment id="12713645" author="shaie" created="Wed, 27 May 2009 18:01:24 +0100"  >&lt;p&gt;It&apos;s ok. I&apos;ve been staring at this code for so long, it definitely could use fresh eyes.&lt;/p&gt;

&lt;p&gt;Besides, I&apos;ve finished all what I planned to do. So I&apos;ll just wait for your updated patch, review it, and if I&apos;ll want to add anything I&apos;ll let you know.&lt;/p&gt;

&lt;p&gt;One thing I noticed from the other issue we&apos;ve both posted patches to, is that the order of the classes in the patch don&apos;t match between us, so it&apos;s harder to compare your patch with mine. But if those are really &lt;em&gt;tweaks&lt;/em&gt;, it should show up more easily.&lt;/p&gt;</comment>
                    <comment id="12713653" author="mikemccand" created="Wed, 27 May 2009 18:35:14 +0100"  >
&lt;p&gt;Patch is looking good!&lt;/p&gt;

&lt;p&gt;OK I attached new patch... note that patch applies to latest&lt;br/&gt;
back-compat tag, so you need to run &quot;ant download-tag&quot; before applying&lt;br/&gt;
it.  Comments/questions:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Init&apos;d doc = -1 in BooleanScorer&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you add an &quot;assert scorer.docID() == -1&quot; in IndexSearcher&lt;br/&gt;
    right when it gets the scorer?  Then we can tease out where we&lt;br/&gt;
    failed to init to -1.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS&lt;br/&gt;
    after the DISI is created?  EG we do this in ConjunctionScorer.&lt;br/&gt;
    (Or, maybe, any docID that&apos;s &amp;lt; the first real docID...hmmm.)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Made DocsWriter.applyDeletes a bit more efficient &amp;#8211; no need to&lt;br/&gt;
    check for the sentinel (it&apos;s &quot;congruent&quot; w/ the existing check).&lt;br/&gt;
    Though it did require an upcast to long, so if we do any add&lt;br/&gt;
    arithmetic w/ doc where doc could be NO_MORE_DOCS we must be&lt;br/&gt;
    careful to upcast.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think we can remove the firstTime from ReqExclScorer, since&lt;br/&gt;
    docID() is defined to return -1 at start?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Made BS.coordFactors final&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed &quot;Shai Erera vs. Mike McCandless&quot; -&amp;gt; &quot;Shai Erera&lt;br/&gt;
    via Mike McCandless&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The addition of this:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (docNr == -1) { &lt;span class=&quot;code-comment&quot;&gt;// should be &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; nextDoc() was not called yet
&lt;/span&gt;      docNr = nextDoc();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;    in BooleanScorer2.score(Collector, int) makes me a bit nervous &amp;#8211;&lt;br/&gt;
    I think one is supposed to have called nextDoc prior to calling&lt;br/&gt;
    this?  Also, this was added to the same method in Scorer.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;BS2.nextDoc is still needing to check if it&apos;s supposed to call&lt;br/&gt;
    initCountingSumScorer?  Can we do this in ctor?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Actually, you did get rid of firstTime from ConjunctionScorer?&lt;br/&gt;
    Maybe you meant BS2?  (Oh, or maybe you meant the addition of&lt;br/&gt;
    &quot;} else if (lastDoc == -1) {&quot; in ConjunctionScorer?  So... if we&lt;br/&gt;
    had a way to do that sorting (in the ctor) without invoking&lt;br/&gt;
    nextDoc on each sub-scorer, then you could eliminate that extra&lt;br/&gt;
    check right?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Put some &quot;nocommit&quot; questions in the patch&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12713668" author="shaie" created="Wed, 27 May 2009 19:08:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;Fixed &quot;Shai Erera vs. Mike McCandless&quot; -&amp;gt; &quot;Shai Erera via Mike McCandless&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ha ha ha &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Sorry ...&lt;/p&gt;

&lt;p&gt;I&apos;ll take a look at the comments a bit later. Regarding ConjunctionScorer, you&apos;re right. If we had a way to sort on the scorers w/o invoking nextDoc(), we could remove that check from nextDoc().&lt;/p&gt;</comment>
                    <comment id="12713671" author="mikemccand" created="Wed, 27 May 2009 19:21:44 +0100"  >&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  It&apos;s OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Regarding ConjunctionScorer, you&apos;re right. If we had a way to sort on the scorers w/o invoking nextDoc(), we could remove that check from nextDoc()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK we may need to hold off on that until we add something like approxCount() to Scorer, or something the measures approximate cost.&lt;/p&gt;</comment>
                    <comment id="12713723" author="shaie" created="Wed, 27 May 2009 21:40:54 +0100"  >&lt;p&gt;Regarding the nocommit in ConjunctionScorer&apos;s ctor - I think the problem with moving doNext() to the end of the ctor is the order of the scorers that will be iterated on. I.e., currently the scorers are first advanced to their first doc, then sorted based on their docID, then advanced to the doc ID that all agree on, in the order of the sort.&lt;/p&gt;

&lt;p&gt;If you move doNext() to the end of the method, then the scorers are sorted based on their docID, and then immediately re-sorted (based on their sparseness, which is a heuristic applied based on their first docID).&lt;/p&gt;

&lt;p&gt;If I understand correctly, the problem with calling doNext() after the re-sort is this: assume you have 5 scorers, whose first docs are 1, 2, 3, 5, 5 respectively. Sorting leaves the array as is (or changes it to be in that order). If you call doNext() after array.sort, then you advance all the first scorers to 5 (or a larger doc ID they all agree on). However, if you do the re-sort, the order will be 5, 3, 2, 1, 5 and then if you call doNext(), it will stop immediately, since the first scorer&apos;s docs equals the last one. So you break an invariant, that after calling doNext() all scorers are on the same doc ID.&lt;/p&gt;

&lt;p&gt;That&apos;s at least how I understand it. I hope I didn&apos;t write too much to explain the obvious (to others).&lt;/p&gt;

&lt;p&gt;So I&apos;ll delete the nocommit tag.&lt;/p&gt;

&lt;p&gt;Regarding nocommit in ReqExclScorer, you&apos;re right. I&apos;ll remove firstTime entirely.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you add an &quot;assert scorer.docID() == -1&quot; in IndexSearcher right when it gets the scorer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Done.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BS2.nextDoc is still needing to check if it&apos;s supposed to call initCountingSumScorer? Can we do this in ctor?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It can, if I delete add() and do all the work in the ctor. I&apos;ll need to pass 3 arrays (Scorer[], boolean[] /&lt;b&gt;required&lt;/b&gt;/, boolean[] /&lt;b&gt;prohibited&lt;/b&gt;/) though, or pass the list of Weights, Clauses and IndexReader. I&apos;m not too fan of either. I check which is the lesser evil.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BooleanScorer2.score(Collector, int) makes me a bit nervous&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I didn&apos;t think it&apos;s such a big deal since it&apos;s one &apos;if&apos; before scoring starts. It&apos;s not like it&apos;s called for every score(). Do you think we should resolve it?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS after the DISI is created? EG we do this in ConjunctionScorer. (Or, maybe, any docID that&apos;s &amp;lt; the first real docID...hmmm.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I do not fully follow you. By allowing to return -1, we already allow any DISI to return a doc ID that&apos;s &amp;lt; the first real doc ID. And allowing to return NO_MORE_DOCS looks strange to me .. I mean imagine a code which creates a DISI and calls doc() and gets back NO_MORE_DOCS .. that&apos;d be strange, won&apos;t it?&lt;/p&gt;</comment>
                    <comment id="12713732" author="mikemccand" created="Wed, 27 May 2009 21:59:41 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Regarding the nocommit in ConjunctionScorer&apos;s ctor - I think the problem with moving doNext() to the end of the ctor is the order of the scorers that will be iterated on. I.e., currently the scorers are first advanced to their first doc, then sorted based on their docID, then advanced to the doc ID that all agree on, in the order of the sort.&lt;br/&gt;
If you move doNext() to the end of the method, then the scorers are sorted based on their docID, and then immediately re-sorted (based on their sparseness, which is a heuristic applied based on their first docID).&lt;/p&gt;

&lt;p&gt;If I understand correctly, the problem with calling doNext() after the re-sort is this: assume you have 5 scorers, whose first docs are 1, 2, 3, 5, 5 respectively. Sorting leaves the array as is (or changes it to be in that order). If you call doNext() after array.sort, then you advance all the first scorers to 5 (or a larger doc ID they all agree on). However, if you do the re-sort, the order will be 5, 3, 2, 1, 5 and then if you call doNext(), it will stop immediately, since the first scorer&apos;s docs equals the last one. So you break an invariant, that after calling doNext() all scorers are on the same doc ID.&lt;/p&gt;

&lt;p&gt;That&apos;s at least how I understand it. I hope I didn&apos;t write too much to explain the obvious (to others).&lt;/p&gt;

&lt;p&gt;So I&apos;ll delete the nocommit tag.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh &amp;#8211; good explanation!  Phew.  This must be what leads to the two&lt;br/&gt;
test failures.  So leave it where it is (maybe add a comment&lt;br/&gt;
explaining it cannot be moved down, lest anyone else gets tempted).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Can you add an &quot;assert scorer.docID() == -1&quot; in IndexSearcher right when it gets the scorer?&lt;/p&gt;

&lt;p&gt;Done.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, except we may delete it depending on the relaxing (below)...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; BS2.nextDoc is still needing to check if it&apos;s supposed to call initCountingSumScorer? Can we do this in ctor?&lt;/p&gt;

&lt;p&gt;It can, if I delete add() and do all the work in the ctor.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should (lacking a DISI.start).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;ll need to pass 3 arrays (Scorer[], boolean[] /required/, boolean[] /prohibited/) though, or pass the list of Weights, Clauses and IndexReader. I&apos;m not too fan of either. I check which is the lesser evil.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm &amp;#8211; I don&apos;t have a stronger lesser-of-evils preference.  I suppose,&lt;br/&gt;
instead, we could add a &quot;start&quot; only to BS2, which BQ would call once&lt;br/&gt;
it&apos;s done adding?  Or, simply call initCountingSumScorer from BQ and&lt;br/&gt;
don&apos;t do the check per nextDoc/advance.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; BooleanScorer2.score(Collector, int) makes me a bit nervous&lt;/p&gt;

&lt;p&gt;I didn&apos;t think it&apos;s such a big deal since it&apos;s one &apos;if&apos; before scoring starts. It&apos;s not like it&apos;s called for every score(). Do you think we should resolve it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What specifically made me nervous that it was even necessary to add&lt;br/&gt;
this (having to conditionally next wasn&apos;t needed before) in the first&lt;br/&gt;
place.  If you remove it, does something actually break?  Like what&lt;br/&gt;
caused it to be added?  (Because I want to go explore/understand&lt;br/&gt;
&lt;b&gt;that&lt;/b&gt; cause).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS after the DISI is created? EG we do this in ConjunctionScorer. (Or, maybe, any docID that&apos;s &amp;lt; the first real docID...hmmm.)&lt;/p&gt;

&lt;p&gt;I do not fully follow you. By allowing to return -1, we already allow any DISI to return a doc ID that&apos;s &amp;lt; the first real doc ID. And allowing to return NO_MORE_DOCS looks strange to me .. I mean imagine a code which creates a DISI and calls doc() and gets back NO_MORE_DOCS .. that&apos;d be strange, won&apos;t it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m thinking it&apos;s OK to call docID before next, and that all we&lt;br/&gt;
require is that call return a docID less than its first real docID.&lt;/p&gt;

&lt;p&gt;And, if you know up-front you have no docs, returning NO_MORE_DOCS up&lt;br/&gt;
front is also OK.&lt;/p&gt;

&lt;p&gt;Ie this is a relaxation over &quot;you must return -1 before nextDoc has&lt;br/&gt;
been called&quot;.&lt;/p&gt;

&lt;p&gt;(EG I think the last patch would return NO_MORE_DOCS from docID() in&lt;br/&gt;
ConjunctionScorer if it determines in ctor that no docs match).&lt;/p&gt;</comment>
                    <comment id="12713748" author="shaie" created="Wed, 27 May 2009 22:22:14 +0100"  >&lt;blockquote&gt;&lt;p&gt;BS2.nextDoc is still needing to check if it&apos;s supposed to call initCountingSumScorer? Can we do this in ctor?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;After I made add() private, created a ScorerClauseWrapper (in BQ) and passed to BS2 a list of SCW (to pass in one call Scorer, req, prohib), I couldn&apos;t still call initCountingSumScorer in the ctor. Then it reminded me that we&apos;ve had this discussion before - it&apos;s related to being able to ask for topScorer() or not. Reason is, if I call initCount...() in the ctor, it advances the sub scorers. If the scorer is then used as a topScorer, they may be advanced again, if BS is used.&lt;/p&gt;

&lt;p&gt;So I thought, let&apos;s not call nextDoc() in BS&apos;s ctor, but that leads to other problems, since the scorers passed may have called nextDoc() themselves (DisjunctionSumScorer) or may not (ReqExclScorer).&lt;/p&gt;

&lt;p&gt;The decision back then was to leave it as-is, and handle it in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;, when we&apos;ll be able to ask for topScorer. What do you think?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Like what caused it to be added?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Two lines below it, where it will be sent to Collector for collection, since it&apos;s &amp;lt; max. This hits AIOOBE for some Collectors.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think the last patch would return NO_MORE_DOCS from docID() in ConjunctionScorer if it determines in ctor that no docs match&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, now that you write it I do notice I broke that invariant in CS. If there is even one scorer that doesn&apos;t have any docs, lastDoc is already set to NO_MORE_DOCS and calling docID before nextDoc will return NO_MORE_DOCS and not -1.&lt;/p&gt;

&lt;p&gt;So I think it&apos;s a fair relaxation. Just to be clear - this is just a relaxation you&apos;re talking about right? This shouldn&apos;t affect any of the existing scorers.&lt;/p&gt;

&lt;p&gt;So if we&apos;re on the same page, I&apos;ll document that relaxation and remove the assert call I&apos;ve added to IndexSearcher. But I don&apos;t think this should actually change scorers.&lt;/p&gt;</comment>
                    <comment id="12713908" author="shaie" created="Thu, 28 May 2009 09:41:04 +0100"  >&lt;p&gt;Deprecated SpanScorer.firstTime and removed the use of it. (in general, I think that SpanScorer should be reviewed, since it&apos;s a public class that&apos;s documented that it&apos;s for inheritance), but I&apos;m not sure all methods should be open for inheritance.&lt;br/&gt;
Also, we may want to add nextDoc and advance() to Spans. But that&apos;s a different issue.&lt;/p&gt;

&lt;p&gt;I noticed I accidentally changed the signature of setFreqCurrentDoc, which is protected. So I reverted the change and added JustCompileSpanScorer which overrides that method, so we&apos;ll discover that safely in the future (test-tag still passes).&lt;/p&gt;

&lt;p&gt;I also changed the documentation of docID, stating the relaxed policy (in DISI and CHANGES).&lt;/p&gt;

&lt;p&gt;Besides, I&apos;ve fixed all of your other comments, except for BS2 initCountingSumScorer which I don&apos;t think we can do yet.&lt;/p&gt;

&lt;p&gt;In general, can we do any other optimization in a different issue? This one already contains a lot of changes, and was opened primarily for introducing the new methods. We have &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt; for further optimizations, even though we&apos;ve covered most (or all) of them here, so perhaps we should cancel it?&lt;/p&gt;</comment>
                    <comment id="12713931" author="mikemccand" created="Thu, 28 May 2009 10:59:53 +0100"  >&lt;blockquote&gt;
&lt;p&gt;After I made add() private, created a ScorerClauseWrapper (in BQ) and passed to BS2 a list of SCW (to pass in one call Scorer, req, prohib), I couldn&apos;t still call initCountingSumScorer in the ctor. Then it reminded me that we&apos;ve had this discussion before - it&apos;s related to being able to ask for topScorer() or not. Reason is, if I call initCount...() in the ctor, it advances the sub scorers. If the scorer is then used as a topScorer, they may be advanced again, if BS is used.&lt;/p&gt;

&lt;p&gt;So I thought, let&apos;s not call nextDoc() in BS&apos;s ctor, but that leads to other problems, since the scorers passed may have called nextDoc() themselves (DisjunctionSumScorer) or may not (ReqExclScorer).&lt;/p&gt;

&lt;p&gt;The decision back then was to leave it as-is, and handle it in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;, when we&apos;ll be able to ask for topScorer. What do you think?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sigh.  I wonder if you could record that next had been called, in the ScorerClauseWrapper, and then BS wouldn&apos;t re-do the next in its ctor?  That added if would only be in the ctor.&lt;/p&gt;

&lt;p&gt;But, yeah I agree: let&apos;s wind down this issue and push this (and other) optimizations into &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I noticed I accidentally changed the signature of setFreqCurrentDoc, which is protected. So I reverted the change and added JustCompileSpanScorer which overrides that method, so we&apos;ll discover that safely in the future (test-tag still passes).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops, OK good.&lt;/p&gt;

&lt;p&gt;I&apos;ll have a look through the current patch.  I think we are close!&lt;/p&gt;</comment>
                    <comment id="12714298" author="shaie" created="Fri, 29 May 2009 05:47:49 +0100"  >&lt;p&gt;Mike, I think we may have relaxed the policy of docID() a bit too much. IMO, it should be clear what this method returns, and saying that it should return any doc ID which is smaller than the first available, or NO_MORE_DOCS if it knows there are not docs in the set, is problematic.&lt;/p&gt;

&lt;p&gt;Consider the code in BS2 which checks if it should call nextDoc() before the while loop (the score(Collector, int) method). If a DISI decided to return &apos;2&apos; simply because the first doc available is &apos;3&apos;, then we may incorrectly collect &apos;2&apos;.&lt;/p&gt;

&lt;p&gt;So I say we relax the policy in this way: &quot;an implementation can return -1 if it knows the iterator is not exhausted, or NO_MORE_DOCS otherwise&quot;.&lt;/p&gt;</comment>
                    <comment id="12714366" author="mikemccand" created="Fri, 29 May 2009 09:42:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;Consider the code in BS2 which checks if it should call nextDoc() before the while loop (the score(Collector, int) method). If a DISI decided to return &apos;2&apos; simply because the first doc available is &apos;3&apos;, then we may incorrectly collect &apos;2&apos;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, I&apos;m not liking that particular added code anyway &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Ie the contract of that method (I believe) is that nextDoc must already have been called.  I don&apos;t like adding ambiguity into the API, and so instead of the check I&apos;d rather switch it to an &quot;assert docID != -1&quot;, ie, assert that nextDoc was in fact called.  And then if that assert trips up, we need to go understand the root cause for that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So I say we relax the policy in this way: &quot;an implementation can return -1 if it knows the iterator is not exhausted, or NO_MORE_DOCS otherwise&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, let&apos;s do that.  Though: it need not return NO_MORE_DOCS up front, right?  Ie, if it is able to determine up front it has no docs to iterate, great, else, it can return -1 until nextDoc() is called at which point it returns NO_MORE_DOCS?&lt;/p&gt;</comment>
                    <comment id="12714399" author="shaie" created="Fri, 29 May 2009 11:48:39 +0100"  >&lt;p&gt;I don&apos;t like that code also. But if we allow to return any value, except -1 or NO_MORE_DOCS before the iteration started, someone will have very hard time trying to write such code (to determine if the iterator has started).&lt;/p&gt;

&lt;p&gt;The current contract already specifies what this method should return when nextDoc or advance were not called. We just need to make it more explicit:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Return -1 if the iteration did not start, and there are documents to return&lt;/li&gt;
	&lt;li&gt;Return NO_MORE_DOCS if there are no more docs to return (whether the iteration started or not).&lt;/li&gt;
	&lt;li&gt;Return the doc ID on any other case..&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Note that I also wrote that this method should not throw any exception, but I think of relaxing that either, and say &quot;it is better if the implementation does not throw any exception in case there are no more documents to return&quot;. The reason is, we cannot force &quot;don&apos;t throw exception&quot; in the code ... What do you think?&lt;/p&gt;

&lt;p&gt;I will update the patch if you agree to these changes.&lt;/p&gt;</comment>
                    <comment id="12714457" author="mikemccand" created="Fri, 29 May 2009 15:14:29 +0100"  >&lt;p&gt;Let&apos;s decouple the two things we are talking about...&lt;/p&gt;

&lt;p&gt;First off, Scorer.score(Collector, int) (and also BooleanScorer2)&lt;br/&gt;
require that nextDoc has already been called.  So we should not add&lt;br/&gt;
the &quot;if&quot; into those methods; if anything, we should do the opposite&lt;br/&gt;
(add an assert).&lt;/p&gt;

&lt;p&gt;Second, the semantics of calling docID() before nextDoc/advance have&lt;br/&gt;
been called... on this I think your proposal is good, except: in the&lt;br/&gt;
event that the Scorer will not match any docs, it&apos;s also fine if it&lt;br/&gt;
returns -1.  Ie we do not require all Scorers to up-front determine&lt;br/&gt;
whether they will match docs or not.  Said another way, if a Scorer&lt;br/&gt;
will not match any docs, docID() may return either -1 or NO_MORE_DOCS&lt;br/&gt;
before nextDoc/advance have been called.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Note that I also wrote that this method should not throw any exception, but I think of relaxing that either, and say &quot;it is better if the implementation does not throw any exception in case there are no more documents to return&quot;. The reason is, we cannot force &quot;don&apos;t throw exception&quot; in the code ... What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we need to allow for docID() to throw an exception?&lt;br/&gt;
(doc() doesn&apos;t today and I haven&apos;t heard complaints, I think).&lt;/p&gt;

&lt;p&gt;If there are no more documents to return, docID() should return&lt;br/&gt;
NO_MORE_DOCS.&lt;/p&gt;</comment>
                    <comment id="12714467" author="shaie" created="Fri, 29 May 2009 15:32:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;First off, Scorer.score(Collector, int) (and also BooleanScorer2) require that nextDoc has already been called. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed. I&apos;ll take a look at the code and check if that&apos;s possible. I thought to do it, but since Scorer is public, and score(Collector, int) is protected, I didn&apos;t feel that making this assumption is a good thing and might break back-compat (i.e., if someone overrode Scorer and call this method w/o calling nextDoc() first).&lt;/p&gt;

&lt;p&gt;I&apos;ll change the semantics as you propose, saying that an impl is free to return -1 or NO_MORE_DOCS in case it knows up front there are no more docs, before nextDoc or advance were called.&lt;/p&gt;

&lt;p&gt;Regarding the exceptions, I meant runtime exceptions. The method does not declare to throw anything. But I&apos;ve seen cases, like ReqExclScorer where NPE may be thrown, or AIOOBE. That&apos;s what I would like to document - that impl should try to avoid it. Since I don&apos;t have a way in Java to restrict that, I&apos;d like that to appear in the javadocs.&lt;/p&gt;</comment>
                    <comment id="12714500" author="mikemccand" created="Fri, 29 May 2009 17:32:35 +0100"  >&lt;blockquote&gt;&lt;p&gt;Agreed. I&apos;ll take a look at the code and check if that&apos;s possible. I thought to do it, but since Scorer is public, and score(Collector, int) is protected, I didn&apos;t feel that making this assumption is a good thing and might break back-compat (i.e., if someone overrode Scorer and call this method w/o calling nextDoc() first).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well the javadoc clearly states the requirement (&quot;next must be called&quot;).  And if external Scorers are violating this, it&apos;ll cause problems if their used as sub-scorers by BooleanScorer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I&apos;ve seen cases, like ReqExclScorer where NPE may be thrown, or AIOOBE. That&apos;s what I would like to document - that impl should try to avoid it. Since I don&apos;t have a way in Java to restrict that, I&apos;d like that to appear in the javadocs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Under what cases are NPE &amp;amp; AIOOBE thrown by ReqExclScorer?  (That doesn&apos;t seem right).&lt;/p&gt;

&lt;p&gt;I don&apos;t think we need to document that you shouldn&apos;t throw RuntimeExceptions &amp;#8211; that&apos;s pretty much par for the course, right?  Or maybe I&apos;m missing something... does something go horribly wrong in particular if an exception is thrown by docID()?&lt;/p&gt;</comment>
                    <comment id="12714567" author="shaie" created="Fri, 29 May 2009 20:52:15 +0100"  >&lt;blockquote&gt;&lt;p&gt;Under what cases are NPE &amp;amp; AIOOBE thrown by ReqExclScorer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Previously, ReqExclScorer had this code:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc() {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; reqScorer.doc(); &lt;span class=&quot;code-comment&quot;&gt;// reqScorer may be &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; when next() or skipTo() already &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The current patch already fixes it to not rely on reqScorer to be or not be null (we&apos;ve also discussed this issue somewhere up this thread).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t think we need to document that you shouldn&apos;t throw RuntimeExceptions&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah ... I guess you&apos;re right. When I read the documentation it does sound kind of silly (as if we&apos;re begging &quot;please don&apos;t throw RuntimeException&quot;). I&apos;ll remove that. I just wanted to encourage implementers to not rely on an object which may or may not be null (or index going out of range).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Well the javadoc clearly states the requirement (&quot;next must be called&quot;)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right Mike, I didn&apos;t read the javadocs (shame on me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ). I&apos;ll fix the code then.&lt;/p&gt;</comment>
                    <comment id="12714589" author="shaie" created="Fri, 29 May 2009 21:45:59 +0100"  >&lt;p&gt;DISI.docID documentation (and CHANGES) changed. Also the code in Scorer and BS2 score(Collector, int) does not check for -1.&lt;/p&gt;</comment>
                    <comment id="12714762" author="shaie" created="Sat, 30 May 2009 21:24:08 +0100"  >&lt;p&gt;I was wondering if instead of adding an assert to score(Collector, int) on the doc ID not being -1, we create another method score(Collector, int, int /* firstDocID */) and deprecate the current one.&lt;br/&gt;
It will behave exactly as score(Collector, int), only I think it makes it more explicit that we require nextDoc() to be called before. The documentation can state that the method expects the first doc ID and not a negative number.&lt;/p&gt;

&lt;p&gt;Besides, the code today does: (1) nextDoc() and (2) score(Collector, int) which then calls docID(). If we allow to pass the first doc ID, we can use the value that&apos;s returned from nextDoc() (e.g., score(Collector, int, nextDoc())).&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12714849" author="mikemccand" created="Sun, 31 May 2009 11:33:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;we create another method score(Collector, int, int /* firstDocID */) and deprecate the current one.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that makes sense!&lt;/p&gt;</comment>
                    <comment id="12714854" author="mikemccand" created="Sun, 31 May 2009 12:08:47 +0100"  >&lt;p&gt;It seems like we lost this at some point (I couldn&apos;t find it in the latest patch)?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Can you add an &quot;assert scorer.docID() == -1&quot; in IndexSearcher right when it gets the scorer?&lt;/p&gt;

&lt;p&gt;Done.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When I add &lt;tt&gt;assert scorer.docID() == -1 || scorer.docID() == Scorer.NO_MORE_DOCS;&lt;/tt&gt;  in doSearch, after we get the scorer, all tests pass.  Was there something that went wrong when you added it?&lt;/p&gt;</comment>
                    <comment id="12714856" author="shaie" created="Sun, 31 May 2009 12:28:48 +0100"  >&lt;p&gt;Ok I&apos;ll add this method.&lt;/p&gt;

&lt;p&gt;Regarding that assert, you wrote the following somewhere up this thread:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;    &amp;gt; Can you add an &quot;assert scorer.docID() == -1&quot; in IndexSearcher right when it gets the scorer?&lt;/p&gt;

&lt;p&gt;    Done.&lt;/p&gt;

&lt;p&gt;OK, except we may delete it depending on the relaxing (below)...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So I removed it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Anyway I&apos;ll add it back.&lt;/p&gt;</comment>
                    <comment id="12714857" author="mikemccand" created="Sun, 31 May 2009 12:38:51 +0100"  >&lt;blockquote&gt;&lt;p&gt;So I removed it . Anyway I&apos;ll add it back.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh, OK &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  But we didn&apos;t end up relaxing the semantics, ie we are back to &quot;docID() must return -1 or NO_MORE_DOCS before nextDoc/advance have been called&quot;... so let&apos;s just add it back.&lt;/p&gt;</comment>
                    <comment id="12714859" author="shaie" created="Sun, 31 May 2009 13:24:01 +0100"  >&lt;p&gt;Added Scorer.score(Collector, int, int) and deprecated the other one, with an impl:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; score(collector, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, docID());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I also added the assert to IndexSearcher.doSearch.&lt;/p&gt;

&lt;p&gt;Do you think we should add &apos;assert firstDocID &amp;gt;= 0&apos; to the new score(Collector, int, int) implementations? It seems redundant to me ... &lt;/p&gt;</comment>
                    <comment id="12714898" author="mikemccand" created="Sun, 31 May 2009 17:40:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;Do you think we should add &apos;assert firstDocID &amp;gt;= 0&apos; to the new score(Collector, int, int) implementations? It seems redundant to me ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, I think it&apos;s redundant.  Let&apos;s skip it.&lt;/p&gt;</comment>
                    <comment id="12714900" author="shaie" created="Sun, 31 May 2009 17:54:09 +0100"  >&lt;p&gt;Ok then I guess we&apos;re ready for the final (hopefully &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) iteration.&lt;/p&gt;</comment>
                    <comment id="12714905" author="mikemccand" created="Sun, 31 May 2009 18:40:08 +0100"  >&lt;p&gt;Yes... I&apos;m reviewing &amp;amp; I&apos;ll post any changes...&lt;/p&gt;</comment>
                    <comment id="12715064" author="mikemccand" created="Mon, 1 Jun 2009 12:16:12 +0100"  >&lt;p&gt;OK I think we&apos;re getting close... I attached patch w/ these&lt;br/&gt;
changes/questions:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think we should require that nextDoc/advance not be called again&lt;br/&gt;
    once NO_MORE_DOCS has already been returned?  This would save&lt;br/&gt;
    checks, eg in ConjunctionScorer &amp;amp; DisjunctionMaxScorer &amp;amp;&lt;br/&gt;
    ReqExclScorer at least, for &quot;did I already return NO_MORE_DOCS&quot; on&lt;br/&gt;
    every nextDoc call.  Some things already seem to require this (eg&lt;br/&gt;
    DocIdBitSet&apos;s DISI).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think the new code for applying a filter during searching (~line&lt;br/&gt;
    282 of IndexSearcher) can be made more efficient in the &quot;if&lt;br/&gt;
    (scorerDoc == filterDoc)&quot; case.  Inside there, we ask&lt;br/&gt;
    filterDocIter to do nextDoc(), at which point we know scorerDoc is&lt;br/&gt;
    &amp;lt; filterDoc, and so it&apos;d be better to call scorer.advance, there,&lt;br/&gt;
    instead of wrapping around the loop and having to do the if at the&lt;br/&gt;
    top?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed bug in how &quot;more&quot; is computed in BooleanScorer (we were&lt;br/&gt;
    directly assigning to more instead of or&apos;ing in the new value)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Various cosmetic changes &amp;#8211; removed unused vars, imports; made&lt;br/&gt;
    some attrs final.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;[As a separate issue, it seems like NonMatchingScorer should be&lt;br/&gt;
    removed, and we should fix BooleanQuery.scorer to instead return&lt;br/&gt;
    null in such cases]&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12715070" author="shaie" created="Mon, 1 Jun 2009 12:58:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think we should require that nextDoc/advance not be called again once NO_MORE_DOCS has already been returned?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you mean add something like this to the javadocs &quot;after NO_MORE_DOCS was returned, you should not call this method again, or it may result in unpredicted behavior&quot;?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Some things already seem to require this (eg DocIdBitSet&apos;s DISI).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean that this will remove the d == -1 check?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think the new code for applying a filter during searching (~line 282 of IndexSearcher) ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you mean to change the last line here:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (scorerDoc == filterDoc) { &lt;span class=&quot;code-comment&quot;&gt;// permitted by filter
&lt;/span&gt;        collector.collect(scorerDoc);
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) {
  &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((scorerDoc = scorer.advance(filterDoc)) == DocIdSetIterator.NO_MORE_DOCS) {
  &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I don&apos;t see what it will give us since after the loop wraps around, we check anyway if filterDoc &amp;gt; scoreDoc.&lt;/p&gt;

&lt;p&gt;But .. I think the while loop can be changed to:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; filterDoc = filterDocIdIterator.nextDoc();
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; scorerDoc = scorer.advance(filterDoc);
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (filterDoc == DocIdSetIterator.NO_MORE_DOCS
    || scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}

collector.setScorer(scorer);
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
  &lt;span class=&quot;code-comment&quot;&gt;// scorerDoc &amp;gt;= filterDoc
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (scorerDoc == filterDoc) { &lt;span class=&quot;code-comment&quot;&gt;// permitted by filter
&lt;/span&gt;    collector.collect(scorerDoc);
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
  } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((filterDoc = filterDocIdIterator.advance(scorerDoc)) == DocIdSetIterator.NO_MORE_DOCS) &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;

  &lt;span class=&quot;code-comment&quot;&gt;// The above code may have moved filterDoc beyond scorerDoc, so advance scorerDoc
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ((scorerDoc = scorer.advance(filterDoc)) == DocIdSetIterator.NO_MORE_DOCS) &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;Also Mike - the patch you posted is 152KB, while my last patch is 201KB. It&apos;s hard to compare our patches since the order of the classes is different, so until I apply the patch and check it, I wanted to make sure you included all the changes in the patch. (comparing our previous 2 patches from May 27 - they were of same size, so the last one is a bit fishy).&lt;/p&gt;</comment>
                    <comment id="12715072" author="mikemccand" created="Mon, 1 Jun 2009 13:19:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;So you mean add something like this to the javadocs &quot;after NO_MORE_DOCS was returned, you should not call this method again, or it may result in unpredicted behavior&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right.  And, optimizing the core Scorers based on this (ie, to stop&lt;br/&gt;
checking if they had already returned NO_MORE_DOCS, in&lt;br/&gt;
nextDoc/advance).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You mean that this will remove the d == -1 check?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, I think that check must remain, even once we switch to the new&lt;br/&gt;
semantics.  What I meant was, currently, if I call nextDoc() on&lt;br/&gt;
DocIdBitSet&apos;s DISI after nextDoc had already returned NO_MORE_DOCS, it&lt;br/&gt;
looks like I&apos;ll get into trouble because that will then call&lt;br/&gt;
BitSet.nextSetBit(NO_MORE_DOCS+1), ie,&lt;br/&gt;
BitSet.nextSetBit(Integer.MIN_VALUE), which&apos;ll throw an exception.&lt;br/&gt;
Ie, this DISI already requires that you don&apos;t call nextDoc() again&lt;br/&gt;
after it&apos;s returned NO_MORE_DOCS.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So you mean to change the last line here:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, I meant in the case where filterDoc == scorerDoc, you ought&lt;br/&gt;
to advance both filter &amp;amp; scorer, not just filter (you know at that&lt;br/&gt;
point that both must advance).&lt;/p&gt;

&lt;p&gt;I think the new while loop is buggy: if scorerDoc is not == filterDoc,&lt;br/&gt;
and you ask filterDocIdIter to advance to scorerDoc, it may advance to&lt;br/&gt;
become ==, yet you then illegally advance scorerDoc to filterDoc?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also Mike - the patch you posted is 152KB, while my last patch is 201KB. It&apos;s hard to compare our patches since the order of the classes is different, so until I apply the patch and check it, I wanted to make sure you included all the changes in the patch. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m pretty sure this is OK: it&apos;s because I changed the eol-style to&lt;br/&gt;
native (in my local checkout), which then caused &quot;svn diff&quot; to produce&lt;br/&gt;
more reasonable diffs.  In your patch, there are several files where&lt;br/&gt;
the entire file is deleted, and then the entire new file is added,&lt;br/&gt;
because the eol-style wasn&apos;t set.  If you &quot;grep Index: patch.txt | wc&quot;&lt;br/&gt;
of yours &amp;amp; mine, they should the same.&lt;/p&gt;</comment>
                    <comment id="12715081" author="shaie" created="Mon, 1 Jun 2009 14:20:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think the new while loop is buggy:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right. But then, I don&apos;t see the benefit of adding that advance() call, since in the while loop you&apos;d still need to check whether filterDoc &amp;gt; scorerDoc. So why do it? Is it just a matter of &apos;not relying on the above instruction, since at that point I know both should be advanced&apos;?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I changed the eol-style to native&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you explain me what that means? Maybe I should also change it in my eclipse?&lt;/p&gt;</comment>
                    <comment id="12715090" author="shaie" created="Mon, 1 Jun 2009 15:06:20 +0100"  >&lt;p&gt;Actually, Mike, removing those check from ConjunctionScorer is a bit problematic. After I changed CS to initialize in the ctor, it may realize one of the Scorers does not have any more documents, and so set lastDoc to be NO_MORE_DOCS.&lt;br/&gt;
Then, nextDoc() is called by BS2.score(Collector), which yields down the stack to TermScorer attempting to score Integer.MAX_VALUE and AIOOBE is thrown, or for some other query to ReqExclScorer to throw NPE.&lt;/p&gt;

&lt;p&gt;So I think the solution is to make sure Scorers which do not have a nextDoc() should not be passed to CS in the first place. And remove this check from CS ctor.&lt;/p&gt;</comment>
                    <comment id="12715104" author="shaie" created="Mon, 1 Jun 2009 15:54:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;So I think the solution is to make sure Scorers which do not have a nextDoc() should not be passed to CS in the first place. And remove this check from CS ctor.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m afraid that&apos;s impossible too, since CS advances all Scorers in its ctor to the first agreed-upon doc ID, which may result in NO_MORE_DOCS right upfront.&lt;/p&gt;

&lt;p&gt;What if we document that you shouldn&apos;t call nextDoc() after it return NO_MORE_DOCS for now, and then maybe we do proceed (in another issue) with the DISI.start() method. Then CS can implement start() and return false if there are no more docs?&lt;/p&gt;

&lt;p&gt;I also tried changing BS2.score(Collector) to first check the docID of countingSumScorer, but that is not good either, since a Scorer is allowed to return -1 or NO_MORE_DOCS before nextDoc() was called ...&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12715117" author="mikemccand" created="Mon, 1 Jun 2009 16:20:05 +0100"  >
&lt;blockquote&gt;&lt;p&gt;But then, I don&apos;t see the benefit of adding that advance() call, since in the while loop you&apos;d still need to check whether filterDoc &amp;gt; scorerDoc. So why do it? Is it just a matter of &apos;not relying on the above instruction, since at that point I know both should be advanced&apos;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since you know both should be advanced, why loop back and do an&lt;br/&gt;
unecessary if check?  Ie, I the CPU will do more work (computing a&lt;br/&gt;
redundant if) if we don&apos;t advance both.&lt;/p&gt;

&lt;p&gt;However, my solution (also advancing the scorer) is still not right,&lt;br/&gt;
because on cycling back you know scorerDoc &amp;gt;= filterDoc, so we&apos;ve also&lt;br/&gt;
wasted an if check there... hmmm.&lt;/p&gt;

&lt;p&gt;So actually let&apos;s just stick w/ your current approach, since it&apos;s a&lt;br/&gt;
straight conversion of what trunk currently does, except can we stop&lt;br/&gt;
checking NO_MORE_DOCS on each advance/nextDoc, and only check it when&lt;br/&gt;
we&apos;re about to collect a doc?&lt;/p&gt;

&lt;p&gt;And, anyway, maybe we shouldn&apos;t fret so much about it; we know this&lt;br/&gt;
filter loop needs to change for 2.9 anyway.  I think we want something&lt;br/&gt;
like this:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;If filter is random access, it should be pushed all the way down&lt;br/&gt;
    and applied just like deleted docs&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If filter is &quot;relatively&quot; sparse compared to query, then we should&lt;br/&gt;
    to use the (to-be-added) DISI.check() method&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Else, add filter as clause on BQ.  If incoming Query is already a&lt;br/&gt;
    BQ, clone that and tack filter on as clause; else, make a BQ and&lt;br/&gt;
    add both.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;Can you explain me what that means? Maybe I should also change it in my eclipse?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;re supposed to do this (tell svn to use native EOL &amp;#8211; &quot;svn propset&lt;br/&gt;
svn:eol-style native&quot;) for all our sources, to avoid issues like&lt;br/&gt;
this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What if we document that you shouldn&apos;t call nextDoc() after it return NO_MORE_DOCS for now&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, let&apos;s do that.  We can leave &quot;taking advantage of this&quot; (start&lt;br/&gt;
method) to another issue.  But let&apos;s be crystal clear on the semantics&lt;br/&gt;
of DISI for this issue.&lt;/p&gt;</comment>
                    <comment id="12715129" author="shaie" created="Mon, 1 Jun 2009 16:39:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;But let&apos;s be crystal clear on the semantics of DISI for this issue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll change the Javadocs. Actually nextDoc() was already documented that way, I&apos;ll add it to advance also.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Since you know both should be advanced, why loop back and do an unecessary if check?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You do the &apos;if&apos; check anyway because of scorer.advance() before the loop starts. If we remove scorer.advance() before the loop starts, we can remove the &apos;if&apos; check also.&lt;br/&gt;
Anyway, I&apos;ll try to optimize that code segment.&lt;/p&gt;</comment>
                    <comment id="12715233" author="shaie" created="Mon, 1 Jun 2009 21:12:38 +0100"  >&lt;p&gt;Changed IndexSearcher.doSearch a bit. I think it&apos;s more efficient now, since it does not check for filterDoc &amp;gt; scorerDoc at the beginning of the iteration, but rather is handled at the &apos;else&apos; part. (since when we enter the loop scorerDoc &amp;gt;= filterDoc, that check should not have happened right at the beginning).&lt;/p&gt;

&lt;p&gt;I also changed DISI&apos;s nextDoc and advance javadocs, to advise against calling them after the iterator has exhausted.&lt;/p&gt;</comment>
                    <comment id="12715277" author="mikemccand" created="Mon, 1 Jun 2009 22:43:25 +0100"  >&lt;p&gt;Patch looks good!  I plan to commit in a day or two...&lt;/p&gt;</comment>
                    <comment id="12715280" author="thetaphi" created="Mon, 1 Jun 2009 23:04:08 +0100"  >&lt;p&gt;Quickly looking over the code:&lt;/p&gt;

&lt;p&gt;Javadocs for DocIdSetIterator still sometimes contain -1 instead of NO_MORE_DOCS&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    Scorer.score(Collector, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) was deprecated in favor of 
+    Scorer.score(Collector, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;) which take an extra &apos;firstDocID&apos; 
+    parameter. This is meant to ensure nextDoc() is called before &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Collector is a new class in 2.9, so no need to deprecate (in the code it seems correct).&lt;/p&gt;

&lt;p&gt;Will look into it more detailed tomorrow.&lt;/p&gt;</comment>
                    <comment id="12715399" author="shaie" created="Tue, 2 Jun 2009 08:01:57 +0100"  >&lt;p&gt;Updated to 20090601a tag.&lt;br/&gt;
I also removed the comment on Scorer from CHANGES. Thanks Uwe - this deprecation stuff really got over me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I deleted the method from Scorer as well.&lt;/p&gt;

&lt;p&gt;Uwe, regarding the -1 in DISI - -1 is a valid value for docID() in case nextDoc/advance were not called yet. That&apos;s why you see it in the javadocs. I did however fix advance&apos;s sample code in the javadocs to return NO_MORE_DOCS instead of -1. If that&apos;s what you meant, then thanks for spotting that.&lt;/p&gt;</comment>
                    <comment id="12715405" author="thetaphi" created="Tue, 2 Jun 2009 08:42:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;Uwe, regarding the -1 in DISI - -1 is a valid value for docID() in case nextDoc/advance were not called yet. That&apos;s why you see it in the javadocs. I did however fix advance&apos;s sample code in the javadocs to return NO_MORE_DOCS instead of -1. If that&apos;s what you meant, then thanks for spotting that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I meant the sample code that explains how it is internally implemented for backwards compatibility (if not overwritten). So you fixed the right one, I think.&lt;/p&gt;

&lt;p&gt;There is one other thing with the deprecation: When we deprectated the Filters getBits() method we un-abstracted this method and added the new one with the note, that it will be made abstract and the old bits() removed.&lt;/p&gt;

&lt;p&gt;You kept the old methods skipTo() and next() abstract, but deprecated. One must now always implement next() and skipTo() but gets a deprecated warning because of that. So I would do it in the same way like bits() for filters. Un-abstract it and implement it with throwing an UnsupportedOperationException(). The new advance() and others are calling this method (as it is now). If somebody overwrites this abstract class, he can leave out the deprecated one, will get no warning. As the method is not called anymore by Lucene he will never see a UOE. In 3.0 it can easily removed without problems for any users.&lt;/p&gt;</comment>
                    <comment id="12715425" author="shaie" created="Tue, 2 Jun 2009 09:46:55 +0100"  >&lt;p&gt;Thanks Uwe - that&apos;s a good idea. I&apos;ve implemented all 3 to throw UOE as well as document that in their javadocs. I kept nextDoc() as is, i.e., calling doc() instead of docID(), since that&apos;s required for back-compat. Since all DISIs should have their doc() implemented, that shouldn&apos;t be a problem.&lt;/p&gt;</comment>
                    <comment id="12715428" author="thetaphi" created="Tue, 2 Jun 2009 09:53:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;I kept nextDoc() as is, i.e., calling doc() instead of docID(), since that&apos;s required for back-compat.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But doc() is also deprecated, why should they have implemented it? This makes no sense for me. Non-deprecated-code should always call non-deprectaed methods, so docID().&lt;/p&gt;

&lt;p&gt;EDIT: Ah sorry, you are right. new iterators would override this method and not call doc() and next().&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Since all DISIs should have their doc() implemented, that shouldn&apos;t be a problem.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This should be &quot;Since all DISIs should have their docID() implemented, that shouldn&apos;t be a problem.&quot;, then it makes sense to me.&lt;/p&gt;</comment>
                    <comment id="12715431" author="shaie" created="Tue, 2 Jun 2009 10:00:50 +0100"  >&lt;p&gt;This is all to support jar drop-in ability. So say you wrote your own DISI with doc(), next() and skipTo() and now pass it to 2.9. The code in 2.9 will call nextDoc(), but you have implemented docID(), just doc(). Therefore nextDoc() cannot call docID(), same as it calls next() which is also deprecated.&lt;/p&gt;

&lt;p&gt;We cannot implement docID() by calling doc() either, since docID() defines new semantics, which existing doc() implementations may not adhere to.&lt;/p&gt;

&lt;p&gt;Of course, if someone chooses to change his/her code, he/she should override all 3 and provide his/her own implementation, especially since all 3 of them will become abstract in 3.0.&lt;/p&gt;

&lt;p&gt;I actually meant to say &quot;Since all DISIs should have their &lt;b&gt;doc()&lt;/b&gt; implemented ...&quot; - that&apos;s the jar drop-in ability side of the story. Not all DISIs will have their docID() implemented. In fact none of them will, unless someone upgrades his code.&lt;/p&gt;

&lt;p&gt;Right?&lt;/p&gt;</comment>
                    <comment id="12715434" author="thetaphi" created="Tue, 2 Jun 2009 10:08:26 +0100"  >&lt;p&gt;Yes! Sorry for the false alarm, I did not think to the end.&lt;/p&gt;

&lt;p&gt;For completely new impls of DISI, one can leave the deprecated methods as they are and is also fine (and will get no deprecations), because current code will not call the old methods anymore. If he would drop this new class into an old Lucene it will throw UOE, but this is not what he should do.&lt;/p&gt;</comment>
                    <comment id="12716014" author="mikemccand" created="Wed, 3 Jun 2009 19:11:03 +0100"  >&lt;p&gt;Latest patch looks good.  I plan to commit in a day or two.  Phew!  Thank Shai.&lt;/p&gt;</comment>
                    <comment id="12717053" author="mikemccand" created="Sun, 7 Jun 2009 17:59:16 +0100"  >&lt;p&gt;Thanks Shai!&lt;/p&gt;</comment>
                    <comment id="12731647" author="thetaphi" created="Wed, 15 Jul 2009 20:41:32 +0100"  >&lt;p&gt;As Yonik noted on java-user, the backwards pattern is wrongly implemented for DocIdSetIterator.advance(). It should simply call skipTo, so that iterators only implementing skipTo() work correct when updated to Lucene 2.9.&lt;/p&gt;

&lt;p&gt;The method advance should look similar to nextDoc(), only next() replaced by skipTo()&lt;/p&gt;

&lt;p&gt;Uwe&lt;/p&gt;</comment>
                    <comment id="12731648" author="thetaphi" created="Wed, 15 Jul 2009 20:45:32 +0100"  >&lt;p&gt;This patch fixes this. All tests, especially test-tag pass.&lt;/p&gt;</comment>
                    <comment id="12731653" author="thetaphi" created="Wed, 15 Jul 2009 21:06:59 +0100"  >&lt;p&gt;Here is a second possibility, maybe better. The javadocs of advance note, that it may be called with NO_MORE_DOCS as parameter. skipTo may not be able to handle this. So I added an extra check to the BW-compatiility method. Is this better, or is the first patch ok?&lt;/p&gt;

&lt;p&gt;I see no difference. Maybe yonik could try this out with Solr?&lt;/p&gt;</comment>
                    <comment id="12731656" author="mikemccand" created="Wed, 15 Jul 2009 21:15:01 +0100"  >&lt;p&gt;Whoa I agree: advance should fallback to skipTo.  What a doozie.  Crazy we didn&apos;t catch this the first time around.&lt;/p&gt;

&lt;p&gt;I think the 2nd patch is safest.  There may be DISIs out there for which skipTo(Integer.MAX_VALUE) is costly and/or throws an errant exception.  I&apos;ll commit soon.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12413595" name="LUCENE-1614-advance-bw.patch" size="584" author="thetaphi" created="Wed, 15 Jul 2009 21:06:59 +0100" />
                    <attachment id="12413592" name="LUCENE-1614-advance-bw.patch" size="507" author="thetaphi" created="Wed, 15 Jul 2009 20:45:32 +0100" />
                    <attachment id="12409648" name="LUCENE-1614.patch" size="217022" author="shaie" created="Tue, 2 Jun 2009 09:46:55 +0100" />
                    <attachment id="12409641" name="LUCENE-1614.patch" size="217118" author="shaie" created="Tue, 2 Jun 2009 08:01:57 +0100" />
                    <attachment id="12409592" name="LUCENE-1614.patch" size="217408" author="shaie" created="Mon, 1 Jun 2009 21:12:38 +0100" />
                    <attachment id="12409557" name="LUCENE-1614.patch" size="156124" author="mikemccand" created="Mon, 1 Jun 2009 12:16:12 +0100" />
                    <attachment id="12409496" name="LUCENE-1614.patch" size="205738" author="shaie" created="Sun, 31 May 2009 13:24:01 +0100" />
                    <attachment id="12409416" name="LUCENE-1614.patch" size="201283" author="shaie" created="Fri, 29 May 2009 21:45:59 +0100" />
                    <attachment id="12409246" name="LUCENE-1614.patch" size="202126" author="shaie" created="Thu, 28 May 2009 09:41:01 +0100" />
                    <attachment id="12409190" name="LUCENE-1614.patch" size="138700" author="mikemccand" created="Wed, 27 May 2009 18:35:14 +0100" />
                    <attachment id="12409175" name="LUCENE-1614.patch" size="138420" author="shaie" created="Wed, 27 May 2009 15:55:28 +0100" />
                    <attachment id="12409164" name="LUCENE-1614.patch" size="137833" author="shaie" created="Wed, 27 May 2009 14:53:07 +0100" />
                    <attachment id="12408903" name="LUCENE-1614.patch" size="103700" author="shaie" created="Sun, 24 May 2009 08:30:32 +0100" />
                    <attachment id="12408701" name="LUCENE-1614.patch" size="103413" author="shaie" created="Thu, 21 May 2009 15:08:56 +0100" />
                    <attachment id="12408487" name="LUCENE-1614.patch" size="84264" author="shaie" created="Tue, 19 May 2009 15:34:16 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>15.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 27 Apr 2009 17:34:05 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12143</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26114</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>