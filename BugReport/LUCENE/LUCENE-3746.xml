<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:28:31 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3746/LUCENE-3746.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3746] suggest.fst.Sort.BufferSize should not automatically fail just because of freeMemory()</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3746</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Follow up op dev thread: &lt;a href=&quot;http://markmail.org/message/d7ugfo5xof4h5jeh&quot; class=&quot;external-link&quot;&gt;FSTCompletionTest failure &quot;At least 0.5MB RAM buffer is needed&quot; &lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12540949">LUCENE-3746</key>
            <summary>suggest.fst.Sort.BufferSize should not automatically fail just because of freeMemory()</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="doronc">Doron Cohen</assignee>
                                <reporter username="doronc">Doron Cohen</reporter>
                        <labels>
                    </labels>
                <created>Thu, 2 Feb 2012 16:22:17 +0000</created>
                <updated>Fri, 10 May 2013 11:44:54 +0100</updated>
                    <resolved>Tue, 7 Feb 2012 07:05:13 +0000</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>modules/spellchecker</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13198979" author="doronc" created="Thu, 2 Feb 2012 17:12:39 +0000"  >&lt;p&gt;Simple fix: consult also with maxMemory if freeMemory not suffice.&lt;/p&gt;</comment>
                    <comment id="13199038" author="doronc" created="Thu, 2 Feb 2012 18:06:09 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://markmail.org/message/jobtemqm4u4vrxze&quot; class=&quot;external-link&quot;&gt;Dawid:&lt;/a&gt; (maxMemory - totalMemory) because that&apos;s how much the heap can&lt;br/&gt;
grow? The problem is none of this is atomic, so the result can&lt;br/&gt;
unpredictable. There are other methods in management interface that&lt;br/&gt;
permit a somewhat more detailed checks.  Don&apos;t know if they guarantee&lt;br/&gt;
atomicity of the returned snapshot, but I doubt it.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/management/MemoryMXBean.html#getHeapMemoryUsage()&quot; class=&quot;external-link&quot;&gt;MemoryMXBean.getHeapMemoryUsage()&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/management/MemoryPoolMXBean.html#getPeakUsage()&quot; class=&quot;external-link&quot;&gt;MemoryPoolMXBean.getPeakUsage()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Current patch not (yet) handling the atomicity issue Dawid described. &lt;/p&gt;</comment>
                    <comment id="13200802" author="doronc" created="Sun, 5 Feb 2012 16:39:10 +0000"  >&lt;p&gt;Updated patch using ManagementFactory.getMemoryMXBean().getHeapMemoryUsage(). &lt;/p&gt;

&lt;p&gt;Javadocs are not explicit about this call being atomic, but from the wording it seems almost certain to conclude that each call returns a new Usage instance. In this patch this is (Java) asserted and the assert passes (-ea) in two different JVMs - IBM and Oracle - so this might be correct. I searched some more explicit info on this with no success. &lt;/p&gt;

&lt;p&gt;Annoyingly though, in IBM JDK, running the tests like this produces the nice warning:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;WARNING: test class left thread running: Thread[MemoryPoolMXBean notification dispatcher,6,main]
RESOURCE LEAK: test class left 1 thread(s) running
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This makes me reluctant to use the memory bean - I did not find a way to prevent that thread leak.&lt;/p&gt;

&lt;p&gt;So perhaps a better approach would be to be conservative about the sequence of calls when using Runtime? something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; free = rt.freeMemory();
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (free is sufficient)
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; decideBy(free);
&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; max = rt.maxMemory();
&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; total = rt.totalMemory();
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; decideBy(max - total)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is conservative in that &apos;total&apos; is computed last, and in that total-free is not added to the computed available bytes.&lt;/p&gt;

&lt;p&gt;In both approaches, even if atomicity is guaranteed, it is possible that more heap is allocated in another thread between the time that the size is computed, to the time that the bytes are actually allocated, so not sure how safe this check can be made.&lt;/p&gt;</comment>
                    <comment id="13200806" author="doronc" created="Sun, 5 Feb 2012 17:00:13 +0000"  >&lt;p&gt;Updated patch - without MemoryMXBean - computing &apos;max, total, free&apos; (in that order) and deciding by &apos;free&apos; or falling to &apos;max-free&apos;. This is more conservative, than MemoryMxBean but since the latter is not full proof either, I prefer the simpler approach. &lt;/p&gt;</comment>
                    <comment id="13200834" author="dweiss" created="Sun, 5 Feb 2012 19:53:02 +0000"  >&lt;p&gt;As for spawning MemoryPoolMXBean &amp;#8211; I wouldn&apos;t be worried about it, it&apos;s probably a system daemon thread for sending memory threshold notifications  (didn&apos;t check though). I will peek at openjdk sources and see how the mx is implemented to verify if it&apos;s atomic or not (not a guarantee, just curiosity).&lt;/p&gt;</comment>
                    <comment id="13200843" author="dweiss" created="Sun, 5 Feb 2012 20:05:55 +0000"  >&lt;p&gt;Just checked and it seems to be that within a single memory pool the results will be atomic. Unfortunately that call aggregates all memory pools and (depending on the GC used) this may result in inconsistencies if the calculation happens to be interwoven with garbage collector activity. As stated in the sources of G1, for example:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;// 4) Now, there is a very subtle issue with all the above. The
// framework will call get_memory_usage() on the three pools
// asynchronously. As a result, each call might get a different value
// for, say, survivor_num which will yield inconsistent values for
// eden_used, survivor_used, and old_gen_used (as survivor_num is used
// in the calculation of all three). This would normally be
// ok. However, it&apos;s possible that this might cause the sum of
// eden_used, survivor_used, and old_gen_used to go over the max heap
// size and this seems to sometimes cause JConsole (and maybe other
// clients) to get confused. There&apos;s not a really an easy / clean
// solution to this problem, due to the asynchrounous nature of the
// framework. 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Makes sense to me. I wouldn&apos;t bother with management interface then and just use the Runtime.* heuristic you proposed.&lt;/p&gt;</comment>
                    <comment id="13201073" author="doronc" created="Mon, 6 Feb 2012 06:33:17 +0000"  >&lt;p&gt;Thanks Dawid! &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;it&apos;s probably a system daemon thread for sending memory threshold notifications&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes this makes sense. &lt;br/&gt;
Still the difference between the two JDKs felt bothering.&lt;br/&gt;
Some more digging, and now I think it is clear. &lt;/p&gt;

&lt;p&gt;Here are the stack traces reported (at the end of the test) with Oracle:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1.  Thread[ReaderThread,5,main]
2.  Thread[main,5,main]
3.  Thread[Reference Handler,10,system]
4.  Thread[Signal Dispatcher,9,system]
5.  Thread[Finalizer,8,system]
6.  Thread[Attach Listener,5,system]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And with IBM JDK:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1.  Thread[Attach API wait loop,10,main]
2.  Thread[Finalizer thread,5,system]
3.  Thread[JIT Compilation Thread,10,system]
4.  Thread[main,5,main]
5.  Thread[Gc Slave Thread,5,system]
6.  Thread[ReaderThread,5,main]
7.  Thread[Signal Dispatcher,5,main]
8.  Thread[MemoryPoolMXBean notification dispatcher,6,main]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The 8th thread is the one that started only after accessing the memory management layer. The thing is, that in the IBM JDK that thread is created in the ThreadGroup &quot;main&quot;, while in the Oracle JDK it is created under &quot;system&quot;. To me the latter makes more sense. &lt;/p&gt;

&lt;p&gt;To be more sure I added a fake memory notification listener and check the thread in which notification happens: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
MemoryMXBean mmxb = ManagementFactory.getMemoryMXBean();
NotificationListener listener = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NotificationListener() {
  @Override
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void handleNotification(Notification notification, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; handback) {
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.currentThread());
  }
};
((NotificationEmitter) mmxb).addNotificationListener(listener, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Evidently in IBM JDK the notification is in &quot;main&quot; group thread (also in line with the thread-group in the original warning message which triggered this threads discussion):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Thread[MemoryPoolMXBean notification dispatcher,6,main]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While in Oracle JDK notification is in &quot;system&quot; group thread:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Thread[Low Memory Detector,9,system]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This also explains why the warning is reported only for IBM JDK: because the threads check in LTC only account for the threads in the same thread-group as the one running the specific test case. So when dispatching happens in a &quot;system&quot; group thread it is not sensed by that check at all.&lt;/p&gt;

&lt;p&gt;Ok now with mystery solved I can commit the simpler code...&lt;/p&gt;</comment>
                    <comment id="13202121" author="doronc" created="Tue, 7 Feb 2012 07:05:13 +0000"  >&lt;p&gt;Committed:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;r1241355 - trunk&lt;/li&gt;
	&lt;li&gt;r1241363 - 3x&lt;/li&gt;
&lt;/ul&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12513311" name="LUCENE-3746.patch" size="2423" author="doronc" created="Sun, 5 Feb 2012 17:00:13 +0000" />
                    <attachment id="12513310" name="LUCENE-3746.patch" size="2821" author="doronc" created="Sun, 5 Feb 2012 16:39:10 +0000" />
                    <attachment id="12513002" name="LUCENE-3746.patch" size="2182" author="doronc" created="Thu, 2 Feb 2012 17:12:39 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 5 Feb 2012 19:53:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>226303</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23953</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>