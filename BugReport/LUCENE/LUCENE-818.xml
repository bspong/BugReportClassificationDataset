<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:11:00 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-818/LUCENE-818.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-818] IndexWriter should detect when it&apos;s used after being closed</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-818</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Spinoff from this thread on java-user:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-user/45986&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-user/45986&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you call addDocument on IndexWriter after it&apos;s closed you&apos;ll hit a&lt;br/&gt;
hard-to-explain NullPointerException (because the RAMDirectory was&lt;br/&gt;
closed).  Before 2.1, apparently you won&apos;t hit any exception and the&lt;br/&gt;
IndexWrite will keep running but will have released it&apos;s write lock (I&lt;br/&gt;
think).&lt;/p&gt;

&lt;p&gt;I plan to fix IndexWriter methods to throw an IllegalStateException if&lt;br/&gt;
it has been closed.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12363642">LUCENE-818</key>
            <summary>IndexWriter should detect when it&apos;s used after being closed</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Mon, 26 Feb 2007 19:33:00 +0000</created>
                <updated>Tue, 19 Jun 2007 09:14:54 +0100</updated>
                    <resolved>Wed, 14 Mar 2007 18:47:09 +0000</resolved>
                            <version>2.1</version>
                                <fixVersion>2.2</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12475987" author="doronc" created="Mon, 26 Feb 2007 20:20:58 +0000"  >&lt;p&gt;I looked at Java IO as a reference for acceptable behavior in this regard. &lt;/p&gt;

&lt;p&gt;If you close a file system object and try to use it, &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;RandomAccessFile will throw IOException with: &quot;No such file or directory&quot;&lt;/li&gt;
	&lt;li&gt;FileWriter will throw IOException with &quot;Stream closed&quot;&lt;/li&gt;
	&lt;li&gt;FileOutputStream will throw IOException with &quot;Stream closed&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So you could say that Java did not go all the way with a well defined illegalState exception. &lt;br/&gt;
Databases on the other hand would give you a well definied error code.&lt;/p&gt;

&lt;p&gt;I don&apos;t have a strong opinion if this is a must for Lucene or not. &lt;/p&gt;

&lt;p&gt;But if this is to be added, one way to do it is to define a Closable interface &lt;/p&gt;
{ close(); isOpen() }
&lt;p&gt;, implement this interface in all public classes that need to check open state (IndexWriter, IndexReader, etc.), add a single static ensureOpen(Closable) method in a utils class that would throw the IllegalState exception, and just call this method from every (public?) open-state open dependent method. I think this would keep the &apos;noise&apos; in the code to minimum.&lt;/p&gt;
</comment>
                    <comment id="12476044" author="mikemccand" created="Mon, 26 Feb 2007 23:54:40 +0000"  >
&lt;p&gt;That approach seems a little overkill to me.&lt;/p&gt;

&lt;p&gt;I would need to create a new Closeable interface, and then a static&lt;br/&gt;
&quot;ensureOpen&quot; method somewhere else.  These would probably live in&lt;br/&gt;
util, so then this is all public: users see that these classes&lt;br/&gt;
implement Closeable, yet, it&apos;s not really a publicly useful feature,&lt;br/&gt;
so it adds noise to the javadocs.&lt;/p&gt;

&lt;p&gt;I was planning instead on just adding a private &quot;ensureOpen()&quot; to&lt;br/&gt;
IndexWriter (and I agree I should do IndexReader as well) that throws&lt;br/&gt;
IllegalStateException if it&apos;s closed.  I think noise is kept to the&lt;br/&gt;
same minimum &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; because all public methods that require this just have an&lt;br/&gt;
added ensureOpen() call at the top.  This is how IndexModifier works&lt;br/&gt;
today.&lt;/p&gt;

&lt;p&gt;Hmm, IndexReader already throws IOException in certain cases if it&apos;s&lt;br/&gt;
already closed.  So I think I will make a new exception&lt;br/&gt;
(AlreadyClosedException?) that subclasses IOException and throw that.&lt;/p&gt;</comment>
                    <comment id="12476240" author="gsingers" created="Tue, 27 Feb 2007 17:36:50 +0000"  >&lt;p&gt;FWIW: Some of the other Readers (actually, IndexInput) are undefined when invoking after close.  I ran into this w/ the FieldsReader when working on lazy loading.  See &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/34109?search_string=lazy%20field%20loading;#34109&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/34109?search_string=lazy%20field%20loading;#34109&lt;/a&gt;&lt;br/&gt;
for reference.&lt;/p&gt;</comment>
                    <comment id="12476360" author="mikemccand" created="Tue, 27 Feb 2007 20:19:57 +0000"  >&lt;p&gt;I see, so IndexInput indeed does not track isClosed.  It&apos;s not easy to&lt;br/&gt;
fix that since IndexInput is public and non-final?&lt;/p&gt;

&lt;p&gt;Though I&apos;m actually less concerned about this one because it&apos;s very&lt;br/&gt;
&quot;internal&quot; to Lucene.&lt;/p&gt;

&lt;p&gt;I&apos;m more concerned about the public paths (IndexWriter, IndexReader).&lt;br/&gt;
Users seem to accidentally close these classes fairly often.  I think&lt;br/&gt;
IndexSearcher is OK because on close it at worst closes the underlying&lt;br/&gt;
IndexReader, and then any call to that IndexReader will catch that&lt;br/&gt;
it&apos;s closed.&lt;/p&gt;

&lt;p&gt;Oh, I see: this public path will indeed access IndexInput after it&apos;s&lt;br/&gt;
been closed:&lt;/p&gt;

&lt;p&gt;  Open reader&lt;br/&gt;
  Get a doc w/ lazy field(s)&lt;br/&gt;
  Close reader&lt;br/&gt;
  Try to get the lazy field&apos;s value&lt;/p&gt;

&lt;p&gt;That last step will clone the cloneableFieldsStream after it had been&lt;br/&gt;
closed.  Hmmm.  Though I think we could just fix this path in&lt;br/&gt;
FieldsReader by having it record when it&apos;s closed &amp;amp; throw an&lt;br/&gt;
AlreadyClosedException if the LazyField class is used after that?&lt;br/&gt;
That seems like the simplest fix.&lt;/p&gt;</comment>
                    <comment id="12476373" author="steven_parkes" created="Tue, 27 Feb 2007 20:42:34 +0000"  >&lt;p&gt;Shades of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-686&quot; title=&quot;Resources not always reclaimed in scorers after each search&quot;&gt;&lt;del&gt;LUCENE-686&lt;/del&gt;&lt;/a&gt;. It&apos;d be nice to agree on that one, too (though it&apos;s internal, not external).&lt;/p&gt;</comment>
                    <comment id="12476386" author="mikemccand" created="Tue, 27 Feb 2007 21:04:13 +0000"  >
&lt;p&gt;I&apos;m planning on adding o.a.l.store.AlreadyClosedException.&lt;/p&gt;

&lt;p&gt;But, I&apos;m back to subclassing this from IllegalStateException (not&lt;br/&gt;
IOException).  There are a fair number of methods where we should&lt;br/&gt;
throw this exception but IOException was not already in the throws&lt;br/&gt;
clause.  Also, since it&apos;s rather rare, I think subclassing an&lt;br/&gt;
unchecked Exception is appropriate.&lt;/p&gt;

&lt;p&gt;The only counter argument is IndexReader which currently throws&lt;br/&gt;
IOException if it has been closed but then acquireWriteLock is called&lt;br/&gt;
(for one of the &quot;writer&quot; methods).  So this would technically be an&lt;br/&gt;
API change for this particular case in IndexReader.  But I think it&apos;s&lt;br/&gt;
a tiny API change especially because it does not affect user&apos;s code&lt;br/&gt;
since they already must catch the existing IOException (vs the other&lt;br/&gt;
methods where adding checked &quot;throws IOException&quot; would be a major API&lt;br/&gt;
change).&lt;/p&gt;</comment>
                    <comment id="12477395" author="mikemccand" created="Fri, 2 Mar 2007 18:18:11 +0000"  >&lt;p&gt;Attached patch.&lt;/p&gt;

&lt;p&gt;I added checks to all public methods in IndexReader (and its&lt;br/&gt;
subclasses in Lucene&apos;s sources: SegmentReader, MultiReader,&lt;br/&gt;
FilteredIndexReader, ParallelReader), IndexWriter and FieldsReader&lt;br/&gt;
that throw AlreadyClosedException if they are used after being closed.&lt;/p&gt;

&lt;p&gt;I then hit a few tests that were incorrectly closing&lt;br/&gt;
reader/searcher/writer and then continuing to use them (or double&lt;br/&gt;
closing them), so I fixed those.&lt;/p&gt;</comment>
                    <comment id="12477398" author="doronc" created="Fri, 2 Mar 2007 18:30:27 +0000"  >&lt;p&gt;Throwing that exception for close() seems a bit too restrictive...&lt;br/&gt;
Perhaps for close() of an already closed object just do nothing?&lt;br/&gt;
This would be more forgiving/friendly to &quot;over protecting&quot; (possibly existing) applications.&lt;/p&gt;
</comment>
                    <comment id="12477399" author="cutting" created="Fri, 2 Mar 2007 18:35:50 +0000"  >&lt;p&gt;&amp;gt; Perhaps for close() of an already closed object just do nothing? &lt;/p&gt;

&lt;p&gt;+1 Double-closing is sometimes hard to avoid.  I&apos;d rather have it ignored than force folks to, e.g., write more complicated exception handlers.&lt;/p&gt;</comment>
                    <comment id="12477406" author="mikemccand" created="Fri, 2 Mar 2007 18:51:50 +0000"  >&lt;p&gt;Excellent point.  OK I fixed the patch to silently ignore close() when&lt;br/&gt;
the IndexReader, IndexWriter, FieldsReader was already closed.&lt;/p&gt;</comment>
                    <comment id="12477412" author="yseeley@gmail.com" created="Fri, 2 Mar 2007 19:15:59 +0000"  >&lt;p&gt;I think that accessing a closed reader should continue to be undefined.&lt;br/&gt;
If we define it to throw an exception, then we have thread safety issues which would be too costly (IMO) to fix.&lt;/p&gt;

&lt;p&gt;If we are to add checks for a closed reader, it seems like they should only be put on methods where an additional method call would be negligible.  Hand-holding that decreases performance for everyone isn&apos;t something I like.  Sun often goes too far in this regard, and as a consequence, people end up rewriting their own version of classes to get better performance.&lt;/p&gt;

&lt;p&gt;After all, this is really just making nicer error messages for incorrect programs, right?  Everyone shouldn&apos;t have to pay for that.  I guess I&apos;m a minimalist &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12477442" author="mikemccand" created="Fri, 2 Mar 2007 20:53:10 +0000"  >&lt;p&gt;Yes, this is about giving a clear (and prompt) error message when&lt;br/&gt;
Lucene is used incorrectly.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-140&quot; title=&quot;docs out of order&quot;&gt;&lt;del&gt;LUCENE-140&lt;/del&gt;&lt;/a&gt; was also a similar situation.  In that case incorrect usage&lt;br/&gt;
could lead to index corruption much later.&lt;/p&gt;

&lt;p&gt;I feel like that is important because it affects the perceived quality&lt;br/&gt;
of Lucene.  Enough users seem to hit this (especially common seems to&lt;br/&gt;
be iterating through Hits after the reader is closed).  As Lucene&lt;br/&gt;
adoption grows, more users will hit it.&lt;/p&gt;

&lt;p&gt;Because detection of this now is so &quot;intermittant&quot; (undefined), a&lt;br/&gt;
developer could think everything is OK in testing, push things into&lt;br/&gt;
their production world, only to suddenly see an error.  Then, the&lt;br/&gt;
error is something strange (eg confusing NullPointerException) which&lt;br/&gt;
doesn&apos;t make it clear what&apos;s happened.&lt;/p&gt;

&lt;p&gt;In the IndexWriter case it&apos;s potentially devastating because (I&lt;br/&gt;
think?) if you keep using your closed IndexWriter, then, it&apos;s&lt;br/&gt;
operating on the index without holding the write lock (this was pre&lt;br/&gt;
2.1).&lt;/p&gt;

&lt;p&gt;I do agree we shouldn&apos;t go overboard with this (eg I certainly think&lt;br/&gt;
we should not add checks inside things like TermDocs/TermPositions).&lt;/p&gt;

&lt;p&gt;And I agree this is in general a difficult tradeoff.&lt;/p&gt;

&lt;p&gt;But I think in this case the performance impact is likely very small; I could&lt;br/&gt;
work out a test to be sure.&lt;/p&gt;

&lt;p&gt;Maybe we could remove checking for clearly frequently called methods&lt;br/&gt;
(eg isDeleted)?&lt;/p&gt;</comment>
                    <comment id="12477457" author="yseeley@gmail.com" created="Fri, 2 Mar 2007 21:35:22 +0000"  >
&lt;p&gt;&amp;gt; Then, the error is something strange (eg confusing NullPointerException) which doesn&apos;t make it clear what&apos;s happened. &lt;/p&gt;

&lt;p&gt;I think that depends on context.  Many cases of NPEs are perfectly clear when you look at the stack trace.&lt;/p&gt;

&lt;p&gt;&amp;gt; In the IndexWriter case it&apos;s potentially devastating&lt;/p&gt;

&lt;p&gt;Agreed... when it affects correctness, we should fix.&lt;/p&gt;

&lt;p&gt;Adding ensureOpen() to something like maxDoc() does not ensure correctness though - an exception may or may not be thrown in the reader is already closed (because of those thread-safety issues).  It actually increases the variability of behavior.  We need to be careful not to guarantee the throwing of the exception.&lt;/p&gt;

&lt;p&gt;&amp;gt; especially common seems to be iterating through Hits after the reader is closed&lt;/p&gt;

&lt;p&gt;Good point, for document() esp.  I&apos;m OK with the heavyweight methods.&lt;/p&gt;

&lt;p&gt;&amp;gt; Maybe we could remove checking for clearly frequently called methods (eg isDeleted)?&lt;/p&gt;

&lt;p&gt;That&apos;s one of the ones I had in mind... isDeleted() can be called millions of times for a single query.  Probably numDoc(), maxDoc(), etc, are also candidates.&lt;/p&gt;

&lt;p&gt;Earlier detection of bugs when the cost is nil is good though...&lt;br/&gt;
what about setting more things to null when a reader is closed?&lt;/p&gt;</comment>
                    <comment id="12477604" author="mikemccand" created="Sat, 3 Mar 2007 10:31:06 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; Then, the error is something strange (eg confusing NullPointerException) which doesn&apos;t make it clear what&apos;s happened.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I think that depends on context.  Many cases of NPEs are perfectly clear when you look at the stack trace.&lt;/p&gt;

&lt;p&gt;Well for people familiar with Lucene&apos;s sources, yes.  But most of our&lt;br/&gt;
users are not and so seeing an &quot;AlreadyClosedException&quot; can make a big&lt;br/&gt;
difference over &lt;span class=&quot;error&quot;&gt;&amp;#91;possibly rather nested, and, rather delayed&amp;#93;&lt;/span&gt; NPE or&lt;br/&gt;
something else.&lt;/p&gt;

&lt;p&gt;EG look at the poor user that led to my opening this issue (link in&lt;br/&gt;
opening comment).  The user was understandably confused by the NPE&lt;br/&gt;
inside the RAMDirectory.&lt;/p&gt;

&lt;p&gt;&amp;gt; Adding ensureOpen() to something like maxDoc() does not ensure&lt;br/&gt;
&amp;gt; correctness though - an exception may or may not be thrown in the&lt;br/&gt;
&amp;gt; reader is already closed (because of those thread-safety issues). It&lt;br/&gt;
&amp;gt; actually increases the variability of behavior. We need to be&lt;br/&gt;
&amp;gt; careful not to guarantee the throwing of the exception.&lt;/p&gt;

&lt;p&gt;On the thread safety issue: are you saying if one thread closes the&lt;br/&gt;
reader while another thread is using it, there is uncertainty excactly&lt;br/&gt;
when the 2nd thread will hit the AlreadyClosedException (because of&lt;br/&gt;
how the JVM schedules the threads)?  I think this kind of thread&lt;br/&gt;
behavior is normal/expected?&lt;/p&gt;

&lt;p&gt;Or is the thread safety issue something else?&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; especially common seems to be iterating through Hits after the reader is closed&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Good point, for document() esp. I&apos;m OK with the heavyweight methods.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&amp;gt; Maybe we could remove checking for clearly frequently called methods (eg isDeleted)?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; That&apos;s one of the ones I had in mind... isDeleted() can be called millions of times for a single query. Probably numDoc(), maxDoc(), etc, are also candidates.&lt;/p&gt;

&lt;p&gt;OK how about we do not call ensureOpen() in these IndexReader methods?:&lt;/p&gt;

&lt;p&gt;  numDoc()&lt;br/&gt;
  maxDoc()&lt;br/&gt;
  isDeleted()&lt;/p&gt;

&lt;p&gt;I think even without checking in those methods we still catch a number&lt;br/&gt;
of common cases:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Close reader then try to run a search (termDocs()/termPositions()&lt;br/&gt;
    catch the close)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Run a search, close reader, then try to iterate through Hits&lt;br/&gt;
    (document() catches the close)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Close a reader then try to delete docs or setNorms&lt;br/&gt;
    (deleteDocument()/setNorm() catch the close)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; Earlier detection of bugs when the cost is nil is good though...&lt;/p&gt;

&lt;p&gt;Yes I think we in general want &quot;fail-fast&quot; here.&lt;/p&gt;

&lt;p&gt;&amp;gt; what about setting more things to null when a reader is closed?&lt;/p&gt;

&lt;p&gt;Well ... I would prefer not to increase the frequency of getting&lt;br/&gt;
&quot;undefined&quot; NPEs out of the reader.  If we are going to cause&lt;br/&gt;
additional exceptions here, I&apos;d like to make them intelligible to the&lt;br/&gt;
user (ie, AlreadyClosedException).  EG, take SegmentReader&apos;s &quot;si&quot;&lt;br/&gt;
(SegmentInfo).  If we set this to null on close, then numDoc() and&lt;br/&gt;
maxDoc() would hit NPE instead of just returning the correct answer.&lt;br/&gt;
I think I&apos;d prefer returning the correct answer for such cases.&lt;/p&gt;</comment>
                    <comment id="12477670" author="yseeley@gmail.com" created="Sat, 3 Mar 2007 19:50:02 +0000"  >&lt;p&gt;&amp;gt; On the thread safety issue: are you saying if one thread closes the&lt;br/&gt;
&amp;gt; reader while another thread is using it, there is uncertainty excactly&lt;br/&gt;
&amp;gt; when the 2nd thread will hit the AlreadyClosedException (because of&lt;br/&gt;
&amp;gt; how the JVM schedules the threads)?&lt;/p&gt;

&lt;p&gt;Yes, but it&apos;s not just thread scheduling, it&apos;s also lack of memory barriers.  The 2nd thread may &lt;b&gt;never&lt;/b&gt; see the close(), depending on the exact architecture of machine and the JVM.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think this kind of thread behavior is normal/expected? &lt;/p&gt;

&lt;p&gt;For a class that isn&apos;t thread safe, yes.  IndexReader is advertised as being thread safe though.  If we guarantee an exception accessing a closed reader, then that should work 100% of the time. I don&apos;t think we should make that guarantee. &lt;/p&gt;

&lt;p&gt;We can still throw meaningful errors in more cases and make it easier for the user to debug that, but it should not be deemed an error if we don&apos;t throw an exception.  Users should never rely on getting this exception for flow-control purposes anyway.&lt;/p&gt;

&lt;p&gt;&amp;gt; OK how about we do not call ensureOpen() in these IndexReader methods?:&lt;br/&gt;
&amp;gt;  numDoc()&lt;br/&gt;
&amp;gt;  maxDoc()&lt;br/&gt;
&amp;gt;  isDeleted() &lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;hasDeletions() too?&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; what about setting more things to null when a reader is closed?&lt;br/&gt;
&amp;gt; Well ... I would prefer not to increase the frequency of getting &quot;undefined&quot; NPEs out of the reader&lt;/p&gt;

&lt;p&gt;Yes, but not all bugs will be user bugs.  Some will be internal Lucene stuff that bypass public methods.&lt;br/&gt;
It&apos;s still better that these fail quicker too.  Anyway, that can be handled on a case-by-case basis later.&lt;/p&gt;
</comment>
                    <comment id="12477713" author="mikemccand" created="Sat, 3 Mar 2007 23:57:00 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; On the thread safety issue: are you saying if one thread closes the&lt;br/&gt;
&amp;gt;&amp;gt; reader while another thread is using it, there is uncertainty excactly&lt;br/&gt;
&amp;gt;&amp;gt; when the 2nd thread will hit the AlreadyClosedException (because of&lt;br/&gt;
&amp;gt;&amp;gt; how the JVM schedules the threads)?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Yes, but it&apos;s not just thread scheduling, it&apos;s also lack of memory&lt;br/&gt;
&amp;gt; barriers. The 2nd thread may &lt;b&gt;never&lt;/b&gt; see the close(), depending on&lt;br/&gt;
&amp;gt; the exact architecture of machine and the JVM.&lt;/p&gt;

&lt;p&gt;Yikes.  Is this the Java memory model issue?  Ie, there is no hard&lt;br/&gt;
guarantee on when a &quot;write&quot; from one thread will be visible to other&lt;br/&gt;
threads, unless you use &quot;volatile&quot;?&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; I think this kind of thread behavior is normal/expected?&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; For a class that isn&apos;t thread safe, yes. IndexReader is advertised&lt;br/&gt;
&amp;gt; as being thread safe though. If we guarantee an exception accessing&lt;br/&gt;
&amp;gt; a closed reader, then that should work 100% of the time. I don&apos;t&lt;br/&gt;
&amp;gt; think we should make that guarantee.&lt;/p&gt;

&lt;p&gt;OK I think we shouldn&apos;t &quot;guarantee&quot; it.  I think listing as &quot;@throws&lt;br/&gt;
AlreadyClosedException if this IndexReader is closed&quot; is OK?&lt;/p&gt;

&lt;p&gt;&amp;gt; We can still throw meaningful errors in more cases and make it&lt;br/&gt;
&amp;gt; easier for the user to debug that, but it should not be deemed an&lt;br/&gt;
&amp;gt; error if we don&apos;t throw an exception. Users should never rely on&lt;br/&gt;
&amp;gt; getting this exception for flow-control purposes anyway.&lt;/p&gt;

&lt;p&gt;Agreed.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; OK how about we do not call ensureOpen() in these IndexReader methods?:&lt;br/&gt;
&amp;gt;&amp;gt; numDoc()&lt;br/&gt;
&amp;gt;&amp;gt; maxDoc()&lt;br/&gt;
&amp;gt;&amp;gt; isDeleted()&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; +1&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; hasDeletions() too?&lt;/p&gt;

&lt;p&gt;OK I will change to not call ensureOpen() for hasDeletions too.  I&lt;br/&gt;
will roll a new patch with this.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; &amp;gt; what about setting more things to null when a reader is closed?&lt;br/&gt;
&amp;gt;&amp;gt; Well ... I would prefer not to increase the frequency of getting &quot;undefined&quot; NPEs out of the reader&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Yes, but not all bugs will be user bugs. Some will be internal&lt;br/&gt;
&amp;gt; Lucene stuff that bypass public methods.  It&apos;s still better that&lt;br/&gt;
&amp;gt; these fail quicker too. Anyway, that can be handled on a&lt;br/&gt;
&amp;gt; case-by-case basis later.&lt;/p&gt;

&lt;p&gt;OK, I agree.  Better to throw a &quot;fail-fast&quot; NPE than do something&lt;br/&gt;
strange later.&lt;/p&gt;</comment>
                    <comment id="12477716" author="djd" created="Sun, 4 Mar 2007 00:46:06 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; Yes, but it&apos;s not just thread scheduling, it&apos;s also lack of memory&lt;br/&gt;
&amp;gt;&amp;gt; barriers. The 2nd thread may &lt;b&gt;never&lt;/b&gt; see the close(), depending on&lt;br/&gt;
&amp;gt;&amp;gt; the exact architecture of machine and the JVM.&lt;/p&gt;

&lt;p&gt;&amp;gt;Yikes. Is this the Java memory model issue? Ie, there is no hard&lt;br/&gt;
&amp;gt;guarantee on when a &quot;write&quot; from one thread will be visible to other&lt;br/&gt;
&amp;gt;threads, unless you use &quot;volatile&quot;? &lt;/p&gt;

&lt;p&gt;Doesn&apos;t crossing a synchronization barrier ensure that all threads will seem the same value of a field?&lt;/p&gt;</comment>
                    <comment id="12477723" author="yseeley@gmail.com" created="Sun, 4 Mar 2007 01:35:23 +0000"  >&lt;p&gt;&amp;gt; Doesn&apos;t crossing a synchronization barrier ensure that all threads will seem the same value of a field?&lt;/p&gt;

&lt;p&gt;Yes, if the changing thread crosses a write barrier and the reading  thread crosses a read barrier.&lt;/p&gt;

&lt;p&gt;The obvious implication that you need to synchronize the sets/gets of isClosed.  That&apos;s not a big deal in some cases, but in anything that could be in an inner loop, it is a big deal.  We already have reports of simple things like isDeleted() being a bottleneck on servers with many CPUs and concurrent threads because of the synchronization.  That particular sync point is something that I&apos;ve planned to get rid of at some point in the future by having a &quot;read only&quot; IndexReader.&lt;/p&gt;</comment>
                    <comment id="12477724" author="yseeley@gmail.com" created="Sun, 4 Mar 2007 01:43:39 +0000"  >&lt;p&gt;&amp;gt; Yikes. Is this the Java memory model issue?&lt;/p&gt;

&lt;p&gt;Yes, but it&apos;s not a problem with the Java memory model, it&apos;s more of a feature.  Threads in general have this problem (or perform very poorly if they don&apos;t).  It&apos;s also very much about compiler optimizations as well.  The optimizer may stuff a value in a register, and never check it&apos;s location in main-memory, and never see the changes.  Even if it doesn&apos;t then you drop down to problems with the CPU and cache + memory architectue in SMP systems.  Some systems require explicit memory barriers or cache flushes to see memory changes from another CPU.  One CPU writes to a spot in memory, and absent any special instructions, another CPU reading from that spot in memory may not see the change.&lt;/p&gt;</comment>
                    <comment id="12477767" author="mikemccand" created="Sun, 4 Mar 2007 09:44:05 +0000"  >&lt;p&gt;Attached take3, which just removes ensureOpen() checks for IndexReader&apos;s maxDoc(), numDoc(), hasDeletions(), isDeleted(...).&lt;/p&gt;</comment>
                    <comment id="12477875" author="hossman" created="Sun, 4 Mar 2007 23:15:29 +0000"  >&lt;p&gt;I havne&apos;t been following this issue that closely, and i haven&apos;t read any of the patches, but if the goal is:&lt;/p&gt;

&lt;p&gt;  &quot;reduce situations where novice users get confusing exceptions when using IndexWriter after closing it&quot;&lt;/p&gt;

&lt;p&gt;...and the concern is that calling a new &quot;ensureOpen()&quot; method at the begining of every public method may be a performacne issue, then perhaps an alternative would be to catch all exceptions inside public methods and wrap them if not closed, ie...&lt;/p&gt;

&lt;p&gt;   public Foo somePublicMethod() throws IOException {&lt;br/&gt;
       try &lt;/p&gt;
{
          // current method body
       }
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
          if (isOpen()) &lt;/p&gt;
{
             throw e;
          }
&lt;p&gt; else &lt;/p&gt;
{
             throw new AllreadyClosedException(e);
          }
&lt;p&gt;       }&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;...that way any performance cost of ensureOpen/isOpen is only payed on an existing Exception.  the down side i see to this approach is that since it only explains exceptions hte caller would get anyway, it doesn&apos;t give any feedback about using a closed writer in cases where the current code returns cleanly (but may not function properly) ... we might be able to solve that by adding better error checking in those specific cases (if we know of any) and throwing explicit exceptions.&lt;/p&gt;</comment>
                    <comment id="12477957" author="mikemccand" created="Mon, 5 Mar 2007 09:44:01 +0000"  >&lt;p&gt;To make that work, I think we&apos;d have to convert the Exception into&lt;br/&gt;
either IOException or RuntimeException before throwing it (so we don&apos;t&lt;br/&gt;
have to change method signature).&lt;/p&gt;

&lt;p&gt;But, I think this approach adds more noise to the source code.  Also&lt;br/&gt;
because it&apos;s &quot;after the fact&quot; then damage could have been done (I&lt;br/&gt;
&lt;b&gt;think&lt;/b&gt; IndexWriter before 2.1 would gleefully keep writing, but&lt;br/&gt;
without holding the write lock!).  It would only catch cases where an&lt;br/&gt;
exception was thrown (many times there is none) whereas I prefer &quot;fail&lt;br/&gt;
fast&quot;.&lt;/p&gt;</comment>
                    <comment id="12478166" author="hossman" created="Mon, 5 Mar 2007 21:32:40 +0000"  >&lt;p&gt;1) my example attempted to be concise ... ideally we would be explicit in our catches.&lt;/p&gt;

&lt;p&gt;2) the body of the catch clauses could be put into a helper method just like ensureOpen to help reduce code noise&lt;/p&gt;

&lt;p&gt;3) if there are situations where damage will be done by not testing that we are open before taking some action, that would fall under my &quot;adding better error checking in those specific cases (if we know of any) and throwing explicit exceptions.&quot; ... a lot of this could be achieved (as Yonik suggested) by nulling out more things in close so that the first attempt to do something dangerous after the close triggered a NullPointerException.&lt;/p&gt;

&lt;p&gt;4) &quot;fail fast&quot; is always good ... except when it makes the non-failure case slow ... i was merely suggesting an alternative that would achieve the same results without penalizing performance of people obeying the rules.&lt;/p&gt;

&lt;p&gt;as an added bonus, both methodologies could be used... &lt;/p&gt;

&lt;p&gt;if numDoc(), maxDoc(), isDeleted(), and hasDeletions() are the only mehtods were people are concerned about the performance impacts of calling ensureOpen() everytime, then those methods could be the ones where isOpen could be checked in any exception handling block, and all of the other mehtods could use ensureOpen as orriginal described.&lt;/p&gt;</comment>
                    <comment id="12478327" author="mikemccand" created="Tue, 6 Mar 2007 09:47:49 +0000"  >
&lt;p&gt;&amp;gt; 2) the body of the catch clauses could be put into a helper method just like ensureOpen to help reduce code noise&lt;/p&gt;

&lt;p&gt;True, but I think it&apos;s still more code noise to have&lt;br/&gt;
try/catch/call-helper-method than ensureOpen() call?  Esp. since you&apos;d&lt;br/&gt;
have to handle IOException and RuntimeException as 2 separate catch&lt;br/&gt;
clauses (I think?), each of which calls a separate helper.  Ie instead&lt;br/&gt;
of:&lt;/p&gt;

&lt;p&gt;  ensureOpen();&lt;br/&gt;
  ...do stuff...&lt;/p&gt;

&lt;p&gt;we would need something like:&lt;/p&gt;

&lt;p&gt;  try &lt;/p&gt;
{
    ...do stuff...
  }
&lt;p&gt; catch (IOException exc) &lt;/p&gt;
{
    throw ensureOpenAfterIOException(exc);
  }
&lt;p&gt; catch (RuntimeException exc) &lt;/p&gt;
{
    throw ensureOpenAfterRuntimeException(exc);
  }

&lt;p&gt;I think?&lt;/p&gt;

&lt;p&gt;&amp;gt; 3) if there are situations where damage will be done by not testing that we are open before taking some action, that would fall under my &quot;adding better error checking in those specific cases (if we know of any) and throwing explicit exceptions.&quot; ... a lot of this could be achieved (as Yonik suggested) by nulling out more things in close so that the first attempt to do something dangerous after the close triggered a NullPointerException.&lt;/p&gt;

&lt;p&gt;The thing is we may not know all such cases (yet)?  I prefer taking a&lt;br/&gt;
defensive approach here.  I don&apos;t really like the null-out solution&lt;br/&gt;
because I think getting an AlreadyClosedException is clearer to the&lt;br/&gt;
user than a NPE&apos;s.&lt;/p&gt;

&lt;p&gt;&amp;gt; 4) &quot;fail fast&quot; is always good ... except when it makes the non-failure case slow ... i was merely suggesting an alternative that would achieve the same results without penalizing performance of people obeying the rules.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; if numDoc(), maxDoc(), isDeleted(), and hasDeletions() are the only mehtods were people are concerned about the performance impacts of calling ensureOpen() everytime, then those methods could be the ones where isOpen could be checked in any exception handling block, and all of the other mehtods could use ensureOpen as orriginal described.&lt;/p&gt;

&lt;p&gt;Good idea!  An added bonus is that these methods do not throw&lt;br/&gt;
IOException so the exception handling would just have the one&lt;br/&gt;
RuntimeException catch clause above.  OK I will rework patch with this&lt;br/&gt;
approach and see how it looks...&lt;/p&gt;</comment>
                    <comment id="12478544" author="hossman" created="Tue, 6 Mar 2007 19:55:29 +0000"  >&lt;p&gt;i would make sure to &lt;b&gt;heavily&lt;/b&gt; document each and every use of isOpen/ensureOpen to make it clear why they are being used when they are from a performance concern case ... otherwise people will be very confused down the road (&quot;why the hell isn&apos;t this being checked until the catch block?!?!?!&quot;)&lt;/p&gt;</comment>
                    <comment id="12478585" author="mikemccand" created="Tue, 6 Mar 2007 21:20:51 +0000"  >
&lt;p&gt;&amp;gt; i would make sure to &lt;b&gt;heavily&lt;/b&gt; document each and every use of isOpen/ensureOpen to make it clear why they are being used when they are from a performance concern case ... otherwise people will be very confused down the road (&quot;why the hell isn&apos;t this being checked until the catch block?!?!?!&quot;)&lt;/p&gt;

&lt;p&gt;OK I changed my mind.&lt;/p&gt;

&lt;p&gt;I don&apos;t think we should add the &quot;check if closed after the fact&quot;&lt;br/&gt;
logic.  I reviewed the 4 methods in question (maxDoc, numDocs,&lt;br/&gt;
hasDeletions, isDeleted) and for all subclasses of IndexReader these&lt;br/&gt;
are very trivial methods that won&apos;t throw exceptions.&lt;/p&gt;

&lt;p&gt;So I&apos;m back to thinking this added complexity (and future confusion to&lt;br/&gt;
people looking @ Lucene source code) isn&apos;t worthwhile and we should&lt;br/&gt;
leave these methods with no checking for whether they are already&lt;br/&gt;
closed.&lt;/p&gt;

&lt;p&gt;But I will document why ensureOpen is &lt;b&gt;not&lt;/b&gt; being called in each of&lt;br/&gt;
these methods.&lt;/p&gt;</comment>
                    <comment id="12478718" author="mikemccand" created="Wed, 7 Mar 2007 09:08:18 +0000"  >&lt;p&gt;New patch based on above discussion: just re-based to the current trunk, and, added comments on why ensureOpen is not called in the 4 methods.&lt;/p&gt;</comment>
                    <comment id="12479179" author="yseeley@gmail.com" created="Thu, 8 Mar 2007 00:42:54 +0000"  >&lt;p&gt;If we aren&apos;t guaranteeing an exception be thrown after a close, why are we bothering to put the exception in the method signature?&lt;/p&gt;

&lt;p&gt;It&apos;s already apparent to everyone that using something after it&apos;s closed isn&apos;t good, so we were just cleaning up the  error messages and making it easier to debug.  People shouldn&apos;t have specific application logic for this exception... it should be treated as a program error.&lt;/p&gt;

&lt;p&gt;IMO, listing the exception encourages people to catch it, suggests that they can depend on the exception being thrown, and also makes it more difficult to remove it from certain methods in the future.&lt;/p&gt;</comment>
                    <comment id="12479207" author="doronc" created="Thu, 8 Mar 2007 03:25:19 +0000"  >&lt;p&gt;&amp;gt; People shouldn&apos;t have specific application logic for this exception... it should be treated as a program error. &lt;br/&gt;
+1 &lt;/p&gt;

&lt;p&gt;Also, another candidate for AlreadyClosedException upon using an already closed (RAM)Directory - came up in &lt;a href=&quot;http://www.nabble.com/sharing-my-experience-for-upgrading-from-Lucene-1.9-to-Lucene-2.2-dev-tf3366948.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/sharing-my-experience-for-upgrading-from-Lucene-1.9-to-Lucene-2.2-dev-tf3366948.html&lt;/a&gt; &lt;/p&gt;
</comment>
                    <comment id="12479273" author="mikemccand" created="Thu, 8 Mar 2007 09:27:03 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; People shouldn&apos;t have specific application logic for this exception... it should be treated as a program error.&lt;br/&gt;
&amp;gt; +1&lt;/p&gt;

&lt;p&gt;OK, agreed.  I will remove AlreadyClosedException from all @throws&lt;br/&gt;
method signatures.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, another candidate for AlreadyClosedException upon using an already closed (RAM)Directory - came up in &lt;a href=&quot;http://www.nabble.com/sharing-my-experience-for-upgrading-from-Lucene-1.9-to-Lucene-2.2-dev-tf3366948.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/sharing-my-experience-for-upgrading-from-Lucene-1.9-to-Lucene-2.2-dev-tf3366948.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Yeah I saw this too.  Here&apos;s the relevant excerpt:&lt;/p&gt;

&lt;p&gt;&amp;gt; 3. RAMDirectory related changes&lt;br/&gt;
&amp;gt;   It took me something to find this out. Previously, after&lt;br/&gt;
&amp;gt;     ramDirectory = new RAMDirectory(file)&lt;br/&gt;
&amp;gt;   I could ramDirectory.close() to release the resources. And later, I&lt;br/&gt;
&amp;gt; could do a check for IndexReader.indexExists(ramDirectory) to see if&lt;br/&gt;
&amp;gt; there is an index in the directory. FSDirectory behaves this way also.&lt;br/&gt;
&amp;gt;   But with lucene 2.2, NullPointerExceptions came out. It turns out&lt;br/&gt;
&amp;gt; when ramDirectory.close(), the instance variable fileMap is set to&lt;br/&gt;
&amp;gt; null. And IndexReader.indexExists(ramDirectory) is reading fileMap to&lt;br/&gt;
&amp;gt; look for indexes, causing the NPE.&lt;/p&gt;

&lt;p&gt;In fact the original user&apos;s list email that started this bug was also&lt;br/&gt;
due to RAMDirectory setting its fileMap to null, but in that case, it&lt;br/&gt;
was via IndexWriter so detecting that IndexWriter is closed would&lt;br/&gt;
prevent that one.&lt;/p&gt;

&lt;p&gt;In this case the developer is using a RAMDirectory directly.&lt;/p&gt;

&lt;p&gt;I think this is an example where &quot;nulling things out on close&quot; leads&lt;br/&gt;
to developer confusion.  Previously RAMDirectory functioned fine after&lt;br/&gt;
being closed(); now, it throws a hard to understand (unless you are&lt;br/&gt;
familiar w/ Lucene&apos;s sources &amp;amp; what specifically we changed in 2.1)&lt;br/&gt;
NPE.&lt;/p&gt;

&lt;p&gt;I think we should fix this?&lt;/p&gt;

&lt;p&gt;Since RAMDir&apos;s public methods are fairly hot (eg heavily used building&lt;br/&gt;
single-doc RAM segment), we can use Hoss&apos;s neat approach and&lt;br/&gt;
specifically catch the NPE and rethrow as an AlreadyClosedException?&lt;/p&gt;

&lt;p&gt;I don&apos;t mind if the &quot;after close semantics&quot; is &quot;it works just like it&lt;br/&gt;
did when it was open&quot; (ie, close is a no-op).  I also don&apos;t mind if&lt;br/&gt;
you get a &quot;fail-fast&quot; quick AlreadyClosedException.  But I think&lt;br/&gt;
anything in between (NPE or other undefined, intermittant exceptions)&lt;br/&gt;
only confuses our developers.&lt;/p&gt;

&lt;p&gt;Looking at FSDirectory, it continues to work fine after close with the&lt;br/&gt;
one spooky exception that it may have been removed from the&lt;br/&gt;
DIRECTORIES hashtable, which means if you then open the same canonical&lt;br/&gt;
path again you get a different FSDirectory instance.  The comment&lt;br/&gt;
states &quot;this permits synchronization on directories&quot;, but I don&apos;t see&lt;br/&gt;
where in Lucene we are relying on this?  Ie, what could break if a&lt;br/&gt;
user keeps using a closed FSDirectory thus possibly having more than&lt;br/&gt;
one FSDirectory instance for a given canonical path?&lt;/p&gt;</comment>
                    <comment id="12479357" author="yseeley@gmail.com" created="Thu, 8 Mar 2007 16:56:38 +0000"  >&lt;p&gt;&amp;gt; we can use Hoss&apos;s neat approach and&lt;br/&gt;
&amp;gt; specifically catch the NPE and rethrow as an AlreadyClosedException? &lt;/p&gt;

&lt;p&gt;I&apos;m not enough of an expert to know if this would be faster or slower than a simple fileMap==null check.&lt;br/&gt;
I would guess it depends on what needs to be set up in the stack frame to potentially catch an exception, and if the try/catch/throw code prevents any optimizations (such as inlining).&lt;/p&gt;

&lt;p&gt;Also, catching a NPE seems a little icky to me... so w/o more info I&apos;d lean toward a fileMap==null check (if anything).&lt;/p&gt;
</comment>
                    <comment id="12479373" author="mikemccand" created="Thu, 8 Mar 2007 18:06:52 +0000"  >&lt;p&gt;&amp;gt; I&apos;m not enough of an expert to know if this would be faster or slower than a simple fileMap==null check.&lt;br/&gt;
&amp;gt; I would guess it depends on what needs to be set up in the stack frame to potentially catch an exception, and if the try/catch/throw code prevents any optimizations (such as inlining).&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Also, catching a NPE seems a little icky to me... so w/o more info I&apos;d lean toward a fileMap==null check (if anything).&lt;/p&gt;

&lt;p&gt;OK, good points.  It is not in fact clear that a try/catch solution is&lt;br/&gt;
less costly, so, let&apos;s keep it simple.  I will just add ensureOpen().&lt;/p&gt;</comment>
                    <comment id="12480158" author="mikemccand" created="Mon, 12 Mar 2007 17:52:07 +0000"  >&lt;p&gt;Attached patch: removed AlreadyClosedException from throws clauses &amp;amp; javadocs; added ensureOpen calls inside RAMDirectory as well.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12352470" name="LUCENE-818.patch" size="71314" author="mikemccand" created="Fri, 2 Mar 2007 18:18:11 +0000" />
                    <attachment id="12352473" name="LUCENE-818.take2.patch" size="71761" author="mikemccand" created="Fri, 2 Mar 2007 18:51:49 +0000" />
                    <attachment id="12352540" name="LUCENE-818.take3.patch" size="68598" author="mikemccand" created="Sun, 4 Mar 2007 09:44:05 +0000" />
                    <attachment id="12352817" name="LUCENE-818.take4.patch" size="69649" author="mikemccand" created="Wed, 7 Mar 2007 09:08:18 +0000" />
                    <attachment id="12353128" name="LUCENE-818.take5.patch" size="50064" author="mikemccand" created="Mon, 12 Mar 2007 17:52:06 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 26 Feb 2007 20:20:58 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12922</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26912</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>