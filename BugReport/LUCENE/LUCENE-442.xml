<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:14:49 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-442/LUCENE-442.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-442] TestIndexModifier.testIndexWithThreads is not valid?</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-442</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I recently started playing with the trunk of SVN, and noticed that intermitently, TestIndexModifier.testIndexWithThreads (revision 292010) would fail.&lt;/p&gt;

&lt;p&gt;The basic premise of the test seems to be that 3 pairs of IndexThread instances can be started in parallel, each pair using the same instance of IndexModifier to concurrently and randomly add/delete/optimize a single FSDirectory index.  &lt;br/&gt;
The test is considered a success if the sum of additions-deletions recorded by each pair of threads equals the final docCount() for the IndexModifier instance used by that pair of threads.&lt;/p&gt;

&lt;p&gt;Now I freely admit that I&apos;m not 100% familiar with the code for IndexModifier, but at a glance, the basic premise seems to be: &lt;br/&gt;
   a) If method for IndexWriter is called, open it if needed, close the IndexReader first if needed.&lt;br/&gt;
   b) if method for IndexReader is called, open it if needed, close the IndexWriter first if needed.&lt;/p&gt;

&lt;p&gt;If I&apos;m understnading that correctly, I see no reason to assume this test will pass.  &lt;br/&gt;
It seems like there could be plenty of scenerios in which the number of additions-deletions != docCount(). The most trivial example I can think of is:&lt;br/&gt;
   1) the first IndexThread instance which has a chance to run adds a document, and optimizes before any other IndexThreads ever open the Directory.&lt;br/&gt;
   2) a subsequent pair of IndexThread instances open their IndexModifier instance before any documents are deleted.&lt;br/&gt;
   3) the IndexThread instances from #2 do nothing but add documents&lt;br/&gt;
...that pair of IndexThreads is now garunteed to have recorded a differnet number of additions then the docCount returned by their IndexModifier.&lt;/p&gt;

&lt;p&gt;Am I missing something, or should this test be removed?&lt;/p&gt;
</description>
                <environment></environment>
            <key id="12317359">LUCENE-442</key>
            <summary>TestIndexModifier.testIndexWithThreads is not valid?</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="hossman">Hoss Man</reporter>
                        <labels>
                    </labels>
                <created>Wed, 28 Sep 2005 11:52:03 +0100</created>
                <updated>Thu, 27 Oct 2005 03:21:09 +0100</updated>
                    <resolved>Thu, 27 Oct 2005 03:21:09 +0100</resolved>
                            <version>1.9</version>
                                <fixVersion>1.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>2</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12344241" author="lucenebugs@danielnaber.de" created="Mon, 24 Oct 2005 08:10:44 +0100"  >&lt;p&gt;Hoss,&lt;/p&gt;

&lt;p&gt;how exactly did the test fail, what was the real number and what was the expected number?&lt;/p&gt;

&lt;p&gt;I must admit I don&apos;t understand your scenario. The test happens only at the end, on an optimized index. We start two threads on an empty index. Both threads randomly add and delete documents and remember the number of documents added and deleted. At the end, when both threads are finished, the index should contain this many documents:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;added by thread 1 + # added by thread 2 - # deleted by thread 1 - # deleted by thread 2&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This is how I understand it. Maybe you could rephrase your scenario?&lt;/p&gt;

&lt;p&gt;Regards&lt;br/&gt;
 Daniel&lt;/p&gt;</comment>
                    <comment id="12344567" author="lucenebugs@danielnaber.de" created="Mon, 24 Oct 2005 08:40:01 +0100"  >&lt;p&gt;Okay, I see now that there are problems with the test. I will try to fix them, maybe that way it becomes clear (to me) if that test case makes sense at all.&lt;/p&gt;</comment>
                    <comment id="12349910" author="yseeley@gmail.com" created="Mon, 24 Oct 2005 12:46:28 +0100"  >&lt;p&gt;I see a few issues:&lt;/p&gt;

&lt;p&gt;1) A constant seed is used for reproducability:&lt;br/&gt;
  private Random random = new Random(101);		// constant seed for reproducability&lt;br/&gt;
But, it won&apos;t have that effect since the same random number generator is used across threads.&lt;/p&gt;

&lt;p&gt;2) race condition between checking idStack.size() and calling pop()&lt;/p&gt;

&lt;p&gt;3) non-atomic increment of the document id could lead to duplicates&lt;/p&gt;

&lt;p&gt;IMO, the ideal multithreaded test would be designed to not use any synchronization at all, making it easier to test if IndexModifier actually does all the synchronization it needs to.&lt;/p&gt;</comment>
                    <comment id="12355652" author="lucenebugs@danielnaber.de" created="Tue, 25 Oct 2005 06:56:49 +0100"  >&lt;p&gt;I just committed some updates, could you please check whether it&apos;s okay now?&lt;/p&gt;</comment>
                    <comment id="12355911" author="hossman" created="Wed, 26 Oct 2005 11:56:15 +0100"  >&lt;p&gt;Daniel: I used the following script to run through 50 iterations of the test...&lt;/p&gt;

&lt;p&gt;#!/bin/sh&lt;br/&gt;
for ((i=0; i &amp;lt; 50; i++)); do {&lt;br/&gt;
  ant test -Dtestcase=TestIndexModifier;&lt;br/&gt;
  mv build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml.$i;&lt;br/&gt;
};&lt;br/&gt;
done&lt;br/&gt;
grep -l &quot;failure message&quot; build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml.*&lt;/p&gt;

&lt;p&gt;...prior to upgrading to the changes you made, 30 of the 50 test runs failed (with the values being off by one or two in each case).  After upgrading to TestIndexModifier.java v328151, 0 of the 50 runs failed.  &lt;/p&gt;

&lt;p&gt;It&apos;s not a proof of correctness, but it certainly bodes well.&lt;/p&gt;

&lt;p&gt;I also want to clarify the scenerio I described earlier: I&apos;m an idiot.  I completely missed that each call to testIndexInternal(int) blocks waiting for the threads to finish &amp;#8211; for some reason I thought all three calls were happening concurrently.  So the types of scenerios I was initially thinking could cause problems were completely non-existent &amp;#8211; and it looks like you fixed all the ones Yonik noticed.&lt;/p&gt;

&lt;p&gt;(I do think Yonik has a good point however regarding a test with no synchronization at all &amp;#8211; this should be possible if each instant of IndexThread maintaining it&apos;s own id and idStack variables, using  &apos;threadNumber + &quot;-&quot; id++&apos; to generate new doc identifiers, and only ever deleted documents it added).&lt;/p&gt;</comment>
                    <comment id="12355988" author="yseeley@gmail.com" created="Thu, 27 Oct 2005 02:30:02 +0100"  >&lt;p&gt;Yep, it looks good.  I&apos;d go ahead and close this issue (if I knew how...)&lt;/p&gt;

&lt;p&gt;The multithreaded tests w/o any synchronization is just a good general guideline.  I briefly browsed the TestIndexModifier, and there shouldn&apos;t be any issues in that regard since  the synchronization is trivial (all public methods synchronized on the same object)&lt;/p&gt;</comment>
                    <comment id="12355991" author="lucenebugs@danielnaber.de" created="Thu, 27 Oct 2005 03:21:09 +0100"  >&lt;p&gt;Yonik, thanks for your review. I&apos;m closing this issue now. You&apos;ll need to ask Erik to give you committer&apos;s permissions in Jira, then you&apos;ll be able to close issues with the &quot;Workflow actions&quot; on the left.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 24 Oct 2005 07:10:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13307</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27289</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>