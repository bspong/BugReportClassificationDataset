<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:00:23 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2588/LUCENE-2588.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2588] terms index should not store useless suffixes</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2588</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This idea came up when discussing w/ Robert how to improve our terms index...&lt;/p&gt;

&lt;p&gt;The terms dict index today simply grabs whatever term was at a 0 mod 128 index (by default).&lt;/p&gt;

&lt;p&gt;But this is wasteful because you often don&apos;t need the suffix of the term at that point.&lt;/p&gt;

&lt;p&gt;EG if the 127th term is aa and the 128th (indexed) term is abcd123456789, instead of storing that full term you only need to store ab.  The suffix is useless, and uses up RAM since we load the terms index into RAM.&lt;/p&gt;

&lt;p&gt;The patch is very simple.  The optimization is particularly easy because terms are now byte[] and we sort in binary order.&lt;/p&gt;

&lt;p&gt;I tested on first 10M 1KB Wikipedia docs, and this reduces the terms index (tii) file from 3.9 MB -&amp;gt; 3.3 MB = 16% smaller (using StandardAnalyzer, indexing body field tokenized but title / date fields untokenized).  I expect on noisier terms dicts, especially ones w/ bad terms accidentally indexed, that the savings will be even more.&lt;/p&gt;

&lt;p&gt;In the future we could do crazier things.  EG there&apos;s no real reason why the indexed terms must be regular (every N terms), so, we could instead pick terms more carefully, say &quot;approximately&quot; every N, but favor terms that have a smaller net prefix.  We can also index more sparsely in regions where the net docFreq is lowish, since we can afford somewhat higher seek+scan time to these terms since enuming their docs will be much faster.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12470840">LUCENE-2588</key>
            <summary>terms index should not store useless suffixes</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Wed, 4 Aug 2010 22:39:30 +0100</created>
                <updated>Fri, 10 May 2013 11:44:46 +0100</updated>
                    <resolved>Sun, 19 Sep 2010 15:35:43 +0100</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12895435" author="mikemccand" created="Wed, 4 Aug 2010 22:45:23 +0100"  >&lt;p&gt;Attached patch.&lt;/p&gt;

&lt;p&gt;I also fixed int numTerms -&amp;gt; long numTerms which was a latent bug.&lt;/p&gt;</comment>
                    <comment id="12895438" author="yseeley@gmail.com" created="Wed, 4 Aug 2010 22:53:47 +0100"  >&lt;p&gt;Ah sweet, nice idea!&lt;/p&gt;</comment>
                    <comment id="12895506" author="rcmuir" created="Thu, 5 Aug 2010 02:34:56 +0100"  >&lt;p&gt;i think this patch as-is is a good improvement (at least as a defensive measure against &quot;noise&quot; terms and other things). it also seems to buy more savings on the non-latin data i tested (60kb -&amp;gt; 40kb). +1 to commit&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the future we could do crazier things. EG there&apos;s no real reason why the indexed terms must be regular (every N terms), so, we could instead pick terms more carefully, say &quot;approximately&quot; every N, but favor terms that have a smaller net prefix&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should explore this in the future. &quot;randomly&quot; selecting every N terms isn&apos;t optimal when allowing a &quot;fudge&quot; of the interval maybe +/- 5 or 10% could intentionally select terms that differ very quickly from their previous term, without wasting a bunch of cpu or unbalancing the terms index... &lt;/p&gt;

&lt;p&gt;if additional smarts like this could save enough size on average maybe we could rethink lowering the default interval of 128?&lt;/p&gt;</comment>
                    <comment id="12895638" author="mikemccand" created="Thu, 5 Aug 2010 11:22:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;if additional smarts like this could save enough size on average maybe we could rethink lowering the default interval of 128?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;With flex we&apos;ve already very substantially reduced the RAM cost, GC load and init time of the terms index.  We no longer create a TermInfo, Term, String objects per indexed term.&lt;/p&gt;

&lt;p&gt;So, I think even without these further mods we could drop the default index interval to maybe 32.&lt;/p&gt;</comment>
                    <comment id="12895639" author="mikemccand" created="Thu, 5 Aug 2010 11:29:57 +0100"  >&lt;p&gt;New patch, changes default TII to 32.&lt;/p&gt;</comment>
                    <comment id="12895640" author="mikemccand" created="Thu, 5 Aug 2010 11:33:49 +0100"  >&lt;p&gt;Allowing the term index interval to be variable (eg to find &quot;short min prefix&quot; terms to further improve savings from this opto, or to balance index terms by net docFreq of terms in each block) makes seek-by-ord more complex.&lt;/p&gt;

&lt;p&gt;Ie, today, because indexed terms are every N, seek by ord is a straight divide/mod.  But with variable spaced index terms, I think we&apos;d have to hold the ord of each indexed term in RAM, probably as packed int array so added RAM cost shouldn&apos;t be too bad.  Then a lookup by ord would require a binary search then scan.&lt;/p&gt;</comment>
                    <comment id="12895709" author="rcmuir" created="Thu, 5 Aug 2010 16:10:30 +0100"  >&lt;blockquote&gt;
&lt;p&gt;But with variable spaced index terms, I think we&apos;d have to hold the ord of each indexed term in RAM, probably as packed int array so added RAM cost shouldn&apos;t be too bad. Then a lookup by ord would require a binary search then scan.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, I was suggesting this mainly to try to justify lowering default TII, but if we can lower it &lt;br/&gt;
separately as you propose, but keep TII constant and not have to deal with this tradeoff, I think thats great!&lt;/p&gt;</comment>
                    <comment id="12896206" author="mikemccand" created="Sat, 7 Aug 2010 01:45:46 +0100"  >&lt;p&gt;Unfortunately, it&apos;s not quite as simple to do this on 3.x.&lt;/p&gt;

&lt;p&gt;On trunk, an indexed term points to the file pointer for that term&apos;s entry in the tis file, and we then read the absolute (term and frq/prx pointers) at that entry.&lt;/p&gt;

&lt;p&gt;But in 3.x, all entries are deltas (even the seek points), and, the indexed term points to the entry &lt;b&gt;after&lt;/b&gt; itself in the tis file, which requires that the term in memory be the full term (unless we change 3.x&apos;s index format to also store the absolutes at the seek points).&lt;/p&gt;</comment>
                    <comment id="12909688" author="simonw" created="Wed, 15 Sep 2010 11:25:19 +0100"  >&lt;p&gt;Reopening this because this optimization is not safe for all BytesRef comparators. Reverse unicode order already breaks it. See &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2622&quot; title=&quot;Random Test Failure org.apache.lucene.TestExternalCodecs.testPerFieldCodec (from TestExternalCodecs)&quot;&gt;&lt;del&gt;LUCENE-2622&lt;/del&gt;&lt;/a&gt; for details. The non-distinguishable suffix must be determined by the actually used Comparator otherwise the assumption might be wrong for non-standard sort order.&lt;/p&gt;</comment>
                    <comment id="12909699" author="rcmuir" created="Wed, 15 Sep 2010 12:46:47 +0100"  >&lt;p&gt;Should we really change StandardCodec to support this &lt;span class=&quot;error&quot;&gt;&amp;#91;non-binary order&amp;#93;&lt;/span&gt;?&lt;/p&gt;

&lt;p&gt;Really if you have anything but regular unicode order, other things in lucene will break too, such as queries.&lt;br/&gt;
The test just doesnt test these. Try changing the order of PreFlexCodec&apos;s comparator...&lt;/p&gt;

&lt;p&gt;Can&apos;t we just fix the test not to use StandardCodec? I mean we aren&apos;t taking any feature away here.&lt;/p&gt;</comment>
                    <comment id="12909717" author="simonw" created="Wed, 15 Sep 2010 13:59:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;Should we really change StandardCodec to support this &lt;span class=&quot;error&quot;&gt;&amp;#91;non-binary order&amp;#93;&lt;/span&gt;?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;m not sure if we should do, but we should at least document the limitation. People who work with that level do also read doc strings - if they don&apos;t let them be doomed but if you run into the bug we had in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2622&quot; title=&quot;Random Test Failure org.apache.lucene.TestExternalCodecs.testPerFieldCodec (from TestExternalCodecs)&quot;&gt;&lt;del&gt;LUCENE-2622&lt;/del&gt;&lt;/a&gt; you will have a super hard time to figure out what is going on without knowing lucene very very well. &lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;Can&apos;t we just fix the test not to use StandardCodec? I mean we aren&apos;t taking any feature away here. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 I think we should fix this test ASAP with either using byte sort order or add some MockCodec (what robert has suggested). &lt;/p&gt;</comment>
                    <comment id="12910072" author="mikemccand" created="Thu, 16 Sep 2010 11:07:12 +0100"  >&lt;p&gt;After I commit the simple renaming of standard codec&apos;s terms dicts (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2647&quot; title=&quot;Move &amp;amp; rename the terms dict, index, abstract postings out of oal.index.codecs.standard&quot;&gt;&lt;del&gt;LUCENE-2647&lt;/del&gt;&lt;/a&gt;), I plan to make this suffix-stripping opto private to StandardCodec (I think by refactoring SimpleTermsIndexWriter to add a method that can alter the indexed term before it&apos;s written).&lt;/p&gt;

&lt;p&gt;Since StandardCodec hardwires the term sort to unicode order, the opto is safe there.&lt;/p&gt;

&lt;p&gt;In general, if a codec uses a different term sort (such as this test&apos;s codec) it&apos;s conceivable a different opto could apply.  EG I think this test could prune suffix based on the term after the index term.  But, it makes no sense to spend time exploring this until a &quot;real&quot; use case arrives... this is just a simple test to assert that a codec is in fact free to customize the sort order.&lt;/p&gt;

&lt;p&gt;Also, there are other fun optos we could explore w/ terms index.  EG we could &quot;wiggle&quot; the index term selection a bit, so it wouldn&apos;t be fixed to every N, to try to find terms that are small after removing the useless suffix.  Separately, we could choose index terms according to docFreq &amp;#8211; eg one simple policy would be to plant an index term on term X if either 1) term X&apos;s docFreq is over a threshold, or, 2) it&apos;s been &amp;gt; N terms since the last indexed terms.  This could be a powerful way to even further reduce RAM usage of the terms index, because it&apos;d ensure that high cost terms (ie, many docs/freqs/positions to visit) are in fact fast to lookup.  The low freq terms can afford a higher seek time since it&apos;ll be so fast to enum the docs.&lt;/p&gt;</comment>
                    <comment id="12910084" author="simonw" created="Thu, 16 Sep 2010 11:40:57 +0100"  >&lt;blockquote&gt;
&lt;p&gt;After I commit the simple renaming of standard codec&apos;s terms dicts (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2647&quot; title=&quot;Move &amp;amp; rename the terms dict, index, abstract postings out of oal.index.codecs.standard&quot;&gt;&lt;del&gt;LUCENE-2647&lt;/del&gt;&lt;/a&gt;), I plan to make this suffix-stripping opto private to StandardCodec (I think by refactoring SimpleTermsIndexWriter to add a method that can alter the indexed term before it&apos;s written).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Mike what about factoring out a method like &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;short&lt;/span&gt; indexTermPrefixLen(BytesRef lastTerm, BytesRef currentTerm){
  ...
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then we can simply override that method if there is a comparator which can not utilize / breaks this opto?&lt;/p&gt;</comment>
                    <comment id="12910090" author="mikemccand" created="Thu, 16 Sep 2010 11:56:13 +0100"  >&lt;p&gt;I think that&apos;s good!  I&apos;ll take that approach.&lt;/p&gt;</comment>
                    <comment id="12910140" author="rcmuir" created="Thu, 16 Sep 2010 14:00:20 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Also, there are other fun optos we could explore w/ terms index. EG we could &quot;wiggle&quot; the index term selection a bit, so it wouldn&apos;t be fixed to every N, to try to find terms that are small after removing the useless suffix. Separately, we could choose index terms according to docFreq - eg one simple policy would be to plant an index term on term X if either 1) term X&apos;s docFreq is over a threshold, or, 2) it&apos;s been &amp;gt; N terms since the last indexed terms. This could be a powerful way to even further reduce RAM usage of the terms index, because it&apos;d ensure that high cost terms (ie, many docs/freqs/positions to visit) are in fact fast to lookup. The low freq terms can afford a higher seek time since it&apos;ll be so fast to enum the docs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;it would be great to come up with a heuristic that balances all 3 of these: &lt;br/&gt;
Because selecting % 32 is silly if it would give you &quot;abracadabra&quot; when the previous term is &quot;a&quot; and a fudge would give you a smaller index term (of course it depends too, on what the next index term would be, and the docfreq optimization too).&lt;/p&gt;

&lt;p&gt;It sounds tricky, but right now we are just selecting index terms with no basis at all (essentially random). then we are trying to deal with bad selections by trimming wasted suffixes, etc.&lt;/p&gt;</comment>
                    <comment id="12911190" author="mikemccand" created="Sun, 19 Sep 2010 11:48:06 +0100"  >&lt;p&gt;Attached patch &amp;#8211; factors out the opto into a separate method (indexedTermPrefixLength), and leaves the opto enabled by default.  Then I fixed TestExternalCodecs to override &amp;amp; disable the opto, and the test then passes w/ the seed that failed before.&lt;/p&gt;</comment>
                    <comment id="12911191" author="simonw" created="Sun, 19 Sep 2010 12:04:23 +0100"  >&lt;p&gt;Mike this looks good, just a little nit-picking&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; indexedTermPrefixLength(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; BytesRef priorTerm, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; BytesRef indexedTerm) {
    &lt;span class=&quot;code-comment&quot;&gt;// As &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; as codec sorts terms in unicode codepoint
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// order, we can safely strip off the non-distinguishing
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// suffix to save RAM in the loaded terms index.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; idxOffset = indexedTerm.offset;
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; priorOffset = priorTerm.offset;
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; limit = &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.min(priorTerm.length, indexedTerm.length);
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; byteIdx=0;byteIdx&amp;lt;limit;byteIdx++) {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (priorTerm.bytes[priorOffset+byteIdx] != indexedTerm.bytes[idxOffset+byteIdx]) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; byteIdx+1;
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.min(1+priorTerm.length, indexedTerm.length);;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I know this is not super hot code but maybe we wanna safe the Math.min() method call if not necessary and public member deref is also an unnecessary indirection. On a low termIndexInterval and lot of long terms like shingles we might save some cycles &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I mean that would&apos;t make a big difference just mentioning it though.&lt;/p&gt;</comment>
                    <comment id="12912216" author="mikemccand" created="Sun, 19 Sep 2010 13:20:16 +0100"  >&lt;p&gt;Sure &amp;#8211; we can fix those.  You wanna take a stab?&lt;/p&gt;</comment>
                    <comment id="12912220" author="simonw" created="Sun, 19 Sep 2010 13:48:01 +0100"  >&lt;p&gt;attached nit-picky iteration. Both failures from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2622&quot; title=&quot;Random Test Failure org.apache.lucene.TestExternalCodecs.testPerFieldCodec (from TestExternalCodecs)&quot;&gt;&lt;del&gt;LUCENE-2622&lt;/del&gt;&lt;/a&gt; pass now - I will commit soon if nobody objects&lt;/p&gt;</comment>
                    <comment id="12912232" author="simonw" created="Sun, 19 Sep 2010 15:35:43 +0100"  >&lt;p&gt;Committed revision 998675.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12472537">LUCENE-2622</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12454974" name="LUCENE-2588.patch" size="3762" author="simonw" created="Sun, 19 Sep 2010 13:48:01 +0100" />
                    <attachment id="12454972" name="LUCENE-2588.patch" size="3719" author="mikemccand" created="Sun, 19 Sep 2010 11:48:06 +0100" />
                    <attachment id="12451321" name="LUCENE-2588.patch" size="4226" author="mikemccand" created="Thu, 5 Aug 2010 11:29:57 +0100" />
                    <attachment id="12451269" name="LUCENE-2588.patch" size="2624" author="mikemccand" created="Wed, 4 Aug 2010 22:45:23 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 4 Aug 2010 21:53:47 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11246</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25104</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>