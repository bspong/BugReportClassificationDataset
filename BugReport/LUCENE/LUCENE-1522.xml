<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:19:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1522/LUCENE-1522.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1522] another highlighter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1522</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I&apos;ve written this highlighter for my project to support bi-gram token stream (general token stream (e.g. WhitespaceTokenizer) also supported. see test code in patch). The idea was inherited from my previous project with my colleague and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-644&quot; title=&quot;Contrib: another highlighter approach&quot;&gt;&lt;del&gt;LUCENE-644&lt;/del&gt;&lt;/a&gt;. This approach needs highlight fields to be TermVector.WITH_POSITIONS_OFFSETS, but is fast and can support N-grams. This depends on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt; to get refined term offsets.&lt;/p&gt;

&lt;p&gt;usage:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
TopDocs docs = searcher.search( query, 10 );
Highlighter h = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Highlighter();
FieldQuery fq = h.getFieldQuery( query );
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;( ScoreDoc scoreDoc : docs.scoreDocs ){
  &lt;span class=&quot;code-comment&quot;&gt;// fieldName=&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, fragCharSize=100, numFragments=3
&lt;/span&gt;  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] fragments = h.getBestFragments( fq, reader, scoreDoc.doc, &lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, 100, 3 );
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( fragments != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ){
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; fragment : fragments )
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println( fragment );
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;features:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fast for large docs&lt;/li&gt;
	&lt;li&gt;supports not only whitespace-based token stream, but also &quot;fixed size&quot; N-gram (e.g. (2,2), not (1,3)) (can solve &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1489&quot; title=&quot;highlighter problem with n-gram tokens&quot;&gt;&lt;del&gt;LUCENE-1489&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;supports PhraseQuery, phrase-unit highlighting with slops
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;q=&quot;w1 w2&quot;
&amp;lt;b&amp;gt;w1 w2&amp;lt;/b&amp;gt;
---------------
q=&quot;w1 w2&quot;~1
&amp;lt;b&amp;gt;w1&amp;lt;/b&amp;gt; w3 &amp;lt;b&amp;gt;w2&amp;lt;/b&amp;gt; w3 &amp;lt;b&amp;gt;w1 w2&amp;lt;/b&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;highlight fields need to be TermVector.WITH_POSITIONS_OFFSETS&lt;/li&gt;
	&lt;li&gt;easy to apply patch due to independent package (contrib/highlighter2)&lt;/li&gt;
	&lt;li&gt;uses Java 1.5&lt;/li&gt;
	&lt;li&gt;looks query boost to score fragments (currently doesn&apos;t see idf, but it should be possible)&lt;/li&gt;
	&lt;li&gt;pluggable FragListBuilder&lt;/li&gt;
	&lt;li&gt;pluggable FragmentsBuilder&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;to do:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;term positions can be unnecessary when phraseHighlight==false&lt;/li&gt;
	&lt;li&gt;collects performance numbers&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
            <key id="12412752">LUCENE-1522</key>
            <summary>another highlighter</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="markrmiller@gmail.com">Mark Miller</assignee>
                                <reporter username="koji">Koji Sekiguchi</reporter>
                        <labels>
                    </labels>
                <created>Mon, 19 Jan 2009 14:45:22 +0000</created>
                <updated>Thu, 2 May 2013 03:29:20 +0100</updated>
                    <resolved>Sun, 16 Aug 2009 22:57:46 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>modules/highlighter</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>3</watches>
                                                    <comments>
                    <comment id="12665132" author="koji" created="Mon, 19 Jan 2009 14:50:43 +0000"  >&lt;p&gt;to apply this patch, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt; also need to be applied.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;$ svn co -r713975 http:&lt;span class=&quot;code-comment&quot;&gt;//svn.apache.org/repos/asf/lucene/java/trunk
&lt;/span&gt;$ cd trunk
$ patch -p0 &amp;lt; LUCENE-1448.patch
$ patch -p0 &amp;lt; LUCENE-1522.patch
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12675977" author="koji" created="Mon, 23 Feb 2009 17:05:04 +0000"  >&lt;p&gt;The attached patch has &quot;colored tag highlighting&quot; feature. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I provided the following colored tags:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;BaseFragmentsBuilder.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] COLORED_PRE_TAGS = {
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:yellow\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:lawngreen\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:aquamarine\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;,
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:magenta\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:palegreen\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:coral\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;,
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:wheat\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:khaki\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:lime\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;,
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;b style=\&quot;&lt;/span&gt;background:deepskyblue\&lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;
};
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A sample picture will be attached shortly.&lt;/p&gt;</comment>
                    <comment id="12681249" author="mikemccand" created="Thu, 12 Mar 2009 10:28:31 +0000"  >
&lt;p&gt;This highlighter looks very interesting!  I love the colored tags, and&lt;br/&gt;
the fast performance on large docs, and the extensive unit tests.&lt;/p&gt;

&lt;p&gt;When I applied the patch to current trunk, I see some tests failing,&lt;br/&gt;
eg:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit] Testcase: test1PhraseLongMVB(org.apache.lucene.search.highlight2.FieldPhraseListTest):	FAILED
    [junit] expected:&amp;lt;sppeeeed(1.0)((8[8,93]))&amp;gt; but was:&amp;lt;sppeeeed(1.0)((8[7,92]))&amp;gt;
    [junit] junit.framework.ComparisonFailure: expected:&amp;lt;sppeeeed(1.0)((8[8,93]))&amp;gt; but was:&amp;lt;sppeeeed(1.0)((8[7,92]))&amp;gt;
    [junit] 	at org.apache.lucene.search.highlight2.FieldPhraseListTest.test1PhraseLongMVB(FieldPhraseListTest.java:175)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is this approach guaranteed to only highlight term occurrences that&lt;br/&gt;
actually contribute to the document match?  Can it handle all /&lt;br/&gt;
arbitrary Query subclasses?  How does it score fragments?&lt;/p&gt;

&lt;p&gt;I also like that you first generate hits in the document, and from&lt;br/&gt;
those hits you generate fragments (if I&apos;m reading the code correctly);&lt;br/&gt;
this is a nicely scalable approach.&lt;/p&gt;</comment>
                    <comment id="12681264" author="koji" created="Thu, 12 Mar 2009 11:15:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This highlighter looks very interesting! I love the colored tags, and&lt;br/&gt;
the fast performance on large docs, and the extensive unit tests.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thank you for paying attention on this issue, Mike!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When I applied the patch to current trunk, I see some tests failing,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Note that this issue depends on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt;, so you apply &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt;.patch first, then apply &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1522&quot; title=&quot;another highlighter&quot;&gt;&lt;del&gt;LUCENE-1522&lt;/del&gt;&lt;/a&gt;.patch.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;# To apply LUCENE-1448.patch, check out revision 713975!!!
$ svn co -r713975 http://svn.apache.org/repos/asf/lucene/java/trunk
$ cd trunk
$ patch -p0 &amp;lt; LUCENE-1448.patch
$ patch -p0 &amp;lt; LUCENE-1522.patch
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;ll post comment later for the rest of your questions. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12681282" author="mikemccand" created="Thu, 12 Mar 2009 12:15:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;Note that this issue depends on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops, right I had skipped that step.&lt;/p&gt;</comment>
                    <comment id="12681517" author="mikemccand" created="Thu, 12 Mar 2009 22:03:34 +0000"  >&lt;p&gt;Does this highlighter have a &quot;max tokens to analyze&quot; setting?  Or does it always visit all terms in each document?&lt;/p&gt;</comment>
                    <comment id="12681531" author="markh" created="Thu, 12 Mar 2009 22:45:25 +0000"  >&lt;p&gt;I&apos;m guessing that&apos;s not an issue given it uses stored TermVectors rather than re-analyzing?&lt;/p&gt;

&lt;p&gt;At some stage I hope to take a closer look at this contribution.  I&apos;d be interested to see if all the Highlighter1  Junit tests could be adapted to work with Highlighter2 and get some comparative benchmarks.&lt;/p&gt;</comment>
                    <comment id="12682111" author="koji" created="Sun, 15 Mar 2009 00:58:32 +0000"  >&lt;p&gt;Mike, I&apos;m sorry for late reply.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is this approach guaranteed to only highlight term occurrences that actually contribute to the document match?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure if I understand what you are asking, but if you talk about &quot;hl.requireFieldMatch feature in Solr&quot;, YES. highlighter2 has the feature:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/**
 * a constructor. A FragListBuilder and a FragmentsBuilder can be specified (plugins).
 * 
 * @param phraseHighlight &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; of &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; phrase highlighting
 * @param fieldMatch &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; of &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; field matching
 * @param fragListBuilder an instance of FragListBuilder
 * @param fragmentsBuilder an instance of FragmentsBuilder
 */
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Highlighter( &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; phraseHighlight, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; fieldMatch, FragListBuilder fragListBuilder, FragmentsBuilder fragmentsBuilder ){
  &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.phraseHighlight = phraseHighlight;
  &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.fieldMatch = fieldMatch;
  &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.fragListBuilder = fragListBuilder;
  &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.fragmentsBuilder = fragmentsBuilder;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;Can it handle all / arbitrary Query subclasses?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Currently, no. Highlighter2 calls flatten() method to try to flat the sourceQuery in the beginning. In flatten() method, it recognizes TermQuery and PhraseQuery, and BooleanQuery that contains TermQuery and PhraseQuery:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;FieldQuery.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
void flatten( Query sourceQuery, Collection&amp;lt;Query&amp;gt; flatQueries ){
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( sourceQuery &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; BooleanQuery ){
    BooleanQuery bq = (BooleanQuery)sourceQuery;
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;( BooleanClause clause : bq.getClauses() ){
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( !clause.isProhibited() )
        flatten( clause.getQuery(), flatQueries );
    }
  }
  &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( sourceQuery &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; TermQuery ){
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( !flatQueries.contains( sourceQuery ) )
      flatQueries.add( sourceQuery );
  }
  &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( sourceQuery &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; PhraseQuery ){
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( !flatQueries.contains( sourceQuery ) ){
      PhraseQuery pq = (PhraseQuery)sourceQuery;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( pq.getTerms().length &amp;gt; 1 )
        flatQueries.add( pq );
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( pq.getTerms().length == 1 ){
        flatQueries.add( &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TermQuery( pq.getTerms()[0] ) );
      }
    }
  }
  &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; discard queries
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But I&apos;m always positive to support all / arbitrary Query subclasses in H2. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How does it score fragments?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Currently, H2 takes into account query time boost and tf in fragment. For example, if we have q=&quot;a OR b^3&quot; and two fragment candidates f1=&quot;a a a&quot; and f2=&quot;a b&quot;, f1 gets 3 and f2 gets 4, getBestFragments() will return f2 first, then f1 when ScoreOrderFragmentsBuilder (default) is used.&lt;/p&gt;</comment>
                    <comment id="12682112" author="koji" created="Sun, 15 Mar 2009 01:05:31 +0000"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m guessing that&apos;s not an issue given it uses stored TermVectors rather than re-analyzing?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;At some stage I hope to take a closer look at this contribution.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Very nice!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;d be interested to see if all the Highlighter1 Junit tests could be adapted to work with Highlighter2 and get some comparative benchmarks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure all H1 test cases could be adapted to work with H2 because boundary of fragments will be different between H1 and H2, but benchmarks of performance is on my todo list.&lt;/p&gt;</comment>
                    <comment id="12682270" author="mikemccand" created="Mon, 16 Mar 2009 10:35:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure if I understand what you are asking, but if you talk about &quot;hl.requireFieldMatch feature in Solr&quot;, YES. highlighter2 has the feature:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually I was asking whether every fragment that&apos;s returned is&lt;br/&gt;
guaranteed to show a match to my original query.&lt;/p&gt;

&lt;p&gt;EG if my query is a PhraseQuery, is it guaranteed that all fragments&lt;br/&gt;
presented are valid matches?  If I search for &quot;Alan Greenspan&apos;s&lt;br/&gt;
mortgage&quot;, is it ever possible to see a fragment that contains only&lt;br/&gt;
&quot;Alan Greenspan&quot;?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Currently, no. Highlighter2 calls flatten() method to try to flat the sourceQuery in the beginning. In flatten() method, it recognizes TermQuery and PhraseQuery, and BooleanQuery that contains TermQuery and PhraseQuery:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK so eg *SpanQuery won&apos;t work?  It seems like both highlighters take&lt;br/&gt;
this &quot;flatten&quot; approach, which can lose the constraints for&lt;br/&gt;
interesting queries (like Span, or a custom query).&lt;/p&gt;

&lt;p&gt;I think a nice &lt;span class=&quot;error&quot;&gt;&amp;#91;eventual&amp;#93;&lt;/span&gt; model would be if we could simply re-run the&lt;br/&gt;
scorer on the single document (using InstantiatedIndex maybe, or&lt;br/&gt;
simply some sort of wrapper on the term vectors which are already a&lt;br/&gt;
mini-inverted-index for a single doc), but extend the scorer API to&lt;br/&gt;
tell us the exact term occurrences that participated in a match (which&lt;br/&gt;
I don&apos;t think is exposed today).&lt;/p&gt;

&lt;p&gt;EG ExactPhraseScorere.phraseFreq has the logic to check term positions&lt;br/&gt;
and find all positions where the phrase matches.  Right now that&lt;br/&gt;
method throws away the specific position where each match occurred,&lt;br/&gt;
but if instead we had it call a normally no-op method&lt;br/&gt;
(recordDocMatchPosition(int position, float score) or some such), we&lt;br/&gt;
could then make use of it for highlighting.&lt;/p&gt;</comment>
                    <comment id="12682351" author="koji" created="Mon, 16 Mar 2009 16:22:18 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Actually I was asking whether every fragment that&apos;s returned is&lt;br/&gt;
guaranteed to show a match to my original query.&lt;/p&gt;

&lt;p&gt;EG if my query is a PhraseQuery, is it guaranteed that all fragments&lt;br/&gt;
presented are valid matches? If I search for &quot;Alan Greenspan&apos;s&lt;br/&gt;
mortgage&quot;, is it ever possible to see a fragment that contains only&lt;br/&gt;
&quot;Alan Greenspan&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I see. Yes, H2 guarantees it.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OK so eg *SpanQuery won&apos;t work? It seems like both highlighters take&lt;br/&gt;
this &quot;flatten&quot; approach, which can lose the constraints for&lt;br/&gt;
interesting queries (like Span, or a custom query).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;H2 doesn&apos;t support SpanQuery right now. I&apos;ll look at SpanScorer and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1425&quot; title=&quot;Add ConstantScore highlighting support to SpanScorer&quot;&gt;&lt;del&gt;LUCENE-1425&lt;/del&gt;&lt;/a&gt; to see whether I can support &quot;interesting queries&quot; in H2, before going to &quot;eventual model&quot; (looks great) you mentioned above.&lt;/p&gt;</comment>
                    <comment id="12682387" author="markrmiller@gmail.com" created="Mon, 16 Mar 2009 17:51:45 +0000"  >&lt;p&gt;I don&apos;t think its easy to get a speedy highlighter that works with positions for all of the Lucene queries. In the long term, I&apos;d love to see a fast highlighter that works with positions for all of Lucene&apos;s queries . I&apos;d also like it to work if you don&apos;t have termvectors stored (though be faster if they are perhaps, as it is now).&lt;/p&gt;

&lt;p&gt;Essentially we have each of these pieces separately now - the difficulty is doing it with one highlighter. &lt;/p&gt;

&lt;p&gt;We have the standard Highlighter with two modes: one that doesn&apos;t handle positions, and one that handles position sensitive highlighting for Spans and almost all of the queries. This framework is great - its customizable, it handles a lot of corner cases, it works without termvectors, it gets faster with termvectors. Unfortunately, it runs through the source stream one token at a time, and doesn&apos;t scale well. Getting hit positions for position sensitive clauses requires converting the query to a span query and calling getSpans on a memory index&lt;/p&gt;

&lt;p&gt;We also have the termvector highlighters that can work from offsets in the query and avoid running through a token at a time. You need termvectors for this approach, and its difficult to handle positions, but it scales.&lt;/p&gt;

&lt;p&gt;The difficulty and goal is in merging the qualities of both. &lt;/p&gt;</comment>
                    <comment id="12682390" author="markrmiller@gmail.com" created="Mon, 16 Mar 2009 17:59:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think a nice &lt;span class=&quot;error&quot;&gt;&amp;#91;eventual&amp;#93;&lt;/span&gt; model would be if we could simply re-run the&lt;br/&gt;
scorer on the single document (using InstantiatedIndex maybe, or&lt;br/&gt;
simply some sort of wrapper on the term vectors which are already a&lt;br/&gt;
mini-inverted-index for a single doc), but extend the scorer API to&lt;br/&gt;
tell us the exact term occurrences that participated in a match (which&lt;br/&gt;
I don&apos;t think is exposed today).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Variations on this have been tossed around before, but this sounds like a slightly more interesting approach than whats been mentioned. Its sort of how the current highlighter handles positions, but avoids the messy step of trying to convert any query to a spanquery.&lt;/p&gt;

&lt;p&gt;Not sure it solves being able to gets offsets from the query terms and still mask for positions though - if that step can be completed, we can start by using the current SpanScorer logic with this patch, until we get the pieces into core Lucene. &lt;/p&gt;</comment>
                    <comment id="12682422" author="michaelbusch" created="Mon, 16 Mar 2009 19:32:47 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think a nice &lt;span class=&quot;error&quot;&gt;&amp;#91;eventual&amp;#93;&lt;/span&gt; model would be if we could simply re-run the&lt;br/&gt;
scorer on the single document (using InstantiatedIndex maybe, or&lt;br/&gt;
simply some sort of wrapper on the term vectors which are already a&lt;br/&gt;
mini-inverted-index for a single doc), but extend the scorer API to&lt;br/&gt;
tell us the exact term occurrences that participated in a match (which&lt;br/&gt;
I don&apos;t think is exposed today).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But, if you have for example a document &apos;a b c a b c&apos; and the query&lt;br/&gt;
&apos;a AND b&apos;, then this approach would only highlight the first two terms,&lt;br/&gt;
no?&lt;/p&gt;</comment>
                    <comment id="12682492" author="mikemccand" created="Mon, 16 Mar 2009 22:37:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;d also like it to work if you don&apos;t have termvectors stored (though&lt;br/&gt;
be faster if they are perhaps, as it is now).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Getting hit positions for position sensitive clauses requires&lt;br/&gt;
converting the query to a span query and calling getSpans on a memory&lt;br/&gt;
index &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is the reason why H1 creates the full token stream (even when&lt;br/&gt;
TermVectors is the source) in order to build the MemoryIndex?&lt;/p&gt;

&lt;p&gt;If term vectors (w/ positions, offsets) were stored, wouldn&apos;t it be&lt;br/&gt;
possible to make a simple index (or at least TermDocs, TermPositions)&lt;br/&gt;
wrapped on those TermVectors? &lt;/p&gt;</comment>
                    <comment id="12682494" author="mikemccand" created="Mon, 16 Mar 2009 22:38:11 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;But, if you have for example a document &apos;a b c a b c&apos; and the query&lt;br/&gt;
&apos;a AND b&apos;, then this approach would only highlight the first two terms,&lt;br/&gt;
no?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh right &amp;#8211; in fact, nothing would be highlighted because the scorer&lt;br/&gt;
for AND queries doesn&apos;t visit positions at all (it doesn&apos;t need to).&lt;/p&gt;

&lt;p&gt;I guess we&apos;d have to ask such scorers to forcefully visit positions &amp;amp;&lt;br/&gt;
enumerate all matches within one doc, when running in &quot;highlight&quot;&lt;br/&gt;
mode.  Hmm, feeling like a big change...&lt;/p&gt;

&lt;p&gt;But maybe it could work.  It&apos;d be sort of like a positional-aware&lt;br/&gt;
&quot;explain&quot;, ie &quot;show me the term occurrences that allowed the full&lt;br/&gt;
query to accept this document&quot;.&lt;/p&gt;

&lt;p&gt;Imagine query &quot;(a AND b) OR (c AND d)&quot;.  When looking at the fragments&lt;br/&gt;
for each doc, I would want to see both a AND b, or both c AND d, but&lt;br/&gt;
never (for example) just a and d.&lt;/p&gt;

&lt;p&gt;But, flattening could produce just a and d (I think?); and I think H1&lt;br/&gt;
could do the same even with SpanScorer (Mark is that true?  I don&apos;t&lt;br/&gt;
fully understand the Query -&amp;gt; SpanQuery conversion).&lt;/p&gt;

&lt;p&gt;Whereas if we could ask for positions of the &quot;real&quot; matches I think it&lt;br/&gt;
would work correctly?&lt;/p&gt;</comment>
                    <comment id="12682502" author="mikemccand" created="Mon, 16 Mar 2009 22:45:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;Not sure it solves being able to gets offsets from the query terms and still mask for positions though&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you explain that more?&lt;/p&gt;</comment>
                    <comment id="12682506" author="markrmiller@gmail.com" created="Mon, 16 Mar 2009 22:57:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;Is the reason why H1 creates the full token stream (even when&lt;br/&gt;
TermVectors is the source) in order to build the MemoryIndex?&lt;/p&gt;

&lt;p&gt;If term vectors (w/ positions, offsets) were stored, wouldn&apos;t it be&lt;br/&gt;
possible to make a simple index (or at least TermDocs, TermPositions)&lt;br/&gt;
wrapped on those TermVectors? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It creates the full tokenstream because it was designed to work without termvectors, and so without offset info for the query terms, it rebuilds the stream and processes a token at a time - the api gives you hooks to highlight at any of these tokens - thats essentially the bottleneck I think - taking everything a token at a time, but the whole API is based on that fact. With the SpanScorer version, we can get almost any info from the MemoryIndex, but it was convenient to fit into the current highlighter API to start. I had it in my mind to break from the API and make a largedoc highlighter that didn&apos;t need termvectors, but I found the memory index and getspans to still be too slow in my initial testing. I&apos;d hoped to work more on it, but havn&apos;t had a chance. So essentially, while more can be done with termvectors, the improvements break the current API at a pretty deep level - no one has done the work to solve that I guess - which is why we have the alternate highlighters.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;edit&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;I suppose one of the main problems with my briefly tested large doc approach I tried is that it still requires that you rebuild the tokenstream (and I was attempting to not use termvectors either).  Avoiding the need for that would probably make it much more competitive.&lt;/p&gt;</comment>
                    <comment id="12682515" author="creamyg" created="Mon, 16 Mar 2009 23:25:02 +0000"  >&lt;p&gt;&amp;gt; It&apos;d be sort of like a positional-aware &quot;explain&quot;, ie &quot;show me the term&lt;br/&gt;
&amp;gt; occurrences that allowed the full query to accept this document&quot;.&lt;/p&gt;

&lt;p&gt;FWIW, this is more or less how the KinoSearch highlighter now works in svn&lt;br/&gt;
trunk.  It doesn&apos;t use a Scorer, though, but instead the KS analogue to&lt;br/&gt;
Lucene&apos;s &quot;Weight&quot; class.&lt;/p&gt;

&lt;p&gt;The (Weight) is fed what is essentially a single doc index, using stored term&lt;br/&gt;
vectors.  Weight.highlightSpans() returns an array of &quot;span&quot; objects, each of &lt;br/&gt;
which has a start offset, a length, and a score.  The Highlighter then &lt;br/&gt;
processes these span objects to create a &quot;heat map&quot; and choose its excerpt &lt;br/&gt;
points.&lt;/p&gt;

&lt;p&gt;The idea is that by delegating responsibility for creating the scoring spans, we&lt;br/&gt;
make it easier to support arbitrary Query implementations with a single&lt;br/&gt;
Highlighter class.&lt;/p&gt;</comment>
                    <comment id="12682609" author="mikemccand" created="Tue, 17 Mar 2009 09:29:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; It&apos;d be sort of like a positional-aware &quot;explain&quot;, ie &quot;show me the term&lt;br/&gt;
&amp;gt; occurrences that allowed the full query to accept this document&quot;.&lt;/p&gt;

&lt;p&gt;FWIW, this is more or less how the KinoSearch highlighter now works in svn&lt;br/&gt;
trunk. It doesn&apos;t use a Scorer, though, but instead the KS analogue to&lt;br/&gt;
Lucene&apos;s &quot;Weight&quot; class.&lt;/p&gt;

&lt;p&gt;The (Weight) is fed what is essentially a single doc index, using stored term&lt;br/&gt;
vectors. Weight.highlightSpans() returns an array of &quot;span&quot; objects, each of &lt;br/&gt;
which has a start offset, a length, and a score. The Highlighter then &lt;br/&gt;
processes these span objects to create a &quot;heat map&quot; and choose its excerpt &lt;br/&gt;
points.&lt;/p&gt;

&lt;p&gt;The idea is that by delegating responsibility for creating the scoring spans, we&lt;br/&gt;
make it easier to support arbitrary Query implementations with a single&lt;br/&gt;
Highlighter class.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Awesome!&lt;/p&gt;

&lt;p&gt;Do you require term vectors to be stored, for highlighting (cannot&lt;br/&gt;
re-analyze the text)?&lt;/p&gt;

&lt;p&gt;For queries that normally do not use positions at all (simple AND/OR&lt;br/&gt;
of terms), how does your highlightSpans() work?&lt;/p&gt;

&lt;p&gt;For BooleanQuery, is coord factor used to favor fragment sets that&lt;br/&gt;
include more unique terms?&lt;/p&gt;

&lt;p&gt;Are you guaranteed to always present a net set of fragments that&lt;br/&gt;
&quot;matches&quot; the query? (eg the example query above).&lt;/p&gt;

&lt;p&gt;I think the base litmus test for a hightlighter is: if one were to&lt;br/&gt;
take all fragments presented for a document (call this a &quot;fragdoc&quot;)&lt;br/&gt;
and make a new document from it, would that document match the&lt;br/&gt;
original query?&lt;/p&gt;

&lt;p&gt;In fact, I think the perfect highlighter would &quot;logically&quot; work as&lt;br/&gt;
follows: take a single document and enumerate every single possible&lt;br/&gt;
fragdoc.  Each fragdoc is allowed to have maxNumFragments fragments,&lt;br/&gt;
where each fragment has a min/max number of characters.  The set of&lt;br/&gt;
fragdocs is of course ridiculously immense.&lt;/p&gt;

&lt;p&gt;Take this massive collection of fragdocs and build a new temporary&lt;br/&gt;
index, then run your Query against that index.  Many of the fragdocs&lt;br/&gt;
would not match the Query, so they are eliminated right off (this is&lt;br/&gt;
the litmus test).  Then, of the ones that do, you want the highest&lt;br/&gt;
scoring fragdocs.&lt;/p&gt;

&lt;p&gt;Obviously you can&apos;t actually implement a highlighter like that, but I&lt;br/&gt;
think &quot;logically&quot; that is the optimal highlighter that we are trying&lt;br/&gt;
to emulate with more efficient implementations.&lt;/p&gt;

&lt;p&gt;I think having the Query/Weight/Scorer class be the single-source for&lt;br/&gt;
hits, explanation &amp;amp; highlight spans is the right approach.  Having a&lt;br/&gt;
whole separate package trying to reverse-engineer where matches had&lt;br/&gt;
taken place between Query and Document is hard to get right.  EG&lt;br/&gt;
BooleanScorer2&apos;s coord factor would naturally/correctly influence the&lt;br/&gt;
selection.&lt;/p&gt;

&lt;p&gt;I also think building a &lt;span class=&quot;error&quot;&gt;&amp;#91;reduced, just Postings&amp;#93;&lt;/span&gt; IndexReader API on top of&lt;br/&gt;
TermVectors ought to be a simple way to get great performance here.&lt;/p&gt;</comment>
                    <comment id="12682672" author="creamyg" created="Tue, 17 Mar 2009 13:31:06 +0000"  >&lt;p&gt;&amp;gt; Do you require term vectors to be stored, for highlighting (cannot&lt;br/&gt;
&amp;gt; re-analyze the text)?&lt;/p&gt;

&lt;p&gt;Yes, but that&apos;s not fundamental to the design.  You just have to hand the&lt;br/&gt;
Weight some sort of single-doc index that includes sufficient data to&lt;br/&gt;
determine what parts of the text contributed to the hit and how much they&lt;br/&gt;
contributed.  The Weight needn&apos;t care whether that single-doc index was&lt;br/&gt;
created on the fly or stored at index time.&lt;/p&gt;

&lt;p&gt;&amp;gt; For queries that normally do not use positions at all (simple AND/OR&lt;br/&gt;
&amp;gt; of terms), how does your highlightSpans() work?&lt;/p&gt;

&lt;p&gt;ANDQuery, ORQuery, and RequiredOptionalQuery just return the union of the&lt;br/&gt;
spans produced by their children.&lt;/p&gt;

&lt;p&gt;&amp;gt; For BooleanQuery, is coord factor used to favor fragment sets that&lt;br/&gt;
&amp;gt; include more unique terms?&lt;/p&gt;

&lt;p&gt;No; I don&apos;t think that would be fine grained enough to help.&lt;/p&gt;

&lt;p&gt;There&apos;s a HeatMap class that performs additional weighting.  Spans that&lt;br/&gt;
cluster together tightly (i.e. that could fit together within the excerpt) are&lt;br/&gt;
boosted.&lt;/p&gt;

&lt;p&gt;&amp;gt; Are you guaranteed to always present a net set of fragments that&lt;br/&gt;
&amp;gt; &quot;matches&quot; the query? (eg the example query above).&lt;/p&gt;

&lt;p&gt;No.  The KS version supplies a single fragment.  It naturally prefers&lt;br/&gt;
fragments with rarer terms, because the span scores are multiplied by the&lt;br/&gt;
Weight&apos;s weighting factor (which includes IDF).  &lt;/p&gt;

&lt;p&gt;Once that fragment is selected, the KS highlighter worries a lot about&lt;br/&gt;
trimming to sensible sentence boundaries.&lt;/p&gt;

&lt;p&gt;In my own subjective judgment, supplying a single maximally coherent fragment&lt;br/&gt;
which prefers clusters of rare terms results in an excerpt which &quot;scans&quot; as&lt;br/&gt;
quickly as possible, conveying the gist of the content with minimal &quot;visual&lt;br/&gt;
effort&quot;.  I used Google&apos;s excerpting as a model.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think the base litmus test for a hightlighter is: if one were to&lt;br/&gt;
&amp;gt; take all fragments presented for a document (call this a &quot;fragdoc&quot;)&lt;br/&gt;
&amp;gt; and make a new document from it, would that document match the&lt;br/&gt;
&amp;gt; original query?&lt;/p&gt;

&lt;p&gt;With out the aid of formal studies to guide us, this is a subjective call.&lt;br/&gt;
FWIW, I disagree.  In my view, visual scanning speed and coherence&lt;br/&gt;
are more important than completeness.  &lt;/p&gt;

&lt;p&gt;I&apos;m not a big fan of the multi-fragment approach, because I think it takes too&lt;br/&gt;
much effort to grok each individual entry.  Furthermore, the fact that the&lt;br/&gt;
fragments don&apos;t start on sentence boundaries (whenever feasible) adds to the&lt;br/&gt;
visual effort needed to orient yourself.&lt;/p&gt;

&lt;p&gt;Search results contain a lot of junk.  The user needs to be able to parse the&lt;br/&gt;
results page as quickly as possible and refine their search query as needed.&lt;br/&gt;
Noisy excerpts, with lots of elipses and few sentences that can be &quot;swallowed&lt;br/&gt;
whole&quot; impede that.  Trees vs. Forest.&lt;/p&gt;

&lt;p&gt;Again, that&apos;s my own aesthetic judgment, but I&apos;ll wager that there are studies&lt;br/&gt;
out there showing that fragments which start at the top of a sentence are&lt;br/&gt;
easier to consume, and I think that&apos;s important.&lt;/p&gt;

&lt;p&gt;&amp;gt; In fact, I think the perfect highlighter would &quot;logically&quot; work as&lt;br/&gt;
&amp;gt; follows: take a single document and enumerate every single possible&lt;br/&gt;
&amp;gt; fragdoc. &lt;/p&gt;

&lt;p&gt;KS uses a sliding window rather than chunking up the text into fragdocs of&lt;br/&gt;
fixed length.&lt;/p&gt;

&lt;p&gt;&amp;gt; Having a whole separate package trying to reverse-engineer where matches had&lt;br/&gt;
&amp;gt; taken place between Query and Document is hard to get right.&lt;/p&gt;

&lt;p&gt;Exactly.&lt;/p&gt;

&lt;p&gt;PS: Obviously, refinements of the highlighting algo will help Lucy, too. I&lt;br/&gt;
don&apos;t suppose you want to continue this on the Lucy dev list so that Lucy&lt;br/&gt;
banks some community credit for this discussion.  :\&lt;/p&gt;</comment>
                    <comment id="12682688" author="mikemccand" created="Tue, 17 Mar 2009 15:00:25 +0000"  >&lt;blockquote&gt;
&lt;p&gt;PS: Obviously, refinements of the highlighting algo will help Lucy, too. I&lt;br/&gt;
don&apos;t suppose you want to continue this on the Lucy dev list so that Lucy&lt;br/&gt;
banks some community credit for this discussion. :\&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... remember that more discussions between you and I and Nathan on&lt;br/&gt;
Lucy-dev (as much as I love having them) don&apos;t really &quot;count&quot; as a&lt;br/&gt;
&quot;bigger&quot; community.  In other words, like the scoring of a&lt;br/&gt;
BooleanQuery, there is a very strong coord factor at play when&lt;br/&gt;
measuring &quot;community&quot;.  If you and I and nathan have fewer&lt;br/&gt;
conversations on Lucy-dev, but then two other new people join in, that&lt;br/&gt;
is a much stronger community.&lt;/p&gt;

&lt;p&gt;So, maybe send a note to lucy-dev, referencing this as a relevant&lt;br/&gt;
discussion to Lucy&apos;s approach to highlighting... and leave a&lt;br/&gt;
tantalizing invite here for others to make the jump to lucy-dev.&lt;br/&gt;
Growing a community is not easy!&lt;/p&gt;</comment>
                    <comment id="12682689" author="mikemccand" created="Tue, 17 Mar 2009 15:03:53 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Do you require term vectors to be stored, for highlighting (cannot&lt;br/&gt;
&amp;gt; re-analyze the text)?&lt;/p&gt;

&lt;p&gt;Yes, but that&apos;s not fundamental to the design. You just have to hand the&lt;br/&gt;
Weight some sort of single-doc index that includes sufficient data to&lt;br/&gt;
determine what parts of the text contributed to the hit and how much they&lt;br/&gt;
contributed. The Weight needn&apos;t care whether that single-doc index was&lt;br/&gt;
created on the fly or stored at index time.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; For queries that normally do not use positions at all (simple AND/OR&lt;br/&gt;
&amp;gt; of terms), how does your highlightSpans() work?&lt;/p&gt;

&lt;p&gt;ANDQuery, ORQuery, and RequiredOptionalQuery just return the union of the&lt;br/&gt;
spans produced by their children.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm &amp;#8211; it seems like that loses information.  Ie, for ANDQuery, you&lt;br/&gt;
lose the fact that you should try to include a match from each of the&lt;br/&gt;
sub-clauses&apos; spans.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; For BooleanQuery, is coord factor used to favor fragment sets that&lt;br/&gt;
&amp;gt; include more unique terms?&lt;/p&gt;

&lt;p&gt;No; I don&apos;t think that would be fine grained enough to help.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What I meant was: all other things being equal, do you more strongly&lt;br/&gt;
favor a fragment that has all N of the terms in a query vs another&lt;br/&gt;
fragment that has fewer than N but say higher net number of&lt;br/&gt;
occurrences.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There&apos;s a HeatMap class that performs additional weighting. Spans that&lt;br/&gt;
cluster together tightly (i.e. that could fit together within the excerpt) are&lt;br/&gt;
boosted.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds great.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Are you guaranteed to always present a net set of fragments that&lt;br/&gt;
&amp;gt; &quot;matches&quot; the query? (eg the example query above).&lt;/p&gt;

&lt;p&gt;No. The KS version supplies a single fragment. It naturally prefers&lt;br/&gt;
fragments with rarer terms, because the span scores are multiplied by the&lt;br/&gt;
Weight&apos;s weighting factor (which includes IDF).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm OK.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Once that fragment is selected, the KS highlighter worries a lot about&lt;br/&gt;
trimming to sensible sentence boundaries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I totally agree: easy/fast consumability is very important, so&lt;br/&gt;
choosing entire sentences, or at least anchoring the start or maybe&lt;br/&gt;
end on a sentence boundary, is important.  Lucene&apos;s H1 doesn&apos;t do this&lt;br/&gt;
ootb today I think (though you could plug in your own fragmenter).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In my own subjective judgment, supplying a single maximally coherent fragment&lt;br/&gt;
which prefers clusters of rare terms results in an excerpt which &quot;scans&quot; as&lt;br/&gt;
quickly as possible, conveying the gist of the content with minimal &quot;visual&lt;br/&gt;
effort&quot;. I used Google&apos;s excerpting as a model.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Google picks more than one fragment; it seems like it picks one or two&lt;br/&gt;
fragments.&lt;/p&gt;

&lt;p&gt;I&apos;m torn on whether IDF should really come into play though...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I think the base litmus test for a hightlighter is: if one were to&lt;br/&gt;
&amp;gt; take all fragments presented for a document (call this a &quot;fragdoc&quot;)&lt;br/&gt;
&amp;gt; and make a new document from it, would that document match the&lt;br/&gt;
&amp;gt; original query?&lt;/p&gt;

&lt;p&gt;With out the aid of formal studies to guide us, this is a subjective call.&lt;br/&gt;
FWIW, I disagree. In my view, visual scanning speed and coherence&lt;br/&gt;
are more important than completeness.&lt;/p&gt;

&lt;p&gt;I&apos;m not a big fan of the multi-fragment approach, because I think it takes too&lt;br/&gt;
much effort to grok each individual entry. Furthermore, the fact that the&lt;br/&gt;
fragments don&apos;t start on sentence boundaries (whenever feasible) adds to the&lt;br/&gt;
visual effort needed to orient yourself.&lt;/p&gt;

&lt;p&gt;Search results contain a lot of junk. The user needs to be able to parse the&lt;br/&gt;
results page as quickly as possible and refine their search query as needed.&lt;br/&gt;
Noisy excerpts, with lots of elipses and few sentences that can be &quot;swallowed&lt;br/&gt;
whole&quot; impede that. Trees vs. Forest.&lt;/p&gt;

&lt;p&gt;Again, that&apos;s my own aesthetic judgment, but I&apos;ll wager that there are studies&lt;br/&gt;
out there showing that fragments which start at the top of a sentence are&lt;br/&gt;
easier to consume, and I think that&apos;s important.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, it&apos;s not cut and dry here; this is all quite subjective.&lt;/p&gt;

&lt;p&gt;I think one case that&apos;s tricky is two terms that do not tend do&lt;br/&gt;
co-occur in proximity.  Eg search for python greenspan on Google, and&lt;br/&gt;
most of the fragdocs consist of two fragments, one for each term.  Ie&lt;br/&gt;
google is trying to include all the terms in the fragdoc (my &quot;coord&lt;br/&gt;
factor&quot; question above).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; In fact, I think the perfect highlighter would &quot;logically&quot; work as&lt;br/&gt;
&amp;gt; follows: take a single document and enumerate every single possible&lt;br/&gt;
&amp;gt; fragdoc.&lt;/p&gt;

&lt;p&gt;KS uses a sliding window rather than chunking up the text into fragdocs of&lt;br/&gt;
fixed length.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or, the allowed length of each fragment could span a specified min/max&lt;br/&gt;
range.&lt;/p&gt;

&lt;p&gt;And I like the sliding window approach instead of the pre-fragment&lt;br/&gt;
approach.&lt;/p&gt;

&lt;p&gt;(Note: a fragdoc is one or more fragments stuck together, ie, the&lt;br/&gt;
entire excerpt.)&lt;/p&gt;</comment>
                    <comment id="12682696" author="markrmiller@gmail.com" created="Tue, 17 Mar 2009 15:18:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;But, flattening could produce just a and d (I think?); and I think H1&lt;br/&gt;
could do the same even with SpanScorer (Mark is that true? I don&apos;t&lt;br/&gt;
fully understand the Query -&amp;gt; SpanQuery conversion). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right - SpanScorer won&apos;t follow boolean logic - it will just break down each clause and not highlight  a NOT - similar to standard H1. If a particular clause is position sensitive, it will only be &apos;lit if its found in a valid position, but thats as deep as it goes.&lt;/p&gt;
</comment>
                    <comment id="12682762" author="michaelbusch" created="Tue, 17 Mar 2009 19:08:40 +0000"  >&lt;p&gt;I wrote the highlighter for the OmniFind Yahoo Edition a few years ago&lt;br/&gt;
and I totally agree that all this stuff is very subjective.&lt;/p&gt;

&lt;p&gt;The OYE highlighter is of course based on Lucene and uses a sliding&lt;br/&gt;
window too. It also uses information about sentence boundaries and&lt;br/&gt;
prefers fragments that start at the beginning of a sentence.&lt;/p&gt;

&lt;p&gt;So it goes through the document and generates fragment candidates on&lt;br/&gt;
the fly. It calculates a score for each fragment and puts it into a&lt;br/&gt;
priority queue. The score is calculated using different heuristics:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fragments are boosted that start at the beginning of a sentence&lt;/li&gt;
	&lt;li&gt;the more highlighted terms a fragment contains, the higher is it&lt;br/&gt;
scored&lt;/li&gt;
	&lt;li&gt;more different highlighted terms scores higher than a lot of&lt;/li&gt;
	&lt;li&gt;occurrences of the same term&lt;/li&gt;
	&lt;li&gt;no tf-idf is used&lt;/li&gt;
	&lt;li&gt;if a fragment does not start at the beginning of a sentence, then it&lt;br/&gt;
is scored higher if the highlighted term(s) occur(s) more in the middle&lt;br/&gt;
of the fragment: e.g. &apos;a b c d e&apos; scores lower than &apos;b c a d e&apos; if &apos;a&apos;&lt;br/&gt;
is the highlighted term; this is being done to show as much context as &lt;br/&gt;
possible around a highlighted term&lt;/li&gt;
	&lt;li&gt;only a single long fragment is created if it contains all query terms&lt;br/&gt;
(like google)&lt;/li&gt;
	&lt;li&gt;The queue tries to gather fragments, so that the union of the fragments&lt;br/&gt;
contain as many different query terms as possible. So it might toss a&lt;br/&gt;
fragment in favor of one with a lower score, if it increases the&lt;br/&gt;
total number of different highlighted terms.&lt;/li&gt;
	&lt;li&gt;For performance reasons there is an early termination if the&lt;br/&gt;
fragments in the queue contain all query terms.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Initially this highlighter also imitated Lucene&apos;s behavior to find the&lt;br/&gt;
highlighted positions. Last year I changed it to use SpanQueries. With&lt;br/&gt;
our flexible query parser (which I introduced on java-dev recently) we&lt;br/&gt;
have two different QueryBuilders. One creates the &quot;normal&quot; query, that&lt;br/&gt;
is executed to find the matching docs. Then a different QueryBuilder&lt;br/&gt;
creates SpanQueries from the same query for the highlighter.&lt;/p&gt;

&lt;p&gt;The output of the highlighter is not formatted html, but rather an&lt;br/&gt;
object containing the unformatted text, together with offset&lt;br/&gt;
information for both fragments and highlights. These offset spans can&lt;br/&gt;
carry additional information, which can be used for multi-color&lt;br/&gt;
highlighting too. We then use an HTMLFormatter class to generate the&lt;br/&gt;
formatted text, also an XMLFormatter that keeps the offset information&lt;br/&gt;
separate from the actual text is possible (we&apos;re currently working on&lt;br/&gt;
such a XMLFormatter). This is useful for frontends written in e.g. Flex. &lt;/p&gt;

&lt;p&gt;The performance of our highlighter is good and so far we have been&lt;br/&gt;
pretty happy with the quality of the excerpts, but there is still much&lt;br/&gt;
room for improvements.&lt;/p&gt;

&lt;p&gt;I&apos;d be happy to help working on a new highlighter. I think this is a&lt;br/&gt;
very important component, and Lucene&apos;s core should have a very good&lt;br/&gt;
and flexible one.&lt;/p&gt;</comment>
                    <comment id="12682777" author="creamyg" created="Tue, 17 Mar 2009 20:04:45 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; ANDQuery, ORQuery, and RequiredOptionalQuery just return the union of the&lt;br/&gt;
&amp;gt;&amp;gt; spans produced by their children.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Hmm - it seems like that loses information.  Ie, for ANDQuery, you lose the &lt;br/&gt;
&amp;gt; fact that you should try to include a match from each of the sub-clauses&apos; spans.&lt;/p&gt;

&lt;p&gt;A good idea.  ANDQuery&apos;s highlightSpans() method could probably be improved by&lt;br/&gt;
post-processing the child spans to take this into account.  That way we&lt;br/&gt;
wouldn&apos;t have to gum up the main Highlighter code with a bunch of conditionals&lt;br/&gt;
which afford special treatment to certain query types.&lt;/p&gt;

&lt;p&gt;&amp;gt; What I meant was: all other things being equal, do you more strongly&lt;br/&gt;
&amp;gt; favor a fragment that has all N of the terms in a query vs another&lt;br/&gt;
&amp;gt; fragment that has fewer than N but say higher net number of occurrences.&lt;/p&gt;

&lt;p&gt;No, the diversity of the terms in a fragment isn&apos;t factored in.  The span &lt;br/&gt;
objects only tell the Highlighter that a particular range of characters &lt;br/&gt;
was important; they don&apos;t say why.&lt;/p&gt;

&lt;p&gt;However, note that IDF would prevent a bunch of hits on &quot;the&quot; from causing too&lt;br/&gt;
hot a hotspot in the heat map.  So you&apos;re likely to see fragments with high&lt;br/&gt;
discriminatory value.&lt;/p&gt;

&lt;p&gt;&amp;gt; Google picks more than one fragment; it seems like it picks one or two&lt;br/&gt;
&amp;gt; fragments.&lt;/p&gt;

&lt;p&gt;I probably overstated my opposition to supplying an excerpt containing more&lt;br/&gt;
than one fragment.  It seems OK to me to select more than one, so long as they&lt;br/&gt;
all scan easily, and so long as the excerpts don&apos;t get long enough to force&lt;br/&gt;
excessive scrolling and slow down the time it takes the user to scan the whole&lt;br/&gt;
results page.  &lt;/p&gt;

&lt;p&gt;What bothers me is that the excerpts don&apos;t scan easily right now.  I consider&lt;br/&gt;
that a much more important defect than the fact that the fragdoc doesn&apos;t hit &lt;br/&gt;
every term (which isn&apos;t even possible for large queries), and it seemed to me &lt;br/&gt;
that pursuing exhaustive term matching was likely to yield even more highly &lt;br/&gt;
fragmented, visually chaotic fragdocs.  &lt;/p&gt;</comment>
                    <comment id="12682985" author="mikemccand" created="Wed, 18 Mar 2009 10:55:29 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;&amp;gt;&amp;gt; ANDQuery, ORQuery, and RequiredOptionalQuery just return the union of the&lt;br/&gt;
&amp;gt;&amp;gt; spans produced by their children.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Hmm - it seems like that loses information. Ie, for ANDQuery, you lose the &lt;br/&gt;
&amp;gt; fact that you should try to include a match from each of the sub-clauses&apos; spans.&lt;/p&gt;

&lt;p&gt;A good idea. ANDQuery&apos;s highlightSpans() method could probably be improved by&lt;br/&gt;
post-processing the child spans to take this into account. That way we&lt;br/&gt;
wouldn&apos;t have to gum up the main Highlighter code with a bunch of conditionals&lt;br/&gt;
which afford special treatment to certain query types.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we may need a tree-structured result returned by the&lt;br/&gt;
Weight/Scorer, compactly representing the &quot;space&quot; of valid fragdocs&lt;br/&gt;
for this one doc.  And then somehow we walk that tree,&lt;br/&gt;
enumerating/scoring individual &quot;valid&quot; fragdocs that are created from&lt;br/&gt;
that tree.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; What I meant was: all other things being equal, do you more strongly&lt;br/&gt;
&amp;gt; favor a fragment that has all N of the terms in a query vs another&lt;br/&gt;
&amp;gt; fragment that has fewer than N but say higher net number of occurrences.&lt;/p&gt;

&lt;p&gt;No, the diversity of the terms in a fragment isn&apos;t factored in. The span &lt;br/&gt;
objects only tell the Highlighter that a particular range of characters &lt;br/&gt;
was important; they don&apos;t say why.&lt;/p&gt;

&lt;p&gt;However, note that IDF would prevent a bunch of hits on &quot;the&quot; from causing too&lt;br/&gt;
hot a hotspot in the heat map. So you&apos;re likely to see fragments with high&lt;br/&gt;
discriminatory value.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This still seems subjectively wrong to me.  If I search for &quot;president&lt;br/&gt;
bush&quot;, probably bush is the rarer term and so you would favor showing&lt;br/&gt;
me a single fragment that had bush occur twice, over a fragment that&lt;br/&gt;
had a single occurrence of president and bush?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Google picks more than one fragment; it seems like it picks one or two&lt;br/&gt;
&amp;gt; fragments.&lt;/p&gt;

&lt;p&gt;I probably overstated my opposition to supplying an excerpt containing more&lt;br/&gt;
than one fragment. It seems OK to me to select more than one, so long as they&lt;br/&gt;
all scan easily, and so long as the excerpts don&apos;t get long enough to force&lt;br/&gt;
excessive scrolling and slow down the time it takes the user to scan the whole&lt;br/&gt;
results page.&lt;/p&gt;

&lt;p&gt;What bothers me is that the excerpts don&apos;t scan easily right now. I consider&lt;br/&gt;
that a much more important defect than the fact that the fragdoc doesn&apos;t hit &lt;br/&gt;
every term (which isn&apos;t even possible for large queries), and it seemed to me &lt;br/&gt;
that pursuing exhaustive term matching was likely to yield even more highly &lt;br/&gt;
fragmented, visually chaotic fragdocs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which excerpts don&apos;t scan easily right now?  Google&apos;s, KS&apos;s, Lucene&apos;s&lt;br/&gt;
H1 or H2?&lt;/p&gt;

&lt;p&gt;I think with a tree structure representing the search space for all&lt;br/&gt;
fragdocs, we could then efficiently enumerate fradocs with an&lt;br/&gt;
appropriate scoring model (favoring sentence starts or surrounding&lt;br/&gt;
context, breadth of terms, etc.).  This way we can do a real search&lt;br/&gt;
(on all fragdocs) subject to the preference for&lt;br/&gt;
consumability/breadth.&lt;/p&gt;</comment>
                    <comment id="12682987" author="mikemccand" created="Wed, 18 Mar 2009 10:59:26 +0000"  >
&lt;p&gt;OK to sum up here with observations / wish list / ideas /&lt;br/&gt;
controversies / etc. for Lucene&apos;s future merged highlighter:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Fragmenter should aim for fast &quot;eye + brain scanning&lt;br/&gt;
    consumability&quot; (eg, try hard to start on sentence boundaries,&lt;br/&gt;
    include context)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Let&apos;s try for single source &amp;#8211; each Query/Weight/Scorer should be&lt;br/&gt;
    able to enumerate the set of term positions/spans that caused it&lt;br/&gt;
    to match a specific doc (like explain(), but provides&lt;br/&gt;
    positions/spans detailing the match).  Trying to &quot;reverse&lt;br/&gt;
    engineer&quot; the matching is brittle&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Sliding window is better than static &quot;top down&quot; fragmentation&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;To scale, we should make a simple IndexReader impl on top of term&lt;br/&gt;
    vectors, but still allow the &quot;re-index single doc on the fly&quot;&lt;br/&gt;
    option&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Favoring breadth (more unique terms instead of many occurences of&lt;br/&gt;
    certain terms) seems important, except for too-many-term queries&lt;br/&gt;
    where this gets unwieldy&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Prefer a single fragment if it scores well enough, but fall back&lt;br/&gt;
    to several, if necessary, to show &quot;breadth&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Produce structured output so non-HTML front ends (eg Flex) can&lt;br/&gt;
    render&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Try to include &quot;context around the hits&quot;, when possible (eg the&lt;br/&gt;
    &quot;favor middle of hte sentence&quot; that Michael described)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Maybe or maybe don&apos;t let IDF affect fragment scoring&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Performance is important &amp;#8211; use TermVectors if present, add early&lt;br/&gt;
    termination if you&apos;ve already found a good enough fragdoc, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Maybe a tree-based fragdoc enumeration / searching model; I think&lt;br/&gt;
    this&apos;d be even more efficient than sliding window, especially for&lt;br/&gt;
    large docs&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Multi-color, HeatMap default ootb HTML UIs are nice&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;s all very subjective and quite a good challenge!!&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In the meantime, it seems like we should commit this H2 and give users&lt;br/&gt;
the choice?  We can then iterate over time on our wish list....&lt;/p&gt;</comment>
                    <comment id="12683030" author="creamyg" created="Wed, 18 Mar 2009 14:26:08 +0000"  >&lt;p&gt;&amp;gt; I think we may need a tree-structured result returned by the&lt;br/&gt;
&amp;gt; Weight/Scorer, compactly representing the &quot;space&quot; of valid fragdocs&lt;br/&gt;
&amp;gt; for this one doc. And then somehow we walk that tree,&lt;br/&gt;
&amp;gt; enumerating/scoring individual &quot;valid&quot; fragdocs that are created from&lt;br/&gt;
&amp;gt; that tree.&lt;/p&gt;

&lt;p&gt;Something like that.  An array of span scores is too limited; a full fledged&lt;br/&gt;
class would do better.  Designing that class requires striking a balance&lt;br/&gt;
between what information we think is useful and what information Highlighter&lt;br/&gt;
can sanely reduce.  By proposing the tree structure, you&apos;re suggesting that &lt;br/&gt;
Highlighter will reverse engineer boolean matching; that sounds like a lot of &lt;br/&gt;
work to me.  &lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; However, note that IDF would prevent a bunch of hits on &quot;the&quot; from causing too&lt;br/&gt;
&amp;gt;&amp;gt; hot a hotspot in the heat map. So you&apos;re likely to see fragments with high&lt;br/&gt;
&amp;gt;&amp;gt; discriminatory value.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; This still seems subjectively wrong to me. If I search for &quot;president&lt;br/&gt;
&amp;gt; bush&quot;, probably bush is the rarer term and so you would favor showing&lt;br/&gt;
&amp;gt; me a single fragment that had bush occur twice, over a fragment that&lt;br/&gt;
&amp;gt; had a single occurrence of president and bush?&lt;/p&gt;

&lt;p&gt;We&apos;ve ended up in a false dichotomy.  Favoring high IDF terms &amp;#8211; or more&lt;br/&gt;
accurately, high scoring character position spans &amp;#8211; and favoring fragments &lt;br/&gt;
with high term diversity are not mutually exclusive.  &lt;/p&gt;

&lt;p&gt;Still, the KS highlighter probably wouldn&apos;t do what you describe.  The proximity&lt;br/&gt;
boosting accelerates as the spans approach each other, and maxes out if &lt;br/&gt;
they&apos;re adjacent.  So &quot;bush bush&quot; might be prefered over &quot;president bush&quot;, &lt;br/&gt;
but &quot;bush or bush&quot; proabably wouldn&apos;t.&lt;/p&gt;

&lt;p&gt;I don&apos;t think that there&apos;s anything wrong with preferring high term diversity;&lt;br/&gt;
the KS highlighter doesn&apos;t happen to support favoring fragments with high term&lt;br/&gt;
diversity now, but would be improved by adding that capability.  I just don&apos;t&lt;br/&gt;
think term diversity is so important that it qualifies as a &quot;base litmus&lt;br/&gt;
test&quot;.&lt;/p&gt;

&lt;p&gt;There are other ways of choosing good fragments, and IDF is one of them.  If&lt;br/&gt;
you want to show why a doc matched a query, it makes sense to show the section&lt;br/&gt;
of the document that contributed most to the score, surrounded by a little&lt;br/&gt;
context.  &lt;/p&gt;

&lt;p&gt;&amp;gt; Which excerpts don&apos;t scan easily right now? Google&apos;s, KS&apos;s, Lucene&apos;s&lt;br/&gt;
&amp;gt; H1 or H2?&lt;/p&gt;

&lt;p&gt;Lucene H1.  Too many elipses, and fragments don&apos;t prefer to start on sentence&lt;br/&gt;
boundaries.  &lt;/p&gt;

&lt;p&gt;I have to qualify the assertion that the fragments don&apos;t scan well with the caveat &lt;br/&gt;
that I&apos;m basing this on a personal impression.  However, I&apos;m pretty confident &lt;br/&gt;
about that impression.  I would be stunned if there were not studies out there&lt;br/&gt;
demonstrating that sentence fragments which begin at the top are easier to&lt;br/&gt;
consume than sentence fragments which begin in the middle.&lt;/p&gt;</comment>
                    <comment id="12683032" author="markrmiller@gmail.com" created="Wed, 18 Mar 2009 14:33:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;Lucene H1. Too many elipses, and fragments don&apos;t prefer to start on sentence boundaries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thats not necessarily a property of the Highlighter, just the basic implementations we currently supply for the pluggable classes. You can supply a custom fragmenter and you can control the number of fragments.&lt;/p&gt;</comment>
                    <comment id="12683053" author="mikemccand" created="Wed, 18 Mar 2009 15:50:01 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;Something like that. An array of span scores is too limited; a full fledged&lt;br/&gt;
class would do better. Designing that class requires striking a balance&lt;br/&gt;
between what information we think is useful and what information Highlighter&lt;br/&gt;
can sanely reduce.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, and I&apos;m not sure about the tree structure (just floating&lt;br/&gt;
ideas...).  It could very well be overkill.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By proposing the tree structure, you&apos;re suggesting that &lt;br/&gt;
Highlighter will reverse engineer boolean matching; that sounds like a lot of &lt;br/&gt;
work to me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It wouldn&apos;t be reverse engineered: BooleanQuery/Weight/Scorer2 itself&lt;br/&gt;
will have returned that.  Ie we would add a method to&lt;br/&gt;
&quot;getSpanTree()&quot;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Still, the KS highlighter probably wouldn&apos;t do what you describe.  The proximity&lt;br/&gt;
boosting accelerates as the spans approach each other, and maxes out if &lt;br/&gt;
they&apos;re adjacent.  So &quot;bush bush&quot; might be prefered over &quot;president bush&quot;, &lt;br/&gt;
but &quot;bush or bush&quot; proabably wouldn&apos;t.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, it sounds like one can simply use different models to score&lt;br/&gt;
fragdocs and it&apos;s still an open debate how much each of these criteria&lt;br/&gt;
(IDF, showing surround context, being on sentence boundary, diversity&lt;br/&gt;
of terms) should impact the score.  I agree, the &quot;basic litmus test&quot; I&lt;br/&gt;
proposed is too strong.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Lucene H1. Too many elipses, and fragments don&apos;t prefer to start on sentence boundaries.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thats not necessarily a property of the Highlighter, just the basic&lt;br/&gt;
implementations we currently supply for the pluggable classes. You can&lt;br/&gt;
supply a custom fragmenter and you can control the number of&lt;br/&gt;
fragments.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree: H1 is very pluggable and one could plug in a better&lt;br/&gt;
fragmenter, but we don&apos;t offer such an impl in H1, and this is a case&lt;br/&gt;
where &quot;out-of-the-box defaults&quot; are very important.&lt;/p&gt;</comment>
                    <comment id="12683064" author="creamyg" created="Wed, 18 Mar 2009 16:37:58 +0000"  >&lt;p&gt;&amp;gt; OK, it sounds like one can simply use different models to score&lt;br/&gt;
&amp;gt; fragdocs and it&apos;s still an open debate how much each of these criteria&lt;br/&gt;
&amp;gt; (IDF, showing surround context, being on sentence boundary, diversity&lt;br/&gt;
&amp;gt; of terms) should impact the score. &lt;/p&gt;

&lt;p&gt;With Michael Busch&apos;s priority queue approach, the algorithm for choosing the&lt;br/&gt;
fragments can be abstracted into the class of object we put in the queue and&lt;br/&gt;
its lessThan() method.  The output from the queue just has to be something the&lt;br/&gt;
Highlighter can chew.&lt;/p&gt;</comment>
                    <comment id="12683079" author="dkaelbling@blackducksoftware.com" created="Wed, 18 Mar 2009 17:03:53 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Our application wants to find and highlight all the hits in a document,&lt;br/&gt;
not just the best one(s).  If future highlighters still allowed this,&lt;br/&gt;
even if only by judicious use of subclasses, I would be happy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;	Thanks,&lt;br/&gt;
	David&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;br/&gt;
David Kaelbling&lt;br/&gt;
Senior Software Engineer&lt;br/&gt;
Black Duck Software, Inc.&lt;/p&gt;

&lt;p&gt;dkaelbling@blackducksoftware.com&lt;br/&gt;
T +1.781.810.2041&lt;br/&gt;
F +1.781.891.5145&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.blackducksoftware.com&quot; class=&quot;external-link&quot;&gt;http://www.blackducksoftware.com&lt;/a&gt;&lt;/p&gt;

</comment>
                    <comment id="12688408" author="mikemccand" created="Mon, 23 Mar 2009 20:46:39 +0000"  >&lt;p&gt;Randomly searching in Google I came across this:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://stackoverflow.com/questions/82151/is-there-a-fast-accurate-highlighter-for-lucene&quot; class=&quot;external-link&quot;&gt;http://stackoverflow.com/questions/82151/is-there-a-fast-accurate-highlighter-for-lucene&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;...which emphasizes how important it is that the highlighter only highlight &quot;matching&quot; fragdocs when possible.&lt;/p&gt;

&lt;p&gt;(Meaning, if you were to copy &amp;amp; paste the full excerpt you are looking at, index it as a document, would your current search match it).&lt;/p&gt;</comment>
                    <comment id="12688419" author="markrmiller@gmail.com" created="Mon, 23 Mar 2009 21:09:46 +0000"  >&lt;p&gt;I think you are reading more into that than I see - that guy is just frustrated that PhraseQueries don&apos;t highlight correctly. That was/is a common occurrence and you can find tons of examples. There are one or two JIRA highlighters that address it, and the their is the Span highlighter (more interestingly, there is a link to the birth of the Span highlighter idea on that page - thanks M. Harwood).&lt;/p&gt;

&lt;p&gt;When users see the PhraseQuery look right, I havn&apos;t seen any other repeated complaints really. While it would be nice to match boolean logic fully, I almost don&apos;t think its worth the effort. You likely have an interest in those terms anyway - its not a given that the terms that caused the match (non positional) matter. I have not seen a complaint on that one - mostly just positional type stuff. And I think we have positional solved fairly well with the current API - its just too darn slow. Not that I am against things being sweet and perfect, and getting exact matches, but there has been lots of talk in the past about integrating the highlighter into core and making things really fast and efficient - and generally it comes down to what work actually gets done (and all this stuff ends up at the hard end of the pool).&lt;/p&gt;

&lt;p&gt;When I wrote the SpanScorer, many times it was discussed how things should &lt;b&gt;really&lt;/b&gt; be done. Most methods involved working with core - but what has been there for a couple years now is the SpanScorer that plugs into the current highlighter API and nothing else has made any progress. Not really an argument, just kind of thinking out loud at this point...&lt;/p&gt;

&lt;p&gt;I&apos;m all for improving the speed and accuracy of the highlighter at the end of the day, but its a tall order considering how much attention the Highlighter has managed to receive in the past. Its large on ideas and low on sweat.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;edit&lt;/b&gt;&lt;br/&gt;
A lot of the sweat that is given has been fragmented by the 3 or 4 alternate highlighters.&lt;/p&gt;</comment>
                    <comment id="12688439" author="mikemccand" created="Mon, 23 Mar 2009 22:07:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think you are reading more into that than I see - that guy is just frustrated that PhraseQueries don&apos;t highlight correctly&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that&apos;s really quite a serious problem; it&apos;s the kind that&lt;br/&gt;
immediately erodes user&apos;s trust.  Though if this user had used&lt;br/&gt;
SpanScorer it would have been fixed (right?).&lt;/p&gt;

&lt;p&gt;Is there any reason not to use SpanScorer (vs QueryScorer)?&lt;/p&gt;

&lt;p&gt;The &quot;final inch&quot; (search UI) is exceptionally important!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When users see the PhraseQuery look right, I havn&apos;t seen any other repeated complaints really.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And I think we have positional solved fairly well with the current API - its just too darn slow.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... I&apos;d still like to explore some way to better integrate w/ core&lt;br/&gt;
(just don&apos;t have enough time, but maybe if I keep talking about it&lt;br/&gt;
here, someone else will get the itch + time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;I think an IndexReader impl around loaded TermVectors can get us OK&lt;br/&gt;
performance (no re-analysis nor linear scan of resynthesized&lt;br/&gt;
TokenStream).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Not that I am against things being sweet and perfect, and getting exact matches, but there has been lots of talk in the past about integrating the highlighter into core and making things really fast and efficient - and generally it comes down to what work actually gets done (and all this stuff ends up at the hard end of the pool).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well this is open source after all.  Things get &quot;naturally&lt;br/&gt;
prioritized&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A lot of the sweat that is given has been fragmented by the 3 or 4 alternate highlighters.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah also another common theme in open-source development, though it&apos;s&lt;br/&gt;
in good company: evolution and capitalism share the same &quot;flaw&quot;.&lt;/p&gt;</comment>
                    <comment id="12688448" author="markrmiller@gmail.com" created="Mon, 23 Mar 2009 22:43:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;But that&apos;s really quite a serious problem; it&apos;s the kind that&lt;br/&gt;
immediately erodes user&apos;s trust. Though if this user had used&lt;br/&gt;
SpanScorer it would have been fixed (right?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right - my point was more that it was a common complaint and has been solved in one way or another for a long time. Even back when that post occured, there was a JIRA highlighter that worked with phrase queries I think. There have been at least one or two besides the SpanScorer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is there any reason not to use SpanScorer (vs QueryScorer)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is slower when working with position sensitive clauses - because it actually does some work. For non position sensitive terms, its the same speed as the standard. Makes sense to me to always use it, but if you don&apos;t care and want every term highlighted, why pay the price I guess...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Well... I&apos;d still like to explore some way to better integrate w/ core&lt;br/&gt;
(just don&apos;t have enough time, but maybe if I keep talking about it&lt;br/&gt;
here, someone else will get the itch + time .&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right - don&apos;t get me wrong - I was just getting thoughts in my head down. These types of brain dumps you higher level guys do def leads to work getting done - the SpanScorer came directly from these types of discussions, and quite a bit later - the original discussion happened before my time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Well this is open source after all. Things get &quot;naturally&lt;br/&gt;
prioritized&quot;.&lt;/p&gt;

&lt;p&gt;    A lot of the sweat that is given has been fragmented by the 3 or 4 alternate highlighters.&lt;/p&gt;

&lt;p&gt;Yeah also another common theme in open-source development, though it&apos;s&lt;br/&gt;
in good company: evolution and capitalism share the same &quot;flaw&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right. I suppose I was just suggesting that something more practical might make more sense (more musing than suggesting). And practical in terms of how much activity we have seen in the highlighter area (fairly low, and not usually to the extent needed to get something committed and in use).&lt;/p&gt;

&lt;p&gt;And the split work on the highlighters is fine - but if we had the right highlighter base, more work could have been concentrated on the highlighter thats most used. Not really a complaint, but idea for the future. If we can get something better going, perhaps we can get to the point were people work with the current implementation rather than creating a new one every time.&lt;/p&gt;</comment>
                    <comment id="12688451" author="michaelbusch" created="Mon, 23 Mar 2009 22:52:20 +0000"  >&lt;blockquote&gt;
&lt;p&gt;(Meaning, if you were to copy &amp;amp; paste the full excerpt you are looking at, index it as a document, would your current search match it).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is an unrealistic requirement in some cases (e.g. AND queries). I agree it makes sense for phrases to show them entirely in a fragment (even if that means not to show the beginning of a sentence). But often you have only one or two lines of text to display an extract. Then it might be a better choice to show two decently sized fragments with some context around the highlighted terms, rather than showing e.g. 4 short fragments just to show all 4 highlighted query terms (e.g. for query &apos;+a +b +c +d&apos;)&lt;/p&gt;
</comment>
                    <comment id="12688454" author="mikemccand" created="Mon, 23 Mar 2009 23:09:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think this is an unrealistic requirement in some cases (e.g. AND queries).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.&lt;/p&gt;</comment>
                    <comment id="12724943" author="koji" created="Sun, 28 Jun 2009 12:18:50 +0100"  >&lt;p&gt;Added more comment and index time synonym support and its test cases.&lt;/p&gt;</comment>
                    <comment id="12725705" author="koji" created="Tue, 30 Jun 2009 18:08:43 +0100"  >&lt;p&gt;I added package.html to explain the algorithm of H2. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12727728" author="mikemccand" created="Mon, 6 Jul 2009 20:44:44 +0100"  >&lt;p&gt;Is it possible to decouple this issue from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt; (whose latest patch is quite old and no longer applies and may not make it into 2.9)?  Ie, is it only the unit tests that rely on this fix to pass (because they test multi-valued fields)?&lt;/p&gt;</comment>
                    <comment id="12727868" author="koji" created="Tue, 7 Jul 2009 02:41:46 +0100"  >&lt;p&gt;Thank you for your advice, Michael.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;because they test multi-valued fields&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right.&lt;/p&gt;

&lt;p&gt;I commentted out the part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt; dependencies, ie, test cases for multi valued:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/*
 * ----------------------------------
 *  THIS TEST DEPENDS ON LUCENE-1448
 *  UNCOMMENT WHEN IT IS COMMITTED.
 * ----------------------------------
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testXXXXXXXMVB() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
      :
  }
*/
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All tests pass without &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12728288" author="mikemccand" created="Tue, 7 Jul 2009 19:47:03 +0100"  >&lt;p&gt;Patch looks good, thanks Koji!  All tests now pass for me.&lt;/p&gt;

&lt;p&gt;I attached a new patch, that updates the website w/ references to highlighter2.  I plan to commit in a day or two.&lt;/p&gt;</comment>
                    <comment id="12728304" author="thetaphi" created="Tue, 7 Jul 2009 20:14:40 +0100"  >&lt;p&gt;Mike: As I have done these type of site updates many times because of TrieRange:&lt;/p&gt;

&lt;p&gt;You should add highligther2 also to the source dirs and the package prefixes for the combined all-javadocs in the main build.xml. And as far as I know, also the main site docs also reference the contribs in developer-resources.xml.&lt;/p&gt;

&lt;p&gt;Everything else looks good!&lt;/p&gt;</comment>
                    <comment id="12728316" author="mikemccand" created="Tue, 7 Jul 2009 20:32:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;You should add highligther2 also to the source dirs and the package prefixes for the combined all-javadocs in the main build.xml.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh right.  I&apos;ll fix that!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the main site docs also reference the contribs in developer-resources.xml.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa OK I&apos;ll update that as well!  Thanks for the pointers &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12728354" author="markrmiller@gmail.com" created="Tue, 7 Jul 2009 21:35:16 +0100"  >&lt;p&gt;Hmmm... is it still Highlighter2?&lt;/p&gt;

&lt;p&gt;Can we come up with a better name that kind of gives a feel for the difference between this and the other highlighter?&lt;/p&gt;

&lt;p&gt;FastVectorHighlighter?&lt;/p&gt;

&lt;p&gt;Well - maybe that will triger a better idea from someone else anyway ... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12728454" author="koji" created="Wed, 8 Jul 2009 02:07:30 +0100"  >&lt;blockquote&gt;&lt;p&gt;FastVectorHighlighter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 from me. I&apos;ll attach a renamed version of the patch tomorrow, since I have to be out soon and back late tonight.&lt;/p&gt;</comment>
                    <comment id="12729218" author="koji" created="Thu, 9 Jul 2009 13:01:33 +0100"  >&lt;p&gt;renamed Highlighter2 to FastVectorHighlighter &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12729250" author="mikemccand" created="Thu, 9 Jul 2009 14:05:51 +0100"  >&lt;p&gt;Patch looks good Koji!  I will commit shortly.  Thanks for persisting here &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12729251" author="mikemccand" created="Thu, 9 Jul 2009 14:07:10 +0100"  >&lt;p&gt;Thanks Koji!&lt;/p&gt;</comment>
                    <comment id="12737985" author="koji" created="Sun, 2 Aug 2009 05:14:38 +0100"  >&lt;p&gt;Now &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1448&quot; title=&quot;add getFinalOffset() to TokenStream&quot;&gt;&lt;del&gt;LUCENE-1448&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1759&quot; title=&quot;Implement TokenStream.end() in contrib TokenStreams&quot;&gt;&lt;del&gt;LUCENE-1759&lt;/del&gt;&lt;/a&gt; has been committed, these tests should be uncommentted. All tests pass.&lt;/p&gt;</comment>
                    <comment id="12738106" author="mikemccand" created="Sun, 2 Aug 2009 19:00:33 +0100"  >&lt;p&gt;Thanks Koji, I&apos;ll commit this (turning on the tests).  Always nice to add more tests!&lt;/p&gt;</comment>
                    <comment id="12743800" author="koji" created="Sun, 16 Aug 2009 04:02:48 +0100"  >&lt;p&gt;There is a bug in BaseFragmentsBuilder. When the highlighting field is not stored, StringIndexOutOfBoundException will be thrown. I&apos;d like to reopen this issue so the fix can be included in 2.9. I&apos;ll post the fix soon.&lt;/p&gt;</comment>
                    <comment id="12743801" author="koji" created="Sun, 16 Aug 2009 04:04:34 +0100"  >&lt;p&gt;The patch includes the fix and a test case.&lt;/p&gt;</comment>
                    <comment id="12743915" author="markrmiller@gmail.com" created="Sun, 16 Aug 2009 22:57:46 +0100"  >&lt;p&gt;Thanks Koji!&lt;/p&gt;

&lt;p&gt;r804786&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12429941">SOLR-1268</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12408226">LUCENE-1448</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12400770" name="colored-tag-sample.png" size="28217" author="koji" created="Mon, 23 Feb 2009 17:06:23 +0000" />
                    <attachment id="12416688" name="LUCENE-1522-fix-SIOOBE.patch" size="3458" author="koji" created="Sun, 16 Aug 2009 04:04:34 +0100" />
                    <attachment id="12415259" name="LUCENE-1522-multiValued-test.patch" size="5070" author="koji" created="Sun, 2 Aug 2009 05:14:38 +0100" />
                    <attachment id="12413004" name="LUCENE-1522.patch" size="206431" author="koji" created="Thu, 9 Jul 2009 13:01:32 +0100" />
                    <attachment id="12412773" name="LUCENE-1522.patch" size="202151" author="mikemccand" created="Tue, 7 Jul 2009 19:47:03 +0100" />
                    <attachment id="12412685" name="LUCENE-1522.patch" size="155380" author="koji" created="Tue, 7 Jul 2009 02:41:46 +0100" />
                    <attachment id="12412184" name="LUCENE-1522.patch" size="154752" author="koji" created="Tue, 30 Jun 2009 18:08:43 +0100" />
                    <attachment id="12412014" name="LUCENE-1522.patch" size="149465" author="koji" created="Sun, 28 Jun 2009 12:18:50 +0100" />
                    <attachment id="12400769" name="LUCENE-1522.patch" size="126177" author="koji" created="Mon, 23 Feb 2009 17:05:04 +0000" />
                    <attachment id="12398235" name="LUCENE-1522.patch" size="124163" author="koji" created="Mon, 19 Jan 2009 14:50:43 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>10.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 12 Mar 2009 10:28:31 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12231</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26206</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>