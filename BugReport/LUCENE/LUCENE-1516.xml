<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:22:22 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1516/LUCENE-1516.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1516] Integrate IndexReader with IndexWriter </title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1516</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The current problem is an IndexReader and IndexWriter cannot be open&lt;br/&gt;
at the same time and perform updates as they both require a write&lt;br/&gt;
lock to the index. While methods such as IW.deleteDocuments enables&lt;br/&gt;
deleting from IW, methods such as IR.deleteDocument(int doc) and&lt;br/&gt;
norms updating are not available from IW. This limits the&lt;br/&gt;
capabilities of performing updates to the index dynamically or in&lt;br/&gt;
realtime without closing the IW and opening an IR, deleting or&lt;br/&gt;
updating norms, flushing, then opening the IW again, a process which&lt;br/&gt;
can be detrimental to realtime updates. &lt;/p&gt;

&lt;p&gt;This patch will expose an IndexWriter.getReader method that returns&lt;br/&gt;
the currently flushed state of the index as a class that implements&lt;br/&gt;
IndexReader. The new IR implementation will differ from existing IR&lt;br/&gt;
implementations such as MultiSegmentReader in that flushing will&lt;br/&gt;
synchronize updates with IW in part by sharing the write lock. All&lt;br/&gt;
methods of IR will be usable including reopen and clone. &lt;/p&gt;</description>
                <environment></environment>
            <key id="12412095">LUCENE-1516</key>
            <summary>Integrate IndexReader with IndexWriter </summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="jasonrutherglen">Jason Rutherglen</reporter>
                        <labels>
                    </labels>
                <created>Sat, 10 Jan 2009 01:00:00 +0000</created>
                <updated>Fri, 25 Sep 2009 17:23:16 +0100</updated>
                    <resolved>Thu, 9 Apr 2009 18:18:13 +0100</resolved>
                            <version>2.4</version>
                                <fixVersion>2.9</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                          <timeoriginalestimate seconds="2419200">672h</timeoriginalestimate>
                    <timeestimate seconds="2419200">672h</timeestimate>
                                  <comments>
                    <comment id="12662603" author="jasonrutherglen" created="Sat, 10 Jan 2009 02:06:46 +0000"  >&lt;p&gt;It looks like DirectoryIndexReader needs to have an IndexWriter mode&lt;br/&gt;
as unfortunately subclassing won&apos;t work. In this context overriding a&lt;br/&gt;
method implies the IW mode is being used.&lt;/p&gt;

&lt;p&gt;I assume we&apos;ll share the segmentInfos object from IW rather than&lt;br/&gt;
share a clone with the IR?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;DirectoryIndexReader.doCommit needs to be overridden&lt;/li&gt;
	&lt;li&gt;IndexReader uses the IndexDeletionPolicy from IndexWriter&lt;/li&gt;
	&lt;li&gt;DirectoryIndexReader.acquireWriteLock is overridden and synchronizes&lt;br/&gt;
  on the write lock of IndexWriter, other details need to be worked out&lt;/li&gt;
	&lt;li&gt;Method requiring synchronization in IW: optimize, expungeDeletes,&lt;br/&gt;
  prepareCommit, flush, addIndexes, methods that modify segmentInfos.&lt;br/&gt;
  Do we synchronize on IW or writeLock? &lt;/li&gt;
	&lt;li&gt;addDocument, updateDocument, deleteDocument do not seem to require&lt;br/&gt;
  synchronization &lt;/li&gt;
	&lt;li&gt;IW.getReader returns a cloned reader. IW keeps it&apos;s own reference.&lt;br/&gt;
  This is to allow IW to perform deletes using the internal reader rather than &lt;br/&gt;
  open a new reader and in general not affect IW&apos;s reader while still sharing&lt;br/&gt;
  resources.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12662800" author="gsingers" created="Sun, 11 Jan 2009 17:41:25 +0000"  >&lt;p&gt;It still seems to me that we should think about what objects need to be shared and how they can be produced/instantiated appropriately instead of adding a Reader onto the Writer, which, IMO, pollutes the Writer API.  I know it complicates things, but I think it will be less confusing to users of the API.&lt;/p&gt;</comment>
                    <comment id="12663933" author="jasonrutherglen" created="Wed, 14 Jan 2009 23:50:13 +0000"  >&lt;p&gt;Patch includes the latest patch from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt; and is unfortunately&lt;br/&gt;
not readable. Is there a way to create a patch minus another patch?&lt;/p&gt;

&lt;p&gt;The IW internal reader is always the results of the latest external&lt;br/&gt;
IR.reopen. In this way deletes made in IW and from the external IR&lt;br/&gt;
remain in sync. The latest IR always has the write lock anyways&lt;br/&gt;
according to IR.clone semantics. &lt;/p&gt;

&lt;p&gt;DocumentsWriter.applyDeletes reuses the reader in IW rather than call&lt;br/&gt;
SegmentReader.get/.deleteDocument&lt;/p&gt;

&lt;p&gt;In IW.doFlush the internal reader is reopened with the new&lt;br/&gt;
segmentinfos&lt;/p&gt;

&lt;p&gt;Included a very basic test case &lt;/p&gt;</comment>
                    <comment id="12672096" author="jasonrutherglen" created="Tue, 10 Feb 2009 01:09:07 +0000"  >&lt;p&gt;This is an extremely early patch and has a bunch of System.outs for debugging&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TestIndexWriterReader.testMerge tries to use IW.addIndexes and fails&lt;br/&gt;
because the lookup of the SegmentReader from the IW internal IR&lt;br/&gt;
returns the incorrect reader (I spent a lot of time on trying to&lt;br/&gt;
figure out why and could not). &lt;/li&gt;
	&lt;li&gt;TestIndexWriterReader.testReader passes&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12674295" author="jasonrutherglen" created="Tue, 17 Feb 2009 18:43:56 +0000"  >&lt;p&gt;Some terminology for this patch, an internal reader is the&lt;br/&gt;
IndexWriter&apos;s reader. An external reader given via the&lt;br/&gt;
IW.reopenReader method. &lt;/p&gt;

&lt;p&gt;If DirectoryIndexReader has a writer, no lock is acquired on updates.&lt;br/&gt;
IR.clone normally passes the writeLock to the new reader, however the&lt;br/&gt;
external IR and the IW internal IR both need to hold the write lock.&lt;br/&gt;
For this reason the user must be careful when flushing to insure the&lt;br/&gt;
proper instance of the IR&apos;s deletes are merged with the writer. &lt;/p&gt;

&lt;p&gt;The external IR.flush does not flush the deletes to disk, instead it&lt;br/&gt;
merges with the IW&apos;s internal IR which is in RAM. IW.flush causes&lt;br/&gt;
deletes and new segments to be flushed to the directory.&lt;/p&gt;

&lt;p&gt;The test cases from TestIndexWriterReader testIndexWriterDeletes and&lt;br/&gt;
testIndexWriterReopenSegment fail when the IW is opened again after&lt;br/&gt;
commit and close. The index files are being deleted during IW.commit.&lt;br/&gt;
I traced this to IW.finishCommit -&amp;gt; deleter.checkpoint -&amp;gt;&lt;br/&gt;
deleter.deletePendingFiles. &lt;/p&gt;


</comment>
                    <comment id="12674411" author="jasonrutherglen" created="Wed, 18 Feb 2009 00:34:03 +0000"  >&lt;p&gt;Added TestIndexWriterReader.testIndexWriterDeletes,&lt;br/&gt;
testIndexWriterDeletesOptimize, testIndexWriterReopenSegment,&lt;br/&gt;
testIndexWriterReopenSegmentOptimize. Where the optimize methods&lt;br/&gt;
fail, the non optimize ones work. The optimize methods delete _0.fdt&lt;br/&gt;
and _0.fdx and so fail when the writer is created again because it&lt;br/&gt;
cannot find those files. It could be a segment infos merging problem&lt;br/&gt;
or something else.&lt;/p&gt;</comment>
                    <comment id="12674415" author="jasonrutherglen" created="Wed, 18 Feb 2009 01:03:50 +0000"  >&lt;p&gt;The previously mentioned issue in the test case is fixed. Perhaps&lt;br/&gt;
IW.reopenInternalReader() should be called in IW.checkpoint? &lt;/p&gt;</comment>
                    <comment id="12674662" author="mikemccand" created="Wed, 18 Feb 2009 15:44:40 +0000"  >
&lt;p&gt;Looks good, Jason.  This is big change, and I expect to go through a&lt;br/&gt;
number of iterations before settling... plus we still need to figure&lt;br/&gt;
out how the API is exposed.  Comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;All this logic needs to be conditional (this also depends on what&lt;br/&gt;
    API we actually settle on to expose this...): right now you always&lt;br/&gt;
    open a reader whenever IW is created.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We should assume we do not need to support autoCommit=true in this&lt;br/&gt;
    patch (since this will land after 3.0).  This simplifies things.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;IW.reopenInternalReader only does a clone not a reopen; how does&lt;br/&gt;
    it cover the newly flushed segment?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;After a merge commits you don&apos;t seem to reopen the reader?  This&lt;br/&gt;
    is actually tricky to do right, for realtime search: we somehow&lt;br/&gt;
    need to allow for warming of the newly created (merged) segment,&lt;br/&gt;
    in such a way that we do not block the flushing of further&lt;br/&gt;
    segments and reopen of readers against those new segments.  I&lt;br/&gt;
    think what may be best is to subclass IW, and override a newly&lt;br/&gt;
    added &quot;postMerge&quot; method that&apos;s invoked on the new segment before&lt;br/&gt;
    the merge is committed into the SegmentInfos.  This is cleaner&lt;br/&gt;
    than allowing the change into the SegmentInfos and then having to&lt;br/&gt;
    make a custom deletion policy &amp;amp; track history of each segment.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It seems like reader.reopen() (where reader was obtained with&lt;br/&gt;
    IW.getReader()) doesn&apos;t do the right thing?  (ie it&apos;s looking for&lt;br/&gt;
    the most recent segments_N in the Directory, but it should be&lt;br/&gt;
    looking for it @ IW.segmentInfos).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think we should decouple &quot;materializing deletes down to docIDs&quot;&lt;br/&gt;
    from &quot;flushing deletes to disk&quot;.  IW does both as the same&lt;br/&gt;
    operation now (because it doesn&apos;t want to hold SR open for a long&lt;br/&gt;
    time), but once we have persistent open SegmentReaders we should&lt;br/&gt;
    separate these.  It&apos;s not necessary for IW to write new .del files&lt;br/&gt;
    when it materializes deletes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Instead of having to merge readers, I think we should have a&lt;br/&gt;
    single source to obtain an SR from.  This way, when IW needs to&lt;br/&gt;
    materialize deletes, it will grab the same instance of SR for a&lt;br/&gt;
    given segment that the currently open MSR is using.  Also, when&lt;br/&gt;
    merging kicks off, it&apos;ll grab the SR from the same source (this&lt;br/&gt;
    way deletes in RAM will be correctly merged away).  Also, I think&lt;br/&gt;
    we should not use MSR for doing deletions (and still go segment by&lt;br/&gt;
    segment): it&apos;s quite a bit slower since every invocation must do&lt;br/&gt;
    the binary search again.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Likewise, you have to fix the commitMergedDeletes to decouple&lt;br/&gt;
    computing the new BitVector from writing the .del file to disk.&lt;br/&gt;
    That method should only create a new BitVector, for the newly&lt;br/&gt;
    merged segment.  It must be synchronized to prevent any new&lt;br/&gt;
    deletions against the segments that were just merged.  In fact,&lt;br/&gt;
    this is a real danger: after a merge finishes, if one continues to&lt;br/&gt;
    use an older reader to do deletions you get into trouble.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I still don&apos;t really like having both the IR and IW able to do&lt;br/&gt;
    deletions, with slightly different semantics.  As it stands now,&lt;br/&gt;
    since you can&apos;t predict when IW materializes deletes, your reader&lt;br/&gt;
    will suddenly see a bunch of deletes appear.  I think it&apos;s better&lt;br/&gt;
    if no deletes appear, ever, until you reopen your reader.  Maybe&lt;br/&gt;
    we simply prevent deletion through the IR?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We need some serious unit tests here!&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12675069" author="jasonrutherglen" created="Thu, 19 Feb 2009 18:14:12 +0000"  >&lt;p&gt;Mike, good points... &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; since you can&apos;t predict when IW materializes deletes, your reader&lt;br/&gt;
will suddenly see a bunch of deletes appear.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The reader would need to be reopened to see the deletes. Isn&apos;t that&lt;br/&gt;
expected behavior?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; Instead of having to merge readers, I think we need a single&lt;br/&gt;
source to obtain an SR from &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this however how would IR.clone work? I like having the&lt;br/&gt;
internal reader separate from the external reader. The main reason to&lt;br/&gt;
expose IR from IW is to allow delete by doc id and norms updates&lt;br/&gt;
(eventually column stride fields updates). I don&apos;t see how we can&lt;br/&gt;
grab a reader during a merge, and block realtime deletes occurring on&lt;br/&gt;
the external reader. However it is difficult to rectify deletes to an&lt;br/&gt;
external SR that&apos;s been merged away. &lt;/p&gt;

&lt;p&gt;It seems like we&apos;re getting closer to using a unique long UID for&lt;br/&gt;
each doc that is carried over between merges. I was going to&lt;br/&gt;
implement this above &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; however we may want to make UIDs a&lt;br/&gt;
part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; to implement the behavior we&apos;re discussing. &lt;/p&gt;

&lt;p&gt;If the updates to SR are queued, then it seems like the only way to&lt;br/&gt;
achieve this is a doc UID. This way merges can happen in the&lt;br/&gt;
background, the IR has a mechanism for mapping it&apos;s queue to the&lt;br/&gt;
newly merged segments when flushed. Hopefully we aren&apos;t wreaking&lt;br/&gt;
havoc with the IndexReader API?&lt;/p&gt;

&lt;p&gt;The scenario I think we&apos;re missing is if there&apos;s multiple cloned SRs&lt;br/&gt;
out there. With the IW checkout an SR model how do we allow cloning?&lt;br/&gt;
A clone&apos;s updates will be placed into a central original SR queue?&lt;br/&gt;
The queue is drained automatically on a merge or IW.flush? What&lt;br/&gt;
happens when we want the IR deletes to be searchable without flushing&lt;br/&gt;
to disk? Do a reopen/clone? &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;number of iterations before settling&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, if it were simple it wouldn&apos;t be fun. &#9786;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; It&apos;s not necessary for IW to write new .del files when it&lt;br/&gt;
materializes deletes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point, DocumentsWriter.applyDeletes shouldn&apos;t be flushing to&lt;br/&gt;
disk and this sounds like a test case to add to TestIndexWriterReader.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; IW.reopenInternalReader only does a clone not a reopen; however&lt;br/&gt;
does it cover the newly flushed segment? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The segmentinfos is obtained from the Writer. In the test case&lt;br/&gt;
testIndexWriterReopenSegment it looks like using clone reopens the&lt;br/&gt;
new segments.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; I think it&apos;s better if no deletes appear, ever, until you reopen&lt;br/&gt;
your reader. Maybe we simply prevent deletion through the IR? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Preventing deletion through the IR would seem to defeat the purpose&lt;br/&gt;
of the patch unless there&apos;s some alternative mechanism for deleting&lt;br/&gt;
by doc id? &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; commitMergedDeletes to decouple computing the new BitVector from&lt;br/&gt;
writing the .del file to disk.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A hidden method I never noticed. I&apos;ll keep it in mind.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; It seems like reader.reopen() (where reader was obtained with&lt;br/&gt;
IW.getReader()) doesn&apos;t do the right thing? (ie it&apos;s looking for the&lt;br/&gt;
most recent segments_N in the Directory, but it should be looking for&lt;br/&gt;
it @ IW.segmentInfos).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Using the reopen method implementation for a Reader with IW does not&lt;br/&gt;
seem necessary. It seems like it could call clone underneath?&lt;/p&gt;
</comment>
                    <comment id="12675177" author="mikemccand" created="Thu, 19 Feb 2009 23:26:03 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; since you can&apos;t predict when IW materializes deletes, your reader&lt;br/&gt;
&amp;gt; will suddenly see a bunch of deletes appear.&lt;/p&gt;

&lt;p&gt;The reader would need to be reopened to see the deletes. Isn&apos;t that&lt;br/&gt;
expected behavior?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh right, so long as we keep internal (private) clone, materializing&lt;br/&gt;
the deletes won&apos;t affect the external reader.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Instead of having to merge readers, I think we need a single&lt;br/&gt;
&amp;gt; source to obtain an SR from &lt;/p&gt;

&lt;p&gt;I like this however how would IR.clone work?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It should work fine?  The single source would only be used internally&lt;br/&gt;
by IW (for merging, for materializing deletes, for the internal&lt;br/&gt;
reader).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I like having the internal reader separate from the external reader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should keep that separation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The main reason to&lt;br/&gt;
expose IR from IW is to allow delete by doc id and norms updates&lt;br/&gt;
(eventually column stride fields updates). I don&apos;t see how we can&lt;br/&gt;
grab a reader during a merge, and block realtime deletes occurring on&lt;br/&gt;
the external reader. However it is difficult to rectify deletes to an&lt;br/&gt;
external SR that&apos;s been merged away.&lt;/p&gt;

&lt;p&gt;It seems like we&apos;re getting closer to using a unique long UID for&lt;br/&gt;
each doc that is carried over between merges. I was going to&lt;br/&gt;
implement this above &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; however we may want to make UIDs a&lt;br/&gt;
part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; to implement the behavior we&apos;re discussing.&lt;/p&gt;

&lt;p&gt;If the updates to SR are queued, then it seems like the only way to&lt;br/&gt;
achieve this is a doc UID. This way merges can happen in the&lt;br/&gt;
background, the IR has a mechanism for mapping it&apos;s queue to the&lt;br/&gt;
newly merged segments when flushed. Hopefully we aren&apos;t wreaking&lt;br/&gt;
havoc with the IndexReader API?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But... do we need delete by docID once we have realtime search?  I&lt;br/&gt;
think the last compelling reason to keep IR&apos;s delete by docID was&lt;br/&gt;
immediacy, but realtime search can give us that, from IW, even when&lt;br/&gt;
deleting by Term or Query?&lt;/p&gt;

&lt;p&gt;(Your app can always add that long UID if it doesn&apos;t already have&lt;br/&gt;
something usable).&lt;/p&gt;

&lt;p&gt;docIDs are free to changing inside IW.  I don&apos;t see how we can hand&lt;br/&gt;
out a reader, allow deletes by docID to it, and merge those deletes&lt;br/&gt;
back in at a later time, unless we track the genealogy of the&lt;br/&gt;
segments?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The scenario I think we&apos;re missing is if there&apos;s multiple cloned SRs&lt;br/&gt;
out there. With the IW checkout an SR model how do we allow cloning?&lt;br/&gt;
A clone&apos;s updates will be placed into a central original SR queue?&lt;br/&gt;
The queue is drained automatically on a merge or IW.flush? What&lt;br/&gt;
happens when we want the IR deletes to be searchable without flushing&lt;br/&gt;
to disk? Do a reopen/clone?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is why I think all changes must be done through IW if you&apos;ve&lt;br/&gt;
opened a reader from it.  In fact, with the addition of realtime&lt;br/&gt;
search to Lucene, if we also add updating norms/column-stride fields&lt;br/&gt;
to IW, can&apos;t we move away from allowing any changes via IR?  (Ie&lt;br/&gt;
deprecate deleteDocuments/setNorms/etc.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; It&apos;s not necessary for IW to write new .del files when it&lt;br/&gt;
&amp;gt; materializes deletes.&lt;/p&gt;

&lt;p&gt;Good point, DocumentsWriter.applyDeletes shouldn&apos;t be flushing to&lt;br/&gt;
disk and this sounds like a test case to add to TestIndexWriterReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, if IW has no persistent reader to hold the deletes, it must keep&lt;br/&gt;
doing what it does now (flush immediately to disk)?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; IW.reopenInternalReader only does a clone not a reopen; however&lt;br/&gt;
&amp;gt; does it cover the newly flushed segment? &lt;/p&gt;

&lt;p&gt;The segmentinfos is obtained from the Writer. In the test case&lt;br/&gt;
testIndexWriterReopenSegment it looks like using clone reopens the&lt;br/&gt;
new segments.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Wait, where is this test?  Maybe you need to svn add it?&lt;/p&gt;

&lt;p&gt;And, clone should not be reopening segments...?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I think it&apos;s better if no deletes appear, ever, until you reopen&lt;br/&gt;
&amp;gt; your reader. Maybe we simply prevent deletion through the IR? &lt;/p&gt;

&lt;p&gt;Preventing deletion through the IR would seem to defeat the purpose&lt;br/&gt;
of the patch unless there&apos;s some alternative mechanism for deleting&lt;br/&gt;
by doc id?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;See above.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; commitMergedDeletes to decouple computing the new BitVector from&lt;br/&gt;
&amp;gt; writing the .del file to disk.&lt;/p&gt;

&lt;p&gt;A hidden method I never noticed. I&apos;ll keep it in mind.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s actually very important.  This is how IW allows deletes to&lt;br/&gt;
materialize to docIDs, while a merge is running &amp;#8211; any newly&lt;br/&gt;
materialized deletes against the just-merged segments are coalesced&lt;br/&gt;
and carried over to the newly created segment.  Any further deletes&lt;br/&gt;
must be done against the docIDs in the new segment (which is why I&lt;br/&gt;
don&apos;t see how we can allow deletes by docID to happen against a&lt;br/&gt;
checked out reader).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; It seems like reader.reopen() (where reader was obtained with&lt;br/&gt;
&amp;gt; IW.getReader()) doesn&apos;t do the right thing? (ie it&apos;s looking for the&lt;br/&gt;
&amp;gt; most recent segments_N in the Directory, but it should be looking for&lt;br/&gt;
&amp;gt; it @ IW.segmentInfos).&lt;/p&gt;

&lt;p&gt;Using the reopen method implementation for a Reader with IW does not&lt;br/&gt;
seem necessary. It seems like it could call clone underneath?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, clone should be very different from reopen.  It seems like&lt;br/&gt;
calling reader.reopen() (on reader obtained from writer) should&lt;br/&gt;
basically do the same thing as calling writer.getReader().  Ie they&lt;br/&gt;
are nearly synonyms?  (Except for small difference in ref counting &amp;#8211;&lt;br/&gt;
I think writer.getReader() should always incRef, but reopen only&lt;br/&gt;
incRefs if it returns a new reader).&lt;/p&gt;</comment>
                    <comment id="12675188" author="jasonrutherglen" created="Fri, 20 Feb 2009 00:14:17 +0000"  >&lt;p&gt;Added the test case to the patch.  &lt;/p&gt;</comment>
                    <comment id="12675206" author="jasonrutherglen" created="Fri, 20 Feb 2009 01:18:02 +0000"  >&lt;p&gt;The path forward seems to be exposing a cloned readonly reader&lt;br/&gt;
from IW.getReader. This would be easier than doing hula hoops to do&lt;br/&gt;
segment genealogy (at least for now &#9786;)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;can&apos;t we move away from allowing any changes via IR? (Ie&lt;br/&gt;
deprecate deleteDocuments/setNorms/etc.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would simplify things however as a thought experiment how would&lt;br/&gt;
the setNorms work if it were a part of IndexWriter? &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; And, clone should not be reopening segments...? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;DirectoryIndexReader.clone(boolean openReadonly) calls&lt;br/&gt;
doReopen(SegmentInfos infos, boolean doClone, boolean openReadOnly)&lt;br/&gt;
which is an abstract method that in SegmentReader and&lt;br/&gt;
MultiSegmentReader reopens the segments? The segment infos for a&lt;br/&gt;
ReaderIW is obtained from IW, which is how it knows about the new&lt;br/&gt;
segments. Perhaps not desired behavior?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; do we need delete by docID once we have realtime search? I&lt;br/&gt;
think the last compelling reason to keep IR&apos;s delete by docID was&lt;br/&gt;
immediacy, but realtime search can give us that, from IW, even when&lt;br/&gt;
deleting by Term or Query? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point! I think we may want to support it but for now it&apos;s&lt;br/&gt;
shouldn&apos;t be necessary. I&apos;m thinking of the case where someone is&lt;br/&gt;
using the field cache (or some variant), performs some sort of query&lt;br/&gt;
on it and then needs to delete based on doc id. What do they do?&lt;br/&gt;
Would we expose a callback mechanism where a deleteFrom(IndexReader&lt;br/&gt;
ir) method is exposed and deletes occur at the time of the IW&apos;s&lt;br/&gt;
choosing?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt; It seems like calling reader.reopen() (on reader obtained&lt;br/&gt;
from writer) should basically do the same thing as calling&lt;br/&gt;
writer.getReader(). Ie they are nearly synonyms? (Except for small&lt;br/&gt;
difference in ref counting - I think writer.getReader() should always&lt;br/&gt;
incRef, but reopen only incRefs if it returns a new reader). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perhaps ReaderIW.reopen will call IW.getReader underneath instead of&lt;br/&gt;
using IR&apos;s usual mechanism.&lt;/p&gt;

</comment>
                    <comment id="12675334" author="gsingers" created="Fri, 20 Feb 2009 11:25:06 +0000"  >&lt;p&gt;This latest patch doesn&apos;t seem to apply.&lt;/p&gt;
</comment>
                    <comment id="12675338" author="gsingers" created="Fri, 20 Feb 2009 11:42:49 +0000"  >&lt;p&gt;Is there ever a need for the normal IR construction anymore?  Or do we always just ask for it from the IW (or wherever we choose to expose this, as I still don&apos;t think it belongs on the IW API wise, but that isn&apos;t a big deal right now) every time?  I suppose if I know I&apos;m not going to be changing my index, I can still just get a read-only IR, right?&lt;/p&gt;

&lt;p&gt;API wise, I think we could do something like (with obvious other variations):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexAccessor{

  IndexWriter getWriter(Directory);

  &lt;span class=&quot;code-comment&quot;&gt;//returns read-only reader
&lt;/span&gt;  IndexReader getReader(Directory);

  &lt;span class=&quot;code-comment&quot;&gt;//returns the external IR described above
&lt;/span&gt;  IndexReader.getReader(IndexWriter);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, everyone has a single point of entry for both writers and readers and all of this stuff can just be done through package private methods on the IW and it allows us to change things if we decide otherwise and it means that the IW is not coupled with the IR publicly.&lt;/p&gt;</comment>
                    <comment id="12675343" author="mikemccand" created="Fri, 20 Feb 2009 12:14:15 +0000"  >&lt;p&gt;Jason, I think you need to &quot;svn up&quot;.  Or, tell us which revision you&apos;re on and we can downgrade to that revision before applying the patch.  (We need &quot;svn patch&quot;!).&lt;/p&gt;</comment>
                    <comment id="12675345" author="mikemccand" created="Fri, 20 Feb 2009 12:19:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The path forward seems to be exposing a cloned readonly reader&lt;br/&gt;
from IW.getReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; can&apos;t we move away from allowing any changes via IR? (Ie&lt;br/&gt;
&amp;gt; deprecate deleteDocuments/setNorms/etc.)&lt;/p&gt;

&lt;p&gt;This would simplify things however as a thought experiment how would&lt;br/&gt;
the setNorms work if it were a part of IndexWriter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it&apos;d look like this?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexWriter.setNorm(Term term, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; norm)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ie the Term IDs the doc(s) you want to set the norm for.&lt;/p&gt;

&lt;blockquote&gt;

&lt;p&gt;&amp;gt; And, clone should not be reopening segments...? &lt;/p&gt;

&lt;p&gt;DirectoryIndexReader.clone(boolean openReadonly) calls&lt;br/&gt;
doReopen(SegmentInfos infos, boolean doClone, boolean openReadOnly)&lt;br/&gt;
which is an abstract method that in SegmentReader and&lt;br/&gt;
MultiSegmentReader reopens the segments? The segment infos for a&lt;br/&gt;
ReaderIW is obtained from IW, which is how it knows about the new&lt;br/&gt;
segments. Perhaps not desired behavior?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, I think it does not reopen &lt;b&gt;existing&lt;/b&gt; segments.  Meaning, if a&lt;br/&gt;
segment is in common w/ old and new, it truly clones it (does not&lt;br/&gt;
reopen norms nor del).  But if there is a new segment that did not&lt;br/&gt;
exist in old, it opens a whole new segment reader?  I&apos;ll commit an&lt;br/&gt;
assert that this doesn&apos;t happen &amp;#8211; if caller passes in &quot;doClone=true&quot;&lt;br/&gt;
then caller should not have passed in a segmentInfos with changes?&lt;br/&gt;
Else the reader is on thin ice (mismatch what&apos;s in RAM vs what&lt;br/&gt;
SegmentInfo says).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; do we need delete by docID once we have realtime search? I&lt;br/&gt;
&amp;gt; think the last compelling reason to keep IR&apos;s delete by docID was&lt;br/&gt;
&amp;gt; immediacy, but realtime search can give us that, from IW, even when&lt;br/&gt;
&amp;gt; deleting by Term or Query? &lt;/p&gt;

&lt;p&gt;Good point! I think we may want to support it but for now it&apos;s&lt;br/&gt;
shouldn&apos;t be necessary. I&apos;m thinking of the case where someone is&lt;br/&gt;
using the field cache (or some variant), performs some sort of query&lt;br/&gt;
on it and then needs to delete based on doc id. What do they do?&lt;br/&gt;
Would we expose a callback mechanism where a deleteFrom(IndexReader&lt;br/&gt;
ir) method is exposed and deletes occur at the time of the IW&apos;s&lt;br/&gt;
choosing?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Wouldn&apos;t delete-by-Query cover this?  Ie one could always make a&lt;br/&gt;
Filter implementing the &quot;look @ field cache, do some logic, provide&lt;br/&gt;
docIDs to delete&quot;, wrap as Query, then delete-by-Query?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; It seems like calling reader.reopen() (on reader obtained&lt;br/&gt;
&amp;gt; from writer) should basically do the same thing as calling&lt;br/&gt;
&amp;gt; writer.getReader(). Ie they are nearly synonyms? (Except for small&lt;br/&gt;
&amp;gt; difference in ref counting - I think writer.getReader() should always&lt;br/&gt;
&amp;gt; incRef, but reopen only incRefs if it returns a new reader). &lt;/p&gt;

&lt;p&gt;Perhaps ReaderIW.reopen will call IW.getReader underneath instead of&lt;br/&gt;
using IR&apos;s usual mechanism.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, that&apos;s what I&apos;m thinking.  Once you&apos;ve obtained reader coupled&lt;br/&gt;
to a writer, you can then simply reopen it whenever you want to see&lt;br/&gt;
(materialize) changes done by the writer.&lt;/p&gt;

&lt;p&gt;We still need a solution for the &quot;warm the just merged&lt;br/&gt;
segment&quot;... else we will not be realtime, especially when big merge&lt;br/&gt;
finishes.  It seems like after merge finishes, it should immediately&lt;br/&gt;
1) open a SegmentReader on the new segment, 2) invoke the method you&lt;br/&gt;
passed in (or you subclassed &amp;#8211; not sure which), 3) carry over deletes&lt;br/&gt;
that materialized during the merge, 4) commit the merge (replace old&lt;br/&gt;
segments w/ new one).&lt;/p&gt;</comment>
                    <comment id="12675349" author="mikemccand" created="Fri, 20 Feb 2009 12:43:17 +0000"  >
&lt;blockquote&gt;&lt;p&gt;I suppose if I know I&apos;m not going to be changing my index, I can still just get a read-only IR, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, I think we still want to allow opening a standalone (uncoupled)&lt;br/&gt;
reader.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Then, everyone has a single point of entry for both writers and readers and all of this stuff can just be done through package private methods on the IW and it allows us to change things if we decide otherwise and it means that the IW is not coupled with the IR publicly.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m torn... the IndexAccessor would need to expose many variants to&lt;br/&gt;
carry over all the options we now have (String or File or Directory,&lt;br/&gt;
IndexCommit or not, IndexDeletionPolicy or not, create or not).  It&lt;br/&gt;
will end up exposing a number of new methods...  and, would it try to&lt;br/&gt;
be &quot;smart&quot; (like IndexModifier, and the LuceneIndexAccessor class in&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-390&quot; title=&quot;Contribution: LuceneIndexAccessor&quot;&gt;&lt;del&gt;LUCENE-390&lt;/del&gt;&lt;/a&gt;), keeping track of references to the readers it&apos;s handed&lt;br/&gt;
out, etc.?  Or is it simply a pass-through to the underlying&lt;br/&gt;
open/ctors we have today?&lt;/p&gt;

&lt;p&gt;The alternative (as of right now, unless we are missing something&lt;br/&gt;
further with these changes) is adding one method to IndexWriter,&lt;br/&gt;
getReader, that returns a readOnly IndexReader, &quot;coupled&quot; to the&lt;br/&gt;
writer you got it from in that it&apos;s able to search un-committed&lt;br/&gt;
changes and if you reopen it, writer will materialize all changes and&lt;br/&gt;
make them visible to the reopened reader.&lt;/p&gt;

&lt;p&gt;I guess so far I don&apos;t really see why this small (one method) API&lt;br/&gt;
change merits a switch to a whole new accessor API for creating&lt;br/&gt;
readers &amp;amp; writers on an index?  Maybe there is a&lt;br/&gt;
straw-that-breaks-the-camel&apos;s-back argument that I&apos;m missing...&lt;/p&gt;</comment>
                    <comment id="12675354" author="gsingers" created="Fri, 20 Feb 2009 13:06:03 +0000"  >&lt;p&gt;Good points, MIke, but maybe we don&apos;t need all those variants?  String, File and Directory are all easily enough collapsed down to just Directory.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Directory(indexFile));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally, there are no more variants than there already are on the IW and IR, right?   &lt;/p&gt;

&lt;p&gt;As for pass-through or not, I think it would just pass-through, at least initially, but it certainly leaves open the possibility for reference counting in the future if someone wants to implement that.&lt;/p&gt;

&lt;p&gt;As someone who teaches people these APIs on a regular basis, I feel pretty confident in saying that adding an IR to the IW as a public API is going to confuse a good chunk of people just as the delete stuff on the IR currently does now.  You wouldn&apos;t ask FileWriter for a FileReader, would you?  I don&apos;t see why it would be good to ask a IW for an IR, API-wise (I get why we are doing this, it makes sense).&lt;/p&gt;

&lt;p&gt;Likewise, isn&apos;t it just as logical to ask for an IW from an IR?  If I have an IR already and I want it to be aware of the writes I want to do, why wouldn&apos;t we then add IR.getIW()?  And then we can have total circular dependency. &lt;/p&gt;
</comment>
                    <comment id="12675394" author="mikemccand" created="Fri, 20 Feb 2009 16:37:46 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;maybe we don&apos;t need all those variants? String, File and Directory are all easily enough collapsed down to just Directory.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Directory(indexFile));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;p&gt;(You&apos;d presumably need to close that Directory).  But, yeah, we may be&lt;br/&gt;
able to drop some of them, although I do think they are convenient for&lt;br/&gt;
new users of Lucene.  And forcing users to switch to a totally new yet&lt;br/&gt;
pass through API on ugprade, but not giving them one to one carryover,&lt;br/&gt;
is not very nice.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Additionally, there are no more variants than there already are on the IW and IR, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, I&apos;m just saying IndexAccessor will have many methods.  And then&lt;br/&gt;
you&apos;re asking every app to make this switch, on upgrade.  It&apos;s alot of&lt;br/&gt;
API swapping/noise vs a single added expert method to IW.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As for pass-through or not, I think it would just pass-through, at&lt;br/&gt;
least initially, but it certainly leaves open the possibility for&lt;br/&gt;
reference counting in the future if someone wants to implement that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we think it&apos;ll be more than just pass through, we should try to&lt;br/&gt;
hash out, somewhat, what it will &amp;amp; won&apos;t do up front (changing it&lt;br/&gt;
later is a big change)?  And we should start from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-390&quot; title=&quot;Contribution: LuceneIndexAccessor&quot;&gt;&lt;del&gt;LUCENE-390&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As someone who teaches people these APIs on a regular basis, I feel&lt;br/&gt;
pretty confident in saying that adding an IR to the IW as a public API&lt;br/&gt;
is going to confuse a good chunk of people just as the delete stuff on&lt;br/&gt;
the IR currently does now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But this will be an expert/advanced API, a single added method to IW.&lt;br/&gt;
I wouldn&apos;t expect users to be confused: on upgrade I think most users&lt;br/&gt;
will not even notice its existence!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You wouldn&apos;t ask FileWriter for a FileReader, would you?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure that&apos;s the right comparison &amp;#8211; Lucene&apos;s IW does far more&lt;br/&gt;
than a FileWriter.  And the fact that Lucene allows &quot;point in time&quot;&lt;br/&gt;
searching (which is very useful and rather unique) is a very big&lt;br/&gt;
difference vs FileReader/Writer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Likewise, isn&apos;t it just as logical to ask for an IW from an IR?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think so: the functionality is not symmetric, because Lucene&lt;br/&gt;
allows only one writer open at a time, but many readers (eg on&lt;br/&gt;
different commits).  Since a writer is the one making changes, it&lt;br/&gt;
makes sense that you&apos;d ask it, right now, to give you a reader&lt;br/&gt;
reflecting all changes up to that point.  And call it again later to&lt;br/&gt;
get a reader seeing changes after that, etc.&lt;/p&gt;</comment>
                    <comment id="12675397" author="mikemccand" created="Fri, 20 Feb 2009 16:43:30 +0000"  >&lt;p&gt;Or, here&apos;s an idea: can we do both?  Put IndexAccessor as an optional&lt;br/&gt;
&quot;convenience&quot; layer that simplifies the ctors and expert methods of IW&lt;br/&gt;
&amp;amp; IR, but leave public direct access to the ctros &amp;amp; expert methods?&lt;br/&gt;
This way on upgrade nobody is forced to migrate to an entirely new yet&lt;br/&gt;
simply pass-through API?&lt;/p&gt;

&lt;p&gt;Or another idea is to decouple these two discussions: go ahead and add&lt;br/&gt;
the single expert method to IW, but as a separate discussion/JIRA work&lt;br/&gt;
out how we can simplify overall access/management of IR/IW instances?&lt;/p&gt;</comment>
                    <comment id="12675404" author="jasonrutherglen" created="Fri, 20 Feb 2009 17:26:36 +0000"  >&lt;p&gt;Ah yes, patch from the old directory that need deleting.  Here&apos;s the correct one.  Sorry about that.&lt;/p&gt;</comment>
                    <comment id="12675414" author="gsingers" created="Fri, 20 Feb 2009 17:55:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;Right, I&apos;m just saying IndexAccessor will have many methods. And then&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;you&apos;re asking every app to make this switch, on upgrade. It&apos;s alot of&lt;br/&gt;
API swapping/noise vs a single added expert method to IW.&lt;/p&gt;

&lt;p&gt;Sure, but that is already the case w/ IW/IR anyway.&lt;/p&gt;

&lt;p&gt;I agree about the short term noise, but in the long run it seems cleaner.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But this will be an expert/advanced API, a single added method to IW.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I wouldn&apos;t expect users to be confused: on upgrade I think most users&lt;br/&gt;
will not even notice its existence!&lt;/p&gt;

&lt;p&gt;Hmm, I don&apos;t agree, but I guess it depends on the performance hit.  If given a choice between the semantics of a reader that sees changes as they are made versus having to do the whole reopen thing, I&apos;m betting most users will say &quot;duh, I want to see my changes right away&quot; and choose the IR that is synced w/ the IW, b/c that is what people think is the logical thing to happen and it is how DBs work, which many devs. are used to.  As an app developer, if I don&apos;t have to think about IR lifecycle management, why would I want to as long as it performs?  What this patch is offering, AFAICT, is the removal of IR lifecycle managment from the user.&lt;/p&gt;

&lt;p&gt;In other words, my guess is that over time, as the performance proves out, it will be the default choice, not &quot;expert&quot;.  Now, if you&apos;re telling me this is going to be significantly slower even when updates are rare, then maybe I would stick to the current lifecycle, but if there isn&apos;t much difference, I&apos;ll take the one that pushes the lifecycle complexity down into Lucene instead of in my app.&lt;/p&gt;</comment>
                    <comment id="12675462" author="yseeley@gmail.com" created="Fri, 20 Feb 2009 20:29:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;a reader that sees changes as they are made versus having to do the whole reopen thing&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s hard keeping up with the current proposal in big issues/threads, but I don&apos;t think anyone is proposing a reader that automatically sees changes... i.e. the view of an IndexReader instance will still be fixed.&lt;/p&gt;</comment>
                    <comment id="12675490" author="mikemccand" created="Fri, 20 Feb 2009 22:21:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s hard keeping up with the current proposal in big issues/threads, but I don&apos;t think anyone is proposing a reader that automatically sees changes... i.e. the view of an IndexReader instance will still be fixed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s right.  The current proposal is to add one method to IW:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;IndexReader getReader()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;that returns a point-in-time view of the index plus all changes&lt;br/&gt;
buffered in IW up until that point.  Then you can reopen that reader&lt;br/&gt;
(or call getReader() again, which does the same thing) to quickly get&lt;br/&gt;
a new point-in-time reader.&lt;/p&gt;

&lt;p&gt;I think the point-in-time semantics is important to keep.&lt;/p&gt;

&lt;p&gt;Also, you can&apos;t easily emulate point-in-time if we implemented the&lt;br/&gt;
&quot;live&quot; approach, but you can easily do vice/versa (assuming we can&lt;br/&gt;
keep reopen() time fast enough).&lt;/p&gt;

&lt;p&gt;EG the IndexAccessor convenience layer could do automatic reopening so&lt;br/&gt;
that when you ask it for the reader it always reopens it; this would&lt;br/&gt;
emulate &quot;live updates&quot; and hide the lifecycle management.&lt;/p&gt;
</comment>
                    <comment id="12675499" author="mikemccand" created="Fri, 20 Feb 2009 22:50:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;I guess it depends on the performance hit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s challenging to implement truly live updates w/ decent&lt;br/&gt;
performance: I think we&apos;d need to build the reader impl that can&lt;br/&gt;
search DocumentsWriter buffer.&lt;/p&gt;

&lt;p&gt;Whereas the approach (patch) here is actually quite simple (all the&lt;br/&gt;
hard work was already done &amp;#8211; IndexReader.reopen,&lt;br/&gt;
collection/sorting/filtering by segment, etc.).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In other words, my guess is that over time, as the performance proves out, it will be the default choice, not &quot;expert&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree: realtime search will likely be a popular feature once we&lt;br/&gt;
finish it, release it, it proves stable, performant, etc.  Eventually&lt;br/&gt;
(maybe soon) it should be made the default.&lt;/p&gt;

&lt;p&gt;I think IndexAccessor makes alot of sense, but it&apos;s a big change and&lt;br/&gt;
I&apos;d rather not couple it to this issue.  There are many questions to&lt;br/&gt;
be hashed out (under a new issue): is it a simple pass-through?  Or&lt;br/&gt;
does it manage the lifecycle of the readers for you?  Does it warm new&lt;br/&gt;
readers?  Should it emulate &quot;live&quot; update semantics?  Should getReader&lt;br/&gt;
get it from the writer if there is one (ie, making realtime search the&lt;br/&gt;
&quot;default&quot;)?  Etc.&lt;/p&gt;</comment>
                    <comment id="12675504" author="gsingers" created="Fri, 20 Feb 2009 23:09:23 +0000"  >&lt;p&gt;OK, I agree.  Let&apos;s just mark it as expert/subject to revision and then we&apos;re good.&lt;/p&gt;

&lt;p&gt;We can revisit IndexAccessor separately.&lt;/p&gt;
</comment>
                    <comment id="12675523" author="jasonrutherglen" created="Sat, 21 Feb 2009 01:36:11 +0000"  >&lt;p&gt;There&apos;s concurrency issues to work out.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;IW.getReader returns a cloned read only reader&lt;/li&gt;
	&lt;li&gt;Removed IW.reopenReader&lt;/li&gt;
	&lt;li&gt;All test methods pass except testAddIndexesAndDoDeletesThreads. testAddIndexesAndDoDeletesThreads&lt;br/&gt;
currently merges indexes concurrently (and fails). In the future the&lt;br/&gt;
method will test merging, deleting, and searching concurrently. &lt;/li&gt;
	&lt;li&gt;Concurrent merges fail when &quot;ant test-core&quot; is run&lt;/li&gt;
	&lt;li&gt;DocumentsWriter.applyDeletes deletes again at the SegmentReader level&lt;/li&gt;
&lt;/ul&gt;

</comment>
                    <comment id="12675630" author="jasonrutherglen" created="Sun, 22 Feb 2009 07:40:04 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added segmentReaders, segmentReaderClone to MergePolicy.OneMerge&lt;/li&gt;
	&lt;li&gt;mergeFinish decRefs the OneMerge.segmentReaders&lt;/li&gt;
	&lt;li&gt;_mergeInit clones segmentreaders&lt;/li&gt;
	&lt;li&gt;commitMergedDeletes uses OneMerge.segmentReaders instead of loading&lt;br/&gt;
bitvectors from the directory&lt;/li&gt;
	&lt;li&gt;testAddIndexesAndDoDeletesThreads fails with 20 less documents (80 vs 100)&lt;br/&gt;
(an index that was supposed to be added isn&apos;t showing up)&lt;/li&gt;
	&lt;li&gt;Getting exceptions from org.apache.lucene.TestSnapshotDeletionPolicy, such as:&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Caused by: java.io.IOException: read past EOF
    [junit] 	at org.apache.lucene.store.BufferedIndexInput.readBytes(BufferedIndexInput.java:135)
    [junit] 	at org.apache.lucene.store.BufferedIndexInput.readBytes(BufferedIndexInput.java:92)
    [junit] 	at org.apache.lucene.store.IndexOutput.copyBytes(IndexOutput.java:172)
    [junit] 	at org.apache.lucene.index.TermVectorsWriter.addRawDocuments(TermVectorsWriter.java:185)
    [junit] 	at org.apache.lucene.index.SegmentMerger.mergeVectors(SegmentMerger.java:447)
    [junit] 	at org.apache.lucene.index.SegmentMerger.merge(SegmentMerger.java:145)
    [junit] 	at org.apache.lucene.index.IndexWriter.mergeMiddle(IndexWriter.java:4823)
    [junit] 	at org.apache.lucene.index.IndexWriter.merge(IndexWriter.java:4408)
    [junit] 	at org.apache.lucene.index.ConcurrentMergeScheduler.doMerge(ConcurrentMergeScheduler.java:218)
    [junit] 	at org.apache.lucene.index.ConcurrentMergeScheduler$MergeThread.run(ConcurrentMergeScheduler.java:274)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12675717" author="mikemccand" created="Sun, 22 Feb 2009 22:10:02 +0000"  >&lt;p&gt;I think your latest test is missing the the new unit test source.&lt;/p&gt;</comment>
                    <comment id="12675719" author="mikemccand" created="Sun, 22 Feb 2009 22:10:53 +0000"  >&lt;p&gt;Woops, sorry &amp;#8211; I downloaded the wrong patch.&lt;/p&gt;</comment>
                    <comment id="12675863" author="mikemccand" created="Mon, 23 Feb 2009 12:03:35 +0000"  >
&lt;p&gt;I think we can simplify the approach here:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I don&apos;t think IW should track an &quot;internal reader&quot; at all.&lt;br/&gt;
    Instead, it tracks a pool of held-open and re-used SegmentReader&lt;br/&gt;
    instances.  Maybe make a new SegmentReaderPool private class.  It&lt;br/&gt;
    exposes get() to load a SegmentReader, returning the pooled one if&lt;br/&gt;
    present, else falling back to the normal SegmentReader.get.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Then, the many places where we currently pull a segment reader (to&lt;br/&gt;
    apply deletes, to do a merge, to carry over new deletes after&lt;br/&gt;
    merge finishes) as well as the new getReader() method, should use&lt;br/&gt;
    this pool to get the reader.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We would never mergeSegmentInfos, never ask the &quot;internal reader&quot;&lt;br/&gt;
    to commit, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Other things:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Since IndexReader will always be readonly, you can simplify the&lt;br/&gt;
    new DirectoryIndexReader.open method, eg we don&apos;t need to copy&lt;br/&gt;
    over the writeLock nor the DeletionPolicy, and we don&apos;t need the&lt;br/&gt;
    readOnly param, and closeDirectory is always false.  In fact we&lt;br/&gt;
    could simply create a ReadOnly
{Multi,}
&lt;p&gt;SegmentReader directly.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think IndexReader.clone() should not grab the writer&apos;s&lt;br/&gt;
    segmentInfos?  Ie it should truly be a clone(), not a reopen.&lt;br/&gt;
    Actually, when the reader is created we should make a private full&lt;br/&gt;
    copy of the SegmentInfos.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We lost some &quot;private&quot; modifiers, unecessarily; eg&lt;br/&gt;
    DirectoryIndexReader.writeLock.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I don&apos;t understand why we need merge.segmentReadersClone?  If we&lt;br/&gt;
    only use to detect new deletions for carrying over deletes after&lt;br/&gt;
    merge finishes, we should instead just grab the delCount when the&lt;br/&gt;
    merge kicked off?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think the only reason for reader to hold a reference to writer&lt;br/&gt;
    is so that on reopen, the reader realizes it was created from&lt;br/&gt;
    IW.getReader and simply forwards the request to IW.  Otherwise&lt;br/&gt;
    writer should not be used in reader.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Once we no longer store/maintain/merge an &quot;internal&quot; reader,&lt;br/&gt;
    IW.getReader simply becomes a call to IndexReader.open, with two&lt;br/&gt;
    differences: 1) we pass in a SegmentInfos instance (instead of&lt;br/&gt;
    looking for last segments_N in dir), and 2) we pass in our own&lt;br/&gt;
    SegmentReaderPool that should be used to open the SR&apos;s.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You need to add mainDir.close() in&lt;br/&gt;
    testAddIndexesAndDoDeletesThreads.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12675979" author="jasonrutherglen" created="Mon, 23 Feb 2009 17:09:27 +0000"  >&lt;p&gt;&amp;gt; make a new SegmentReaderPool private class&lt;/p&gt;

&lt;p&gt;I&apos;d prefer the SegmentReaderPool model over the patch&apos;s existing one&lt;br/&gt;
as it is simpler and closer to how the underlying system actually&lt;br/&gt;
works meaning it works directly with the segments in a systematized way.&lt;/p&gt;

&lt;p&gt;&amp;gt; We would never mergeSegmentInfos, never ask the &quot;internal reader&quot;&lt;br/&gt;
to commit&lt;/p&gt;

&lt;p&gt;Good, merging the segmentInfos is confusing and tricky to debug&lt;/p&gt;

&lt;p&gt;&amp;gt; Since IndexReader will always be readonly, you can simplify the new&lt;br/&gt;
DirectoryIndexReader.open method&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; why we need merge.segmentReadersClone?&lt;/p&gt;

&lt;p&gt;I was modeling after the segmentInfosClone. If it&apos;s not necessary&lt;br/&gt;
I&apos;ll happily remove it.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think the only reason for reader to hold a reference to writer is&lt;br/&gt;
so that on reopen, the reader realizes it was created from&lt;br/&gt;
IW.getReader and simply forwards the request to IW&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; Wouldn&apos;t delete-by-Query cover this? Ie one could always make a&lt;br/&gt;
Filter implementing the &quot;look @ field cache, do some logic, provide&lt;br/&gt;
docIDs to delete&quot;, wrap as Query, then delete-by-Query? (from a&lt;br/&gt;
previous coment) &lt;/p&gt;

&lt;p&gt;Yes that will work. &lt;/p&gt;

&lt;p&gt;How are these sample SegmentReaderPool method signatures? &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; class SegmentReaderPool {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; SegmentReader get(SegmentInfo si) {}
    
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void decRef(SegmentReader sr) {}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12675982" author="jasonrutherglen" created="Mon, 23 Feb 2009 17:12:44 +0000"  >&lt;p&gt;In SegmentInfo it&apos;s hashCode only takes into&lt;br/&gt;
account the name and directory, why not the delete generation?&lt;/p&gt;</comment>
                    <comment id="12676053" author="mikemccand" created="Mon, 23 Feb 2009 20:19:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;How are these sample SegmentReaderPool method signatures? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Looks good for starters.  decRef would simply pass-through to the SR&apos;s&lt;br/&gt;
normal decRef, but would then also decRef its copy if the ref count has&lt;br/&gt;
dropped to 1?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In SegmentInfo it&apos;s hashCode only takes into&lt;br/&gt;
account the name and directory, why not the delete generation?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Two SegmentInfo instances are considered equal if the dir is == and&lt;br/&gt;
the name is .equals, so hashCode must match that (be the same value&lt;br/&gt;
when equals returns true).&lt;/p&gt;</comment>
                    <comment id="12676444" author="jasonrutherglen" created="Tue, 24 Feb 2009 22:53:02 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added SegmentReaderPool that maintains a map of SegmentInfoKey -&amp;gt;&lt;br/&gt;
SegmentReader. SegmentInfoKey returns a hashcode of a SegmentInfo&lt;br/&gt;
that also includes the deletes and norms generations.&lt;br/&gt;
SegmentReaderPool also maintains a map of SegmentReaders that&lt;br/&gt;
represent &quot;working copies&quot; (cloned readers) for realtime deletes&lt;br/&gt;
occurring. When IW.getReader is called the &quot;working copy&quot; readers&lt;br/&gt;
replace the existing readers keyed with the same segmentinfo in the&lt;br/&gt;
SegmentReaderPool. This way IW.deleteDocument applies to the in&lt;br/&gt;
memory cloned &quot;working copies&quot; but does not alter SegmentReaders&lt;br/&gt;
already returned from SegmentReaderPool. &lt;/li&gt;
	&lt;li&gt;The test methods in TestIndexWriterReader pass&lt;/li&gt;
	&lt;li&gt;I&apos;m hesitant to automatically flush on IW.getReader as IW.flush has&lt;br/&gt;
a number of parameters. However for updateDocument to work properly&lt;br/&gt;
we&apos;ll probably need to do this? &lt;/li&gt;
	&lt;li&gt;DocumentsWriter.applyDeletes should no longer need to apply deletes&lt;br/&gt;
as they are already applied in realtime in IW.deleteDocument? It&lt;br/&gt;
should only need to call SR.commitChanges? &lt;/li&gt;
	&lt;li&gt;&quot;ant test-core&quot; fails in ConcurrentMergeScheduler with the same&lt;br/&gt;
exception as above in TestSnapshotDeletionPolicy (and some others). I&lt;br/&gt;
suspect in the case of TestSnapshotDeletionPolicy the errors could be&lt;br/&gt;
due to the SegmentReader holding files open while they are being&lt;br/&gt;
copied. Perhaps this would explain the EOFExceptions? &lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12676469" author="jasonrutherglen" created="Wed, 25 Feb 2009 01:13:32 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Fixed the basic concurrency merge issue (TestSnapshotDeletionPolicy passes)&lt;/li&gt;
	&lt;li&gt;Many unit tests fail due to other reasons&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12676476" author="jasonrutherglen" created="Wed, 25 Feb 2009 02:07:22 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TestAddIndexesNoOptimize test passes&lt;/li&gt;
	&lt;li&gt;There&apos;s an incRef issue still&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12676652" author="mikemccand" created="Wed, 25 Feb 2009 14:00:15 +0000"  >&lt;p&gt;Jason could you rebase the patch on current trunk?  (Or post the revision you&apos;re on?).&lt;/p&gt;</comment>
                    <comment id="12676708" author="jasonrutherglen" created="Wed, 25 Feb 2009 17:11:28 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Revised to trunk&lt;/li&gt;
	&lt;li&gt;Still an incRef issue.&lt;br/&gt;
TestIndexWriterReader.testDeleteFromIndexWriter fails.&lt;br/&gt;
TestConcurrentMergeScheduler fails, as well as others&lt;/li&gt;
	&lt;li&gt;Removed the working copy stuff from SegmentReaderPool as the&lt;br/&gt;
deletes need to be applied to the internal readers, the external&lt;br/&gt;
IW.getReader is a clone of the internal SRs.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12676713" author="jasonrutherglen" created="Wed, 25 Feb 2009 17:22:03 +0000"  >&lt;p&gt;We&apos;ll need a method to check the SegmentReaderPool for readers that&lt;br/&gt;
may be removed. It seems it would check IW.segmentInfos, pending&lt;br/&gt;
merges, current merges for segmentinfo(s) that are in use, then all&lt;br/&gt;
others in the pool are expunged. I&apos;m not sure if this method would&lt;br/&gt;
need to run in a background thread. &lt;/p&gt;</comment>
                    <comment id="12676749" author="mikemccand" created="Wed, 25 Feb 2009 19:41:14 +0000"  >&lt;p&gt;Looks good!:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The SegmentReaderPool class should be package private.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You&apos;re still passing readOnly &amp;amp; closeDirectory into the new&lt;br/&gt;
    DirectoryIndexReader ctor; I think you can pass in only the&lt;br/&gt;
    writer, and then it can get all it needs from that (pool, dir,&lt;br/&gt;
    segmentInfos)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Hmm... I think we should change commitMergedDeletes to use the&lt;br/&gt;
    already computed doc ID maps, instead of loading the old deletes.&lt;br/&gt;
    This way you don&apos;t need the old SR.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think you don&apos;t need SegmentInfoKey?  Can&apos;t you key off of just&lt;br/&gt;
    the SegmentInfo?  I think for each segment name we only ever need&lt;br/&gt;
    one SR instance in the pool (dir is always the same)?  (The&lt;br/&gt;
    readers we give out will make clones of these).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Why do you applyDeletesImmediately?  I think we should&lt;br/&gt;
    buffer/flush like we normally do?  That code shouldn&apos;t need to&lt;br/&gt;
    change.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think getReader does need to flush, else added docs won&apos;t be&lt;br/&gt;
    seen in the reopend reader.  You should call flush(true, true,&lt;br/&gt;
    true) &amp;#8211; because you want to triggerMerges, flushDocStores,&lt;br/&gt;
    and flushDeletes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Are segmentInfosList/printSegmentInfosList temporary debugging?&lt;br/&gt;
    Can you stick &quot;nocommits&quot; on them?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For SegmentReaderPool:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think IW should always use the pool API internally to load &amp;amp;&lt;br/&gt;
    decRef the SRs it uses.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If getReader has never been called, then the pool should not hold&lt;br/&gt;
    refs, ie IW should behave exactly as it does today (get SR, use&lt;br/&gt;
    it, commit it, close it).  Ie, the pool should detect on decRef&lt;br/&gt;
    that the RC is now 1, and release the SR.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If getReader has been called, then the pool should hold onto an SR&lt;br/&gt;
    as long as the writer&apos;s segmentInfos still references that&lt;br/&gt;
    segment.  This means, after a merge commits we should prune the&lt;br/&gt;
    pool.  Ie, we decRef and remove the SR from the pool, but we don&apos;t&lt;br/&gt;
    close it since a reader may still be using it.  Maybe add a&lt;br/&gt;
    prune() method?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Somehow, we should not let the SR commit itself on close &amp;#8211; that&apos;s&lt;br/&gt;
    up to IW to decide.  If getReader has not been called then IW must&lt;br/&gt;
    commit deletes as soon as applies them (like today).  Else, it&apos;s&lt;br/&gt;
    only on closing the pool that deletes are committed.  EG pending&lt;br/&gt;
    deletes on SRs that have been merged can be freely discarded,&lt;br/&gt;
    since those deletes &quot;made it&quot; into the newly merged segment.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;So I don&apos;t think we need a BG thread to do the culling.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12676811" author="jasonrutherglen" created="Wed, 25 Feb 2009 23:18:34 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think we should change commitMergedDeletes to use the&lt;br/&gt;
already computed doc ID maps, instead of loading the old deletes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Where do I get the already computed doc ID maps?  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think getReader does need to flush, else added docs won&apos;t be&lt;br/&gt;
seen in the reopend reader. You should call flush(true, true,&lt;br/&gt;
true) - because you want to triggerMerges, flushDocStores,&lt;br/&gt;
and flushDeletes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I added a flushDeletesToDir flag that defaults to true except for IW.getReader.&lt;/p&gt;
</comment>
                    <comment id="12676815" author="jasonrutherglen" created="Wed, 25 Feb 2009 23:27:44 +0000"  >&lt;p&gt;Found the doc ID map in SegmentMerger in IW.commitMerge&lt;/p&gt;</comment>
                    <comment id="12676836" author="jasonrutherglen" created="Thu, 26 Feb 2009 01:33:44 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;commitMergedDeletes uses the docIdMap from commitMerge SegmentMerger to map new deletes to the newly merged segment&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed applyDeletesImmediately&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Haven&apos;t solved the decRef issue which appears in TestIndexWriterReader.testDeleteFromIndexWriter.  It doesn&apos;t show up in the debugger.&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[junit] java.lang.AssertionError
    [junit] 	at org.apache.lucene.index.SegmentReader$Ref.incRef(SegmentReader.java:103)
    [junit] 	at org.apache.lucene.index.SegmentReader.incRef(SegmentReader.java:341)
    [junit] 	at org.apache.lucene.index.IndexWriter$SegmentReaderPool.get(IndexWriter.java:647)
    [junit] 	at org.apache.lucene.index.IndexWriter$SegmentReaderPool.getReadOnlyClone(IndexWriter.java:615)
    [junit] 	at org.apache.lucene.index.MultiSegmentReader.&amp;lt;init&amp;gt;(MultiSegmentReader.java:86)
    [junit] 	at org.apache.lucene.index.ReadOnlyMultiSegmentReader.&amp;lt;init&amp;gt;(ReadOnlyMultiSegmentReader.java:35)
    [junit] 	at org.apache.lucene.index.IndexWriter.getReader(IndexWriter.java:396)
    [junit] 	at org.apache.lucene.index.TestIndexWriterReader.testDeleteFromIndexWriter(TestIndexWriterReader.java:159)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12677195" author="jasonrutherglen" created="Fri, 27 Feb 2009 01:20:38 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The patch is not committable as the debugging and comments need cleaning&lt;/li&gt;
	&lt;li&gt;The clone issue was hacked around so more tests pass&lt;/li&gt;
	&lt;li&gt;TestAtomicUpdate fails&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12677523" author="jvolkman" created="Fri, 27 Feb 2009 20:52:33 +0000"  >&lt;p&gt;I noticed the comments about IW.getReader() flushing the current state of the writer, launching merges, etc. Does this mean that the point of interaction between index writes and reads will still be the Directory? (i.e. the disk)&lt;/p&gt;</comment>
                    <comment id="12677533" author="mikemccand" created="Fri, 27 Feb 2009 21:12:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;Does this mean that the point of interaction between index writes and reads will still be the Directory? (i.e. the disk)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For added docs, yes.  But deletions will carry straight through in memory.&lt;/p&gt;</comment>
                    <comment id="12678164" author="jasonrutherglen" created="Mon, 2 Mar 2009 23:50:28 +0000"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Most tests pass. Because SegmentReaders are held by the writer,&lt;br/&gt;
files remain open whereas before this patch they did not. This causes&lt;br/&gt;
some tests to fail. &lt;/li&gt;
	&lt;li&gt;I&apos;m working a way to remove unreferenced segments from the pool&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12678174" author="jasonrutherglen" created="Tue, 3 Mar 2009 00:33:26 +0000"  >&lt;ul&gt;
	&lt;li&gt;In IW.checkpoint, SegmentReaderPool.closeUnusedSegmentReaders is&lt;br/&gt;
called which gathers a set of all currently active segment names and&lt;br/&gt;
closes the segment readers not in the set. When the IW is closed an&lt;br/&gt;
assertion checks to insure the IW.segmentInfos names are the same as&lt;br/&gt;
those in the pool. &lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Bunches of private variables were made package protected and need to&lt;br/&gt;
be changed back&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12678386" author="jasonrutherglen" created="Tue, 3 Mar 2009 18:31:39 +0000"  >&lt;ul&gt;
	&lt;li&gt;In TestConcurrentMergeScheduler.testNoWaitClose I&apos;m seeing a couple&lt;br/&gt;
of exceptions. I&apos;m not quite sure what to make of them. The&lt;br/&gt;
testNoWaitClose method calls IW.close(false) a number of times on an&lt;br/&gt;
IW that uses ConcurrentMergeScheduler. &lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[junit] Caused by: java.lang.AssertionError
    [junit] 	at org.apache.lucene.index.IndexFileDeleter$RefCount.DecRef(IndexFileDeleter.java:553)
    [junit] 	at org.apache.lucene.index.IndexFileDeleter.decRef(IndexFileDeleter.java:470)
    [junit] 	at org.apache.lucene.index.IndexFileDeleter.decRef(IndexFileDeleter.java:481)
    [junit] 	at org.apache.lucene.index.IndexWriter.decrefMergeSegments(IndexWriter.java:4485)
    [junit] 	at org.apache.lucene.index.IndexWriter.commitMerge(IndexWriter.java:4473)
    [junit] 	at org.apache.lucene.index.IndexWriter.mergeMiddle(IndexWriter.java:4910)
    [junit] 	at org.apache.lucene.index.IndexWriter.merge(IndexWriter.java:4539)
    [junit] 	at org.apache.lucene.index.ConcurrentMergeScheduler.doMerge(ConcurrentMergeScheduler.java:218)
    [junit] 	at org.apache.lucene.index.ConcurrentMergeScheduler$MergeThread.run(ConcurrentMergeScheduler.java:274)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[junit] java.lang.AssertionError
    [junit] 	at org.apache.lucene.index.IndexWriter.finishMerges(IndexWriter.java:3350)
    [junit] 	at org.apache.lucene.index.IndexWriter.closeInternal(IndexWriter.java:2090)
    [junit] 	at org.apache.lucene.index.IndexWriter.close(IndexWriter.java:2045)
    [junit] 	at org.apache.lucene.index.TestConcurrentMergeScheduler.testNoWaitClose(TestConcurrentMergeScheduler.java:211)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12678525" author="jasonrutherglen" created="Wed, 4 Mar 2009 00:34:44 +0000"  >&lt;p&gt;The IndexFileDeleter$RefCount.DecRef exception is related to an incorrect ref count of .del files when TestConcurrentMergeScheduler is run.&lt;/p&gt;</comment>
                    <comment id="12678528" author="jasonrutherglen" created="Wed, 4 Mar 2009 00:51:27 +0000"  >&lt;p&gt;Because the patch does not flush deletes to disk like the existing&lt;br/&gt;
code does, the SegmentInfo delGen etc isn&apos;t updated at the same&lt;br/&gt;
points as expected. In tracing the code the .del files that have 0&lt;br/&gt;
refs then are decRefed throwing the assertion error were never&lt;br/&gt;
incRefed by IndexFileDeleter. This is because the deletes are carried&lt;br/&gt;
over in the IW internal readers. Eventually the .del files are&lt;br/&gt;
written but aren&apos;t increfed as they usually would be. Is there a good&lt;br/&gt;
solution to this? Do we need an interim SegmentInfo variable that&lt;br/&gt;
indicates future flushed deletions? &lt;/p&gt;</comment>
                    <comment id="12678884" author="mikemccand" created="Wed, 4 Mar 2009 19:58:29 +0000"  >
&lt;blockquote&gt;&lt;p&gt;I added a flushDeletesToDir flag that defaults to true except for IW.getReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that should not be necessary.  On releasing a reader, if it&lt;br/&gt;
has pending changes and we want to drop it from the pool, we should&lt;br/&gt;
move its deletes to the directory?&lt;/p&gt;

&lt;p&gt;SegmentMerger should clear the hasChanges on the reader after its done&lt;br/&gt;
merging, so we don&apos;t bother saving delete files for segments that were&lt;br/&gt;
merged away.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In TestConcurrentMergeScheduler.testNoWaitClose I&apos;m seeing a couple of exceptions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the first is the root cause (and causes the 2nd one).&lt;/p&gt;

&lt;p&gt;Which test case hits that?  The test cases that intentionally throw&lt;br/&gt;
exceptions at interesting times are especially fun to debug &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Because the patch does not flush deletes to disk like the existing&lt;br/&gt;
code does, the SegmentInfo delGen etc isn&apos;t updated at the same&lt;br/&gt;
points as expected.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;IFD should be fine with this &amp;#8211; there must be something else at play,&lt;br/&gt;
causing us to over-decRef.&lt;/p&gt;

&lt;p&gt;Other notes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;You still have SegmentInfoKey (see above)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The new DirectoryIndexReader.open should just take IndexWriter&lt;br/&gt;
    (see above)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Rather than the getSegmentsInUse &quot;polling&quot; approach, I think you&lt;br/&gt;
    can incrementally add &amp;amp; remove readers from the pool?  EG after a&lt;br/&gt;
    merge commits, drop the readers for the just-merged segments and&lt;br/&gt;
    add a reader for the newly merged segment (and using it to hold&lt;br/&gt;
    the deletes carried over in commitMergedDeletes).  I think for&lt;br/&gt;
    just-flushed segments you can wait for a getReader() call to&lt;br/&gt;
    happen again, to init their readers, unless something else does&lt;br/&gt;
    first (flushing deletes, merging)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You commented out the last part of commitMergedDeletes, that&lt;br/&gt;
    actually saves the deletes.  You need to instead get the reader&lt;br/&gt;
    for the merged segment from the pool and hand it the new deletes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We lost the cutover to using the already computed docMap in&lt;br/&gt;
    commitMergedDeletes?  We should put that back &amp;#8211; it saves having&lt;br/&gt;
    to read in the prior deletions from disk.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12679013" author="jasonrutherglen" created="Thu, 5 Mar 2009 00:42:51 +0000"  >&lt;ul&gt;
	&lt;li&gt;TestConcurrentMergeScheduler is passing&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;A handful of other tests don&apos;t pass, looking into them next&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;DirectoryIndexReader.open with a writer isn&apos;t necessary so the&lt;br/&gt;
related method is removed&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I&apos;m not sure we need to write out the deletes of unused segment&lt;br/&gt;
readers because they are no longer used and so should not be&lt;br/&gt;
required. I realized the unused readers needs to also check with&lt;br/&gt;
the deletion policy?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The TestConcurrentMergeScheduler. testNoWaitClose exception is&lt;br/&gt;
caused by the way .del files are created when SR.commitChanges is&lt;br/&gt;
called, altering the SR segmentinfo without IFD.incRefing the .del&lt;br/&gt;
file. The solution, manually incref the .del file after the pool&lt;br/&gt;
commits on the SRs. Before this process was handled transparently by&lt;br/&gt;
IW.checkpoint. Also the other issue was the SegmentInfo files&lt;br/&gt;
variable was created before the delGen change, then the .del file was&lt;br/&gt;
not being returned by SI.files(). With the .del file being returned&lt;br/&gt;
the IFD related exception went away.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SegmentInfoKey is removed, SegmentInfo is used as the key for&lt;br/&gt;
SegmentReaderPool.get&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&amp;gt; You commented out the last part of commitMergedDeletes, that&lt;br/&gt;
actually saves the deletes. You need to instead get the reader for&lt;br/&gt;
the merged segment from the pool and hand it the new deletes.&lt;/p&gt;

&lt;p&gt;I wasn&apos;t sure what you meant by this, in the patch the deletes are&lt;br/&gt;
copied into the merged reader. Do you mean instead the merged reader&lt;br/&gt;
should not be opened and instead the deletes file needs to be written&lt;br/&gt;
to?&lt;/p&gt;

&lt;p&gt;&amp;gt; We lost the cutover to using the already computed docMap in&lt;br/&gt;
commitMergedDeletes?&lt;/p&gt;

&lt;p&gt;SegmentMerger wasn&apos;t always returning the docMap so I stopped using&lt;br/&gt;
it.  &lt;/p&gt;</comment>
                    <comment id="12679024" author="jasonrutherglen" created="Thu, 5 Mar 2009 01:11:10 +0000"  >&lt;p&gt;A little over zealous in altering the flushDeletesToDisk flag in IW.flush&lt;/p&gt;</comment>
                    <comment id="12679140" author="mikemccand" created="Thu, 5 Mar 2009 10:10:33 +0000"  >&lt;p&gt;Thanks Jason, good progress...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;m not sure we need to write out the deletes of unused segment&lt;br/&gt;
readers because they are no longer used and so should not be&lt;br/&gt;
required.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;EG I think DocumentsWriter.applyDeletes should get the reader from&lt;br/&gt;
pool, do deletes, then call pool.release(reader), and that release&lt;br/&gt;
would write the changes to disk if we&apos;re not pooling readers.  Then we&lt;br/&gt;
don&apos;t need a new &quot;flushDeletesToDir&quot; propogated around.&lt;/p&gt;

&lt;p&gt;On an explicit commit(), we should also sweep the pool and write&lt;br/&gt;
changes to disk for any SR that has pending changes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; You commented out the last part of commitMergedDeletes, that&lt;br/&gt;
actually saves the deletes. You need to instead get the reader for&lt;br/&gt;
the merged segment from the pool and hand it the new deletes.&lt;/p&gt;

&lt;p&gt;I wasn&apos;t sure what you meant by this, in the patch the deletes are&lt;br/&gt;
copied into the merged reader. Do you mean instead the merged reader&lt;br/&gt;
should not be opened and instead the deletes file needs to be written&lt;br/&gt;
to?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops &amp;#8211; sorry: you are doing it correctly (applying to the&lt;br/&gt;
mergedReader).  I missed that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;SegmentMerger wasn&apos;t always returning the docMap so I stopped using it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It should always return it, unless there were no deletes on that&lt;br/&gt;
segment when the merge started, in which case the docMap is null.  But&lt;br/&gt;
you can handle that case (just check if there are now any deletes, and&lt;br/&gt;
carry them over).&lt;/p&gt;

&lt;p&gt;(Then we shouldn&apos;t need merge.segmentReadersClone, again).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The solution, manually incref the .del file after the pool&lt;br/&gt;
commits on the SRs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s spooky &amp;#8211; why exactly is it needed?  We should only do an extra&lt;br/&gt;
incRef if we can explain exactly which decRef it will correspond to.&lt;br/&gt;
Shouldn&apos;t IW.checkpoint still work properly for the .del files?&lt;/p&gt;

&lt;p&gt;Also, SegmentInfo.files should be cleared whenever delGen is advanced&lt;br/&gt;
&amp;#8211; can you give more details on what path doesn&apos;t properly clear the&lt;br/&gt;
files?&lt;/p&gt;

&lt;p&gt;The fact that an SR can carry deletes in memory without writing a new&lt;br/&gt;
.del file should not impact IFD.  Whenever we do advance delGen and&lt;br/&gt;
write new .del files, then we must call checkpoint().&lt;/p&gt;

&lt;p&gt;So I think we need to really explain the root cause here...&lt;/p&gt;

&lt;p&gt;Others:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;You overrode decRef in DirectoryIndexReader, to not write changes&lt;br/&gt;
    whenever a writer is present, but I think that a better approach&lt;br/&gt;
    is to leave decRef as it is and then from writer, clear hasChanges&lt;br/&gt;
    when you want to discard them (because they were merged away).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You inserted applyDeletes at the top of commitMergedDeletes &amp;#8211; why&lt;br/&gt;
    was that needed?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;There&apos;s alot of noise in the patch &amp;#8211; whitespace changes,&lt;br/&gt;
    commented out debug code, etc.  Can you remove some of it?  It&lt;br/&gt;
    makes it harder to separate signal from noise...&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12679355" author="jasonrutherglen" created="Thu, 5 Mar 2009 21:11:03 +0000"  >&lt;p&gt;Here&apos;s a summary of the which tests are failing grouped by the&lt;br/&gt;
guessed cause:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;TestDeletionPolicy, TestIndexFileDeleter, TestIndexReader fails (not&lt;br/&gt;
all methods but they seem to be related, i.e. files are being left&lt;br/&gt;
open that should not be)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In TestIndexWriter most test methods pass, however a few such as&lt;br/&gt;
testCommitOnCloseDiskUsage fail.&lt;br/&gt;
TestIndexWriterDelete.testUpdatesOnDiskFull fails for reasons&lt;br/&gt;
presumably similar to TestIndexWriter.testCommitOnCloseDiskUsage&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;TestTransactions and TestStressIndexing2 fails. At first glance I&apos;m&lt;br/&gt;
not sure why &lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12679377" author="jasonrutherglen" created="Thu, 5 Mar 2009 21:37:59 +0000"  >&lt;p&gt;On IW.close -&amp;gt; SegmentReaderPool.flushChanged -&amp;gt;&lt;br/&gt;
segmentreader.commitChanges was being called on SRs that had no&lt;br/&gt;
changes. TestDeletionPolicy and TestIndexFileDeleter passes.&lt;/p&gt;
</comment>
                    <comment id="12679383" author="jasonrutherglen" created="Thu, 5 Mar 2009 21:44:13 +0000"  >&lt;p&gt;TestIndexReader.testDocsOutOfOrderJIRA140 fails because IW.close&lt;br/&gt;
isn&apos;t called before dir.close. Is this a bug in the unit test?&lt;/p&gt;</comment>
                    <comment id="12679404" author="jasonrutherglen" created="Thu, 5 Mar 2009 22:46:53 +0000"  >&lt;p&gt;TestIndexWriterDelete.testOperationsOnDiskFull fails with&lt;br/&gt;
MockRAMDirectory.close (still open files) because IW.close isn&apos;t&lt;br/&gt;
called.&lt;/p&gt;

&lt;p&gt;TestIndexWriter.testImmediateDiskFullWithThreads fails because&lt;br/&gt;
IW.close fails on the disk full exception. Should IW.closeInternal -&amp;gt;&lt;br/&gt;
SegmentReaderPool.close be placed in the finally clause?&lt;/p&gt;

&lt;p&gt;TestTransactions fails because the purposely random failure occurs&lt;br/&gt;
during IW.close (SRP.close specifically) &lt;/p&gt;

&lt;p&gt;The TestStressIndexing2 failure could be tricky&lt;/p&gt;</comment>
                    <comment id="12679576" author="mikemccand" created="Fri, 6 Mar 2009 12:25:30 +0000"  >&lt;blockquote&gt;
&lt;p&gt;TestIndexReader.testDocsOutOfOrderJIRA140 fails because IW.close&lt;br/&gt;
isn&apos;t called before dir.close. Is this a bug in the unit test?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this looks like a bug in the test.  This also means when we eventually commit this, we&apos;ll have to first fix that bug on the back-compat tests branch.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TestIndexWriterDelete.testOperationsOnDiskFull fails with&lt;br/&gt;
MockRAMDirectory.close (still open files) because IW.close isn&apos;t&lt;br/&gt;
called.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t understand: that test looks like it does call IW.close for all IW&apos;s opened?  (It&apos;s a little tricky, because modifier.close gets called the 2nd time the for(int x = 0...) loop runs).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TestIndexWriter.testImmediateDiskFullWithThreads fails because&lt;br/&gt;
IW.close fails on the disk full exception. Should IW.closeInternal -&amp;gt;&lt;br/&gt;
SegmentReaderPool.close be placed in the finally clause?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Does the 2nd call to close (close(false)) also hit an exception?  Perhaps, modify the test so that if that 2nd close hits an exception, call abort?&lt;/p&gt;

&lt;p&gt;It&apos;s good that you&apos;re down to mainly the exceptions-based test failures... though I think you should focus more on the bigger structural changes to the approach (eg switching back to docMap for merging deletes, adding SegmentReaderPool.release, which should write changes to the dir &amp;amp; calling it from all places that do a .get(), and the other comments above) before trying to get all tests to pass.&lt;/p&gt;</comment>
                    <comment id="12679702" author="jasonrutherglen" created="Fri, 6 Mar 2009 19:59:41 +0000"  >&lt;blockquote&gt;&lt;p&gt; On an explicit commit(), we should also sweep the pool and&lt;br/&gt;
write changes to disk for any SR that has pending changes. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I created SegmentReaderPool.commitAll which commits changes for all&lt;br/&gt;
SRs in the pool in IW.startCommit.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;applyDeletes at the top of commitMergedDeletes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Removed&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;switching back to docMap for merging deletes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Where should I get the numDeletedDocs from? (Used for docUpto +=&lt;br/&gt;
docCount - previousReader.numDeletedDocs()) Should the entire&lt;br/&gt;
docIdMap be scanned? Is there an expense in cloning the segment&lt;br/&gt;
readers besides the extra bitvectors?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;SegmentReaderPool.release is implemented instead of using&lt;br/&gt;
reader.decRef. I think you&apos;re saying put this patch&apos;s decRef logic in&lt;br/&gt;
the SRP.release method? &lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added IW.close to TestIndexReader.testDocsOutOfOrderJIRA140&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;TestTransactions may sometimes be failing legitimately during the&lt;br/&gt;
prepareCommit, the exception can&apos;t be reliably reproduced but perhaps&lt;br/&gt;
another test case can be written that does&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;TestIndexWriterDelete.testErrorAfterApplyDeletes fails due to&lt;br/&gt;
IW.commit not throwing an expected exception &lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12679747" author="mikemccand" created="Fri, 6 Mar 2009 22:27:35 +0000"  >&lt;p&gt;Jason can you resync to trunk?&lt;/p&gt;</comment>
                    <comment id="12679758" author="mikemccand" created="Fri, 6 Mar 2009 23:02:55 +0000"  >
&lt;blockquote&gt;&lt;p&gt;Where should I get the numDeletedDocs from?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;SegmentMerger.getDelCounts()&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should the entire docIdMap be scanned?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, when the before/after delCount is different.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is there an expense in cloning the segment readers besides the extra bitvectors?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Copy-on-write of the bitvectors (time and space) is the biggest cost I&lt;br/&gt;
think.  Since docMap already has everything we need, I think we should&lt;br/&gt;
use it... we could even separate out this change and do it first, if&lt;br/&gt;
you want.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think you&apos;re saying put this patch&apos;s decRef logic in&lt;br/&gt;
the SRP.release method?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually the release method should always commit changes, if there are&lt;br/&gt;
any, when an SR is removed SR from the pool.&lt;/p&gt;

&lt;p&gt;Then, something higher up (merging, once successful) should clear&lt;br/&gt;
changes when it&apos;s safe, so that release doesn&apos;t save anything.&lt;/p&gt;

&lt;p&gt;The &quot;decRef that never commits whenever writer is present&quot; in&lt;br/&gt;
DirectoryIndexReader is too low level, I think.&lt;/p&gt;</comment>
                    <comment id="12679764" author="jasonrutherglen" created="Fri, 6 Mar 2009 23:24:33 +0000"  >&lt;ul&gt;
	&lt;li&gt;The patch is updated to trunk, in most tests &quot;there are still open&lt;br/&gt;
files&quot; failures occur now (maybe it&apos;s not related to the latest revision)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;mergeMiddle isn&apos;t synchronized so if we use a pooled reader&lt;br/&gt;
(instead of a frozen clone) couldn&apos;t deletes be applied to the SR as&lt;br/&gt;
merging is happening? &lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12679939" author="mikemccand" created="Sun, 8 Mar 2009 01:14:34 +0000"  >&lt;blockquote&gt;
&lt;p&gt;mergeMiddle isn&apos;t synchronized so if we use a pooled reader&lt;br/&gt;
(instead of a frozen clone) couldn&apos;t deletes be applied to the SR as&lt;br/&gt;
merging is happening?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hmm &amp;#8211; good point.  You&apos;re right, we need to clone the reader up front, so deletions don&apos;t change during the merging process.&lt;/p&gt;

&lt;p&gt;In which case let&apos;s just stick with the current approach in the patch?&lt;/p&gt;</comment>
                    <comment id="12682690" author="mikemccand" created="Tue, 17 Mar 2009 15:09:12 +0000"  >&lt;p&gt;Jason can I have the conch here?  (Ie take your patch and make some changes / iterate).  Are all of your changes included in the last patch?&lt;/p&gt;</comment>
                    <comment id="12682707" author="jasonrutherglen" created="Tue, 17 Mar 2009 16:06:44 +0000"  >&lt;p&gt;Hi Mike, yes please!  I have not had time to work on it.  All my changes are in the last patch.  I can clean it up, but it would not be until later today.&lt;/p&gt;</comment>
                    <comment id="12682720" author="mikemccand" created="Tue, 17 Mar 2009 16:49:11 +0000"  >&lt;p&gt;OK, don&apos;t worry about cleaning things up &amp;#8211; I&apos;ll start from what&apos;s here now.  Thanks!&lt;/p&gt;</comment>
                    <comment id="12689887" author="mikemccand" created="Fri, 27 Mar 2009 12:45:11 +0000"  >&lt;p&gt;New patch attached.  All tests pass.  Back-compat tests pass with no&lt;br/&gt;
changes.&lt;/p&gt;

&lt;p&gt;I made a number of changes, added asserts, cleaned things up, added&lt;br/&gt;
javadocs, CHANGES entry, etc.&lt;/p&gt;

&lt;p&gt;I try to consistently refer to this as &quot;near real-time search&quot;.&lt;br/&gt;
Calling it realtime is overstating it, especially when you compare it&lt;br/&gt;
to what &quot;realtime operating systems&quot; do.&lt;/p&gt;

&lt;p&gt;I also added IndexWriter.setMergedSegmentWarmer(..) and abstract base&lt;br/&gt;
class so the caller can have a merged segment warmed before it&apos;s&lt;br/&gt;
committed to the index.  This is important for reducing turnaround&lt;br/&gt;
time after merges are completed; eg it means you can go ahead adding&lt;br/&gt;
new docs/deletes, and opening new readers, while the merged segment is&lt;br/&gt;
being warmed.&lt;/p&gt;

&lt;p&gt;Net/net I think the approach here is sound, and it&apos;s a good step&lt;br/&gt;
forward.  I think we can get this in for 2.9.&lt;/p&gt;

&lt;p&gt;But, I added a few nocommits that we still need to figure out.&lt;/p&gt;

&lt;p&gt;Otherwise this is close to committable, though I&apos;d like to let it age&lt;br/&gt;
for a while so people can look/test.&lt;/p&gt;

&lt;p&gt;We also still need to pursue in-memory transactional data structures&lt;br/&gt;
for representing deletes/norms (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1526&quot; title=&quot;For near real-time search, use paged copy-on-write BitVector impl&quot;&gt;&lt;del&gt;LUCENE-1526&lt;/del&gt;&lt;/a&gt; is already open for&lt;br/&gt;
this, and it should not block this issue).&lt;/p&gt;

&lt;p&gt;Next up I plan to run some basic tests to see what the &quot;typical&quot; delay&lt;br/&gt;
is for opening a near-realtime reader...&lt;/p&gt;</comment>
                    <comment id="12690019" author="mikemccand" created="Fri, 27 Mar 2009 19:43:20 +0000"  >&lt;p&gt;OK I ran a basic initial test of the latency when opening a near&lt;br/&gt;
real-time reader.&lt;/p&gt;

&lt;p&gt;Using contrib/benchmark, I index wikipedia docs like normal, but then&lt;br/&gt;
I added a NearRealTimeReaderTask, which runs a BG thread that once&lt;br/&gt;
every N (I did 3) seconds it gets a new reader from the writer.&lt;/p&gt;

&lt;p&gt;Then it does a simple search for term &quot;1&quot; in the body, and sorts by&lt;br/&gt;
the docdate field.&lt;/p&gt;

&lt;p&gt;I measured milli-seconds to reopen and to run the search, and plot&lt;br/&gt;
those as a function of index size.&lt;/p&gt;

&lt;p&gt;I ran two tests.  The first (attached as ssd.png) stores the index on&lt;br/&gt;
an Intel X25M solid-state disk; the second (attached as magnetic.png)&lt;br/&gt;
on a WD Velociraptor.&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The reopen time is ~700 msec in both cases, and doesn&apos;t change&lt;br/&gt;
    much as index grows (which is nice).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It is quite noisy, likely due to merges committing.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I logged (but did not graph) the flush time vs actual reopen time,&lt;br/&gt;
    and it&apos;s the flush time that dominates.  This is good because with&lt;br/&gt;
    a slower indexing rate, this flush time would go way down.  My&lt;br/&gt;
    guess is flushing is CPU bound not IO bound.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The search time ramps up linearly (expected), and also shows&lt;br/&gt;
    spikes due to merging.  There&apos;s one massive spike at the end of&lt;br/&gt;
    the SSD one that&apos;s odd (did not correspond to reopening after a&lt;br/&gt;
    merge, though perhaps during a merge).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;This is a somewhat overly stressful test because I&apos;m indexing docs&lt;br/&gt;
    at full speed.  Whereas I&apos;d expect for the typical near realtime&lt;br/&gt;
    search app, the docs would usually be trickling in more slowly and&lt;br/&gt;
    a reopen would happen after just a few docs.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SSD and magnetic look pretty darn similar, though magnetic shows&lt;br/&gt;
    more noise and maybe is more affected by merges.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I&apos;m doing no deletions in this test, but the typical near&lt;br/&gt;
    real-time app presumably would.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12693465" author="mikemccand" created="Sat, 28 Mar 2009 16:06:23 +0000"  >&lt;p&gt;Disregard the search time in the above results... we have a sneaky bug&lt;br/&gt;
(&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1579&quot; title=&quot;Cloned SegmentReaders fail to share FieldCache entries&quot;&gt;&lt;del&gt;LUCENE-1579&lt;/del&gt;&lt;/a&gt;) that is causing FieldCache to not be re-used for shared&lt;br/&gt;
segments in a reopened reader.  This makes the search time after&lt;br/&gt;
reopen far worse than it should be.&lt;/p&gt;</comment>
                    <comment id="12693498" author="mikemccand" created="Sat, 28 Mar 2009 22:06:30 +0000"  >&lt;p&gt;New patch:  Fixed a few small issues... and made some changes to&lt;br/&gt;
contrib/benchmark to help in running more realistic near real-time&lt;br/&gt;
tests:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Fixed LineDocMaker to properly set &quot;docid&quot; primary key field.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added UpdateDocTask that calls IndexWriter.updateDocument,&lt;br/&gt;
    randomly picking a docid.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added NearRealTimeReader task, that creates BG thread that every N&lt;br/&gt;
    seconds opens a reader, runs a static search and prints results.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This patch also contains patch from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1579&quot; title=&quot;Cloned SegmentReaders fail to share FieldCache entries&quot;&gt;&lt;del&gt;LUCENE-1579&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, using this you can 1) create a large index, 2) create an alg that&lt;br/&gt;
does doc updates at a fixed rate and then tests the near real-time&lt;br/&gt;
reader performance.&lt;/p&gt;</comment>
                    <comment id="12693559" author="mikemccand" created="Sun, 29 Mar 2009 14:55:58 +0100"  >
&lt;p&gt;OK using the last patch, I ran another near real-time test, using this&lt;br/&gt;
alg:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer

doc.maker=org.apache.lucene.benchmark.byTask.feeds.LineDocMaker

merge.policy=org.apache.lucene.index.LogDocMergePolicy

docs.file=/Volumes/External/lucene/wiki.txt
doc.stored = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
doc.term.vector = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
doc.add.log.step=10
max.field.length=2147483647

directory=FSDirectory
autocommit=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
compound=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
merge.factor = 10
ram.flush.mb = 128
doc.maker.forever = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
doc.random.id.limit = 3204040

work.dir=/lucene/work

{ &lt;span class=&quot;code-quote&quot;&gt;&quot;BuildIndex&quot;&lt;/span&gt;
  - OpenIndex
  - NearRealtimeReader(1)
   { &lt;span class=&quot;code-quote&quot;&gt;&quot;UpdateDocs&quot;&lt;/span&gt; UpdateDoc &amp;gt; : 100000 : 50/sec
  - CloseIndex
}

RepSumByPrefRound BuildIndex
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It opens a full (3.2M docs, previously built) wikipedia index, then&lt;br/&gt;
randomly selects a doc and updates it (deletes old, adds new) at the&lt;br/&gt;
rate of 50 docs/sec.  Then, once per second I open a new reader, do&lt;br/&gt;
the same search (term &quot;1&quot;, sorted by date).&lt;/p&gt;

&lt;p&gt;I attached another graph (ssd2.png) with the results, showing reopen &amp;amp;&lt;br/&gt;
search time as a function of how many updates have been done; rough&lt;br/&gt;
comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Search time is pretty constant ~35 msec, except occassional&lt;br/&gt;
    glitches where it goes as high as ~340 msec.  Net/net very&lt;br/&gt;
    reasonable I think.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Search time is remarkably non-noisy, except for occasional&lt;br/&gt;
    spikes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Reopen time is also fast (~ 40 msec) but is more noisy.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;s not clear the merges are really impacting things that much.&lt;br/&gt;
    It could simply be that I didn&apos;t run test for long enough for a&lt;br/&gt;
    big merge to run.  Also, this index has no stored fields nor term&lt;br/&gt;
    vectors, so if we added those, merges would get slower.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;This is a better test than last one, since it&apos;s doing some deletes&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Since I open writer with autoCommit false, and near-realtime&lt;br/&gt;
    carries all pending deletes in RAM, no *.del file ever gets&lt;br/&gt;
    written to the index&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12693922" author="jasonrutherglen" created="Mon, 30 Mar 2009 23:07:44 +0100"  >&lt;p&gt;Mike, nice work!  &lt;/p&gt;

&lt;p&gt;I will hopefully test this week.&lt;/p&gt;</comment>
                    <comment id="12693932" author="mikemccand" created="Mon, 30 Mar 2009 23:49:10 +0100"  >&lt;p&gt;Nice work to you too &amp;#8211; I just picked things up where you left off!  I&apos;m still working on the nocommits, but I think we can commit this soon.&lt;/p&gt;</comment>
                    <comment id="12694166" author="mikemccand" created="Tue, 31 Mar 2009 17:07:46 +0100"  >&lt;p&gt;New patch: sync&apos;d to trunk, cleaned up the nocommits (some fixing, some turned into TODOs).&lt;/p&gt;

&lt;p&gt;I&apos;d like to add some more tests, but otherwise I think this is ready to commit.&lt;/p&gt;</comment>
                    <comment id="12694220" author="mikemccand" created="Tue, 31 Mar 2009 20:22:44 +0100"  >&lt;p&gt;Attached patch: added more test cases, and fixed the near real-time reader to NOT try to open segments in a foreign Directory (which happens when addIndexes* is running).&lt;/p&gt;</comment>
                    <comment id="12694920" author="mikemccand" created="Thu, 2 Apr 2009 10:00:53 +0100"  >&lt;p&gt;Added another test case to TestIndexWriterReader, stress testing adding/deleting docs while constant opening near real-time reader.&lt;/p&gt;</comment>
                    <comment id="12695185" author="jasonrutherglen" created="Fri, 3 Apr 2009 01:25:49 +0100"  >&lt;p&gt;In ReaderPool.get(SegmentInfo info, boolean doOpenStores, int readBufferSize) the readBufferSize needs to be passed into SegmentReader.get&lt;/p&gt;</comment>
                    <comment id="12695306" author="mikemccand" created="Fri, 3 Apr 2009 10:19:07 +0100"  >&lt;p&gt;Good catch!  I&apos;ll fix.&lt;/p&gt;</comment>
                    <comment id="12696444" author="mikemccand" created="Tue, 7 Apr 2009 10:08:00 +0100"  >&lt;p&gt;I think NRT search is finally ready to go in... I&apos;ll wait another day or two.&lt;/p&gt;</comment>
                    <comment id="12697567" author="mikemccand" created="Thu, 9 Apr 2009 18:18:13 +0100"  >&lt;p&gt;I just committed this.  Thanks Jason!&lt;/p&gt;</comment>
                    <comment id="12700354" author="jasonrutherglen" created="Fri, 17 Apr 2009 23:19:31 +0100"  >&lt;p&gt;I noticed NearRealtimeReaderTask is in trunk, can you include the .alg?  How does one create a line based wiki file?&lt;/p&gt;</comment>
                    <comment id="12700414" author="shaie" created="Sat, 18 Apr 2009 03:32:00 +0100"  >&lt;p&gt;look at extractWikipedia.alg, which uses the EnwikiDocMaker, the enwiki.xml file and the WriteLineDoc task. BTW, with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1591&quot; title=&quot;Enable bzip compression in benchmark&quot;&gt;&lt;del&gt;LUCENE-1591&lt;/del&gt;&lt;/a&gt; you can run this alg with bzip.compression=true and feed it with the .bz2 file rather than the xml.&lt;/p&gt;</comment>
                    <comment id="12700459" author="mikemccand" created="Sat, 18 Apr 2009 12:08:08 +0100"  >&lt;p&gt;This is the alg I use:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
{ &lt;span class=&quot;code-quote&quot;&gt;&quot;BuildIndex&quot;&lt;/span&gt;
  - OpenIndex
  - NearRealtimeReader(1)
   { &lt;span class=&quot;code-quote&quot;&gt;&quot;UpdateDocs&quot;&lt;/span&gt; UpdateDoc &amp;gt; : 100000 : 50/sec
  - CloseIndex
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ie, using a BG thread, the NRT reader reopens once per second, runs a fixed search, and prints timing info.&lt;/p&gt;

&lt;p&gt;Meanwhile, a single thread replaces the docs at the rate of 50/sec up to 100K docs.&lt;/p&gt;</comment>
                    <comment id="12700899" author="jasonrutherglen" created="Mon, 20 Apr 2009 20:19:54 +0100"  >&lt;p&gt;We need an IndexWriter.getMergedSegmentWarmer method?&lt;/p&gt;</comment>
                    <comment id="12702461" author="mikemccand" created="Fri, 24 Apr 2009 18:32:51 +0100"  >&lt;blockquote&gt;&lt;p&gt;We need an IndexWriter.getMergedSegmentWarmer method?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I just committed; thanks!&lt;/p&gt;</comment>
                    <comment id="12720427" author="jasonrutherglen" created="Wed, 17 Jun 2009 01:05:00 +0100"  >&lt;p&gt;In LogMergePolicy.findMergesToExpungeDeletes I think we need to&lt;br/&gt;
change how deletes are checked for. I added this change into&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt;, however as we&apos;re about to release 2.9, we probably&lt;br/&gt;
need to implement it. &lt;/p&gt;

&lt;p&gt;Currently we check the info for deletes, however with this&lt;br/&gt;
patch, I think we need to check the segmentReader which could&lt;br/&gt;
have deletes that don&apos;t show up in the info.&lt;/p&gt;</comment>
                    <comment id="12720569" author="mikemccand" created="Wed, 17 Jun 2009 09:56:25 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Currently we check the info for deletes, however with this&lt;br/&gt;
patch, I think we need to check the segmentReader which could&lt;br/&gt;
have deletes that don&apos;t show up in the info.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good catch!  Can you open a new issue &amp;amp; attach patch?  Though: how would you do this?  Right now MergePolicy never receives a SegmentReader, and makes all its decisions based on the SegmentInfo.  Each SegmentReader tracks its own pendingDelCount... maybe we add a private pendingDelCount to SegmentInfo, and change SegmentReader to use that instead?  That&apos;d be a single source, and then the merge policy could retrieve it...&lt;/p&gt;</comment>
                    <comment id="12725779" author="jasonrutherglen" created="Tue, 30 Jun 2009 21:10:30 +0100"  >&lt;p&gt;I think we will want to do something like what field cache does&lt;br/&gt;
with CreationPlaceholder for IndexWriter.readerPool. Otherwise&lt;br/&gt;
we have the (I think somewhat problematic) issue of all other&lt;br/&gt;
readerPool.get* methods waiting for an SR to warm. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; SegmentReader get(SegmentInfo info, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; doOpenStores, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; readBufferSize) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (poolReaders) {
        readBufferSize = BufferedIndexInput.BUFFER_SIZE;
      }

      SegmentReader sr = (SegmentReader) readerMap.get(info);
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (sr == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-comment&quot;&gt;// TODO: we may want to avoid doing &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// Returns a ref, which we xfer to readerMap:
&lt;/span&gt;        sr = SegmentReader.get(info, readBufferSize, doOpenStores);
        readerMap.put(info, sr);
      } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doOpenStores) {
        sr.openDocStores();
      }

      &lt;span class=&quot;code-comment&quot;&gt;// Return a ref to our caller
&lt;/span&gt;      sr.incRef();
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; sr;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12404425" name="LUCENE-1516.patch" size="99691" author="mikemccand" created="Thu, 2 Apr 2009 10:00:53 +0100" />
                    <attachment id="12404257" name="LUCENE-1516.patch" size="97482" author="mikemccand" created="Tue, 31 Mar 2009 20:22:44 +0100" />
                    <attachment id="12404248" name="LUCENE-1516.patch" size="92087" author="mikemccand" created="Tue, 31 Mar 2009 17:07:46 +0100" />
                    <attachment id="12404069" name="LUCENE-1516.patch" size="97131" author="mikemccand" created="Sat, 28 Mar 2009 22:06:30 +0000" />
                    <attachment id="12403801" name="LUCENE-1516.patch" size="78114" author="mikemccand" created="Fri, 27 Mar 2009 12:45:11 +0000" />
                    <attachment id="12401655" name="LUCENE-1516.patch" size="98334" author="jasonrutherglen" created="Fri, 6 Mar 2009 23:24:33 +0000" />
                    <attachment id="12401641" name="LUCENE-1516.patch" size="98287" author="jasonrutherglen" created="Fri, 6 Mar 2009 19:59:41 +0000" />
                    <attachment id="12401548" name="LUCENE-1516.patch" size="84661" author="jasonrutherglen" created="Thu, 5 Mar 2009 21:37:59 +0000" />
                    <attachment id="12401474" name="LUCENE-1516.patch" size="82769" author="jasonrutherglen" created="Thu, 5 Mar 2009 01:11:10 +0000" />
                    <attachment id="12401472" name="LUCENE-1516.patch" size="82577" author="jasonrutherglen" created="Thu, 5 Mar 2009 00:42:51 +0000" />
                    <attachment id="12401327" name="LUCENE-1516.patch" size="82933" author="jasonrutherglen" created="Tue, 3 Mar 2009 18:31:39 +0000" />
                    <attachment id="12401272" name="LUCENE-1516.patch" size="78867" author="jasonrutherglen" created="Tue, 3 Mar 2009 00:33:26 +0000" />
                    <attachment id="12401270" name="LUCENE-1516.patch" size="77735" author="jasonrutherglen" created="Mon, 2 Mar 2009 23:50:28 +0000" />
                    <attachment id="12401079" name="LUCENE-1516.patch" size="82836" author="jasonrutherglen" created="Fri, 27 Feb 2009 01:20:38 +0000" />
                    <attachment id="12400981" name="LUCENE-1516.patch" size="73694" author="jasonrutherglen" created="Thu, 26 Feb 2009 01:33:44 +0000" />
                    <attachment id="12400954" name="LUCENE-1516.patch" size="66502" author="jasonrutherglen" created="Wed, 25 Feb 2009 17:11:28 +0000" />
                    <attachment id="12400898" name="LUCENE-1516.patch" size="65201" author="jasonrutherglen" created="Wed, 25 Feb 2009 02:07:22 +0000" />
                    <attachment id="12400896" name="LUCENE-1516.patch" size="64830" author="jasonrutherglen" created="Wed, 25 Feb 2009 01:13:32 +0000" />
                    <attachment id="12400888" name="LUCENE-1516.patch" size="54047" author="jasonrutherglen" created="Tue, 24 Feb 2009 22:53:02 +0000" />
                    <attachment id="12400690" name="LUCENE-1516.patch" size="48001" author="jasonrutherglen" created="Sun, 22 Feb 2009 07:40:04 +0000" />
                    <attachment id="12400646" name="LUCENE-1516.patch" size="37838" author="jasonrutherglen" created="Sat, 21 Feb 2009 01:36:11 +0000" />
                    <attachment id="12400617" name="LUCENE-1516.patch" size="43656" author="jasonrutherglen" created="Fri, 20 Feb 2009 17:26:36 +0000" />
                    <attachment id="12400557" name="LUCENE-1516.patch" size="25179" author="jasonrutherglen" created="Fri, 20 Feb 2009 00:14:17 +0000" />
                    <attachment id="12400368" name="LUCENE-1516.patch" size="25179" author="jasonrutherglen" created="Wed, 18 Feb 2009 01:03:50 +0000" />
                    <attachment id="12400367" name="LUCENE-1516.patch" size="24300" author="jasonrutherglen" created="Wed, 18 Feb 2009 00:34:03 +0000" />
                    <attachment id="12400346" name="LUCENE-1516.patch" size="22786" author="jasonrutherglen" created="Tue, 17 Feb 2009 18:43:55 +0000" />
                    <attachment id="12399872" name="LUCENE-1516.patch" size="18531" author="jasonrutherglen" created="Tue, 10 Feb 2009 01:09:07 +0000" />
                    <attachment id="12397922" name="LUCENE-1516.patch" size="72103" author="jasonrutherglen" created="Wed, 14 Jan 2009 23:50:13 +0000" />
                    <attachment id="12403836" name="magnetic.png" size="42717" author="mikemccand" created="Fri, 27 Mar 2009 19:43:20 +0000" />
                    <attachment id="12404079" name="ssd2.png" size="43117" author="mikemccand" created="Sun, 29 Mar 2009 14:55:58 +0100" />
                    <attachment id="12403835" name="ssd.png" size="39867" author="mikemccand" created="Fri, 27 Mar 2009 19:43:20 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>31.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 11 Jan 2009 17:41:25 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12236</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4268</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>