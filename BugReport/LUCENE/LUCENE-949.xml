<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:31:09 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-949/LUCENE-949.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-949] AnalyzingQueryParser can&apos;t work with leading wildcards.</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-949</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The getWildcardQuery mehtod in AnalyzingQueryParser.java need the following changes to accept leading wildcards:&lt;/p&gt;

&lt;p&gt;	protected Query getWildcardQuery(String field, String termStr) throws ParseException&lt;br/&gt;
	{&lt;br/&gt;
		String useTermStr = termStr;&lt;br/&gt;
		String leadingWildcard = null;&lt;br/&gt;
		if (&quot;*&quot;.equals(field))&lt;/p&gt;
		{
			if (&quot;*&quot;.equals(useTermStr))
				return new MatchAllDocsQuery();
		}
&lt;p&gt;		boolean hasLeadingWildcard = (useTermStr.startsWith(&quot;*&quot;) || useTermStr.startsWith(&quot;?&quot;)) ? true : false;&lt;/p&gt;

&lt;p&gt;		if (!getAllowLeadingWildcard() &amp;amp;&amp;amp; hasLeadingWildcard)&lt;br/&gt;
			throw new ParseException(&quot;&apos;*&apos; or &apos;?&apos; not allowed as first character in WildcardQuery&quot;);&lt;/p&gt;

&lt;p&gt;		if (getLowercaseExpandedTerms())&lt;/p&gt;
		{
			useTermStr = useTermStr.toLowerCase();
		}

&lt;p&gt;		if (hasLeadingWildcard)&lt;/p&gt;
		{
			leadingWildcard = useTermStr.substring(0, 1);
			useTermStr = useTermStr.substring(1);
		}

&lt;p&gt;		List tlist = new ArrayList();&lt;br/&gt;
		List wlist = new ArrayList();&lt;br/&gt;
		/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;somewhat a hack: find/store wildcard chars in order to put them back&lt;/li&gt;
	&lt;li&gt;after analyzing&lt;br/&gt;
		 */&lt;br/&gt;
		boolean isWithinToken = (!useTermStr.startsWith(&quot;?&quot;) &amp;amp;&amp;amp; !useTermStr.startsWith(&quot;*&quot;));&lt;br/&gt;
		isWithinToken = true;&lt;br/&gt;
		StringBuffer tmpBuffer = new StringBuffer();&lt;br/&gt;
		char[] chars = useTermStr.toCharArray();&lt;br/&gt;
		for (int i = 0; i &amp;lt; useTermStr.length(); i++)&lt;br/&gt;
		{&lt;br/&gt;
			if (chars&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; == &apos;?&apos; || chars&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; == &apos;*&apos;)
			&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				if (isWithinToken)				{
					tlist.add(tmpBuffer.toString());
					tmpBuffer.setLength(0);
				}				isWithinToken = false;			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			else&lt;/p&gt;
			&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				if (!isWithinToken)				{
					wlist.add(tmpBuffer.toString());
					tmpBuffer.setLength(0);
				}				isWithinToken = true;			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			tmpBuffer.append(chars&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;);&lt;br/&gt;
		}&lt;br/&gt;
		if (isWithinToken)&lt;/p&gt;
		{
			tlist.add(tmpBuffer.toString());
		}
&lt;p&gt;		else&lt;/p&gt;
		{
			wlist.add(tmpBuffer.toString());
		}&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;		// get Analyzer from superclass and tokenize the term&lt;br/&gt;
		TokenStream source = getAnalyzer().tokenStream(field, new StringReader(useTermStr));&lt;br/&gt;
		org.apache.lucene.analysis.Token t;&lt;/p&gt;

&lt;p&gt;		int countTokens = 0;&lt;br/&gt;
		while (true)&lt;br/&gt;
		{&lt;br/&gt;
			try&lt;/p&gt;
			{
				t = source.next();
			}
&lt;p&gt;			catch (IOException e)&lt;/p&gt;
			{
				t = null;
			}
&lt;p&gt;			if (t == null)&lt;/p&gt;
			{
				break;
			}
&lt;p&gt;			if (!&quot;&quot;.equals(t.termText()))&lt;br/&gt;
			{&lt;br/&gt;
				try&lt;/p&gt;
				{
					tlist.set(countTokens++, t.termText());
				}
&lt;p&gt;				catch (IndexOutOfBoundsException ioobe)&lt;/p&gt;
				{
					countTokens = -1;
				}
&lt;p&gt;			}&lt;br/&gt;
		}&lt;br/&gt;
		try&lt;/p&gt;
		{
			source.close();
		}
&lt;p&gt;		catch (IOException e)&lt;/p&gt;
		{
			// ignore
		}

&lt;p&gt;		if (countTokens != tlist.size())&lt;/p&gt;
		{
			/*
			 * this means that the analyzer used either added or consumed
			 * (common for a stemmer) tokens, and we can&apos;t build a WildcardQuery
			 */
			throw new ParseException(&quot;Cannot build WildcardQuery with analyzer &quot; + getAnalyzer().getClass()
					+ &quot; - tokens added or lost&quot;);
		}

&lt;p&gt;		if (tlist.size() == 0)&lt;/p&gt;
		{
			return null;
		}
&lt;p&gt;		else if (tlist.size() == 1)&lt;br/&gt;
		{&lt;br/&gt;
			if (wlist.size() == 1)&lt;br/&gt;
			{&lt;br/&gt;
				/*&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;if wlist contains one wildcard, it must be at the end,&lt;/li&gt;
	&lt;li&gt;because: 1) wildcards at 1st position of a term by&lt;/li&gt;
	&lt;li&gt;QueryParser where truncated 2) if wildcard was &lt;b&gt;not&lt;/b&gt; in end,&lt;/li&gt;
	&lt;li&gt;there would be &lt;b&gt;two&lt;/b&gt; or more tokens&lt;br/&gt;
				 */&lt;br/&gt;
				StringBuffer sb = new StringBuffer();&lt;br/&gt;
				if (hasLeadingWildcard)
				{
					// adding leadingWildcard
					sb.append(leadingWildcard);
				}&lt;br/&gt;
				sb.append((String) tlist.get(0));&lt;br/&gt;
				sb.append(wlist.get(0).toString());&lt;br/&gt;
				return super.getWildcardQuery(field, sb.toString());&lt;br/&gt;
			}&lt;br/&gt;
			else if (wlist.size() == 0 &amp;amp;&amp;amp; hasLeadingWildcard)&lt;br/&gt;
			{&lt;br/&gt;
				/*&lt;br/&gt;
				 * if wlist contains no wildcard, it must be at 1st position&lt;br/&gt;
				 */&lt;br/&gt;
				StringBuffer sb = new StringBuffer();&lt;br/&gt;
				if (hasLeadingWildcard)&lt;br/&gt;
				{					// adding leadingWildcard					sb.append(leadingWildcard);				}
&lt;p&gt;				sb.append((String) tlist.get(0));&lt;br/&gt;
				sb.append(wlist.get(0).toString());&lt;br/&gt;
				return super.getWildcardQuery(field, sb.toString());&lt;br/&gt;
			}&lt;br/&gt;
			else&lt;/p&gt;
			{
				/*
				 * we should never get here! if so, this method was called with
				 * a termStr containing no wildcard ...
				 */
				throw new IllegalArgumentException(&quot;getWildcardQuery called without wildcard&quot;);
			}
&lt;p&gt;		}&lt;br/&gt;
		else&lt;br/&gt;
		{&lt;br/&gt;
			/*&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;the term was tokenized, let&apos;s rebuild to one token with wildcards&lt;/li&gt;
	&lt;li&gt;put back in postion&lt;br/&gt;
			 */&lt;br/&gt;
			StringBuffer sb = new StringBuffer();&lt;br/&gt;
			if (hasLeadingWildcard)
			{
				// adding leadingWildcard
				sb.append(leadingWildcard);
			}
&lt;p&gt;			for (int i = 0; i &amp;lt; tlist.size(); i++)&lt;/p&gt;
			&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				sb.append((String) tlist.get(i));				if (wlist != null &amp;amp;&amp;amp; wlist.size() &amp;gt; i)				{
					sb.append((String) wlist.get(i));
				}			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;			return super.getWildcardQuery(field, sb.toString());&lt;br/&gt;
		}&lt;br/&gt;
	}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
            <key id="12372906">LUCENE-949</key>
            <summary>AnalyzingQueryParser can&apos;t work with leading wildcards.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="steve_rowe">Steve Rowe</assignee>
                                <reporter username="stefan.klein">Stefan Klein</reporter>
                        <labels>
                    </labels>
                <created>Tue, 3 Jul 2007 13:41:35 +0100</created>
                <updated>Fri, 10 May 2013 23:57:23 +0100</updated>
                    <resolved>Tue, 7 May 2013 00:03:19 +0100</resolved>
                            <version>2.2</version>
                                <fixVersion>5.0</fixVersion>
                <fixVersion>4.4</fixVersion>
                                <component>core/queryparser</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>6</watches>
                                                    <comments>
                    <comment id="12986910" author="shaie" created="Wed, 26 Jan 2011 09:13:41 +0000"  >&lt;p&gt;Way outdated code and it&apos;s not really clear what needs to be done. If this is still a problem, I suggest reopening and post a proper patch.&lt;/p&gt;</comment>
                    <comment id="13108413" author="vidda" created="Tue, 20 Sep 2011 08:18:04 +0100"  >&lt;p&gt;Hi.&lt;/p&gt;

&lt;p&gt;Is there some way to re-open and fix this behavior/bug in AnalyzingQueryParser?&lt;br/&gt;
I have discover this opened (and closed 4 years later) bug. We are working with Lucene 3.2 and we use AnalyzingQueryParser because we need to parse with analyzer every query, even wildcard queries. &lt;/p&gt;

&lt;p&gt;This works great with most queries, and with the ones that don&apos;t work (for example in cases analyzer add/remove words and query have wildcards) we use QueryParser although it doesn&apos;t analyze wildcard queries.&lt;/p&gt;

&lt;p&gt;In our application there are some cases when we need to allow leading wildcard queries, and AnalyzingQueryParser fails although I set to true &apos;AllowLeadingWildcard&apos; flag. Strings like &apos;&lt;b&gt;ucene&apos; is converted into WildcardQuery like this &apos;ucene&lt;/b&gt;&apos;. This is another strange behavior, the ending wildcard.&lt;/p&gt;

&lt;p&gt;I know QueryParser doesn&apos;t have this leading wildcard bug, but I need to parse query (I am Spanish and we have special characters (&#241;, &#252;, vocals with accent on them) and we parse indexed data, and to search we need to parse query too.&lt;/p&gt;



&lt;p&gt;Thanks in advance. Regards!&lt;/p&gt;
</comment>
                    <comment id="13108415" author="vidda" created="Tue, 20 Sep 2011 08:22:04 +0100"  >&lt;p&gt;Sorry, is my first post here and I didn&apos;t know special characters like &lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;*&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; is bold. For that mistake, in my previous comment there one bold line that I didn&apos;t want to be bold. This is what I want to put:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&apos;*ucene&apos; is converted into WildcardQuery like this &apos;ucene*&apos;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13620032" author="dsmiley" created="Tue, 2 Apr 2013 18:36:16 +0100"  >&lt;p&gt;Reopening at the request of &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tallison%40mitre.org&quot; class=&quot;user-hover&quot; rel=&quot;tallison@mitre.org&quot;&gt;Tim Allison&lt;/a&gt; who intends to attach a patch.  Regular users can&apos;t re-open JIRA issues, apparently.&lt;/p&gt;</comment>
                    <comment id="13620036" author="tallison@mitre.org" created="Tue, 2 Apr 2013 18:40:15 +0100"  >&lt;p&gt;This allows for leading wildcards in the AnalyzingQueryParser if setAllowLeadingWildcard is set to true.  &lt;/p&gt;</comment>
                    <comment id="13626606" author="rcmuir" created="Tue, 9 Apr 2013 14:33:00 +0100"  >&lt;p&gt;Hello Timothy, can you turn these changes into a patch?&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;http://wiki.apache.org/lucene-java/HowToContribute#Creating_a_patch&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/HowToContribute#Creating_a_patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                    <comment id="13629337" author="tallison@mitre.org" created="Thu, 11 Apr 2013 21:42:43 +0100"  >&lt;p&gt;First patch.  Let me know if this actually works.&lt;/p&gt;</comment>
                    <comment id="13630226" author="rcmuir" created="Fri, 12 Apr 2013 17:03:17 +0100"  >&lt;p&gt;Thank you Timothy. the patch looks very good to me, thanks also for adding tests!&lt;/p&gt;

&lt;p&gt;A few questions:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The regex simplification looks good to me, but I&apos;m not a regex expert. Maybe someone that is better with regex like &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=steve_rowe&quot; class=&quot;user-hover&quot; rel=&quot;steve_rowe&quot;&gt;Steve Rowe&lt;/a&gt; can have a look. If nobody objects after a few days I&apos;m inclined to move forward though.&lt;/li&gt;
	&lt;li&gt;What about the case where someone has escaped wildcards? I&apos;m not sure whats even happening today in this case... perhaps it already has surprising behavior and should really be a separate bug, or maybe its working and I just dont see it. I doubt its tested though... but it seems the regex would need to accomodate that?&lt;/li&gt;
	&lt;li&gt;The String.format() invocations should probably pass getLocale() from the superclass as the first argument, rather than depending on the default locale. Since they are locale sensitive I think its best to use the one that someone configured on the queryparser (e.g. via setLocale)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13630354" author="steve_rowe" created="Fri, 12 Apr 2013 18:15:52 +0100"  >&lt;p&gt;Hi Timothy, I agree with Robert, the patch reduces line count while improving clarity and adding functionality - sweet!&lt;/p&gt;

&lt;p&gt;A few nitpicks (+1 otherwise):&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;You don&apos;t handle escaped metachars ? and * in the query, though the original doesn&apos;t either, so this shouldn&apos;t stop the patch from being committed.&lt;/li&gt;
	&lt;li&gt;The &lt;tt&gt;(?s)&lt;/tt&gt; has no effect in &lt;tt&gt;&quot;(?s)(&lt;span class=&quot;error&quot;&gt;&amp;#91;^\\?\\*&amp;#93;&lt;/span&gt;+)&quot;&lt;/tt&gt;, since it only affects the expansion of the dot metachar, which isn&apos;t present (see &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#DOTALL&quot; class=&quot;external-link&quot;&gt;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#DOTALL&lt;/a&gt;): an inverted charset will always include newlines unless the charset to be inverted explicitly includes them.  Of course, this is all moot, since the query parser will already have split on whitespace before sending &lt;tt&gt;termStr&lt;/tt&gt; to &lt;tt&gt;getWildcardQuery()&lt;/tt&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;You can drop the following line in &lt;tt&gt;normalizeMustBeSingleTerm()&lt;/tt&gt;: &lt;tt&gt;nonWildcardMatcher.reset(termStr);&lt;/tt&gt;, since nonWildcardMatcher is never reused.&lt;/li&gt;
	&lt;li&gt;The presence of term breaking chars is not the only condition under which analysis of a single term can produce multiple terms (e.g. synonyms, multiple readings), so the following exception message should be generalized: &quot;There is a term breaking character between %s and %s&quot;.&lt;/li&gt;
	&lt;li&gt;In your new test, the following assertion message seems to have too many words? &quot;Testing wildcard with wildcard with initial wildcard not allowed&quot;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13630370" author="steve_rowe" created="Fri, 12 Apr 2013 18:25:42 +0100"  >&lt;p&gt;One more minor thing: the javadoc on &lt;tt&gt;getWildcardQuery()&lt;/tt&gt; needs fixing - probably previously should have been &quot;&lt;tt&gt;but not for &amp;lt;code&amp;gt;user*&amp;lt;/code&amp;gt;&lt;/tt&gt;&quot; to illustrate not being called for prefix queries, but with your patch it&apos;s just plain wrong:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;* Example: will be called for &amp;lt;code&amp;gt;H?user&amp;lt;/code&amp;gt; or for &amp;lt;code&amp;gt;H*user&amp;lt;/code&amp;gt; 
* but not for &amp;lt;code&amp;gt;*user&amp;lt;/code&amp;gt;.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13635415" author="tallison@mitre.org" created="Thu, 18 Apr 2013 18:49:40 +0100"  >&lt;p&gt;Thank you very much for the feedback. I refactored a bit and added escaped wildcard handling.  Let me know how this looks.&lt;/p&gt;</comment>
                    <comment id="13635425" author="steve_rowe" created="Thu, 18 Apr 2013 18:54:29 +0100"  >&lt;p&gt;Tim, thanks, I&apos;ll take a look at your new patch later today.&lt;/p&gt;

&lt;p&gt;FYI, you shouldn&apos;t remove old patches - when you upload a file with the same name, the older versions still appear, but their names appear in grey, and you can see the date/time each was uploaded.  See e.g. &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-3251&quot; title=&quot;dynamically add fields to schema&quot;&gt;&lt;del&gt;SOLR-3251&lt;/del&gt;&lt;/a&gt;, where I&apos;ve uploaded the same-named patch multiple times.&lt;/p&gt;</comment>
                    <comment id="13642457" author="tallison@mitre.org" created="Fri, 26 Apr 2013 01:59:37 +0100"  >&lt;p&gt;Refactored a bit and added a few more tests.&lt;/p&gt;</comment>
                    <comment id="13649555" author="steve_rowe" created="Mon, 6 May 2013 08:11:39 +0100"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tallison%40mitre.org&quot; class=&quot;user-hover&quot; rel=&quot;tallison@mitre.org&quot;&gt;Tim Allison&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Sorry it took so long, I&apos;ve attached a patch based on your patch with some fixes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Removed tabs.&lt;/li&gt;
	&lt;li&gt;Restored license header and class javadoc to &lt;tt&gt;AnalyzingQueryParser.java&lt;/tt&gt; (your patch removed them for some reason?).&lt;/li&gt;
	&lt;li&gt;Converted all code indentation to 2 spaces per level (you had a lot of 3 space per level indentation).&lt;/li&gt;
	&lt;li&gt;Converted the &lt;tt&gt;wildcardPattern&lt;/tt&gt; to allow anything to be escaped, not just backslashes and wildcard chars &apos;?&apos; and &apos;*&apos;.  Also removed the optional backslashes from group 2 (the actual wildcards) - when iterating over wildcardPattern matches, your patch would throw away any number of real wildcards following an escaped wildcard.  I added a test for this.&lt;/li&gt;
	&lt;li&gt;When multiple output tokens are produced (and there should only be one), now reporting all of them in the exception message instead of just the first two.&lt;/li&gt;
	&lt;li&gt;Removed all references to &quot;chunklet&quot; in favor of &quot;output token&quot; - this non-standard terminology made the code harder to read.&lt;/li&gt;
	&lt;li&gt;Changed descriptions of multiple output tokens to not necessarily be as the result of splitting (e.g. synonyms).&lt;/li&gt;
	&lt;li&gt;In &lt;tt&gt;analyzeSingleChunk()&lt;/tt&gt;, moved exception throwing to the source of problems.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I also added a &lt;tt&gt;CHANGES.txt&lt;/tt&gt; entry.  &lt;/p&gt;

&lt;p&gt;Tim, let me know if you think my changes are okay - if so, I think it&apos;s ready to commit.&lt;/p&gt;</comment>
                    <comment id="13649560" author="steve_rowe" created="Mon, 6 May 2013 08:20:08 +0100"  >&lt;p&gt;One other change I forgot to mention, Tim: I substituted MockAnalyzer where you used StandardAnalyzer in the test code - this allowed me to remove the analyzers-common dependency you introduced (and also the memory dependency, which didn&apos;t seem to be used for anything in your patch).&lt;/p&gt;</comment>
                    <comment id="13649670" author="tallison@mitre.org" created="Mon, 6 May 2013 12:40:14 +0100"  >&lt;p&gt;Steve, no problem on the delay.  Thank you for your help!  Changes sound great.  Thank you.&lt;/p&gt;
</comment>
                    <comment id="13650208" author="steve_rowe" created="Tue, 7 May 2013 00:03:19 +0100"  >&lt;p&gt;Committed to trunk and branch_4x.&lt;/p&gt;

&lt;p&gt;Thanks Tim!&lt;/p&gt;</comment>
                    <comment id="13654988" author="steve_rowe" created="Fri, 10 May 2013 23:57:23 +0100"  >&lt;p&gt;Although this is labelled as a Major Bug, it feels more like a new feature to me, so I&apos;m not motivated to backport this to 4.3.1.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12581853" name="LUCENE-949.patch" size="24298" author="steve_rowe" created="Mon, 6 May 2013 08:11:39 +0100" />
                    <attachment id="12580635" name="LUCENE-949.patch" size="33999" author="tallison@mitre.org" created="Fri, 26 Apr 2013 01:59:37 +0100" />
                    <attachment id="12579378" name="LUCENE-949.patch" size="10109" author="tallison@mitre.org" created="Thu, 18 Apr 2013 18:48:50 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 26 Jan 2011 09:13:41 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12793</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26780</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>