<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:18:25 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2164/LUCENE-2164.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2164] Make CMS smarter about thread priorities</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2164</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Spinoff from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2161&quot; title=&quot;Some concurrency improvements for NRT&quot;&gt;&lt;del&gt;LUCENE-2161&lt;/del&gt;&lt;/a&gt;...&lt;/p&gt;

&lt;p&gt;The hard throttling CMS does (blocking the incoming thread that wants&lt;br/&gt;
to launch a new merge) can be devastating when it strikes during NRT&lt;br/&gt;
reopen.&lt;/p&gt;

&lt;p&gt;It can easily happen if a huge merge is off and running, but then a&lt;br/&gt;
tiny merge is needed to clean up recently created segments due to&lt;br/&gt;
frequent reopens.&lt;/p&gt;

&lt;p&gt;I think a small change to CMS, whereby it assigns a higher thread&lt;br/&gt;
priority to tiny merges than big merges, should allow us to increase&lt;br/&gt;
the max merge thread count again, and greatly reduce the chance that&lt;br/&gt;
NRT&apos;s reopen would hit this.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12443363">LUCENE-2164</key>
            <summary>Make CMS smarter about thread priorities</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 15 Dec 2009 10:57:49 +0000</created>
                <updated>Fri, 10 May 2013 11:45:00 +0100</updated>
                    <resolved>Mon, 21 Dec 2009 21:39:11 +0000</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12790827" author="jasonrutherglen" created="Tue, 15 Dec 2009 17:12:17 +0000"  >&lt;p&gt;This issue illustrates why the ram dir approach can be useful,&lt;br/&gt;
because small segment merges compete with large segment merges&lt;br/&gt;
for IO, which can spike the turnaround time. With a ram dir, the&lt;br/&gt;
small segments are held in RAM until they&apos;re large enough to be&lt;br/&gt;
placed onto disk. They can then be given the same IO priority as&lt;br/&gt;
the other merging segments which should result in consistent&lt;br/&gt;
reopen times.&lt;/p&gt;</comment>
                    <comment id="12790943" author="mikemccand" created="Tue, 15 Dec 2009 20:51:15 +0000"  >&lt;p&gt;Attached patch.&lt;/p&gt;

&lt;p&gt;Whenever CMS starts a new thread, or an existing thread pulls a new merge to run, it updates the thread priorities (smaller merges get higher thread priority).&lt;/p&gt;

&lt;p&gt;I also increased the default max thread count from 1 to 2.&lt;/p&gt;</comment>
                    <comment id="12790976" author="mikemccand" created="Tue, 15 Dec 2009 21:50:02 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This issue illustrates why the ram dir approach can be useful,&lt;br/&gt;
because small segment merges compete with large segment merges&lt;br/&gt;
for IO, which can spike the turnaround time. With a ram dir, the&lt;br/&gt;
small segments are held in RAM until they&apos;re large enough to be&lt;br/&gt;
placed onto disk. They can then be given the same IO priority as&lt;br/&gt;
the other merging segments which should result in consistent&lt;br/&gt;
reopen times.Make CMS smarter about thread priorities&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m still not convinced we should game the OS, here.&lt;/p&gt;

&lt;p&gt;Ie, the small segments are likely still in the IO cache, so&lt;br/&gt;
we&apos;re probably not really competing for IO on the smaller merges.&lt;/p&gt;

&lt;p&gt;I think it&apos;s when an immense merge is running that we&apos;re in trouble.&lt;br/&gt;
EG I see very long NRT reopen times when such a merge is running.&lt;/p&gt;

&lt;p&gt;I&apos;ve been wondering whether we need to take IO prioritization into our&lt;br/&gt;
own hands.  EG, instead of relying &lt;span class=&quot;error&quot;&gt;&amp;#91;only&amp;#93;&lt;/span&gt; on thread priorities for&lt;br/&gt;
CMS, somehow have the big merge pause until the small merge can&lt;br/&gt;
complete.  This would really be the best way to implement the &quot;allow&lt;br/&gt;
at most 1 merge to run at once&quot;.  I guess we may be able to override&lt;br/&gt;
the mergeAbort to implement this...&lt;/p&gt;

&lt;p&gt;I think a similar &quot;emulate IO prioritization&quot; may help when, eg, a&lt;br/&gt;
large merge/optimize is interfering with ongoing searches.  Yes, some&lt;br/&gt;
of the cost is because the merge is evicting IO cache, but for large&lt;br/&gt;
indexes that don&apos;t fit in RAM, there must be some cost to sharing the&lt;br/&gt;
disk heads, too...&lt;/p&gt;</comment>
                    <comment id="12790979" author="hossman" created="Tue, 15 Dec 2009 22:00:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;I also increased the default max thread count from 1 to 2.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;random thought from the peanut gallery: do we want to go down the &quot;Ergonomics&quot; route and make the default number of threads vary based on Runtime.getRuntime().availableProcessors()&lt;/p&gt;

&lt;p&gt;(ie: 1 on a single threaded box, NUM_PROCESSORS/CONSTANT on multithreaded boxes?)&lt;/p&gt;

&lt;p&gt;?&lt;/p&gt;</comment>
                    <comment id="12790986" author="jasonrutherglen" created="Tue, 15 Dec 2009 22:19:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ve been wondering whether we need to take IO&lt;br/&gt;
prioritization into our own hands. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we discussed IO throttling at the directory level&lt;br/&gt;
before. A controller could be passed to createOutput that has a&lt;br/&gt;
setPriority method. The priority level would be set based on the&lt;br/&gt;
demand for IO from IndexWriter. SegmentMerger could know if it&apos;s&lt;br/&gt;
creating a large segment from the sizes of the source segments,&lt;br/&gt;
and set the IO priority accordingly?&lt;/p&gt;

&lt;p&gt;I wonder what algorithm would be suitable for this?&lt;/p&gt;</comment>
                    <comment id="12791029" author="mikemccand" created="Tue, 15 Dec 2009 23:33:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;do we want to go down the &quot;Ergonomics&quot; route and make the default number of threads vary based on Runtime.getRuntime().availableProcessors()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good idea!  How about something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
max(1, min(3, numberOfCores / 2))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ie, number of cores divided by 2, but floored at 1 and ceiling&apos;d at 3?&lt;/p&gt;

&lt;p&gt;I think 1 BG thread is always good since you gain CPU + IO&lt;br/&gt;
concurrency.  Too many thread (I&apos;m guess above 3) will swamp the IO&lt;br/&gt;
system (unless IO system is SSD).&lt;/p&gt;

&lt;p&gt;This would just be a dynamic default, ie, if you call&lt;br/&gt;
setMaxThreadCount yourself, you override it.&lt;/p&gt;</comment>
                    <comment id="12791039" author="mikemccand" created="Tue, 15 Dec 2009 23:40:33 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think we discussed IO throttling at the directory level&lt;br/&gt;
before. A controller could be passed to createOutput that has a&lt;br/&gt;
setPriority method. The priority level would be set based on the&lt;br/&gt;
demand for IO from IndexWriter. SegmentMerger could know if it&apos;s&lt;br/&gt;
creating a large segment from the sizes of the source segments,&lt;br/&gt;
and set the IO priority accordingly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah we talked about this for the more general case (throttling&lt;br/&gt;
merging when searches are running).  That&apos;s a pretty big change&lt;br/&gt;
though.&lt;/p&gt;

&lt;p&gt;I think for this case we could handle the throttling entirely in CMS,&lt;br/&gt;
by wrapping the OneMerge and overriding the checkAborted method to&lt;br/&gt;
pause the large merge when smaller merge(s) are running.  This would&lt;br/&gt;
force the long merges to stop so that the smaller merges could&lt;br/&gt;
complete without fighting for IO.&lt;/p&gt;

&lt;p&gt;To get a sense of how important this would be, I think we need to&lt;br/&gt;
measure how long it takes a merge to complete when it&apos;s alone vs when&lt;br/&gt;
another merge is running at the same time, on a machine with enough&lt;br/&gt;
cores, for a &quot;typical&quot; IO system.  If they do cause one another to&lt;br/&gt;
thrash (seems likely, though, I&apos;ve also seen evidence that merging is&lt;br/&gt;
CPU bound, at least for merging the postings...) then we should only&lt;br/&gt;
allow 1 to run at once...&lt;/p&gt;</comment>
                    <comment id="12791119" author="mikemccand" created="Wed, 16 Dec 2009 01:47:47 +0000"  >&lt;p&gt;Actually, I&apos;d like to explore the throttling, just within CMS, with this issue.&lt;/p&gt;

&lt;p&gt;I have a crude prototype working and it&apos;s actually quite simple... I think this is a good way to force the prioritization of different threads.&lt;/p&gt;</comment>
                    <comment id="12791125" author="jasonrutherglen" created="Wed, 16 Dec 2009 02:05:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;max(1, min(3, numberOfCores / 2))... This would just be a dynamic default, ie, if you call setMaxThreadCount yourself, you override it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a good idea as a default.&lt;/p&gt;</comment>
                    <comment id="12792526" author="mikemccand" created="Fri, 18 Dec 2009 16:49:19 +0000"  >&lt;p&gt;Attached patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Adds new CMS.setMaxMergeCount, which must be greater than&lt;br/&gt;
    maxThreadCount, allowing CMS to pause big threads so small threads&lt;br/&gt;
    can finish&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Uses dynamic default for CMS.maxThreadCount, to between 1 &amp;amp; 3&lt;br/&gt;
    depending on number of cores; defaults maxMergeCount to that&lt;br/&gt;
    number +2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The pausing works well the NRT stress test &amp;#8211; it greatly reduces how&lt;br/&gt;
often the NRT reopen is blocked because of too many merges running.&lt;br/&gt;
It&apos;s most important when there is a very big merge running &amp;#8211; in that&lt;br/&gt;
case it&apos;s better to pause &amp;amp; unpause that big merge when tiny merges&lt;br/&gt;
arrive then to force NRT to wait for the completion of the merge.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12428450" name="LUCENE-2164.patch" size="16869" author="mikemccand" created="Fri, 18 Dec 2009 16:49:19 +0000" />
                    <attachment id="12428079" name="LUCENE-2164.patch" size="5305" author="mikemccand" created="Tue, 15 Dec 2009 20:51:15 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 15 Dec 2009 17:12:17 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11621</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25561</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>