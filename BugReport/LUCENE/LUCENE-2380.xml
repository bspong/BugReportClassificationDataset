<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:59:48 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2380/LUCENE-2380.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2380] Add FieldCache.getTermBytes, to load term data as byte[]</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2380</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;With flex, a term is now an opaque byte[] (typically, utf8 encoded unicode string, but not necessarily), so we need to push this up the search stack.&lt;/p&gt;

&lt;p&gt;FieldCache now has getStrings and getStringIndex; we need corresponding methods to load terms as native byte[], since in general they may not be representable as String.  This should be quite a bit more RAM efficient too, for US ascii content since each character would then use 1 byte not 2.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12461421">LUCENE-2380</key>
            <summary>Add FieldCache.getTermBytes, to load term data as byte[]</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Wed, 7 Apr 2010 17:16:54 +0100</created>
                <updated>Fri, 10 May 2013 11:44:57 +0100</updated>
                    <resolved>Thu, 3 Jun 2010 19:38:19 +0100</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12854594" author="thetaphi" created="Wed, 7 Apr 2010 17:50:19 +0100"  >&lt;p&gt;The structure should look like String and StringIndex, but I am not sure, if we need real BytesRefs. In my opinion, it should be an array of byte[], where each byte[] is allocated with the termsize from the enums BytesRef and copied over - this is. This is no problem, as the terms need to be replicated either way, as the BytesRef from the enum is reused. The only problem is that byte[] is mising the cool bytesref methods like utf8ToString() that may be needed by consumers.&lt;/p&gt;

&lt;p&gt;getStrings and getStringIndex should be deprecated. We cannot emulate them using BytesRef.utf8ToString, as the String[] arrays are raw and allow no wrapping. If FieldCache would use accessor methods and not raw arrays, we would not have that problem...&lt;/p&gt;</comment>
                    <comment id="12854615" author="mikemccand" created="Wed, 7 Apr 2010 18:39:55 +0100"  >&lt;p&gt;We could also do shared byte[] blocks (private), with a public method to retrieve the BytesRef for a given doc?  Standard codec&apos;s terms index does this &amp;#8211; we could share it I think.&lt;/p&gt;

&lt;p&gt;A new byte[] per doc adds alot of RAM overhead and GC load.  (Of course, so does the String solution we use today, so it&apos;d at least be no worse...).&lt;/p&gt;</comment>
                    <comment id="12854621" author="yseeley@gmail.com" created="Wed, 7 Apr 2010 19:00:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;We could also do shared byte[] blocks (private), with a public method to retrieve the BytesRef for a given doc?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Absolutely!  Now that we are in control, it would be a crime not not share the byte[]&lt;br/&gt;
Seems like one should pass in a BytesRef to be filled in... that would be most efficient for people doing simple stuff like compare docid1 to docid2.  Returning a reused BytesRef could also work (as TermsEnum does) but it&apos;s less efficient for anything needing a state of more than 1 BytesRef since it then requires copying.&lt;/p&gt;

&lt;p&gt;We can further save space by putting the length as a vInt in the byte[] - most would be a single byte.&lt;br/&gt;
Then we just need an int[] as an index into the byte[]... or potentially packed ints.&lt;/p&gt;

&lt;p&gt;We&apos;ll also need an implementation that can span multiple byte[]s for larger than 2GB support.  The correct byte[] to look into is then simply a function of the docid (as is done in Solr&apos;s UnInvertedField).&lt;/p&gt;

&lt;p&gt;We could possibly play games with the offsets into the byte[] too - encode as a delta against the average instead of an absolute offset.  So offset = average_size * ord + get_delta(ord)&lt;/p&gt;</comment>
                    <comment id="12854639" author="thetaphi" created="Wed, 7 Apr 2010 19:31:55 +0100"  >&lt;p&gt;This goes again in the direction of not having arrays in FieldCache anymore, but instead have accessor methods taking a docid and giving back the data (possibly as a reference). So getBytes(docid) returns a reused BytesRef with offset and length of the requested term. For native types we should also go away from arrays and only provide accessor methods. Java is so fast and possiby inlines the method call. So for native types we could also use a FloatBuffer or ByteBuffer or whatever from java.nio.&lt;/p&gt;</comment>
                    <comment id="12854853" author="toke" created="Thu, 8 Apr 2010 08:49:40 +0100"  >&lt;p&gt;Working on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2369&quot; title=&quot;Locale-based sort by field with low memory overhead&quot;&gt;LUCENE-2369&lt;/a&gt; I essentially had to re-implement the FieldCache because of the hardwiring of arrays. Switching to accessor methods seems like the right direction to go.&lt;/p&gt;</comment>
                    <comment id="12867534" author="yseeley@gmail.com" created="Fri, 14 May 2010 16:41:53 +0100"  >&lt;p&gt;One thing to keep in mind is that the current way of returning shared BytesRef objects often forces one to make a copy.  We should perhaps consider allowing a BytesRef to be passed in.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// returning shared BytesRef forces a copy
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(;;) {
  BytesRef val1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BytesRef(getValue(doc1))  &lt;span class=&quot;code-comment&quot;&gt;// make a copy
&lt;/span&gt;  BytesRef val2 = getValue(doc2)
  &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; cmp = val1.compareTo(val2)

&lt;span class=&quot;code-comment&quot;&gt;// allowing BytesRef to be passed in means no copy
&lt;/span&gt;BytesRef val1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BytesRef();
BytesRef val2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BytesRef();
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(;;) {
  getValue(doc1, val1)
  getValue(doc2, val2)
  &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; cmp = val1.compareTo(val2)
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12867535" author="mikemccand" created="Fri, 14 May 2010 16:45:44 +0100"  >&lt;p&gt;I agree, let&apos;s pass the reused BytesRef in.&lt;/p&gt;</comment>
                    <comment id="12868747" author="mikemccand" created="Tue, 18 May 2010 18:21:31 +0100"  >&lt;p&gt;Very rough first cut patch attached.&lt;/p&gt;

&lt;p&gt;I removed getStrings and replaced it with getTerms (returns a BytesRef oriented getter API for looking up the String from a doc).&lt;/p&gt;

&lt;p&gt;And I removed getStringsIndex and replaced it with getTermsIndex.&lt;/p&gt;

&lt;p&gt;All lucene tests pass with this hard cutover, but I still need to measure perf hit: I&apos;m using packed ints currently to hold the offsets, and 1 or 2 byte vInt prefix (Yonik&apos;s idea) to encode the term&apos;s length.&lt;/p&gt;

&lt;p&gt;I started to cutover Solr as well, and got some things cutover, but decided I should stop and check if these changes make sense &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  So the Solr side of the patch does not yet compile.  I specifically stopped when I got to StringIndexDocValues (abstract base class for lots of others) &amp;#8211; I&apos;d like to do a hard cutover of this class to use BytesRef, but does anyone see a problem w/ that?  I&apos;m at little nervous about how far &quot;down&quot; I&apos;ll end up having to push the BytesRef... It is marked as &quot;Internal class, subject to change&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I also dropped lots of nocommits along the way on the Solr side... so if someone could have a look and make suggestions that&apos;d help &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12868762" author="yseeley@gmail.com" created="Tue, 18 May 2010 18:57:38 +0100"  >&lt;p&gt;Ahhh, fun stuff!  I&apos;m packing for Prague though - prob won&apos;t be able to look at this for a week.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1 or 2 byte vInt prefix&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1 or 2? a max len of 2**15?  (I know... a term bigger than 32K would be horrible, but so are limits that aren&apos;t necessary).  We could also do 1 or 4 (or 1 or 5), but as long as we make sure the single-byte case is optimized, it shouldn&apos;t matter.&lt;/p&gt;

&lt;p&gt;re: returning null if an ord of 0 is passed to get(int ord, BytesRef ret): do we need to do this?  We could record 0 as zero length in the FieldCache and hence avoid the special-case code.  We could require the user to check for 0 if they care to know the difference between zero length and missing.&lt;/p&gt;</comment>
                    <comment id="12868767" author="mikemccand" created="Tue, 18 May 2010 19:05:32 +0100"  >&lt;blockquote&gt;&lt;p&gt;Ahhh, fun stuff! I&apos;m packing for Prague though - prob won&apos;t be able to look at this for a week.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK no prob... have fun!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1 or 2? a max len of 2**15? (I know... a term bigger than 32K would be horrible, but so are limits that aren&apos;t necessary)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indexer already has this limit, during indexing (these large terms are skipped).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;re: returning null if an ord of 0 is passed to get(int ord, BytesRef ret): do we need to do this? We could record 0 as zero length in the FieldCache and hence avoid the special-case code. We could require the user to check for 0 if they care to know the difference between zero length and missing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would love to return empty string (not null) if ord 0 comes in, and require caller to specifically handle ord 0 if they need to differentiate... I had started down that path but got spooked by it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I think we can revisit it, but maybe separately.&lt;/p&gt;</comment>
                    <comment id="12868776" author="yseeley@gmail.com" created="Tue, 18 May 2010 19:25:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;would love to return empty string (not null) if ord 0 comes in, and require caller to specifically handle ord 0 if they need to differentiate... I had started down that path but got spooked by it&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah... I guess I could see how it could cause a loss of info if you go though a few layers and you only have a BytesRef w/o an ord to tell you the value was missing.&lt;/p&gt;</comment>
                    <comment id="12870888" author="mikemccand" created="Mon, 24 May 2010 23:42:25 +0100"  >&lt;p&gt;New iteration attached.&lt;/p&gt;

&lt;p&gt;I got Solr mostly cutover, at least for the immediate usage of FieldCache.getStrings/getStringIndex.&lt;/p&gt;

&lt;p&gt;However one Solr test (TestDistributedSearch) is still failing...&lt;/p&gt;</comment>
                    <comment id="12871089" author="mikemccand" created="Tue, 25 May 2010 11:49:01 +0100"  >&lt;p&gt;New patch &amp;#8211; now all tests pass.  Getting closer... but I still have to perf tes...&lt;/p&gt;</comment>
                    <comment id="12871308" author="mikemccand" created="Tue, 25 May 2010 20:24:41 +0100"  >&lt;p&gt;OK I ran some sort perf tests.  I picked the worst case &amp;#8211; trivial&lt;br/&gt;
query (TermQuery) matching all docs, sorting by either a highly unique&lt;br/&gt;
string field (random string) or enumerated field (country ~ a couple&lt;br/&gt;
hundred values), from benchmark&apos;s SortableSingleDocSource.&lt;/p&gt;

&lt;p&gt;Index has 5M docs.  Each run is best of 3.&lt;/p&gt;

&lt;p&gt;Results:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk QPS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch QPS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Change %&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;random&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.75&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;5.64&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;red&quot;&gt;-27.2%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;country&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;8.05&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.62&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;red&quot;&gt;-5.3%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;So.... the packed ints lookups are more costly than trunk today (but,&lt;br/&gt;
at a large reduction in RAM used).&lt;/p&gt;

&lt;p&gt;Then I tried another test, asking packed ints to upgrade to an array&lt;br/&gt;
of the nearest native type (ie byte[], short[], int[], long[]) for the&lt;br/&gt;
doc -&amp;gt; ord map.  This is faster since lookups don&apos;t require&lt;br/&gt;
shift/mask, but, wastes some space since you have unused bits:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk QPS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch QPS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Change %&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;random&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.75&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.89&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;green&quot;&gt;1.8%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;country&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;8.05&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.64&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;red&quot;&gt;-5.1%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;The country case didn&apos;t get any better (noise) because it happened to&lt;br/&gt;
already be using 8 bits (byte[]) for doc-&amp;gt;ord map.&lt;/p&gt;

&lt;p&gt;Remember this is a worst case test &amp;#8211; if you query matches fewer&lt;br/&gt;
results than your entire index, or your query is more costly to&lt;br/&gt;
evaluate than the simple single TermQuery, this FieldCache lookup cost&lt;br/&gt;
will be relatively smaller.&lt;/p&gt;

&lt;p&gt;So... I think we should expose in the new FieldCache methods an&lt;br/&gt;
optional param to control time/space tradeoff; I&apos;ll add this,&lt;br/&gt;
defaulting to upgrading to nearest native type.  I think the 5.3%&lt;br/&gt;
slowdown on the country field is acceptable given the large reduction&lt;br/&gt;
in RAM used...&lt;/p&gt;</comment>
                    <comment id="12871342" author="mikemccand" created="Tue, 25 May 2010 21:34:28 +0100"  >&lt;p&gt;I did some rough estimates of RAM usage for StringIndex (trunk) vs&lt;br/&gt;
TermIndex (patch).&lt;/p&gt;

&lt;p&gt;Java String is an object, so estimate 8 byte object header in the JRE.&lt;br/&gt;
It seems to have 3 int fields (offset, count, hashCode), from&lt;br/&gt;
OpenJDK&apos;s sources, plus ref to char[].&lt;/p&gt;

&lt;p&gt;The char[] has 8 byte object header, int length, and actual array&lt;br/&gt;
data.&lt;/p&gt;

&lt;p&gt;So in trunk&apos;s StringIndex:&lt;/p&gt;

&lt;p&gt;  per-unique-term: 40 bytes (48 on 64bit jre) + 2*length-of-string-in-UTF16&lt;br/&gt;
  per-doc: 4 bytes (8 bytes on 64 bit)&lt;/p&gt;

&lt;p&gt;In the patch:&lt;/p&gt;

&lt;p&gt;  per-unique-term: ceil(log2(totalUTF8BytesTermData)) + utf8 bytes + 1 or 2 bytes (vInt, for term length)&lt;br/&gt;
  per-doc: ceil(log2(numUniqueTerm)) bits&lt;/p&gt;

&lt;p&gt;So eg say you have an English title field, avg length 40 chars, and&lt;br/&gt;
assume always unique.  On a 5M doc index, trunk would take ~591MB and&lt;br/&gt;
patch would take ~226 MB (32bit JRE) = 62% less.&lt;/p&gt;

&lt;p&gt;But if you have a CJK title field, avg 10 chars (may be highish), it&apos;s&lt;br/&gt;
less savings because UTF8 takes 50% more RAM than UTF16 does for CJK&lt;br/&gt;
(and others).  Trunk would take ~305MB and patch ~178MB (32bit JRE) =&lt;br/&gt;
42% less.&lt;/p&gt;

&lt;p&gt;Also don&apos;t forget the GC load of having 5M String &amp;amp; char[] objects...&lt;/p&gt;</comment>
                    <comment id="12873131" author="mikemccand" created="Fri, 28 May 2010 21:05:57 +0100"  >&lt;p&gt;OK I fixed up the patch.  I think it&apos;s ready to commit, though it&apos;d be&lt;br/&gt;
great if someone could double check my Solr changes...:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Updated to trunk&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed bug in Solr&apos;s ByteUtils.java (it was not respecting the&lt;br/&gt;
    offset in the incoming BytesRef)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added optional boolean &quot;fasterButMoreRAM&quot; option when loading&lt;br/&gt;
    field cache, defaults to true&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;For DocTermsIndex, I defined ord=0 to mean &quot;unset&quot;; and made it&lt;br/&gt;
    the caller&apos;s responsibility to do something with the ord=0 case if&lt;br/&gt;
    empty (length=0) BytesRef isn&apos;t acceptable.  Likewise, for&lt;br/&gt;
    DocTerms, I now directly return empty BytesRef if doc didn&apos;t have&lt;br/&gt;
    this field, but I also added an exists method to explicitly check&lt;br/&gt;
    if you need to.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added a getTerm convenience method (calls getOrd then lookup, by&lt;br/&gt;
    default) to the terms index; renamed DocTerms.get -&amp;gt; getTerm for&lt;br/&gt;
    consistency&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed the nocommits and/or changed to TODOs&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Small cleanups&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ve also added a MIGRATE.txt that spells out more details on how an&lt;br/&gt;
app can cutover to the new APIs.&lt;/p&gt;

&lt;p&gt;I think there are some other good things to do here, but as a future&lt;br/&gt;
issue (this one&apos;s big enough!) &amp;#8211; I&apos;ll open it:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;For DocTermsIndex, make it optional whether the bytes data is&lt;br/&gt;
    loaded.  EG for a single segment index (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2335&quot; title=&quot;optimization: when sorting by field, if index has one segment and field values are not needed, do not load String[] into field cache&quot;&gt;LUCENE-2335&lt;/a&gt;), or for sort&lt;br/&gt;
    comparators apps that do not need the bytes data (eg because they&lt;br/&gt;
    use terms dict to resolve ord -&amp;gt; term, and v/v).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Possibly merge DocTerms &amp;amp; DocTermsIndex.  EG it&apos;s dangerous today&lt;br/&gt;
    if you load terms and then termsIndex because you&apos;re wasting tons&lt;br/&gt;
    of RAM; it&apos;d be nicer if we could have a single cache entry that&apos;d&lt;br/&gt;
    &quot;upgrade&quot; itself to be an index (have the ords).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12875233" author="mikemccand" created="Thu, 3 Jun 2010 19:39:43 +0100"  >&lt;p&gt;I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2483&quot; title=&quot;When loading FieldCache terms index, make terms data optional&quot;&gt;LUCENE-2483&lt;/a&gt; for the future improvements.&lt;/p&gt;</comment>
                    <comment id="12875256" author="yseeley@gmail.com" created="Thu, 3 Jun 2010 20:16:07 +0100"  >&lt;p&gt;Whew, that&apos;s one involved patch!&lt;br/&gt;
I didn&apos;t get to it before, but I&apos;ll start looking over the Solr changes now.&lt;/p&gt;</comment>
                    <comment id="12875287" author="yseeley@gmail.com" created="Thu, 3 Jun 2010 21:53:29 +0100"  >&lt;p&gt;I did some performance testing on faceting using the field cache (single valued field with facet.method fc and fcs).&lt;/p&gt;

&lt;p&gt;field=100000 unique values&lt;br/&gt;
fc: 5% slower&lt;br/&gt;
fcs: 55% slower&lt;/p&gt;

&lt;p&gt;field=100 unique values&lt;br/&gt;
fc: 2.5% slower&lt;br/&gt;
fcs: 26% slower&lt;/p&gt;

&lt;p&gt;I&apos;ll look into it to see how we can regain some of that lost performance.&lt;/p&gt;</comment>
                    <comment id="12875291" author="thetaphi" created="Thu, 3 Jun 2010 22:02:44 +0100"  >&lt;p&gt;What do the numbers mean? Time to build cache or time for sorting something? Thats unclear to me.&lt;/p&gt;</comment>
                    <comment id="12875302" author="mikemccand" created="Thu, 3 Jun 2010 22:27:10 +0100"  >&lt;p&gt;Hmmmm.&lt;/p&gt;

&lt;p&gt;Can you try adding &quot;, true&quot; to FieldCache.DEFAULT.getTermsIndex?  That&apos;ll use more RAM but should be faster.&lt;/p&gt;

&lt;p&gt;Also, could the fix for executor have changed the performance?&lt;/p&gt;</comment>
                    <comment id="12875360" author="yseeley@gmail.com" created="Fri, 4 Jun 2010 00:37:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;What do the numbers mean?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Time to do the faceting (roughly).  FieldCache build time is not included.  Given that the degradation is much worse for a higher number of unique values, this points to the increased cost of going from ord-&amp;gt;value.&lt;/p&gt;</comment>
                    <comment id="12875368" author="yseeley@gmail.com" created="Fri, 4 Jun 2010 00:47:44 +0100"  >&lt;p&gt;I just committed a patch that helps... when merging the fieldcaches,  instead of looking up the term for each comparison, it&apos;s now stored in the segment data structure.&lt;/p&gt;

&lt;p&gt;Per-segment faceting is now 26% slower for the 100,000 term field, and 17% slower for the 100 term field.&lt;/p&gt;

&lt;p&gt;One way to regain more performance is to implement some kind of stateful iterator over the values in the field cache entry instead of looking up by ord each time.&lt;/p&gt;</comment>
                    <comment id="12875913" author="yseeley@gmail.com" created="Sat, 5 Jun 2010 17:06:29 +0100"  >&lt;p&gt;FYI, while trying to implement an iterator over the fieldcache terms, I ran into a bug where each term is written twice. This causes double the memory usage for the bytes (but no functionality bugs). I&apos;ll fix shortly, and anyone who has done performance tests might want to redo them again (cache effects, GC differences, and bigger entry build times). &lt;/p&gt;</comment>
                    <comment id="12875919" author="yseeley@gmail.com" created="Sat, 5 Jun 2010 17:52:06 +0100"  >&lt;p&gt;Here&apos;s a draft patch (it currently fails) of an enumerator over the field cache entry.&lt;/p&gt;</comment>
                    <comment id="12878785" author="yseeley@gmail.com" created="Mon, 14 Jun 2010 23:51:34 +0100"  >&lt;p&gt;Here&apos;s an updated &quot;terms enum over fieldcache&quot; patch.&lt;br/&gt;
PagedBytes now keeps track of how much space was used in each byte array and allows access to the raw blocks and end info.  Slightly less elegant, but it works.&lt;/p&gt;

&lt;p&gt;I still need to do performance testing with this.&lt;/p&gt;</comment>
                    <comment id="12878907" author="mikemccand" created="Tue, 15 Jun 2010 10:29:06 +0100"  >&lt;p&gt;Patch looks good Yonik!&lt;/p&gt;</comment>
                    <comment id="12878974" author="yseeley@gmail.com" created="Tue, 15 Jun 2010 14:34:22 +0100"  >
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;terms in field&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;facet method&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;pre-bytes ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;trunk+patch ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;new/old&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100000&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;fc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;27&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;36&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.33&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100000&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;fcs&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;333&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;325&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0.98&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;fc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;20&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;22&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;fcs&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;24&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;25&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.04&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;OK - so the biggest problem area initially (bottlenecked by field cache merging) that was 55% slower is now 2% faster.&lt;/p&gt;</comment>
                    <comment id="12879712" author="mikemccand" created="Thu, 17 Jun 2010 10:09:47 +0100"  >&lt;p&gt;The above commit was actually for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2378&quot; title=&quot;Cutover remaining usage of pre-flex APIs&quot;&gt;&lt;del&gt;LUCENE-2378&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12880481" author="yseeley@gmail.com" created="Sat, 19 Jun 2010 14:30:02 +0100"  >&lt;p&gt;This patch adds the ability to get at the raw arrays from the Direct* classes, and using those fixes the performance regressions in the &quot;fc&quot; faceting I was seeing.&lt;/p&gt;

&lt;p&gt;To do this, it adds this to DocTermsIndex.  Anyone have a better solution?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /** @lucene.internal */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; PackedInts.Reader getDocToOrd();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12880483" author="yseeley@gmail.com" created="Sat, 19 Jun 2010 14:52:03 +0100"  >&lt;p&gt;It was really tricky performance testing this.&lt;/p&gt;

&lt;p&gt;If I started solr and tested one type of faceting exclusively, the performance impact of going through the new FieldCache interfaces (PackedInts for ord lookup) was relatively minimal.&lt;/p&gt;

&lt;p&gt;However, I had a simple script that tested the different variants (the 4 in the table above)... and using that resulted in the bigger slowdowns.&lt;/p&gt;

&lt;p&gt;The script would do the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
1) test 100 iterations of facet.method=fc on the 100,000 term field
2) test 10 iterations of facet.method=fcs on the 100,000 term field
3) test 100 iterations of facet.method=fc on the 100 term field
4) test 10 iterations of facet.method=fcs on the 100 term field
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I would run the script a few times, making sure the numbers stabilized and were repeatable.&lt;/p&gt;

&lt;p&gt;Testing #1 alone resulted in trunk slowing down ~ 4%&lt;br/&gt;
Testing #1 along with any single other test: same small slowdown of ~4%&lt;br/&gt;
Running the complete script: slowdown of 33-38% for #1 (as well as others)&lt;br/&gt;
When running the complete script, the first run of Test #1 was always the best... as if the JVM correctly specialized it, but then discarded it later, never to return.&lt;br/&gt;
I saw the same affect on both an AMD Phenom II w/ ubuntu, Java 1.6_14 and Win7 with a Core2, Java 1.6_17, both 64 bit.  The drop on Win7 was only 20% though.&lt;/p&gt;

&lt;p&gt;So: you can&apos;t always depend on the JVM being able to inline stuff for you, and it seems very hard to determine when it can.&lt;br/&gt;
This obviously has implications for the lucene benchmarker too.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                <outwardlinks description="blocks">
                            <issuelink>
            <issuekey id="12461116">LUCENE-2364</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                                <inwardlinks description="is depended upon by">
                            <issuelink>
            <issuekey id="12463515">LUCENE-2426</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12447532" name="LUCENE-2380_direct_arr_access.patch" size="4856" author="yseeley@gmail.com" created="Sat, 19 Jun 2010 14:30:02 +0100" />
                    <attachment id="12447080" name="LUCENE-2380_enum.patch" size="9287" author="yseeley@gmail.com" created="Mon, 14 Jun 2010 23:51:34 +0100" />
                    <attachment id="12446413" name="LUCENE-2380_enum.patch" size="6838" author="yseeley@gmail.com" created="Sat, 5 Jun 2010 17:52:06 +0100" />
                    <attachment id="12445806" name="LUCENE-2380.patch" size="135982" author="mikemccand" created="Fri, 28 May 2010 21:05:57 +0100" />
                    <attachment id="12445440" name="LUCENE-2380.patch" size="131884" author="mikemccand" created="Tue, 25 May 2010 11:49:01 +0100" />
                    <attachment id="12445397" name="LUCENE-2380.patch" size="116793" author="mikemccand" created="Mon, 24 May 2010 23:42:25 +0100" />
                    <attachment id="12444816" name="LUCENE-2380.patch" size="93774" author="mikemccand" created="Tue, 18 May 2010 18:21:30 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 7 Apr 2010 16:50:19 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11421</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25311</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>