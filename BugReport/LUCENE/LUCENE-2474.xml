<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:29:05 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2474/LUCENE-2474.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2474] Allow to plug in a Cache Eviction Listener to IndexReader to eagerly clean custom caches that use the IndexReader (getFieldCacheKey)</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2474</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Allow to plug in a Cache Eviction Listener to IndexReader to eagerly clean custom caches that use the IndexReader (getFieldCacheKey).&lt;/p&gt;

&lt;p&gt;A spin of: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2468&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-2468&lt;/a&gt;. Basically, its make a lot of sense to cache things based on IndexReader#getFieldCacheKey, even Lucene itself uses it, for example, with the CachingWrapperFilter. FieldCache enjoys being called explicitly to purge its cache when possible (which is tricky to know from the &quot;outside&quot;, especially when using NRT - reader attack of the clones).&lt;/p&gt;

&lt;p&gt;The provided patch allows to plug a CacheEvictionListener which will be called when the cache should be purged for an IndexReader.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12465068">LUCENE-2474</key>
            <summary>Allow to plug in a Cache Eviction Listener to IndexReader to eagerly clean custom caches that use the IndexReader (getFieldCacheKey)</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="kimchy">Shay Banon</reporter>
                        <labels>
                    </labels>
                <created>Thu, 20 May 2010 22:28:46 +0100</created>
                <updated>Wed, 30 Mar 2011 16:50:06 +0100</updated>
                    <resolved>Tue, 25 Jan 2011 23:10:33 +0000</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12869778" author="kimchy" created="Thu, 20 May 2010 22:29:48 +0100"  >&lt;p&gt;First revision of the patch, tell me what you think... .&lt;/p&gt;</comment>
                    <comment id="12870559" author="mikemccand" created="Mon, 24 May 2010 11:29:53 +0100"  >&lt;p&gt;Should we rename this to &quot;CloseEventListener&quot;?  Ie, when an IR is closed it&apos;ll notify those subscribers who asked to find out?&lt;/p&gt;

&lt;p&gt;Also, shouldn&apos;t the FieldCache&apos;s listener be created/installed from FieldCache, not from IR?  Ie, when FieldCache creates an entry it should at that point ask the reader to notify it when that reader is closed?&lt;/p&gt;</comment>
                    <comment id="12978371" author="yseeley@gmail.com" created="Thu, 6 Jan 2011 15:42:05 +0000"  >&lt;p&gt;There&apos;s a lot of little issues here I think:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;close event&quot; doesn&apos;t really describe the behavior since an event is not generated on every close of every reader as one might expect.&lt;/li&gt;
	&lt;li&gt;This implementation is problematic since higher level readers don&apos;t propagate the event listeners to subreaders... i.e. I need to walk the tree myself and add add a listener to every reader, and on a reopen() I would need to walk the tree again and add listeners only to the new readers that have a new coreKey.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We&apos;ve talked before about putting caches directly on the readers - that still seems like the most straightforward approach?&lt;br/&gt;
We really need one cache that doesn&apos;t care about deletions, and one cache that does.&lt;/p&gt;</comment>
                    <comment id="12978391" author="mikemccand" created="Thu, 6 Jan 2011 16:18:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;&quot;close event&quot; doesn&apos;t really describe the behavior since an event is not generated on every close of every reader as one might expect.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, it&apos;s really more like a &quot;segment is unloaded&quot; event.  Ie a single segment can have many cloned/reopened SegmentReaders, all sharing the same &quot;core&quot; (= same cache entry eg in FieldCache)... when this event occurs in means all SegmentReaders for a given segment have been closed.  But, then we also need to generate this for toplevel readers, since &lt;span class=&quot;error&quot;&gt;&amp;#91;horribly&amp;#93;&lt;/span&gt; such readers are still allowed into eg the FieldCache.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This implementation is problematic since higher level readers don&apos;t propagate the event listeners to subreaders... i.e. I need to walk the tree myself and add add a listener to every reader, and on a reopen() I would need to walk the tree again and add listeners only to the new readers that have a new coreKey.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should just fix that, ie so your listener is propagated to the subs and to reopened readers (and their subs and their reopens, etc.).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We&apos;ve talked before about putting caches directly on the readers - that still seems like the most straightforward approach?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would be great, but I&apos;m not sure I&apos;d call it straightforward &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I think a separate baby step (ie this proposed approach) is fine for today?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We really need one cache that doesn&apos;t care about deletions, and one cache that does.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And maybe norms, since they too can change in cloned SegmentReaders that otherwise share the same core.  Or, maybe we make the &quot;core&quot; a first class object, and you interact with it to cache things that don&apos;t care about changes to deletions/norms.  Or, the core could just the first SegmentReader to be opened on this segment.  Or something.&lt;/p&gt;

&lt;p&gt;I think Earwin has also worked out some sort of caching model w/ IndexReaders... Earwin, how do you handle timely eviction?&lt;/p&gt;</comment>
                    <comment id="12978480" author="kimchy" created="Thu, 6 Jan 2011 19:58:50 +0000"  >&lt;p&gt;Right, I was thinking that its a low level API that you can just add it to the low level readers, but I agree, it will be nicer to have it on the high level as well. Regarding the close method name, I guess we can name it similar to the FieldCache one, maybe purge?&lt;/p&gt;

&lt;p&gt;&amp;gt; We&apos;ve talked before about putting caches directly on the readers - that still seems like the most straightforward approach?&lt;/p&gt;

&lt;p&gt;not sure I understand that. Do you mean getting FieldCache into the readers? And then what about cached filters? And other custom caching constructs that rely on the same mechanism as the CachingWrapperFilter? &lt;/p&gt;

&lt;p&gt;I think that if one implements such caching, its an advance enough feature where you should know how to handle deletes and other tidbits (if you need to).&lt;/p&gt;

&lt;p&gt;&amp;gt; We really need one cache that doesn&apos;t care about deletions, and one cache that does.&lt;/p&gt;

&lt;p&gt;Isn&apos;t that up to the cache to decide? That cache can be anything (internally implemented in Lucene or externally) that follows the mechanism of caching based on (segment) readers. As long as there are constructs to get the deleted docs to handle deletes (for example), then the implementation can use it.&lt;/p&gt;
</comment>
                    <comment id="12978493" author="yseeley@gmail.com" created="Thu, 6 Jan 2011 20:27:10 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; We&apos;ve talked before about putting caches directly on the readers - that still seems like the most straightforward approach?&lt;br/&gt;
&amp;gt; not sure I understand that. Do you mean getting FieldCache into the readers? And then what about cached filters?&lt;/p&gt;

&lt;p&gt;It would be a cache of anything... one element of that cache would be the FieldCache, there could be one for filters, or one entry per-filter.&lt;br/&gt;
edit: Maybe a better way to think about it is like a ServletContext or something - it&apos;s just a way to attach anything arbitrary to a reader.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; We really need one cache that doesn&apos;t care about deletions, and one cache that does.&lt;br/&gt;
&amp;gt; Isn&apos;t that up to the cache to decide?&lt;/p&gt;

&lt;p&gt;Not with this current patch, as there is no mechanism to get a callback when you do care about deletes.  If I want to cache something that depends on deletions, I want to purge that cache when the actual reader is closed (as opposed to the reader&apos;s core cache key that is shared amongst all readers that just have different deletions).  So if we go a &quot;close event&quot; route, we really want two different events... one for the close of a reader (i.e. deleted matter), and one for the close of the segment (deletes don&apos;t matter).&lt;/p&gt;</comment>
                    <comment id="12978719" author="kimchy" created="Fri, 7 Jan 2011 10:19:40 +0000"  >&lt;p&gt;&amp;gt; It would be a cache of anything... one element of that cache would be the FieldCache, there could be one for filters, or one entry per-filter.&lt;br/&gt;
&amp;gt; edit: Maybe a better way to think about it is like a ServletContext or something - it&apos;s just a way to attach anything arbitrary to a reader.&lt;/p&gt;

&lt;p&gt;Got you. My personal taste is to try and keep those readers as lightweight as possible, and have the proper constructs in place to allow to externally use them for caching, without having them manage it as well.&lt;/p&gt;

&lt;p&gt;&amp;gt; Not with this current patch, as there is no mechanism to get a callback when you do care about deletes. If I want to cache something that depends on deletions, I want to purge that cache when the actual reader is closed (as opposed to the reader&apos;s core cache key that is shared amongst all readers that just have different deletions). So if we go a &quot;close event&quot; route, we really want two different events... one for the close of a reader (i.e. deleted matter), and one for the close of the segment (deletes don&apos;t matter).&lt;/p&gt;

&lt;p&gt;I think that a cache that is affected by deletes is a problematic cache to begin with, so was thinking that maybe it should be discouraged by not allowing for it. Especially with NRT. My idea was to simply expand the purge capability that the FC gets for free to other external custom components.&lt;/p&gt;

&lt;p&gt;Also, if we did have a type safe separation between segment readers and compound readers, I would not have added the ability to register a listener on the compound readers, just the segment readers, as this will encourage people to write caches that only work on segment readers (since the registration for the &quot;purge event&quot; will happen within the cache, and it should work only with segment readers). That was why my patch does not take compound readers into account.&lt;/p&gt;

</comment>
                    <comment id="12978889" author="mikemccand" created="Fri, 7 Jan 2011 18:00:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;My idea was to simply expand the purge capability that the FC gets for free to other external custom components.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s a good baby step, for this issue, today, just for segment readers.&lt;/p&gt;

&lt;p&gt;Separately, eventually, we can tackle the bigger challenge of allowing caching on any reader.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Also, if we did have a type safe separation between segment readers and compound readers, I would not have added the ability to register a listener on the compound readers, just the segment readers, as this will encourage people to write caches that only work on segment readers (since the registration for the &quot;purge event&quot; will happen within the cache, and it should work only with segment readers). That was why my patch does not take compound readers into account.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I very much want to get type safe IndexReaders done before 4.0...&lt;/p&gt;

&lt;p&gt;But: I think we&apos;d want to have composite reader just forward the registration down to the atomic readers?  (And, forward on reopen).&lt;/p&gt;</comment>
                    <comment id="12978975" author="kimchy" created="Fri, 7 Jan 2011 21:33:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;But: I think we&apos;d want to have composite reader just forward the registration down to the atomic readers? (And, forward on reopen).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am not sure that you would want to do it. Any caching layer or an external component that is properly written would work on the low level segment readers, it will not even compile against compound readers. This will help direct people to write proper code and dealing only with segment readers.&lt;/p&gt;</comment>
                    <comment id="12978982" author="yseeley@gmail.com" created="Fri, 7 Jan 2011 21:56:03 +0000"  >&lt;p&gt;&amp;gt;  &amp;gt; But: I think we&apos;d want to have composite reader just forward the registration down to the atomic readers? (And, forward on reopen).&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt;I am not sure that you would want to do it.&lt;/p&gt;

&lt;p&gt;So a user doesn&apos;t have to walk the tree and re-register it&apos;s listeners with every new segment on a reopen.&lt;/p&gt;

&lt;p&gt;&amp;gt; Any caching layer or an external component that is properly written would work on the low level segment readers&lt;/p&gt;

&lt;p&gt;It&apos;s completely proper to cache stuff wrt the top level reader - Solr does so (and will continue to provide that option) .  Some people update their index infrequently, and the performance gains of having cached information on a unified view of the index is a win for them.&lt;/p&gt;</comment>
                    <comment id="12979700" author="mikemccand" created="Mon, 10 Jan 2011 19:24:36 +0000"  >&lt;p&gt;I started to implement the &quot;forwards to all subs and to all reopened readers&quot; and... it&apos;s kinda hairy.  I mean there are TONS of places where we make new readers (Earwin&apos;s working on improving this, I think, under &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2355&quot; title=&quot;Refactor Directory/Multi/SegmentReader creation/reopening/cloning/closing&quot;&gt;LUCENE-2355&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;So then I wondered: what if we just make this a static method, eg on IndexReader, add/removeReaderFinishedListener?  (Or we could put it on FieldCache).  That&apos;d be a tiny change...&lt;/p&gt;</comment>
                    <comment id="12979720" author="jasonrutherglen" created="Mon, 10 Jan 2011 19:58:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;make this a static method, eg on IndexReader, add/removeReaderFinishedListener? (Or we could put it on FieldCache). That&apos;d be a tiny change...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This makes the most sense however it feels temporary as should should probably move to a unified IWC/IRC config where all parameters are set and shared for writers and readers?  This way we can eventually coordinate things like IO scheduling, eg, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2793&quot; title=&quot;Directory createOutput and openInput should take an IOContext&quot;&gt;&lt;del&gt;LUCENE-2793&lt;/del&gt;&lt;/a&gt;&apos;s IOContext.  Also shouldn&apos;t there simply be a reader event listener and perhaps even a writer event listener?&lt;/p&gt;</comment>
                    <comment id="12979733" author="mikemccand" created="Mon, 10 Jan 2011 20:16:55 +0000"  >&lt;p&gt;I think we can generalize this to any event and to writer in the future... for today, just letting something external be notified when a reader is &quot;gone&quot;, just as FieldCache is privately notified today, is a good baby step.&lt;/p&gt;</comment>
                    <comment id="12979855" author="mikemccand" created="Mon, 10 Jan 2011 23:45:25 +0000"  >&lt;p&gt;OK, here&apos;s a patch exposing the readerFinishedListeners as static methods on IndexReader.&lt;/p&gt;

&lt;p&gt;It was also nice to consolidate all the various places we were previously purging the FieldCache.&lt;/p&gt;</comment>
                    <comment id="12979888" author="earwin" created="Tue, 11 Jan 2011 01:00:07 +0000"  >&lt;blockquote&gt;&lt;p&gt;Earwin&apos;s working on improving this, I think, under &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2355&quot; title=&quot;Refactor Directory/Multi/SegmentReader creation/reopening/cloning/closing&quot;&gt;LUCENE-2355&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I stalled, and then there were just so many changes under trunk, so I have to restart now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Thanks for another kick.&lt;/p&gt;</comment>
                    <comment id="12982509" author="kimchy" created="Mon, 17 Jan 2011 07:23:35 +0000"  >&lt;blockquote&gt;&lt;p&gt;OK, here&apos;s a patch exposing the readerFinishedListeners as static methods on IndexReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should use a CopyOneWriteArrayList so calling the listeners will not happen under a global synchronize block. If maintaining set behavior is required, then I can patch with a ConcurrentHashSet implementation or we can simply replace it with a CHM with PRESENT, or any other solution that does not require calling the listeners under a global sync block.&lt;/p&gt;</comment>
                    <comment id="12982604" author="mikemccand" created="Mon, 17 Jan 2011 11:44:48 +0000"  >&lt;p&gt;Ahh, I get it &amp;#8211; invoking the listeners (on cache evict) is dangerous to do under a global lock since they could conceivably be costly.&lt;/p&gt;

&lt;p&gt;I had switched to Set to try to prevent silliness in the event that an app adds same listener over &amp;amp; over (w/o removing it), and also to not have O(N^2) cost when removing listeners.  I mean, it is an expert API, but I still think we should attempt to be defensive against silliness?&lt;/p&gt;

&lt;p&gt;How about CHM?  (There is not builtin CHS, right?  And HS just wraps an HM anyway....).&lt;/p&gt;</comment>
                    <comment id="12982695" author="kimchy" created="Mon, 17 Jan 2011 16:25:14 +0000"  >&lt;p&gt;Yea, I got the reasoning for Set, we can use that, CHM with PRESENT. If you want, I can attach a simple MapBackedSet that makes any Map a Set.&lt;/p&gt;

&lt;p&gt;Still, I think that using CopyOnWriteArrayList is best here. I don&apos;t think that adding and removing listeners is something that will be done often in an app. But I might be mistaken. In this case, traversal over listeners is much better on CopyOnWriteArrayList compared to CHM.&lt;/p&gt;</comment>
                    <comment id="12982761" author="yseeley@gmail.com" created="Mon, 17 Jan 2011 17:45:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;Still, I think that using CopyOnWriteArrayList is best here.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agree - I think we should optimize for good/correct behavior.&lt;/p&gt;

&lt;p&gt;I&apos;d like even more for there to be just a single CopyOnWriteArrayList per &quot;top-level&quot; reader that is then propagated to all sub/segment readers, including new ones on a reopen.  But I guess Mike indicated that was currently too hard/hairy.&lt;/p&gt;

&lt;p&gt;The static is really non-optimal though - among other problems, it requires systems with multiple readers (and wants to do different things with different readers, such as maintain separate caches) to figure out what top-level reader a segment reader is associated with.  And given that we are dealing with IndexReader instances in the callbacks, and not ReaderContext objects, this seems impossible?&lt;/p&gt;</comment>
                    <comment id="12983159" author="mikemccand" created="Tue, 18 Jan 2011 11:40:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;Still, I think that using CopyOnWriteArrayList is best here.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I&apos;ll switch back to COWAL... it makes me nervous though.  I like&lt;br/&gt;
being defensive and the added cost of CHM iteration really should be&lt;br/&gt;
negligible here.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&apos;d like even more for there to be just a single CopyOnWriteArrayList per &quot;top-level&quot; reader that is then propagated to all sub/segment readers, including new ones on a reopen. But I guess Mike indicated that was currently too hard/hairy.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This did get hairy... eg if you make a MultiReader (or ParallelReader)&lt;br/&gt;
w/ subs... what should happen to their listeners?  Ie what if the subs&lt;br/&gt;
already have listeners enrolled?&lt;/p&gt;

&lt;p&gt;It also spooked me that apps may think they have to re-register after&lt;br/&gt;
re-open (if we stick w/ ArrayList) since then the list&apos;d just grow...&lt;br/&gt;
it&apos;s trappy.&lt;/p&gt;

&lt;p&gt;And, if you pull an NRT reader from IW (which is what reopen does&lt;br/&gt;
under the hood for an NRT reader), how to share its listeners?  Ie,&lt;br/&gt;
we&apos;d have to add a setter to IW as well, so it&apos;s also &quot;single source&quot;&lt;br/&gt;
(propagates on reopen).&lt;/p&gt;

&lt;p&gt;This is why I fell back to a simple static as the baby step for now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The static is really non-optimal though - among other problems, it requires systems with multiple readers (and wants to do different things with different readers, such as maintain separate caches) to figure out what top-level reader a segment reader is associated with. And given that we are dealing with IndexReader instances in the callbacks, and not ReaderContext objects, this seems impossible?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ReaderContext doesn&apos;t really make sense here?&lt;/p&gt;

&lt;p&gt;Ie, the listener is invoked when any/all composite readers sharing a&lt;br/&gt;
given segment have now closed (ie when the RC for that segment&apos;s core&lt;br/&gt;
drops to 0), or when a composite reader is closed.&lt;/p&gt;

&lt;p&gt;Also, in practice, is it really so hard for the app to figure out&lt;br/&gt;
which SR goes to which of their caches?  Isn&apos;t this &quot;typically&quot; a&lt;br/&gt;
containsKey against the app level caches...?&lt;/p&gt;</comment>
                    <comment id="12983793" author="mikemccand" created="Wed, 19 Jan 2011 16:58:33 +0000"  >&lt;p&gt;New patch &amp;#8211; cut back to COWAL.&lt;/p&gt;</comment>
                    <comment id="12983818" author="yseeley@gmail.com" created="Wed, 19 Jan 2011 18:06:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;eg if you make a MultiReader (or ParallelReader) w/ subs... what should happen to their listeners?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This doesn&apos;t have to be a super-flexible public API - it&apos;s clearly expert level and we can impose limitations that make sense.&lt;br/&gt;
A MultiReader is just a wrapper - you don&apos;t reopen it, so it could just start off with an empty listener list, the subs could all retain their listener lists and an addListener() could just delegate to the contained readers.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ReaderContext doesn&apos;t really make sense here?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, it doesn&apos;t (which circles around to the fact that the callbacks should be set on the top-reader)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Isn&apos;t this &quot;typically&quot; a containsKey against the app level caches...?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In a (solr) multi-core environment, you don&apos;t know &lt;b&gt;which&lt;/b&gt; caches to check, or even how to get to those caches.&lt;br/&gt;
You would either need to add &lt;b&gt;all&lt;/b&gt; of them and check all of them on a purge (which has other problems, including performance&lt;br/&gt;
problems for highly multi-tenanted uses where people have thousands of cores), or have one big static cache (which has other problems such as not being configurable per-core).&lt;/p&gt;

&lt;p&gt;I&apos;m not against this patch, I&apos;m just pointing out that the &quot;staticness&quot; of it (which I hope we can continue to move away from over time) severely limits it&apos;s usefulness, and it doesn&apos;t represent incremental progress if we do want to get rid of statics.&lt;/p&gt;

&lt;p&gt;Actually, I am against the last patch you posted, as it clearly has nothing to do with this issue &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12984280" author="mikemccand" created="Thu, 20 Jan 2011 16:56:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;Actually, I am against the last patch you posted, as it clearly has nothing to do with this issue &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops!  Heh.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A MultiReader is just a wrapper - you don&apos;t reopen it, so it could just start off with an empty listener list, the subs could all retain their listener lists and an addListener() could just delegate to the contained readers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, it does have a reopen (reopens the subs &amp;amp; wraps in a new MR), but I guess delegation would work for MR.  And, same for ParallelReader.&lt;/p&gt;

&lt;p&gt;And I think the NRT case should work fine, since we don&apos;t expose IW.getReader anymore (hmm &amp;#8211; this was never backported to 3.x?) &amp;#8211; if you new IndexReader(IW), it creates a single collection holding all listeners, and then shares it w/ all SRs.&lt;/p&gt;</comment>
                    <comment id="12985392" author="mikemccand" created="Sun, 23 Jan 2011 18:45:35 +0000"  >&lt;p&gt;Patch (for trunk), with non-static solution.&lt;/p&gt;

&lt;p&gt;I cut back to sync(HashSet) because it&apos;s easy, now, for dups to be added.  EG the collection is shared to all sub-readers, and FC registers its listener to all subs... and, each of FC&apos;s typed caches will register the listener.&lt;/p&gt;

&lt;p&gt;DirReader shares the collection to all subs and to all reopens.&lt;/p&gt;

&lt;p&gt;MultiReader, ParReader delegate (but also track/invoke their own listeners).&lt;/p&gt;

&lt;p&gt;I added a private reader listeners collection to IW, which is only used to make sure all NRT readers opened from the writer share the same collection (ie, this is not a public API in IW).&lt;/p&gt;

&lt;p&gt;Subclasses of IR are now responsible for initializing the reader listeners collection (if the add/removeReaderFinishedListener could be invoked).&lt;/p&gt;</comment>
                    <comment id="12986983" author="kimchy" created="Wed, 26 Jan 2011 12:36:25 +0000"  >&lt;p&gt;A MapBackedSet implementation, that can wrap a CHM to have a concurrent set implementation. We can consider using that instead of sync set and copy on read when notifying listeners.&lt;/p&gt;</comment>
                    <comment id="12987261" author="mikemccand" created="Wed, 26 Jan 2011 22:24:45 +0000"  >&lt;p&gt;OK, I cutover to MBS(CHM)!  Thanks Shay.&lt;/p&gt;</comment>
                    <comment id="12987267" author="thetaphi" created="Wed, 26 Jan 2011 22:36:38 +0000"  >&lt;p&gt;I would make the map wrapper final, else no comments for now, but I want to look into the code, if for perf reasons more AbstractSet methods should be overridden. Is this map backed set some impl from e.g. Commons Collect or Google Collect?&lt;/p&gt;</comment>
                    <comment id="13013365" author="gsingers" created="Wed, 30 Mar 2011 16:50:06 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12469097" name="LUCENE-2474.patch" size="20949" author="mikemccand" created="Sun, 23 Jan 2011 18:45:35 +0000" />
                    <attachment id="12467938" name="LUCENE-2474.patch" size="10623" author="mikemccand" created="Mon, 10 Jan 2011 23:45:25 +0000" />
                    <attachment id="12445103" name="LUCENE-2474.patch" size="5943" author="kimchy" created="Thu, 20 May 2010 22:29:48 +0100" />
                    <attachment id="12468769" name="LUCENE-2574.patch" size="43861" author="mikemccand" created="Wed, 19 Jan 2011 16:58:33 +0000" />
                    <attachment id="12469417" name="MapBackedSet.java" size="1074" author="kimchy" created="Wed, 26 Jan 2011 12:36:25 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 24 May 2010 10:29:53 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11346</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25218</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>