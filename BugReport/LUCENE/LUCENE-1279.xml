<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:33:56 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1279/LUCENE-1279.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1279] RangeQuery and RangeFilter should use collation to check for range inclusion</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1279</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;See &lt;a href=&quot;http://www.nabble.com/lucene-farsi-problem-td16977096.html&quot; class=&quot;external-link&quot;&gt;this java-user discussion&lt;/a&gt; of problems caused by Unicode code-point comparison, instead of collation, in RangeQuery.&lt;/p&gt;

&lt;p&gt;RangeQuery could take in a Locale via a setter, which could be used with a java.text.Collator and/or CollationKey&apos;s, to handle ranges for languages which have alphabet orderings different from those in Unicode.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12395210">LUCENE-1279</key>
            <summary>RangeQuery and RangeFilter should use collation to check for range inclusion</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="gsingers">Grant Ingersoll</assignee>
                                <reporter username="steve_rowe">Steve Rowe</reporter>
                        <labels>
                    </labels>
                <created>Fri, 2 May 2008 18:15:37 +0100</created>
                <updated>Sat, 1 Nov 2008 05:03:19 +0000</updated>
                    <resolved>Tue, 16 Sep 2008 22:03:44 +0100</resolved>
                            <version>2.3.1</version>
                                <fixVersion>2.4</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12593819" author="steve_rowe" created="Fri, 2 May 2008 18:17:25 +0100"  >&lt;p&gt;RangeFilter should also take in a Locale, to perform the same sort of comparisons.&lt;/p&gt;

&lt;p&gt;QueryParser already takes in a Locale, though it was originally intended to be used for date comparisons.  It could forward this Locale, through ConstantScoreRangeQuery, to RangeFilter.&lt;/p&gt;</comment>
                    <comment id="12593858" author="yseeley@gmail.com" created="Fri, 2 May 2008 20:31:16 +0100"  >&lt;p&gt;How do you suggest actually retrieving all of the documents between two endpoints based on non-index ordering?&lt;/p&gt;</comment>
                    <comment id="12593867" author="steve_rowe" created="Fri, 2 May 2008 21:01:24 +0100"  >&lt;p&gt;(Wild guess): iterate over all terms instead of iterating over terms between the lower and upper term.  Hmm, this is going to be slow.&lt;/p&gt;

&lt;p&gt;The implementation could default to the current behavior if no/null Locale is supplied.&lt;/p&gt;</comment>
                    <comment id="12594137" author="steve_rowe" created="Mon, 5 May 2008 05:38:56 +0100"  >&lt;p&gt;Attaching a patch containing class CollatingRangeQuery, which extends RangeQuery, overriding the rewrite() method.  A test class is also supplied.  This is targetted at contrib/.&lt;/p&gt;

&lt;p&gt;Because &lt;b&gt;all&lt;/b&gt; index terms in the Field of the lower and upper terms of the range have to be examined, since index term ordering (Unicode code point order) is not necessarily the same as the collation in the given Locale, CollatingRangeQuery&apos;s will be significantly slower than the RangeQuery&apos;s.&lt;/p&gt;

&lt;p&gt;One of the tests uses some of the Farsi information Esra supplied in the original post.  Note that neither Java 1.4.2 nor 1.5.0 contains collation information for Farsi.  Instead, the test uses the Arabic Locale, which appears to contain the proper letter ordering for the non-Arabic Farsi letters.&lt;/p&gt;</comment>
                    <comment id="12594464" author="hossman" created="Tue, 6 May 2008 05:37:19 +0100"  >&lt;p&gt;a few random thoughts:&lt;/p&gt;

&lt;p&gt;1) you should be able to at least start the enumerator by skiping to a term consisting of the lowerTermField and the termText of &quot;&quot; ... even if the Collation of the term text is random, you still know which field you want.&lt;/p&gt;

&lt;p&gt;2) why can a collator only be specified by a Locale, why not just let people specify the Collator they want directly?&lt;/p&gt;

&lt;p&gt;3) instead of adding a new public CollatingRangeQuery, would it make more sense to add an optional Collator to RangeQuery (and RangeFilter) which triggers a different code path when non null?  (from a performance standpoint it would basically be one conditional check at the begining of the rewrite method.)&lt;/p&gt;

&lt;p&gt;4) when i first saw the thread that spawned this issue, my first reaction was to wonder if it would make sense to start allowing a Collator to be specified when indexing, and to use the raw bytes from the CollationKey as the indexed value &amp;#8211; I haven&apos;t thought it through very hard, but i wonder if that would be feasible (it seems like it would certainly faster at query time, since it would allow more traditional term skipping.&lt;/p&gt;</comment>
                    <comment id="12594574" author="steve_rowe" created="Tue, 6 May 2008 14:09:12 +0100"  >&lt;blockquote&gt;&lt;p&gt;1) you should be able to at least start the enumerator by skiping to a term consisting of the lowerTermField and the termText of &quot;&quot; ... even if the Collation of the term text is random, you still know which field you want.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought I did that - from the patch:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    TermEnum enumerator = reader.terms(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(getField(), &quot;&quot;));
    ...
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; getField() {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (lowerTerm != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ? lowerTerm.field() : upperTerm.field());
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;2) why can a collator only be specified by a Locale, why not just let people specify the Collator they want directly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the java-user thread that spawned this issue, I mentioned that this would be necessary for custom Collators.  I used Locale because it&apos;s simpler to specify, but you&apos;re right, directly specifying a Collator makes more sense.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;3) instead of adding a new public CollatingRangeQuery, would it make more sense to add an optional Collator to RangeQuery (and RangeFilter) which triggers a different code path when non null? (from a performance standpoint it would basically be one conditional check at the begining of the rewrite method.)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was my original thought, but since the performance impact could be large compared to a standard RangeQuery, I thought it made more sense to put it where it couldn&apos;t be used accidentally &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.  I can redo it to integrate with the existing classes, though.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;4) when i first saw the thread that spawned this issue, my first reaction was to wonder if it would make sense to start allowing a Collator to be specified when indexing, and to use the raw bytes from the CollationKey as the indexed value - I haven&apos;t thought it through very hard, but i wonder if that would be feasible (it seems like it would certainly faster at query time, since it would allow more traditional term skipping.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought of something similar, but wow, this would be large.  It would require that the exact Collator used to generate the index terms also be used to generate CollationKeys for RangeQuery&apos;s/Filter&apos;s &amp;#8211; the Collator&apos;s rules would have to be stored in the index.  Also, how would binary CollationKey (de-)serialization fit into the String (de-)serialization currently in place for index terms?&lt;/p&gt;

&lt;p&gt;My guess is that the functionality provided here is most useful for fields with a small number of terms &amp;#8211; especially in the case of RangeQuery&apos;s, where the BooleanQuery clause limit is not guarded against.  Given this IMHO most likely scenario, the performance optimization you&apos;re talking about (and the attendant code complexification) probably isn&apos;t warranted.&lt;/p&gt;</comment>
                    <comment id="12595412" author="hossman" created="Thu, 8 May 2008 23:30:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;I thought I did that &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;my bad.  i missread.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;since the performance impact could be large compared to a standard RangeQuery, I thought it made more sense to put it where it couldn&apos;t be used accidentally&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm...  excellent point.  you convinced me.&lt;/p&gt;

&lt;p&gt;BTW: if hooks for CollatingRangeQuery are added to QueryParser, it shouldn&apos;t use this class just because a Locale is specified &amp;#8211; that would cause some unexpected results for people who have been specifying a Locale for date reasons. a new &quot;setter&quot; would need to indicate when to pay attention to Collation.&lt;/p&gt;</comment>
                    <comment id="12595467" author="steve_rowe" created="Fri, 9 May 2008 06:03:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;Hmmm... excellent point. you convinced me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Okay. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  At your (previous) suggestion, I have redone the patch (will attach shortly), moving the collating stuff into RangeQuery and RangeFilter, with enabling bits in QueryParser and ConstantScoreRangeQuery.  I put WARNING text in the javadoc for each method that invokes the expensive index Term iteration, so hopefully that will give pause to those who might otherwise unwittingly slow things down.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW: if hooks for CollatingRangeQuery are added to QueryParser, it shouldn&apos;t use this class just because a Locale is specified - that would cause some unexpected results for people who have been specifying a Locale for date reasons. a new &quot;setter&quot; would need to indicate when to pay attention to Collation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I added a new setter to QueryParser for this purpose: &lt;tt&gt;setRangeCollator(Collator)&lt;/tt&gt;.&lt;/p&gt;</comment>
                    <comment id="12595469" author="steve_rowe" created="Fri, 9 May 2008 06:05:03 +0100"  >&lt;p&gt;Rewritten patch, with the collating range functionality now added to existing classes RangeQuery and RangeFilter.&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                    <comment id="12629131" author="mikemccand" created="Mon, 8 Sep 2008 12:29:50 +0100"  >&lt;p&gt;Grant, what&apos;s the game plan on this one?&lt;/p&gt;</comment>
                    <comment id="12630563" author="gsingers" created="Fri, 12 Sep 2008 14:09:56 +0100"  >&lt;p&gt;Steve, can you update this for trunk (assuming SVN is working)?&lt;/p&gt;</comment>
                    <comment id="12630654" author="steve_rowe" created="Fri, 12 Sep 2008 19:41:02 +0100"  >&lt;p&gt;Updated to current trunk revision (694771).  Mostly this consisted of switching away from deprecated Hits in tests.&lt;/p&gt;

&lt;p&gt;Also, I used JavaCC 4.1 to regenerate QueryParser.java et al., and it looks like all of the files in the o.a.l.queryParser package have been changed - apparently the last time they were generated, JavaCC 4.0 was used.&lt;/p&gt;

&lt;p&gt;All tests pass for me (except TestIndexReaderReopen.testThreadSafety(), which I just posted to java-dev about, and which should be completely unrelated to this issue).&lt;/p&gt;</comment>
                    <comment id="12630766" author="gsingers" created="Sat, 13 Sep 2008 14:46:52 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Mostly this consisted of switching away from deprecated Hits in tests. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Seems like the new tests in TestRangeFilter still uses Hits.&lt;/p&gt;

&lt;p&gt;Also, from the Collator javadocs:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When sorting a list of Strings however, it is generally necessary to compare each String multiple times. In this case, CollationKeys provide better performance. The CollationKey class converts a String to a series of bits that can be compared bitwise against other CollationKeys. A CollationKey is created by a Collator object for a given String. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we need to implement this now, but I wonder if there is a performance difference if we created the CollationKey for comparison.  The big question is whether the construction of that for each term outweighs the savings by repeated comparisons to lower and upper.  &lt;/p&gt;

&lt;p&gt;One more question, and it probably shows my lack of knowledge here, but would it be possible to enumerate the various codepoints where there are problems and just handle these separately, somehow?  Basically, how pervasive is the problem?  Would we perhaps be better off having a check to see if one of these bad codepoints falls in the range of lower/upper and then handle it separately?  Or, perhaps, some reasoning  would allow us to better narrow in on the lowerTerm/upper instead of having to check the whole field.  Just thinking out loud...&lt;/p&gt;

&lt;p&gt;Otherwise, looks pretty good.&lt;/p&gt;</comment>
                    <comment id="12630803" author="steve_rowe" created="Sat, 13 Sep 2008 18:17:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;Seems like the new tests in TestRangeFilter still uses Hits.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks, I missed those - this new patch removes Hits usages; also, switched a few deprecated Field.Index.UN_TOKENIZED usages to NOT_ANALYZED.&lt;/p&gt;

&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                    <comment id="12630806" author="steve_rowe" created="Sat, 13 Sep 2008 18:45:47 +0100"  >&lt;blockquote&gt;
&lt;p&gt;from the Collator javadocs:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;When sorting a list of Strings however, it is generally necessary to compare each String multiple times. In this case, CollationKeys provide better performance. The CollationKey class converts a String to a series of bits that can be compared bitwise against other CollationKeys. A CollationKey is created by a Collator object for a given String. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we need to implement this now, but I wonder if there is a performance difference if we created the CollationKey for comparison. The big question is whether the construction of that for each term outweighs the savings by repeated comparisons to lower and upper.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the problem is that every single index term has to be converted to a CollationKey for every single (range) search.  In an earlier comment on this issue, Hoss said:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;4) when i first saw the thread that spawned this issue, my first reaction was to wonder if it would make sense to start allowing a Collator to be specified when indexing, and to use the raw bytes from the CollationKey as the indexed value - I haven&apos;t thought it through very hard, but i wonder if that would be feasible (it seems like it would certainly faster at query time, since it would allow more traditional term skipping.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m working on a utility class to store arbitrary binary in sortable, indexable Strings, so that CollationKeys can be stored in the index.  IMHO, though, this issue should still go forward.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One more question, and it probably shows my lack of knowledge here, but would it be possible to enumerate the various codepoints where there are problems and just handle these separately, somehow? Basically, how pervasive is the problem? Would we perhaps be better off having a check to see if one of these bad codepoints falls in the range of lower/upper and then handle it separately?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Languages, in some cases using the same character repertoire, define different orderings.  Also, I believe some orderings are context dependent - you can&apos;t always compare character by character.   So adding this stuff to Lucene would be to duplicate a lot of the stuff that&apos;s already done in the Collator.&lt;/p&gt;</comment>
                    <comment id="12630894" author="gsingers" created="Sun, 14 Sep 2008 17:20:15 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I think the problem is that every single index term has to be converted to a CollationKey for every single (range) search. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, agreed.  The question mainly is would that be faster than the String comparisons.  Basically, is a construction plus a bitwise compare faster than a string compare?  &lt;/p&gt;


&lt;blockquote&gt;
&lt;p&gt;Languages, in some cases using the same character repertoire, define different orderings. Also, I believe some orderings are context dependent - you can&apos;t always compare character by character. So adding this stuff to Lucene would be to duplicate a lot of the stuff that&apos;s already done in the Collator.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Makes sense, was just wondering if there were some shortcuts to be had since we have a very particular case and I was thinking maybe it would allow us to narrow down the range to search.&lt;/p&gt;

&lt;p&gt;For instance, hypothetically speaking, say your field had a full range of words starting with A up to Z, but that you knew the ordering problem only occurred between L and P and that your lower and upper terms K and Q, then you could feel confident that you could skip to K and stop at Q w/o any ramifications.  I realize this is repeating what is in the Collator, but it would be nice if the collator exposed the info.  However, perhaps, if using a RuleBasedCollator, the getRules() method could be used to optimize.  Again, just thinking out loud, I haven&apos;t explored it.&lt;/p&gt;

&lt;p&gt;I agree, this should still go forward, even as is.&lt;/p&gt;</comment>
                    <comment id="12631549" author="gsingers" created="Tue, 16 Sep 2008 22:03:44 +0100"  >&lt;p&gt;Committed revision 696056.&lt;/p&gt;</comment>
                    <comment id="12644492" author="steve_rowe" created="Sat, 1 Nov 2008 05:01:58 +0000"  >&lt;p&gt;Hoss wrote:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;4) when i first saw the thread that spawned this issue, my first reaction was to wonder if it would make sense to start allowing a Collator to be specified when indexing, and to use the raw bytes from the CollationKey as the indexed value - I haven&apos;t thought it through very hard, but i wonder if that would be feasible (it seems like it would certainly faster at query time, since it would allow more traditional term skipping.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;See &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1435&quot; title=&quot;CollationKeyFilter: convert tokens into CollationKeys encoded using IndexableBinaryStringTools&quot;&gt;&lt;del&gt;LUCENE-1435&lt;/del&gt;&lt;/a&gt;, which is an implementation of this idea.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12407645">LUCENE-1435</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12390062" name="LUCENE-1279.patch" size="95433" author="steve_rowe" created="Sat, 13 Sep 2008 18:17:33 +0100" />
                    <attachment id="12390025" name="LUCENE-1279.patch" size="94809" author="steve_rowe" created="Fri, 12 Sep 2008 19:41:02 +0100" />
                    <attachment id="12381741" name="LUCENE-1279.patch" size="60873" author="steve_rowe" created="Fri, 9 May 2008 06:05:02 +0100" />
                    <attachment id="12381404" name="LUCENE-1279.patch" size="12852" author="steve_rowe" created="Mon, 5 May 2008 05:38:56 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 2 May 2008 19:31:16 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12469</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26449</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>