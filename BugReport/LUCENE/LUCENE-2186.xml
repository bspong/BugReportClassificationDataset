<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:35:46 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2186/LUCENE-2186.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2186] First cut at column-stride fields (index values storage)</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2186</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I created an initial basic impl for storing &quot;index values&quot; (ie&lt;br/&gt;
column-stride value storage).  This is still a work in progress... but&lt;br/&gt;
the approach looks compelling.  I&apos;m posting my current status/patch&lt;br/&gt;
here to get feedback/iterate, etc.&lt;/p&gt;

&lt;p&gt;The code is standalone now, and lives under new package&lt;br/&gt;
oal.index.values (plus some util changes, refactorings) &amp;#8211; I have yet&lt;br/&gt;
to integrate into Lucene so eg you can mark that a given Field&apos;s value&lt;br/&gt;
should be stored into the index values, sorting will use these values&lt;br/&gt;
instead of field cache, etc.&lt;/p&gt;

&lt;p&gt;It handles 3 types of values:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Six variants of byte[] per doc, all combinations of fixed vs&lt;br/&gt;
    variable length, and stored either &quot;straight&quot; (good for eg a&lt;br/&gt;
    &quot;title&quot; field), &quot;deref&quot; (good when many docs share the same value,&lt;br/&gt;
    but you won&apos;t do any sorting) or &quot;sorted&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Integers (variable bit precision used as necessary, ie this can&lt;br/&gt;
    store byte/short/int/long, and all precisions in between)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Floats (4 or 8 byte precision)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;String fields are stored as the UTF8 byte[].  This patch adds a&lt;br/&gt;
BytesRef, which does the same thing as flex&apos;s TermRef (we should merge&lt;br/&gt;
them).&lt;/p&gt;

&lt;p&gt;This patch also adds basic initial impl of PackedInts (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1990&quot; title=&quot;Add unsigned packed int impls in oal.util&quot;&gt;&lt;del&gt;LUCENE-1990&lt;/del&gt;&lt;/a&gt;);&lt;br/&gt;
we can swap that out if/when we get a better impl.&lt;/p&gt;

&lt;p&gt;This storage is dense (like field cache), so it&apos;s appropriate when the&lt;br/&gt;
field occurs in all/most docs.  It&apos;s just like field cache, except the&lt;br/&gt;
reading API is a get() method invocation, per document.&lt;/p&gt;

&lt;p&gt;Next step is to do basic integration with Lucene, and then compare&lt;br/&gt;
sort performance of this vs field cache.&lt;/p&gt;

&lt;p&gt;For the &quot;sort by String value&quot; case, I think RAM usage &amp;amp; GC load of&lt;br/&gt;
this index values API should be much better than field caache, since&lt;br/&gt;
it does not create object per document (instead shares big long[] and&lt;br/&gt;
byte[] across all docs), and because the values are stored in RAM as&lt;br/&gt;
their UTF8 bytes.&lt;/p&gt;

&lt;p&gt;There are abstract Writer/Reader classes.  The current reader impls&lt;br/&gt;
are entirely RAM resident (like field cache), but the API is (I think)&lt;br/&gt;
agnostic, ie, one could make an MMAP impl instead.&lt;/p&gt;

&lt;p&gt;I think this is the first baby step towards &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1231&quot; title=&quot;Column-stride fields (aka per-document Payloads)&quot;&gt;&lt;del&gt;LUCENE-1231&lt;/del&gt;&lt;/a&gt;.  Ie, it&lt;br/&gt;
cannot yet update values, and the reading API is fully random-access&lt;br/&gt;
by docID (like field cache), not like a posting list, though I&lt;br/&gt;
do think we should add an iterator() api (to return flex&apos;s DocsEnum)&lt;br/&gt;
&amp;#8211; eg I think this would be a good way to track avg doc/field length&lt;br/&gt;
for BM25/lnu.ltc scoring.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12444498">LUCENE-2186</key>
            <summary>First cut at column-stride fields (index values storage)</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="simonw">Simon Willnauer</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Sat, 2 Jan 2010 15:09:27 +0000</created>
                <updated>Fri, 10 May 2013 11:44:30 +0100</updated>
                    <resolved>Thu, 9 Jun 2011 11:49:31 +0100</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                <fixVersion>CSF branch</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>8</watches>
                                                    <comments>
                    <comment id="12795897" author="thetaphi" created="Sat, 2 Jan 2010 18:53:35 +0000"  >&lt;p&gt;Is this patch for flex, as it contains CodecUtils and so on?&lt;/p&gt;

&lt;p&gt;If it is so we should use &quot;affects version: flex&quot;.&lt;/p&gt;</comment>
                    <comment id="12795963" author="michaelbusch" created="Sun, 3 Jan 2010 10:37:10 +0000"  >&lt;p&gt;Great to see progress here, Mike!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;String fields are stored as the UTF8 byte[]. This patch adds a&lt;br/&gt;
BytesRef, which does the same thing as flex&apos;s TermRef (we should merge&lt;br/&gt;
them).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It looks like ByteRef is very similar to Payload? Could you use that instead &lt;br/&gt;
and extend it with the new String constructor and compare methods? &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It handles 3 types of values:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So it looks like with your approach you want to support certain&lt;br/&gt;
&quot;primitive&quot; types out of the box, such as byte[], float, int, String?&lt;br/&gt;
If someone has custom data types, then they have, similar as with&lt;br/&gt;
payloads today, the byte[] indirection? &lt;/p&gt;

&lt;p&gt;The code I initially wrote for 1231 exposed IndexOutput, so that one&lt;br/&gt;
can call write*() directly, without having to convert to byte[]&lt;br/&gt;
first. I think we will also want to do that for 2125 (store attributes&lt;br/&gt;
in the index). So I&apos;m wondering if this and 2125 should work&lt;br/&gt;
similarly? &lt;br/&gt;
Thinking out loud: Could we have then attributes with&lt;br/&gt;
serialize/deserialize methods for primitive types, such as float?&lt;br/&gt;
Could we efficiently use such an approach all the way up to&lt;br/&gt;
FieldCache? It would be compelling if you could store an attribute as&lt;br/&gt;
CSF, or in the postinglist, retrieve it from the flex APIs, and also&lt;br/&gt;
from the FieldCache. All would be the same API and there would only be&lt;br/&gt;
one place that needs to &quot;know&quot; about the encoding (the attribute).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Next step is to do basic integration with Lucene, and then compare&lt;br/&gt;
sort performance of this vs field cache.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, that&apos;s where I got kind of stuck with 1231: We need to figure&lt;br/&gt;
out how the public API should look like, with which a user can add CSF&lt;br/&gt;
values to the index and retrieve them. The easiest and fastest way&lt;br/&gt;
would be to add a dedicated new API. The cleaner one would be to make the whole&lt;br/&gt;
Document/Field/FieldInfos API more flexible. &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1597&quot; title=&quot;New Document and Field API&quot;&gt;&lt;del&gt;LUCENE-1597&lt;/del&gt;&lt;/a&gt; was a first attempt.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are abstract Writer/Reader classes. The current reader impls&lt;br/&gt;
are entirely RAM resident (like field cache), but the API is (I think)&lt;br/&gt;
agnostic, ie, one could make an MMAP impl instead.&lt;/p&gt;

&lt;p&gt;I think this is the first baby step towards &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1231&quot; title=&quot;Column-stride fields (aka per-document Payloads)&quot;&gt;&lt;del&gt;LUCENE-1231&lt;/del&gt;&lt;/a&gt;. Ie, it&lt;br/&gt;
cannot yet update values, and the reading API is fully random-access&lt;br/&gt;
by docID (like field cache), not like a posting list, though I&lt;br/&gt;
do think we should add an iterator() api (to return flex&apos;s DocsEnum)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, so random-access would obviously be the preferred approach for SSDs, but&lt;br/&gt;
with conventional disks I think the performance would be poor? In 1231&lt;br/&gt;
I implemented the var-sized CSF with a skip list, similar to a posting&lt;br/&gt;
list. I think we should add that here too and we can still keep the&lt;br/&gt;
additional index that stores the pointers? We could have two readers:&lt;br/&gt;
one that allows random-access and loads the pointers into RAM (or uses&lt;br/&gt;
MMAP as you mentioned), and a second one that doesn&apos;t load anything&lt;br/&gt;
into RAM, uses the skip lists and only allows iterator-based access?&lt;/p&gt;

&lt;p&gt;About updating CSF: I hope we can use parallel indexing for that. In&lt;br/&gt;
other words: It should be possible for users to use parallel indexes&lt;br/&gt;
to update certain fields, and Lucene should use the same approach&lt;br/&gt;
internally to store different &quot;generations&quot; of things like norms and CSFs.&lt;/p&gt;</comment>
                    <comment id="12796200" author="mikemccand" created="Mon, 4 Jan 2010 14:53:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;Is this patch for flex, as it contains CodecUtils and so on?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually it&apos;s intended for trunk; I was thinking this should land&lt;br/&gt;
before flex (it&apos;s a much smaller change, and it&apos;s &quot;isolated&quot; from&lt;br/&gt;
flex), and so I wrote the CodecUtil/BytesRef basic infrastructure,&lt;br/&gt;
thinking flex would then cutover to them.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hmm, so random-access would obviously be the preferred approach for SSDs, but&lt;br/&gt;
with conventional disks I think the performance would be poor? In 1231&lt;br/&gt;
I implemented the var-sized CSF with a skip list, similar to a posting&lt;br/&gt;
list. I think we should add that here too and we can still keep the&lt;br/&gt;
additional index that stores the pointers? We could have two readers:&lt;br/&gt;
one that allows random-access and loads the pointers into RAM (or uses&lt;br/&gt;
MMAP as you mentioned), and a second one that doesn&apos;t load anything&lt;br/&gt;
into RAM, uses the skip lists and only allows iterator-based access?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The intention here is for this (&quot;index values&quot;) to replace field&lt;br/&gt;
cache, but not aim (initially at least) to do much more.  Ie, it&apos;s&lt;br/&gt;
&quot;meant&quot; to be a RAM resident (either via explicit slurping-into-RAM or&lt;br/&gt;
via MMAP).  So the SSD or spinning magnets should not be hit on&lt;br/&gt;
retrieval.&lt;/p&gt;

&lt;p&gt;If we add an iterator API, I think it should be simpler than the&lt;br/&gt;
postings API (ie, no seeking, dense (every doc is visited,&lt;br/&gt;
sequentially) iteration).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It looks like ByteRef is very similar to Payload? Could you use that instead &lt;br/&gt;
and extend it with the new String constructor and compare methods?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point!  I agree.  Also, we should use BytesRef when reading the&lt;br/&gt;
payload from TermsEnum.  Actually I think Payload, BytesRef, TermRef&lt;br/&gt;
(in flex) should all eventually be merged; of the three names, I think&lt;br/&gt;
I like BytesRef the best.  With *Enum in flex we can switch to&lt;br/&gt;
BytesRef.  For analysis we should switch PayloadAttribute to BytesRef,&lt;br/&gt;
and deprecate the methods using Payload?  Hmmm... but PayloadAttribute&lt;br/&gt;
is an interface.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So it looks like with your approach you want to support certain&lt;br/&gt;
&quot;primitive&quot; types out of the box, such as byte[], float, int, String?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, all &quot;primitive&quot; types (ie, byte/short/int/long are&lt;br/&gt;
&quot;included&quot; under int, as well as arbitrary bit precision &quot;between&quot;&lt;br/&gt;
those primitive types).  Because the API uses a method invocation (eg&lt;br/&gt;
IntSource.get) instead of direct array access, we can &quot;hide&quot; how many&lt;br/&gt;
bits are actually used, under the impl.  Same is true for float/double&lt;br/&gt;
(except we can&apos;t &lt;span class=&quot;error&quot;&gt;&amp;#91;easily&amp;#93;&lt;/span&gt; do arbitrary bit precision here... just 4 or&lt;br/&gt;
8 bytes).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If someone has custom data types, then they have, similar as with&lt;br/&gt;
payloads today, the byte[] indirection?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, byte[] is for String, but also for arbitrary (opaque to Lucene)&lt;br/&gt;
extensibility.  The six anonymous (separate package private classes)&lt;br/&gt;
concrete impls should give good efficiency to fit the different use&lt;br/&gt;
cases.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The code I initially wrote for 1231 exposed IndexOutput, so that one&lt;br/&gt;
can call write*() directly, without having to convert to byte[]&lt;br/&gt;
first. I think we will also want to do that for 2125 (store attributes&lt;br/&gt;
in the index). So I&apos;m wondering if this and 2125 should work&lt;br/&gt;
similarly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is compelling (letting Attrs read/write directly), but, I have&lt;br/&gt;
some questions:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;How would the random-access API work?  (Attrs are designed for&lt;br/&gt;
    iteration).  Eg, just providing IndexInput/Output to the Attr&lt;br/&gt;
    isn&apos;t quite enough &amp;#8211; the encoding is sometimes context dependent&lt;br/&gt;
    (like frq writes the delta between docIDs, the symbol table needed&lt;br/&gt;
    when reading/writing deref/sorted).  How would I build a random&lt;br/&gt;
    access API on top of that?  captureState-per-doc is too costly.&lt;br/&gt;
    What API would be used to write the shared state, ie, to tell the&lt;br/&gt;
    Attr &quot;we now are writing the segment, so you need to dump the&lt;br/&gt;
    symbol table&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;How would the packed ints work?  EG say my ints only need 5 bits.&lt;br/&gt;
    (Attrs are sort of designed for one-value-at-once).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;How would the &quot;symbol table&quot; based encodings (deref, sorted) work?&lt;br/&gt;
    I guess the attr would need to have some state associated with&lt;br/&gt;
    it, and when I first create the attr I need to pass it segment&lt;br/&gt;
    name, Directory, etc, so it opens the right files?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I&apos;m thinking we should still directly support native types, ie,&lt;br/&gt;
    Attrs are there for extensibility beyond native types?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Exposing single attr across a multi reader sounds tricky &amp;#8211;&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2154&quot; title=&quot;Need a clean way for Dir/MultiReader to &amp;quot;merge&amp;quot; the AttributeSources of the sub-readers&quot;&gt;LUCENE-2154&lt;/a&gt; (and, we need this for flex, which is worrying me!).&lt;br/&gt;
    But it sounds like you and Uwe are making some progress on that&lt;br/&gt;
    (using some under-the-hood Java reflection magic)... and this&lt;br/&gt;
    doesn&apos;t directly affect this issue, assuming we don&apos;t expose this&lt;br/&gt;
    API at the MultiReader level.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;
&lt;p&gt;Thinking out loud: Could we have then attributes with&lt;br/&gt;
serialize/deserialize methods for primitive types, such as float?&lt;br/&gt;
Could we efficiently use such an approach all the way up to&lt;br/&gt;
FieldCache? It would be compelling if you could store an attribute as&lt;br/&gt;
CSF, or in the postinglist, retrieve it from the flex APIs, and also&lt;br/&gt;
from the FieldCache. All would be the same API and there would only be&lt;br/&gt;
one place that needs to &quot;know&quot; about the encoding (the attribute).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is the grand unification of everything &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I like it, but, I&lt;br/&gt;
don&apos;t want that future utopia to stall our progress today... ie I&apos;d&lt;br/&gt;
rather do something simple yet concrete, now, and then work step by&lt;br/&gt;
step towards that future (&quot;progress not perfection&quot;).&lt;/p&gt;

&lt;p&gt;That said, if we can get some bite sized step in, today, towards that&lt;br/&gt;
future, that&apos;d be good.&lt;/p&gt;

&lt;p&gt;Eg, the current patch only supports &quot;dense&quot; storage, ie it&apos;s assumed&lt;br/&gt;
every document will have a value, because it&apos;s aiming to replace field&lt;br/&gt;
cache.  If we wanted to add sparse storage... I think that&apos;d&lt;br/&gt;
require/strongly encourage access via a postings-like iteration API,&lt;br/&gt;
which I don&apos;t see how to take a baby step towards &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I do think it would be compelling for an Attr to &quot;only&quot; have to expose&lt;br/&gt;
read/write methods, and then the Attr can be stored in CSF or&lt;br/&gt;
postings, but I don&apos;t see how to make an efficient random-access API&lt;br/&gt;
on top of that.  I think it&apos;s in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2125&quot; title=&quot;Ability to store and retrieve attributes in the inverted index&quot;&gt;LUCENE-2125&lt;/a&gt; where we should explore&lt;br/&gt;
this.&lt;/p&gt;

&lt;p&gt;Norms and deleted docs should be able to eventually switch to CSF.&lt;/p&gt;

&lt;p&gt;In fact, norms should just be a FloatSource, with default impl being&lt;br/&gt;
the 1-byte float encoding we use today.  This then gives apps full&lt;br/&gt;
flexibility to plugin their own FloatSource.&lt;/p&gt;

&lt;p&gt;For deleted docs we should probably create a BoolSource.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;About updating CSF: I hope we can use parallel indexing for that. In&lt;br/&gt;
other words: It should be possible for users to use parallel indexes&lt;br/&gt;
to update certain fields, and Lucene should use the same approach&lt;br/&gt;
internally to store different &quot;generations&quot; of things like norms and&lt;br/&gt;
CSFs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds great, though, I think we need a more efficient way to&lt;br/&gt;
store the changes.  Ie, norms rewrites all norms on any change, which&lt;br/&gt;
is costly.  It&apos;d be better to have some sort of delta format, where&lt;br/&gt;
you sparsely encode docID + new value, and then when loading we merge&lt;br/&gt;
those on the fly (and, segment merging periodically also merges &amp;amp;&lt;br/&gt;
commits them).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yeah, that&apos;s where I got kind of stuck with 1231: We need to figure&lt;br/&gt;
out how the public API should look like, with which a user can add CSF&lt;br/&gt;
values to the index and retrieve them. The easiest and fastest way&lt;br/&gt;
would be to add a dedicated new API. The cleaner one would be to make the whole&lt;br/&gt;
Document/Field/FieldInfos API more flexible. &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1597&quot; title=&quot;New Document and Field API&quot;&gt;&lt;del&gt;LUCENE-1597&lt;/del&gt;&lt;/a&gt; was a first attempt.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, but &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1597&quot; title=&quot;New Document and Field API&quot;&gt;&lt;del&gt;LUCENE-1597&lt;/del&gt;&lt;/a&gt; is another good but far-away-from-landing&lt;br/&gt;
goal.  I think a dedicated API is fine for the atomic types.  Field&lt;br/&gt;
cache today is a dedicated API...&lt;/p&gt;

&lt;p&gt;I guess to sum up my thoughts now (but I&apos;m still mulling...):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think the random-access-field-cache-like-API should be separate&lt;br/&gt;
    from the designed-for-iteration-from-a-file postings API.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Attrs for extensibilty could be compelling, but I don&apos;t see how to&lt;br/&gt;
    build an &lt;span class=&quot;error&quot;&gt;&amp;#91;efficient&amp;#93;&lt;/span&gt; random access API on top of Attrs.  It would&lt;br/&gt;
    be very elegant only having to add a read/write method to your&lt;br/&gt;
    Attr, but, that&apos;s not really enough for a full codec.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I don&apos;t think we should hold up adding direct support for atomic&lt;br/&gt;
    types until/if we can figure out how to add Attrs.  Ie I think we&lt;br/&gt;
    should do this in two steps.  The current patch is &lt;span class=&quot;error&quot;&gt;&amp;#91;roughly&amp;#93;&lt;/span&gt; step&lt;br/&gt;
    1, and I think should be a compelling replacement for field cache.&lt;br/&gt;
    Memory usage and GC cost of string sorting should be much lower&lt;br/&gt;
    than field cache.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m also still mulling on these issues w/ the current patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;How could we use index values to efficiently maintain stats needed&lt;br/&gt;
    for flexible scoring (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2187&quot; title=&quot;improve lucene&amp;#39;s similarity algorithm defaults&quot;&gt;LUCENE-2187&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Current patch doesn&apos;t handle merging yet.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Could norms/deleted docs &quot;conceivably&quot; cutover to index values&lt;br/&gt;
    API?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What &quot;dedicated API&quot; for indexing &amp;amp; sorting.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Run basic perf tests to see cost of using method instead of direct&lt;br/&gt;
    array.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12801250" author="mikemccand" created="Sat, 16 Jan 2010 18:34:30 +0000"  >&lt;p&gt;Attaching my current state &amp;#8211; things are still very very rough, and there are contrib/remote test failures.&lt;/p&gt;

&lt;p&gt;This patch has an initial integration with Lucene, enabling a Field to set how its values should be indexed into CSF... values are merged during indexign, and I created FieldComparators to use them for sorting.&lt;/p&gt;

&lt;p&gt;There are still some outright hacks in there, under nocommits (eg how SegmentInfo.files() computes the CSF files)...&lt;/p&gt;

&lt;p&gt;I&apos;m now thinking we should wrap up &amp;amp; land flex, before going much further on this feature...&lt;/p&gt;</comment>
                    <comment id="12802778" author="mikemccand" created="Wed, 20 Jan 2010 10:10:00 +0000"  >&lt;p&gt;I did a RAM cost estimation of FieldCache vs the approach in this&lt;br/&gt;
patch (attached mem.py).  I took a 5M doc Wikipedia index I have, and&lt;br/&gt;
computed how much RAM is used by FieldCache for STORE ONLY&lt;br/&gt;
(.getStrings) and for SORTING (.getStringIndex), vs the patch, on&lt;br/&gt;
the title field.  I assume all titles are unique:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;STORE ONLY
  32 bit current: 449.0 MB
  32 bit   patch: 136.0 MB [69.7% smaller]
  64 bit current: 487.1 MB
  64 bit   patch: 136.0 MB [72.1% smaller]

SORTING
  32 bit current: 468.0 MB
  32 bit   patch: 149.7 MB [68.0% smaller]
  64 bit current: 506.2 MB
  64 bit   patch: 149.7 MB [70.4% smaller]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is a sizable RAM savings!  Also, FieldCache creates 2X the&lt;br/&gt;
objects (because, I think, String creates a separate char[] to hold&lt;br/&gt;
the characters), whereas with the patch 2 or 3 &lt;span class=&quot;error&quot;&gt;&amp;#91;shared&amp;#93;&lt;/span&gt; arrays are&lt;br/&gt;
created, so there&apos;s obviously much less GC load too.&lt;/p&gt;</comment>
                    <comment id="12883681" author="simonw" created="Tue, 29 Jun 2010 21:30:40 +0100"  >&lt;p&gt;Attaching current status. I ported mikes patch to current trunk and added some tests here and there.&lt;br/&gt;
Current status is: &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;all tests pass&lt;/li&gt;
	&lt;li&gt;supports CompoundFile&lt;/li&gt;
	&lt;li&gt;several no-commits still present&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;next steps might be cleaning up most of the no-commits and maybe a first sketch on a Iterator API.&lt;/p&gt;

&lt;p&gt;Mike do you mind if I take this?&lt;/p&gt;</comment>
                    <comment id="12883872" author="mikemccand" created="Wed, 30 Jun 2010 11:15:30 +0100"  >&lt;p&gt;Great &amp;#8211; thanks for pushing this forward Simon!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Mike do you mind if I take this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Please do!&lt;/p&gt;</comment>
                    <comment id="12896108" author="simonw" created="Fri, 6 Aug 2010 19:18:30 +0100"  >&lt;p&gt;Attaching my current state to start iteration over the code as this patch contains may new things.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;All tests are passing&lt;/li&gt;
	&lt;li&gt;handles merging in a generic way&lt;/li&gt;
	&lt;li&gt;handles deletes&lt;/li&gt;
	&lt;li&gt;implements a  dedicated iterator API which operates on the files directly&lt;/li&gt;
	&lt;li&gt;unifies the Values API like Reader, Writer, Source and ValuesEnum&lt;/li&gt;
	&lt;li&gt;enables accessing Values via DirectoryReader (no optimized index needed)&lt;/li&gt;
	&lt;li&gt;add a proposal to utilize Attributes on a per Field basis&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;d like to throw this out and get initial feedback as quite a couple of things need to be discussed before we can proceed with this one. There are still a whole lot of nocommits in the code and some of the lower - level changes need review and feedback by people with more experience down there (Mike? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;

&lt;p&gt;I&apos;d really appreciate any comments especially on the API as this most important to me right now.&lt;/p&gt;

&lt;p&gt;I haven&apos;t had time to implement / propose something to use mmap for Source but this would be next on the list.&lt;br/&gt;
If you have questions please join!!&lt;/p&gt;

&lt;p&gt;Again, this is nothing which is really close to be committable but we are getting closer!&lt;br/&gt;
I would also like to move this to a branch as this seems to grow and a feature branch would be more convenient. &lt;/p&gt;</comment>
                    <comment id="12896112" author="yseeley@gmail.com" created="Fri, 6 Aug 2010 19:30:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;d really appreciate any comments especially on the API as this most important to me right now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Could you show some examples of the most efficient way to use this API?&lt;br/&gt;
i.e. an example that shows both how to index a document with a CSF, and then how to iterate over all values of a CSF (or get the value for a specific set of documents).&lt;/p&gt;</comment>
                    <comment id="12896122" author="simonw" created="Fri, 6 Aug 2010 19:59:12 +0100"  >&lt;p&gt;Hey Yonik,&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Could you show some examples of the most efficient way to use this API?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure! While it&apos;s already late over here I am happy to provide you those two examples. This is how you can index CSF with this Attribute approach:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
    RAMDirectory dir = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RAMDirectory();
    IndexWriter writer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(dir, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriterConfig(Version.LUCENE_40, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SimpleAnalyzer(Version.LUCENE_40)));
    Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    Fieldable fieldable = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; AttributeField(&lt;span class=&quot;code-quote&quot;&gt;&quot;myIntField&quot;&lt;/span&gt;);
    ValuesAttribute valuesAttribute = fieldable.attributes().addAttribute(ValuesAttribute.class);
    valuesAttribute.setType(Values.PACKED_INTS);
    valuesAttribute.ints().set(100);
    doc.add(fieldable);    
    writer.addDocument(doc);
    writer.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is how get the values back via source or the ValuesEnum:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    IndexReader reader = IndexReader.open(dir);
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; might be integrated into Fields eventually
&lt;/span&gt;    Reader indexValues = reader.getIndexValues(&lt;span class=&quot;code-quote&quot;&gt;&quot;myIntField&quot;&lt;/span&gt;); &lt;span class=&quot;code-comment&quot;&gt;// can get cached version too via reader.getIndexValuesCache();
&lt;/span&gt;    Source load = indexValues.load();
    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; value = load.ints(0);
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(value);

    &lt;span class=&quot;code-comment&quot;&gt;// or get it from the &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt;
&lt;/span&gt;    ValuesEnum intEnum = indexValues.getEnum();
    ValuesAttribute attr = intEnum.getAttribute(ValuesAttribute.class);
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;(intEnum.nextDoc() != ValuesEnum.NO_MORE_DOCS) {
      &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(attr.ints().get());
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I guess this should make it at least easier to get started. I actually expect people saying &lt;tt&gt;ValuesEnum&lt;/tt&gt; looks very much like &lt;tt&gt;DocsEnum&lt;/tt&gt; which is certainly correct. Yet, I didn&apos;t integrate &lt;tt&gt;ValuesEnum&lt;/tt&gt; into &lt;tt&gt;Fields&lt;/tt&gt; etc. for simplicity as changes to &lt;tt&gt;Fields&lt;/tt&gt; touches lot of code. Having &lt;tt&gt;ValuesEnum&lt;/tt&gt; being a &quot;stand-alone&quot; API makes iterating and development easier and a cut over to DocsEnum would be easy API wise as it already implements &lt;tt&gt;DocIdSetIterator&lt;/tt&gt;. &lt;/p&gt;

&lt;p&gt;With that in mind, the use of &lt;tt&gt;ValuesAttribute&lt;/tt&gt; makes sense too - with a stand-also API this would be obsolet and could be direct part of &lt;tt&gt;ValuesEnum&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;What I don&apos;t like about &lt;tt&gt;DocsEnum&lt;/tt&gt; is the &lt;tt&gt;BulkReadResult&lt;/tt&gt; class and its relative being a first class citizen in &lt;tt&gt;DocsEnum&lt;/tt&gt;. With CSF not every &lt;tt&gt;DocsEnum&lt;/tt&gt; iterates over &amp;lt;id,freq&amp;gt;* - but maybe we can move that to an attribute and make a more general abstract class.  The Attributes on those enums don&apos;t introduce a real overhead but solve lots of extendability problems though.&lt;/p&gt;</comment>
                    <comment id="12896530" author="mikemccand" created="Mon, 9 Aug 2010 14:07:05 +0100"  >&lt;p&gt;Great work Simon!&lt;/p&gt;

&lt;p&gt;Now that FieldCache has cut over to shared byte[] blocks, them mem&lt;br/&gt;
gains for CSF when storing byte[] data are mostly gone.&lt;/p&gt;

&lt;p&gt;But, there is still important benefits with CSF:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The full image is stored on-disk (= much faster than uninversion&lt;br/&gt;
    (&amp;amp; sometimes sorting) that FieldCache does, on startup)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You can specify all 6 combinations of variable/fixed length X&lt;br/&gt;
    straight/deref/sorted.  FieldCache is either var-length X deref&lt;br/&gt;
    (FieldCache.getTerms) or var-length X sorted&lt;br/&gt;
    (FieldCache.getTermsIndex).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It should be more extensible, ie, you can make your own attrs to&lt;br/&gt;
    store whatever you want.  EG we should be able to use this to&lt;br/&gt;
    store the flex scoring stats (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2392&quot; title=&quot;Enable flexible scoring&quot;&gt;&lt;del&gt;LUCENE-2392&lt;/del&gt;&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The end-user API is rather cumbersome now (ie, that the user must&lt;br/&gt;
interact directly w/ attrs).  It seems like we should have a sugar&lt;br/&gt;
layer on top, eg an IntField(Type) and I can do IntField.set/get.&lt;/p&gt;

&lt;p&gt;Also... maybe we should use Attrs the way NumericField does.  Ie, for&lt;br/&gt;
CSF we&apos;d have a TokenStream (single valued, for now anyway), and then&lt;br/&gt;
attrs could be added to it.  If we can get attr serialization&lt;br/&gt;
(&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2125&quot; title=&quot;Ability to store and retrieve attributes in the inverted index&quot;&gt;LUCENE-2125&lt;/a&gt;) online, then we can refactor all the read/write code in&lt;br/&gt;
this issue as the default attr serializers?  And, then, indexer would&lt;br/&gt;
have no special code for CSF in particular.  It just asks attrs to&lt;br/&gt;
serialize themselves...&lt;/p&gt;

&lt;p&gt;Shouldn&apos;t FloatsRef be FloatRef (same for IntsRef)?  It&apos;s ref&apos;ing a&lt;br/&gt;
single value right?&lt;/p&gt;</comment>
                    <comment id="12896614" author="simonw" created="Mon, 9 Aug 2010 17:50:55 +0100"  >&lt;blockquote&gt;
&lt;p&gt;It should be more extensible, ie, you can make your own attrs to&lt;br/&gt;
store whatever you want. EG we should be able to use this to&lt;br/&gt;
store the flex scoring stats (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2392&quot; title=&quot;Enable flexible scoring&quot;&gt;&lt;del&gt;LUCENE-2392&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is actually the first real use-case together with the norms which is kind of part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2392&quot; title=&quot;Enable flexible scoring&quot;&gt;&lt;del&gt;LUCENE-2392&lt;/del&gt;&lt;/a&gt; anyway&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The end-user API is rather cumbersome now (ie, that the user must&lt;br/&gt;
interact directly w/ attrs). It seems like we should have a sugar&lt;br/&gt;
layer on top, eg an IntField(Type) and I can do IntField.set/get.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah I guess lots of users would have a rather hard time with that. I remember Grant saying that he tries to explain Document and Fields since every in his trainings and with users in mind this should be done with least amount of changes. Nevertheless this is something which should be fixed outside of this particular issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2310&quot; title=&quot;Reduce Fieldable, AbstractField and Field complexity&quot;&gt;&lt;del&gt;LUCENE-2310&lt;/del&gt;&lt;/a&gt; would be one I could think of. Guess I need to talk to chrismale on Friday about that.&lt;/p&gt;


&lt;blockquote&gt;

&lt;p&gt;Also... maybe we should use Attrs the way NumericField does. Ie, for&lt;br/&gt;
CSF we&apos;d have a TokenStream (single valued, for now anyway), and then&lt;br/&gt;
attrs could be added to it. If we can get attr serialization&lt;br/&gt;
(&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2125&quot; title=&quot;Ability to store and retrieve attributes in the inverted index&quot;&gt;LUCENE-2125&lt;/a&gt;) online, then we can refactor all the read/write code in&lt;br/&gt;
this issue as the default attr serializers? And, then, indexer would&lt;br/&gt;
have no special code for CSF in particular. It just asks attrs to&lt;br/&gt;
serialize themselves...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2125&quot; title=&quot;Ability to store and retrieve attributes in the inverted index&quot;&gt;LUCENE-2125&lt;/a&gt; is something which would be nice to have together with CSF. Yet I don&apos;t think it depends on each other but it should use the same or very closely related APIs eventually. &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2125&quot; title=&quot;Ability to store and retrieve attributes in the inverted index&quot;&gt;LUCENE-2125&lt;/a&gt; has different problems to tackle first I guess - but I am closely following that! I will update that patch to make use of the &lt;/p&gt;
{NumericField}
&lt;p&gt; - lets call it - work-around to make this patch &quot;less hairy&quot;. Still hairy but I like the idea of using TokenStream to attach the ValuesAttribute.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Shouldn&apos;t FloatsRef be FloatRef (same for IntsRef)? It&apos;s ref&apos;ing a&lt;br/&gt;
single value right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes and no. I was too lazy to add all the capabilities &lt;/p&gt;
{BytesRef}
&lt;p&gt; has but I could imagine that this can benefit from being able to hold more values - maybe a entire page when paging is used.  If it only holds a single value we don&apos;t need offset and length too. I will leaf it like that for now, can still change it later if it turns out that we don&apos;t need this flexibility.&lt;/p&gt;

&lt;p&gt;I guess I will move the ValuesEnum down to Fields and FieldsEnum soon. I don&apos;t think we should confuse this with an DocsEnum since DocsEnum is so closely related to Terms and has explicit getters for freq() though. DocIdSetIterator seems to be fine for that purpose - while the AttributeSource could be pulled up.&lt;/p&gt;</comment>
                    <comment id="12914488" author="simonw" created="Fri, 24 Sep 2010 15:42:13 +0100"  >&lt;p&gt;We should get the BytesHash in first to make this patch little simpler. I don&apos;t wanna refactor TermsHashPerField in here. &lt;/p&gt;</comment>
                    <comment id="12914490" author="simonw" created="Fri, 24 Sep 2010 15:44:09 +0100"  >&lt;p&gt;I would want to move this to a branch for further development. If nobody objects I&apos;m gonna move forward within the next days.&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12914494" author="rcmuir" created="Fri, 24 Sep 2010 15:54:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;I would want to move this to a branch for further development. If nobody objects I&apos;m gonna move forward within the next days.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;In my opinion, if its helpful to use a branch for a feature like this, we should not hesitate!&lt;br/&gt;
With a lot of development on trunk, big patches make it difficult for anyone to get involved.&lt;/p&gt;

&lt;p&gt;Additionally its extremely difficult to iterate, because its hard to see the differences between iterations.&lt;br/&gt;
But say, with the flexible indexing branch, this history is preserved since it was done in a branch.&lt;br/&gt;
So I am able to just click &apos;view merged revisions&apos; in my IDE and see all that history.&lt;/p&gt;</comment>
                    <comment id="12919729" author="simonw" created="Mon, 11 Oct 2010 07:29:59 +0100"  >&lt;p&gt;Updates patch to trunk - all tests pass. Since &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1990&quot; title=&quot;Add unsigned packed int impls in oal.util&quot;&gt;&lt;del&gt;LUCENE-1990&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2662&quot; title=&quot;BytesHash&quot;&gt;&lt;del&gt;LUCENE-2662&lt;/del&gt;&lt;/a&gt; have been committed some of the improvement / refactorings in this patch became obsolet. I update everything to current trunk and made the Field / Values API somewhat easier to use. I would go a create a branch based on this patch in the next days.&lt;/p&gt;

&lt;p&gt;Anybody preferences on the name? I would suggest &quot;values_branch&quot; or &quot;perdoc-payloads&quot; but it really doesn&apos;t matter though. Suggestions?&lt;/p&gt;</comment>
                    <comment id="12919769" author="mikemccand" created="Mon, 11 Oct 2010 10:53:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;Updates patch to trunk - all tests pass&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Patch is looking good....&lt;/p&gt;

&lt;p&gt;There are still many nocommits but most look like they could become TODOs?&lt;/p&gt;

&lt;p&gt;Do you have a high level sense of what&apos;s missing before we can commit to trunk?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anybody preferences on the name? I would suggest &quot;values_branch&quot; or &quot;perdoc-payloads&quot; but it really doesn&apos;t matter though. Suggestions?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about docvalues?  You don&apos;t need the _branch part since it&apos;ll be at &lt;a href=&quot;http://svn.apache.org.../branches/docvalues&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org.../branches/docvalues&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12919864" author="simonw" created="Mon, 11 Oct 2010 16:18:06 +0100"  >&lt;blockquote&gt;
&lt;p&gt;There are still many nocommits but most look like they could become TODOs?&lt;br/&gt;
Do you have a high level sense of what&apos;s missing before we can commit to trunk?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes and No &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, here is my roadmap for this issue. We have 47 nocommit pending where about the half of it can be TODOs while the other half of it are rather easy task and should be fixed before we go to trunk.&lt;br/&gt;
These are the major steps I would like to finish until we land this on trunk&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Implement bulk copies for merging where possible. Currently there are still some value types not bulk copied and the ones which are only do if there are no deletes. Yet, the deletes thing I would make a TODO for now - we can still make that more efficient once we are on trunk. If I recall correctly figuring out the next deleted document is still a linear problem (I need to iterate through deletes), right? I guess that would be easier if I could figure out the next one so see if bulks are reasonable - maybe an invalid concern though.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Exposing the API via Fields / IndexReader. I think we should expose the Iterator API via Fields just like Terms is today. Currently it doesn&apos;t feel very natural to get the ValuesEnum via IR.&lt;/li&gt;
	&lt;li&gt;Rethink the Source API - I get the feeling that we don&apos;t really need the Source class but could rather use a Random Access Enum like Terms where we can see back and forth depending on how we loaded the fields values. We could actually unify the iterator API and random access which would catch two birds with one stone. internally we simply use the *Refs to set the actual values, default values would no be needed anymore (would save some code / branches internally) and the user would not have to access two different APIs. Additionally we could expose bulk reads just like BulkReadResult in DocsEnum to obtain all values in an array. Maybe if we wanna populate FieldsCache from it. I think we won&apos;t have perf. losts due to that since there is not really an overhead compared to the get() call on Source. - Reminds me I need to think about how we use that with sorted values.... If we keep Source we should at least make it implement ValuesEnum so we can use it as enumeration if they are in mem already.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;To do merging for byte values correctly we need to figure out how to specify the comparator for each field. I don&apos;t have a concrete idea for this but I think this should somehow go into IndexWriterConfig in a per field map. Thougths?&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Remaining nocommits could be converted into TODOs - I think we can do so with the following&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Evaluate if we can decide if a Bytes Payload should be stored as straight or as fixed which would make it easier for the user to use the byte variants.&lt;/li&gt;
	&lt;li&gt;Evaluate if we need String variants or if they can simple be solved with the byte ones&lt;/li&gt;
	&lt;li&gt;We should have some king of compatibility notion so that slightly different segments can be merged like fixed vs. var bytes float32 vs. float64.&lt;/li&gt;
	&lt;li&gt;For a cleaner transition we should create a sep. SortField that always uses index values.&lt;/li&gt;
	&lt;li&gt;explore a better way to obtain all dat / idx fiels in SegmentInfo to do segment merges for index values.&lt;/li&gt;
	&lt;li&gt;BytesValueProcessor should be thread private but I will leave that as a todo since this code might change anyway once realtime lands on trunk though. Not super urgent for now.&lt;/li&gt;
	&lt;li&gt;Fix some exception handling issues especially in MultiSource &amp;amp; MultiValuesEnum&lt;/li&gt;
	&lt;li&gt;Fix the singed / unsigned limitations in Ints implementation&lt;/li&gt;
	&lt;li&gt;Explore ways to preven Ints impl do two method calls maybe we can expose PackedInts directly somehow&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;How about docvalues? You don&apos;t need the _branch part since it&apos;ll be at &lt;a href=&quot;http://svn.apache.org.../branches/docvalues&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org.../branches/docvalues&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;OK&lt;/p&gt;</comment>
                    <comment id="12920110" author="simonw" created="Tue, 12 Oct 2010 07:20:41 +0100"  >&lt;p&gt;created branch at &lt;a href=&quot;http://http://svn.apache.org/repos/asf/lucene/dev/branches/docvalues/&quot; class=&quot;external-link&quot;&gt;docvalues&lt;/a&gt; and committed the last patch at r1021636. I think the next steps are adding a fix version &quot;docvalues&quot; to JIRA and create new issues according to the &quot;roadmap&quot; above. Once we are through with the mandatory stuff and documentation we can land this on trunk. Thoughts?&lt;/p&gt;

&lt;p&gt;I&apos;m not sure if we should continue on this issue or close it and create a new &quot;top level&quot; one and spawn issues from there.&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12920151" author="mikemccand" created="Tue, 12 Oct 2010 11:08:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Implement bulk copies for merging where possible. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think this should block landing on trunk?  (Even in the non-deletes case).&lt;/p&gt;

&lt;p&gt;But, yes, searching for next del doc is a linear op, but a very small constant in front (at least OpenBitSet.nextSetBit, though del docs are currently a BitVector), yet is very much worth it once we get the bulk copying in since presumably big chunks of docs can be bulk copied.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Exposing the API via Fields / IndexReader. I think we should expose the Iterator API via Fields just like Terms is today. Currently it doesn&apos;t feel very natural to get the ValuesEnum via IR.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh that does sound like the right place.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe if we wanna populate FieldsCache from it. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We should be careful here &amp;#8211; it&apos;s best if things consume the docvalues instead of double-copying into the FC.&lt;/p&gt;</comment>
                    <comment id="12935428" author="mikemccand" created="Wed, 24 Nov 2010 18:29:18 +0000"  >&lt;p&gt;I think this is very close!!&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Using attr source as the way to specify the docValue is nice in&lt;br/&gt;
    that we get full extensibility, but, it&apos;s also heavyweight&lt;br/&gt;
    compared to a dedicated API (ie, .setIntValue, etc.).  So I think&lt;br/&gt;
    this means apps that use doc values really must re-use their Field&lt;br/&gt;
    instances (if they are using doc values) else indexing performance&lt;br/&gt;
    will likely take a good hit.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;ValuesField is nice sugar on top (of the attr) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Can you add some&lt;br/&gt;
    jdocs to ValuesField? EG it&apos;s not stored/indexed.  It&apos;s OK to have&lt;br/&gt;
    same field name as existing field (hmm... is it)?  Etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Did you want to make FieldsConsumer.addValuesField abstract?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The javadoc above DocValues.Source is wrong &amp;#8211; Source is not just&lt;br/&gt;
    for ints.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You can change jdocs like &quot;This feature is experimental and the&lt;br/&gt;
    API is free to change in non-backwards-compatible ways.&quot; to&lt;br/&gt;
    @lucene.experimental &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  (eg in Values.java)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;So, you&apos;re not allowed to change the DocValues type for a field&lt;br/&gt;
    once you&apos;ve set it the first time... and, also, segments cannot be&lt;br/&gt;
    merged if the same field has different value types.  I&apos;m thinking&lt;br/&gt;
    it&apos;s really important now to carry over the same FieldInfos from&lt;br/&gt;
    the last segment when opening the writer (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1737&quot; title=&quot;Always use bulk-copy when merging stored fields and term vectors&quot;&gt;&lt;del&gt;LUCENE-1737&lt;/del&gt;&lt;/a&gt;)... because&lt;br/&gt;
    hitting that IllegalStateExc during merge is a trap.  This would&lt;br/&gt;
    let us change that IllegalStateExc into an assert (in&lt;br/&gt;
    SegmentMerger) and also turn the assert back on in FieldsConsumer.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Should we rename MissingValues to MissingValue? Ie it holds the&lt;br/&gt;
    single value for your type that represents &quot;missing&quot;?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We need better names than PagedBytes.fillUsingLengthPrefix,2,3,4&lt;br/&gt;
    heh.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;d be nice to have a more approachable test case that shows the&lt;br/&gt;
    &quot;simple&quot; way to index doc values, ie using ValuesField instead of&lt;br/&gt;
    getting the attr, getting the intsRef, setting it, etc.  I think&lt;br/&gt;
    such an &quot;example&quot; should be very compact right?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12935713" author="simonw" created="Thu, 25 Nov 2010 10:40:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think this is very close!!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Heh, I strongly agree!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;    Using attr source as the way to specify the docValue is nice in&lt;br/&gt;
    that we get full extensibility, but, it&apos;s also heavyweight&lt;br/&gt;
    compared to a dedicated API (ie, .setIntValue, etc.).  So I think&lt;br/&gt;
    this means apps that use doc values really must re-use their Field&lt;br/&gt;
    instances (if they are using doc values) else indexing performance&lt;br/&gt;
    will likely take a good hit.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Well it is a nice way of extending field but I am not sure if we&lt;br/&gt;
should keep it since it is heavy weight. We could get rid of&lt;br/&gt;
ValuesAttribute for landing on trunk and work on making field&lt;br/&gt;
extendible - which is desperately needed anyway. I was also thinking&lt;br/&gt;
that the ValuesEnum doesn&apos;t need the ValuesAttribute per se. it would&lt;br/&gt;
be more intuitive to have getter on ValuesEnum too. I just really hate&lt;br/&gt;
those instanceof checks on fields.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;   ValuesField is nice sugar on top (of the attr) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Can you add some&lt;br/&gt;
    jdocs to ValuesField? EG it&apos;s not stored/indexed.  It&apos;s OK to have&lt;br/&gt;
    same field name as existing field (hmm... is it)?  Etc.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah - until here I haven&apos;t done much javadoc but that is on top of&lt;br/&gt;
the list. I will start adding JavaDoc to main classes of the API and&lt;br/&gt;
ValuesField is 100% a main class of it.&lt;br/&gt;
BTW. it is ok to have the same name as a existing field.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Did you want to make FieldsConsumer.addValuesField abstract?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That is a leftover - I will remove it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The javadoc above DocValues.Source is wrong &amp;#8211; Source is not just for ints.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;True - see above that class had a different purpose back in the days&lt;br/&gt;
where it was a patch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can change jdocs like &quot;This feature is experimental and the&lt;br/&gt;
API is free to change in non-backwards-compatible ways.&quot; to&lt;br/&gt;
 @lucene.experimental &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  (eg in Values.java)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah - its good to have stuff like that left!!!!! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; yay!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; So, you&apos;re not allowed to change the DocValues type for a field&lt;br/&gt;
 once you&apos;ve set it the first time... and, also, segments cannot be&lt;br/&gt;
merged if the same field has different value types.  I&apos;m thinking&lt;br/&gt;
it&apos;s really important now to carry over the same FieldInfos from&lt;br/&gt;
the last segment when opening the writer (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1737&quot; title=&quot;Always use bulk-copy when merging stored fields and term vectors&quot;&gt;&lt;del&gt;LUCENE-1737&lt;/del&gt;&lt;/a&gt;)... because&lt;br/&gt;
hitting that IllegalStateExc during merge is a trap.  This would&lt;br/&gt;
let us change that IllegalStateExc into an assert (in&lt;br/&gt;
SegmentMerger) and also turn the assert back on in FieldsConsumer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that should not block us from moving forward and landing on trunk ey?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Should we rename MissingValues to MissingValue? Ie it holds the single&lt;br/&gt;
value for your type that represents &quot;missing&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, I was also thinking to rename some of the classes like&lt;br/&gt;
Values -&amp;gt; DocValueType&lt;br/&gt;
PackedIntsImpl -&amp;gt; Ints&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;We need better names than PagedBytes.fillUsingLengthPrefix,2,3,4&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;hehe yeah - lemme change the one I added and lets fix the rest on&lt;br/&gt;
trunk. I will open an issue once I have a reliable inet connection&lt;br/&gt;
again.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; It&apos;d be nice to have a more approachable test case that shows the&lt;br/&gt;
&quot;simple&quot; way to index doc values, ie using ValuesField instead of&lt;br/&gt;
getting the attr, getting the intsRef, setting it, etc.  I think&lt;br/&gt;
such an &quot;example&quot; should be very compact right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done on my checkout!&lt;/p&gt;

&lt;p&gt;so on my list there are the following topics until landing:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;missing testcase for addIndexes and a simple one to show how to use the api&lt;/li&gt;
	&lt;li&gt;split up exiting tests in smaller tests - they test too much and&lt;br/&gt;
they are hard to understand&lt;/li&gt;
	&lt;li&gt;Add JavaDoc to main classes like DocValues, Source, ValuesEnum, ValuesField&lt;/li&gt;
	&lt;li&gt;Document the different types&lt;/li&gt;
	&lt;li&gt;Consistent class naming - see above&lt;/li&gt;
	&lt;li&gt;enable ram usage tracking for all DocValuesProducer to support&lt;br/&gt;
flush by RAM usage&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That seems very very close to me. Lets see how much I get done on my&lt;br/&gt;
flight to boston &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12935977" author="mikemccand" created="Fri, 26 Nov 2010 11:20:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;BTW. it is ok to have the same name as a existing field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is, usually... but we should add a test to assert this is still the&lt;br/&gt;
case for other field + ValuesField?&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I&apos;m thinking it&apos;s really important now to carry over the same FieldInfos from the last segment when opening the writer (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1737&quot; title=&quot;Always use bulk-copy when merging stored fields and term vectors&quot;&gt;&lt;del&gt;LUCENE-1737&lt;/del&gt;&lt;/a&gt;)... because hitting that IllegalStateExc during merge is a trap.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that should not block us from moving forward and landing on trunk ey?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It makes me mighty nervous though... I&apos;ll try to get that issue done&lt;br/&gt;
soon.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Well it is a nice way of extending field but I am not sure if we&lt;br/&gt;
should keep it since it is heavy weight. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The ValuesAttr for ValuesField is actually really heavyweight.  Not&lt;br/&gt;
only must it fire up an AttrSource, but then ValuesAttrImpl itself has&lt;br/&gt;
a field for each type.  Worse, for the type you do actually use, it&apos;s&lt;br/&gt;
then another object eg FloatsRef, which in turn holds&lt;br/&gt;
array/offset/len, a new length 1 array, etc.&lt;/p&gt;

&lt;p&gt;Maybe we shouldn&apos;t use attrs here?  And instead somehow let&lt;br/&gt;
ValuesField store a single value as it&apos;s own private member?&lt;/p&gt;

&lt;p&gt;FloatsRef, LongsRef are missing the ASL header.  Maybe it&apos;s time to&lt;br/&gt;
run RAT &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12935994" author="simonw" created="Fri, 26 Nov 2010 12:35:10 +0000"  >&lt;blockquote&gt;
&lt;p&gt;It is, usually... but we should add a test to assert this is still the&lt;br/&gt;
case for other field + ValuesField?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I already implemented a simple testcase that shows that this works as an example (I will commit that soon though) but I think we need to add another test that ensures that this works with all types of DocValues though. Yet, I work on making the test more &quot;atomic&quot; and test only a single thing anyway so i will add that too.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It makes me mighty nervous though... I&apos;ll try to get that issue done soon.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Well until then I just go on and get the remaining stuff done here.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;Maybe we shouldn&apos;t use attrs here? And instead somehow let ValuesField store a single value as it&apos;s own private member?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I more and more think we can nuke ValuesAttribute completely since its other purpose on ValuesEnum is somewhat obsolete too. It is actually a leftover from earlier days where I was experimenting with using DocEnum to serve CSF too. There it would have made sense though but now we can provide a dedicated API. It still bugs me that Field is so hard to extend. We really need to fix that soon!&lt;/p&gt;

&lt;p&gt;I think what we should do is extend AbstractField and simply use a long/double/BytesRef and force folks to add another field instance if they want to have it indexed and stored.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Maybe it&apos;s time to run RAT&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                    <comment id="12964464" author="mikemccand" created="Sat, 27 Nov 2010 23:07:07 +0000"  >&lt;p&gt;Is there any test cases that cover the new FieldComparators that use the doc values?&lt;/p&gt;

&lt;p&gt;I think a good test case would be to sort w/ FieldCache and then again w/ doc values and verify they match...&lt;/p&gt;</comment>
                    <comment id="12965242" author="simonw" created="Tue, 30 Nov 2010 14:48:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;Is there any test cases that cover the new FieldComparators that use the doc values?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;not yet, I added it to my internal roadmap to land on trunk. I just committed my latest changes including a simple testcase to show how to use the API and used bytes tracking. &lt;/p&gt;

&lt;p&gt;here is a list of what is missing:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /*
   * TODO:
   * Roadmap to land on trunk
   *   - Cut over to a direct API on ValuesEnum vs. ValuesAttribute 
   *   - Add documentation &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;:
   *      - Source and ValuesEnum
   *      - DocValues
   *      - ValuesField
   *      - ValuesAttribute
   *      - Values
   *   - Add @lucene.experimental to all necessary classes
   *   - Try to make ValuesField more lightweight -&amp;gt; AttributeSource
   *   - add test &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; unoptimized &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; with deletes
   *   - add a test &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; addIndexes
   *   - split up existing testcases and give them meaningfull names
   *   - use consistent naming throughout DocValues
   *     - Values -&amp;gt; DocValueType
   *     - PackedIntsImpl -&amp;gt; Ints
   *   - run RAT
   *   - add tests &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; FieldComparator FloatIndexValuesComparator vs. FloatValuesComparator etc.
   */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;once I am through with it I will create a new issue and create the final patch so we can iterate over it if needed.&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12968381" author="yseeley@gmail.com" created="Mon, 6 Dec 2010 19:47:25 +0000"  >&lt;p&gt;Whew... this interface is more expansive than I thought it would be (but I guess it&apos;s really many issues rolled into one... like sorting, caching, etc).&lt;br/&gt;
So it seems like DocValuesEnum is the traditional lowest level &quot;read the index&quot;, and Source is a cached version of that?&lt;/p&gt;

&lt;p&gt;A higher level question I have is why we&apos;re not reusing the FieldCache for caching/sorting?&lt;/p&gt;</comment>
                    <comment id="12968416" author="simonw" created="Mon, 6 Dec 2010 21:21:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Whew... this interface is more expansive than I thought it would be (but I guess it&apos;s really many issues rolled into one... like sorting, caching, etc).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;sorry about that &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So it seems like DocValuesEnum is the traditional lowest level &quot;read the index&quot;, and Source is a cached version of that?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not quiet DocValuesEnum is an iterator based access to the DocValues which does not load everything to memory while Source is a entirely Ram-Resident offering random access to values similar to field cache. Yet, you can also obtain a DocValuesEnum from a Source since its already in memory. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A higher level question I have is why we&apos;re not reusing the FieldCache for caching/sorting?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You mean as a replacement for Source? - For caching what we did in here is to leave it to the user to do the caching or cache based on Source instance how would that relate to FieldCache in your opinion?&lt;/p&gt;</comment>
                    <comment id="12979395" author="jasonrutherglen" created="Sun, 9 Jan 2011 19:29:41 +0000"  >&lt;p&gt;Out of curiosity, re: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2312&quot; title=&quot;Search on IndexWriter&amp;#39;s RAM Buffer&quot;&gt;LUCENE-2312&lt;/a&gt;, are we planning on putting CSF into Lucene 4.x?  What&apos;s left to be done?&lt;/p&gt;</comment>
                    <comment id="12979404" author="simonw" created="Sun, 9 Jan 2011 20:47:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;Out of curiosity, re: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2312&quot; title=&quot;Search on IndexWriter&amp;#39;s RAM Buffer&quot;&gt;LUCENE-2312&lt;/a&gt;, are we planning on putting CSF into Lucene 4.x? What&apos;s left to be done?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;we are very close - to land on trunk there is about an evening of work left. JDoc is missing here and there plus some tests for FieldComparators - thats it!&lt;/p&gt;</comment>
                    <comment id="12979407" author="jasonrutherglen" created="Sun, 9 Jan 2011 21:12:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;we are very close - to land on trunk there is about an evening of work left. JDoc is missing here and there plus some tests for FieldComparators - thats it!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nice!  Once it&apos;s in I&apos;ll try to get started on the RT field cache/doc values, which can likely be implemented and tested somewhat independent of the RT inverted index.&lt;/p&gt;</comment>
                    <comment id="13017679" author="jasonrutherglen" created="Fri, 8 Apr 2011 22:57:14 +0100"  >&lt;p&gt;I&apos;m wondering if there is a limitation on whether or not we can randomly access the doc values from the underlying Directory implementation, rather than need to load all the values directly into the main heap space.  This seems doable, and if so let me know if I can provide a patch.&lt;/p&gt;</comment>
                    <comment id="13017822" author="simonw" created="Sat, 9 Apr 2011 10:13:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m wondering if there is a limitation on whether or not we can randomly access the doc values from the underlying Directory implementation, rather than need to load all the values directly into the main heap space. This seems doable, and if so let me know if I can provide a patch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;the current implementation to access docValues not loaded into memory uses DocIdSetIterator as its parent interface so it works only in one direction currently. changing this to a random access &quot;seekable&quot; API should be not too hard. &lt;br/&gt;
Look at &lt;a href=&quot;http://svn.apache.org/repos/asf/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org/repos/asf/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;
</comment>
                    <comment id="13017886" author="jasonrutherglen" created="Sat, 9 Apr 2011 15:58:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;changing this to a random access &quot;seekable&quot; API should be not too hard&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we can offer the option of MMap&apos;ing the field caches, which I think will help alleviate OOMs?&lt;/p&gt;</comment>
                    <comment id="13025033" author="lancenorskog" created="Tue, 26 Apr 2011 03:49:25 +0100"  >&lt;p&gt;What&apos;s the current status on this? &lt;/p&gt;</comment>
                    <comment id="13025130" author="simonw" created="Tue, 26 Apr 2011 09:29:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;What&apos;s the current status on this?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I am currently focusing on RT and DWPT to be landed on trunk. Once this is done I can merge DocValues and finish the last remaining limitations. Its pretty close there are a couple of issues like javadoc (not complete but close), Codec integration is somewhat flaky and needs some new api. Feature wise its complete.&lt;/p&gt;
</comment>
                    <comment id="13046460" author="simonw" created="Thu, 9 Jun 2011 11:49:31 +0100"  >&lt;p&gt;currently landing on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3108&quot; title=&quot;Land DocValues on trunk&quot;&gt;&lt;del&gt;LUCENE-3108&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                                <inwardlinks description="is blocked by">
                            <issuelink>
            <issuekey id="12438385">LUCENE-1990</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12474788">LUCENE-2662</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                        <issuelinktype id="12310010">
                <name>Incorporates</name>
                                <outwardlinks description="incorporates">
                            <issuelink>
            <issuekey id="12477214">LUCENE-2700</issuekey>
        </issuelink>
                    </outwardlinks>
                                                <inwardlinks description="is part of">
                            <issuelink>
            <issuekey id="12391410">LUCENE-1231</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12444511">LUCENE-2187</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12474349">LUCENE-2649</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12474301">LUCENE-2648</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12456830" name="LUCENE-2186.patch" size="219003" author="simonw" created="Mon, 11 Oct 2010 07:29:59 +0100" />
                    <attachment id="12451447" name="LUCENE-2186.patch" size="239636" author="simonw" created="Fri, 6 Aug 2010 19:18:30 +0100" />
                    <attachment id="12448351" name="LUCENE-2186.patch" size="164260" author="simonw" created="Tue, 29 Jun 2010 21:30:40 +0100" />
                    <attachment id="12430515" name="LUCENE-2186.patch" size="413266" author="mikemccand" created="Sat, 16 Jan 2010 18:34:30 +0000" />
                    <attachment id="12429272" name="LUCENE-2186.patch" size="96650" author="mikemccand" created="Sat, 2 Jan 2010 15:10:29 +0000" />
                    <attachment id="12430868" name="mem.py" size="2045" author="mikemccand" created="Wed, 20 Jan 2010 10:10:00 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 2 Jan 2010 18:53:35 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11600</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25539</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>