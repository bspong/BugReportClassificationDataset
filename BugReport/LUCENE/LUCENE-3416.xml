<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:59:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3416/LUCENE-3416.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3416] Allow to pass an instance of RateLimiter to FSDirectory allowing to rate limit merge IO across several directories / instances</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3416</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This can come in handy when running several Lucene indices in the same VM, and wishing to rate limit merge across all of them.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12521431">LUCENE-3416</key>
            <summary>Allow to pass an instance of RateLimiter to FSDirectory allowing to rate limit merge IO across several directories / instances</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="simonw">Simon Willnauer</assignee>
                                <reporter username="kimchy">Shay Banon</reporter>
                        <labels>
                    </labels>
                <created>Tue, 6 Sep 2011 11:06:08 +0100</created>
                <updated>Fri, 9 Sep 2011 21:35:49 +0100</updated>
                    <resolved>Fri, 9 Sep 2011 21:35:49 +0100</resolved>
                                                            <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13097873" author="simonw" created="Tue, 6 Sep 2011 11:19:56 +0100"  >&lt;p&gt;Shay, can&apos;t you use a Input / Output wrapper on a RateLimitingDirectoryDelegate? With lucene 4.0 you get the IOContext when open / creating streams so you can decide based on this?&lt;/p&gt;</comment>
                    <comment id="13098018" author="kimchy" created="Tue, 6 Sep 2011 15:07:59 +0100"  >&lt;p&gt;It is possible, but requires more work to do, and depends on overriding the createOutput method (as well as all the other methods in Directory). If rate limiting makes sense on the directory level to be exposed as a &quot;feature&quot;, I think that this small change allows for greater control over it.&lt;/p&gt;</comment>
                    <comment id="13098286" author="simonw" created="Tue, 6 Sep 2011 20:18:25 +0100"  >&lt;p&gt;I see, I guess that is kind of overkill here. This patch looks fine to me though while I wonder why this needs to be synchronized since we don&apos;t read it from a synced block. if you want this to take immediate effect you should rather use volatile here? I doubt that this is necessary in this context - I&apos;d rather not invalidate a cache line for each IndexOutput creation.&lt;/p&gt;</comment>
                    <comment id="13099146" author="kimchy" created="Wed, 7 Sep 2011 18:52:06 +0100"  >&lt;p&gt;The only reason its synchronized is because the setMaxMergeWriteMBPerSec method is synchronized (I guess to protected from setting the rate limit concurrently). In practice, I don&apos;t see users changing it that often, so concerns about cache lines are not really relevant.&lt;/p&gt;</comment>
                    <comment id="13099154" author="simonw" created="Wed, 7 Sep 2011 18:58:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;The only reason its synchronized is because the setMaxMergeWriteMBPerSec method is synchronized (I guess to protected from setting the rate limit concurrently). In practice, I don&apos;t see users changing it that often, so concerns about cache lines are not really relevant.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;this make no sense to me. If you don&apos;t want to set this concurrently how does a lock protect you from this? I mean you if you have two threads accessing this you have either A B or B A. but this would happen without a lock too. if you want to have the changes to take effect immediately you need to either lock on each read on this var or make it volatile which is almost equivalent (a mem barrier). &lt;/p&gt;

&lt;p&gt;My concern here was related to make this var volatile which would be a cacheline invalidation each time you read the var. I think we should get rid of the synchronized.&lt;/p&gt;</comment>
                    <comment id="13099160" author="kimchy" created="Wed, 7 Sep 2011 19:10:58 +0100"  >&lt;p&gt;&amp;gt; this make no sense to me. If you don&apos;t want to set this concurrently how does a lock protect you from this? I mean you if you have two threads accessing this you have either A B or B A. but this would happen without a lock too. if you want to have the changes to take effect immediately you need to either lock on each read on this var or make it volatile which is almost equivalent (a mem barrier).&lt;/p&gt;

&lt;p&gt;No, thats not correct. setMaxMergeWriteMBPerSec (not the method I added, the other one) is a complex method, and I think Mike wanted to protect from two threads setting the value concurrently. As for reading the value, I think Mike logic was that its not that importnat the have &quot;immediate&quot; visibility of the change to require a volatile field (which is understandable). So, since setMaxMergeWriteMBPerSec is synchronized, the method added in this patch has to be as well.&lt;/p&gt;

&lt;p&gt;&amp;gt; My concern here was related to make this var volatile which would be a cacheline invalidation each time you read the var. I think we should get rid of the synchronized.&lt;/p&gt;

&lt;p&gt;Reading a volatile var in x86 is not a cache invalidation, though it does come with a cost. Its not relevant here based on what I explained before (and second guessing Mike &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;</comment>
                    <comment id="13099195" author="simonw" created="Wed, 7 Sep 2011 19:45:51 +0100"  >&lt;blockquote&gt;&lt;p&gt;Reading a volatile var in x86 is not a cache invalidation, though it does come with a cost.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yes unless you are reading and writing it. Yet since this is not intended here we don&apos;t need to get into details. Bottom line that synchronization doesn&apos;t make much sense here. we should try to control some order here that we can not control. if somebody sets either of those concurrently they should take care of synchronization. What should I expect if you set this concurrently? IMO we should craft those method to work without synchronization which is certainly possible. synchronized here buys us nothing and should be removed.&lt;/p&gt;</comment>
                    <comment id="13099210" author="mikemccand" created="Wed, 7 Sep 2011 19:54:41 +0100"  >&lt;p&gt;I made setMaxMergeWriteMBPerSec sync&apos;d because ie has tricky logic about creating a new RateLimiter or reusing an existing one (so current merges can see the change on a &quot;best effort&quot; basis) or clearing the current one... so I just wanted to be safe and have only one thread doing this at once; else eg you could get NPE I think.&lt;/p&gt;

&lt;p&gt;But, probably we should in fact make mergeWriteRateLimiter volatile, just to make sure the unsync&apos;d read sees the current value?  The minor added read cost should be negligible vs the overhead of creating / writing / closing files.&lt;/p&gt;</comment>
                    <comment id="13099233" author="kimchy" created="Wed, 7 Sep 2011 20:16:33 +0100"  >&lt;p&gt;I agree with Mike, I think it should remain synchronized, it does safeguard concurrently calling setMaxMergeWriteMBPerSec from falling over itself (who &quot;wins&quot; the call is not really relevant). Since thats synchronized, the metod I added should be as well. Personally, I really don&apos;t think there is a need to make it thread safe without &quot;blocking&quot;, since calling the &quot;setters&quot; is not something people do frequently at all, so the optimization is mute, and it will complicate the code.&lt;/p&gt;

&lt;p&gt;As for making mergeWriteRateLimiter volatile, it can be done. Though, in practice, there really is no need to do it (there is a memory barrier when reading it before). But, I think that should go in a different issue? Just to keep changes clean and isolated?&lt;/p&gt;</comment>
                    <comment id="13099235" author="simonw" created="Wed, 7 Sep 2011 20:18:37 +0100"  >&lt;p&gt;what about something like that:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setMaxMergeWriteMBPerSec(&lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt; mbPerSec) {
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; RateLimiter limiter = mergeWriteRateLimiter;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (mbPerSec == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (limiter != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        limiter.setMaxRate(&lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.MAX_VALUE);
        mergeWriteRateLimiter = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
      }
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (limiter != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
      limiter.setMaxRate(mbPerSec);
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
      mergeWriteRateLimiter = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RateLimiter(mbPerSec);
    }
  }

  /** See {@link #setMaxMergeWriteMBPerSec}.
   *
   * @lucene.experimental */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt; getMaxMergeWriteMBPerSec() {
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; RateLimiter limiter = mergeWriteRateLimiter;
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; limiter == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; : limiter.getMaxRateMB();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think we can make this simple without any synchronization which is totally unnecessary here.&lt;/p&gt;</comment>
                    <comment id="13099242" author="mikemccand" created="Wed, 7 Sep 2011 20:24:52 +0100"  >&lt;p&gt;That change looks fine to me Simon.&lt;/p&gt;</comment>
                    <comment id="13099287" author="kimchy" created="Wed, 7 Sep 2011 21:23:55 +0100"  >&lt;p&gt;I must say that I am at a lost in trying to understand why we need this &quot;optimization&quot;, but it does not really matter to me as long as the ability to set the rate limiter instance gets in.&lt;/p&gt;</comment>
                    <comment id="13100131" author="kimchy" created="Thu, 8 Sep 2011 08:37:00 +0100"  >&lt;p&gt;A new patch, remove synchronization. It also adds another field to RateLimiter to record the original mbPerSec value set, so we can easily get it back.&lt;/p&gt;</comment>
                    <comment id="13100133" author="simonw" created="Thu, 8 Sep 2011 08:41:04 +0100"  >&lt;p&gt;that looks good to me, thanks shay!&lt;/p&gt;</comment>
                    <comment id="13101075" author="simonw" created="Fri, 9 Sep 2011 09:55:27 +0100"  >&lt;p&gt;I am planning to commit this today, any objections?&lt;/p&gt;</comment>
                    <comment id="13101542" author="simonw" created="Fri, 9 Sep 2011 21:35:49 +0100"  >&lt;p&gt;committed to trunk. Thanks Shay&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12493557" name="LUCENE-3416.patch" size="3736" author="kimchy" created="Thu, 8 Sep 2011 08:37:00 +0100" />
                    <attachment id="12493136" name="LUCENE-3416.patch" size="996" author="kimchy" created="Tue, 6 Sep 2011 11:07:26 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 6 Sep 2011 10:19:56 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2697</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24280</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>