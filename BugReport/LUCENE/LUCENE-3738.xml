<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:03:19 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3738/LUCENE-3738.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3738] Be consistent about negative vInt/vLong</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3738</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Today, write/readVInt &quot;allows&quot; a negative int, in that it will encode and decode correctly, just horribly inefficiently (5 bytes).&lt;/p&gt;

&lt;p&gt;However, read/writeVLong fails (trips an assert).&lt;/p&gt;

&lt;p&gt;I&apos;d prefer that both vInt/vLong trip an assert if you ever try to write a negative number... it&apos;s badly trappy today.  But, unfortunately, we sometimes rely on this... had we had this assert in &apos;since the beginning&apos; we could have avoided that.&lt;/p&gt;

&lt;p&gt;So, if we can&apos;t add that assert in today, I think we should at least fix readVLong to handle negative longs... but then you quietly spend 9 bytes (even more trappy!).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12540553">LUCENE-3738</key>
            <summary>Be consistent about negative vInt/vLong</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 31 Jan 2012 13:49:41 +0000</created>
                <updated>Fri, 10 May 2013 11:44:25 +0100</updated>
                    <resolved>Mon, 2 Apr 2012 23:41:18 +0100</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="13196915" author="thetaphi" created="Tue, 31 Jan 2012 13:51:51 +0000"  >&lt;p&gt;That was my fault when the &quot;Schindler VM&quot; instead the &quot;Hotspot VM&quot; unrolled the loop (Schindler loop optimizer bug). I unrolled maximum of 9 bytes not 10 (which is wasteful, too).&lt;/p&gt;

&lt;p&gt;We had no negative VLongs until now, so that was no issue &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13196916" author="thetaphi" created="Tue, 31 Jan 2012 13:55:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, if we can&apos;t add that assert in today, I think we should at least fix readVLong to handle negative longs... but then you quietly spend 9 bytes (even more trappy!).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As the code is written by a loop, we would write 10 bytes, of course the last one only with 1 bit. If we wont to spare that and optimize the long case to interpret the continuation bit in the last byte different (as part of data), the writer must also do that. Ideally we would unroll both loops.&lt;/p&gt;</comment>
                    <comment id="13196918" author="rcmuir" created="Tue, 31 Jan 2012 14:00:32 +0000"  >&lt;blockquote&gt;
&lt;p&gt;As the code is written by a loop, we would write 10 bytes, of course the last one only with 1 bit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is ok: otherwise its not a variable-length integer but something else &lt;br/&gt;
(with a special case where 9th byte high bit means sign bit instead of continuation bit).&lt;/p&gt;

&lt;p&gt;Either way we should either fix it to assert value &amp;gt;=0 in the writer, or make it work.&lt;br/&gt;
Ideally we would do that for both vint and vlong, but the problem is some things like term vectors&lt;br/&gt;
sometimes write negative vints (since it does startOffset - lastEndOffset, if you have any synonyms&lt;br/&gt;
you get tons of huge 5-byte vints in your term vectors)&lt;/p&gt;

&lt;p&gt;But currently its inconsistent: negatives don&apos;t trip any assert for either vint/vlong at write-time,&lt;br/&gt;
but at read-time for vlong &lt;b&gt;only&lt;/b&gt;.&lt;/p&gt;</comment>
                    <comment id="13196919" author="rcmuir" created="Tue, 31 Jan 2012 14:02:38 +0000"  >&lt;blockquote&gt;
&lt;p&gt;We had no negative VLongs until now, so that was no issue&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should still avoid this!&lt;/p&gt;

&lt;p&gt;I think the javadocs should still say: negatives are unsupported.&lt;br/&gt;
Maybe we can fix lucene 4&apos;s term vectors format to never write negatives, &lt;br/&gt;
and in version 5 when 3.x indexes no longer need to be read, we can assert &amp;gt;= 0 at write-time?&lt;/p&gt;</comment>
                    <comment id="13196929" author="thetaphi" created="Tue, 31 Jan 2012 14:11:43 +0000"  >&lt;p&gt;The correct fix for longs would be to add one more unrolled loop iteration (for 10th byte). Then it would work with negative numbers as vInts. But very wasterful.&lt;/p&gt;

&lt;p&gt;About negative vInts: We have them unfortunately in pre-4.0 formats with version numbers. I think e.g. stored fields reader reads the first vInt from file, if its &amp;gt;=0 its a pre-very-ancient format and is some offset/count/foo/bar (no idea). If its negative, its a version number.&lt;/p&gt;

&lt;p&gt;We should fix the unrolled vLong reader in 3.x and trunk to have one more loop so its consisten with writer (the assert stays -&amp;gt; ist an assert for the continuation bit not set on last byte).&lt;/p&gt;

&lt;p&gt;We should try to never write negative numbers for post 4.0 formats, maybe add conditional assert (like for utf8 strings), so preflex can write using negative vints and dont trip assert.&lt;/p&gt;</comment>
                    <comment id="13196941" author="rcmuir" created="Tue, 31 Jan 2012 14:20:08 +0000"  >&lt;blockquote&gt;
&lt;p&gt;We should try to never write negative numbers for post 4.0 formats, maybe add conditional assert (like for utf8 strings), so preflex can write using negative vints and dont trip assert.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We still have this problem then with negatives in 4.0 formats (like stored fields).&lt;/p&gt;

&lt;p&gt;I think we should fix them all to use codec header, and fix term vectors writer.&lt;/p&gt;

&lt;p&gt;we could have a conditionalized assert for this in mockdirectorywrapper or something like that: it could be disabled when preflex is used for now.&lt;/p&gt;</comment>
                    <comment id="13196948" author="thetaphi" created="Tue, 31 Jan 2012 14:30:51 +0000"  >&lt;p&gt;Here the patch that simply fixes the &quot;Schindler VM unroll bug&quot;.&lt;/p&gt;</comment>
                    <comment id="13196951" author="thetaphi" created="Tue, 31 Jan 2012 14:35:33 +0000"  >&lt;p&gt;Just to conclude: The bug with reading negative vLongs affects only DataInputs that dont override readVLong. So e.g. BufferedIndexInput is not affected. So when you read index from MMap or ByteArrayDataInput or InputStreamDataInput you will hit the bug.&lt;/p&gt;</comment>
                    <comment id="13196955" author="thetaphi" created="Tue, 31 Jan 2012 14:47:06 +0000"  >&lt;p&gt;The BufferedIndexInput one has also this bug, only affecting reads at the boundaries (if the 10 bytes of a full int are no longer in buffer), in that case it throws AIOOBE:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; readVLong() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (9 &amp;lt;= bufferLength-bufferPosition) {
    &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; b = buffer[bufferPosition++];
    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; i = b &amp;amp; 0x7F;
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; shift = 7; (b &amp;amp; 0x80) != 0; shift += 7) {
      b = buffer[bufferPosition++];
      i |= (b &amp;amp; 0x7FL) &amp;lt;&amp;lt; shift;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; i;
  } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.readVLong();
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13196957" author="thetaphi" created="Tue, 31 Jan 2012 14:49:42 +0000"  >&lt;p&gt;Patch fixing both to be consistent/not-buggy.&lt;/p&gt;</comment>
                    <comment id="13196968" author="mikemccand" created="Tue, 31 Jan 2012 15:15:06 +0000"  >&lt;p&gt;I think we should disallow (assert) writing negative vLong, and, ideally disallow negative vInt also, by fixing all the places that rely on this (but, carefully... preflexrw will need a backdoor)...&lt;/p&gt;

&lt;p&gt;Separately: can&apos;t we strengthen the last assert in writeVInt to verify the top 4 bits are 0, not just the top bit?  We have 36 bits at that point right?  So top 4 should be unused (assert (b &amp;amp; 0xf0) == 0)&lt;/p&gt;</comment>
                    <comment id="13196972" author="thetaphi" created="Tue, 31 Jan 2012 15:20:14 +0000"  >&lt;p&gt;If we disallow, it should be a hard check (no assert), as the data is coming from a file (and somebody could used a hex editor). The reader will crash later...&lt;/p&gt;</comment>
                    <comment id="13197383" author="rcmuir" created="Tue, 31 Jan 2012 23:35:30 +0000"  >&lt;p&gt;after investigating: its difficult to prevent negative offsets, even after fixing term vectors writer (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3739&quot; title=&quot;cleanup 4.0 term vectors format&quot;&gt;LUCENE-3739&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;At first i tried a simple assert in BaseTokenStreamTestCase:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        assertTrue(&lt;span class=&quot;code-quote&quot;&gt;&quot;offsets must not go backwards&quot;&lt;/span&gt;, offsetAtt.startOffset() &amp;gt;= lastStartOffset);
        lastStartOffset = offsetAtt.startOffset();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then these analyzers failed:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;MockCharFilter itself had a bug, but thats easy to fix (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3741&quot; title=&quot;MockCharFilter offset correction is wrong&quot;&gt;&lt;del&gt;LUCENE-3741&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;synonymsfilter failed sometimes (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3742&quot; title=&quot;SynFilter doesn&amp;#39;t set offsets for outputs that hang off the end of the input tokens&quot;&gt;&lt;del&gt;LUCENE-3742&lt;/del&gt;&lt;/a&gt;) because it wrote zeros for offsets in situations like &quot;a -&amp;gt; b c&quot;&lt;/li&gt;
	&lt;li&gt;(edge)ngramtokenizers failed, because ngrams(1,2) of &quot;ABCD&quot; are not A, AB, B, BC, C, CD, D but instead A, B, C, D, AB, BC, CD, ...&lt;/li&gt;
	&lt;li&gt;(edge)ngramfilters failed for similar reasons.&lt;/li&gt;
	&lt;li&gt;worddelimiterfilter failed, because it doesnt break &quot;AB&quot; into A, AB, B but instead A, B, AB&lt;/li&gt;
	&lt;li&gt;trimfilter failed when &apos;offsets changing&apos; is enabled, because if you have &quot; rob&quot;, &quot;robert&quot; as synonyms then it trims the first, and the second offsets &quot;go backwards&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;These are all bugs.&lt;/p&gt;

&lt;p&gt;In general I think offsets after being set should not be changed, because filters don&apos;t have access to any charfilters&lt;br/&gt;
offset correction (correctOffset()) anyway, so they shouldnt be mucking offsets.&lt;/p&gt;

&lt;p&gt;So really: only the creator of tokens should make the offsets. And if thats a filter, it should be a standard way, &lt;br/&gt;
only inherited from existing offsets and not &apos;offset mathematics&apos; and not A, AB, B in some places and A, B, AB in others.&lt;/p&gt;

&lt;p&gt;Really i think we need to step it up if we want highlighting to be first-class citizen in lucene, nothing checks the offsets anyhwere at all,&lt;br/&gt;
even to check/assert if they are negative, and there are little tests... all we have is some newish stuff in basetokenstreamtestcase and&lt;br/&gt;
a few trivial test cases.&lt;/p&gt;

&lt;p&gt;On the other hand, for example, position increment&apos;s impl actually throws exception if you give it something like a negative number...&lt;/p&gt;</comment>
                    <comment id="13231222" author="rcmuir" created="Fri, 16 Mar 2012 14:19:52 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3876&quot; title=&quot;TestIndexWriterExceptions fails (reproducible)&quot;&gt;&lt;del&gt;LUCENE-3876&lt;/del&gt;&lt;/a&gt;/&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3879&quot; title=&quot;fix more position corrumptions in 4.0 codecs&quot;&gt;&lt;del&gt;LUCENE-3879&lt;/del&gt;&lt;/a&gt; reveal more situations where we must write negatives with the current encodings,&lt;br/&gt;
because we steal bits from things like positions (payloads) and docids too (at least in skip data?)&lt;/p&gt;

&lt;p&gt;So sometimes its possible these are encoded as negatives.&lt;/p&gt;

&lt;p&gt;I think Uwe should commit his fixes?&lt;/p&gt;</comment>
                    <comment id="13231295" author="mikemccand" created="Fri, 16 Mar 2012 15:33:14 +0000"  >&lt;p&gt;Hmm... I think we should think about it more.&lt;/p&gt;

&lt;p&gt;Ie, we apparently never write a negative vLong today... and I&apos;m not sure we should start allowing it...?&lt;/p&gt;</comment>
                    <comment id="13231297" author="rcmuir" created="Fri, 16 Mar 2012 15:36:22 +0000"  >&lt;p&gt;Well that differs with the title of the issue (consistency with vInt).&lt;/p&gt;

&lt;p&gt;I don&apos;t see how we can avoid negative vints. I think its ok to be inconsistent with vLong,&lt;br/&gt;
but it should not be something we assert only at read-time. It should be asserted on write&lt;br/&gt;
so that problems are found immediately.&lt;/p&gt;</comment>
                    <comment id="13231309" author="mikemccand" created="Fri, 16 Mar 2012 15:48:22 +0000"  >&lt;blockquote&gt;
&lt;p&gt; don&apos;t see how we can avoid negative vints. I think its ok to be inconsistent with vLong,&lt;br/&gt;
 but it should not be something we assert only at read-time. It should be asserted on write&lt;br/&gt;
 so that problems are found immediately.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;I think we are stuck with negative vInts, as trappy as they are (5 bytes!!).&lt;/p&gt;

&lt;p&gt;Let&apos;s not make it worse by allowing negative vLongs.  But let&apos;s assert that at write time (and read time)...&lt;/p&gt;

&lt;p&gt;I think inconsistency here is the lesser evil.&lt;/p&gt;</comment>
                    <comment id="13231329" author="mikemccand" created="Fri, 16 Mar 2012 16:18:58 +0000"  >&lt;p&gt;Patch, just adding assert in writeVLong that i &amp;gt;=0, and also strengthening existing assert in readVInt to check that top 4 (not just top 1) bits are 0.&lt;/p&gt;</comment>
                    <comment id="13231401" author="thetaphi" created="Fri, 16 Mar 2012 17:17:42 +0000"  >&lt;p&gt;I just repeat myself:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;If we disallow, it should be a hard check (no assert), as the data is coming from a file (and somebody could used a hex editor). The reader will crash later...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Mike: If you fix the unrolled loops, please also add the checks to the other implementations in Buffered* and so on. My original patch fixed those. Please include that patch.&lt;/p&gt;</comment>
                    <comment id="13231470" author="mikemccand" created="Fri, 16 Mar 2012 18:10:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;If we disallow, it should be a hard check (no assert), as the data is coming from a file (and somebody could used a hex editor). The reader will crash later...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, I don&apos;t think we should do that.&lt;/p&gt;

&lt;p&gt;If you go and edit your index with a hex editor... there are no guarantees on what may ensue!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Mike: If you fix the unrolled loops, please also add the checks to the other implementations in Buffered* and so on. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think the unrolled loops or other impls of write/readVLong are wrong?  The javadocs state clearly that negatives are not supported.  All we&apos;re doing here is added an assert to backup that javadoc statement.&lt;/p&gt;
</comment>
                    <comment id="13231492" author="thetaphi" created="Fri, 16 Mar 2012 18:30:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;Hmm, I don&apos;t think we should do that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It costs nothing, as the standard vInt will be read only some 1 or 2 bytes, if you really read until the last byte, you have so big vInts that it might even be better not to use vInts at all.- And: The not-unrolled loops do the check always.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you go and edit your index with a hex editor... there are no guarantees on what may ensue!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Disk IO can produce wrong data. We must check this if we can and it costs nothing, which is the case here (see above).&lt;/p&gt;

&lt;p&gt;I was already talking with Robert, there are other asserts in the index readiung code at places completely outside any loops, executed only once when index is opened. Its first priority to do consistency checks of the read bytes. Otherwise you can even produce endless loops at some places. - Of course not when you have tight loops, but things like checking that the document count is in line with e.g. some other value from liveDocs is essential. I will open an issue for that, the older Lucene formats are much besster secured, but trunk is horrible, just because some people here seem to want to prevent any check, which is also a security issue when you e.g. download indexes through network connections and a man in the middle modifies the stream. &lt;/p&gt;</comment>
                    <comment id="13231506" author="rcmuir" created="Fri, 16 Mar 2012 18:42:33 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Otherwise you can even produce endless loops at some places. - Of course not when you have tight loops, but things like checking that the document count is in line with e.g. some other value from liveDocs is essential.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree there a ton of places (essentially all metadata) where we should be using real checks (not asserts).&lt;/p&gt;

&lt;p&gt;I see Mike&apos;s point though: readVLong() is very general, so someone could be using it where performance is important.&lt;br/&gt;
It just so happens its mostly only used today for metadata type things (except maybe terms dictionary stats and a few other places).&lt;/p&gt;</comment>
                    <comment id="13231543" author="thetaphi" created="Fri, 16 Mar 2012 19:18:11 +0000"  >&lt;p&gt;You misunderstood my comment:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I see Mike&apos;s point though: readVLong() is very general, so someone could be using it where performance is important.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The check is only ommitted in the unrolled loop, the for-loop still contains the check. In that case it also handles maybe too-long vints correctly, which the unrolled code will never do. The unrolled code also has a bug, that it handles negative longs wrong, but that should be prevented (in my opinion also for ints).&lt;/p&gt;

&lt;p&gt;The current assert for both long and int is completely harmless, as it will only be executed, if the vInt/vLong has the maximum number of bytes, which is very unlikely. And as said before the check is done in the loop-based code, too. And comparison in perf showed that the speed of the unrolled loop and the standard loop are identical, so about what are you talking?&lt;/p&gt;

&lt;p&gt;The good thing here is that we can (in the unrolled loops) harden the check for negative vInts, as because of the unrolled loop we have a separate cocde branch already, so we can modify the check (which was always done before my unrolling) to do the better check.&lt;/p&gt;

&lt;p&gt;I had the idea at that times to unroll that loop because of Java bugs, so the bug is caused by me and I want to fix it the correct way, definitely without loosing anything. Is this so hard to understand?&lt;/p&gt;</comment>
                    <comment id="13231962" author="mikemccand" created="Sat, 17 Mar 2012 13:27:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;The check is only ommitted in the unrolled loop, the for-loop still contains the check.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m confused... I don&apos;t see how/where BufferedIndexInput.readVLong is&lt;br/&gt;
checking for negative result now...?  Are you proposing adding an if&lt;br/&gt;
into that method?  That&apos;s what I don&apos;t want to do... eg, readVLong is&lt;br/&gt;
called 3 times per term we decode (Lucene40 codec); it&apos;s a very low&lt;br/&gt;
level API... other codecs may very well call it more often.  I don&apos;t&lt;br/&gt;
think we should add an if inside BII.readVLong.&lt;/p&gt;

&lt;p&gt;Or.... maybe you are saying you just want the unrolled code to handle&lt;br/&gt;
the negative vLong case (ie, unroll the currently missing 10th cycle),&lt;br/&gt;
and not add an if to BufferedIndexInput.readVLong?  And then &quot;for&lt;br/&gt;
free&quot; we can add a real if (not assert) if that 10th cycle is hit?&lt;br/&gt;
(ie, if we get to that 10th byte, throw an exception).  I think that&lt;br/&gt;
makes sense!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;there are other asserts in the index readiung code at places completely outside any loops, executed only once when index is opened. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 to make those real checks, as long as the cost is vanishingly&lt;br/&gt;
small.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;which is also a security issue when you e.g. download indexes through network connections and a man in the middle modifies the stream.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think it&apos;s our job to protect against / detect that.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Disk IO can produce wrong data.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, but all bets are off if that happens: you&apos;re gonna get all sorts&lt;br/&gt;
of crazy exceptions out of Lucene.  We are not a filesystem.&lt;/p&gt;</comment>
                    <comment id="13231978" author="thetaphi" created="Sat, 17 Mar 2012 14:08:53 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;The check is only ommitted in the unrolled loop, the for-loop still contains the check.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m confused... I don&apos;t see how/where BufferedIndexInput.readVLong is&lt;br/&gt;
checking for negative result now...?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I mean that the actual &quot;if (b &amp;amp; mask &amp;#33;= 0)&quot; is also in the original while loop. The original while loop then simply proceeds with reading bytes util the highest bit is null. The unrolled loop behaves different (and thats a real bug), because it will silently not read those remaining bytes, so the file pointer is on a different byte after the call. This also affects readVInt!!!&lt;/p&gt;

&lt;p&gt;In my opinion, we should unroll &lt;b&gt;all&lt;/b&gt; readVInt/readVLong loops so all behave 100% identical! And in the case of the last byte read (where the current assert is), throw exception. If we don&apos;t unroll all readVInts we have to somehow also make the loop exit after too many bytes are read, which would be an costly extra check in the loop - thats the reason why I want to unroll all loops to fail after 5 or 9 bytes.&lt;/p&gt;</comment>
                    <comment id="13232272" author="mikemccand" created="Sun, 18 Mar 2012 13:32:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;In my opinion, we should unroll all readVInt/readVLong loops so all behave 100% identical! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="13232332" author="thetaphi" created="Sun, 18 Mar 2012 19:07:53 +0000"  >&lt;p&gt;Patch that fixes all DataInput and DataOutput subclasses to:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;on writeVLong add Mike&apos;s assert for positive longs&lt;/li&gt;
	&lt;li&gt;unrolled all readVInts and readVLongs&lt;/li&gt;
	&lt;li&gt;the readV* methods are now more straightforward implemented at the end of method and do the same branching and fail at the end with an IOException (last statement)&lt;/li&gt;
	&lt;li&gt;I made all read methods in BufferedIndexInput final, as they should be never overridden (only readInternal/seekInternal). This could improve performance as hotspot knows finalness better -&amp;gt; inlining.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13232336" author="mikemccand" created="Sun, 18 Mar 2012 19:20:30 +0000"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Looks awesome Uwe!&lt;/p&gt;</comment>
                    <comment id="13232391" author="thetaphi" created="Sun, 18 Mar 2012 22:23:24 +0000"  >&lt;p&gt;I added a test, also checking ByteArrayDataInput and the exceptions.&lt;/p&gt;

&lt;p&gt;I will commit this now and then backport.&lt;/p&gt;</comment>
                    <comment id="13232392" author="thetaphi" created="Sun, 18 Mar 2012 22:27:40 +0000"  >&lt;p&gt;Committed trunk revision: 1302238&lt;/p&gt;</comment>
                    <comment id="13232396" author="thetaphi" created="Sun, 18 Mar 2012 22:42:03 +0000"  >&lt;p&gt;Committed 3.x revision: 1302242&lt;/p&gt;</comment>
                    <comment id="13239618" author="yseeley@gmail.com" created="Tue, 27 Mar 2012 17:48:17 +0100"  >&lt;p&gt;Regarding unrolling... it hasn&apos;t always proved faster in the past, esp wrt vint.&lt;/p&gt;

&lt;p&gt;My first try was in 2005: &lt;a href=&quot;http://www.lucidimagination.com/search/document/6d2efedb4dde07d#2a896a9a9adc3f2d&quot; class=&quot;external-link&quot;&gt;http://www.lucidimagination.com/search/document/6d2efedb4dde07d#2a896a9a9adc3f2d&lt;/a&gt;&lt;br/&gt;
And again in 2006: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-639&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-639&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13239621" author="thetaphi" created="Tue, 27 Mar 2012 17:51:40 +0100"  >&lt;p&gt;Yonik, the unrolling was added because of a recent Java 6 hotspot bug (who unrolled the loop itsself - but wrongly). The thing that Mike has seen was a strange thing that the already unrolled code (since 3.1) behaves different before/after a slight code change done in this issue.&lt;/p&gt;</comment>
                    <comment id="13239628" author="rcmuir" created="Tue, 27 Mar 2012 17:54:14 +0100"  >&lt;p&gt;The original unrolling here was to dodge a JVM bug, possible&lt;br/&gt;
in all java versions from ... java6u20 until java6u29 or so?&lt;/p&gt;

&lt;p&gt;I don&apos;t know if there&apos;s another solution other than unrolling&lt;br/&gt;
to work around that loop bug.&lt;/p&gt;

&lt;p&gt;I don&apos;t like the workaround but it does seem realistic at this&lt;br/&gt;
point to prevent index corruption since these versions of&lt;br/&gt;
java are really recent.&lt;/p&gt;</comment>
                    <comment id="13239662" author="thetaphi" created="Tue, 27 Mar 2012 18:21:49 +0100"  >&lt;p&gt;The problem might come from the asserts (they are not completely non-existent -&amp;gt; classloader does &lt;b&gt;not&lt;/b&gt; remove them; the JVM relies on hotspot removing them when hotspot sees &quot;dead&quot; code -&amp;gt; &quot;final static boolean $assertionsDisabled&quot; in every class). The method in this class got too complex by that. We should better remove the assert and not use it in small methods (because they prevent inlining): &lt;a href=&quot;http://goo.gl/KjrXe&quot; class=&quot;external-link&quot;&gt;http://goo.gl/KjrXe&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13239667" author="mikemccand" created="Tue, 27 Mar 2012 18:27:01 +0100"  >&lt;p&gt;+1 to remove those asserts... let&apos;s see if this fixes the slowdown the nightly builds hit on 3/18: &lt;a href=&quot;http://people.apache.org/~mikemccand/lucenebench/IntNRQ.html&quot; class=&quot;external-link&quot;&gt;http://people.apache.org/~mikemccand/lucenebench/IntNRQ.html&lt;/a&gt;&lt;/p&gt;
</comment>
                    <comment id="13239672" author="thetaphi" created="Tue, 27 Mar 2012 18:30:03 +0100"  >&lt;p&gt;Committed the assert removal in revision: trunk 1305909, 3.x 1305911&lt;/p&gt;

&lt;p&gt;If this does not help, we can revert again. But the checks are in my opinion not really useful and too risky.&lt;/p&gt;</comment>
                    <comment id="13242550" author="mikemccand" created="Fri, 30 Mar 2012 18:08:54 +0100"  >&lt;p&gt;Removing the asserts apparently didn&apos;t change the perf...&lt;/p&gt;

&lt;p&gt;I can reproduce the slowdown in a separate test (before/after this commit):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;                Task    QPS base StdDev base    QPS vInt StdDev vInt      Pct diff
              IntNRQ        7.11        0.89        6.73        0.58  -23% -   17%
             Prefix3       16.07        0.96       15.65        0.72  -12% -    8%
            Wildcard       20.14        0.91       19.67        0.77  -10% -    6%
            PKLookup      154.62        5.08      151.11        2.82   -7% -    2%
              Fuzzy1       85.24        1.53       83.87        1.18   -4% -    1%
              Fuzzy2       44.11        1.03       43.96        0.44   -3% -    3%
            SpanNear        3.23        0.11        3.22        0.07   -5% -    5%
      TermBGroup1M1P       42.35        0.49       42.43        1.43   -4% -    4%
             Respell       65.11        1.91       65.27        1.27   -4% -    5%
          AndHighMed       54.18        4.04       54.50        2.27  -10% -   13%
         TermGroup1M       31.27        0.35       31.46        0.63   -2% -    3%
        TermBGroup1M       45.01        0.33       45.37        1.42   -3% -    4%
         AndHighHigh       13.35        0.71       13.46        0.50   -7% -   10%
                Term       82.71        3.12       83.56        2.33   -5% -    7%
           OrHighMed       10.66        0.67       10.78        0.44   -8% -   12%
          OrHighHigh        7.08        0.42        7.19        0.26   -7% -   11%
        SloppyPhrase        5.11        0.24        5.20        0.31   -8% -   13%
              Phrase       11.14        0.75       11.40        0.50   -8% -   14%
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But then Uwe made a patch (I&apos;ll attach) reducing the byte code for the&lt;br/&gt;
unrolled methods:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;                Task    QPS base StdDev base    QPS vInt StdDev vInt      Pct diff
            SpanNear        3.24        0.13        3.18        0.07   -7% -    4%
              Phrase       11.34        0.68       11.13        0.38  -10% -    7%
        SloppyPhrase        5.17        0.23        5.08        0.18   -9% -    6%
      TermBGroup1M1P       41.92        0.80       41.57        0.94   -4% -    3%
         TermGroup1M       30.74        0.68       30.81        0.96   -5% -    5%
                Term       80.87        3.52       81.29        2.05   -6% -    7%
        TermBGroup1M       43.94        0.93       44.17        1.32   -4% -    5%
          AndHighMed       53.71        2.62       54.21        1.97   -7% -    9%
         AndHighHigh       13.20        0.42       13.41        0.41   -4% -    8%
             Respell       65.37        2.70       66.53        3.29   -7% -   11%
              Fuzzy1       84.29        2.11       86.44        3.36   -3% -    9%
            PKLookup      149.81        4.20      153.87        9.46   -6% -   12%
          OrHighHigh        7.19        0.28        7.40        0.48   -7% -   13%
           OrHighMed       10.82        0.43       11.16        0.73   -7% -   14%
              Fuzzy2       43.72        0.96       45.24        2.03   -3% -   10%
            Wildcard       18.96        1.00       20.05        0.39   -1% -   13%
             Prefix3       14.96        0.83       15.89        0.27   -1% -   14%
              IntNRQ        5.89        0.58        6.95        0.17    4% -   34%
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So... I think we should commit it!&lt;/p&gt;</comment>
                    <comment id="13242552" author="mikemccand" created="Fri, 30 Mar 2012 18:11:24 +0100"  >&lt;p&gt;Uwe&apos;s patch to reduce bytecode for the readVInt/Long methods...&lt;/p&gt;</comment>
                    <comment id="13242554" author="thetaphi" created="Fri, 30 Mar 2012 18:13:57 +0100"  >&lt;p&gt;I an commit that, OK?&lt;/p&gt;

&lt;p&gt;We should also do this in 3.x, Robert are you fine? Otherwise this issue is only half committed to 3.x &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Its no risk.&lt;/p&gt;</comment>
                    <comment id="13242564" author="rcmuir" created="Fri, 30 Mar 2012 18:22:08 +0100"  >&lt;p&gt;I&apos;m going with your instinct on this one. It would be bad to have a slowdown for 3.6,&lt;br/&gt;
but I want the negative vlong checks, too.&lt;/p&gt;</comment>
                    <comment id="13243113" author="thetaphi" created="Sat, 31 Mar 2012 12:13:32 +0100"  >&lt;p&gt;After looking a while on the code, I have a further minor improvement. The most common case (int &amp;lt; 128) now exits directly after reading the byte without any &amp;amp; or variable assignment operations.&lt;/p&gt;

&lt;p&gt;Mike: Can you look at it and maybe do a quick test? I would like to commit this this evening to both branches.&lt;/p&gt;</comment>
                    <comment id="13243125" author="mikemccand" created="Sat, 31 Mar 2012 13:22:27 +0100"  >&lt;p&gt;Thanks Uwe, I&apos;ll test!&lt;/p&gt;</comment>
                    <comment id="13243138" author="mikemccand" created="Sat, 31 Mar 2012 14:22:22 +0100"  >&lt;p&gt;Alas, the results are now all over the place!  And I went back to the prior patch and tried to reproduce the above results... and the results are still all over the place.  I think we are chasing Java ghosts at this point...&lt;/p&gt;</comment>
                    <comment id="13243143" author="thetaphi" created="Sat, 31 Mar 2012 14:42:20 +0100"  >&lt;p&gt;What does your comment mean? Good or bad?&lt;/p&gt;</comment>
                    <comment id="13243265" author="thetaphi" created="Sat, 31 Mar 2012 20:33:30 +0100"  >&lt;p&gt;Mike, I was away from home and did not understand your comment, now its clear: You cannot reproduce the speedup from last patch neither can you see a difference with current patch.&lt;/p&gt;

&lt;p&gt;I would suggest that I commit this now to trunk, we test a few nights and then commit it to 3.x (Robert needs to backport Ivy to 3.6, so we have some time).&lt;/p&gt;

&lt;p&gt;I will commit this later before going to sleep, so we see results tomorrow.&lt;/p&gt;</comment>
                    <comment id="13243293" author="mikemccand" created="Sat, 31 Mar 2012 22:22:29 +0100"  >&lt;p&gt;Sorry Uwe, that was exactly it: I don&apos;t know what to conclude from the perf runs anymore.&lt;/p&gt;

&lt;p&gt;But +1 for your new patch: it ought to be better since the code is simpler.&lt;/p&gt;</comment>
                    <comment id="13243295" author="thetaphi" created="Sat, 31 Mar 2012 22:34:06 +0100"  >&lt;p&gt;Committed trunk revision: 1307910&lt;/p&gt;

&lt;p&gt;I will keep this issue open for merging to 3.x the next days.&lt;/p&gt;</comment>
                    <comment id="13243704" author="rcmuir" created="Sun, 1 Apr 2012 13:04:16 +0100"  >&lt;p&gt;since there is no performance regression, let&apos;s do trunk only.&lt;/p&gt;</comment>
                    <comment id="13243729" author="thetaphi" created="Sun, 1 Apr 2012 14:58:56 +0100"  >&lt;p&gt;I added a random test for vints and vlogs in TestIndexInput. I wanted to especially test the long case, which looked broken in DataOutput (but it was correct - but only because of the way how java handles negative values when casting to long - I just made it clear what happens).&lt;/p&gt;

&lt;p&gt;Robert: The tests last night showed no change, so I have no preference.&lt;/p&gt;</comment>
                    <comment id="13244399" author="rcmuir" created="Mon, 2 Apr 2012 19:12:00 +0100"  >&lt;p&gt;Uwe, is this one good to go now? Can we mark it resolved?&lt;/p&gt;</comment>
                    <comment id="13244729" author="thetaphi" created="Mon, 2 Apr 2012 23:15:00 +0100"  >&lt;p&gt;Commit patch or not? I have no preference. Perf is sometimes slightly better (in microbenchmark on my slow-io system always).&lt;/p&gt;</comment>
                    <comment id="13244738" author="rcmuir" created="Mon, 2 Apr 2012 23:18:38 +0100"  >&lt;p&gt;If there is no real measurable performance regression, can we just commit it to trunk?&lt;/p&gt;

&lt;p&gt;I really am afraid of last minute .store optimizations.&lt;/p&gt;</comment>
                    <comment id="13244743" author="thetaphi" created="Mon, 2 Apr 2012 23:21:55 +0100"  >&lt;p&gt;Part of the optimization is already committed to 3.x since 4 days, this is just another round of optimization. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13244748" author="thetaphi" created="Mon, 2 Apr 2012 23:23:06 +0100"  >&lt;p&gt;I don&apos;t care, it&apos;s committed to trunk. The new random test I created yesterday was committed to 3.x, but not the latest code change/opto. You are the release manager, do what you prefer &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13244770" author="rcmuir" created="Mon, 2 Apr 2012 23:38:42 +0100"  >&lt;p&gt;Lets resolve the issue.&lt;/p&gt;</comment>
                    <comment id="13244774" author="thetaphi" created="Mon, 2 Apr 2012 23:41:18 +0100"  >&lt;p&gt;Latest code change not backported.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12624823">LUCENE-4641</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12520155" name="ByteArrayDataInput.java.patch" size="3676" author="thetaphi" created="Tue, 27 Mar 2012 18:21:48 +0100" />
                    <attachment id="12520780" name="LUCENE-3738-improvement.patch" size="6834" author="thetaphi" created="Sat, 31 Mar 2012 12:13:32 +0100" />
                    <attachment id="12518858" name="LUCENE-3738.patch" size="14687" author="thetaphi" created="Sun, 18 Mar 2012 22:23:24 +0000" />
                    <attachment id="12518846" name="LUCENE-3738.patch" size="11110" author="thetaphi" created="Sun, 18 Mar 2012 19:07:53 +0000" />
                    <attachment id="12518689" name="LUCENE-3738.patch" size="1036" author="mikemccand" created="Fri, 16 Mar 2012 16:18:58 +0000" />
                    <attachment id="12512573" name="LUCENE-3738.patch" size="1229" author="thetaphi" created="Tue, 31 Jan 2012 14:49:42 +0000" />
                    <attachment id="12512570" name="LUCENE-3738.patch" size="613" author="thetaphi" created="Tue, 31 Jan 2012 14:30:51 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 31 Jan 2012 13:51:51 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>225967</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23960</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>