<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:30:34 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3531/LUCENE-3531.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3531] Improve CachingWrapperFilter to optionally also cache acceptDocs, if identical to liveDocs</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3531</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Spinoff from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1536&quot; title=&quot;if a filter can support random access API, we should use it&quot;&gt;&lt;del&gt;LUCENE-1536&lt;/del&gt;&lt;/a&gt;: This issue removed the different cache modes completely and always applies the acceptDocs using BitsFilteredDocIdSet.wrap(), the cache only contains raw DocIdSet without any deletions/acceptDocs. For IndexReaders that are seldom reopened, this might not be as performant as it could be. If the acceptDocs==IR.liveDocs, those DocIdSet could also be cached with liveDocs applied.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12528658">LUCENE-3531</key>
            <summary>Improve CachingWrapperFilter to optionally also cache acceptDocs, if identical to liveDocs</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="thetaphi">Uwe Schindler</reporter>
                        <labels>
                    </labels>
                <created>Tue, 25 Oct 2011 13:17:41 +0100</created>
                <updated>Fri, 10 May 2013 11:44:32 +0100</updated>
                    <resolved>Wed, 14 Dec 2011 23:37:55 +0000</resolved>
                            <version>4.0-ALPHA</version>
                                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13167094" author="mikemccand" created="Sun, 11 Dec 2011 13:59:24 +0000"  >&lt;p&gt;Patch, adding optional boolean &quot;recacheDeletes&quot;, defaulting to false.  We only cache if the incoming acceptDocs == reader&apos;s liveDocs.&lt;/p&gt;</comment>
                    <comment id="13167107" author="thetaphi" created="Sun, 11 Dec 2011 14:53:39 +0000"  >&lt;p&gt;Looks fine!&lt;/p&gt;</comment>
                    <comment id="13168632" author="mikemccand" created="Tue, 13 Dec 2011 19:23:21 +0000"  >&lt;p&gt;Uwe found a sneaky problem here: using acceptDocs as the cache key is bad, eg FixedBitSet&apos;s equals/hashCode are horribly costly... we need a WeakIdentityHashMap.&lt;/p&gt;</comment>
                    <comment id="13168647" author="thetaphi" created="Tue, 13 Dec 2011 19:42:08 +0000"  >&lt;p&gt;I will take care and also use the map then for MMapDirectory.MMapIndexInput where I explicitely overrided the equals/hashcode of the keys to be 100% identity.&lt;/p&gt;</comment>
                    <comment id="13168812" author="thetaphi" created="Tue, 13 Dec 2011 22:54:19 +0000"  >&lt;p&gt;I did some investigation. If you want a complete WeakIdentityHashMap witha all iterators and so on its heavy to do and you must in all cases also wrap all keys with a WeakReference even for lookup (unless you implement your completely own HashMap impl). The easy fix here is to use a wrapper &quot;Reference&quot; object as cache key, that simply has a final field and equals/hashCode that does the system hashcode. By comparing the wrapper object as key, two wrapper objects are only equal, if the wrapped objects are identical:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; class IdentityKeyWrapper&amp;lt;T&amp;gt; {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; T key;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode;

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; IdentityKeyWrapper(T key) {
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.key = key;
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.hashCode = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.identityHashCode(key);
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hashCode; }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {
   &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
   &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (o &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; IdentityKeyWrapper) {
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; ((IdentityKeyWrapper&amp;lt;T&amp;gt;)o).key == &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.key;
   }
   &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
  }

}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The backside is that you have to wrap the Bits interface even on a lookup, but thats cheap just like boxing/unboxing (eden space).&lt;/p&gt;</comment>
                    <comment id="13168840" author="thetaphi" created="Tue, 13 Dec 2011 23:15:36 +0000"  >&lt;p&gt;Here the fix. Mike, I think this is fine?&lt;/p&gt;

&lt;p&gt;The fix also removes the useless genericfication of FilterCache, as we removed the SpanCachingWrapperFilter.&lt;/p&gt;</comment>
                    <comment id="13169215" author="thetaphi" created="Wed, 14 Dec 2011 09:03:43 +0000"  >&lt;p&gt;Here an improved patch factoring out the wrapper object to o.a.l.util, adding tests.&lt;/p&gt;

&lt;p&gt;Once this is committed, I will review other code and maybe move to this wrapper class (e.g. MMapIndexInput&apos;s cloned inputs)&lt;/p&gt;</comment>
                    <comment id="13169232" author="thetaphi" created="Wed, 14 Dec 2011 09:34:04 +0000"  >&lt;p&gt;There is one problem with this wrapper object and WeakHashMap. The wrapped object does not have a reference to the wrapper itsself, so the wrapper may get garbage collected (as nothing refers to it) and the item may get removed from the map.&lt;/p&gt;

&lt;p&gt;So this does not work! ...digging!&lt;/p&gt;</comment>
                    <comment id="13169236" author="thetaphi" created="Wed, 14 Dec 2011 09:38:48 +0000"  >&lt;p&gt;This is why most custom implementations of WeakIdentityHashMaps found on the net internally extend WeakReference to add equals/hashCode to it. It must be one object, otherwise GC may purge objects.&lt;/p&gt;

&lt;p&gt;There is no way around implementing an own WeakIdentityHashMap (not fully implementing the Map interface, as not needed for caches).&lt;/p&gt;</comment>
                    <comment id="13169315" author="thetaphi" created="Wed, 14 Dec 2011 13:15:45 +0000"  >&lt;p&gt;New patch, now with WeakIdentityHashMap impl from Apache CXF (excluding its inefficient Collection views and supporting null keys).&lt;/p&gt;

&lt;p&gt;I also changed the CachingWrapperFilter to hold soft references to the DocIdSet, as otherwise e.g. the Bits==null key will never be purged (as the null key cannot be reclaimed by GC).&lt;/p&gt;

&lt;p&gt;We should maybe also change FieldCache to hold soft references to its arrays, as this makes it more easy to purge them for the GC in low-memory conditions, even if the reader key is still alive (means field cache can be purged although reader is still alive).&lt;/p&gt;</comment>
                    <comment id="13169407" author="thetaphi" created="Wed, 14 Dec 2011 14:44:52 +0000"  >&lt;p&gt;Updated patch, now also supporting purging CachingWrapperFilter&apos;s cache when the reader(-core) is closed.&lt;/p&gt;

&lt;p&gt;This fix should also be backported to 3.x.&lt;/p&gt;</comment>
                    <comment id="13169411" author="thetaphi" created="Wed, 14 Dec 2011 14:51:25 +0000"  >&lt;p&gt;More cleanup and made more fields private/final.&lt;/p&gt;

&lt;p&gt;I will commit this now.&lt;/p&gt;</comment>
                    <comment id="13169413" author="thetaphi" created="Wed, 14 Dec 2011 14:53:17 +0000"  >&lt;p&gt;Committed trunk revision: 1214274&lt;/p&gt;</comment>
                    <comment id="13169424" author="thetaphi" created="Wed, 14 Dec 2011 15:14:30 +0000"  >&lt;p&gt;Backported adding close listeners to 3.x.&lt;/p&gt;</comment>
                    <comment id="13169493" author="mikemccand" created="Wed, 14 Dec 2011 16:38:29 +0000"  >&lt;p&gt;Phew thanks Uwe!  What a doozie that turned out to be &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13169506" author="thetaphi" created="Wed, 14 Dec 2011 17:12:13 +0000"  >&lt;p&gt;After some investigation, we should remove the purgeing on IndexReader/Core close again, as this holds strong references from the IndexReader to the CachingWrapperFilter. This would lead to problems in the following case: A app has an IndexReader that never changes and is never closed, but creates lots of CachingWrapperFilters for short-time caches. This will fill up the event listener queue.&lt;/p&gt;</comment>
                    <comment id="13169511" author="thetaphi" created="Wed, 14 Dec 2011 17:17:16 +0000"  >&lt;p&gt;Reverted backport of listeners in 3.x revision: 1214347&lt;br/&gt;
Reverted listeners in trunk revision: 1214349&lt;/p&gt;

&lt;p&gt;If I have a better idea, I will open an issue.&lt;/p&gt;</comment>
                    <comment id="13169729" author="thetaphi" created="Wed, 14 Dec 2011 21:46:42 +0000"  >&lt;p&gt;Mike and I discussed on IRC about easier ways to solve the caching problem. We came  to the conclusion, that using the acceptDocs (may be null) as a sub-key are suboptimal, because the null key cannot be evicted from the WeakIdentityHashMap. Also the two caches inside each other are hard to manage.&lt;/p&gt;

&lt;p&gt;The idea was to have a &quot;combined&quot; key on segmentreader, thats hard referenced by the instance, changing only when deletions change. This key should also only have identity equals/hashCode.&lt;/p&gt;

&lt;p&gt;IndexReader like in 3.x now supplies two keys, one based on the core without deletions, and a second one thats equal for all segmentreaders with same deletions and same core. The trick is to use a Object field in SegmentReader thats initialized with new Object() at the beginning and transferred over to a new instance when cloned. But once deletions change, we reassign a new &quot;new Object()&quot;, so the key changes.&lt;/p&gt;

&lt;p&gt;CachingWrapperFilter uses either the conventional coreCacheKey (if if does not respect deletions at all and caches without acceptDocs), or it uses the combined key (IndexReader.getCombinedCoreAndDeletesKey()) for the cache.&lt;/p&gt;

&lt;p&gt;The WeakIdentityHashMap is therefore obsolete again, I will nuke it.&lt;/p&gt;</comment>
                    <comment id="13169730" author="thetaphi" created="Wed, 14 Dec 2011 21:48:46 +0000"  >&lt;p&gt;Patch.&lt;/p&gt;</comment>
                    <comment id="13169747" author="rcmuir" created="Wed, 14 Dec 2011 22:09:04 +0000"  >&lt;p&gt;can&apos;t this just be on segmentreader only?&lt;/p&gt;</comment>
                    <comment id="13169766" author="thetaphi" created="Wed, 14 Dec 2011 22:40:05 +0000"  >&lt;p&gt;Not yet, once we have split composite readers and atomic reader, yes. But at this point i cannot handle that, as SegmentReader can be replaced by SlowMultiReaderWrapper (and they have no common base class): &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2858&quot; title=&quot;Separate SegmentReaders (and other atomic readers) from composite IndexReaders&quot;&gt;&lt;del&gt;LUCENE-2858&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So I would like to commit this first and later move this with all this stuff to atomic readers only.&lt;/p&gt;</comment>
                    <comment id="13169806" author="thetaphi" created="Wed, 14 Dec 2011 23:34:47 +0000"  >&lt;p&gt;Updated patch with a test for the core key and combined key. I will commit this now and then work on splitting atomic and composite readers.&lt;/p&gt;</comment>
                    <comment id="13169812" author="thetaphi" created="Wed, 14 Dec 2011 23:37:55 +0000"  >&lt;p&gt;Committed trunk revision: 1214551&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12507365" name="LUCENE-3531-identityFix.patch" size="16296" author="thetaphi" created="Wed, 14 Dec 2011 14:51:24 +0000" />
                    <attachment id="12507360" name="LUCENE-3531-identityFix.patch" size="16337" author="thetaphi" created="Wed, 14 Dec 2011 14:44:52 +0000" />
                    <attachment id="12507348" name="LUCENE-3531-identityFix.patch" size="14399" author="thetaphi" created="Wed, 14 Dec 2011 13:15:44 +0000" />
                    <attachment id="12507324" name="LUCENE-3531-identityFix.patch" size="10028" author="thetaphi" created="Wed, 14 Dec 2011 09:03:43 +0000" />
                    <attachment id="12507264" name="LUCENE-3531-identityFix.patch" size="2947" author="thetaphi" created="Tue, 13 Dec 2011 23:15:36 +0000" />
                    <attachment id="12506896" name="LUCENE-3531.patch" size="13001" author="mikemccand" created="Sun, 11 Dec 2011 13:59:24 +0000" />
                    <attachment id="12507457" name="LUCENE-3531-v2.patch" size="20733" author="thetaphi" created="Wed, 14 Dec 2011 23:34:47 +0000" />
                    <attachment id="12507440" name="LUCENE-3531-v2.patch" size="18347" author="thetaphi" created="Wed, 14 Dec 2011 21:48:45 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 11 Dec 2011 13:59:24 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>214519</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24166</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>