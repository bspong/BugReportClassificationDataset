<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:59:18 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3068/LUCENE-3068.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3068] The repeats mechanism in SloppyPhraseScorer is broken when doc has tokens at same position</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3068</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;In &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-736&quot; title=&quot;Sloppy Phrase Scorer matches the doc &amp;quot;A B C D E&amp;quot; for query = &amp;quot;B C B&amp;quot;~2&quot;&gt;&lt;del&gt;LUCENE-736&lt;/del&gt;&lt;/a&gt; we made fixes to SloppyPhraseScorer, because it was&lt;br/&gt;
matching docs that it shouldn&apos;t; but I think those changes caused it&lt;br/&gt;
to fail to match docs that it should, specifically when the doc itself&lt;br/&gt;
has tokens at the same position.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12506155">LUCENE-3068</key>
            <summary>The repeats mechanism in SloppyPhraseScorer is broken when doc has tokens at same position</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="doronc">Doron Cohen</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Wed, 4 May 2011 11:01:13 +0100</created>
                <updated>Fri, 3 Jun 2011 17:37:10 +0100</updated>
                    <resolved>Wed, 18 May 2011 16:37:23 +0100</resolved>
                            <version>3.0.3</version>
                <version>3.1</version>
                <version>4.0-ALPHA</version>
                                <fixVersion>3.2</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13028696" author="mikemccand" created="Wed, 4 May 2011 11:04:36 +0100"  >&lt;p&gt;Patch w/ test case showing the problem.&lt;/p&gt;

&lt;p&gt;If you set slop to 0 for the PhraseQuery, the test passes.  The MultiPhraseQuery passes with slop or no slop because it handles the same-position case itself (Union*Enum).&lt;/p&gt;

&lt;p&gt;That got me thinking... maybe any time a *PhraseQuery has overlapping positions, we should rewrite to a MultiPhraseQuery and let it handle the same positions...?  Is there any downside to that?&lt;/p&gt;</comment>
                    <comment id="13028895" author="doronc" created="Wed, 4 May 2011 19:59:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;specifically when the doc itself has tokens at the same position.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am not convinced yet that there is a bug here - I think the code does allow this? &lt;/p&gt;

&lt;p&gt;There is another assumption in the code, that any two different PPs are in different TPs - which underlines the assumption that originally each PP differs in position, This seems a valid assumption, because QP will create MFQ if there are two terms in the (phrase) query with same position. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;maybe any time a *PhraseQuery has overlapping positions, we should rewrite to a MultiPhraseQuery and let it handle the same positions...? Is there any downside to that?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is the correct behavior - in particular this will be the query that a QP will create. The only way to create a PQ (not MPQ) for PPs in same positions is to create it manually. But why would anyone do that? And they did, wouldn&apos;t such a rewrite be a surprise to them?&lt;/p&gt;

&lt;p&gt;A patch to follow with a revised version of this test - one that uses the QP. In this patch the QP indeed creates an MFQ, and I am yet unable to make it fail. Still trying.&lt;/p&gt;</comment>
                    <comment id="13028898" author="doronc" created="Wed, 4 May 2011 20:05:58 +0100"  >&lt;p&gt;Attached modified version of the test - one that invokes the query parser to create an MFQ. The test passes.&lt;/p&gt;</comment>
                    <comment id="13029150" author="doronc" created="Thu, 5 May 2011 07:06:23 +0100"  >&lt;p&gt;This is more complex than I originally thought.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;QueryParser creates a MultiplePhraseQuery (MPQ) when one of the (phrase) query positions is a multi-term.&lt;/li&gt;
	&lt;li&gt;MPQ has an implicit OR behavior - it is used for e.g. wildcarding a phrase query.&lt;/li&gt;
	&lt;li&gt;PhraseQuery (PQ) sloppy scorer assumes each query position has a single term.&lt;/li&gt;
	&lt;li&gt;PQ with several terms in same position cannot be created by parsing it with a QP, only manual.&lt;br/&gt;
  Manually created, it would have an AND semantics: only docs with ALL the terms in pos N should match.&lt;br/&gt;
  In other words, assume doc D terms and positions are: &lt;br/&gt;
  a:0 b:1 c:1 d:2&lt;br/&gt;
  MPQ for (a,b):0 d:1 should match D, finding the phrase b:1 d:2 (OR semantics)&lt;br/&gt;
  PQ for (a,b):0 d:1 should not match D, because it does not contain &apos;a&apos; and &apos;b&apos; in the same position (AND semantics).&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;Therefore, rewriting PQ into MPQ is not a valid fix, because it would turn the AND logic assumed by creating the PQ this way, by an OR logic as assumed in MPQ. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;TestPositionIncrement.testSetPosition has a test for this case exactly&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// phrase query should fail &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; non existing searched term 
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// even &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there exist another searched terms in the same searched position. 
&lt;/span&gt;    q = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; PhraseQuery();
    q.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;code-quote&quot;&gt;&quot;field&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;3&quot;&lt;/span&gt;),0);
    q.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;code-quote&quot;&gt;&quot;field&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;9&quot;&lt;/span&gt;),0);
    hits = searcher.search(q, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, 1000).scoreDocs;
    assertEquals(0, hits.length);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Although QP by default will not create this PQ, I think we need to support it, for applications needing to be strict with the search results, with slop. &lt;/p&gt;

&lt;p&gt;So fixing this would need to take place inside SloppyScorer, digging further...&lt;/p&gt;</comment>
                    <comment id="13029223" author="doronc" created="Thu, 5 May 2011 08:57:57 +0100"  >&lt;p&gt;Attached patch fixes this bug by excluding fro the repeats check those PPs originated fro same offset in the query. &lt;/p&gt;

&lt;p&gt;This allows more strict phrase queries: strict on terms in same position (AND logic) but still sloppy.&lt;/p&gt;

&lt;p&gt;All tests pass, this is ready to go in (unless there are reservations).&lt;/p&gt;</comment>
                    <comment id="13029229" author="shaie" created="Thu, 5 May 2011 09:22:23 +0100"  >&lt;p&gt;Patch looks good to me.&lt;/p&gt;

&lt;p&gt;One comment about the test - perhaps use the LTC methods that do random tests, like newDirectory(), newIndexWriterConfig() etc.? If you don&apos;t think it&apos;s appropriate for this test, that&apos;s ok with me.&lt;/p&gt;</comment>
                    <comment id="13029274" author="doronc" created="Thu, 5 May 2011 11:42:40 +0100"  >&lt;p&gt;Thanks for reviewing Shai!&lt;br/&gt;
I&apos;ll updated the patch with random newDirectory and newICFG - not the focus here, but may improve coverage anyhow,&lt;br/&gt;
I added tests for the combined case - some AND some OR - that is, using MPQ, some add() with a single term (AND), some with an array longer than 1 (OR). Also refactored the tests a bit so that now there&apos;s a small test method for each test case.&lt;/p&gt;</comment>
                    <comment id="13029277" author="doronc" created="Thu, 5 May 2011 11:53:56 +0100"  >&lt;p&gt;Patch with more test cases - AND/OR logic for MPQ is combined, and test code made simpler.&lt;/p&gt;</comment>
                    <comment id="13035422" author="doronc" created="Wed, 18 May 2011 16:00:08 +0100"  >&lt;p&gt;fixed in trunk in r1124293.&lt;/p&gt;</comment>
                    <comment id="13035444" author="doronc" created="Wed, 18 May 2011 16:37:23 +0100"  >&lt;p&gt;fix merged to 3x in r1124302.&lt;/p&gt;</comment>
                    <comment id="13035643" author="doronc" created="Wed, 18 May 2011 21:21:03 +0100"  >&lt;p&gt;I wonder if this should be fixed also in 3.1 branch?&lt;br/&gt;
Probably so only if we make a 3.1.1, but not needed if its gonna be a 3.2. &lt;br/&gt;
What&apos;s the best practice then? Reopen until decision?&lt;br/&gt;
Or rely on rescanning all 3.2 changes in case its gonna be 3.1.1?&lt;/p&gt;</comment>
                    <comment id="13036107" author="doronc" created="Thu, 19 May 2011 11:36:56 +0100"  >&lt;p&gt;Looking at &lt;a href=&quot;http://people.apache.org/~mikemccand/lucenebench/SloppyPhrase.html&quot; class=&quot;external-link&quot;&gt;http://people.apache.org/~mikemccand/lucenebench/SloppyPhrase.html&lt;/a&gt; (Mike this is a great tool!) I see no particular slowdown at the last runs.&lt;/p&gt;

&lt;p&gt;A thought about these benchmarks, it would be helpful if the checked revision would be shown - perhaps as part of the hover text when hovering the mouse on a graph point...&lt;/p&gt;</comment>
                    <comment id="13036109" author="mikemccand" created="Thu, 19 May 2011 11:50:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;A thought about these benchmarks, it would be helpful if the checked revision would be shown - perhaps as part of the hover text when hovering the mouse on a graph point..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good idea!  I&apos;ll try to do this...&lt;/p&gt;

&lt;p&gt;Note that if you go back to the root page, and click on a given day, it tells you the svn rev and also hg ref (of luceneutil), so that&apos;s a &lt;span class=&quot;error&quot;&gt;&amp;#91;cumbersome&amp;#93;&lt;/span&gt; way to get the svn rev.&lt;/p&gt;</comment>
                    <comment id="13036111" author="doronc" created="Thu, 19 May 2011 12:09:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;Note that if you go back to the root page, and click on a given day, it tells you the svn rev and also hg ref (of luceneutil)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Great, thanks!&lt;/p&gt;

&lt;p&gt;So, this commit to trunk in r1124293 falls between these two:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Tue 17/05/2011 Lucene/Solr trunk rev 1104671&lt;/li&gt;
	&lt;li&gt;Wed 18/05/2011 Lucene/Solr trunk rev 1124524&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;... No measurable degradation, good!&lt;/p&gt;</comment>
                    <comment id="13036140" author="simonw" created="Thu, 19 May 2011 13:11:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;Looking at &lt;a href=&quot;http://people.apache.org/~mikemccand/lucenebench/SloppyPhrase.html&quot; class=&quot;external-link&quot;&gt;http://people.apache.org/~mikemccand/lucenebench/SloppyPhrase.html&lt;/a&gt; (Mike this is a great tool!) I see no particular slowdown at the last runs.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I love it! good that all the work on LuceneUtil pays off!!!!!&lt;/p&gt;</comment>
                    <comment id="13043463" author="rcmuir" created="Fri, 3 Jun 2011 17:37:10 +0100"  >&lt;p&gt;Bulk closing for 3.2&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12478266" name="LUCENE-3068.patch" size="10956" author="doronc" created="Thu, 5 May 2011 11:53:56 +0100" />
                    <attachment id="12478256" name="LUCENE-3068.patch" size="8754" author="doronc" created="Thu, 5 May 2011 08:57:57 +0100" />
                    <attachment id="12478198" name="LUCENE-3068.patch" size="3111" author="doronc" created="Wed, 4 May 2011 20:05:58 +0100" />
                    <attachment id="12478146" name="LUCENE-3068.patch" size="2176" author="mikemccand" created="Wed, 4 May 2011 11:04:36 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 4 May 2011 18:59:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2150</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24625</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>