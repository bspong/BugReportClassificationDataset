<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:27:48 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-467/LUCENE-467.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-467] Use Float.floatToRawIntBits over Float.floatToIntBits</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-467</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Copied From my Email:&lt;br/&gt;
  Float.floatToRawIntBits (in Java1.4) gives the raw float bits without&lt;br/&gt;
normalization (like &lt;b&gt;(int&lt;/b&gt;)&amp;amp;floatvar would in C).  Since it doesn&apos;t do&lt;br/&gt;
normalization of NaN values, it&apos;s faster (and hopefully optimized to a&lt;br/&gt;
simple inline machine instruction by the JVM).&lt;/p&gt;

&lt;p&gt;On my Pentium4, using floatToRawIntBits is over 5 times as fast as&lt;br/&gt;
floatToIntBits.&lt;br/&gt;
That can really add up in something like Similarity.floatToByte() for&lt;br/&gt;
encoding norms, especially if used as a way to compress an array of&lt;br/&gt;
float during query time as suggested by Doug.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12325731">LUCENE-467</key>
            <summary>Use Float.floatToRawIntBits over Float.floatToIntBits</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Thu, 17 Nov 2005 07:16:05 +0000</created>
                <updated>Sat, 27 May 2006 02:39:15 +0100</updated>
                    <resolved>Sun, 27 Nov 2005 03:25:00 +0000</resolved>
                            <version>1.9</version>
                                                <component>core/other</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12357827" author="yseeley@gmail.com" created="Thu, 17 Nov 2005 07:21:25 +0000"  >&lt;p&gt;Paul Smith&apos;s profiling shows that that encodeNorm() taking 20% of the total indexing time, with floatToIntBits registering all of that 20%!  almost hard to believe...&lt;/p&gt;

&lt;p&gt;There should be some good gains with this change.&lt;br/&gt;
It would be nice to change the usage in Query.hashCode too.&lt;/p&gt;</comment>
                    <comment id="12357838" author="yseeley@gmail.com" created="Thu, 17 Nov 2005 13:26:54 +0000"  >&lt;p&gt;With -server mode, it&apos;s only 3 times as fast, and both are really fairly fast.&lt;br/&gt;
I do wonder if the profiler had it&apos;s numbers right, or if the act of observation messed things up... 20% seems too high.&lt;/p&gt;</comment>
                    <comment id="12357839" author="psmith@apache.org" created="Thu, 17 Nov 2005 13:38:21 +0000"  >&lt;p&gt;I probably didn&apos;t make my testing framework as clear as I should.  Yourkit was setup to use method sampling (waking up every X milliseconds).  I wouldn&apos;t use the 20% as a &apos;accurate&apos; figure but suffice to say that improving this method would &apos;certainly&apos; improve things.  Only testing the way you have will flush out the correct numbers.&lt;/p&gt;

&lt;p&gt;We don&apos;t use -server (due to some Linux vagaries we&apos;ve been careful with -server because of some stability problems)&lt;/p&gt;</comment>
                    <comment id="12357851" author="yseeley@gmail.com" created="Thu, 17 Nov 2005 15:12:00 +0000"  >&lt;p&gt;Fun with premature optimization!&lt;br/&gt;
I know this isn&apos;t a bottleneck, but here is the fastest floatToByte() that I could come up with:&lt;/p&gt;

&lt;p&gt;  public static byte floatToByte(float f) &lt;/p&gt;
{
    int bits = Float.floatToRawIntBits(f);
    if (bits&amp;lt;=0) return 0;
    int mantissa = (bits &amp;amp; 0xffffff) &amp;gt;&amp;gt; 21;
    int exponent = (bits &amp;gt;&amp;gt;&amp;gt; 24) - 63 + 15;
    if ((exponent &amp;amp; ~0x1f)==0) return (byte)((exponent &amp;lt;&amp;lt; 3) | mantissa);
    else if (exponent&amp;lt;0) return 1;
    return -1;
  }

&lt;p&gt;Here is the original from Lucene for reference:&lt;/p&gt;

&lt;p&gt;  public static byte floatToByte(float f) {&lt;br/&gt;
    if (f &amp;lt; 0.0f)                                 // round negatives up to zero&lt;br/&gt;
      f = 0.0f;&lt;/p&gt;

&lt;p&gt;    if (f == 0.0f)                                // zero is a special case&lt;br/&gt;
      return 0;&lt;/p&gt;

&lt;p&gt;    int bits = Float.floatToIntBits(f);           // parse float into parts&lt;br/&gt;
    int mantissa = (bits &amp;amp; 0xffffff) &amp;gt;&amp;gt; 21;&lt;br/&gt;
    int exponent = (((bits &amp;gt;&amp;gt; 24) &amp;amp; 0x7f) - 63) + 15;&lt;br/&gt;
    if (exponent &amp;gt; 31) &lt;/p&gt;
{                          // overflow: use max value
      exponent = 31;
      mantissa = 7;
    }

&lt;p&gt;    if (exponent &amp;lt; 0) &lt;/p&gt;
{                           // underflow: use min value
      exponent = 0;
      mantissa = 1;
    }

&lt;p&gt;    return (byte)((exponent &amp;lt;&amp;lt; 3) | mantissa);    // pack into a byte&lt;br/&gt;
   }&lt;/p&gt;


&lt;p&gt;Here is the performance (in seconds) on my P4 to do 640M conversions:&lt;/p&gt;

&lt;p&gt;              JDK14-server  JDK14-client  JDK15-server  JDK15-client  JDK16-server  JDK16-client&lt;br/&gt;
orig       75.422               89.451            8.344                 57.631            7.656                 57.984&lt;br/&gt;
new      67.265               78.891            5.906                 22.172            5.172                 18.750&lt;br/&gt;
diff        12%                    13%                41%                   160%              48%                   209%&lt;/p&gt;

&lt;p&gt;Some decent gains... but the biggest moral of the story is: use Java&amp;gt;=1.5 and -server if you can!&lt;/p&gt;
</comment>
                    <comment id="12357911" author="yseeley@gmail.com" created="Fri, 18 Nov 2005 02:27:45 +0000"  >&lt;p&gt;Here is a new version that&apos;s faster by keeping the mantissa and exponent&lt;br/&gt;
together.  It&apos;s fast-path does a single shift and a single add after&lt;br/&gt;
getting the float bits.&lt;/p&gt;

&lt;p&gt;  public  byte floatToByte(float f) {&lt;br/&gt;
    int bits = Float.floatToRawIntBits(f);&lt;br/&gt;
    int smallfloat = bits &amp;gt;&amp;gt; 21;  // only keep 3 highest bits in mantissa&lt;br/&gt;
    if (smallfloat &amp;lt; (63-15)&amp;lt;&amp;lt;3) &lt;/p&gt;
{
      return (bits&amp;lt;=0) ? (byte)0 : (byte)1;  // 0 or underflow
    }
&lt;p&gt;    if (smallfloat &amp;gt;= ((63-15)+32)&amp;lt;&amp;lt;3) &lt;/p&gt;
{
      return -1; // overflow
    }
&lt;p&gt;    return (byte)(smallfloat - ((63-15)&amp;lt;&amp;lt;3));&lt;br/&gt;
  }&lt;/p&gt;


&lt;p&gt;--&lt;del&gt;JVM&lt;/del&gt;-- &lt;del&gt;CUR&lt;/del&gt;- &lt;del&gt;NEW&lt;/del&gt;- &lt;del&gt;DIFF&lt;/del&gt;&lt;br/&gt;
14-server 75.422 66.515 13%&lt;br/&gt;
14-client 89.451 79.734 12%&lt;br/&gt;
15-server 8.344  3.859 116%&lt;br/&gt;
15-client 57.631 17.031 238%&lt;br/&gt;
16-server 7.656  3.172 141%&lt;br/&gt;
16-client 57.984 16.531 251%&lt;/p&gt;

&lt;p&gt;These numbers include the overhead of a float loop and the method&lt;br/&gt;
call overhead.&lt;/p&gt;</comment>
                    <comment id="12357917" author="cutting" created="Fri, 18 Nov 2005 03:22:56 +0000"  >&lt;p&gt;How fast can you make:&lt;/p&gt;

&lt;p&gt;public byte floatToByte(float f, int numMantissaBits);&lt;/p&gt;

&lt;p&gt;?&lt;/p&gt;

&lt;p&gt;That would be more reusable, and shouldn&apos;t be much slower...&lt;/p&gt;</comment>
                    <comment id="12357920" author="yseeley@gmail.com" created="Fri, 18 Nov 2005 04:44:31 +0000"  >&lt;p&gt;&amp;gt; How fast can you make: public byte floatToByte(float f, int numMantissaBits);&lt;/p&gt;

&lt;p&gt;With Java5 and -server -Xbatch, just  as fast as the specialized version!  That server JVM is amazing!&lt;br/&gt;
With Java5 -client,  it&apos;s 60% slower though...&lt;br/&gt;
Still this code might be good to keep around for double checking implementations.&lt;/p&gt;

&lt;p&gt;   public static byte floatToByte(float f, int numMantissaBits) {&lt;br/&gt;
     int rshift = 24-numMantissaBits;   // 21 in old func&lt;br/&gt;
     int maxexp = 0xff &amp;gt;&amp;gt; numMantissaBits; // 31 in old func&lt;br/&gt;
     int zeroexp = 0xff &amp;gt;&amp;gt; (numMantissaBits+1); // 15 in old func&lt;br/&gt;
     // int overflowexp = 0x100 &amp;gt;&amp;gt; numMantissaBits; // 32 in old func&lt;br/&gt;
     int overflowexp = maxexp+1;&lt;br/&gt;
     int bits = Float.floatToRawIntBits(f);&lt;br/&gt;
     int smallfloat = bits &amp;gt;&amp;gt; rshift;&lt;br/&gt;
     if (smallfloat &amp;lt; (63-zeroexp)&amp;lt;&amp;lt;numMantissaBits) &lt;/p&gt;
{
       return (bits&amp;lt;=0) ? (byte)0 : (byte)1;  // 0 or underflow
     }
&lt;p&gt; else if (smallfloat &amp;gt;= (63-zeroexp+overflowexp)&amp;lt;&amp;lt;numMantissaBits) &lt;/p&gt;
{
       return -1;
     }
&lt;p&gt; else &lt;/p&gt;
{
       return (byte)(smallfloat - ((63-zeroexp)&amp;lt;&amp;lt;numMantissaBits));
     }
&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;   public byte floatToByte(float f) &lt;/p&gt;
{
    return floatToByte(f,3);
   }</comment>
                    <comment id="12357925" author="psmith@apache.org" created="Fri, 18 Nov 2005 05:38:45 +0000"  >&lt;p&gt;If you can create a patch against 1.4.3 there is a reasonable possibility that I could create a 1.4.3 Lucene+ThisPatch jar and re-index in our test environment that was the source of the YourKit graph I provided earlier.  This should reflect how useful the change might be against a decent baseline?&lt;/p&gt;</comment>
                    <comment id="12357926" author="yseeley@gmail.com" created="Fri, 18 Nov 2005 05:43:54 +0000"  >&lt;p&gt;Here&apos;s a version that further generalizes the exponent zero point (below are negative exponents, above are positive), and includes the reverse byteToFloat as well.&lt;/p&gt;

&lt;p&gt;  public static float byteToFloat(byte b, int numMantissaBits, int zeroExp) &lt;/p&gt;
{
    if (b == 0) return 0.0f;
    int bits = (b&amp;amp;0xff) &amp;lt;&amp;lt; (24-numMantissaBits);
    bits += (63-zeroExp) &amp;lt;&amp;lt; 24;
    return Float.intBitsToFloat(bits);
  }

&lt;p&gt;  public float byteToFloat(byte b) &lt;/p&gt;
{
    return byteToFloat(b, 3, 15);
  }

&lt;p&gt;  public static byte floatToByte(float f, int numMantissaBits, int zeroExp) {&lt;br/&gt;
    int shift = 24-numMantissaBits;   // 21 in old func&lt;br/&gt;
    int maxexp = 0xff &amp;gt;&amp;gt; numMantissaBits; // 31 in old func&lt;br/&gt;
    // int zeroExp = 0xff &amp;gt;&amp;gt; (numMantissaBits+1); // 15 in old func&lt;br/&gt;
    // int overflowexp = 0x100 &amp;gt;&amp;gt; numMantissaBits; // 32 in old func&lt;br/&gt;
    int overflowexp = maxexp+1;&lt;br/&gt;
    int bits = Float.floatToRawIntBits(f);&lt;br/&gt;
    int smallfloat = bits &amp;gt;&amp;gt; shift;&lt;br/&gt;
    if (smallfloat &amp;lt; (63-zeroExp)&amp;lt;&amp;lt;numMantissaBits) &lt;/p&gt;
{
      return (bits&amp;lt;=0) ? (byte)0 : (byte)1;  // 0 or underflow
    }
&lt;p&gt; else if (smallfloat &amp;gt;= (63-zeroExp +overflowexp)&amp;lt;&amp;lt;numMantissaBits) &lt;/p&gt;
{
      return -1;
    }
&lt;p&gt; else &lt;/p&gt;
{
      return (byte)(smallfloat - ((63-zeroExp)&amp;lt;&amp;lt;numMantissaBits));
    }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;  public byte floatToByte(float f) &lt;/p&gt;
{
    return floatToByte(f,3,15);
  }</comment>
                    <comment id="12358071" author="yseeley@gmail.com" created="Sun, 20 Nov 2005 05:50:47 +0000"  >&lt;p&gt;Committed current implementation as SmallFloat&lt;br/&gt;
&lt;a href=&quot;http://svn.apache.org/viewcvs.cgi/lucene/java/trunk/src/java/org/apache/lucene/util/SmallFloat.java&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org/viewcvs.cgi/lucene/java/trunk/src/java/org/apache/lucene/util/SmallFloat.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Unless I hear objections, I&apos;ll convert the norm encoding/decoding in Similarity to use it.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 17 Nov 2005 13:38:21 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13282</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27264</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>