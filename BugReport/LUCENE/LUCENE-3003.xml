<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:35:14 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3003/LUCENE-3003.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3003] Move UnInvertedField into Lucene core</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3003</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Solr&apos;s UnInvertedField lets you quickly lookup all terms ords for a&lt;br/&gt;
given doc/field.&lt;/p&gt;

&lt;p&gt;Like, FieldCache, it inverts the index to produce this, and creates a&lt;br/&gt;
RAM-resident data structure holding the bits; but, unlike FieldCache,&lt;br/&gt;
it can handle multiple values per doc, and, it does not hold the term&lt;br/&gt;
bytes in RAM.  Rather, it holds only term ords, and then uses&lt;br/&gt;
TermsEnum to resolve ord -&amp;gt; term.&lt;/p&gt;

&lt;p&gt;This is great eg for faceting, where you want to use int ords for all&lt;br/&gt;
of your counting, and then only at the end you need to resolve the&lt;br/&gt;
&quot;top N&quot; ords to their text.&lt;/p&gt;

&lt;p&gt;I think this is a useful core functionality, and we should move most&lt;br/&gt;
of it into Lucene&apos;s core.  It&apos;s a good complement to FieldCache.  For&lt;br/&gt;
this first baby step, I just move it into core and refactor Solr&apos;s&lt;br/&gt;
usage of it.&lt;/p&gt;

&lt;p&gt;After this, as separate issues, I think there are some things we could&lt;br/&gt;
explore/improve:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The first-pass that allocates lots of tiny byte[] looks like it&lt;br/&gt;
    could be inefficient.  Maybe we could use the byte slices from the&lt;br/&gt;
    indexer for this...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We can improve the RAM efficiency of the TermIndex: if the codec&lt;br/&gt;
    supports ords, and we are operating on one segment, we should just&lt;br/&gt;
    use it.  If not, we can use a more RAM-efficient data structure,&lt;br/&gt;
    eg an FST mapping to the ord.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We may be able to improve on the main byte[] representation by&lt;br/&gt;
    using packed ints instead of delta-vInt?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Eventually we should fold this ability into docvalues, ie we&apos;d&lt;br/&gt;
    write the byte[] image at indexing time, and then loading would be&lt;br/&gt;
    fast, instead of uninverting&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
            <key id="12502752">LUCENE-3003</key>
            <summary>Move UnInvertedField into Lucene core</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 29 Mar 2011 20:48:46 +0100</created>
                <updated>Fri, 10 May 2013 11:42:48 +0100</updated>
                    <resolved>Tue, 6 Mar 2012 11:11:55 +0000</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>4</watches>
                                                    <comments>
                    <comment id="13012647" author="mikemccand" created="Tue, 29 Mar 2011 20:50:01 +0100"  >&lt;p&gt;Attached patch.  I moved most of UnInvertedField into Lucene, as&lt;br/&gt;
oal.index.DocTermsOrds, but left the two faceting methods (getCounts,&lt;br/&gt;
getStats) in UnInvertedField.  UnInvertedField subclasses&lt;br/&gt;
DocTermOrds.&lt;/p&gt;

&lt;p&gt;I added a simple &quot;OrdIterator&quot; API, for stepping through the ords for&lt;br/&gt;
a doc + field (but, Solr&apos;s UnInvertedField still just directly uses&lt;br/&gt;
the packed structures), and a Lucene test case that verifies this is&lt;br/&gt;
working right (though I still need a few more test cases).&lt;/p&gt;

&lt;p&gt;All tests pass, but I have various small nocommits to work through.&lt;/p&gt;</comment>
                    <comment id="13012659" author="jasonrutherglen" created="Tue, 29 Mar 2011 21:05:06 +0100"  >&lt;blockquote&gt;&lt;p&gt;Eventually we should fold this ability into docvalues, ie we&apos;d&lt;br/&gt;
write the byte[] image at indexing time, and then loading would be&lt;br/&gt;
fast, instead of uninverting&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d guess that pulsing should be &apos;good enough&apos; most of the time?  It seems like there&apos;ll be some overlap in terms of the gains from pulsing vis-&#224;-vis DocValues?  &lt;/p&gt;</comment>
                    <comment id="13012683" author="mikemccand" created="Tue, 29 Mar 2011 21:43:30 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;d guess that pulsing should be &apos;good enough&apos; most of the time? It seems like there&apos;ll be some overlap in terms of the gains from pulsing vis-&#224;-vis DocValues?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think Pulsing codec probably doesn&apos;t help much here?&lt;/p&gt;

&lt;p&gt;Ie Pulsing is good for terms that have only 1 or 2 docs.&lt;/p&gt;

&lt;p&gt;But for this case (faceting), usually, you have relatively few terms&lt;br/&gt;
and many docs per term?&lt;/p&gt;</comment>
                    <comment id="13012687" author="jasonrutherglen" created="Tue, 29 Mar 2011 21:48:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;Ie Pulsing is good for terms that have only 1 or 2 docs&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought the default is 16 docs?  If there are more then seek&apos;ing to the postings should be negligible (in comparison to a larger aggregate index size when using CSF/DocValues, which&apos;ll consume more of the system IO cache)?&lt;/p&gt;</comment>
                    <comment id="13012810" author="cmale" created="Wed, 30 Mar 2011 02:36:53 +0100"  >&lt;p&gt;+1 to committing this change then tackling the improvements separately.&lt;/p&gt;</comment>
                    <comment id="13013727" author="mikemccand" created="Thu, 31 Mar 2011 00:20:21 +0100"  >&lt;p&gt;New patch, fixing all the nocommits, adding test case for non-null prefix passed to DTO.  I think it&apos;s ready to commit.&lt;/p&gt;</comment>
                    <comment id="13013731" author="yseeley@gmail.com" created="Thu, 31 Mar 2011 00:36:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;d guess that pulsing should be &apos;good enough&apos; most of the time?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This already really pulses I think? If the bytes can fit in an int, they are &quot;inlined&quot; right in the pointer that would normally point out to the byte array.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But for this case (faceting), usually, you have relatively few terms and many docs per term?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We see everything.  But this structure was more optimized for a high number of unique terms, but relatively few per document.  This will perform well on a multi-valued author field, but relatively poorly on a large full-text field.&lt;/p&gt;

</comment>
                    <comment id="13013747" author="yseeley@gmail.com" created="Thu, 31 Mar 2011 00:57:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;The first-pass that allocates lots of tiny byte[] looks like it could be inefficient. Maybe we could use the byte slices from the indexer for this...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is inefficient - but I never saw a way around it since the lists are all being built in parallel (due to the fact that we are uninverting).&lt;/p&gt;


&lt;p&gt;Another small &amp;amp; easy optimization I hadn&apos;t gotten around to yet was to lower the indexIntervalBits and make it configurable.  Another small optimization would be to store an array of offsets to length-prefixed byte arrays, rather than a BytesRef[].  At least the values are already in packed byte arrays via PagedBytes.&lt;/p&gt;


&lt;p&gt;I&apos;d also love to hear others thoughts on this memory optimization for many small byte arrays:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
              &lt;span class=&quot;code-comment&quot;&gt;// We avoid a doubling strategy to lower memory usage.
&lt;/span&gt;              &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; faceting method isn&apos;t &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; docs with many terms.
&lt;/span&gt;              &lt;span class=&quot;code-comment&quot;&gt;// In hotspot, objects have 2 words of overhead, then fields, rounded up to a 64-bit boundary.
&lt;/span&gt;              &lt;span class=&quot;code-comment&quot;&gt;// TODO: figure out what array lengths we can round up to w/o actually using more memory
&lt;/span&gt;              &lt;span class=&quot;code-comment&quot;&gt;// (how much space does a &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] take up?  Is data preceded by a 32 bit length only?
&lt;/span&gt;              &lt;span class=&quot;code-comment&quot;&gt;// It should be safe to round up to the nearest 32 bits in any &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;.
&lt;/span&gt;              &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; newLen = (newend + 3) &amp;amp; 0xfffffffc;  &lt;span class=&quot;code-comment&quot;&gt;// 4 &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; alignment&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13013869" author="dweiss" created="Thu, 31 Mar 2011 08:18:32 +0100"  >&lt;p&gt;For what it&apos;s worth, the instrumentation interface allows one to get exact allocation sizes of objects. I put together a small spike at &lt;a href=&quot;https://github.com/dweiss/poligon/tree/master/instrumenter&quot; class=&quot;external-link&quot;&gt;https://github.com/dweiss/poligon/tree/master/instrumenter&lt;/a&gt; that measures the actual allocation size of byte[]. On my hotspot, 64-bit, this yields:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;byte[0] takes 24 bytes.
byte[1] takes 32 bytes.
byte[2] takes 32 bytes.
byte[3] takes 32 bytes.
byte[4] takes 32 bytes.
byte[5] takes 32 bytes.
byte[6] takes 32 bytes.
byte[7] takes 32 bytes.
byte[8] takes 32 bytes.
byte[9] takes 40 bytes.
byte[10] takes 40 bytes.
byte[11] takes 40 bytes.
...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IBM&apos;s VM yields the same (64-bit), but the version of jrockit that I have (which may be an old one, but is 64-bit!) yields:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;byte[0] takes 16 bytes.
byte[1] takes 24 bytes.
byte[2] takes 24 bytes.
byte[3] takes 24 bytes.
byte[4] takes 24 bytes.
byte[5] takes 24 bytes.
byte[6] takes 24 bytes.
byte[7] takes 24 bytes.
byte[8] takes 24 bytes.
byte[9] takes 32 bytes.
byte[10] takes 32 bytes.
byte[11] takes 32 bytes.
byte[12] takes 32 bytes.
byte[13] takes 32 bytes.
byte[14] takes 32 bytes.
byte[15] takes 32 bytes.
byte[16] takes 32 bytes.
byte[17] takes 40 bytes.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Don&apos;t have access to a 32-bit system right now, but if you&apos;re keen on checking, checkout that github repo and run:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;cd instrumenter
mvn package
java -javaagent:target/instrumenter-0.1.0-SNAPSHOT.jar -version
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13013986" author="yseeley@gmail.com" created="Thu, 31 Mar 2011 15:12:13 +0100"  >&lt;p&gt;Thanks Dawid, this suggests that we could round up to the 8 byte boundary for free.&lt;/p&gt;</comment>
                    <comment id="13014370" author="markrmiller@gmail.com" created="Fri, 1 Apr 2011 03:37:59 +0100"  >&lt;p&gt;Attached: 32-bit results&lt;/p&gt;</comment>
                    <comment id="13014703" author="yseeley@gmail.com" created="Fri, 1 Apr 2011 16:45:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Attached: 32-bit results&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah, bummer.  It&apos;s every 8 bytes, but with a 4 byte offset!&lt;br/&gt;
I guess we could make it based on if we detect 32 vs 64 bit jvm... but maybe first see if anyone has any ideas about how to use something like pagedbytes instead.&lt;/p&gt;</comment>
                    <comment id="13014723" author="mikemccand" created="Fri, 1 Apr 2011 17:32:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;It is inefficient - but I never saw a way around it since the lists are all being built in parallel (due to the fact that we are uninverting).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Lucene&apos;s indexer (TermsHashPerField) has precisely this same problem&lt;br/&gt;
&amp;#8211; every unique term must point to two (well, one if omitTFAP)&lt;br/&gt;
growable byte arrays.  We use &quot;slices&quot; into a single big (paged)&lt;br/&gt;
byte[], where first slice is tiny and can only hold like 5 bytes, but&lt;br/&gt;
then points to the next slice which is a bit bigger, etc.&lt;/p&gt;

&lt;p&gt;We could look @ refactoring that for this use too...&lt;/p&gt;

&lt;p&gt;Though this is &quot;just&quot; the one-time startup cost.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Another small &amp;amp; easy optimization I hadn&apos;t gotten around to yet was to lower the indexIntervalBits and make it configurable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I did make it configurable to the Lucene class (you can pass it in to&lt;br/&gt;
ctor), but for Solr I left it using every 128th term.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Another small optimization would be to store an array of offsets to length-prefixed byte arrays, rather than a BytesRef[]. At least the values are already in packed byte arrays via PagedBytes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Both FieldCache and docvalues (branch) store an array-of-terms like&lt;br/&gt;
this (the array of offsets is packed ints).&lt;/p&gt;

&lt;p&gt;We should also look at using an FST, which&apos;d be the most compact but&lt;br/&gt;
the ord -&amp;gt; term lookup cost goes up.&lt;/p&gt;

&lt;p&gt;Anyway I think we can pursue these cool ideas on new &lt;span class=&quot;error&quot;&gt;&amp;#91;future&amp;#93;&lt;/span&gt;&lt;br/&gt;
issues...&lt;/p&gt;</comment>
                    <comment id="13043558" author="rcmuir" created="Fri, 3 Jun 2011 17:40:46 +0100"  >&lt;p&gt;bulk move 3.2 -&amp;gt; 3.3&lt;/p&gt;</comment>
                    <comment id="13222914" author="rcmuir" created="Tue, 6 Mar 2012 02:08:33 +0000"  >&lt;p&gt;3.6 pruning: can we push this out to 4.0 (mark resolved?)&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310050">
                <name>Regression</name>
                                <outwardlinks description="breaks">
                            <issuelink>
            <issuekey id="12543519">SOLR-3150</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12553572">SOLR-3427</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12475187" name="byte_size_32-bit-openjdk6.txt" size="3409" author="markrmiller@gmail.com" created="Fri, 1 Apr 2011 03:37:59 +0100" />
                    <attachment id="12475033" name="LUCENE-3003.patch" size="89610" author="mikemccand" created="Thu, 31 Mar 2011 00:20:21 +0100" />
                    <attachment id="12474916" name="LUCENE-3003.patch" size="78927" author="mikemccand" created="Tue, 29 Mar 2011 20:50:01 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 29 Mar 2011 20:05:06 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>10887</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24689</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>