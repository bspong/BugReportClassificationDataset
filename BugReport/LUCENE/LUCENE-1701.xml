<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:02:13 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1701/LUCENE-1701.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1701] Add NumericField, make plain text numeric parsers public in FieldCache, move trie parsers to FieldCache</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1701</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;In discussions about &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1673&quot; title=&quot;Move TrieRange to core&quot;&gt;&lt;del&gt;LUCENE-1673&lt;/del&gt;&lt;/a&gt;, Mike &amp;amp; me wanted to add a new NumericField to o.a.l.document specific for easy indexing. An alternative would be to add a NumericUtils.newXxxField() factory, that creates a preconfigured Field instance with norms and tf off, optionally a stored text (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1699&quot; title=&quot;Field tokenStream should be usable with stored fields.&quot;&gt;&lt;del&gt;LUCENE-1699&lt;/del&gt;&lt;/a&gt;) and the TokenStream already initialized. On the other hand NumericUtils.newXxxSortField could be moved to NumericSortField.&lt;/p&gt;

&lt;p&gt;I and Yonik tend to use the factory for both, Mike tends to create the new classes.&lt;/p&gt;

&lt;p&gt;Also the parsers for string-formatted numerics are not public in FieldCache. As the new SortField API (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1478&quot; title=&quot;Missing possibility to supply custom FieldParser when sorting search results&quot;&gt;&lt;del&gt;LUCENE-1478&lt;/del&gt;&lt;/a&gt;) makes it possible to support a parser in SortField instantiation, it would be good to have the static parsers in FieldCache public available. SortField would init its member variable to them (instead of NULL), so making code a lot easier (FieldComparator has this ugly null checks when retrieving values from the cache).&lt;/p&gt;

&lt;p&gt;Moving the Trie parsers also as static instances into FieldCache would make the code cleaner and we would be able to hide the &quot;hack&quot; StopFillCacheException by making it private to FieldCache (currently its public because NumericUtils is in o.a.l.util).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12428360">LUCENE-1701</key>
            <summary>Add NumericField, make plain text numeric parsers public in FieldCache, move trie parsers to FieldCache</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="thetaphi">Uwe Schindler</reporter>
                        <labels>
                    </labels>
                <created>Fri, 19 Jun 2009 14:28:06 +0100</created>
                <updated>Tue, 23 Jun 2009 17:59:08 +0100</updated>
                    <resolved>Tue, 23 Jun 2009 16:43:50 +0100</resolved>
                            <version>2.9</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/index</component>
                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12721787" author="earwin" created="Fri, 19 Jun 2009 14:59:57 +0100"  >&lt;p&gt;I vote for factories - escaping back-compat woes by exposing minimum interface.&lt;/p&gt;</comment>
                    <comment id="12721810" author="mikemccand" created="Fri, 19 Jun 2009 16:14:29 +0100"  >&lt;p&gt;Uwe can you also open an issue for handling byte/short/Date with&lt;br/&gt;
Numeric*?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I vote for factories - escaping back-compat woes by exposing minimum interface.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;By this same logic, should we remove NumericRangeFilter/Query and use&lt;br/&gt;
static factories instead?&lt;/p&gt;

&lt;p&gt;We can&apos;t let fear of our back-compat policies prevent progress.&lt;/p&gt;

&lt;p&gt;I seem to be the only one &lt;span class=&quot;error&quot;&gt;&amp;#91;who&amp;#39;s speaking up, at least&amp;#93;&lt;/span&gt; who feels&lt;br/&gt;
consumability of Lucene&apos;s APIs is important...&lt;/p&gt;

&lt;p&gt;Here&apos;s my reasoning: numeric fields are common; many apps need them.&lt;br/&gt;
But, it&apos;s painful to use them today; it&apos;s a trap for users because&lt;br/&gt;
Lucene acts like it can handle them (eg SortField.INT exists) but then&lt;br/&gt;
RangeQuery is buggy unless you encode the numbers (zero pad ints, use&lt;br/&gt;
Solr&apos;s or your own NumberUtils for floats/doubles).  And once you&lt;br/&gt;
figured out the encoding, you discovered RangeQuery can have horrific&lt;br/&gt;
performance.&lt;/p&gt;

&lt;p&gt;For the longest time Lucene could not provide good ootb handling of&lt;br/&gt;
numerics, but now finally an awesome step forward (thank you Uwe!)&lt;br/&gt;
comes along... and Lucene can provide correct &amp;amp; performant handling of&lt;br/&gt;
numerics.&lt;/p&gt;

&lt;p&gt;Such an important &amp;amp; useful functionality deserves a consumable API.&lt;br/&gt;
It should be obvious to people playing with Lucene how to use numeric&lt;br/&gt;
fields.  I should be able to do this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, 15.50f));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;not this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
Field f = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericTokenStream(4).setFloatValue(15.50f));
f.setOmitNorms(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
f.setOmitTermFreqAndPositions(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
doc.add(field);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nor, this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
doc.add(NumericUtils.createFloatField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, 15.50f));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When I want to reuse, I should be able to call&lt;br/&gt;
&lt;tt&gt;NumericField.setFloatValue()&lt;/tt&gt;, not ask the TokenStream to set the&lt;br/&gt;
value.&lt;/p&gt;

&lt;p&gt;In fact, as a user of this API, I shouldn&apos;t even have to know that a&lt;br/&gt;
powerful TokenStream was created to index my NumericField.  I&lt;br/&gt;
shouldn&apos;t have to know to set those advanced flags on Field.  These&lt;br/&gt;
are implementation details.  In fact with time we may make&lt;br/&gt;
improvements to these &quot;implemenation details&quot;, so we don&apos;t want such&lt;br/&gt;
implementation details out in the user&apos;s code.&lt;/p&gt;

&lt;p&gt;NumericUtils should be utility methods used only by the current&lt;br/&gt;
implemention.  Ideally it would not even be public, but Java doesn&apos;t&lt;br/&gt;
give us the ability to be package private to &quot;org.apache.lucene.*&quot;.&lt;/p&gt;

&lt;p&gt;Here&apos;s what I propose:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Add NumericField and NumericSortField, and&lt;br/&gt;
    rename RangeQuery -&amp;gt; TermRangeQuery  (TextRangeQuery?).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Move the Numeric FieldCache parsers into FieldCache,&lt;br/&gt;
    and make them (PLAIN_TEXT_INT_PARSER vs NUMERIC_INT_PARSER) public.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I would also really like to have NumericField come back when you&lt;br/&gt;
    retrieve the doc; this only requires 1 bit added to the flags&lt;br/&gt;
    stored in each doc&apos;s entry in the .fdt file.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Why should we make such an excellent addition to Lucene, only to make&lt;br/&gt;
it hard to use?&lt;/p&gt;</comment>
                    <comment id="12721827" author="thetaphi" created="Fri, 19 Jun 2009 16:41:18 +0100"  >&lt;p&gt;But the same problem like with NumericTokenStream affects also NumericField, because of type safety it will only work with a setXxxValue (if not factory), e.g.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, precisionStep).setFloatValue(15.50f));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code is not shorter than:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
doc.add(NumericUtils.newFloatField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, precisionStep, 15.50f));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1699&quot; title=&quot;Field tokenStream should be usable with stored fields.&quot;&gt;&lt;del&gt;LUCENE-1699&lt;/del&gt;&lt;/a&gt;, we could also add Field.Store.XXX to the factory/ctor. &lt;/p&gt;

&lt;p&gt;OK, the factory solution has the problem, that you cannot reuse the field for effectiveness, so this is an argument &lt;b&gt;for&lt;/b&gt; the extra class, that has setXxXValue().&lt;/p&gt;

&lt;p&gt;For SortField: The factory code inside NumericUtils is only one Line, you only create a conventional SortField with a specific parser. If we do not want to have the factory in NumericUtils, I could also add an additional ctor option to the normal sortfield (which is still there: it takes the parser, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1478&quot; title=&quot;Missing possibility to supply custom FieldParser when sorting search results&quot;&gt;&lt;del&gt;LUCENE-1478&lt;/del&gt;&lt;/a&gt;). When all parsers are central in the FieldCache, one can create a SortField with one line of code (the current factory demonstrates this).&lt;/p&gt;</comment>
                    <comment id="12721830" author="earwin" created="Fri, 19 Jun 2009 16:48:32 +0100"  >&lt;p&gt;Mike, I very much agree with everything you said, except &quot;factory is less consumable than constructor&quot; and &quot;add stuff to index to handle NumericField&quot;.&lt;/p&gt;

&lt;p&gt;Out of your three examples the second one is bad, no questions. But first and last are absolutely equal in terms of consumability.&lt;br/&gt;
Static factories are cool (they allow to switch implementations and instantiation logic without changing API) and are as easy to use (probably even easier with generics in Java5) as constructors.&lt;/p&gt;

&lt;p&gt;If we add some generic storable flags for Lucene fields, this is cool (probably), NumericField can then capitalize on it, as well as users writing their own NNNFields.&lt;br/&gt;
Tying index format to some particular implementation of numerics is bad design. Why on earth can&apos;t my own split-field (vs single-field as in current Lucene) trie-encoded number enjoy the same benefits as NumericField from Lucene core?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;By this same logic, should we remove NumericRangeFilter/Query and use static factories instead?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I do use factory methods for all my queries and filters, and it makes me feel warm and fuzzy! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Under the hood some of them consult FieldInfo to instantiate custom-tailored query variants, so I just use range(CREATION_TIME, from, to) and don&apos;t think if this field is trie-encoded or raw.&lt;/p&gt;

&lt;p&gt;&quot;Simple things should be simple&quot;, okay. Complex things should be simple too, argh! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12721873" author="thetaphi" created="Fri, 19 Jun 2009 17:47:37 +0100"  >&lt;p&gt;Here is a first draft of NumericField with the same handling as NumericTokenStream. It is for indexing only, on retrieving stored fields, one would get the numeric field value as a string (according to Number.toString()). Because of this, this class returns in stringValue() the string representation of the numeric value and with tokenStreamValue the NumericTokenStream is returned.&lt;/p&gt;

&lt;p&gt;For SortField I still have the very strong opinion, that here a extra class is not needed. A factory is enough (and even too much, supplying the Parser to SortField would be enough).&lt;/p&gt;

&lt;p&gt;I will later post a patch with this file and the moved/made public Parsers.&lt;/p&gt;</comment>
                    <comment id="12721880" author="yseeley@gmail.com" created="Fri, 19 Jun 2009 18:04:50 +0100"  >&lt;p&gt;Having the trie parsers public is good (or public factory method(s) to get the right parser given a set of trie params), but shouldn&apos;t they stay with the trie classes?  Or am I misunderstanding where you are proposing to move the parsers?&lt;/p&gt;</comment>
                    <comment id="12721914" author="thetaphi" created="Fri, 19 Jun 2009 19:06:19 +0100"  >&lt;p&gt;Yonik, I will explain my intention:&lt;br/&gt;
The real numeric parsing is always done in NumericUtils, as for conventional FieldCache the real parsing is done in Integer.parseInt() and so on.&lt;br/&gt;
Specific to the FieldCache is the Parser interface. This parser interface is a java interface specific to FieldCache. FieldCache currently has (private) static parser instances for Number.toString()-type fields. These parser are simple 5-liners and singletons. For trie fields, this is the same, the static parser instances (also singletons) should be moved also to FieldCache, after that both as public constants (like Mike said: PLAIN_TEXT_INT_PARSER and NUMERIC_INT_PARSER).&lt;br/&gt;
Currently for Trie fields there is a ugly hack in FieldCache, that stops parsing, when a term with lower precision is reached (as trie terms are ordered with highest precision first, the cache for a field is filled, when the first lower-precision term comes). Because of this, the trie parsers throw a unchecked StopFillCacheException to stop the iteration of TermEnum/TermDocs in the Uninverter. This is just a hack and because of package differences this FieldCache-internal exception is made public (see Javadocs). When moving the parser interfaces to FieldCace, this Exception can be hidden again and made private to the FieldCache implementation (until we have the better univerters some time in future, see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt;). NumericUtils then will only just export a method to get the shift value out of a encoded string (which I forgot to add in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1673&quot; title=&quot;Move TrieRange to core&quot;&gt;&lt;del&gt;LUCENE-1673&lt;/del&gt;&lt;/a&gt; when removing ShiftAttribute).&lt;br/&gt;
Trie field parsing does not depend on Trie-specific flags, precisionStep is not needed, so the parsers are real singletons.&lt;/p&gt;

&lt;p&gt;SortFields can then simply created in the Following way: new SortField(field, FieldCache.PLAIN_TEXT_INT_PARSER) for a conventional int field (like with SortField.INT) or new SortField(field, FieldCache.NUMERIC_INT_PARSER). giving a NULL parser still does the same as before, it uses FieldCache.PLAIN_TEXT_INT_PARSER implicitely.&lt;/p&gt;</comment>
                    <comment id="12721915" author="yseeley@gmail.com" created="Fri, 19 Jun 2009 19:19:47 +0100"  >&lt;p&gt;Regardless of the fact that plain_int parser is on FieldCache, it still doesn&apos;t seem like we should add parsers to FieldCache for every field type.  It&apos;s also the case that a single static parser won&apos;t be able to handle all the cases... consider future functionality of using positions or payloads to fill out the full value.  A factory allows you to return the correct implementation given the parameters (number of bits to store as position, etc).&lt;/p&gt;</comment>
                    <comment id="12721920" author="thetaphi" created="Fri, 19 Jun 2009 19:27:39 +0100"  >&lt;p&gt;When this comes (payloads, CSF,...) we will have the new &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; field cache, where we will have a ValueSource-like thing. Until then, a static parser is enough, and the static parser is still in NumericUtils! I want to move it because of this hack with the unchecked exception. When the new FieldCache is alive this is all nonsense.&lt;/p&gt;</comment>
                    <comment id="12721929" author="yseeley@gmail.com" created="Fri, 19 Jun 2009 19:53:42 +0100"  >&lt;p&gt;The exception certainly is a hack - but any new field cache API should be powerful enough to handle trie through the normal APIs that anyone else would have to go through when implementing their own field type.  If Trie &lt;b&gt;needs&lt;/b&gt; to be part of the new field cache implementation, that would be a big red flag.&lt;/p&gt;</comment>
                    <comment id="12721946" author="thetaphi" created="Fri, 19 Jun 2009 20:20:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;ut any new field cache API should be powerful enough to handle trie through the normal APIs that anyone else would have to go through when implementing their own field type&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is true, the &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; patch contains a TrieValueSource for that (but it does not apply anymore, as contrib/search/trie is no longer available). Because of this, it can be implemented very cleanly.&lt;/p&gt;

&lt;p&gt;For easy usage, I would simply suggest to have the parsers for the current plain text and trie field cache implementation public available as singletons, very simple and hurts nobody. I will post a patch for the whole case soon. NumericField will be tested in the NumericRangeQuery index creation (which is currently very ugly, like meikes comments about the code and reusing Fields/TokenStreams, with NumericField it looks like any other index code).&lt;/p&gt;

&lt;p&gt;For Solr (&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-940&quot; title=&quot;TrieRange support&quot;&gt;&lt;del&gt;SOLR-940&lt;/del&gt;&lt;/a&gt;), there is not need to use NumericField (which is just a helper), the code of TrieField can stay as it is, only some renamings and so on. It just presents a TokenStream to the underlying Solr indexer, as before.&lt;/p&gt;</comment>
                    <comment id="12721956" author="mikemccand" created="Fri, 19 Jun 2009 20:37:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;Here is a first draft of NumericField with the same handling as NumericTokenStream.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Looks good Uwe!  Is there an OK default for precisionStep so we don&apos;t have&lt;br/&gt;
to make that a required arg?  4?&lt;/p&gt;</comment>
                    <comment id="12721961" author="mikemccand" created="Fri, 19 Jun 2009 20:49:36 +0100"  >&lt;blockquote&gt;&lt;p&gt;Static factories are cool (they allow to switch implementations and instantiation logic without changing API) and are as easy to use (probably even easier with generics in Java5) as constructors.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Coolness is in the eye of the beholder?&lt;/p&gt;

&lt;p&gt;Yes, they are cool in that they give the &lt;b&gt;developer&lt;/b&gt; (us) future&lt;br/&gt;
freedom (to change the actual class returned, re-use instances, use&lt;br/&gt;
singletons, etc.), but not cool (in my eyes) for consumability.&lt;/p&gt;

&lt;p&gt;Static factory classes are a good fit when the impls really should&lt;br/&gt;
remain anonymous because there are trivial differences.  EG the 12&lt;br/&gt;
different impls that can be returned by TopFieldCollector.create are a&lt;br/&gt;
good example.&lt;/p&gt;

&lt;p&gt;But NumericField vs Field, and SortField vs NumericSortField, are&lt;br/&gt;
different and should be seen as different to consumer of Lucene&apos;s API.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If we add some generic storable flags for Lucene fields, this is cool (probably), NumericField can then capitalize on it, as well as users writing their own NNNFields.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1  Wanna make a patch?&lt;/p&gt;

&lt;p&gt;Then NumericField would just tap in to this extensibility... and,&lt;br/&gt;
somehow, in our future improved search time document() API, have the&lt;br/&gt;
ability to make a NumericField.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why on earth can&apos;t my own split-field (vs single-field as in current Lucene) trie-encoded number enjoy the same benefits as NumericField from Lucene core?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because.... we&apos;ve decided that this is our core approach to numerics?&lt;/p&gt;

&lt;p&gt;Seriously, I don&apos;t see that as unfair.  Trie works well.  We have&lt;br/&gt;
chosen it as our way (for now, until something better comes along) of&lt;br/&gt;
handling numerics.  Just like we&apos;ve picked a certain format for the&lt;br/&gt;
terms dict and prx file.&lt;/p&gt;

&lt;p&gt;Sure, we should make it easy (add extensibility) so external fields&lt;br/&gt;
could store stuff in the index, but that doesn&apos;t mean we should hold&lt;br/&gt;
back on Numeric* consumability until we get that extensibility.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I do use factory methods for all my queries and filters, and it makes me feel warm and fuzzy!  Under the hood some of them consult FieldInfo to instantiate custom-tailored query variants, so I just use range(CREATION_TIME, from, to) and don&apos;t think if this field is trie-encoded or raw.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Someday maybe I&apos;ll convince you to donate this &quot;schema&quot; layer on top&lt;br/&gt;
of Lucene &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But I hope there are SOME named classes in there and not&lt;br/&gt;
all static factory methods returning anonymous untyped impls.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;Simple things should be simple&quot;, okay. Complex things should be simple too, argh! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa, this is all simple stuff?  What should be complex about using&lt;br/&gt;
numeric fields in Lucene?  This whole issue is &quot;simple things should&lt;br/&gt;
be simple&quot;.&lt;/p&gt;</comment>
                    <comment id="12721972" author="yseeley@gmail.com" created="Fri, 19 Jun 2009 21:02:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;Because.... we&apos;ve decided that this is our core approach to numerics?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We decided to move trie from contrib to core because it was the most stable and usable numeric implementation.  We did not decide to rewrite it, or make it &quot;special&quot;.  It&apos;s not sufficient for everyone, there will be (many) enhancements to trie, and there will be other numeric field types.  Trie is not, and should not be the only numeric field, and should not be baked into the index format.&lt;/p&gt;

&lt;p&gt;The next step after adding NumericField seems to be &quot;it&apos;s a bug if getDocument() doesn&apos;t return a NumericField, so we must encode it in the index&quot;.  If that&apos;s the case, I&apos;m -1 on adding NumericField in the first place.&lt;/p&gt;</comment>
                    <comment id="12721979" author="mikemccand" created="Fri, 19 Jun 2009 21:16:15 +0100"  >&lt;p&gt;I still think we should make NumericSortField strongly typed (not a&lt;br/&gt;
factory method that returns a SortField w/ the right parser).&lt;/p&gt;

&lt;p&gt;I think it&apos;s far more consumable, from the user&apos;s standpoint. I made&lt;br/&gt;
a NumericField when indexing so making a NumericSortField to sort&lt;br/&gt;
makes it &quot;obvious&quot;.&lt;/p&gt;

&lt;p&gt;Ie this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericSortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;is better than this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, FieldCache.NUMERIC_FLOAT_PARSER);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
SortField.getNumericSortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, SortField.FLOAT);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Uwe, I agree that if we take the developer&apos;s (us) standpoint, the&lt;br/&gt;
implementation of NumericSortField is so trivial (just pick the right&lt;br/&gt;
parser) that it&apos;s tempting to not name the class.  But from the user&apos;s&lt;br/&gt;
standpoint it&apos;s less consumable.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Regardless of the fact that plain_int parser is on FieldCache, it still doesn&apos;t seem like we should add parsers to FieldCache for every field type.&lt;/p&gt;&lt;/blockquote&gt;

{Extended,}
&lt;p&gt;FieldCache already is the central place that holds parsers&lt;br/&gt;
for all of Lucene&apos;s core types; why change that?  Leaving Numeric* out&lt;br/&gt;
is dangerous because then people will naturally assume getFloats() is&lt;br/&gt;
the method to call.&lt;/p&gt;</comment>
                    <comment id="12721983" author="yseeley@gmail.com" created="Fri, 19 Jun 2009 21:26:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;new NumericSortField(&quot;price&quot;);&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Magic.&lt;br/&gt;
How is this supposed to work?&lt;br/&gt;
How will the sort field know the exact encoding?  How many bits are stored in a payload or in the position?&lt;br/&gt;
Could I make my own field type that had the same privileges?&lt;/p&gt;</comment>
                    <comment id="12721988" author="thetaphi" created="Fri, 19 Jun 2009 21:34:31 +0100"  >&lt;p&gt;I aggree with Yonik, this is too much magic and would not work. There must be at least the type, which would be SortField.FLOAT or something like that). If you keep that in mind, there is really no difference between:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, FieldCache.NUMERIC_FLOAT_PARSER)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, FieldCache.PLAIN_TEXT_FLOAT_PARSER)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;equivalent to:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SortField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, SortField.FLOAT)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12721989" author="mikemccand" created="Fri, 19 Jun 2009 21:36:43 +0100"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s not sufficient for everyone, there will be (many) enhancements to trie, and there will be other numeric field types. Trie is not, and should not be the only numeric field, and should not be baked into the index format.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But trie is the best we have today?&lt;/p&gt;

&lt;p&gt;And it&apos;s sooooo much better than we had before?  Prior to trie, with&lt;br/&gt;
Lucene directly if you did a RangeQuery on a float/double field, it&lt;br/&gt;
was a nightmare.  You had to get Solr&apos;s NumberUtils (or, roll your&lt;br/&gt;
own) to get something that even returned the correct results.  Then,&lt;br/&gt;
you&apos;ll discover that performance was basically unusable.&lt;/p&gt;

&lt;p&gt;The addition of numeric indexing to Lucene is a &lt;b&gt;major&lt;/b&gt; step forward.&lt;br/&gt;
Why not make it work well with Lucene, today, and as these future&lt;br/&gt;
improvements arrive, we take them as they come?  Design for today.&lt;/p&gt;

&lt;p&gt;Anyway, if push comes to shove (which it &lt;b&gt;seems&lt;/b&gt; to be doing!), I can&lt;br/&gt;
accept just returning a Field (not NumericField) from the document at&lt;br/&gt;
search time.  I think it&apos;s a worse user experience, and will be seen&lt;br/&gt;
as buggy, but it would in fact mean zero change to the index format.&lt;/p&gt;</comment>
                    <comment id="12721993" author="mikemccand" created="Fri, 19 Jun 2009 21:39:58 +0100"  >&lt;blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;new NumericSortField(&quot;price&quot;);&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Magic.&lt;br/&gt;
How is this supposed to work?&lt;br/&gt;
How will the sort field know the exact encoding? How many bits are stored in a payload or in the position?&lt;br/&gt;
Could I make my own field type that had the same privileges?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops, sorry, you&apos;re right: you&apos;d need to specify the type, at least.&lt;/p&gt;

&lt;p&gt;So.... how about for SortField we make the parser a required arg (as&lt;br/&gt;
Uwe suggested) for numeric types?  Allow null to mean &quot;give me the&lt;br/&gt;
default parser&quot; for all other types.  And we consolidate all parsers&lt;br/&gt;
in FieldCache.&lt;/p&gt;</comment>
                    <comment id="12722002" author="thetaphi" created="Fri, 19 Jun 2009 21:53:44 +0100"  >&lt;p&gt;That is what I was talking about all the time!&lt;/p&gt;

&lt;p&gt;But this is all not really the best solution. It is too bad, that &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; (not in current form, it is just not discussed to the end) is not to be included into 2.9. I know we will have to stick with parsers until end of days, because the new ValueSource staff and Uninverters was not introduces early enough to be removed with 3.0. And Trie fields with positions/payloads would never work with current FieldCache, so I need no factories.&lt;/p&gt;

&lt;p&gt;So this would be postponed until this is done. Then we could have a ValueSource for trie fields, where you could add these magic stuff like payloads and so on. But until this comes to reality (including CSF), the static parsers is all we have until now and is best placed in FieldCache (because of the strong linkage with this ugly exception to be hidden to the outside).&lt;/p&gt;

&lt;p&gt;Earwin, Yonik: I know TrieRange is only &lt;b&gt;one&lt;/b&gt; implementation of the whole numeric problem, but none of you ever presented your implementation to the public. This is the best we have now, its included into core and everybody is happy. If you have a better private implementation, you can still use it!&lt;/p&gt;</comment>
                    <comment id="12722017" author="mikemccand" created="Fri, 19 Jun 2009 22:19:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;That is what I was talking about all the time!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Eh, yeah... somethings things just need a good hashing out!&lt;/p&gt;

&lt;p&gt;2.9 is really shaping up to be an awesome release...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But this is all not really the best solution. It is too bad, that &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; (not in current form, it is just not discussed to the end) is not to be included into 2.9.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Progress not perfection!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I know we will have to stick with parsers until end of days, because the new ValueSource staff and Uninverters was not introduces early enough to be removed with 3.0.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well we are discussing relaxing the back-compat policy... so maybe&lt;br/&gt;
earlier than &quot;end of days&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And Trie fields with positions/payloads would never work with current FieldCache, so I need no factories.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;ll cross that bridge when we get there...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So this would be postponed until this is done. Then we could have a ValueSource for trie fields, where you could add these magic stuff like payloads and so on. But until this comes to reality (including CSF), the static parsers is all we have until now and is best placed in FieldCache (because of the strong linkage with this ugly exception to be hidden to the outside).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Earwin, Yonik: I know TrieRange is only one implementation of the whole numeric problem, but none of you ever presented your implementation to the public. This is the best we have now, its included into core and everybody is happy. If you have a better private implementation, you can still use it!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We shouldn&apos;t weaken trie&apos;s integration to core just because others&lt;br/&gt;
have private implementations.  What&apos;s important is that we don&apos;t&lt;br/&gt;
weaken those private implementations with trie&apos;s addition, and I don&apos;t&lt;br/&gt;
think our approach here has done that.&lt;/p&gt;</comment>
                    <comment id="12722060" author="earwin" created="Fri, 19 Jun 2009 23:19:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;Someday maybe I&apos;ll convince you to donate this &quot;schema&quot; layer on top of Lucene&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s not generic enough to be of use for every user of Lucene, and it doesn&apos;t aim to be such. It also evolves, and donating something to Lucene means casting it in concrete.&lt;br/&gt;
So that&apos;s not me being greedy or lazy (okay, maybe a little bit of the latter), it&apos;s simply not public-quality (as I understand it) code.&lt;br/&gt;
I can share the design if anybody&apos;s interested, but everyone&apos;s coping with it themselves it seems.&lt;/p&gt;

&lt;p&gt;Solr has its own schema approach, and it has its merits and downfalls compared to mine. That&apos;s what is nice, we&apos;re able to use the same library in differing ways, and it doesn&apos;t force its sense of &apos;best practices&apos; on us. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I hope there are SOME named classes in there and not all static factory methods returning anonymous untyped impls.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;SOME of them aren&apos;t static :-D&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We shouldn&apos;t weaken trie&apos;s integration to core just because others have private implementations.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You shouldn&apos;t integrate into core something that is not core functionality. Think microkernels.&lt;br/&gt;
It&apos;s strange seeing you drive CSFs, custom indexing chains, pluggability everywhere on one side, and trying to add some weird custom properties into index that are tightly interwoven with only one of possible numeric implementations on the other side.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Design for today.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;And spend two years deprecating and supporting today&apos;s designs after you get a better thing tomorrow. Back-compat Lucene-style and agile design aren&apos;t something that marries well.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What&apos;s important is that we don&apos;t weaken those private implementations with trie&apos;s addition, and I don&apos;t think our approach here has done that.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You&apos;re weakening Lucene itself by introducing too much coupling between its components.&lt;/p&gt;

&lt;p&gt;IndexReader/Writer pair is a good example of what I&apos;m arguing against. A dusty closet of microfeatures that are tightly interwoven into a complex hard-to-maintain mess with zillions of (possibly broken) control paths - remember mutable deletes/norms+clone/reopen permutations? It could be avoided if IR/W were kept to the bare minimum (which most people are going to use), and more advanced features were built on top of it, not in the same place.&lt;/p&gt;

&lt;p&gt;NRT seems to tread the same path, and I&apos;m not sure it&apos;s going to win that much turnaround time after newly-introduced per-segment collection. Some time ago I finished a first version of IR plugins, and enjoy pretty low reopen times (field/facet/filter cache warmups included). (Yes, I&apos;m going to open an issue for plugins once they stabilize enough)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; If we add some generic storable flags for Lucene fields, this is cool (probably), NumericField can then capitalize on it, as well as users writing their own NNNFields.&lt;br/&gt;
+1 Wanna make a patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, I&apos;d like to continue IR cleanup and play with positionIncrement companion value that could enable true multiword synonyms. &lt;br/&gt;
I know, I know, it&apos;s do-a-cracy. But it&apos;s not an excuse for hacks.&lt;/p&gt;</comment>
                    <comment id="12722166" author="mikemccand" created="Sat, 20 Jun 2009 11:35:29 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Someday maybe I&apos;ll convince you to donate this &quot;schema&quot; layer on top of Lucene&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s not generic enough to be of use for every user of Lucene, and it doesn&apos;t aim to be such.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh, OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Solr has its own schema approach, and it has its merits and downfalls compared to mine. That&apos;s what is nice, we&apos;re able to use the same library in differing ways, and it doesn&apos;t force its sense of &apos;best practices&apos; on us.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There&apos;s no forcing going on, here.  Even had we added the bit into the&lt;br/&gt;
index, there&apos;s still no &quot;forcing&quot;.  We&apos;re not preventing advanced uses&lt;br/&gt;
of Lucene by providing strong Numeric* support in Lucene.  Simple&lt;br/&gt;
things should be simple; complex things should be possible...&lt;/p&gt;


&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But I hope there are SOME named classes in there and not all static factory methods returning anonymous untyped impls.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;SOME of them aren&apos;t static :-D&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Heh.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;We shouldn&apos;t weaken trie&apos;s integration to core just because others have private implementations.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You shouldn&apos;t integrate into core something that is not core functionality. Think microkernels.&lt;br/&gt;
It&apos;s strange seeing you drive CSFs, custom indexing chains, pluggability everywhere on one side, and trying to add some weird custom properties into index that are tightly interwoven with only one of possible numeric implementations on the other side.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree: if Lucene had all extension points that&apos;d make it possible&lt;br/&gt;
for a good integration of Numeric* without being in &quot;core&quot;, we should&lt;br/&gt;
use that.  But we&apos;re just not there yet.  We want to get there, and we&lt;br/&gt;
will, but we can&apos;t hold up progress just because we think someday&lt;br/&gt;
we&apos;ll get there.  That&apos;s like saying we can&apos;t improve the terms dict&lt;br/&gt;
format because it&apos;s not pluggable yet.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Design for today.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And spend two years deprecating and supporting today&apos;s designs after you get a better thing tomorrow. Back-compat Lucene-style and agile design aren&apos;t something that marries well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;donating something to Lucene means casting it in concrete.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can&apos;t let fear of back-compat prevent us from making progress.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;IndexReader/Writer pair is a good example of what I&apos;m arguing against. A dusty closet of microfeatures that are tightly interwoven into a complex hard-to-maintain mess with zillions of (possibly broken) control paths - remember mutable deletes/norms+clone/reopen permutations? It could be avoided if IR/W were kept to the bare minimum (which most people are going to use), and more advanced features were built on top of it, not in the same place.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, our approach today isn&apos;t perfect (&quot;progress not perfection&quot;).&lt;br/&gt;
There are always improvements to be done.  If you see concrete steps&lt;br/&gt;
to simplify the current approach without losing functionality, please&lt;br/&gt;
post a patch.  I too would love to see such simplifications...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;NRT seems to tread the same path, and I&apos;m not sure it&apos;s going to win that much turnaround time after newly-introduced per-segment collection.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, per-segment collection was the bulk of the gains needed for&lt;br/&gt;
NRT.  This was a big change and a huge step forward in simple reopen&lt;br/&gt;
turnaround.&lt;/p&gt;

&lt;p&gt;But, not having to write &amp;amp; read deletes to disk, not commit (fsync)&lt;br/&gt;
from writer in order to see those changes in reader should also give&lt;br/&gt;
us decent gains.  fsync is surprisingly and intermittently costly.&lt;/p&gt;

&lt;p&gt;And this integration lets us take it a step further with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
where recently created segments can remain in RAM and be shared with&lt;br/&gt;
the reader.&lt;/p&gt;

&lt;p&gt;If you have good simplifications/improvements on the approach here,&lt;br/&gt;
please post them.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Some time ago I finished a first version of IR plugins, and enjoy pretty low reopen times (field/facet/filter cache warmups included). (Yes, I&apos;m going to open an issue for plugins once they stabilize enough)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m confused: I thought that effort was to make SegmentReader&apos;s&lt;br/&gt;
components fully pluggable?  (Not to actually change what components&lt;br/&gt;
SegmentReader is creating).  EG does this modularization alter the&lt;br/&gt;
approach to NRT?  I thought they were orthogonal.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If we add some generic storable flags for Lucene fields, this is cool (probably), NumericField can then capitalize on it, as well as users writing their own NNNFields.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;+1 Wanna make a patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, I&apos;d like to continue IR cleanup and play with positionIncrement companion value that could enable true multiword synonyms. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well I&apos;m looking forward to seeing your approach on these two!&lt;/p&gt;</comment>
                    <comment id="12722216" author="thetaphi" created="Sat, 20 Jun 2009 17:46:17 +0100"  >&lt;p&gt;Patch with all changes, including &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1687&quot; title=&quot;Remove ExtendedFieldCache by rolling functionality into FieldCache&quot;&gt;&lt;del&gt;LUCENE-1687&lt;/del&gt;&lt;/a&gt; (it is easier to do this together):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Add NumericField, change JavaDocs to prefer this where possible.&lt;/li&gt;
	&lt;li&gt;Change range tests to use NumericField during build of test index, this also tests stored fields with NumericField (much cleaner now)&lt;/li&gt;
	&lt;li&gt;Remove SortField factory from NumericUtils, this class is now almost only for expert users; creating a SortField is possible with SortField ctor using parser instance.&lt;/li&gt;
	&lt;li&gt;Make all parsers in FieldCache public (DEFAULT_XXX_PARSER)&lt;/li&gt;
	&lt;li&gt;Add trie parsers to FieldCache, too (NUMERIC_UTILS_XXX_PARSER)&lt;/li&gt;
	&lt;li&gt;Hide StopFillCacheException-hack&lt;/li&gt;
	&lt;li&gt;Change SortField to automatically initialize the correct parser according to the type (defaults to text-only parsers) &amp;#8211; there is still some good javadocs missing to tell the user, that it is better to use SortField(String, Parser) instead of SortField(String, type-int) for numeric values, especially when indexed using NumericField.&lt;/li&gt;
	&lt;li&gt;Because SortField is serializable, all parsers were made singletons and serializable, too (superinterface Parser extends Serializable, default parsers define readResolve() to enforce singletons, which are important for FieldCache to work correctly)&lt;/li&gt;
	&lt;li&gt;Remove now unneeded (parser==null) checks in sorting code, as SortField enforces a non-null parser now.&lt;/li&gt;
	&lt;li&gt;Remove all code from ExtendedFieldCache and move to FieldCache (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1687&quot; title=&quot;Remove ExtendedFieldCache by rolling functionality into FieldCache&quot;&gt;&lt;del&gt;LUCENE-1687&lt;/del&gt;&lt;/a&gt;), keep a stub for binary backwards-compatibility. The only implementation is now FieldCacheImpl referred to by DEFAULT (and EXT_DEFAULT for bw).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;A short note: SortField is only serializable, if all custom comparators used are also serializable, maybe we should also note this in the docs. Parsers are automatically serializable (because superinterface), but not automatically real singletons (but this is not Lucenes problem).&lt;/p&gt;</comment>
                    <comment id="12722218" author="thetaphi" created="Sat, 20 Jun 2009 17:58:03 +0100"  >&lt;p&gt;I know you will kill me, Yonik, and Mike will love me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; but there is a possibility to also support Trie fields with standard SortField.XXX constants using autodetection. Trie fields always start with a shift-prefix defining the type and so for sure contain non-digits. So FieldCache could simply test and catch NumberFormatException.&lt;/p&gt;

&lt;p&gt;So maybe this would be an option, to make the default (parser== null in FieldCaches getInts(),...) detect this automatically.&lt;/p&gt;

&lt;p&gt;Users then could use SortField/FieldCache as before, ignoring the real encoding. If I would implement this, I could remove the enforcing to parser==null in SortField again and make FieldCache do the detection in this case.&lt;/p&gt;</comment>
                    <comment id="12722228" author="thetaphi" created="Sat, 20 Jun 2009 18:48:45 +0100"  >&lt;p&gt;The last patch was still not 100% backwards compatible, now it is. The modified test-tag TestExtendedFieldCache shows it, it will be committed to backwards-compatibility branch&lt;/p&gt;</comment>
                    <comment id="12722257" author="yseeley@gmail.com" created="Sat, 20 Jun 2009 20:53:48 +0100"  >&lt;p&gt;I&apos;ll quote myself, and then attempt to not repeat myself further after this point (the back and forth is silly).&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The next step after adding NumericField seems to be &quot;it&apos;s a bug if getDocument() doesn&apos;t return a NumericField, so we must encode it in the index&quot;. If that&apos;s the case, I&apos;m -1 on adding NumericField in the first place.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Everyone thinks good APIs, good architecture, and good performance is important.  It imply otherwise is also silly.&lt;/p&gt;</comment>
                    <comment id="12722271" author="mikemccand" created="Sat, 20 Jun 2009 23:54:44 +0100"  >&lt;blockquote&gt;&lt;p&gt;there is a possibility to also support Trie fields with standard SortField.XXX constants using autodetection.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Meaning we wouldn&apos;t be forced to specify FieldCache.DEFAULT_INT_PARSER/FieldCache.NUMERIC_UTILS_INT_PARSER when creating SortField or calling FieldCache.getInts?  And we&apos;d make the core parsers package private again?&lt;/p&gt;

&lt;p&gt;So users could simply do &lt;tt&gt;SortField(&quot;price&quot;, SortField.FLOAT)&lt;/tt&gt; and it&apos;d just work?&lt;/p&gt;

&lt;p&gt;I think this is is compelling!  Why not take this approach?  There would then be no user visible changes to how you sort by numeric fields...&lt;/p&gt;</comment>
                    <comment id="12722305" author="thetaphi" created="Sun, 21 Jun 2009 07:14:34 +0100"  >&lt;p&gt; Yes, it would work this way. This only would violate Yoniks complaints about not miximg Trie too much into the other code, but this is already done because of this StopFillCacheException usage. When we do &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt;, this should be thought about, too.&lt;/p&gt;

&lt;p&gt;SortField.AUTO is deprecated and will not be changed (only detect text numbers). There should be a note, that it would not work with the &quot;new&quot; NumericFields.&lt;/p&gt;

&lt;p&gt;I would make the core parsers public to enable users to have full control (on the other hand I could now hide also the trie parsers). But this is a bad approach, wherever automatisms are envolved, oneshould always have the possibility to fix to one parser. And why do we have the SortField/FieldCache accessors with parser parameter, when you cannot even use the default ones?&lt;/p&gt;

&lt;p&gt;P.S.: About payloads &amp;amp; positions and the need for extra parameters to the parser: After adding support for positions or payloads to encode the highest precision, there is still no need for an extra SortField/Parser class or factory. The future &quot;ValueSource&quot; starts to decode the values until a change in shift occurs. This first shift is for sure the highest precision (because of term ordering), if it is 0, its like now (no payloads/prositions); if the first visible shift&amp;gt;0, payloads/positions were used and the numbero of bits there is also known.&lt;/p&gt;</comment>
                    <comment id="12722306" author="thetaphi" created="Sun, 21 Jun 2009 07:27:55 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;ll quote myself, and then attempt to not repeat myself further after this point (the back and forth is silly).&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The next step after adding NumericField seems to be &quot;it&apos;s a bug if getDocument() doesn&apos;t return a NumericField, so we must encode it in the index&quot;. If that&apos;s the case, I&apos;m -1 on adding NumericField in the first place.&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;

&lt;p&gt;It is mentioned in the docs, that this class is for indexing only:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
* &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Please note:&amp;lt;/b&amp;gt; This class is only used during indexing. You can also create
* numeric stored fields with it, but when retrieving the stored field value
* from a {@link Document} instance after search, you will get a conventional
* {@link Fieldable} instance where the numeric values are returned as {@link &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;}s
* (according to &amp;lt;code&amp;gt;toString(value)&amp;lt;/code&amp;gt; of the used data type).
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my opinion: Storing this info in the segments is not doable without pitfalls: If somebody indexes a normal field name in one IndexWriter session and starts to index using NumericFiled in the next session, he would have two segments with different encoding and two different &quot;flags&quot;. When these two segments are merged later, what do with the flag?&lt;/p&gt;

&lt;p&gt;If we want to have such Schemas, they must be index wide and we have no possibility in Lucene for that at the moment.&lt;/p&gt;

&lt;p&gt;If somebody creates a schema, that can do this (by storing the schema in a separate file next to the segments file), we can think about it again (with all problems, like: MultiReader on top of two indexes with different schemas - forbid that because schema different?). All this says me, we should not do this, it is the task of Solr, my own project panFMP, or Earwin&apos;s own schema, to enforce it.&lt;/p&gt;</comment>
                    <comment id="12722310" author="thetaphi" created="Sun, 21 Jun 2009 08:30:29 +0100"  >&lt;p&gt;Here a patch with the auto-detection. All tests pass, also backwards-tests. The parsers are still public for total control on the conversion.&lt;/p&gt;</comment>
                    <comment id="12722324" author="mikemccand" created="Sun, 21 Jun 2009 10:25:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;In my opinion: Storing this info in the segments is not doable without pitfalls:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The proposal was not to store it into the segments file (which I agree it has serious problems, since it&apos;s global).  I had considered FieldInfos (which is &quot;roughly&quot; Lucene&apos;s &quot;schema&quot;, per segment), but that too has clear problems.&lt;/p&gt;

&lt;p&gt;My proposal was the flags per-field stored in the fdt file.  In that file, we are already writing one byte&apos;s worth of flags (only 3 of the bits are used now), for every stored field instance.  This is in FieldsWriter.java ~ line 181.  The flags now record whether each specific field instance was tokenized, compressed, binary.  FieldsReader then uses these flags to reconstruct the Field instances when building the document. This bits are never merged; they are copied (because they apply to that one field instance, in that one document).&lt;/p&gt;

&lt;p&gt;My proposal was to add another flag bit (numeric) and make use of that to return a NumericField instance when you get your document back.  It would have no impact to the index size, since we still have 5 free bits to use.&lt;/p&gt;

&lt;p&gt;But, it is technically a (one bit) change to the index format, which people seriously objected to.  So net/net I&apos;m OK going forward without it.&lt;/p&gt;</comment>
                    <comment id="12722327" author="thetaphi" created="Sun, 21 Jun 2009 10:49:21 +0100"  >&lt;p&gt;Here an updated patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;fix some copy/paste duplicates in assignments&lt;/li&gt;
	&lt;li&gt;add extra check to fail early when autodetection fails&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The patch (and the one before) checks the autodetection two times (so you see in the trie tests, how one would use SortField with trie), what do you think about all this?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But, it is technically a (one bit) change to the index format, which people seriously objected to.  So net/net I&apos;m OK going forward without it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, and for the reasons noted before, I would like to see NumericField as only a helper for indexing. Storing the number as plain-text string (as done in the patch) does not justify a NumericField on getting stored fields.&lt;/p&gt;

&lt;p&gt;When Yonik committed &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1699&quot; title=&quot;Field tokenStream should be usable with stored fields.&quot;&gt;&lt;del&gt;LUCENE-1699&lt;/del&gt;&lt;/a&gt;, I would do some additional NumericField fine tuning, but the patch is finished now.&lt;/p&gt;</comment>
                    <comment id="12722330" author="mikemccand" created="Sun, 21 Jun 2009 11:08:18 +0100"  >&lt;p&gt;Uwe, with your patch, it looks like if I ask for eg doubles w/ parser=null, and then ask again w/ parser=FieldCache.DEFAULT_DOUBLE_PARSER, I get double entries stored?  Is there some way to take the auto-detected parser and use it (not null) in the cache key?&lt;/p&gt;</comment>
                    <comment id="12722334" author="thetaphi" created="Sun, 21 Jun 2009 11:23:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;Uwe, with your patch, it looks like if I ask for eg doubles w/ parser=null, and then ask again w/ parser=FieldCache.DEFAULT_DOUBLE_PARSER, I get double entries stored? Is there some way to take the auto-detected parser and use it (not null) in the cache key?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is correct, the cache key is different for NULL vs. explicit parser, because the result may be different (which is unlikely the case) but they are two different things. When you ask for an auto-cache (we should deprecate the AUTO-part in field cache, too! It is not used anymore with new sorting code, even when SortField.AUTO is enabled), you also get different cache keys!&lt;/p&gt;</comment>
                    <comment id="12722335" author="mikemccand" created="Sun, 21 Jun 2009 11:32:42 +0100"  >&lt;p&gt;But, with the new public exposure of the field cache parsers, this is a newly added trap?  You could accidentally consume 2X the RAM.  Since auto-detection of the parser simply means a specific parser was chosen, why can&apos;t we then cache using that chosen parser?  Then you would not risk 2X memory usage.  Or, maybe we should leave the parsers private to not have this risk.&lt;/p&gt;</comment>
                    <comment id="12722341" author="thetaphi" created="Sun, 21 Jun 2009 11:42:09 +0100"  >&lt;p&gt;Not sure! And it is a trap for the BYTE and SHORT caches, too!&lt;/p&gt;

&lt;p&gt;But for sure, the old, never used auto-cache should be deprecated, too!&lt;/p&gt;</comment>
                    <comment id="12722392" author="thetaphi" created="Sun, 21 Jun 2009 18:44:40 +0100"  >&lt;p&gt;Here a new patch:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;deprecated the AUTO cache parts&lt;/li&gt;
	&lt;li&gt;the test TestFieldCache tests the following algorithm, too&lt;/li&gt;
	&lt;li&gt;changed autodetection for triefields to work like the auto cache:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;in createValue, it is checked if parser==null, if this is so, the method calls the FieldCache.getInts() again, specifying each of the two possible parsers (for byte and short currently only one).&lt;/li&gt;
	&lt;li&gt;After this, the cache will then contain the same array reference for both key variants (&quot;finally used parser&quot; and &quot;null&quot;). Somebody coming later and asking for a specific parser array will get the already cached one, the same for later consumers asking with null parser.&lt;/li&gt;
	&lt;li&gt;To optimize the array allocation, it was delayed until the first value was successfully decoded. In case of an error, the array stays null and GC is happy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12722551" author="mikemccand" created="Mon, 22 Jun 2009 11:30:38 +0100"  >&lt;p&gt;The last patch looks great Uwe!  I think we&apos;re nearly done here:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I like how FieldComparator, and function/*FieldSource, are now&lt;br/&gt;
    simplified to longer have duplicated code for picking the default&lt;br/&gt;
    parser (and simply pass null instead).  Default selection is now&lt;br/&gt;
    single source.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Could you add the &quot;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This API is experimental and might&lt;br/&gt;
    change in incompatible ways in the next release.&quot; caveat to the&lt;br/&gt;
    javadocs?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you change this:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (parser == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getLongs(reader, field, DEFAULT_LONG_PARSER);
} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (NumberFormatException ne) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER);      
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;to this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (parser == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
  &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getLongs(reader, field, DEFAULT_LONG_PARSER);
  } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (NumberFormatException ne) {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER);      
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;?&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;I think we can&apos;t actually deprecate NumberTools until we can call&lt;br/&gt;
    FieldCache.getShorts/getBytes on a NumericField?  Ie, people&lt;br/&gt;
    relying on short/byte (to consume much less memory in FieldCache)&lt;br/&gt;
    cannot switch to numeric, and so must continue to zero-pad if they&lt;br/&gt;
    need to use RangeQuery/Filter?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You need a CHANGES entry.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12722558" author="thetaphi" created="Mon, 22 Jun 2009 11:55:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Could you add the &quot;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This API is experimental and might change in incompatible ways in the next release.&quot; caveat to the javadocs?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For the whole TrieAPI or only NumericUtils? If the first, I would do this with an general JavaDoc commit after this issue. If only NumericField, I could do it now.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you change this: &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, we had this the last time, too (I like my variant more, so I always automatically write it in that way)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think we can&apos;t actually deprecate NumberTools until we can call FieldCache.getShorts/getBytes on a NumericField? Ie, people relying on short/byte (to consume much less memory in FieldCache) cannot switch to numeric, and so must continue to zero-pad if they need to use RangeQuery/Filter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will open an issue because of this byte/short trie fields (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1710&quot; title=&quot;Add byte/short to NumericUtils, NumericField and NumericRangeQuery&quot;&gt;LUCENE-1710&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;NumberTools does not handle zero-padding, so it could stay deprecated. Numbers encoded with NumberTools cannot be natively sorted on at all (only using StringIndex) and can only handle longs.&lt;/p&gt;

&lt;p&gt;You may mean NumberUtils from Solr in contrib/spatial, but this class is not yet released and is only used for spatial.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You need a CHANGES entry. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Will come.&lt;/p&gt;</comment>
                    <comment id="12722577" author="mikemccand" created="Mon, 22 Jun 2009 13:34:49 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Could you add the &quot;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This API is experimental and might change in incompatible ways in the next release.&quot; caveat to the javadocs?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For the whole TrieAPI or only NumericUtils? If the first, I would do this with an general JavaDoc commit after this issue. If only NumericField, I could do it now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For the whole thing; I think an added NOTE at each class level&lt;br/&gt;
javadoc is what we need.  A separate javadoc issue is good, but&lt;br/&gt;
it needs to be done for 2.9.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Can you change this:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, we had this the last time, too (I like my variant more, so I always automatically write it in that way)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which &quot;last time&quot;?  Is there somewhere in the code base now where&lt;br/&gt;
we do this?&lt;/p&gt;

&lt;p&gt;We generally try (though, don&apos;t always succeed) to follow Sun&apos;s coding&lt;br/&gt;
guidelines (&lt;a href=&quot;http://java.sun.com/docs/codeconv/&quot; class=&quot;external-link&quot;&gt;http://java.sun.com/docs/codeconv/&lt;/a&gt;) except 2-space indent&lt;br/&gt;
not 4.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I think we can&apos;t actually deprecate NumberTools until we can call FieldCache.getShorts/getBytes on a NumericField? Ie, people relying on short/byte (to consume much less memory in FieldCache) cannot switch to numeric, and so must continue to zero-pad if they need to use RangeQuery/Filter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;NumberTools does not handle zero-padding, so it could stay deprecated. Numbers encoded with NumberTools cannot be natively sorted on at all (only using StringIndex) and can only handle longs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, I believe it does do 0 padding and handles negative numbers&lt;br/&gt;
correctly (NumberTools.longToString)?&lt;/p&gt;

&lt;p&gt;Ie, I can take a short now, call longToString, index with that, do&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;possibly inefficient&amp;#93;&lt;/span&gt; RangeQuery against it, and sort against it&lt;br/&gt;
using only 2 bytes per doc, today?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I will open an issue because of this byte/short trie fields (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1710&quot; title=&quot;Add byte/short to NumericUtils, NumericField and NumericRangeQuery&quot;&gt;LUCENE-1710&lt;/a&gt;)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK but since we&apos;ve marked it 3.1 (which I think is OK; though in&lt;br/&gt;
CHANGES lets document the limitation?), we should un-deprecate&lt;br/&gt;
NumberTools, now, and deprecate it again along with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1710&quot; title=&quot;Add byte/short to NumericUtils, NumericField and NumericRangeQuery&quot;&gt;LUCENE-1710&lt;/a&gt;?&lt;/p&gt;</comment>
                    <comment id="12722579" author="thetaphi" created="Mon, 22 Jun 2009 13:51:22 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Sure, we had this the last time, too (I like my variant more, so I always automatically write it in that way)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which &quot;last time&quot;?  Is there somewhere in the code base now where&lt;br/&gt;
we do this?&lt;/p&gt;

&lt;p&gt;We generally try (though, don&apos;t always succeed) to follow Sun&apos;s coding&lt;br/&gt;
guidelines (&lt;a href=&quot;http://java.sun.com/docs/codeconv/&quot; class=&quot;external-link&quot;&gt;http://java.sun.com/docs/codeconv/&lt;/a&gt;) except 2-space indent&lt;br/&gt;
not 4.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was not against the change. With &quot;last time&quot; I meant that some time ago you mentioned the same in a different patch from me. I will change it.&lt;/p&gt;

&lt;p&gt;My note was only, that I &quot;automatically&quot; create such code, because I for myself find its better readable. That was all &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;NumberTools does not handle zero-padding, so it could stay deprecated. Numbers encoded with NumberTools cannot be natively sorted on at all (only using StringIndex) and can only handle longs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, I believe it does do 0 padding and handles negative numbers&lt;br/&gt;
correctly (NumberTools.longToString)?&lt;/p&gt;

&lt;p&gt;Ie, I can take a short now, call longToString, index with that, do&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;possibly inefficient&amp;#93;&lt;/span&gt; RangeQuery against it, and sort against it&lt;br/&gt;
using only 2 bytes per doc, today?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You cannot do this with NumberTools. NumberTools uses an special radix 36 encoding (and not radix 10 like normal numbers). The encoding is just like NumericUtils not human-readable and so cannot be parsed with Number.toString(). To convert back, you need the method from the same class.&lt;/p&gt;

&lt;p&gt;Because of this you have two possilities: Write your own parser and pass it to SortField/FieldCache or sort using StringIndex (because it is sortable according to String.compareTo).&lt;/p&gt;

&lt;p&gt;So it can be deprecated.&lt;/p&gt;

&lt;p&gt;If sombody want to do encoding and parsing with FieldCache.getShorts() there is no way around a DecimalFormat with zero-padding and the problem with negative numbers.&lt;/p&gt;</comment>
                    <comment id="12722639" author="mikemccand" created="Mon, 22 Jun 2009 16:28:12 +0100"  >
&lt;blockquote&gt;&lt;p&gt;You cannot do this with NumberTools.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa! Sorry, you are right.  Nothing in FieldCache can handle decoding&lt;br/&gt;
this encoding into short/byte; so you&apos;d need something outside of&lt;br/&gt;
Lucene&apos;s core, today, to do that.&lt;/p&gt;

&lt;p&gt;Though it does allow you to do RangeQuery, with short/byte, and you&lt;br/&gt;
could sort as SortField.STRING, (quite hideously memory inefficient).&lt;/p&gt;

&lt;p&gt;So I now agree: we should deprecate NumberTools entirely, now.&lt;/p&gt;

&lt;p&gt;If people ask how to handle short/byte beforew we resolve &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1710&quot; title=&quot;Add byte/short to NumericUtils, NumericField and NumericRangeQuery&quot;&gt;LUCENE-1710&lt;/a&gt;,&lt;br/&gt;
the answer is to upgrade everything to int.  The resulting wasteful&lt;br/&gt;
int[] that&apos;d be in the FieldCache is not nearly as wasteful as the&lt;br/&gt;
String[] you&apos;d need to use to do sorting, today.  And you could always&lt;br/&gt;
make a custom parser using NumericUtils that downcasts to byte/short,&lt;br/&gt;
anyway, since the needed APIs are public.&lt;/p&gt;</comment>
                    <comment id="12722711" author="thetaphi" created="Mon, 22 Jun 2009 18:50:59 +0100"  >&lt;p&gt;Attached is a patch wil the latest changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Experimental-warning to all Numeric* classes&lt;/li&gt;
	&lt;li&gt;Formatting fixes&lt;/li&gt;
	&lt;li&gt;CHANGES.txt&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12722730" author="mikemccand" created="Mon, 22 Jun 2009 19:09:38 +0100"  >&lt;p&gt;Uwe, can we give a default (4?) for precisionStep, when creating a NumericField, NumericRangeFilter/Query?&lt;/p&gt;</comment>
                    <comment id="12722765" author="thetaphi" created="Mon, 22 Jun 2009 20:02:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;Uwe, can we give a default (4?) for precisionStep, when creating a NumericField, NumericRangeFilter/Query? If we find a good default, it can simplier applied in one issue (just some additional ctors and factories).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you open an issue? There are some problems with defining a good default. In my environment, 8 makes the best results, 4 is only little faster.&lt;br/&gt;
Problems are described in JavaDocs: smaller precisionStep -&amp;gt; more different precisions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;more seek operations and new TermEnums&lt;/li&gt;
	&lt;li&gt;but less terms&lt;br/&gt;
For my index with 8 is in good relation to each other, with 4 seeking gets costly and with 2, I see no difference, only a much larger index (600,000 docs on PANGAEA, 4 Mio doc index locally on Laptop with only trie numbers).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So I do not want to set a default with enough tests from different people/scenarios, and this comes when 2.9 is out and everybody tries out &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I will commit this patch in a day or two after applying &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1701&quot; title=&quot;Add NumericField, make plain text numeric parsers public in FieldCache, move trie parsers to FieldCache&quot;&gt;&lt;del&gt;LUCENE-1701&lt;/del&gt;&lt;/a&gt;-test-tag-special.patch to 2.4-test-branch.&lt;/p&gt;</comment>
                    <comment id="12722769" author="earwin" created="Mon, 22 Jun 2009 20:15:09 +0100"  >&lt;p&gt;Using 4 for int, 6 for long. Dates-as-longs look a bit sad on 8.&lt;/p&gt;

&lt;p&gt;Though, if you want really fast dates, chosing hour/day/month/year as precision steps is vastly superior, plus it also clicks well with user-selected ranges. Still, I dumped this approach for uniformity and clarity.&lt;/p&gt;</comment>
                    <comment id="12722774" author="thetaphi" created="Mon, 22 Jun 2009 20:33:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;Using 4 for int, 6 for long. Dates-as-longs look a bit sad on 8.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think 4 for ints is a good start, better as 4 for longs (which produces 16 different precision terms and upto 31 term enums &lt;span class=&quot;error&quot;&gt;&amp;#91;= precision changes&amp;#93;&lt;/span&gt; per range). 6 is a good idea, it brings a little bit more than 8 but does not produce too much precision changes. I tested that also with my 2 M numeric-only index here.&lt;/p&gt;

&lt;p&gt;Mike: As you see, the precision step is a good config approach, so an default is should be choosen carefully.&lt;br/&gt;
It may even be different for the same data type, when e.g. you have longs, but all longs in your index are only in a very limited range &amp;#8211; ok. You could use an int, too. But e.g. if you index dates as long and your dates are only between two years or something like that, 4 may still good. This is because on a smaller range, the algorith does not need to to up to the lowest precision.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Though, if you want really fast dates, chosing hour/day/month/year as precision steps is vastly superior, plus it also clicks well with user-selected ranges. Still, I dumped this approach for uniformity and clarity.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is clear. Because these precisions are fitting exact to users queries in case of dates (often users take full days when selecting the range).&lt;/p&gt;

&lt;p&gt;Nice to hear, that you use TrieRange? What is your index spec and measured query speeds (if it does not go too far into company internals)?&lt;/p&gt;</comment>
                    <comment id="12722775" author="earwin" created="Mon, 22 Jun 2009 20:34:14 +0100"  >&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; Design for today.&lt;br/&gt;
&amp;gt;&amp;gt; And spend two years deprecating and supporting today&apos;s designs after you get a better thing tomorrow. Back-compat Lucene-style and agile design aren&apos;t something that marries well.&lt;br/&gt;
&amp;gt;&amp;gt; donating something to Lucene means casting it in concrete.&lt;br/&gt;
&amp;gt; We can&apos;t let fear of back-compat prevent us from making progress.&lt;br/&gt;
My point was that strict back-compat prevents people from donating work which is not yet finalized. They either lose comfortable volatility of private code, or have to maintain two versions of it - private and Lucene.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; NRT seems to tread the same path, and I&apos;m not sure it&apos;s going to win that much turnaround time after newly-introduced per-segment collection.&lt;br/&gt;
&amp;gt; I agree, per-segment collection was the bulk of the gains needed for&lt;br/&gt;
&amp;gt; NRT. This was a big change and a huge step forward in simple reopen&lt;br/&gt;
&amp;gt; turnaround.&lt;br/&gt;
I vote it for the most frustrating (in terms of adopting your custom code) and most useful change of 2.9 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; But, not having to write &amp;amp; read deletes to disk, not commit (fsync)&lt;br/&gt;
&amp;gt; from writer in order to see those changes in reader should also give&lt;br/&gt;
&amp;gt; us decent gains. fsync is surprisingly and intermittently costly.&lt;br/&gt;
I&apos;m not sure this can&apos;t be achieved without messing with IR/W guts so much. Guys from LinkedIn that drive this feature (if i&apos;m not mistaken), they had a prior solution with separate indexes, one on disk, one in RAM. Per-segment collection adds superfast reopens and MultiReader that is way greater than MultiSearcher - you can finally do adequate fast searches across separate indexes. Do we still need to add complexity for minor performance gains?&lt;/p&gt;

&lt;p&gt;&amp;gt; And this integration lets us take it a step further with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
&amp;gt; where recently created segments can remain in RAM and be shared with&lt;br/&gt;
&amp;gt; the reader.&lt;br/&gt;
RAMDirectory?&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; Some time ago I finished a first version of IR plugins, and enjoy pretty low reopen times (field/facet/filter cache warmups included). (Yes, I&apos;m going to open an issue for plugins once they stabilize enough)&lt;br/&gt;
&amp;gt; I&apos;m confused: I thought that effort was to make SegmentReader&apos;s&lt;br/&gt;
&amp;gt; components fully pluggable? (Not to actually change what components&lt;br/&gt;
&amp;gt; SegmentReader is creating). EG does this modularization alter the&lt;br/&gt;
&amp;gt; approach to NRT? I thought they were orthogonal.&lt;br/&gt;
Yes, they are orthonogal. This was yet another praise to per-segment collection and an example of how this approach can be extended on your custom stuff (like filtercache).&lt;/p&gt;</comment>
                    <comment id="12722820" author="mikemccand" created="Mon, 22 Jun 2009 21:58:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;Using 4 for int, 6 for long. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Unfortunately we can&apos;t easily conditionalize the default by int vs long.  Ie use you NumericField like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
NumericField f = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, 4);
f.setFloatValue(15.50);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;&lt;p&gt;Mike: As you see, the precision step is a good config approach, so an default is should be choosen carefully.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed!  But, it need not be &quot;perfect&quot;.  Advanced users can test &amp;amp; iterate to find the best tradeoff for their particular field&apos;s value distribution.  For slow ranges now with RangeQuery (because of many unique terms), NumericRangeQuery will be a massive speedup with eg a default of 4.&lt;/p&gt;

&lt;p&gt;New users shouldn&apos;t have to understand what precisionStep means, or anything about &quot;what&apos;s under the hood&quot;, in order to use NumericField.  I should be able to simply:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NumericField(&lt;span class=&quot;code-quote&quot;&gt;&quot;price&quot;&lt;/span&gt;, 15.50);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Erring towards more terms (and faster searches) is fine, I think, because in a &quot;typical&quot; index the text fields with dwarf any small added disk space (hence my proposal of 4 as the default precisionStep).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you open an issue?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I&apos;ll open a new issue.&lt;/p&gt;</comment>
                    <comment id="12722829" author="mikemccand" created="Mon, 22 Jun 2009 22:10:01 +0100"  >&lt;p&gt;OK I opened spinoff issues &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1712&quot; title=&quot;Set default precisionStep for NumericField and NumericRangeFilter&quot;&gt;&lt;del&gt;LUCENE-1712&lt;/del&gt;&lt;/a&gt; (default for precisionStep) and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1713&quot; title=&quot;Rename RangeQuery -&amp;gt; TermRangeQuery&quot;&gt;&lt;del&gt;LUCENE-1713&lt;/del&gt;&lt;/a&gt; (rename RangeQuery -&amp;gt; TextRangeQuery, or something).&lt;/p&gt;</comment>
                    <comment id="12722862" author="mikemccand" created="Mon, 22 Jun 2009 23:14:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;My point was that strict back-compat prevents people from donating work which is not yet finalized. They either lose comfortable volatility of private code, or have to maintain two versions of it - private and Lucene.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good point, though if it&apos;s contrib and you&apos;re a contrib committer it lessens the challenge, but the challenge is still there....&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I vote it for the most frustrating (in terms of adopting your custom code) and most useful change of 2.9 &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No pain no gain?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do we still need to add complexity for minor performance gains?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The problem is I&apos;ve seen fsync take a ridiculous amount of time; it&apos;s not very predictable.  So I think we do need some way to not put fsync between the changes to the index and the ability to search those changes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; And this integration lets us take it a step further with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt;,&lt;br/&gt;
&amp;gt; where recently created segments can remain in RAM and be shared with&lt;br/&gt;
&amp;gt; the reader.&lt;/p&gt;

&lt;p&gt;RAMDirectory?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly; that&apos;s what &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt; is doing (flush new segments to a RAMDir).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This was yet another praise to per-segment collection and an example of how this approach can be extended on your custom stuff (like filtercache).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;</comment>
                    <comment id="12723136" author="thetaphi" created="Tue, 23 Jun 2009 16:43:21 +0100"  >&lt;p&gt;Final patch.&lt;/p&gt;</comment>
                    <comment id="12723137" author="thetaphi" created="Tue, 23 Jun 2009 16:43:50 +0100"  >&lt;p&gt;Commited backwards tests: revision 787714&lt;br/&gt;
Committed patch: revision 787723&lt;/p&gt;

&lt;p&gt;Thanks Mike!&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310010">
                <name>Incorporates</name>
                                <outwardlinks description="incorporates">
                            <issuelink>
            <issuekey id="12427737">LUCENE-1687</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12426825">LUCENE-1673</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12411367">SOLR-940</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12428038">LUCENE-1699</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12411545" name="LUCENE-1701.patch" size="114143" author="thetaphi" created="Tue, 23 Jun 2009 16:43:21 +0100" />
                    <attachment id="12411431" name="LUCENE-1701.patch" size="113936" author="thetaphi" created="Mon, 22 Jun 2009 18:50:59 +0100" />
                    <attachment id="12411344" name="LUCENE-1701.patch" size="108557" author="thetaphi" created="Sun, 21 Jun 2009 18:44:40 +0100" />
                    <attachment id="12411338" name="LUCENE-1701.patch" size="103374" author="thetaphi" created="Sun, 21 Jun 2009 10:49:21 +0100" />
                    <attachment id="12411336" name="LUCENE-1701.patch" size="102262" author="thetaphi" created="Sun, 21 Jun 2009 08:30:29 +0100" />
                    <attachment id="12411316" name="LUCENE-1701.patch" size="101441" author="thetaphi" created="Sat, 20 Jun 2009 18:48:45 +0100" />
                    <attachment id="12411313" name="LUCENE-1701.patch" size="100512" author="thetaphi" created="Sat, 20 Jun 2009 17:46:17 +0100" />
                    <attachment id="12411317" name="LUCENE-1701-test-tag-special.patch" size="1808" author="thetaphi" created="Sat, 20 Jun 2009 18:48:45 +0100" />
                    <attachment id="12411242" name="NumericField.java" size="4083" author="thetaphi" created="Fri, 19 Jun 2009 17:47:37 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>9.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 19 Jun 2009 13:59:57 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12057</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26025</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>