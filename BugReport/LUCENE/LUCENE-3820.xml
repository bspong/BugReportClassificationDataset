<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:00:51 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3820/LUCENE-3820.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3820] Wrong trailing index calculation in PatternReplaceCharFilter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3820</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Reimplementation of PatternReplaceCharFilter to pass randomized tests (used to throw exceptions previously). Simplified code, dropped boundary characters, full input buffered for pattern matching.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12543784">LUCENE-3820</key>
            <summary>Wrong trailing index calculation in PatternReplaceCharFilter</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="dweiss">Dawid Weiss</assignee>
                                <reporter username="dweiss">Dawid Weiss</reporter>
                        <labels>
                    </labels>
                <created>Thu, 23 Feb 2012 02:03:23 +0000</created>
                <updated>Fri, 10 May 2013 11:43:27 +0100</updated>
                    <resolved>Tue, 28 Feb 2012 23:13:56 +0000</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13214197" author="dweiss" created="Thu, 23 Feb 2012 02:05:05 +0000"  >&lt;p&gt;A patch with reimplementation of getReplaceBlock and a test case that is failing with AIOOB (apply test changes without modifying PatternReplaceCharFilter to get the error).&lt;/p&gt;</comment>
                    <comment id="13214203" author="rcmuir" created="Thu, 23 Feb 2012 02:13:25 +0000"  >&lt;p&gt;Unrelated to this change: we should be using StringBuilder here.&lt;/p&gt;</comment>
                    <comment id="13214225" author="rcmuir" created="Thu, 23 Feb 2012 02:34:08 +0000"  >&lt;p&gt;Here&apos;s a simple random test showing some existing bugs in the filter... &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;there are offsets problems as dawid notices...&lt;/li&gt;
	&lt;li&gt;blockbuffer should always oversize by 1 character, if a block ends on a high surrogate (rare) it should do one additional read() so it doesnt create invalid unicode&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13214235" author="rcmuir" created="Thu, 23 Feb 2012 02:41:05 +0000"  >&lt;p&gt;to fix dawid&apos;s problem we can probably modify this test only for ascii, i suspect the unicode &quot;problems&quot;&lt;br/&gt;
are going to be impossible to fix given java&apos;s regex library (i think it does not treat &quot;.&quot; as codepoint&lt;br/&gt;
but code unit). I&apos;ll take another stab at that just to tackle the offsets issue he is seeing.&lt;/p&gt;</comment>
                    <comment id="13214247" author="rcmuir" created="Thu, 23 Feb 2012 03:01:55 +0000"  >&lt;p&gt;updated patch, this tests only ascii (to avoid stupid problems in outdated regex support).&lt;/p&gt;

&lt;p&gt;But there are a lot of offset problems (perhaps this corresponds to the warning in the class&apos;s javadocs?), including things like offsets being corrected to negative numbers...&lt;/p&gt;</comment>
                    <comment id="13214412" author="dweiss" created="Thu, 23 Feb 2012 07:21:01 +0000"  >&lt;p&gt;Thanks for looking at this, Robert. I&apos;ll go back to this later today, but I can tell you right now that from my paper considerations negative indexes make logical sense in case of &quot;prepended&quot; characters. So:&lt;/p&gt;

&lt;p&gt;PATTERN: A&lt;br/&gt;
INPUT: ABCDEF&lt;br/&gt;
REPLACEMENT: XYZ&lt;br/&gt;
OUTPUT:XYZBCDEF&lt;/p&gt;

&lt;p&gt;then (in my patch) X and Y would have negative offsets. It&apos;s a matter of agreement I guess. Negative indexes are consistent with something like this:&lt;/p&gt;

&lt;p&gt;PATTERN: ^&lt;br/&gt;
INPUT: ABC&lt;br/&gt;
REPLACEMENT: XYZ&lt;br/&gt;
OUTPUT:XYZABC&lt;/p&gt;

&lt;p&gt;then all three characters (XYZ) have a negative index to indicate they&apos;re prepended. Thoughts?&lt;/p&gt;</comment>
                    <comment id="13214498" author="dweiss" created="Thu, 23 Feb 2012 09:28:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;Unrelated to this change: we should be using StringBuilder here.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;if you mean the pattern matching bit then Matcher simply doesn&apos;t accept a StringBuilder... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13214508" author="dweiss" created="Thu, 23 Feb 2012 09:43:16 +0000"  >&lt;p&gt;A simplifying patch that includes Robert&apos;s random tests (and passes).&lt;/p&gt;

&lt;p&gt;I&apos;ve made a deliberate decision to deprecate and not use block delimiters and block processing. If you think this is a backwards no-no then feel free to correct this patch... I think block processing may be worth dropping given the code clarity without it. &lt;/p&gt;</comment>
                    <comment id="13214554" author="rcmuir" created="Thu, 23 Feb 2012 11:22:36 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;ll go back to this later today, but I can tell you right now that from my paper considerations negative indexes make logical sense&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We cannot do this... this is the offset (character position in the reader). &lt;/p&gt;

&lt;p&gt;Offsets can never be negative.&lt;/p&gt;</comment>
                    <comment id="13214556" author="dweiss" created="Thu, 23 Feb 2012 11:26:34 +0000"  >&lt;p&gt;The patch I attached works around this by pushing negative offsets to zero. Works for me.&lt;/p&gt;</comment>
                    <comment id="13214606" author="rcmuir" created="Thu, 23 Feb 2012 12:55:01 +0000"  >&lt;p&gt;OK, after reviewing in detail...&lt;/p&gt;

&lt;p&gt;+1 I like the cleanup here! &lt;/p&gt;

&lt;p&gt;I don&apos;t have an opinion / don&apos;t know the use case behind block delimiters, but this is a &lt;br/&gt;
small, clean, elegant implementation that doesnt cause offsets problems (from my futzing&lt;br/&gt;
around there seemed to be at least 2 bugs, one at the beginning and one at the end?)&lt;/p&gt;
</comment>
                    <comment id="13214856" author="dweiss" created="Thu, 23 Feb 2012 17:06:47 +0000"  >&lt;p&gt;I&apos;ll put this on hold and commit in a few days if nobody has anything against. &lt;/p&gt;</comment>
                    <comment id="13217451" author="mikemccand" created="Mon, 27 Feb 2012 19:43:59 +0000"  >&lt;p&gt;I&apos;m seeing TestPatternReplaceCharFilter.testRandomData sometimes take a REALLY long time (longer than I can wait &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;

&lt;p&gt;The test is not hung (CPU is pegged).&lt;/p&gt;

&lt;p&gt;I don&apos;t have a seed (can we somehow tap into kill -QUIT so that in addition to the JRE printing stack traces for all threads, it also prints our seed?)... but here&apos;s the stack trace:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&quot;main&quot; prio=10 tid=0x00007fbc64008000 nid=0x4095 runnable [0x00007fbc69b32000]
   java.lang.Thread.State: RUNNABLE
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4304)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4311)
	at java.util.regex.Pattern$Prolog.match(Pattern.java:4251)
	at java.util.regex.Pattern$Start.match(Pattern.java:3055)
	at java.util.regex.Matcher.search(Matcher.java:1105)
	at java.util.regex.Matcher.find(Matcher.java:535)
	at org.apache.lucene.analysis.pattern.PatternReplaceCharFilter.processPattern(PatternReplaceCharFilter.java:100)
	at org.apache.lucene.analysis.pattern.PatternReplaceCharFilter.read(PatternReplaceCharFilter.java:80)
	at java.io.Reader.read(Reader.java:104)
	at org.apache.lucene.analysis.MockTokenizer.readCodePoint(MockTokenizer.java:138)
	at org.apache.lucene.analysis.MockTokenizer.incrementToken(MockTokenizer.java:105)
	at org.apache.lucene.analysis.BaseTokenStreamTestCase.checkRandomData(BaseTokenStreamTestCase.java:346)
	at org.apache.lucene.analysis.BaseTokenStreamTestCase.checkRandomData(BaseTokenStreamTestCase.java:304)
	at org.apache.lucene.analysis.BaseTokenStreamTestCase.checkRandomData(BaseTokenStreamTestCase.java:259)
	at org.apache.lucene.analysis.pattern.TestPatternReplaceCharFilter.testRandomStrings(TestPatternReplaceCharFilter.java:297)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)
	at org.apache.lucene.util.LuceneTestCase$SubclassSetupTeardownRule$1.evaluate(LuceneTestCase.java:707)
	at org.apache.lucene.util.LuceneTestCase$InternalSetupTeardownRule$1.evaluate(LuceneTestCase.java:606)
	at org.apache.lucene.util.LuceneTestCase$TestResultInterceptorRule$1.evaluate(LuceneTestCase.java:511)
	at org.apache.lucene.util.LuceneTestCase$RememberThreadRule$1.evaluate(LuceneTestCase.java:569)
	at org.junit.rules.RunRules.evaluate(RunRules.java:18)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
	at org.apache.lucene.util.LuceneTestCaseRunner.runChild(LuceneTestCaseRunner.java:165)
	at org.apache.lucene.util.LuceneTestCaseRunner.runChild(LuceneTestCaseRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:24)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:136)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:117)
	at org.junit.runner.JUnitCore.runMain(JUnitCore.java:98)
	at org.junit.runner.JUnitCore.runMainAndExit(JUnitCore.java:53)
	at org.junit.runner.JUnitCore.main(JUnitCore.java:45)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I guess the random regexp (&lt;tt&gt;_TestUtil.randomRegexpishString(random)&lt;/tt&gt;) is sometimes too evil...?&lt;/p&gt;</comment>
                    <comment id="13217452" author="mikemccand" created="Mon, 27 Feb 2012 19:44:52 +0000"  >&lt;p&gt;Reopening to somehow fix the too-evil regexp...&lt;/p&gt;</comment>
                    <comment id="13217485" author="dweiss" created="Mon, 27 Feb 2012 20:03:12 +0000"  >&lt;p&gt;That&apos;s Robert&apos;s evil piece of random pattern generation... I told him this would stress the pattern engine more than our code and this seems to be the case &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; The above seems like a heavy backtracking/ recursion pattern, something Russ Cox was writing about (&lt;a href=&quot;http://swtch.com/~rsc/regexp/regexp1.html&quot; class=&quot;external-link&quot;&gt;http://swtch.com/~rsc/regexp/regexp1.html&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;I&apos;d just add @Ignore to this test? Alternatively, I&apos;d make it absolute-time bound and simply terminate after, say, 3 seconds.&lt;/p&gt;</comment>
                    <comment id="13217546" author="dweiss" created="Mon, 27 Feb 2012 20:51:15 +0000"  >&lt;p&gt;I&apos;ve added a time limit of 2 seconds. Seems to do the trick for me.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;can we somehow tap into kill -QUIT so that in addition to the JRE printing stack traces for all threads, it also prints our seed?)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, put the seed in your test running thread&apos;s name. &lt;/p&gt;</comment>
                    <comment id="13217547" author="dweiss" created="Mon, 27 Feb 2012 20:51:45 +0000"  >&lt;p&gt;Mike, resolve if this fix works for you.&lt;/p&gt;</comment>
                    <comment id="13217716" author="mikemccand" created="Tue, 28 Feb 2012 00:07:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yes, put the seed in your test running thread&apos;s name.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm maybe LTC can somehow do this for us...?  EG maybe we make a utility method to launch a new thread... and it sets the name?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Mike, resolve if this fix works for you.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... I beasted w/ this change, but after 156 iterations it got a bad regexp again.&lt;/p&gt;

&lt;p&gt;Would be ashame to just @Ignore it though... can we somehow make the regexp generation less &quot;evil&quot;?&lt;/p&gt;</comment>
                    <comment id="13217991" author="dweiss" created="Tue, 28 Feb 2012 08:14:03 +0000"  >&lt;p&gt;I&apos;ve committed that thread-name-contains-seed thing. I&apos;ve also tried to reproduce the long pattern but it&apos;s been running on my machine for a few minutes in a tight loop and all of them end below one second. Can you try to reproduce it again? I&apos;m curious what&apos;s causing this. I&apos;ll add @Ignore once we know what the problem is.&lt;/p&gt;</comment>
                    <comment id="13218152" author="mikemccand" created="Tue, 28 Feb 2012 13:22:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ve committed that thread-name-contains-seed thing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Awesome!  Using this, I re-beasted and found this seed (was still going after 75 minutes when I killed it...):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;ant test -Dtestcase=TestPatternReplaceCharFilter -Dtestmethod=testRandomStrings -Dtests.seed=-27d641cb49b46a8e:-4b59e6886f1953b6:7d2fb14a457a628
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13218515" author="dweiss" created="Tue, 28 Feb 2012 19:27:11 +0000"  >&lt;p&gt;Yep, nice catch. That test case causes a beautiful exponential time pattern to be generated (I&apos;ve added it as an @Ignored test &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I limited the input size to 40 characters. With such input it should be possible to traverse the entire search space, even if it&apos;s exponential. I don&apos;t see a way to easily verify if a pattern is exponential or not (without resigning from certain types of patterns).&lt;/p&gt;</comment>
                    <comment id="13218680" author="mikemccand" created="Tue, 28 Feb 2012 23:13:57 +0000"  >&lt;p&gt;Thanks Dawid!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12515735" name="LUCENE-3820.patch" size="23837" author="dweiss" created="Thu, 23 Feb 2012 09:43:16 +0000" />
                    <attachment id="12515678" name="LUCENE-3820.patch" size="7411" author="dweiss" created="Thu, 23 Feb 2012 02:05:03 +0000" />
                    <attachment id="12515685" name="LUCENE-3820_test.patch" size="8885" author="rcmuir" created="Thu, 23 Feb 2012 03:01:55 +0000" />
                    <attachment id="12515682" name="LUCENE-3820_test.patch" size="6992" author="rcmuir" created="Thu, 23 Feb 2012 02:34:08 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 23 Feb 2012 02:13:25 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>229024</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23879</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>