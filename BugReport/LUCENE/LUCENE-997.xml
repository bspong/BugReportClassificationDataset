<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:34:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-997/LUCENE-997.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-997] Add search timeout support to Lucene</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-997</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This patch is based on Nutch-308. &lt;/p&gt;

&lt;p&gt;This patch adds support for a maximum search time limit. After this time is exceeded, the search thread is stopped, partial results (if any) are returned and the total number of results is estimated.&lt;/p&gt;

&lt;p&gt;This patch tries to minimize the overhead related to time-keeping by using a version of safe unsynchronized timer.&lt;/p&gt;

&lt;p&gt;This was also discussed in an e-mail thread.&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/search-timeout-tf3410206.html#a9501029&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/search-timeout-tf3410206.html#a9501029&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12378204">LUCENE-997</key>
            <summary>Add search timeout support to Lucene</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="doronc">Doron Cohen</assignee>
                                <reporter username="timmsc">Sean Timm</reporter>
                        <labels>
                    </labels>
                <created>Thu, 13 Sep 2007 22:04:21 +0100</created>
                <updated>Thu, 3 Mar 2011 06:03:21 +0000</updated>
                    <resolved>Tue, 12 Feb 2008 21:02:16 +0000</resolved>
                                                                    <due></due>
                    <votes>3</votes>
                        <watches>6</watches>
                                                    <comments>
                    <comment id="12527260" author="timmsc" created="Thu, 13 Sep 2007 22:09:00 +0100"  >&lt;p&gt;Patch against trunk revision 575451.&lt;/p&gt;</comment>
                    <comment id="12527263" author="timmsc" created="Thu, 13 Sep 2007 22:11:30 +0100"  >&lt;p&gt;Simple test case.  Run by passing in the index directory as an argument.&lt;/p&gt;</comment>
                    <comment id="12527264" author="timmsc" created="Thu, 13 Sep 2007 22:14:58 +0100"  >&lt;p&gt;Here are some additional details on the changes.&lt;/p&gt;

&lt;p&gt;New files:&lt;br/&gt;
TimeLimitedCollector.java&lt;/p&gt;

&lt;p&gt;    Extends HitCollector and detects timeouts resulting in a TimeLimitedCollector.TimeExceeded exception being thrown.&lt;/p&gt;

&lt;p&gt;TimerThread.java&lt;/p&gt;

&lt;p&gt;    TimerThread provides a pseudo-clock service to all searching threads, so that they can count elapsed time with less overhead than repeatedly calling System.currentTimeMillis.  A single thread should be created to be used for all searches.&lt;/p&gt;

&lt;p&gt;Modified Files:&lt;br/&gt;
Hits.java&lt;/p&gt;

&lt;p&gt;    Added partial result flag.&lt;/p&gt;

&lt;p&gt;IndexSearcher.java&lt;/p&gt;

&lt;p&gt;    Catches TimeLimitedCollector.TimeExceeded, sets partial results flag on TopDocs and estimates the total hit count (if we hadn&apos;t timed out partway through).  Returns TopDocs with partial results.&lt;/p&gt;

&lt;p&gt;Searcher.java&lt;/p&gt;

&lt;p&gt;    Added methods to set and get the timeout parameters.  This implementation decision has the limitation of only permitting a single timeout value per Searcher instance (of which there is usually only one).  However, this greatly minimizes the number of search methods that would need to be added.  In practice, I have not needed the functionality to change the timeout settings on a per query basis.&lt;/p&gt;

&lt;p&gt;TopFieldDocCollector.java&lt;/p&gt;

&lt;p&gt;    Uses TimeLimitedCollector functionality.&lt;/p&gt;

&lt;p&gt;TopDocCollector.java&lt;/p&gt;

&lt;p&gt;    Uses TimeLimitedCollector functionality and exposes it to child class TopFieldDocCollector.&lt;/p&gt;

&lt;p&gt;TopDocs.java&lt;/p&gt;

&lt;p&gt;    Added partial results flag.  Note, TopFieldDocs extends this class and inherits the new functionality.&lt;/p&gt;</comment>
                    <comment id="12527605" author="lucenebugs@danielnaber.de" created="Fri, 14 Sep 2007 19:55:44 +0100"  >&lt;p&gt;Thanks for the patch. I didn&apos;t have a very close look, just one small thing: it&apos;s probably no good idea to catch and ignore the InterruptedException. See &lt;a href=&quot;http://www-128.ibm.com/developerworks/java/library/j-jtp05236.html&quot; class=&quot;external-link&quot;&gt;http://www-128.ibm.com/developerworks/java/library/j-jtp05236.html&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12527666" author="hossman" created="Sat, 15 Sep 2007 01:41:20 +0100"  >&lt;p&gt;I&apos;m not entirely convinced it makes sense to modify these classes to include timeouts as core functionality ... would it make more sense to deal with this in subclasses of IndexSearcher/TopDocs/Hits ?&lt;/p&gt;</comment>
                    <comment id="12528170" author="timmsc" created="Mon, 17 Sep 2007 22:54:44 +0100"  >&lt;p&gt;&lt;a href=&quot;http://www-128.ibm.com/developerworks/java/library/j-jtp05236.html&quot; class=&quot;external-link&quot;&gt;http://www-128.ibm.com/developerworks/java/library/j-jtp05236.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TimerThread Now follows Brian Goetz&apos;s best practice for a noncancelable task that restores interrupted status before returning rather than ignoring the InterruptedException.&lt;/p&gt;</comment>
                    <comment id="12536326" author="timmsc" created="Fri, 19 Oct 2007 20:41:19 +0100"  >&lt;p&gt;Two issues are addressed in this latest patch:&lt;/p&gt;

&lt;p&gt;1) Timeout support was not added to: public TopFieldDocs search(Weight weight, Filter filter, final int nDocs, Sort sort)&lt;/p&gt;

&lt;p&gt;2) getCounter() in TimerThread was replaced by getMilliseconds()&lt;/p&gt;</comment>
                    <comment id="12537128" author="doronc" created="Tue, 23 Oct 2007 21:37:03 +0100"  >&lt;p&gt;I think this is a nice feature to have.&lt;/p&gt;

&lt;p&gt;But I am not sure about the propsed API - the application creates a TimerThread, starts it, and the timer thread is then passed to the searcher with setTimeOut(timer,ticks). Not so simple.&lt;/p&gt;

&lt;p&gt;I think my preference for the API and implementation would be in HitCllector.collect() - in other words, we consider this new feature as an advanced one, and so only allow applications to provide their &quot;timed&quot; hitCollector. The modified collect() would either throw a TimeoutException or return a timedOut indication. If this is a (subclass of) RunTimeException (thuogh I am not crazy about this alternative) then there&apos;s no API change (a plus) but we need to verify that the code below propagates the RuntimeException gracefully and closes all the streams and everything (which I believe it does with all last careful changes by Mike and Michael). If RuntimeEXception is not acceptable, then this is an API change (a minus) and also many (simple) changes will be required in scorers (callers to collect). &lt;/p&gt;

&lt;p&gt;The application&apos;s timedColletor will have all the logic in that collector for both announcing and detecting the timeout. Next we can add a TimedCollector for the benefit of applications, and last, consider adding search() methods with timeOut, but I doubt that last step.&lt;/p&gt;</comment>
                    <comment id="12537153" author="yseeley@gmail.com" created="Tue, 23 Oct 2007 22:43:05 +0100"  >&lt;p&gt;&amp;gt; allow applications to provide their &quot;timed&quot; hitCollector&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12538142" author="goksron" created="Sat, 27 Oct 2007 00:44:07 +0100"  >
&lt;p&gt;I just requested a more fancy feature in the Solr Jira. My apologies, I did not think to search the Lucene Jira.&lt;/p&gt;


&lt;p&gt;1) timeout: stop searching after N milliseconds and return results using only those hits already found&lt;br/&gt;
2) hit limit: stop searching after N milliseconds and return results using only those hits already found&lt;br/&gt;
3) ram limit: estimate the amount of ram used so far and stop searching at a given amount&lt;/p&gt;

&lt;p&gt;Here is the complete request:&lt;/p&gt;</comment>
                    <comment id="12538144" author="goksron" created="Sat, 27 Oct 2007 00:49:58 +0100"  >&lt;p&gt;I stumbled above; I do not yet know Jira &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  The Solr code is &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-392&quot; title=&quot;Way to control search time, hits, and memory usage&quot;&gt;&lt;del&gt;SOLR-392&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This request is inspired by a public search engine with millions of records. &lt;br/&gt;
 There are three different aspects mentioned above that can cause a query to &quot;go rogue&quot;: timing out, finding too many records to give a truly useable result, and using up too much memory. The point is that if a search is going to find 14 million hits, Google does not go and tally them. It stops quickly and estimates how many might remain. I would like to have similar control. &lt;/p&gt;

&lt;p&gt;The HitCollector implementation mentioned above would allow all three of these control options. If they could be pipelined together we could use any or all of them.&lt;/p&gt;</comment>
                    <comment id="12542675" author="timmsc" created="Thu, 15 Nov 2007 05:44:43 +0000"  >&lt;p&gt;&amp;gt; I think my preference for the API and implementation would be in HitCollector.collect()&lt;/p&gt;

&lt;p&gt;This would be simpler, but I don&apos;t see how it would be possible to estimate the total number of results and return partial results in that case.  I think that is an important feature.&lt;/p&gt;

&lt;p&gt;If the concern is complexity for the application, perhaps it is possible to hide the TimerThread altogether.  The TimerThread could be created and started via a searcher setTimeOut(tick, numTicks) method.&lt;/p&gt;

&lt;p&gt;To simplify it further, ticks could be fixed at a reasonable number, e.g., 100 ms, and a timeout in milliseconds could be passed in: setTimeout(milliseconds).&lt;/p&gt;</comment>
                    <comment id="12552143" author="doronc" created="Sat, 15 Dec 2007 21:57:12 +0000"  >&lt;blockquote&gt;
&lt;p&gt;TimerThread provides a pseudo-clock service to all searching threads, &lt;br/&gt;
so that they can count elapsed time with less overhead than repeatedly &lt;br/&gt;
calling System.currentTimeMillis. A single thread should be created to &lt;br/&gt;
be used for all searches.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Is this really faster than calling System.currentTimeMillis()?&lt;br/&gt;
I quick searched but found no references supporting this. &lt;br/&gt;
This one says the opposite:&lt;br/&gt;
  &lt;a href=&quot;http://www.devx.com/Java/Article/28685&quot; class=&quot;external-link&quot;&gt;http://www.devx.com/Java/Article/28685&lt;/a&gt;&lt;br/&gt;
Because if this is not the case, you could do without the TimerThread?&lt;/p&gt;</comment>
                    <comment id="12552147" author="mikemccand" created="Sat, 15 Dec 2007 22:30:51 +0000"  >&lt;p&gt;I think one benefit of a dedicated timer thread is not being affected&lt;br/&gt;
by clock shift on the machine.  System.currentTimeMillis() is not&lt;br/&gt;
guaranteed to be monotonic.  System.nanoTime() (1.5 only!) tries&lt;br/&gt;
to be (I think), but it&apos;s still not guaranteed.&lt;/p&gt;

&lt;p&gt;Without a monotonic clock, if the clock shifts forward then it could&lt;br/&gt;
timeout in-flight queries (way) too early.&lt;/p&gt;

&lt;p&gt;But: what happens when TimerThread overflows the int (a&lt;br/&gt;
2*1024*1024*1024)?  Is it the caller&apos;s job to deal with the&lt;br/&gt;
wraparound?&lt;/p&gt;</comment>
                    <comment id="12552170" author="doronc" created="Sun, 16 Dec 2007 06:47:40 +0000"  >&lt;p&gt;Nice, I didn&apos;t think of this.&lt;/p&gt;

&lt;p&gt;So with this understanding the timer thread  (with long vs int) &lt;br/&gt;
makes sense while in Java 1.4, then in 1.5 System.nanoTime&lt;br/&gt;
will do.&lt;/p&gt;

&lt;p&gt;The suggested patch relied on collect() being called, and&lt;br/&gt;
so if a scorer takes long going over all the posting lists but&lt;br/&gt;
fails to find a single match after the time passed, the search &lt;br/&gt;
operation will not be stopped. I guess it is a fair assumption &lt;br/&gt;
that this would be very rare... &lt;br/&gt;
(so would be a system clock shift...  : - ) )&lt;/p&gt;

&lt;p&gt;Also important to understand is what happens with IO &lt;br/&gt;
resources once search is aborted with timeout exception. &lt;br/&gt;
Current patch does not close the underlying streams (I &lt;br/&gt;
mean IndexInput clones). I think this is ok, because &lt;br/&gt;
once the search is aborted and there are no more references &lt;br/&gt;
to the weights&amp;amp;scorers, the IndexInput clones would be &lt;br/&gt;
eventually garbage collected. Others?&lt;/p&gt;</comment>
                    <comment id="12552174" author="nyh" created="Sun, 16 Dec 2007 07:56:17 +0000"  >&lt;p&gt;I&apos;d like to add my 2 cents on this issue.&lt;/p&gt;

&lt;p&gt;The more I use Lucene in various ways, the more I&apos;m getting convinced that the &quot;Hits&quot; API should be de-emphasized (if not outright depracated), and users should be encouraged to use the HitCollector API (search() taking a hitcollector, TopDocCollector, and so on) - especially for advanced usage.&lt;/p&gt;

&lt;p&gt;I believe that your TimeLimitedCollector is an interesting idea. However, there is simply no justification to change TopDocCollector, TopFieldDocCollector, Topdocs, Hits and Searcher. There&apos;s a MUCH simpler, and in my opinion cleaner, approach: Just make TimeLimitedCollector be a front-end for another collector (for example, TopDocCollector) which will be passed to TimeLimitedCollector&apos;s constructor. For every document that is presented to TimeLimitedCollector&apos;s collect(), it would call the inner collector&apos;s collect().&lt;/p&gt;

&lt;p&gt;This way, without any changes to Lucene&apos;s core APIs, and just the addition of a new class, you can add the new functionality that you wanted. This, I think, is the beauty of the HitCollector interface over the &quot;monolithic&quot; Hits approach, and I think we should encourage this way of thinking instead of adding more and more features to Hits.&lt;/p&gt;</comment>
                    <comment id="12552295" author="yseeley@gmail.com" created="Sun, 16 Dec 2007 22:09:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;make TimeLimitedCollector be a front-end for another collector (for example, TopDocCollector) which will be passed to TimeLimitedCollector&apos;s constructor.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12552322" author="doronc" created="Mon, 17 Dec 2007 04:53:26 +0000"  >&lt;p&gt;Sean, can you revise your patch to follow the suggestions above?&lt;/p&gt;

&lt;p&gt;That is, create a TimeLimitedCollector that takes and Collector parameter &lt;br/&gt;
for its constructor. You should be able to hide all the TimerThread &lt;br/&gt;
details (use long instead of int) within the implementation of this &lt;br/&gt;
new collector class, and so when moving to Java5  the TimeThread &lt;br/&gt;
can be replaced by nanoTime.&lt;/p&gt;

&lt;p&gt;Then we can add to either core search or under contrib.&lt;/p&gt;

&lt;p&gt;On a related point - I am not happy with programming by a &lt;br/&gt;
runtimException - if others agree that this should become &lt;br/&gt;
a standard functionality, how about modifying Collector.collect()&lt;br/&gt;
to return a stop-or-continue indicator?&lt;/p&gt;</comment>
                    <comment id="12553586" author="timmsc" created="Thu, 20 Dec 2007 05:39:49 +0000"  >&lt;p&gt;Thanks for all of the feedback.  I&apos;ll take another stab at this.  I&apos;m on vacation now and probably won&apos;t have time until I get back.  It&apos;ll probably be early Jan. before I have a new patch ready.&lt;/p&gt;</comment>
                    <comment id="12555190" author="tcn" created="Tue, 1 Jan 2008 12:22:09 +0000"  >&lt;p&gt;IMHO it definitely should be part of the core. Being able to control the runtime of queries/your ressources is crucial for every live system and I really wonder this it has taken so long to address this.&lt;/p&gt;

&lt;p&gt;Otherwise I totally agree with Navdav: that Hits thingie is nice and fine for simple full-text queries but as soon as things become somewhat more complex you don&apos;t get around writing your own HitCollector (and do stuff like Facets).&lt;/p&gt;

&lt;p&gt;I also strongly agree that the timeout HC should be implemented as an decorator (what&apos;s been called &quot;front-end&quot; here), I just quickly wrote an example and attached it (no, I&apos;m not happy throwing an runtime exception either):&lt;/p&gt;

&lt;p&gt;MyHitCollector hc = new MyHitCollector();&lt;br/&gt;
s.search(q, null, HitCollectorTimeoutDecorator.decorate( hc, 10 ) );&lt;/p&gt;

&lt;p&gt;And finally, why return partial results? I don&apos;t think that this is reasonable.&lt;/p&gt;

&lt;p&gt;BTW I&apos;m not sure whether volatile in the timer thread is really working reliably in 1.4...&lt;/p&gt;</comment>
                    <comment id="12555191" author="tcn" created="Tue, 1 Jan 2008 12:23:28 +0000"  >&lt;p&gt;Example of the timeout HitCollector implemented as an decorator.&lt;/p&gt;</comment>
                    <comment id="12555192" author="tcn" created="Tue, 1 Jan 2008 12:24:05 +0000"  >&lt;p&gt;Example HitCollector to be decorated by HitCollectorTimeoutDecorator.&lt;/p&gt;</comment>
                    <comment id="12555203" author="paul.elschot@xs4all.nl" created="Tue, 1 Jan 2008 15:00:54 +0000"  >&lt;p&gt;By using only a HitCollector it cannot be guaranteed that searches will not take too long. The reason is that there are searches that take a long time but do not collect any docs.&lt;/p&gt;

&lt;p&gt;For example consider the case where every even doc has term A and every odd doc has term B, and the query requires both A and B. This is going to take an amount of time that is linear in the size of the index but no document will be collected.&lt;/p&gt;

&lt;p&gt;This means that every conjunction (boolean queries with more than one required clause, phrase queries, span near queries) will need to check for timeout. Also a HitCollector with a timeout facility will need a way&lt;br/&gt;
to be informed of a timeout when no document is collected.&lt;/p&gt;</comment>
                    <comment id="12555205" author="tcn" created="Tue, 1 Jan 2008 15:32:15 +0000"  >&lt;p&gt;True, unfortunately, but still better than nothing (-&amp;gt;current situation). This approach isn&apos;t very precise in matters of timing either. Also, throwing a RuntimeException feels more like a hack than well thought out code...&lt;/p&gt;

&lt;p&gt;I don&apos;t know Lucene&apos;s code good enough in order to estimate whether it&apos;s possible to build a real timeout machanism at all/without changing the API/rewriting a lot of code but it&apos;s incredibly important to be able to cancel running queries. You don&apos;t want to servers under high load suffering from lucene queries running up to multiple &lt;b&gt;minutes&lt;/b&gt; at the same time consuming quite a lot of memory. And it makes no sense either because nobody is waiting so long for results...&lt;/p&gt;</comment>
                    <comment id="12562642" author="timmsc" created="Fri, 25 Jan 2008 20:02:08 +0000"  >&lt;p&gt;Created a patch using Timo&apos;s HitCollectorTimeoutDecorator.  This patch just has a few mostly minor changes.  The biggest changes are that it uses a long instead of an int for the counter in TimerThread and the TimerThread interval is fixed at 10 ms.  It also throws a TimeLimitedCollector.TimeExceeded exception on a timeout.&lt;/p&gt;</comment>
                    <comment id="12562646" author="timmsc" created="Fri, 25 Jan 2008 20:11:45 +0000"  >&lt;p&gt;Updated bad patch with good copy.&lt;/p&gt;

&lt;p&gt;Created a patch using Timo&apos;s HitCollectorTimeoutDecorator. This patch just has a few mostly minor changes. The biggest changes are that it uses a long instead of an int for the counter in TimerThread and the TimerThread interval is fixed at 10 ms. It also throws a TimeLimitedCollector.TimeExceeded exception on a timeout.&lt;/p&gt;</comment>
                    <comment id="12562647" author="timmsc" created="Fri, 25 Jan 2008 20:12:52 +0000"  >&lt;p&gt;Updated to work with latest patch.&lt;/p&gt;</comment>
                    <comment id="12562654" author="timmsc" created="Fri, 25 Jan 2008 20:34:58 +0000"  >&lt;p&gt;The TimerThreadTest illustrates the accuracy of the TimerThread under load.  On my 2GHz Xeon 4 CPU dual core RH AS 4 Linux box, it get a 20% difference between the TimerThread implementation and System.currentTimeMillis() and is independent of load.&lt;/p&gt;

&lt;p&gt;java TimerThreadTest 8&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
10010   12020   &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;With my single core single CPU Windows XP laptop I see a 20% difference at load, but when adding additional threads, I see an increasing difference.&lt;/p&gt;

&lt;p&gt;java TimerThreadTest 0&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
10000   11819 &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;java TimerThreadTest 2&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
10040   18890 &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;
</comment>
                    <comment id="12562765" author="ab" created="Fri, 25 Jan 2008 23:35:25 +0000"  >&lt;p&gt;I believe this version of the patch won&apos;t work properly unless you add synchronization - writes to long values are non-atomic (Java Language Specification 17.7, as the comment says), that&apos;s why Nutch uses an int there. Perhaps using AtomicLong would be an answer, if you really need a long value.&lt;/p&gt;</comment>
                    <comment id="12562838" author="hibou" created="Sat, 26 Jan 2008 09:52:14 +0000"  >&lt;p&gt;AtomicLong is a Java 1.5 feature, so it doesn&apos;t fit either.&lt;/p&gt;</comment>
                    <comment id="12562845" author="paul.elschot@xs4all.nl" created="Sat, 26 Jan 2008 11:10:54 +0000"  >&lt;p&gt;After &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-584&quot; title=&quot;Decouple Filter from BitSet&quot;&gt;&lt;del&gt;LUCENE-584&lt;/del&gt;&lt;/a&gt; more work will be needed to get all conjunctions in the same place, but it is a starting point.&lt;/p&gt;

&lt;p&gt;Once all conjunctions are in the same place, it would make sense to add a timeout there.&lt;/p&gt;</comment>
                    <comment id="12562869" author="timmsc" created="Sat, 26 Jan 2008 14:59:13 +0000"  >&lt;p&gt;Andrzej--&lt;/p&gt;

&lt;p&gt;JLS 17.7 Non-atomic Treatment of double and long&lt;/p&gt;

&lt;p&gt;&quot;Writes and reads of volatile long and double values are always atomic.&quot;&lt;/p&gt;</comment>
                    <comment id="12562936" author="ab" created="Sat, 26 Jan 2008 23:23:44 +0000"  >&lt;p&gt;Indeed, thanks for the correction - I forgot about the special treatment of volatile values.&lt;/p&gt;</comment>
                    <comment id="12562952" author="timmsc" created="Sun, 27 Jan 2008 03:59:10 +0000"  >&lt;p&gt;You are right that I forgot to change the comment when I changed it from an int to a long though.  &quot;* updates to 32-bit-sized variables are atomic&quot; is a pretty pointless comment now. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12562964" author="tcn" created="Sun, 27 Jan 2008 08:08:52 +0000"  >&lt;p&gt;@Sean: &quot;The biggest changes are that it uses a long instead of an int for the counter in TimerThread&quot; - didn&apos;t I use a volatile long already? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I hope this will become part of the next release. IMHO this is Priority Major or above...&lt;/p&gt;</comment>
                    <comment id="12562972" author="paul.elschot@xs4all.nl" created="Sun, 27 Jan 2008 08:54:20 +0000"  >&lt;p&gt;In the timeout.patch, instead of this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;time += resolution;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I&apos;d rather have this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;time = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;because all of the wait() methods can become unreliable, especially at high loads.&lt;/p&gt;

&lt;p&gt;With (or without) this change, 100 msecs or even 200 msecs could be used as the&lt;br/&gt;
update frequency instead of the current 10 msecs.&lt;/p&gt;

&lt;p&gt;By computing the time out moment up front, one subtraction can be saved at each document collection. Then only TIMER_THREAD.getMilliseconds() method is needed at document collection time, and the getElapsedMilliseconds() method is superfluous.&lt;/p&gt;</comment>
                    <comment id="12563155" author="timmsc" created="Mon, 28 Jan 2008 14:32:18 +0000"  >&lt;p&gt;@Timo: &quot;didn&apos;t I use a volatile long already?&quot;  Indeed.  I guess that wasn&apos;t a very big change then. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12563624" author="timmsc" created="Tue, 29 Jan 2008 19:18:55 +0000"  >&lt;p&gt;This is a minor update to timeout.patch which fixes the comment about updates to 32-bit-sized variables being atomic and instead talks about volatile longs, as pointed out by Andrzej.  It also computes the time out moment up front to save a subtraction on each document collection as suggested by Paul.&lt;/p&gt;</comment>
                    <comment id="12563632" author="timmsc" created="Tue, 29 Jan 2008 19:38:49 +0000"  >&lt;p&gt;I could go either way on the System.currentTimeMillis() versus a TimerThread issue.  I agree nanoTime is the correct implementation when using 1.5.&lt;/p&gt;

&lt;p&gt;It doesn&apos;t seem like on Linux running ntp it matters much either way.  NTP tries to perform smoothing and makes clock changes slowly over a longer period of time when it can rather than have an abrupt change, but YMMV if your system is having clock issues.  On a really overloaded Windows box, the TimerThread implementation will not behave well as demonstrated above.  I can&apos;t speak to any other platforms.&lt;/p&gt;</comment>
                    <comment id="12563698" author="paul.elschot@xs4all.nl" created="Tue, 29 Jan 2008 22:28:10 +0000"  >&lt;p&gt;The idea of System.currentTimeMillis() is to guard against misbehaviour of the java wait() method and against unexpected delays because of thread scheduling during the jump back for the loop around the wait() call.&lt;br/&gt;
One way to reduce such misbehaviour under heavy load is by increasing the scheduling priority of the timing thread, but I don&apos;t think that is necessary.&lt;/p&gt;

&lt;p&gt;Also System.currentTimeMillis() is obviously correct, whereas timeout += resolution is never more than an assumption about correct wait() behaviour.&lt;/p&gt;

&lt;p&gt;Clock changes by NTP are normally so slow that they don&apos;t really matter for query time outs.&lt;/p&gt;</comment>
                    <comment id="12564126" author="doronc" created="Wed, 30 Jan 2008 18:48:37 +0000"  >&lt;p&gt;Sean, can you add a Junit test to timeout.patch?&lt;/p&gt;

&lt;p&gt;I think such test should check (1) search correctness (regardless of timeout), (2) expected timeout behavior, and (3) some sanity test with multiple searching threads. This can also serve as an example for using this new collector.&lt;/p&gt;

&lt;p&gt;Cheers.&lt;br/&gt;
Doron&lt;/p&gt;
</comment>
                    <comment id="12565720" author="tcn" created="Tue, 5 Feb 2008 12:09:34 +0000"  >&lt;p&gt;IIRC I did time=System.currentTimeMillis() first but was surprised how slow this method actally is.&lt;/p&gt;</comment>
                    <comment id="12565809" author="paul.elschot@xs4all.nl" created="Tue, 5 Feb 2008 16:57:03 +0000"  >&lt;p&gt;Would that still be a problem with a 200ms resolution?&lt;/p&gt;</comment>
                    <comment id="12565835" author="timmsc" created="Tue, 5 Feb 2008 17:47:03 +0000"  >&lt;p&gt;Patch adds JUnit test cases as suggested by Doron.&lt;/p&gt;</comment>
                    <comment id="12565838" author="tcn" created="Tue, 5 Feb 2008 18:03:25 +0000"  >&lt;p&gt;200ms? No, probably not. I don&apos;t recall what resolution I used in my test but actually the timeout check took more time than the Lucene query...&lt;/p&gt;</comment>
                    <comment id="12565906" author="timmsc" created="Tue, 5 Feb 2008 22:11:33 +0000"  >&lt;p&gt;Paul,&lt;br/&gt;
I think that if we were to use System.currentTimeMillis(), we would eschew the TimerThread as Doron suggests in his Dec. 15 comment.  I haven&apos;t seen any performance issues with System.currentTimeMillis().&lt;/p&gt;

&lt;p&gt;As far as 200ms, I think that is too large of a default resolution (and with the current implementation it is not configurable).  With a 200 ms resolution, a query with a 1 second time allowed could timeout in 800 ms, and one with a time allowed of 500 ms could timeout in 300 ms.  I think it is much worse to timeout a query early than to timeout late.&lt;/p&gt;</comment>
                    <comment id="12566116" author="doronc" created="Wed, 6 Feb 2008 12:43:44 +0000"  >&lt;p&gt;Sean thanks for adding the test.&lt;/p&gt;

&lt;p&gt;In the attached I tightened the check of allowed elapsed time until timeout.&lt;br/&gt;
Also added info in the exception, and added ability to modify the resolution - default is 20ms (was 5ms).&lt;br/&gt;
Please let me know what you think. &lt;/p&gt;

&lt;p&gt;As for System.currentTimeMillis() vs. Timer thread - IMHO Mike&apos;s comment on &apos;system clock changes&apos; makes the timer thread favorable.&lt;/p&gt;

&lt;p&gt;I checked this with up to 10,000 threads and with that number the test sometimes fails because it is quite tight on the max elapsed time required comparing to the timeout, so I don&apos;t see this is a problem. In the attached N_THREADS = 50 and this number of threads always passes for me.&lt;/p&gt;

&lt;p&gt;If there are no more major concerns I think this is now ready to go in, question is where to - under core o.a.l.search or under contrib (query or misc). &lt;br/&gt;
Others?&lt;/p&gt;</comment>
                    <comment id="12566171" author="timmsc" created="Wed, 6 Feb 2008 16:02:25 +0000"  >&lt;p&gt;Doron, your comment for setResolution(long) says &quot;The default timer resolution is 50 milliseconds&quot;, however, the default is actually 20 ms (public static final int DEFAULT_RESOLUTION = 20&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.  Other than that, everything looks great.&lt;/p&gt;</comment>
                    <comment id="12566175" author="doronc" created="Wed, 6 Feb 2008 16:10:24 +0000"  >&lt;p&gt;Oh wrote comment that was before I decided to change the default... &lt;br/&gt;
Thanks for catching this.&lt;/p&gt;</comment>
                    <comment id="12566179" author="doronc" created="Wed, 6 Feb 2008 16:16:41 +0000"  >&lt;p&gt;Attached patch corrects default resolution comment.&lt;/p&gt;</comment>
                    <comment id="12568280" author="timmsc" created="Tue, 12 Feb 2008 18:48:06 +0000"  >&lt;p&gt;&quot;If there are no more major concerns I think this is now ready to go in, question is where to - under core o.a.l.search or under contrib (query or misc).&quot;&lt;/p&gt;

&lt;p&gt;My preference would be for core o.a.l.search.&lt;/p&gt;</comment>
                    <comment id="12568286" author="tcn" created="Tue, 12 Feb 2008 18:53:52 +0000"  >&lt;p&gt;I agree, core.&lt;/p&gt;</comment>
                    <comment id="12568292" author="yseeley@gmail.com" created="Tue, 12 Feb 2008 18:57:26 +0000"  >&lt;p&gt;&amp;gt; My preference would be for core o.a.l.search.&lt;br/&gt;
+1&lt;/p&gt;</comment>
                    <comment id="12568312" author="doronc" created="Tue, 12 Feb 2008 21:02:15 +0000"  >&lt;p&gt;Committed (under core o.a.l.search).&lt;br/&gt;
Thanks Sean!&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12493610">LUCENE-2822</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12446742">LUCENE-2237</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12372376" name="HitCollectorTimeoutDecorator.java" size="1427" author="tcn" created="Tue, 1 Jan 2008 12:23:27 +0000" />
                    <attachment id="12374081" name="LuceneTimeoutTest.java" size="1615" author="timmsc" created="Fri, 25 Jan 2008 20:12:52 +0000" />
                    <attachment id="12365769" name="LuceneTimeoutTest.java" size="1649" author="timmsc" created="Thu, 13 Sep 2007 22:11:30 +0100" />
                    <attachment id="12372377" name="MyHitCollector.java" size="322" author="tcn" created="Tue, 1 Jan 2008 12:24:05 +0000" />
                    <attachment id="12374880" name="timeout.patch" size="15923" author="doronc" created="Wed, 6 Feb 2008 16:21:01 +0000" />
                    <attachment id="12374879" name="timeout.patch" size="15923" author="doronc" created="Wed, 6 Feb 2008 16:16:41 +0000" />
                    <attachment id="12374858" name="timeout.patch" size="15922" author="doronc" created="Wed, 6 Feb 2008 12:43:44 +0000" />
                    <attachment id="12374801" name="timeout.patch" size="10342" author="timmsc" created="Tue, 5 Feb 2008 17:47:03 +0000" />
                    <attachment id="12374283" name="timeout.patch" size="4559" author="timmsc" created="Tue, 29 Jan 2008 19:18:55 +0000" />
                    <attachment id="12374080" name="timeout.patch" size="4807" author="timmsc" created="Fri, 25 Jan 2008 20:11:45 +0000" />
                    <attachment id="12368042" name="timeout.patch" size="15630" author="timmsc" created="Fri, 19 Oct 2007 20:41:19 +0100" />
                    <attachment id="12366044" name="timeout.patch" size="14829" author="timmsc" created="Mon, 17 Sep 2007 22:54:44 +0100" />
                    <attachment id="12374083" name="TimerThreadTest.java" size="4815" author="timmsc" created="Fri, 25 Jan 2008 20:34:58 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 14 Sep 2007 18:55:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12747</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26732</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>