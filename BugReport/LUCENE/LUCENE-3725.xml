<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:08:07 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3725/LUCENE-3725.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3725] Add optional packing to FST building</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3725</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The FSTs produced by Builder can be further shrunk if you are willing&lt;br/&gt;
to spend highish transient RAM to do so... our Builder today tries&lt;br/&gt;
hard not to use much RAM (and has options to tweak down the RAM usage,&lt;br/&gt;
in exchange for somewhat lager FST), even when building immense FSTs.&lt;/p&gt;

&lt;p&gt;But for apps that can afford highish transient RAM to get a smaller&lt;br/&gt;
net FST, I think we should offer packing.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12539935">LUCENE-3725</key>
            <summary>Add optional packing to FST building</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Thu, 26 Jan 2012 17:38:20 +0000</created>
                <updated>Fri, 10 May 2013 11:44:59 +0100</updated>
                    <resolved>Mon, 30 Jan 2012 00:15:05 +0000</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/FSTs</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13194013" author="mikemccand" created="Thu, 26 Jan 2012 17:40:20 +0000"  >&lt;p&gt;Initial patch.... it has tons of nocommits but I think it&apos;s basically&lt;br/&gt;
working correctly.&lt;/p&gt;

&lt;p&gt;The packing is fairly simplistic now, but we can improve it with time&lt;br/&gt;
(I know Dawid has done all sorts of cool things!): it chooses the top&lt;br/&gt;
N nodes (sorted by incoming arc count) and saves them dereferenced so&lt;br/&gt;
that nodes w/ high in-count get a &quot;low&quot; address.  It also saves the&lt;br/&gt;
pointer as delta vs current position, if that would take fewer bytes.&lt;br/&gt;
The bytes are then in &quot;forward&quot; order.&lt;/p&gt;

&lt;p&gt;The size savings varies by FST... eg, for the all-Wikipedia-terms FSA&lt;br/&gt;
(no outputs) it reduces byte size by 21%.  If I map to ords (FST) then&lt;br/&gt;
it&apos;s only 13% (I don&apos;t do anything to pack the outputs now, so the&lt;br/&gt;
bytes required for them are unchanged).&lt;/p&gt;

&lt;p&gt;While the resulting FST is smaller, there is some hit to lookup (~8%&lt;br/&gt;
for the Wikipedia ord FST), because we have to deref some nodes.&lt;/p&gt;

&lt;p&gt;I only turned packing on for one thing: the Kuromoji FST (shrank by&lt;br/&gt;
14%, 272 KB).&lt;/p&gt;</comment>
                    <comment id="13194938" author="mikemccand" created="Fri, 27 Jan 2012 17:34:50 +0000"  >&lt;p&gt;New patch with all nocommits removed.  I also optimized Util.get and&lt;br/&gt;
FST.findTargetArc a bit.  I turned off packing for Kuromoji, since the&lt;br/&gt;
JAR actually got larger (despite FST getting smaller)... strange.&lt;/p&gt;

&lt;p&gt;I think it&apos;s ready!&lt;/p&gt;</comment>
                    <comment id="13195108" author="thetaphi" created="Fri, 27 Jan 2012 21:21:12 +0000"  >&lt;p&gt;Mike: This his somehow opposite to the last comment:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I only turned packing on for one thing: the Kuromoji FST (shrank by 14%, 272 KB).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;vs.:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I turned off packing for Kuromoji, since the JAR actually got larger (despite FST getting smaller)... strange.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What&apos;s going on? Does this mean the FST and the TokenInfoDict$fst.dat file was smaller, but the resulting JAR file bigger - can be a &lt;del&gt;gzip&lt;/del&gt; &lt;em&gt;inflate&lt;/em&gt; compression problem? I can only repeat Simon: &lt;a href=&quot;https://www.destroyallsoftware.com/talks/wat&quot; class=&quot;external-link&quot;&gt;https://www.destroyallsoftware.com/talks/wat&lt;/a&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;As you wanted to enable this because of Kumoroji and now don&apos;t use it at all, is there any use-case in Lucene using the compaction?&lt;/p&gt;

&lt;p&gt;I am just confused!&lt;/p&gt;

&lt;p&gt;P.S.: Does this change FST file format again?&lt;/p&gt;</comment>
                    <comment id="13195116" author="dweiss" created="Fri, 27 Jan 2012 21:42:00 +0000"  >&lt;p&gt;A smaller automaton may result in a larger JAR. A smaller automaton will usually have a denser representation and larger entropy. I&apos;ve observed a similar phenomenon when I was working on automata compression for morfologik &amp;#8211; the ZIP file didn&apos;t grow there but it remained pretty much constant as the automaton was (progressively) made smaller and smaller.&lt;/p&gt;</comment>
                    <comment id="13195146" author="mikemccand" created="Fri, 27 Jan 2012 22:13:59 +0000"  >&lt;p&gt;That&apos;s exactly right &amp;#8211; the FST got smaller, but harder for zip to compress, so the JAR got bigger.&lt;/p&gt;

&lt;p&gt;I haven&apos;t turned it on anywhere in Lucene yet... I think it need to be an explicit choice since it requires extra RAM after building.&lt;/p&gt;</comment>
                    <comment id="13195149" author="mikemccand" created="Fri, 27 Jan 2012 22:16:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;P.S.: Does this change FST file format again?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh sorry forgot to answer: yes!&lt;/p&gt;</comment>
                    <comment id="13195162" author="thetaphi" created="Fri, 27 Jan 2012 22:29:14 +0000"  >&lt;p&gt;Thanks @ Dawid and Mike. I expected something like that, but when I read the issue, this was just funny! Thanks for clarification, it seems that there was background information (maybe only discussed in IRC) missing.&lt;/p&gt;

&lt;p&gt;About the Kumoroji: In my opinion, the JAR size is not the major thing. The reason why Robert and me was compacting structures was to a) reduce SVN checkout size (this should improve by packing) b) reduce memory footprint of the Analyzer (and that is also improvement). As the FST is only build once during rebuilding the binary FST from the dict and not at runtime, should we not package for memory efficiency?&lt;/p&gt;</comment>
                    <comment id="13195169" author="rcmuir" created="Fri, 27 Jan 2012 22:35:48 +0000"  >&lt;p&gt;Well it would be good to test kuromoji performance too before cutting over.&lt;/p&gt;

&lt;p&gt;if the performance is not impacted, I tend to agree with Uwe that decreasing memory usage is a good thing, &lt;br/&gt;
even if the jar is slightly larger (how much?), especially in this case as it costs no code complexity to the analyzer.&lt;/p&gt;</comment>
                    <comment id="13195268" author="mikemccand" created="Sat, 28 Jan 2012 00:16:59 +0000"  >&lt;p&gt;OK, I agree... I&apos;ll run perf tests of Kuromoji and post back...&lt;/p&gt;

&lt;p&gt;I&apos;ll re-check the JAR size impact; I think it was only a bit larger.&lt;/p&gt;</comment>
                    <comment id="13195490" author="mikemccand" created="Sat, 28 Jan 2012 11:21:41 +0000"  >&lt;p&gt;OK I turned packing back on for Kuromoji&apos;s TokenInfoDict... this&lt;br/&gt;
reduces size from 1954846 to 1498215 bytes (23% smaller = 445.9 KB).&lt;/p&gt;

&lt;p&gt;And.... now JAR is a bit smaller: 4533833 vs 4570053 bytes (~35&lt;br/&gt;
KB).  What changed was... I tweaked the params to pack (there are 2&lt;br/&gt;
int params) and got better packing than before.&lt;/p&gt;

&lt;p&gt;I wrote a simple perf test (Perf.java attached)... and as far as I can&lt;br/&gt;
tell the perf change is within hotspot noise... with trunk I get this:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1366 msec; 688.1405563689605 tokens/msec
1006 msec; 934.3936381709741 tokens/msec
1020 msec; 921.5686274509804 tokens/msec
938 msec; 1002.1321961620469 tokens/msec
937 msec; 1003.2017075773746 tokens/msec
942 msec; 997.8768577494692 tokens/msec
938 msec; 1002.1321961620469 tokens/msec
940 msec; 1000.0 tokens/msec
939 msec; 1001.0649627263045 tokens/msec
939 msec; 1001.0649627263045 tokens/msec
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And with the packed FST I get this:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1366 msec; 688.1405563689605 tokens/msec
1003 msec; 937.1884346959123 tokens/msec
1014 msec; 927.0216962524655 tokens/msec
934 msec; 1006.423982869379 tokens/msec
935 msec; 1005.3475935828877 tokens/msec
936 msec; 1004.2735042735043 tokens/msec
935 msec; 1005.3475935828877 tokens/msec
938 msec; 1002.1321961620469 tokens/msec
936 msec; 1004.2735042735043 tokens/msec
935 msec; 1005.3475935828877 tokens/msec
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But (annoyingly, as usual!) the results can differ quite a bit&lt;br/&gt;
depending on how hotspot flips coins on startup...&lt;/p&gt;</comment>
                    <comment id="13195492" author="thetaphi" created="Sat, 28 Jan 2012 11:46:44 +0000"  >&lt;p&gt;+1 to enable packing!&lt;/p&gt;</comment>
                    <comment id="13195494" author="thetaphi" created="Sat, 28 Jan 2012 12:03:12 +0000"  >&lt;p&gt;About that one:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// TODO: could require caller to pass in the
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// FSTReader... since a tokenStream is thread &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// anyway...
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; fst.findTargetArc(ch, follow, arc, fst.getBytesReader(0));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The problem is that the TokenInfoFST is a singleton, right? I am not sure that the caller should pass that in, it makes it too complicated. The change a few lines before is fine (getting the reader before loop execution), but a class thats used by multiple threads should not reuse across method calls.&lt;/p&gt;</comment>
                    <comment id="13195513" author="mikemccand" created="Sat, 28 Jan 2012 13:20:10 +0000"  >&lt;p&gt;Right, but eg Viterbi is thread private instance right?  So, eg, Viterbi could hold an FST.BytesReader that it passes into TokenInfoFST.findTargetArc... really TokenInfoFST is just a &quot;thin wrapper&quot; around an FST.&lt;/p&gt;</comment>
                    <comment id="13195534" author="thetaphi" created="Sat, 28 Jan 2012 13:40:48 +0000"  >&lt;p&gt;Ok, should be easy to implement. And its an internal class, so its not risky. We should just not make public APIs that way.&lt;/p&gt;</comment>
                    <comment id="13195588" author="mikemccand" created="Sat, 28 Jan 2012 18:11:12 +0000"  >&lt;p&gt;OK I added the FST.BytesReader to TokenInfoFST.findTargetArc (matching the FST API itself)... and discovered Viterbi isn&apos;t thread private (the instance is shared across threads)... so I just pull and reuse the reader in Viterbi.build.&lt;/p&gt;</comment>
                    <comment id="13195602" author="thetaphi" created="Sat, 28 Jan 2012 19:04:08 +0000"  >&lt;p&gt;Yes, I had the same problem at another place in Viterbi, too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; It&apos;s not easy to understand. In my case I wanted to reuse a scratch IntsRef for the targetMap retrieval, but that failed horrible &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13195914" author="rcmuir" created="Mon, 30 Jan 2012 02:22:38 +0000"  >&lt;p&gt;Just some numbers with another (CJK) fst I have been playing with, this one uses BYTE2 + &quot;SingleByteOutput&quot;&lt;br/&gt;
Before:&lt;br/&gt;
  Finished: 326915 words, 77222 nodes, 358677 arcs, 2617255 bytes... &lt;br/&gt;
  Zipped: 1812629 bytes&lt;br/&gt;
Packed:&lt;br/&gt;
  Finished: 326915 words, 77222 nodes, 358677 arcs, 2027763 bytes...&lt;br/&gt;
  Zipped: 1735486 bytes&lt;/p&gt;</comment>
                    <comment id="13195987" author="dweiss" created="Mon, 30 Jan 2012 08:30:28 +0000"  >&lt;p&gt;I had the time to look at the patch, finally. Yes, this is pretty much the top-n nodes reordering that I did, albeit without any optimization of how many n to take (the hardcoded magic constants should probably be justified somehow? Or replaced by a default in FST somewhere?). Deciding how many nodes to reorder is I think hard &amp;#8211; I failed to provide any sensible fast heuristic for that and I simply do a simulated annealing to find a local optimum.&lt;/p&gt;

&lt;p&gt;One thing I was wondering is why you decided to integrate the packer with the fst &amp;#8211; wouldn&apos;t it be cleaner to separate packing from construction? Granted, this requires a double pass over the fst nodes and more intermediate memory but it wouldn&apos;t add any more complexity to the builder which is already, ehm, a bit complex &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. You can compare this design in Morfologik:&lt;/p&gt;

&lt;p&gt;Builder:&lt;br/&gt;
&lt;a href=&quot;http://morfologik.svn.sourceforge.net/viewvc/morfologik/morfologik-stemming/trunk/morfologik-fsa/src/main/java/morfologik/fsa/FSABuilder.java?revision=343&amp;amp;view=markup&quot; class=&quot;external-link&quot;&gt;http://morfologik.svn.sourceforge.net/viewvc/morfologik/morfologik-stemming/trunk/morfologik-fsa/src/main/java/morfologik/fsa/FSABuilder.java?revision=343&amp;amp;view=markup&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Serialization (optimized or not, takes ant FSA on input) (method #linearize):&lt;br/&gt;
&lt;a href=&quot;http://morfologik.svn.sourceforge.net/viewvc/morfologik/morfologik-stemming/trunk/morfologik-fsa/src/main/java/morfologik/fsa/CFSA2Serializer.java?revision=343&amp;amp;view=markup&quot; class=&quot;external-link&quot;&gt;http://morfologik.svn.sourceforge.net/viewvc/morfologik/morfologik-stemming/trunk/morfologik-fsa/src/main/java/morfologik/fsa/CFSA2Serializer.java?revision=343&amp;amp;view=markup&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I any way, the patch looks good to me.&lt;/p&gt;</comment>
                    <comment id="13196042" author="mikemccand" created="Mon, 30 Jan 2012 10:44:31 +0000"  >&lt;p&gt;Thanks Dawid.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes, this is pretty much the top-n nodes reordering that I did, albeit without any optimization of how many n to take (the hardcoded magic constants should probably be justified somehow? Or replaced by a default in FST somewhere?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;Deciding how many nodes to reorder is I think hard &#8211; I failed to provide any sensible fast heuristic for that and I simply do a simulated annealing to find a local optimum.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah the algo is simplistic now... and it does force caller to pick the params (though minInCountDeref=3 and maxDerefNodes=Inf are probably pretty good)... we can and should make it more sophisticated over time.  We have at least one spare bit to still use in the arc flags &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One thing I was wondering is why you decided to integrate the packer with the fst &#8211; wouldn&apos;t it be cleaner to separate packing from construction? Granted, this requires a double pass over the fst nodes and more intermediate memory but it wouldn&apos;t add any more complexity to the builder which is already, ehm, a bit complex . You can compare this design in Morfologik:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... it&apos;s tricky.  First, I decided to change node targets to ords so that pack could use an array to (relatively!) efficiently hold node data, eg inCount, newAddress, etc.  That required making the first pass FST &quot;modal&quot; (deref&apos;d or not).  If we didn&apos;t do this then the packer would have to use even less RAM efficient data structures (eg Map&amp;lt;Int,X&amp;gt;) I think?&lt;/p&gt;

&lt;p&gt;Second, the format written by the packer is tightly coupled with the FST reading, ie there are sizable differences when reading packed vs unpacked FST.&lt;/p&gt;

&lt;p&gt;But I agree it&apos;d be cleaner if we could move packing out (eg Util.pack), and more strongly decouple packing from FST format...&lt;/p&gt;

&lt;p&gt;One thing I&apos;d really like to somehow do is create different classes for FST writing vs reading, and different classes for each format.  We now have write-ord, write-non-ord, read-packed, read-unpacked (and even the two readers have 3 different modes depending on INPUT_TYPE).&lt;/p&gt;
</comment>
                    <comment id="13196055" author="dweiss" created="Mon, 30 Jan 2012 11:20:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;If we didn&apos;t do this then the packer would have to use even less RAM efficient data structures (eg Map&amp;lt;Int,X&amp;gt;) I think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, this is exactly what I used (although I used a primitive-backed hash maps from HPPC), but the overhead will be there, sure.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Second, the format written by the packer is tightly coupled with the FST reading, ie there are sizable differences when reading packed vs unpacked FST. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right. I have a different design in which the FSA is an abstract superclass and the implementation provides methods to walk the edges/ nodes. The writers simply walk that structure when serializing. Reading is delegated to a reader that can understand a particular format (and then provide a traversal implementation over raw bytes).&lt;/p&gt;

&lt;p&gt;I do have major simplifications over Lucene&apos;s version so this wouldn&apos;t be easy to do in Lucene&apos;s case without sacrificing performance.&lt;/p&gt;


</comment>
                </comments>
                    <attachments>
                    <attachment id="12512306" name="LUCENE-3725.patch" size="124516" author="mikemccand" created="Sat, 28 Jan 2012 11:21:41 +0000" />
                    <attachment id="12512197" name="LUCENE-3725.patch" size="123579" author="mikemccand" created="Fri, 27 Jan 2012 17:34:50 +0000" />
                    <attachment id="12512013" name="LUCENE-3725.patch" size="109693" author="mikemccand" created="Thu, 26 Jan 2012 17:40:20 +0000" />
                    <attachment id="12512307" name="Perf.java" size="1850" author="mikemccand" created="Sat, 28 Jan 2012 11:22:09 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 27 Jan 2012 21:21:12 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>225439</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23973</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>