<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:34:54 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2779/LUCENE-2779.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2779] Use ConcurrentHashMap in RAMDirectory</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2779</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;RAMDirectory synchronizes on its instance in many places to protect access to map of RAMFiles, in addition to updating the sizeInBytes member. In many places the sync is done for &apos;read&apos; purposes, while only in few places we need &apos;write&apos; access. This looks like a perfect use case for ConcurrentHashMap&lt;/p&gt;

&lt;p&gt;Also, syncing around sizeInBytes is unnecessary IMO, since it&apos;s an AtomicLong ...&lt;/p&gt;

&lt;p&gt;I&apos;ll post a patch shortly.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12480932">LUCENE-2779</key>
            <summary>Use ConcurrentHashMap in RAMDirectory</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="shaie">Shai Erera</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Thu, 25 Nov 2010 17:28:40 +0000</created>
                <updated>Wed, 30 Mar 2011 16:50:08 +0100</updated>
                    <resolved>Wed, 1 Dec 2010 15:06:28 +0000</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12935812" author="shaie" created="Thu, 25 Nov 2010 17:43:23 +0000"  >&lt;p&gt;Perhaps we can eliminate synchronization entirely by using ConcurrentHashMap - I&apos;ll check that too.&lt;/p&gt;</comment>
                    <comment id="12935813" author="earwin" created="Thu, 25 Nov 2010 17:49:54 +0000"  >&lt;p&gt;Using RWLock is needless.&lt;br/&gt;
synchronized performs pretty nice on modern JVMs&lt;br/&gt;
to at least some get contention on RAMDir you need to index+reopen gazillion times a second - not a likely scenario. Usual searching doesn&apos;t hit any of these locks&lt;br/&gt;
that&apos;s premature optimization, imo&lt;/p&gt;</comment>
                    <comment id="12935816" author="earwin" created="Thu, 25 Nov 2010 17:53:47 +0000"  >&lt;p&gt;In fact, uncontended synchronized block might perform faster than RWLock.&lt;/p&gt;</comment>
                    <comment id="12964500" author="shaie" created="Sun, 28 Nov 2010 06:10:57 +0000"  >&lt;p&gt;In my app, I need to server ~50 qps on a single JVM. And that JVM is dedicated entirely for reading the index (so the &apos;WriteLock&apos; will in fact never be required. I don&apos;t think this will be a huge performance gain, but as one smart guy once said on the mailing list, if we keep adding 1 to 1, eventually it adds up to a big gain.&lt;/p&gt;

&lt;p&gt;So I do think RWLock is in place. Also, I think CocurrentHashMap nearly perfectly matches here, except for the listAll() case where I still need to figure out if something will go wrong in case the map is modified in the middle of iteration.&lt;/p&gt;</comment>
                    <comment id="12964511" author="earwin" created="Sun, 28 Nov 2010 08:10:43 +0000"  >&lt;p&gt;If you don&apos;t write, you don&apos;t care about locking in RAMDir at all. Your reader opens files once, and then never ever does it again.&lt;br/&gt;
Believe me, this is so pointless.&lt;/p&gt;</comment>
                    <comment id="12964512" author="earwin" created="Sun, 28 Nov 2010 08:19:40 +0000"  >&lt;p&gt;I mean, even if aquiring locks costed you one second each, you&apos;re not going to notice that, as in your case it is a startup-only cost.&lt;/p&gt;

&lt;p&gt;Look at this Directory impl I used for a while - &lt;a href=&quot;https://gist.github.com/715617&quot; class=&quot;external-link&quot;&gt;https://gist.github.com/715617&lt;/a&gt; - it uses synchronizedMap() over HashMap.&lt;br/&gt;
I had around 100qps with it on 4/8-way boxes AND pretty frequent updates.&lt;br/&gt;
I benchmarked a switch to RWLock and it yielded zero benefits.&lt;/p&gt;</comment>
                    <comment id="12964514" author="simonw" created="Sun, 28 Nov 2010 08:46:55 +0000"  >&lt;p&gt;Shai, I actually think Earwin is right with his claim that this is unneeded / pointless really. Performance on modern JVMs is very good for both RWLock and synchronized blocks and to make a big difference heavy contention is needed anyway. I would not expect any difference if you are on a Java 6 JVM at all even if you&apos;d have heavy contention. I have looked into this too a while ago and came to the same conclusion as earwin, there seem to be no real gain in refactoring this to use RWLocks instead fo sync blocks. &lt;/p&gt;</comment>
                    <comment id="12964515" author="earwin" created="Sun, 28 Nov 2010 08:53:19 +0000"  >&lt;p&gt;My primary point was that you&apos;re not going to have contention in that place at all. Take these 100queries/s, turn them into 100reopens+commits/s, multiply by ten, and then &lt;em&gt;maybe&lt;/em&gt; you start noticing &lt;em&gt;something&lt;/em&gt;.&lt;/p&gt;</comment>
                    <comment id="12964516" author="shaie" created="Sun, 28 Nov 2010 09:16:21 +0000"  >&lt;p&gt;I&apos;ve changed RAMDir to use ConcurrentHashMap and everything works (still need to run contrib and Solr tests) so far, w/o any synchronization (neither synchronize nor RWLock). While I don&apos;t expect any major perf gains from this, I think it simplifies the code, a bit. I&apos;ll post a patch shortly.&lt;/p&gt;</comment>
                    <comment id="12964521" author="shaie" created="Sun, 28 Nov 2010 09:47:48 +0000"  >&lt;p&gt;Patch replaces HashMap w/ ConcurrentHashMap and removes synchronized blocks. All tests pass.&lt;/p&gt;</comment>
                    <comment id="12964543" author="shaie" created="Sun, 28 Nov 2010 12:43:11 +0000"  >&lt;p&gt;Changed title and description to better match the issue&apos;s topic.&lt;/p&gt;</comment>
                    <comment id="12964556" author="earwin" created="Sun, 28 Nov 2010 14:11:15 +0000"  >&lt;p&gt;I&apos;m happy with CHM.&lt;br/&gt;
The only thing bothering me is RAMDir.listAll() method. It feels broken both in your directory and the one I posted.&lt;/p&gt;</comment>
                    <comment id="12964565" author="yseeley@gmail.com" created="Sun, 28 Nov 2010 15:55:38 +0000"  >&lt;p&gt;The generic problem with optimizing something is the risk of introducing bugs (so hopefully we&apos;re optimizing where it counts).&lt;/p&gt;

&lt;p&gt;At a quick glance, I see:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;a race in listAll() (as earwin indicated) that can cause an AIOB exception&lt;/li&gt;
	&lt;li&gt;a race in createOutput that can lead to an incorrect directory size (multiple threads can subtract the size of the same file being overwritten).  This probably isn&apos;t an issue with how Lucene uses RAMDirectory.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Changing how concurrency works is rarely easy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12964570" author="shaie" created="Sun, 28 Nov 2010 16:39:09 +0000"  >&lt;p&gt;I checked CHM iterators and they are safe w.r.t the map being modified after the iterator was obtained. It&apos;s easily testable: I added 3 items to CHM and called keySet.iterator(). I then called next() once, removed an item, called next() again and added an item. The changes were no visible to the iterator and it returned 3 items only (those that I added first). So I think we&apos;re safe on that.&lt;/p&gt;

&lt;p&gt;About remove I&apos;ll have to look in the code (not near the comp now) - but I had a feeling that it is safe too, b/c the file is first removed, which is a blocking &apos;write&apos; operation and only if it isn&apos;t null then the AtomicLong is updated. But I&apos;ll Check the code again, and maybe even add a concurrent test case.&lt;/p&gt;

&lt;p&gt;Thanks for the review. If in the end this change will smell bad, I&apos;ll close the issue - introducing concurrency bugs is the last thing we need &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="12964575" author="yseeley@gmail.com" created="Sun, 28 Nov 2010 17:08:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;I checked CHM iterators and they are safe w.r.t the map being modified after the iterator was obtained.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, but that wasn&apos;t the problem.  The iterator for ketSet &quot;guarantees to traverse elements as they existed upon construction of the iterator&quot;.&lt;br/&gt;
The real problem is that the String[] is created based on the size of the keySet, and then later, an iterator is created over the keySet.  If an addition to the set is done between those two events, the iterator will traverse more elements than there is room for - hence the AIOB exception.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About remove I&apos;ll have to look in the code (not near the comp now) - but I had a feeling that it is safe too, b/c the file is first removed,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The createOutput issue is that get() was used (not remove) so multiple threads could overwrite the same file and all of them subtract the size.&lt;/p&gt;</comment>
                    <comment id="12964576" author="yseeley@gmail.com" created="Sun, 28 Nov 2010 17:21:02 +0000"  >&lt;p&gt;Anyway, you should be able to replace all the code in listAll with&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[])fileMap.keySet().toArray();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The toArray() code of collection is smart and can handle the number of elements changing.&lt;/p&gt;

&lt;p&gt;And for createOutput, replacing get() with remove() should be sufficient.&lt;/p&gt;</comment>
                    <comment id="12964626" author="shaie" created="Mon, 29 Nov 2010 04:27:23 +0000"  >&lt;p&gt;Fixed createOutput and listAll as Yonik suggested. Thanks Yonik - it looks safer now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="12964773" author="shaie" created="Mon, 29 Nov 2010 15:20:07 +0000"  >&lt;p&gt;Committed revision 1040138 (trunk).&lt;br/&gt;
Committed revision 1040145 (3x).&lt;/p&gt;</comment>
                    <comment id="12964789" author="yseeley@gmail.com" created="Mon, 29 Nov 2010 16:04:53 +0000"  >&lt;p&gt;Note: there is an important change of semantics to listAll() - it can now &quot;lie&quot;.&lt;br/&gt;
Previously, it always gave an accurate listing of files as they existed at some point in time.  Now, you can get back a list of files that never really existed together at any point in time (i.e. the lie).&lt;/p&gt;

&lt;p&gt;I&apos;m OK with these new semantics because we have the same limitation already on FSDirectory.  This issue manifested in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2585&quot; title=&quot;DirectoryReader.isCurrent might fail to see the segments file during concurrent index changes&quot;&gt;LUCENE-2585&lt;/a&gt;, so we should keep in mind that we could now also see this with RAMDirectory.&lt;/p&gt;

&lt;p&gt;Here&apos;s a test program that demonstrates the issue by having a single writer adding 5,-5 to a map before removing the old 4,-4, etc.  At any point in time, there will always be a pair of numbers.  The single reader looks for this and spits out an error if not found.&lt;/p&gt;

&lt;p&gt;output from my box:&lt;br/&gt;
iterations=1000000 errors=4120 minLen=0 maxLen=10&lt;/p&gt;</comment>
                    <comment id="12964882" author="shaie" created="Mon, 29 Nov 2010 19:07:21 +0000"  >&lt;p&gt;I think we can still avoid this if we clone the keySet(). Since listAll I&apos;d not a frequently called method, and since I believe RAMDirs do not hold hundreds of files, I believe It won&apos;t be expensive. What do you think?&lt;/p&gt;</comment>
                    <comment id="12964920" author="earwin" created="Mon, 29 Nov 2010 20:23:12 +0000"  >&lt;p&gt;I don&apos;t believe cloning the keySet() will make it more &quot;snapshotty&quot;. There&apos;s no way to get a completely consistent snapshot of some concurrent datastructure without locking it completely, or using a variant of copy-on-write approach.&lt;/p&gt;</comment>
                    <comment id="12964968" author="thetaphi" created="Mon, 29 Nov 2010 22:09:55 +0000"  >&lt;p&gt;This commit broke backwards compatibility in 3.x.&lt;/p&gt;

&lt;p&gt;Please revert 3.x, we are no longer backwards compatible, because we changed type of a &lt;b&gt;protected&lt;/b&gt; field!&lt;/p&gt;

&lt;p&gt;(and: is it so complicated to do &lt;b&gt;ant test-backwards&lt;/b&gt; before committing such a change?)&lt;/p&gt;</comment>
                    <comment id="12964971" author="thetaphi" created="Mon, 29 Nov 2010 22:10:44 +0000"  >&lt;p&gt;If we really want to break backwards compatibility, here would be the fix for 3.x backwards branch.&lt;/p&gt;</comment>
                    <comment id="12964978" author="thetaphi" created="Mon, 29 Nov 2010 22:25:57 +0000"  >&lt;p&gt;Reverted 3.x commit in revision: 1040320&lt;/p&gt;

&lt;p&gt;(this change not even had a CHANGES.txt entry!) Please try to resolve this in a correct way!&lt;/p&gt;</comment>
                    <comment id="12964982" author="earwin" created="Mon, 29 Nov 2010 22:27:12 +0000"  >&lt;p&gt;Maybe we should commit it to 4.0 only? Doesn&apos;t look like a really important patch, that just &lt;em&gt;has&lt;/em&gt; to be backported.&lt;/p&gt;</comment>
                    <comment id="12964987" author="thetaphi" created="Mon, 29 Nov 2010 22:30:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Maybe we should commit it to 4.0 only? Doesn&apos;t look like a really important patch, that just has to be backported. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1; And please add a CHANGES.txt entry for trunk.&lt;/p&gt;</comment>
                    <comment id="12964990" author="yseeley@gmail.com" created="Mon, 29 Nov 2010 22:38:21 +0000"  >&lt;p&gt;In Shai&apos;s defense, a CHANGES entry for 4.0 is pretty questionable.  It&apos;s not going to be a noticeable enough speedup to call out as an end-user feature.  Any super-expert level people extending RAMDirectory and accessing the Map directly will get a compile error (a good thing) and instantly know what&apos;s changed.  IMO, this falls into the category of &quot;little internal cleanup&quot; and people can consult the SVN logs or mailing lists if they wish to know every single one of them &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12964993" author="thetaphi" created="Mon, 29 Nov 2010 22:55:30 +0000"  >&lt;p&gt;OK, but in 3.x its clearly a backwards break. So if we change it there, we have to put it into backwards break section and apply the attached patch to backwards/&lt;/p&gt;</comment>
                    <comment id="12965086" author="shaie" created="Tue, 30 Nov 2010 04:37:01 +0000"  >&lt;p&gt;I didn&apos;t add a CHANGES entry because I consider it an internal change. And as a user, I wouldn&apos;t know what to do w/ an entry that says &quot;RAMDirectory now uses CHM&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t believe cloning the keySet() will make it more &quot;snapshotty&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Cloning the keySet() will be exactly the &apos;snapshotty&apos; behavior we&apos;re looking for. Before I made the change, you could call listAll(), lock RAMDir, return the array and before/after that files could be added/removed. W/ the clone, we&apos;ll get the same behavior - files can be added/removed before the clone, clone would reflect those changes, whatever happens after the clone is invisible to the iterator - hence why I consider it snapshotty.&lt;/p&gt;</comment>
                    <comment id="12965130" author="shaie" created="Tue, 30 Nov 2010 07:03:35 +0000"  >&lt;blockquote&gt;&lt;p&gt;Doesn&apos;t look like a really important patch, that just has to be backported. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Earwin, I did not &lt;b&gt;just&lt;/b&gt; backport it. This time I deviated from my usual work habit, which is changing 3x before trunk, because I did want to cause any mergeprops troubles. But in real life, I work on and improve 3x, and back/forward port to trunk &amp;#8211; at least until trunk/4.0 release will be anywhere near sight. So for all intent and purposes, this improvement should have gone into 3x, as far as I&apos;m concerned. That that we have an issue w/ our backwards tests layer (sent a separate email about it) is unrelated to the issue.&lt;/p&gt;

&lt;p&gt;As a general practice though, I do not neglect 3x branch &amp;#8211; if something that I do can fit there, I will put it there, whether it&apos;s a major performance improvement, or a minor house cleaning.&lt;/p&gt;</comment>
                    <comment id="12965167" author="shaie" created="Tue, 30 Nov 2010 09:25:43 +0000"  >&lt;p&gt;Attached patch combines the changes to RAMDir and the changes to MockRAMDir under backwards.&lt;/p&gt;

&lt;p&gt;I also made the map final, as Uwe suggested, but it means that on close() it cannot be nullified, so instead I clear()-ed it. I think it achieves the same goal - clearing the references to RAMFiles.&lt;/p&gt;

&lt;p&gt;Also, what do you know, I&apos;ve hit an AIOB exception thrown from listAll() when it called toArray() &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. So I cloned the set of keys first, which protects against it. After the set is cloned, it&apos;s not affected by any changes to the map, and therefore toArray() works safely, and returns some point in time snapshot of the map. The &quot;point in time&quot; is not necessarily the one that existed when you called listAll(), but the cloned set becomes the &quot;point in time&quot; snapshot. I think it&apos;s ok.&lt;/p&gt;

&lt;p&gt;I&apos;ve hit it when running backwards tests (from TestIndexWriterExceptions), but not from core. Perhaps it was just a threading issue.&lt;/p&gt;

&lt;p&gt;If you&apos;re ok w/ that, I&apos;ll make the same changes to trunk as well (making the map final and cloning the set).&lt;/p&gt;

&lt;p&gt;All tests pass (this time, including backwards &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).&lt;/p&gt;</comment>
                    <comment id="12965194" author="earwin" created="Tue, 30 Nov 2010 10:54:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;Cloning the keySet() will be exactly the &apos;snapshotty&apos; behavior we&apos;re looking for. Before I made the change, you could call listAll(), lock RAMDir, return the array and before/after that files could be added/removed. W/ the clone, we&apos;ll get the same behavior - files can be added/removed before the clone, clone would reflect those changes, whatever happens after the clone is invisible to the iterator - hence why I consider it snapshotty.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There are still weird cases, when file B was added after deleting A, but you see both in listAll(). These - remain, so it&apos;s not a &quot;point in time&quot; it&apos;s more like a &quot;span in time&quot;.&lt;br/&gt;
Whatever happened after toArray was invisible to array too, so the behaviour hasn&apos;t changed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, what do you know, I&apos;ve hit an AIOB exception thrown from listAll() when it called toArray() &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;But &lt;em&gt;this&lt;/em&gt; fact is really interesting. toArray() with no parameters failed on CHM? Cloning has a meaning now &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Earwin, I did not &lt;b&gt;just&lt;/b&gt; backport it. ........&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Didn&apos;t mean to offend anyone, sorry if I did.&lt;/p&gt;</comment>
                    <comment id="12965205" author="shaie" created="Tue, 30 Nov 2010 11:38:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;toArray() with no parameters failed on CHM?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t use toArray(). I use toArray(new String&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;) because I don&apos;t want to cast the returned array to String[]. According to the javadocs:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This method guarantees the right array size will be allocated.&lt;/p&gt;</comment>
                    <comment id="12965234" author="shaie" created="Tue, 30 Nov 2010 14:35:45 +0000"  >&lt;p&gt;I plan to commit this tomorrow, so if you have comments, please share them.&lt;/p&gt;</comment>
                    <comment id="12965235" author="thetaphi" created="Tue, 30 Nov 2010 14:39:58 +0000"  >&lt;p&gt;I am fine, there is only a typo copied from my patch in the RuntimeException &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12965240" author="yseeley@gmail.com" created="Tue, 30 Nov 2010 14:47:34 +0000"  >&lt;p&gt;OK, a few points on the latest patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;cloning the map does not change the &quot;lie&quot; (i.e. it&apos;s still not a point-in-time snapshot)... the constructor for the new set must iterate over the items also, so consistency is not increased.  You&apos;ve just changed where the iteration happens.  You can see this by trying out my test program, and making the following change:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[] vals = map.keySet().toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[0]);
      &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[] vals = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;(map.keySet()).toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[0]);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;toArray() or toArray(T[]) should be safe to call on ConcurrentHashMap.keySet().  It works fine on my JVM (Oracle Java6)&lt;br/&gt;
  What JVM are you using?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12965245" author="thetaphi" created="Tue, 30 Nov 2010 14:55:00 +0000"  >&lt;p&gt;Yonik: You are right. Sun Java 5 creates an ArrayList and then uses the Iterator and adds each key to the ArrayList. After that it calls toArray on the ArrayList. This is safe, as the iterator is documented to be safe. Java 6 is safe as AbstractCollection.toArray() is oficially documented to behave correctly.&lt;/p&gt;

&lt;p&gt;If Shai wants to keep this code, he should at least use ArrayList instead of HashSet for the keys, as cloning is much faster then. But as ArrayList(Collection) uses toArray() in its ctor it may also be broken.&lt;/p&gt;

&lt;p&gt;Maybe Shai uses IBM JRocket? Or Harmony (Harmony is currently broken, &lt;a href=&quot;https://issues.apache.org/jira/browse/HARMONY-6681&quot; title=&quot;AbstractCollection.toArray() and AbstractCollection.toArray(T[]) are broken for concurrently modified collections like ConcurrentHashMap.keySet()&quot;&gt;HARMONY-6681&lt;/a&gt;)?&lt;/p&gt;</comment>
                    <comment id="12965293" author="shaie" created="Tue, 30 Nov 2010 17:06:49 +0000"  >&lt;p&gt;Ok I can change the code to: new ArrayList(map.keySet()).toArray(). How&apos;s that sound?&lt;/p&gt;

&lt;p&gt;I use IBM JVM and I&apos;ll check the KeySet.toArray later when I&apos;m in front of the comp. But I think we should have a resilient code and the one above seems right to me. What do you think?&lt;/p&gt;</comment>
                    <comment id="12965296" author="earwin" created="Tue, 30 Nov 2010 17:18:10 +0000"  >&lt;p&gt;Quoting Sun JDK 1.6:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ArrayList(Collection&amp;lt;? &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
  elementData = c.toArray();
  size = elementData.length;
  &lt;span class=&quot;code-comment&quot;&gt;// c.toArray might (incorrectly) not &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[] (see 6260652)
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (elementData.getClass() != &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[].class)
    elementData = Arrays.copyOf(elementData, size, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[].class);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It calls toArray() on collection provided. You might as well skip wrapping with ArrayList and use toArray directly &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12965300" author="thetaphi" created="Tue, 30 Nov 2010 17:31:04 +0000"  >&lt;p&gt;Earwin: I wanted to say the same. &lt;/p&gt;

&lt;p&gt;JRockit and Harmony are broken, Sun JVM is correct. So remove the code and only use toArray(). We cannot work around bugs in non-oficially-supported JVMs (IBM wants to go away from JRocket, too).&lt;/p&gt;</comment>
                    <comment id="12965301" author="rcmuir" created="Tue, 30 Nov 2010 17:31:18 +0000"  >&lt;p&gt;Hi:&lt;/p&gt;

&lt;p&gt;please don&apos;t post sun/oracle proprietary source code on apache jira issues!&lt;/p&gt;</comment>
                    <comment id="12965303" author="thetaphi" created="Tue, 30 Nov 2010 17:42:07 +0000"  >&lt;p&gt;The only performant variant of that code that works around all these bugs is the code snippet in Java SE6 JavaDocs, which is published by Sun as &quot;works-as-if-implemented-as&quot; in their JavaDocs: &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; set = #####.keySet();
List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; list = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;(set.size());
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s : set) list.add(s);
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; list.toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[0]);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But I still don&apos;t think we should do this, its a bug outside Lucene in a seldom used JVM! Sun Java 5 and Sun Java 6 work 100% correct and never throw exceptions (by using techniques like above).&lt;/p&gt;</comment>
                    <comment id="12965359" author="shaie" created="Tue, 30 Nov 2010 19:23:31 +0000"  >&lt;p&gt;I did hit an AIOOBE though, and I use IBM&apos;s JDK, which its CHM apparently uses AbstractCollection&apos;s impl of toArray(Object[]). The question is, why should we rely on toArray() implemented one way or the other in which JDK? If we think the best impl would be to allocate an ArrayList and add all the elements to it, then why not do this explicitly? Remember that before this change, listAll() would do almost exactly that - it iterated on the keySet() and added to items to an array, only then it could rely on size().&lt;/p&gt;

&lt;p&gt;Apparently, doing new ArrayList(fileMap.keySet()) is not safe either, as internally it allocates an array and calls the set&apos;s toArray. So I ended up writing the following code and comment:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// NOTE: due to different implementations of different JDKs, it&apos;s not safe
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; either:
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// 1. &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; fileMap.keySet().toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[0])
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// 2. &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;(fileMap.keySet()).toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[0])
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// as both can result in ArrayIndexOutOfBoundException, in &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; the keySet()
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// is modified &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method is executed.
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// Therefore we must clone the set in the following manner, never relying on
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// keySet() size (even though it&apos;s used, ArrayList grows as needed.
&lt;/span&gt;    Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; fileNames = fileMap.keySet();
    List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; names = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;(fileNames.size());
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; name : fileNames) names.add(name);
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; names.toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[names.size()]);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12965376" author="mikemccand" created="Tue, 30 Nov 2010 19:39:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;But I still don&apos;t think we should do this, its a bug outside Lucene in a seldom used JVM! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually I think &lt;span class=&quot;error&quot;&gt;&amp;#91;sadly&amp;#93;&lt;/span&gt; it is our responsibility to sidestep JRE bugs when we can.  We want to maximize Lucene&apos;s portability.&lt;/p&gt;</comment>
                    <comment id="12965380" author="earwin" created="Tue, 30 Nov 2010 19:46:46 +0000"  >&lt;blockquote&gt;&lt;p&gt;So I ended up writing the following code and comment&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Looks good.&lt;/p&gt;</comment>
                    <comment id="12965390" author="yseeley@gmail.com" created="Tue, 30 Nov 2010 19:53:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;The question is, why should we rely on toArray() implemented one way or the other in which JDK?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Both Harmony and IBM&apos;s implementations are broken - it&apos;s not an issue of a different but still valid implementation.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Actually I think &lt;span class=&quot;error&quot;&gt;&amp;#91;sadly&amp;#93;&lt;/span&gt; it is our responsibility to sidestep JRE bugs when we can. We want to maximize Lucene&apos;s portability.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 (within reason)&lt;br/&gt;
In this case, it&apos;s relatively straightforward to do so, and it&apos;s not in an inner-loop.&lt;/p&gt;</comment>
                    <comment id="12965396" author="thetaphi" created="Tue, 30 Nov 2010 19:58:18 +0000"  >&lt;p&gt;Code looks good, I would only chnage the comment to simply say, that:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; fileMap.keySet().toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[0]);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;only works correct in Suns JVM. The thing with new ArrayList(Collection) or any other thing is implemented different in every JVM (even new HashSet(Collection) can be broken if it uses toArray() for some weird reason). But just to note, according to the JDK documentation the above code should work - period. So we should only document that and say, that this is broken.&lt;/p&gt;</comment>
                    <comment id="12965571" author="shaie" created="Wed, 1 Dec 2010 04:51:30 +0000"  >&lt;p&gt;Patch w/ the latest code + a typo fix. I will commit it later today.&lt;/p&gt;</comment>
                    <comment id="12965709" author="shaie" created="Wed, 1 Dec 2010 15:06:28 +0000"  >&lt;p&gt;Committed revision 1041019 (3x).&lt;br/&gt;
Committed revision 1041039 (trunk).&lt;/p&gt;

&lt;p&gt;Thanks all for the review !&lt;/p&gt;</comment>
                    <comment id="12966376" author="kimchy" created="Fri, 3 Dec 2010 01:15:33 +0000"  >&lt;p&gt;  If the assumption still stands that an IndexInput will not be opened on a &quot;writing&quot; / unclosed IndexOutput, then RAMFile can also be improved when it comes to concurrency. The RAMOutputStream can maintain its own list of buffers (simple array list, no need to sync), and only when it gets closed, initialize the respective RAMFile with the list. This means most of the synchronize aspects of RAMFile can be removed. Also, on RAMFile, lastModified can be made volatile, and remove the sync on its respective methods.&lt;/p&gt;</comment>
                    <comment id="12966457" author="mikemccand" created="Fri, 3 Dec 2010 09:22:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;If the assumption still stands that an IndexInput will not be opened on a &quot;writing&quot; / unclosed IndexOutput, then RAMFile can also be improved when it comes to concurrency. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This assumption does still stand, and our unit tests now assert this &amp;#8211; MockDirWrapper throws an exception if we ever try to open an II when an IO is still open against that file.&lt;/p&gt;

&lt;p&gt;That said... we are considering relaxing this, because RT search needs to be able to access the doc stores with an II even as IO is appending to it.&lt;/p&gt;</comment>
                    <comment id="13013375" author="gsingers" created="Wed, 30 Mar 2011 16:50:08 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12491656">HARMONY-6681</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12464905" name="LUCENE-2779-backwardsfix.patch" size="1307" author="thetaphi" created="Mon, 29 Nov 2010 22:10:44 +0000" />
                    <attachment id="12465027" name="LUCENE-2779.patch" size="7546" author="shaie" created="Wed, 1 Dec 2010 04:51:30 +0000" />
                    <attachment id="12464949" name="LUCENE-2779.patch" size="7554" author="shaie" created="Tue, 30 Nov 2010 09:25:43 +0000" />
                    <attachment id="12464826" name="LUCENE-2779.patch" size="4819" author="shaie" created="Mon, 29 Nov 2010 04:27:23 +0000" />
                    <attachment id="12464801" name="LUCENE-2779.patch" size="4620" author="shaie" created="Sun, 28 Nov 2010 09:47:48 +0000" />
                    <attachment id="12464871" name="TestCHM.java" size="1727" author="yseeley@gmail.com" created="Mon, 29 Nov 2010 16:04:53 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 25 Nov 2010 17:49:54 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11074</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24913</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>