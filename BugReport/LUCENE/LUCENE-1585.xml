<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:18:40 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1585/LUCENE-1585.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1585] Allow to control how payloads are merged</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1585</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Lucene handles backwards-compatibility of its data structures by&lt;br/&gt;
converting them from the old into the new formats during segment&lt;br/&gt;
merging. &lt;/p&gt;

&lt;p&gt;Payloads are simply byte arrays in which users can store arbitrary&lt;br/&gt;
data. Applications that use payloads might want to convert the format&lt;br/&gt;
of their payloads in a similar fashion. Otherwise it&apos;s not easily&lt;br/&gt;
possible to ever change the encoding of a payload without reindexing.&lt;/p&gt;

&lt;p&gt;So I propose to introduce a PayloadMerger class that the SegmentMerger&lt;br/&gt;
invokes to merge the payloads from multiple segments. Users can then&lt;br/&gt;
implement their own PayloadMerger to convert payloads from an old into&lt;br/&gt;
a new format.&lt;/p&gt;

&lt;p&gt;In the future we need this kind of flexibility also for column-stride&lt;br/&gt;
fields (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1231&quot; title=&quot;Column-stride fields (aka per-document Payloads)&quot;&gt;&lt;del&gt;LUCENE-1231&lt;/del&gt;&lt;/a&gt;) and flexible indexing codecs.&lt;/p&gt;

&lt;p&gt;In addition to that it would be nice if users could store version&lt;br/&gt;
information in the segments file. E.g. they could store &quot;in segment _2&lt;br/&gt;
the term a:b uses payloads of format x.y&quot;.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12422030">LUCENE-1585</key>
            <summary>Allow to control how payloads are merged</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="shaie">Shai Erera</assignee>
                                <reporter username="michaelbusch">Michael Busch</reporter>
                        <labels>
                    </labels>
                <created>Sat, 4 Apr 2009 04:53:22 +0100</created>
                <updated>Wed, 30 Mar 2011 16:49:53 +0100</updated>
                    <resolved>Fri, 14 May 2010 13:12:39 +0100</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12695728" author="mikemccand" created="Sat, 4 Apr 2009 13:20:48 +0100"  >&lt;p&gt;I agree: extensibility to the SegmentInfo (just like FieldInfo) is needed.&lt;/p&gt;

&lt;p&gt;I think, ideally, with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1458&quot; title=&quot;Further steps towards flexible indexing&quot;&gt;&lt;del&gt;LUCENE-1458&lt;/del&gt;&lt;/a&gt; there would be a &quot;payloads codec&quot; responsible for reading &amp;amp; writing &amp;amp; merging.  All things (not just payloads) need this.&lt;/p&gt;

&lt;p&gt;EG, because the payload is opaque to Lucene, we now must encode the length of the byte[] per term occurrence, but if &lt;span class=&quot;error&quot;&gt;&amp;#91;say&amp;#93;&lt;/span&gt; the codec knows it&apos;s always N bytes, or it&apos;s a function of term, or something, the codec would be free not to encode the number of bytes and derive it from other sources.&lt;/p&gt;</comment>
                    <comment id="12695888" author="michaelbusch" created="Sun, 5 Apr 2009 19:52:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;All things (not just payloads) need this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. But as you always say, Mike, &quot;Progress, not perfection&quot;. I think it would be nice to get this in 2.9 for payloads only, and then in 3.x for codecs.&lt;/p&gt;</comment>
                    <comment id="12695897" author="mikemccand" created="Sun, 5 Apr 2009 20:32:12 +0100"  >&lt;p&gt;Agreed!&lt;/p&gt;</comment>
                    <comment id="12860891" author="shaie" created="Mon, 26 Apr 2010 12:00:27 +0100"  >&lt;p&gt;Michael, I would like to take a stab at it if you don&apos;t mind (unless you are working on it). In fact, I&apos;ve investigated and was about to open an issue before I came across this one &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;W/ Flex, one can set a Codec, however that Codec will be used for regular segment merges. The problem (that I&apos;ve run into and you describe here) is that during addIndexes*, one would need a different Codec for payloads, in order to rewrite the ones that come from the external indexes. I was thinking to add another variation of addIndexes* which take a PayloadConsumer as input, and in SM.appendPostings, after it reads the payload from the other index, invoke PayloadConsumer on that payload, and only after that write it to PositionConsumer.&lt;/p&gt;

&lt;p&gt;That API would of course be marked as experimental.&lt;/p&gt;

&lt;p&gt;Also, SM.appendPostings is called from two different code paths - addIndexes* and regular segment merges. For the regular merges, the PC should be null, but for the addIndexes it may not be. So we&apos;ll need to add that API to a bunch of classes in the call chain, but all of them are either private methods or package-private classes.&lt;/p&gt;

&lt;p&gt;How&apos;s that sound? I can cons up a patch if that sounds reasonable.&lt;/p&gt;</comment>
                    <comment id="12860978" author="michaelbusch" created="Mon, 26 Apr 2010 17:24:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;Michael, I would like to take a stab at it if you don&apos;t mind (unless you are working on it).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Please go ahead!  I&apos;m not working on this currently.&lt;/p&gt;</comment>
                    <comment id="12864725" author="shaie" created="Thu, 6 May 2010 12:06:13 +0100"  >&lt;p&gt;Patch adds PayloadConsumer to 3x branch:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Adds variants to addIndexes* which take PayloadConsumer&lt;/li&gt;
	&lt;li&gt;Adds TestPayloadConsumer&lt;/li&gt;
	&lt;li&gt;Propagates PayloadConsumer down then chain to SegmentMerger, allowing null as a parameter.&lt;/li&gt;
	&lt;li&gt;Covers &apos;backwards&apos; too&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will work on the trunk version now. Perhaps for trunk we can avoid adding variants to addIndexes?&lt;/p&gt;</comment>
                    <comment id="12864763" author="shaie" created="Thu, 6 May 2010 14:28:19 +0100"  >&lt;p&gt;Patch covers trunk changes, except for backwards since it&apos;s no longer in trunk. I&apos;d appreciate a review on how I used the flex API and whether there is a better API I should have used (mostly in the tests I guess)&lt;/p&gt;</comment>
                    <comment id="12864934" author="shaie" created="Thu, 6 May 2010 22:24:14 +0100"  >&lt;p&gt;I went over the tests and realized I didn&apos;t write one which adds indexes into an already populated index. Ideally, the payloads in the existing index should not be re-processed b/c of the external ones that are added. But this doesn&apos;t happen, as addIndexes and addIndexesNoOpt don&apos;t distinguish well between local and external segments. It all boils down to IW,merge() which calls SM.merge() ...&lt;br/&gt;
Then I figured a single PayloadConsumer &quot;might not fit all&quot; - e.g. there are cases where different PCs are needed for different indexes. The app can call addIndexes one at a time, but that&apos;s not efficient. So I think the entry-level API should be a PayloadConsumerProvider, which declares one getPayloadConsumer(Directory) method. It returns a PC corresponding to a Directory. It gives the app the freedom it needs to:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Always return the same PC for all Dirs.&lt;/li&gt;
	&lt;li&gt;Return different PCs for different Dirs.&lt;/li&gt;
	&lt;li&gt;Return null for some Dirs, so that their payloads are not re-processed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Setting out to impl that, I&apos;ve noticed addIndexes and addIndexesNoOpt behave differently. While addIndexes interacts w/ the SegmentMerger directly (and hence can easily pass it the PCP), NoOpt reads the SIs from the given Dirs, call maybeMerge(), which triggers SM.merge(), to merge local + external segments. We cannot pass PCP to maybeMerge since that won&apos;t help - the call chain hits MergeScheduler, which loops-back at us when it calls IW.merge() .. seems way too complicated.&lt;br/&gt;
Additionally, there is no way to guarantee that PCP won&apos;t be invoked during addIndexesNoOpt on local segments (unless it does not provide a PC for the target Dir) ...&lt;/p&gt;

&lt;p&gt;Therefore, I&apos;d like to add PCP to IWC, for the following reasons:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;As I said above, there&apos;s no way to guarantee it won&apos;t be invoked on local segments when *NoOpt is called.&lt;/li&gt;
	&lt;li&gt;There&apos;s no clean way to ensure NoOpt passes it on to SM, w/o passing PCP through MergeScheduler.&lt;/li&gt;
	&lt;li&gt;It might be useful for apps that want to rewrite their payloads only over time &amp;#8211; sort of a mini app-level migration tool (of just payloads).&lt;/li&gt;
	&lt;li&gt;It cleans the API - does not affect &apos;backwards&apos;, no need to pass it on through several methods until it gets to SM &amp;#8211; simplifies the solution.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is an expert API. Therefore, apps that set it probably know what they&apos;re doing. Therefore I believe they will be able to understand how to not invoke their PCs on the target dir&apos;s segments.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12864947" author="shaie" created="Thu, 6 May 2010 23:09:25 +0100"  >&lt;p&gt;Patch adds PayloadConsumerProvider to IWC, and more test cases to TestPayloadConsumerProvider. I&apos;ll update the trunk version after I get some feedback on the overall approach. The use pf PCP is much cleaner - touches no API except IWC.&lt;/p&gt;</comment>
                    <comment id="12864978" author="mikemccand" created="Fri, 7 May 2010 01:38:52 +0100"  >&lt;p&gt;OK new approach sounds good Shai!  The 3x patch looks good.&lt;/p&gt;

&lt;p&gt;Should we maybe name it PayloadMergeProcessor or something?  Transformer? Consumer isn&apos;t really what it is... really it transforms the payloads on during merging.&lt;/p&gt;</comment>
                    <comment id="12865014" author="shaie" created="Fri, 7 May 2010 04:47:02 +0100"  >&lt;p&gt;I&apos;m fine w/ not naming it Consumer - I agree it does not really consume it. But if we go with PayloadMergeProcessor, we&apos;ll need PayloadMergeProcessorProvider and they become quite long names &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I was thinking PayloadProcessor and PayloadProcessorProvider (have cool acronyms to PP and PPP), but then people might get confused that it processes all payloads (maybe before they are even written the first time), while it is actually invoked only during segment merges.I was following the *Consumer pattern I saw all over the place w/ SegmentMerger, and thought that if someone ever reads SM code, it will swallow easily another *Consumer one ...&lt;/p&gt;

&lt;p&gt;So between PC, PMP and PP - I prefer PP - the documentation should clarify what it does.&lt;/p&gt;

&lt;p&gt;But I&apos;m open for suggestions.&lt;/p&gt;</comment>
                    <comment id="12865035" author="shaie" created="Fri, 7 May 2010 06:47:16 +0100"  >&lt;p&gt;I see that in trunk, SegmentMerger does not get IW in its ctor, and there are a couple of places which call that ctor. So perhaps to not affect it, I&apos;ll add another ctor which takes a PC/PP (whatever name we decide on), and the current one will delegate to it w/ null? Or ... I can have SM&apos;s ctor accept IW and take whatever it needs from it. Comparing it to 3x, it will work exactly the same, only will obtain Directory, TermIndexInterval and CodecProvider from IW.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12865108" author="mikemccand" created="Fri, 7 May 2010 11:29:28 +0100"  >&lt;p&gt;I think we should somehow get &quot;merge&quot; into its name?  PayloadMerger?  (Though that&apos;s overstating it does &amp;#8211; IW handles merging payloads, while this class just processes them prior to merging).&lt;/p&gt;

&lt;p&gt;If we can&apos;t come up w/ anything better, I think PayloadProcessor* is acceptable even though it&apos;s overstating.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or ... I can have SM&apos;s ctor accept IW and take whatever it needs from it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d prefer explicit ctor that passes exactly what SM needs... the more &quot;decoupled&quot; we can keep these components, the better, I think?&lt;/p&gt;

&lt;p&gt;And I&apos;d just make the new PPP a required arg and fix places that call it to pass null?  I don&apos;t like ctor proliferation &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  And, this is a package private API...&lt;/p&gt;</comment>
                    <comment id="12865113" author="shaie" created="Fri, 7 May 2010 12:31:27 +0100"  >&lt;p&gt;I hate it when it happens, but better sooner than later - I realized the API must take into account the current Term. We cannot process all the payloads in the index the same way. So how about the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;PayloadProcessorProvider will accept both a Directory and a Term, and will return a suitable PayloadProcessor for that Directory, and if needed, for the Directory+Term combination.&lt;/li&gt;
	&lt;li&gt;PayloadProcessor will continue to work as is and will expose the same API - a payload is still a payload. Its the responsibility of PPP to return the right PP instance for the given Dir+Term&lt;br/&gt;
It does not make sense that the payloads of all the terms in the incoming indexes will need to be processed. Specifically, the scenario I have at hand needs to rewrite payloads of certain postings only, but the index contains payloads in other postings as well.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For 3x that&apos;s easy - SMI holds the current Term that is processed. But I don&apos;t see an equivalent in trunk, in PostingsConsumer. It receives a DocsEnum which does not tell you the term it works on, and MergeState which includes just FieldInfo, which can tell you the field name? Any ideas how I can get the Term this posting belongs to? (I know there is no Term, but field + BytesRef will do).&lt;/p&gt;

&lt;p&gt;Mike - I&apos;ll add PP as a required arg to SM, np. I was only suggesting to pass IW so that we can avoid changing it in the future, but explicit args are fine by me.&lt;/p&gt;</comment>
                    <comment id="12865176" author="mikemccand" created="Fri, 7 May 2010 15:41:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;PayloadProcessorProvider will accept both a Directory and a Term, and will return a suitable PayloadProcessor for that Directory, and if needed, for the Directory+Term combination.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, though this is potentially rather costly &amp;#8211; a huge number of terms are visited when merging.  I guess PPP impls would reuse instances of PP?  But then how will it handle threads...?  (Since multiple threads may be merging at once).  Maybe we need three tiers?  PPP, PP, PPperTerm, such that the PP is used only by one thread in Lucene.  Hmm... getting hairy.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Any ideas how I can get the Term this posting belongs to? (I know there is no Term, but field + BytesRef will do).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe set current field &amp;amp; current term in MergeState?&lt;/p&gt;</comment>
                    <comment id="12865198" author="shaie" created="Fri, 7 May 2010 16:21:15 +0100"  >&lt;p&gt;How to handle that case is entirely up to the PPP impl. Some will return the same PP for all terms, but maybe different ones per directory, while others will only care about few terms, returning null for all the rest. In fact, I think the common case will be either handling all payloads by the same PP, or handle some select terms by either one or more PPs.&lt;/p&gt;

&lt;p&gt;As for threading, this is also something the PPP can take care of. Strangely, flex allows stateless PPs mor easily b/c it uses BytesRef, while in 3x one needs to call both process and payloadLength() and hence concurrency is more a problem.&lt;/p&gt;

&lt;p&gt;I believe the common use will be few PPs that handle few terms. Of course once this is out, people will find original uses for it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. But for now, I don&apos;t see a big perf hit...&lt;/p&gt;

&lt;p&gt;about performance, we&apos;re checking for every position and doc whether the processor is not null. I guess it is better than having a no-op processor? Maybe I can factor that code out to two methods - one that always assumes there is a processor and one that doesn&apos;t?&lt;/p&gt;</comment>
                    <comment id="12865487" author="shaie" created="Sat, 8 May 2010 18:49:55 +0100"  >&lt;p&gt;I&apos;ve been thinking about the multi-threading issue, and as far as I understand, it only concerns the local segment merging? PPP works w/ Directory+Term because the format of the payloads is per term for the entire Directory (not per segment). Therefore, I don&apos;t think there is multi-threading issues with the external Directories (the result of addIndexe*)?&lt;/p&gt;

&lt;p&gt;For the local segments, I see what you mean - it is possible that several threads will ask a PP for the same Dir+Term. PPP implementations can still work well in such scenario (if they wish to process payloads of local Dir as well) by holding a ThreadLocal PP for Dir+Term combination? I think proper documentation should be enough in this case. The whole point of this issue is to allow better control when addIndexes* are used. Affecting local payloads is a nice bonus, and I think we should wait for a real scenario which takes advantage of that. If the threading documentation warnings won&apos;t help, we can discuss then how to solve it?&lt;/p&gt;</comment>
                    <comment id="12865581" author="shaie" created="Sun, 9 May 2010 11:51:20 +0100"  >&lt;p&gt;Patch includes Dir+Term combination in PPP, as well as proper jdocs about concurrency concerns. After we settle it for 3x, I&apos;ll update the patch for trunk&lt;/p&gt;</comment>
                    <comment id="12865692" author="shaie" created="Mon, 10 May 2010 08:53:41 +0100"  >&lt;p&gt;Small correction - the comment I&apos;ve made about concurrency issues w/ just the local directory is wrong because you can add an index w/ multiple segments and if you use CMS and the MP returns several OneMerges, then concurrency issues will happen in that case too.&lt;/p&gt;

&lt;p&gt;Anyway, the 3x tests pass w/ the patch. How do we proceed from here - can I port that patch to trunk or does anybody have more comments?&lt;/p&gt;</comment>
                    <comment id="12865707" author="mikemccand" created="Mon, 10 May 2010 10:01:24 +0100"  >&lt;p&gt;Make sure you fix the whitespace &amp;#8211; some indents are now tabs or 8&lt;br/&gt;
spaces, but should be 2.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I believe the common use will be few PPs that handle few terms.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or, maybe even more common will be per-Directory switching and&lt;br/&gt;
ignoring the Term?  EG if I changed my payload format (for all terms)&lt;br/&gt;
at some point...&lt;/p&gt;

&lt;p&gt;Though we don&apos;t have great support for versioning of payloads during&lt;br/&gt;
searching... eg PayloadTermQuery doesn&apos;t make it simple to figure out&lt;br/&gt;
which Dir you are now searching...&lt;/p&gt;

&lt;p&gt;My only concern w/ this API is that it has a built-in unnecessary&lt;br/&gt;
global perf/synchronization cost, by design: I&apos;ll have to use a sync&apos;d&lt;br/&gt;
map or a thread local to implement that method.  Even if my app&lt;br/&gt;
ignores the Term, I&apos;ll need to sync.  This sync is global &amp;#8211; all&lt;br/&gt;
merges running concurrently, per Term, will share a single global&lt;br/&gt;
lock.&lt;/p&gt;

&lt;p&gt;But it&apos;s only the Dir lookup that requires sync.&lt;/p&gt;

&lt;p&gt;So if, instead, the Dir lookup and the Term lookup were separate&lt;br/&gt;
method calls, I&apos;d only need sync on the Dir lookup (called very rarely&lt;br/&gt;
often &amp;#8211; once per segment on the start of the merge).  The Term&lt;br/&gt;
lookup, called far far more often, is guaranteed to be thread private&lt;br/&gt;
so it&apos;d need no sync.&lt;/p&gt;

&lt;p&gt;I guess in practice the sync cost may not be such a big deal?  So&lt;br/&gt;
maybe we could commit w/ this approach (it is experimental), even with&lt;br/&gt;
this limitation?  It&apos;s just that I don&apos;t like adding APIs which make&lt;br/&gt;
our concurrency worse... we are supposed to be moving in the other&lt;br/&gt;
direction &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12865719" author="shaie" created="Mon, 10 May 2010 11:04:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;Make sure you fix the whitespace - some indents are now tabs or 8 spaces, but should be 2.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s weird. I&apos;ll check it again. Can you point me to a specific place where you&apos;ve noticed that?&lt;/p&gt;

&lt;p&gt;About concurrency - do you mean we should separate the Dir and Term APIs, to be PPP -&amp;gt; return DirPP -&amp;gt; return TermPP? Not necessarily these names but a chain of calls to get to the TermPP? It can work, but what guarantees that PPP -&amp;gt; DirPP is synced? The application will still need to sync the &quot;per-Dir-PP&quot; instance by a ThreadLocal or something, so what exactly do we gain here?&lt;/p&gt;

&lt;p&gt;Perhaps I misunderstood your point - if so, can you please clarify?&lt;/p&gt;</comment>
                    <comment id="12865892" author="shaie" created="Mon, 10 May 2010 20:49:47 +0100"  >&lt;p&gt;Patch includes:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;PayloadProcessorProvider which returns DirPayloadProcesor (given a Directory)&lt;/li&gt;
	&lt;li&gt;DirPayloadProcessor returns a PayloadProcessor (given a Term)&lt;/li&gt;
	&lt;li&gt;All classes are defined as static inner classes in PPP - to make it clear that all 3 are coupled together.&lt;/li&gt;
	&lt;li&gt;SegmentMergeInfo contains a DirPayloadProcessor field - which is set by SegmentMerger once, before all of the terms are processed.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12865932" author="mikemccand" created="Mon, 10 May 2010 22:19:51 +0100"  >&lt;p&gt;Patch looks good Shai!  I like the cascading of Dir/Term processors.&lt;/p&gt;</comment>
                    <comment id="12866288" author="shaie" created="Tue, 11 May 2010 20:23:34 +0100"  >&lt;p&gt;I&apos;ve reviewed the patch again, and I think setPPP should move from IWC to IW. PPP is more of a temporary setting - if you only want to use it for addIndexes*, then you probably want to set it just before the call, and unset it afterwards. Otherwise, unnecessary getDirPP would be called, when you don&apos;t really care about them. So PPP is like InfoStream in a sense - usually it&apos;ll be a point-in-time operation. You can still set it right after IW is created, if you want to use it for other merges too.&lt;/p&gt;

&lt;p&gt;Since IWC is a &quot;write-once&quot; object (documented), it doesn&apos;t make sense to set PPP whenever you create an IW, just because at some point you know addIndexes will be called. And also, it doesn&apos;t make sense to create a new IW instance for that purpose only. So I really feel it should be an IW setting and not IWC.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12866310" author="mikemccand" created="Tue, 11 May 2010 21:24:29 +0100"  >&lt;p&gt;OK, though this means any other merges that happen to be kicked off while your addIndexes is running, would also consult the PPP?  So PPP impl would have to &quot;know&quot; this may happen and deal accordingly?&lt;/p&gt;</comment>
                    <comment id="12866441" author="shaie" created="Wed, 12 May 2010 04:25:49 +0100"  >&lt;p&gt;You&apos;re right. And apps that use it may want to handle it by aborting all merges first, or call sync() on CMS.&lt;/p&gt;

&lt;p&gt;Still, I think that I&apos;m most cases, PPP will be used for addIndexes calls and setting it I&apos;m IWC will be a limitation - e.g. you may want to use different PPPs for different addIndexes calls and opening a new writer just for that seems too much?&lt;/p&gt;

&lt;p&gt;I&apos;ll include a NOTE about it in the jdocs. &lt;/p&gt;</comment>
                    <comment id="12866525" author="mikemccand" created="Wed, 12 May 2010 10:35:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;Still, I think that I&apos;m most cases, PPP will be used for addIndexes calls and setting it I&apos;m IWC will be a limitation - e.g. you may want to use different PPPs for different addIndexes calls and opening a new writer just for that seems too much?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I agree.&lt;/p&gt;

&lt;p&gt;Can we go back to making it a parameter to addIndexes?  What was the issue w/ that approach again?  Was it just the difficulty of tracking internally which segments should be mapped and which shouldn&apos;t?&lt;/p&gt;

&lt;p&gt;Or.. maybe we should leave it as globally settable on IW, since users may want to rewrite payloads for &quot;ordinary&quot; segment merges...&lt;/p&gt;</comment>
                    <comment id="12866537" author="shaie" created="Wed, 12 May 2010 11:51:20 +0100"  >&lt;blockquote&gt;&lt;p&gt;What was the issue w/ that approach again?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;addIndexes had no problem. It was addIndexesNoOptimize which calls the MS, which calls back to IW.merge. The only way to pass it through was to get it through MS, which is not good.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or.. maybe we should leave it as globally settable on IW, since users may want to rewrite payloads for &quot;ordinary&quot; segment merges...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly ! I think that&apos;s a useful utility for e.g. index migration of existing indexes. You can set it on IW and then call optimize(). There are other use cases as well.&lt;/p&gt;</comment>
                    <comment id="12867208" author="mikemccand" created="Thu, 13 May 2010 19:29:37 +0100"  >&lt;p&gt;OK so let&apos;s have it as a free setter on IW...&lt;/p&gt;</comment>
                    <comment id="12867226" author="shaie" created="Thu, 13 May 2010 20:32:40 +0100"  >&lt;p&gt;setPPP moved from IWC to IW. I&apos;ll go update the trunk one now.&lt;/p&gt;</comment>
                    <comment id="12867252" author="shaie" created="Thu, 13 May 2010 21:58:33 +0100"  >&lt;p&gt;Update trunk&apos;s patch.&lt;/p&gt;

&lt;p&gt;All tests pass. I plan to commit this tomorrow.&lt;/p&gt;</comment>
                    <comment id="12867254" author="mikemccand" created="Thu, 13 May 2010 22:02:36 +0100"  >&lt;p&gt;Patches look good Shai.&lt;/p&gt;

&lt;p&gt;One thing &amp;#8211; in TermsConsumer, it&apos;d be nice to not step through the for loop checking for non-null dirPP, if the IW had no PPP?&lt;/p&gt;</comment>
                    <comment id="12867260" author="thetaphi" created="Thu, 13 May 2010 22:18:39 +0100"  >&lt;p&gt;Just an idea:&lt;br/&gt;
Could we also use this for the term bytes itsself? E.g. when converting NumericFields in our 4.0 inde x converter to use the full 8bits? So we just process the old index and merge to the converted one? During that all terms are converted using the processor?&lt;/p&gt;</comment>
                    <comment id="12867380" author="shaie" created="Fri, 14 May 2010 04:42:28 +0100"  >&lt;p&gt;Good idea Mike !&lt;/p&gt;

&lt;p&gt;I&apos;ve added hasPayloadProcessorProvider to MergeState and use it in TermsConsumer.&lt;/p&gt;</comment>
                    <comment id="12867382" author="shaie" created="Fri, 14 May 2010 04:47:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;Could we also use this for the term bytes itsself?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think you&apos;d want to use the same approach, yes. But I&apos;m not sure I want to reuse the same classes for that purpose, for several reasons:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The classes have the word Payload all over the place - javadocs, names etc. And for a good reason IMO - that&apos;s what they do.&lt;/li&gt;
	&lt;li&gt;One is expected to include different PP for different Directory and Term, but to convert the NumericField terms, I don&apos;t think one will use different PPs at all? I.e. a single TermsConverter / NumericFieldsTermConverter will be good for whatever Directory + Term?&lt;/li&gt;
	&lt;li&gt;The sort of operation you suggest (converting terms) seems to be a one time op &amp;#8211; when I migrate my indexes? PPP on the other hand (at least in my case) will be used whenever I call addIndexes* so that I can process and rewrite the payloads of the incoming indexes.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So while both will do byte[] conversion, I think those are two separate tools. Your should probably exist in a o.a.l.migration package or something, because it will be relevant to index migration only? Or did I misunderstood you?&lt;/p&gt;</comment>
                    <comment id="12867449" author="mikemccand" created="Fri, 14 May 2010 10:08:53 +0100"  >&lt;p&gt;Also, remapping the term bytes in general on the fly is tricky, since the remapping could alter their sort order.&lt;/p&gt;</comment>
                    <comment id="12867489" author="shaie" created="Fri, 14 May 2010 13:12:39 +0100"  >&lt;p&gt;Committed revision 944214 (3x).&lt;br/&gt;
Committed revision 944220 (trunk).&lt;/p&gt;

&lt;p&gt;Thanks Michael for starting this !&lt;/p&gt;</comment>
                    <comment id="13013293" author="gsingers" created="Wed, 30 Mar 2011 16:49:53 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12444416" name="LUCENE-1585_3x.patch" size="22426" author="shaie" created="Thu, 13 May 2010 20:32:40 +0100" />
                    <attachment id="12444142" name="LUCENE-1585_3x.patch" size="23541" author="shaie" created="Mon, 10 May 2010 20:49:47 +0100" />
                    <attachment id="12444055" name="LUCENE-1585_3x.patch" size="22738" author="shaie" created="Sun, 9 May 2010 11:51:20 +0100" />
                    <attachment id="12443911" name="LUCENE-1585_3x.patch" size="19824" author="shaie" created="Thu, 6 May 2010 23:09:24 +0100" />
                    <attachment id="12443848" name="LUCENE-1585_3x.patch" size="25027" author="shaie" created="Thu, 6 May 2010 12:06:13 +0100" />
                    <attachment id="12444467" name="LUCENE-1585_trunk.patch" size="24494" author="shaie" created="Fri, 14 May 2010 04:42:28 +0100" />
                    <attachment id="12444422" name="LUCENE-1585_trunk.patch" size="24286" author="shaie" created="Thu, 13 May 2010 21:58:32 +0100" />
                    <attachment id="12443858" name="LUCENE-1585_trunk.patch" size="18029" author="shaie" created="Thu, 6 May 2010 14:28:19 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 4 Apr 2009 12:20:48 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12170</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26144</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>