<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:09:32 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3112/LUCENE-3112.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3112] Add IW.add/updateDocuments to support nested documents</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3112</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I think nested documents (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2454&quot; title=&quot;Nested Document query support&quot;&gt;&lt;del&gt;LUCENE-2454&lt;/del&gt;&lt;/a&gt;) is a very compelling addition&lt;br/&gt;
to Lucene.  It&apos;s also a popular (many votes) issue.&lt;/p&gt;

&lt;p&gt;Beyond supporting nested document querying, which is already an&lt;br/&gt;
incredible addition since it preserves the relational model on&lt;br/&gt;
indexing normalized content (eg, DB tables, XML docs), &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2454&quot; title=&quot;Nested Document query support&quot;&gt;&lt;del&gt;LUCENE-2454&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
should also enable speedups in grouping implementation when you group&lt;br/&gt;
by a nested field.&lt;/p&gt;

&lt;p&gt;For the same reason, it can also enable very fast post-group facet&lt;br/&gt;
counting impl (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3097&quot; title=&quot;Post grouping faceting&quot;&gt;&lt;del&gt;LUCENE-3097&lt;/del&gt;&lt;/a&gt;) when you what to&lt;br/&gt;
count(distinct(nestedField)), instead of unique documents, as your&lt;br/&gt;
&quot;identifier&quot;.  I expect many apps that use faceting need this ability&lt;br/&gt;
(to count(distinct(nestedField)) not distinct(docID)).&lt;/p&gt;

&lt;p&gt;To support these use cases, I believe the only core change needed is&lt;br/&gt;
the ability to atomically add or update multiple documents, which you&lt;br/&gt;
cannot do today since in between add/updateDocument calls a flush (eg&lt;br/&gt;
due to commit or getReader()) could occur.&lt;/p&gt;

&lt;p&gt;This new API (addDocuments(Iterable&amp;lt;Document&amp;gt;), updateDocuments(Term&lt;br/&gt;
delTerm, Iterable&amp;lt;Document&amp;gt;) would also further guarantee that the&lt;br/&gt;
documents are assigned sequential docIDs in the order the iterator&lt;br/&gt;
provided them, and that the docIDs all reside in one segment.&lt;/p&gt;

&lt;p&gt;Segment merging never splits segments apart, so this invariant would&lt;br/&gt;
hold even as merges/optimizes take place.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12507476">LUCENE-3112</key>
            <summary>Add IW.add/updateDocuments to support nested documents</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 May 2011 11:48:37 +0100</created>
                <updated>Fri, 3 Jun 2011 17:37:18 +0100</updated>
                    <resolved>Mon, 23 May 2011 22:01:50 +0100</resolved>
                                            <fixVersion>3.2</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13034700" author="mikemccand" created="Tue, 17 May 2011 11:51:12 +0100"  >&lt;p&gt;Initial patch.&lt;/p&gt;

&lt;p&gt;It&apos;s not done yet (needs tests, and the nocommit needs to be addressed).&lt;/p&gt;</comment>
                    <comment id="13034711" author="simonw" created="Tue, 17 May 2011 12:09:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;Initial patch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;nice simple idea! I like the refactorings into pre/postUpdate - looks much cleaner. Yet, I think you should push the document iteration etc into DWPT to actually apply the delterm only once to make it really atomic. I also wonder if we should allow multiple delTerm e.g. Tuple&amp;lt;DelTerm, Document&amp;gt; otherwise you would be bound to one delterm pre &quot;collection&quot; but what if you want to remove only one of the &quot;sub-documents&quot;? So if we would have those tuples you really want to push the iteration into DWPT to make a final finishDocument(Term[] terms) call pushing the terms into a single DeleteItem.&lt;/p&gt;
</comment>
                    <comment id="13034730" author="rcmuir" created="Tue, 17 May 2011 12:42:36 +0100"  >&lt;p&gt;We should really think through the consequences of this though.&lt;/p&gt;

&lt;p&gt;If core features of lucene become implemented in a way that they rely upon these sequential docids, we then lock ourselves out of future optimizations such as reordering docids for optimal index compression.&lt;/p&gt;</comment>
                    <comment id="13034734" author="jasonrutherglen" created="Tue, 17 May 2011 13:13:41 +0100"  >&lt;p&gt;I think perhaps like a Hadoop input format split, we can define meta-data at the segment level as to where the documents live so that if one is &apos;splitting&apos; the index, as is being implemented with HBase, the &apos;splitter&apos; can be &apos;smart&apos;.&lt;/p&gt;</comment>
                    <comment id="13034750" author="mikemccand" created="Tue, 17 May 2011 14:14:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;Yet, I think you should push the document iteration etc into DWPT to actually apply the delterm only once to make it really atomic.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh good point &amp;#8211; it&apos;s wrong just passing that delTerm down N times, too.  I&apos;ll fix.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I also wonder if we should allow multiple delTerm e.g. Tuple&amp;lt;DelTerm, Document&amp;gt; otherwise you would be bound to one delterm pre &quot;collection&quot; but what if you want to remove only one of the &quot;sub-documents&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So, this won&apos;t work today w/ nested querying, if I understand it right.  Ie, if you only update one of the subs, now your subdocs are no longer sequential (nor in one segment).  So I think &quot;design for today&quot; here...?&lt;/p&gt;

&lt;p&gt;Someday, when we implement incremental field updates correctly, so that updates are written as stacked segments against the original segment containing the document, at that point I think we can add an API that lets you update multiple docs atomically?&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;</comment>
                    <comment id="13034850" author="mikemccand" created="Tue, 17 May 2011 17:20:54 +0100"  >&lt;blockquote&gt;
&lt;p&gt;We should really think through the consequences of this though.&lt;/p&gt;

&lt;p&gt;If core features of lucene become implemented in a way that they rely upon these sequential docids, we then lock ourselves out of future optimizations such as reordering docids for optimal index compression.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree it&apos;s somewhat dangerous we are making an (experimental)&lt;br/&gt;
guarantee that these docIDs will remain adjacent &quot;forever&quot;.  We&lt;br/&gt;
normally are very protective about letting apps rely on docID&lt;br/&gt;
assignment/order.&lt;/p&gt;

&lt;p&gt;But, I think this will not be &quot;core&quot; functionality that relies on&lt;br/&gt;
sub-docs (adjacent docs), but rather modules &amp;#8211; grouping, faceting,&lt;br/&gt;
nestedqueries/queries.  And, even if you use these modules, it&apos;s&lt;br/&gt;
optional whether the app did sub-docs.  Ie we would still have the&lt;br/&gt;
&apos;generic&quot; grouping collector, but then also an optimized one that&lt;br/&gt;
takes advantage of sub-docs.&lt;/p&gt;

&lt;p&gt;Finally, I think doing this today would not preclude doing docID&lt;br/&gt;
reording in the future because the sub docs would be recomputable&lt;br/&gt;
based on the &quot;identifier&quot; field which grouped them in the first&lt;br/&gt;
place.&lt;/p&gt;

&lt;p&gt;Ie the worst case future scenario (an app uses this new sub-docs&lt;br/&gt;
feature, but then has a big index they don&apos;t want to reindex and wants&lt;br/&gt;
to take advantage of a future docid reording compression we add) would&lt;br/&gt;
still be solvable because we could use this identifier field to find&lt;br/&gt;
blocks of sub-docs.&lt;/p&gt;

&lt;p&gt;I suppose we could consider changing the index format today to record&lt;br/&gt;
which docs are subs... but I think we don&apos;t need to.  Maybe I should&lt;br/&gt;
strengthen the @experimental to explain the risk that a future&lt;br/&gt;
reindexing could be required?&lt;/p&gt;</comment>
                    <comment id="13034854" author="rcmuir" created="Tue, 17 May 2011 17:26:23 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I suppose we could consider changing the index format today to record&lt;br/&gt;
which docs are subs... but I think we don&apos;t need to. Maybe I should&lt;br/&gt;
strengthen the @experimental to explain the risk that a future&lt;br/&gt;
reindexing could be required?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this would be perfect. I certainly don&apos;t want to hold up this &lt;br/&gt;
improvement, yet, in the future I just didnt want us to be in a &lt;br/&gt;
situation where we say &apos;well if only we had recorded this information,&lt;br/&gt;
now its not possible to do XYZ because someone COULD have used &lt;br/&gt;
add/updateDocuments() for some arbitrary reason and we will &apos;split&apos; &lt;br/&gt;
their grouped ids&apos;.&lt;/p&gt;

&lt;p&gt;We could also include in the note that various existing &lt;br/&gt;
IndexSorters/Splitters are unaware about this, so use with caution &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13036175" author="mikemccand" created="Thu, 19 May 2011 14:24:53 +0100"  >&lt;p&gt;New patch, I think it&apos;s ready to commit but it could use some healthy reviewing...&lt;/p&gt;

&lt;p&gt;I fang&apos;d up TestNRThreads to add/update doc blocks and verify the docs in each block remain adjacent, and also added a couple other test cases to make sure we test non-aborting exceptions when adding a doc block.&lt;/p&gt;

&lt;p&gt;And I put warning in the jdocs about possible future full re-indexing.&lt;/p&gt;</comment>
                    <comment id="13038226" author="mikemccand" created="Mon, 23 May 2011 22:01:50 +0100"  >&lt;p&gt;Fixed.&lt;/p&gt;

&lt;p&gt;Only hitch was in 3.x the APIs take Collection&amp;lt;Document&amp;gt; (vs trunk&apos;s Iterable&amp;lt;Document&amp;gt;).  If we backport DWPT we can put it back to Iterable&amp;lt;Document&amp;gt;...&lt;/p&gt;</comment>
                    <comment id="13038538" author="steve_rowe" created="Tue, 24 May 2011 14:08:39 +0100"  >&lt;p&gt;Mike, when you put the branch_3x port back, contrib/misc&apos;s IndexSplitter.java has javadocs references to IndexWriter#addDocuments(Iterable), instead of IW#aDs(Collection) - this triggers javadocs warnings which fail the build.&lt;/p&gt;</comment>
                    <comment id="13038583" author="mikemccand" created="Tue, 24 May 2011 15:27:01 +0100"  >&lt;p&gt;Argh!  Thanks Steven &amp;#8211; I will fix those jdocs 2nd time around.&lt;/p&gt;</comment>
                    <comment id="13038641" author="steve_rowe" created="Tue, 24 May 2011 16:58:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;IndexSplitter.java has javadocs references&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oops, I got the trunk javadocs problem mixed up with the branch_3x javadocs problem...&lt;/p&gt;

&lt;p&gt;The incorrect references are actually in IndexWriter.java itself, on updateDocuments() methods.&lt;/p&gt;</comment>
                    <comment id="13043511" author="rcmuir" created="Fri, 3 Jun 2011 17:37:18 +0100"  >&lt;p&gt;Bulk closing for 3.2&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                <outwardlinks description="blocks">
                            <issuelink>
            <issuekey id="12507929">LUCENE-3129</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12479768" name="LUCENE-3112.patch" size="42672" author="mikemccand" created="Thu, 19 May 2011 14:24:53 +0100" />
                    <attachment id="12479448" name="LUCENE-3112.patch" size="11998" author="mikemccand" created="Tue, 17 May 2011 11:51:12 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 17 May 2011 11:09:48 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2136</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12222</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>