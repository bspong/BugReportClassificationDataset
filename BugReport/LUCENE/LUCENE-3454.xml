<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:11:02 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3454/LUCENE-3454.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3454] rename optimize to a less cool-sounding name</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3454</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I think users see the name optimize and feel they must do this, because who wants a suboptimal system? but this probably just results in wasted time and resources.&lt;/p&gt;

&lt;p&gt;maybe rename to collapseSegments or something?&lt;/p&gt;</description>
                <environment></environment>
            <key id="12524548">LUCENE-3454</key>
            <summary>rename optimize to a less cool-sounding name</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Sun, 25 Sep 2011 04:00:40 +0100</created>
                <updated>Sun, 19 Feb 2012 10:55:31 +0000</updated>
                    <resolved>Sat, 12 Nov 2011 14:10:18 +0000</resolved>
                            <version>3.4</version>
                <version>4.0-ALPHA</version>
                                <fixVersion>3.5</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="13114124" author="rcmuir" created="Sun, 25 Sep 2011 04:36:49 +0100"  >&lt;p&gt;if anyone wants to take this, don&apos;t hesitate!&lt;/p&gt;</comment>
                    <comment id="13114133" author="otis" created="Sun, 25 Sep 2011 05:31:30 +0100"  >&lt;p&gt;Would it be wise to stick with a name less specific than collapseSegments for example, in order not to have an incorrect name that requires another renaming when this &quot;command&quot; ends up doing something new in the future?&lt;/p&gt;</comment>
                    <comment id="13114154" author="rcmuir" created="Sun, 25 Sep 2011 06:28:56 +0100"  >&lt;p&gt;Otis: thats a good point, currently optimize is just a &quot;request&quot;, we should probably figure out what it &quot;should be&quot;.&lt;/p&gt;

&lt;p&gt;Should it be collapseSegments, which is a well-defined request without a cool sounding name?&lt;/p&gt;

&lt;p&gt;Or, should it be &amp;lt;something else&amp;gt;, which gives you a more optimal configuration for search performance... (i still think optimize is a bad name even for this)? Personally i suspect its going to be hard to support this case, e.g. you would really need to know things like, if the user has executionService set on the IndexSearcher and how big the threadpool is and things like that to make an &apos;optimal&apos; configuration... and we don&apos;t have a nice way of knowing that information today.&lt;/p&gt;</comment>
                    <comment id="13114165" author="shaie" created="Sun, 25 Sep 2011 07:53:55 +0100"  >&lt;p&gt;I personally find optimize() clear, and people got used to it already. However I do agree it sounds like it&apos;s doing magic, but really it just merges segments.&lt;/p&gt;

&lt;p&gt;We already have maybeMerge(), how about consolidating the two under merge(MergeLevel) where MergeLevel is either AGGRESSIVE (optimize) or DELICATE (maybeMerge)? Or something in that spirit.&lt;/p&gt;

&lt;p&gt;Anyway, if we end up renaming, we should probably rename MergePolicy.findSegmentsForOptimize as well. If we consolidate, we should consolidate it as well.&lt;/p&gt;</comment>
                    <comment id="13114184" author="thetaphi" created="Sun, 25 Sep 2011 09:47:09 +0100"  >&lt;p&gt;I like Shai&apos;s idea, let&apos;s remove optimize completely. maybeMerge has the ideal name.&lt;/p&gt;

&lt;p&gt;MergePolicy should then have only one method also getting this aggresiveness parameter.&lt;/p&gt;</comment>
                    <comment id="13114248" author="mikemccand" created="Sun, 25 Sep 2011 14:20:18 +0100"  >&lt;p&gt;How about maybeMerge() and maybeMerge(int maxSegCount) (since we have to absorb optimize(int maxSegCount) too)?&lt;/p&gt;

&lt;p&gt;This way what used to be optimize is now maybeMerge(1).&lt;/p&gt;

&lt;p&gt;I like that this forces the user to make an explicit decision about how many segments they require the index to merge down to, so they realize by picking 1 they are asking for tons of merging.&lt;/p&gt;</comment>
                    <comment id="13114266" author="shaie" created="Sun, 25 Sep 2011 15:09:30 +0100"  >&lt;p&gt;Fine. Can we use the opportunity to remove &apos;maybe&apos;? Just merge(). If it ends up doing nothing, it&apos;s still ok, with me at least.&lt;/p&gt;</comment>
                    <comment id="13114269" author="mikemccand" created="Sun, 25 Sep 2011 15:27:16 +0100"  >&lt;p&gt;Hmm... I like maybeMerge() better because it makes it clear that there may be no merging done?&lt;/p&gt;

&lt;p&gt;But maybe we can find a different word from maybe instead &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  mergeIfNeeded?&lt;/p&gt;</comment>
                    <comment id="13114283" author="shaie" created="Sun, 25 Sep 2011 17:00:31 +0100"  >&lt;p&gt;It&apos;s just that maybeMerge feels like asking a question, to which you expect an answer. Why is it so important to have this &apos;maybe&apos; or &apos;ifNeeded&apos; in the API? just like optimize(), MP decides what to merge, and optimize() can end up doing nothing as well ...&lt;/p&gt;

&lt;p&gt;Why do we have IR.reopen and not maybeReopen? That that it returns something is not much different than IW.merge(), IMO.&lt;/p&gt;</comment>
                    <comment id="13114290" author="eksdev" created="Sun, 25 Sep 2011 17:33:25 +0100"  >&lt;p&gt;as a user, &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;+1 to parameter, if you do not know what NooSegments mean, you shouldn&apos;t be invoking this method.&lt;/li&gt;
	&lt;li&gt;what about tryMerge(int ), attempMerge&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13114304" author="dmsmith" created="Sun, 25 Sep 2011 19:12:34 +0100"  >&lt;p&gt;When I started w/ Lucene, I read the docs and was drawn to call optimize because of its &quot;cool name.&quot; However, it was reading the documentation at the time that convinced me that it was appropriate for my use case:&lt;/p&gt;

&lt;p&gt;Creating an index that once created would never be modified. It needed to be as fast as possible for search on low performance computing devices (old laptops, ancient computers, netbooks, phones, ...).&lt;/p&gt;

&lt;p&gt;Maybe I misunderstood, but wasn&apos;t it and isn&apos;t it still appropriate for that?&lt;/p&gt;

&lt;p&gt;And I have no idea what NooSegments means.&lt;/p&gt;

&lt;p&gt;If you want a really uncool name how about dumbDown()?&lt;/p&gt;

&lt;p&gt;But either way, please document the appropriate use cases for it.&lt;/p&gt;</comment>
                    <comment id="13114323" author="mikemccand" created="Sun, 25 Sep 2011 19:59:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;Why do we have IR.reopen and not maybeReopen?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good point... and I actually don&apos;t like that naming either!!&lt;/p&gt;

&lt;p&gt;I think it trips users up because of it&apos;s hidden maybe-ness, ie, users who always close the old reader on calling this API (which, if no reopen actually occurred, closes the very same reader it had just returned).&lt;/p&gt;

&lt;p&gt;Also, IW already has a merge method, taking a OneMerge parameter; that naming I think is correct because it&apos;s unconditional: IW will carry out the merge you passed to it.&lt;/p&gt;

&lt;p&gt;Naming is the hardest part!&lt;/p&gt;</comment>
                    <comment id="13114347" author="markrmiller@gmail.com" created="Sun, 25 Sep 2011 20:53:23 +0100"  >&lt;p&gt;In spitball land... requestAggressiveMerge?&lt;/p&gt;</comment>
                    <comment id="13114391" author="sokolov" created="Mon, 26 Sep 2011 00:26:12 +0100"  >&lt;p&gt;squeeze()?  You apply some pressure - maybe it merges, and maybe it doesn&apos;t.  Depending how hard you squeeze.  squeeze(1) is squeezing harder than squeeze(10), which is a bit weird, but that&apos;s just down to units of squishiness.&lt;/p&gt;</comment>
                    <comment id="13114568" author="janhoy" created="Mon, 26 Sep 2011 10:56:59 +0100"  >&lt;p&gt;I&apos;ve seen people optimize after every single add(). Even the Django search framework Solango did this terrible mistake.&lt;br/&gt;
So I think renaming is welcome, and now that Lucene does such a good merging job for you most people won&apos;t need optimize. How about:&lt;/p&gt;

&lt;p&gt;reduceSegments(int numSegments)&lt;/p&gt;

&lt;p&gt;Does it convey the &quot;maybeness&quot; well enough? If I use it I need to know what a segment is and have some feeling for how many segments there are and how many I want, so its usage will imply some knowledge. But maybeMerge() works as well.&lt;/p&gt;</comment>
                    <comment id="13114617" author="doronc" created="Mon, 26 Sep 2011 13:22:00 +0100"  >&lt;p&gt;To me merge(num) doing nothing &quot;because there are already no more than n segments&quot; is as fine as close() doing nothing &quot;because of already being closed&quot; so +1 for merge(num).&lt;/p&gt;</comment>
                    <comment id="13137172" author="mindas" created="Thu, 27 Oct 2011 15:21:45 +0100"  >&lt;p&gt;What about &quot;defragment&quot;?&lt;/p&gt;</comment>
                    <comment id="13143564" author="rcmuir" created="Thu, 3 Nov 2011 22:17:48 +0000"  >&lt;p&gt;setting affects 3.x:&lt;/p&gt;

&lt;p&gt;Here&apos;s my +1 for a hard backwards break to remove this name.&lt;/p&gt;</comment>
                    <comment id="13143593" author="gsingers" created="Thu, 3 Nov 2011 23:13:38 +0000"  >&lt;p&gt;How about compactIndex()?&lt;/p&gt;</comment>
                    <comment id="13143654" author="mikemccand" created="Fri, 4 Nov 2011 00:34:16 +0000"  >&lt;p&gt;Patch.&lt;/p&gt;

&lt;p&gt;I picked the name &apos;mergeIfNeeded&apos;, and it requires you pass in the maxSegmentCount (so mergeIfNeeded(1) == what optimize() does today).&lt;/p&gt;

&lt;p&gt;All tests pass, including Solr, but Solr has tons of user-facing references still to &quot;optimize&quot; that I&apos;m not sure how to fix (I tried to remove all references to optimize in Lucene).&lt;/p&gt;

&lt;p&gt;I put nocommits for tests that need to be renamed... I&apos;ll do that at the last second so patching is easier.&lt;/p&gt;</comment>
                    <comment id="13143659" author="yseeley@gmail.com" created="Fri, 4 Nov 2011 00:56:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;but Solr has tons of user-facing references still to &quot;optimize&quot; that I&apos;m not sure how to fix&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s fine.  We probably shouldn&apos;t be changing Solr&apos;s external interfaces (and configuration options) for renamings like this.&lt;/p&gt;</comment>
                    <comment id="13143661" author="rcmuir" created="Fri, 4 Nov 2011 00:59:55 +0000"  >&lt;p&gt;Yonik: I&apos;m not sure? Jan&apos;s comment really hits home at why I opened this issue.&lt;/p&gt;

&lt;p&gt;I think its worth considering &quot;optimize&quot; command to throw an exception in Solr for this reason... we can add an expert option like mergeIfNeeded instead?&lt;/p&gt;

&lt;p&gt;I really think optimize is very dangerous because it sounds magical, the kind of thing that tempts new users into getting terrible performance,&lt;br/&gt;
instead it should be an expert thing.&lt;/p&gt;</comment>
                    <comment id="13143666" author="hossman" created="Fri, 4 Nov 2011 01:21:01 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think its worth considering &quot;optimize&quot; command to throw an exception in Solr for this reason... we can add an expert option like mergeIfNeeded instead?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I have mixed feelings on this ... Solr has really tried to ensure that the user level APIs (ie: HTTP params and the xml syntax) are either unaffected by under the cover changes, or provide good backcompat with warnings logged when people use &quot;deprecated&quot; syntax.&lt;/p&gt;

&lt;p&gt;But I would suggest that we start by keeping this issue focused on nailing down the java level issues in the &quot;lucene&quot; layer and get that committed.  Then when we&apos;re sure it&apos;s done and settled and happy, create a new issue for tracking the solr level API changes, with considerations like:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;should we log a deprecation warning to 3.x if &amp;lt;optimize&amp;gt; or param optimize=true is specified, and ignore in 4.x?&lt;/li&gt;
	&lt;li&gt;should the existing &apos;maxSegments&apos; attribute became an option on &quot;commit&quot; or add a new explicit &quot;merge&quot; command?&lt;/li&gt;
	&lt;li&gt;what do we do with postOptimize events listener registrations? log a deprecation warning, or rename and fire them if/when a merge to a single segment happens?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(my personal opinion, for any general change not just optimize, is to add new syntax to reflect the new world order, but as long as we &lt;b&gt;can&lt;/b&gt; support the old syntax we should &amp;#8211; with anoying warning logs)&lt;/p&gt;</comment>
                    <comment id="13143672" author="yseeley@gmail.com" created="Fri, 4 Nov 2011 01:37:30 +0000"  >&lt;p&gt;It&apos;s at least an order of magnitude more painful to change common external interfaces in Solr than in Lucene (or any other type-safe library).  &quot;optimize&quot; has been with us a very long time, and it should stay.  It should be both simple and effective enough to clarify the documentation if needed.  Changing the name would cause far more collective confusion and pain than the very small percent of people who might not understand when it&apos;s appropriate to call (and changing the name won&apos;t help them understand when it is appropriate!).&lt;/p&gt;

&lt;p&gt;On a side note: optimize still does just that - an index with fewer segments and deleted documents is still more efficient to search.  We just need to make sure to document the downsides as well.&lt;/p&gt;</comment>
                    <comment id="13143677" author="rcmuir" created="Fri, 4 Nov 2011 01:48:14 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Changing the name would cause far more collective confusion and pain than the very small percent of people who might not understand when it&apos;s appropriate to call (and changing the name won&apos;t help them understand when it is appropriate!).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And thats exactly my goal here: whatever it takes. I want to cause confusion so that people think twice before calling optimize. Because I totally disagree with you that its a small percentage of people that know when its appropriate to call, when integrations such as Jan&apos;s example call it after every commit: thats horrible.&lt;/p&gt;

&lt;p&gt;Thats why I think we should rename it in lucene, rename it in solr, but if people start pushing back thats fine. &lt;/p&gt;

&lt;p&gt;I can totally take this up myself with the blogging/email list route instead and intentionally cause so much fucking confusion that nobody will ever use this again.&lt;/p&gt;
</comment>
                    <comment id="13143682" author="yseeley@gmail.com" created="Fri, 4 Nov 2011 01:58:46 +0000"  >&lt;p&gt;There should be &lt;b&gt;extremely&lt;/b&gt; good reasons for changing Solr&apos;s external APIs - and this simply doesn&apos;t come close to rising to that level.&lt;/p&gt;</comment>
                    <comment id="13143684" author="rcmuir" created="Fri, 4 Nov 2011 02:01:00 +0000"  >&lt;p&gt;fine, then i&apos;m +1 to mike&apos;s patch.&lt;/p&gt;

&lt;p&gt;If solr wants to be slow, then it can stay slow, I&apos;m gonna stop fighting it.&lt;/p&gt;</comment>
                    <comment id="13143799" author="thetaphi" created="Fri, 4 Nov 2011 07:25:38 +0000"  >&lt;p&gt;My proposal would be to leave &quot;optimize&quot; in Solr, but make it a no-op. No code will break and Solr will just drop a warning not in the log.&lt;/p&gt;</comment>
                    <comment id="13143800" author="thetaphi" created="Fri, 4 Nov 2011 07:28:53 +0000"  >&lt;p&gt;The same could be done in 3.x of Lucene to prevent hard backwards breaks. As optimize does nothing to your index thats visible to the API/IndexReader/..., we could also meke IndexWriter.optimize() a no-op in Lucene 3.x and document it in the javadocs to do nothing anymore and that its only there to support binary backwards.&lt;/p&gt;</comment>
                    <comment id="13143816" author="rcmuir" created="Fri, 4 Nov 2011 08:06:50 +0000"  >&lt;blockquote&gt;
&lt;p&gt;very small percent of people who might not understand when it&apos;s appropriate to call&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are you saying only a small percentage of people use DataImportHandler or SpellChecker?&lt;/p&gt;

&lt;p&gt;Because both of these optimize by default on any operation... &lt;/p&gt;</comment>
                    <comment id="13143841" author="thetaphi" created="Fri, 4 Nov 2011 09:02:44 +0000"  >&lt;p&gt;Mike, about your patch:&lt;/p&gt;

&lt;p&gt;Would it make sense to remove the extra method completely from MergePolicy and simply do all in one method? By default, IW will call merge(maxSegments=Integer.MAX_VALUE) and when you call mergeIfNeeded&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; it would pass merge(maxSegments=n).&lt;/p&gt;

&lt;p&gt;Otherwise +1 to commmit. &lt;/p&gt;

&lt;p&gt;The stupid and horrible default optimizes in Solr should be handled in another SOLR-xxx issue.&lt;/p&gt;</comment>
                    <comment id="13143903" author="mikemccand" created="Fri, 4 Nov 2011 10:37:25 +0000"  >&lt;p&gt;OK let&apos;s leave this issue focused on Lucene only since changing Solr is contentious.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Would it make sense to remove the extra method completely from MergePolicy and simply do all in one method? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1, good idea!  I&apos;ll rework the patch.&lt;/p&gt;</comment>
                    <comment id="13143930" author="markrmiller@gmail.com" created="Fri, 4 Nov 2011 11:40:10 +0000"  >&lt;p&gt;Perhaps I am the only one, but I find these ifNeeded, mabyeThis, mabyeThat method names so ugly. I prefer JavaDoc for trying to catch the subtleties.&lt;/p&gt;

&lt;p&gt;+1 on compact as suggested by Grant or something like that. &lt;/p&gt;</comment>
                    <comment id="13143935" author="rcmuir" created="Fri, 4 Nov 2011 11:46:13 +0000"  >&lt;p&gt;But names like compact/vacuum/etc imply that its some sort of necessary maintenance routine...&lt;/p&gt;</comment>
                    <comment id="13143951" author="markrmiller@gmail.com" created="Fri, 4 Nov 2011 12:24:36 +0000"  >&lt;p&gt;Vacuum may because it&apos;s part of the db vocabulary - I don&apos;t think compact does at all. Beyond that, that is what javadocs are for. Personally, I don&apos;t think we need to try and design the api for complete morons that just call methods without reading the javadoc for what they do.&lt;/p&gt;</comment>
                    <comment id="13143953" author="markrmiller@gmail.com" created="Fri, 4 Nov 2011 12:27:05 +0000"  >&lt;p&gt;And if we want to keep thinking of the complete moron, I&apos;d make the same argument about mergeIfNeeded - the user might think these needs to be called all the time! My, it doesn&apos;t merge when needed? I better call this every couple seconds to make sure it merges when its needed! It&apos;s a ridiculous never ending path IMO.&lt;/p&gt;</comment>
                    <comment id="13143983" author="rcmuir" created="Fri, 4 Nov 2011 13:02:49 +0000"  >&lt;p&gt;I think a lot of damage has been done by the name being optimize: &lt;br/&gt;
e.g.: why does an &lt;b&gt;incremental&lt;/b&gt; DIH update trigger this by default?&lt;/p&gt;

&lt;p&gt;what sense does this make?&lt;/p&gt;

&lt;p&gt;You can keep lying to yourself that the only problem is complete morons, i&apos;m not buying it.&lt;/p&gt;</comment>
                    <comment id="13143988" author="shaie" created="Fri, 4 Nov 2011 13:11:52 +0000"  >&lt;p&gt;So now we ended up with mergeIfNeeded and maybeMerge()? At the start of this issue, it looks like we agreed to consolidate all methods under a single maybeMerge(). Mike suggested to have two variants of this, one that doesn&apos;t take maxNumSegments and one that does ... I&apos;m fine with that too, as long as we have a single name.&lt;/p&gt;

&lt;p&gt;I also agree with Mark, all these maybe&apos;s/ifNeeded (IR has these now too !) should be part of the Javadocs, not the method names. For instance, IW.rollback() closes the IndexWriter, but the method is not called rollbackAndClose. IMO, that is even more confusing than the IfNeeded versions, because I do not anticipate the instance to be closed just because I rolled-back changes.&lt;/p&gt;

&lt;p&gt;IndexReader.openIfNeeded in fact does reopen() (the old version), but it&apos;s not called reopenIfNeeded. So we force the users to read the javadocs in order to understand that openIfNeeded reuses the unchanged segments from the given IndexReader and only opens the new ones ...&lt;/p&gt;

&lt;p&gt;Names are hard, and I think we should opt for simple and intuitive ones. Javadocs should be used to clarify what the method does in more details. I personally was never confused by optimize(), so I don&apos;t mind if it&apos;s kept. But apparently others were confused by it (have no idea why) ...&lt;/p&gt;

&lt;p&gt;I don&apos;t mind maybeMerge() (perhaps because it&apos;s not a new API), but if we want to remove the maybe-ness, let&apos;s call it something like invokeMergePolicy() (with and without maxNumSegments)? We can replace invoke by some other verb, maybe consultMP / runMerges ...?&lt;/p&gt;</comment>
                    <comment id="13144027" author="yseeley@gmail.com" created="Fri, 4 Nov 2011 13:58:10 +0000"  >&lt;blockquote&gt;&lt;p&gt;e.g.: why does an incremental DIH update trigger this by default?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure...  If they actually meant for this to happen, this just reinforces my point that the name of the call is not the issue.  The guys who wrote DIH absolutely know what optimize does - hence if it was renamed they would have simply called maybeMerge(1) or whatever today.&lt;/p&gt;

&lt;p&gt;At the time it was written, and depending on what it was used for, maybe it did make sense.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;You can keep lying to yourself that the only problem is complete morons, i&apos;m not buying it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s exactly it - it&apos;s not morons, so a simple name change won&apos;t really help.  We need to document the &lt;b&gt;current&lt;/b&gt; tradeoffs so people can make more informed decisions about when to optimize.  And some people will &lt;b&gt;still&lt;/b&gt; chose to maybeMerge(1) when others think maybe they shouldn&apos;t.  That&apos;s OK.&lt;/p&gt;</comment>
                    <comment id="13144095" author="rcmuir" created="Fri, 4 Nov 2011 16:05:46 +0000"  >&lt;blockquote&gt;
&lt;p&gt;At the time it was written, and depending on what it was used for, maybe it did make sense.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You are missing the whole point, now it defaults to optimize on each incremental update, basically O(n^2) indexing performance,&lt;br/&gt;
unless the &lt;b&gt;user&lt;/b&gt; knows enough to know that optimize = shitty perf here and explicitly turn it off. and given its cool-sounding name,&lt;br/&gt;
it discourages them from even questioning that it could be making things slow.&lt;/p&gt;
</comment>
                    <comment id="13145024" author="mikemccand" created="Sun, 6 Nov 2011 15:52:38 +0000"  >
&lt;p&gt;How about the name &quot;forceMerge(int)&quot; instead?&lt;/p&gt;

&lt;p&gt;Fundamentally, this is a different operation from maybeMerge() because&lt;br/&gt;
that method only does &quot;natural&quot; merges, ie ones that the MP has&lt;br/&gt;
selected on its own.&lt;/p&gt;

&lt;p&gt;Whereas forceMerge means you are forcing the MP to do merging that it&lt;br/&gt;
otherwise would not have naturally chosen to do.&lt;/p&gt;

&lt;p&gt;I don&apos;t like names like compact/defragment since they still imply this&lt;br/&gt;
is a sort of necessary periodic maintenance that you are expected / need&lt;br/&gt;
to call.&lt;/p&gt;

&lt;p&gt;The fact is, Lucene has made excellent progress on getting good&lt;br/&gt;
performance on multi-segment indexes: Query rewriting (eg MTQ) and&lt;br/&gt;
searching is per-segment.  TieredMP now targets segments with&lt;br/&gt;
deletions, and can merge out-of-order, etc.  Reducing the index down&lt;br/&gt;
to 1 segment is rarely justified given the cost (yes, there are times,&lt;br/&gt;
like a fully static index, but this is rare).&lt;/p&gt;

&lt;p&gt;The goal here is to discourage &quot;typical&quot; users from calling&lt;br/&gt;
optimize (&quot;expert&quot; users will of course find the method and use it,&lt;br/&gt;
hopefully in the &quot;right&quot; cases).&lt;/p&gt;

&lt;p&gt;The API is badly trappy today; we&apos;ve seen this over and over now (I&lt;br/&gt;
just got a private email a few days ago... when I asked why they&lt;br/&gt;
optimize after every &quot;batch&quot; they said &quot;because it just seemed like&lt;br/&gt;
the right thing to do&quot;).  We&apos;ve all seen many users fall into this&lt;br/&gt;
trap.&lt;/p&gt;

&lt;p&gt;We can try to debate why this is so... I don&apos;t think it&apos;s because they&lt;br/&gt;
are &quot;morons&quot;.  I think there are many other explanations.  EG, our own&lt;br/&gt;
FAQs, javadocs, the Lucene in Action book, tutorials, etc., all&lt;br/&gt;
frequently &quot;suggested&quot; optimize in the past.  I think, also, users&lt;br/&gt;
often don&apos;t realize Lucene has &quot;segments&quot; and that optimize means&lt;br/&gt;
these segments are &quot;fully rewritten&quot; and that this then implies O(N^2)&lt;br/&gt;
cost if you call after every doc/batch, etc.  These things are obvious&lt;br/&gt;
to Lucene developers, but not so to users.&lt;/p&gt;</comment>
                    <comment id="13145027" author="mikemccand" created="Sun, 6 Nov 2011 15:59:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;For instance, IW.rollback() closes the IndexWriter, but the method is not called rollbackAndClose.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, this is bad, because it&apos;s unexpected that the IW is closed: I&lt;br/&gt;
think we should rename it to rollbackAndClose (I&apos;ll open a separate&lt;br/&gt;
issue).&lt;/p&gt;</comment>
                    <comment id="13145047" author="doronc" created="Sun, 6 Nov 2011 17:17:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;Perhaps I am the only one, but I find these ifNeeded, mabyeThis, mabyeThat method names so ugly. I prefer JavaDoc for trying to catch the subtleties.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I feel that way too.&lt;/p&gt;

&lt;p&gt;But a name change here seems in place, because as pointed above, there is an issue with current catchy name &lt;b&gt;optimize()&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;My personal preference between the names suggested above is Mike&apos;s last one: &lt;b&gt;forceMerge(int)&lt;/b&gt;:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it describes what&apos;s done&lt;/li&gt;
	&lt;li&gt;does not suggest to do wonders&lt;/li&gt;
	&lt;li&gt;requires caller to think twice because of deciding to force a certain behavior&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13145078" author="shaie" created="Sun, 6 Nov 2011 19:02:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;How about the name &quot;forceMerge(int)&quot; instead?&lt;/p&gt;

&lt;p&gt;Fundamentally, this is a different operation from maybeMerge() because&lt;br/&gt;
that method only does &quot;natural&quot; merges, ie ones that the MP has&lt;br/&gt;
selected on its own.&lt;/p&gt;

&lt;p&gt;Whereas forceMerge means you are forcing the MP to do merging that it&lt;br/&gt;
otherwise would not have naturally chosen to do.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure that I agree ... I could set MP in such a way that forceMerge(1) would still do nothing. That&apos;s very simple in fact, and I do this today. I set LogMP&apos;s maxMergeMB(ForOptimize) to 4GB, which means that I never end up merging segments larger than that. I call optimize() whenever I can, but at some point, optimize will do nothing (if the indexing process stops), or after my index grew a lot, many segments won&apos;t be merged, and optimize/forceMerge(1) will actually end up with X+1 segments, where X is the number of segments that are too large for me to merge.&lt;/p&gt;

&lt;p&gt;Therefore I&apos;m not sure that trading optimize for forceMerge is much better. Sure, it has a less cool name, but now I think it will be even more confusing, because I&apos;ll call forceMerge(1) and that won&apos;t do what I asked.&lt;/p&gt;

&lt;p&gt;I think that the problem is that we try to come up with names that reflect what API we IndexWriter should call on MP. That&apos;s why we try to distinguish between maybeMerge() and optimize(int). So maybe we should go for a more extreme change &amp;#8211; how about having one method merge() which takes a MergePolicy with a single method findSegmentsForMerge(). We will provide MPs that are good for &apos;regular&apos; merges and &apos;optimize&apos; and the user can pass whatever he wishes to do. The user can also pass the same MP instance to IWC, and that will control the regular merges IW does from time to time (we default to a &apos;regular&apos; merging MP).&lt;/p&gt;

&lt;p&gt;Just a thought.&lt;/p&gt;</comment>
                    <comment id="13145108" author="markrmiller@gmail.com" created="Sun, 6 Nov 2011 21:06:46 +0000"  >&lt;p&gt;I like forceMerge. I&apos;m not opposed to renaming optimize, just one of the candidates so far and some of the new method names in general. Optimize is not the best description IMO regardless of how catchy it is. It&apos;s not really optimal for NRT as just one of many points...&lt;/p&gt;</comment>
                    <comment id="13145111" author="mikemccand" created="Sun, 6 Nov 2011 21:17:29 +0000"  >&lt;p&gt;Some quick googling uncovers depressing examples of over-optimizing:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jira.duraspace.org/browse/FCREPO-155&quot; class=&quot;external-link&quot;&gt;https://jira.duraspace.org/browse/FCREPO-155&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3912253/is-it-mandatory-to-optimize-the-lucene-index-after-write&quot; class=&quot;external-link&quot;&gt;http://stackoverflow.com/questions/3912253/is-it-mandatory-to-optimize-the-lucene-index-after-write&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://issues.liferay.com/browse/LPS-2944&quot; class=&quot;external-link&quot;&gt;http://issues.liferay.com/browse/LPS-2944&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://download.oracle.com/docs/cd/E19316-01/820-7054/girqf/index.html&quot; class=&quot;external-link&quot;&gt;http://download.oracle.com/docs/cd/E19316-01/820-7054/girqf/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.sonatype.org/browse/MNGECLIPSE-2359&quot; class=&quot;external-link&quot;&gt;https://issues.sonatype.org/browse/MNGECLIPSE-2359&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.inflinx.com/tag/lucene&quot; class=&quot;external-link&quot;&gt;http://blog.inflinx.com/tag/lucene&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That last one has this fun comment:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  // Lucene recommends calling optimize upon completion of indexing writer.optimize();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13145138" author="markrmiller@gmail.com" created="Sun, 6 Nov 2011 22:31:27 +0000"  >&lt;p&gt;I&apos;m not sure sure that is a strong case.&lt;/p&gt;

&lt;p&gt;The ones that mention optimizing after loading all your data is practically what had been often recommended for some time. Can&apos;t say the same about optimizing after every add.&lt;/p&gt;

&lt;p&gt;However, up to most of Lucene 2, we still had JavaDoc that said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an index will not have more documents added for a while and optimal search performance is desired, then the optimize method should be called before the index is closed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Based on that, I&apos;d likely think I should optimize after bulk loading up all my data like one of those links asks about.&lt;/p&gt;

&lt;p&gt;The optimize javadoc itself even simply said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Requests an &quot;optimize&quot; operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since, much of this javadoc had gotten better. But it&apos;s no surprise that there are cases of confusion out there? Most of those are from before this javadoc was fixed - and even then the old code and javaodoc/advice are out there reverberating around on google.&lt;/p&gt;

&lt;p&gt;The situation with the javadoc is much better today - someone shouldn&apos;t need to ask those questions, or have those problems, but the &lt;b&gt;javadoc&lt;/b&gt; used to be a trap in showing this great optimize method and not properly explaining or warning about its use.&lt;/p&gt;

&lt;p&gt;Creating method names for cowboy method calling coders that don&apos;t read javadoc seems like the wrong approach to me.&lt;/p&gt;

&lt;p&gt;Though I&apos;m still +1 on renaming optimize to something more fitting.&lt;/p&gt;</comment>
                    <comment id="13145222" author="shaie" created="Mon, 7 Nov 2011 04:33:58 +0000"  >&lt;p&gt;Well ... I don&apos;t like forceMerge for two reasons: (1) it may not actually force anything and (2) it takes a parameter maxNumSegments which is just one of the factors one would want to consider when doing optimize/merge. For instance, when I do index optimization, I cap the process by a time constraint and let it run until the time is exhausted. Given that today I can either call maybeMerge() or optimize(), I call optimize(), and I like it that I don&apos;t need to pass any &apos;fake&apos; parameter, even though I&apos;m aware that under the covers it does optimize(1).&lt;/p&gt;

&lt;p&gt;What about expungeDeletes? Why is it not called maybeExpungeDeletes? Because by tweaking MP settings I can make it leave some deletes in segments. And why isn&apos;t it called expungeDeletesThenMerge or expungeDeletesNoMerge (ala the now gone addIndexesNoOptimize)? Don&apos;t get me wrong (before anyone opens an issue to rename it too) - I like expungeDeletes! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I feel that we mask from the user what happens under the covers when he calls any of the 3 methods (maybMerge, optimize, expungeDeletes). maybeMerge relate to mergeFactor as a bounding criteria (don&apos;t merge if there are aren&apos;t X segments at the same level), while optimize just uses it to determine how many segments to merge at once, and expungeDeletes ignores it altogether.&lt;/p&gt;

&lt;p&gt;So if MP determines so much what will happen when IndexWriter calls it, why hide it from the method call? Instead of setting an MP once on IWC and hope that the settings I&apos;ve done will match any future call to one of these methods, why not allow the user to pass the desired MP for the action he wants to perform? That way we can focus MP implementations on specific tasks.&lt;/p&gt;</comment>
                    <comment id="13145646" author="mikemccand" created="Mon, 7 Nov 2011 17:52:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;I could set MP in such a way that forceMerge(1) would still do nothing. That&apos;s very simple in fact, and I do this today.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, but remember: 1) this is the exception case (not the rule), and&lt;br/&gt;
2) you are an expert user.&lt;/p&gt;

&lt;p&gt;We should name our APIs according to what they &quot;typically&quot; do, not by&lt;br/&gt;
the exceptional cases, which can and should be handled by javadocs&lt;br/&gt;
(for example, that you must close your IW if you hit OOME during&lt;br/&gt;
addDocument).&lt;/p&gt;

&lt;p&gt;The expert users (like you) who are bumping up against these&lt;br/&gt;
exceptions can easily understand and handle them.&lt;/p&gt;

&lt;p&gt;I think forceMerge(int) does a pretty good job explaining what the MP&lt;br/&gt;
is going to try to do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think that the problem is that we try to come up with names that reflect what API we IndexWriter should call on MP. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, optimize() is really sugar for &quot;invoking the current MP and do&lt;br/&gt;
whatever it says&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So maybe we should go for a more extreme change &#8211; how about having one method merge() which takes a MergePolicy with a single method findSegmentsForMerge().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a great idea!  But I think we should pursue it under a new&lt;br/&gt;
issue, after renaming the optimize method?  It&apos;s a bigger change.&lt;/p&gt;

&lt;p&gt;If we took this approach... I think IW would still need a &quot;default MP&quot;&lt;br/&gt;
that it uses to kick off natural merges over time?  (Ie, after a new&lt;br/&gt;
segment is flushed).&lt;/p&gt;

&lt;p&gt;Alternatively, we could have this extra MP sit fully &quot;outside&quot; of IW,&lt;br/&gt;
and so instead of calling IW.merge(MP) you&apos;d call MP.merge(IW), and&lt;br/&gt;
that &quot;foreign&quot; MP would register merges with IW?  Still, it&apos;s gonna&lt;br/&gt;
get tricky, how the &quot;natural&quot; MP interacts with this foreign MP.&lt;/p&gt;

&lt;p&gt;Or... maybe we remove IW.optimize, and instead open up a method on&lt;br/&gt;
each MP impl (eg MP.forceMerge(int)), and you invoke this method on&lt;br/&gt;
the MP instead?  This way you still have the one MP, but IW doesn&apos;t&lt;br/&gt;
need to expose hard-to-name sugar?  Still sounds tricky though... the&lt;br/&gt;
MP would ask IW to maybeMerge&lt;/p&gt;</comment>
                    <comment id="13146106" author="shaie" created="Tue, 8 Nov 2011 06:36:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;Sure, but remember: 1) this is the exception case (not the rule)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree ... I find myself more and more these days telling people to limit their merge size because of performance issues, whether it&apos;s for optimize/maybeMerge. Therefore I don&apos;t think it&apos;s the exception case, or will remain like that for long.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think forceMerge(int) does a pretty good job explaining what the MP is going to try to do.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is that a Javadoc statement? Because we could have just fixed optimize() javadocs without adding API that sort of commits to something that may not happen.&lt;/p&gt;

&lt;p&gt;How about naming it doMaintenance?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
If we took &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; approach... I think IW would still need a &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; MP&quot;&lt;/span&gt;
that it uses to kick off natural merges over time? (Ie, after a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;
segment is flushed).
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sure, we will provide the best MP for doing natural/regular merges which will be the default of IWC.&lt;/p&gt;

&lt;p&gt;I agree this route is bigger than just renaming optimize(), and I don&apos;t think that we need to change the interaction between IW and MP. But let&apos;s handle that in a separate issue.&lt;/p&gt;</comment>
                    <comment id="13146664" author="mikemccand" created="Tue, 8 Nov 2011 23:49:51 +0000"  >
&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Sure, but remember: 1) this is the exception case (not the rule)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree ... I find myself more and more these days telling people to limit their merge size because of performance issues, whether it&apos;s for optimize/maybeMerge. Therefore I don&apos;t think it&apos;s the exception case, or will remain like that for long.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But today, in 3.x or trunk (ie TieredMergePolicy), if you call&lt;br/&gt;
forceMerge(N) this will in fact merge away until you have &amp;lt;= N&lt;br/&gt;
segments.&lt;/p&gt;

&lt;p&gt;I think if you use either LogDoc/ByteSizeMergePolicy, forceMerge also&lt;br/&gt;
does what it says.  It&apos;s only if you change their maxMBForOptimize from&lt;br/&gt;
the default, and you have a large enough index to hit that limit, that&lt;br/&gt;
forceMerge(1) may in fact produce more than one segment.&lt;/p&gt;

&lt;p&gt;So, sure, if you go and change the settings, swap in a different&lt;br/&gt;
MergePolicy, etc., you can make it so IW.forceMerge(int) does&lt;br/&gt;
something totally different.  But that&apos;s the exception, not the rule;&lt;br/&gt;
that&apos;s what the &quot;experts&quot; do, not the normal users who use the&lt;br/&gt;
defaults.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I think forceMerge(int) does a pretty good job explaining what the MP is going to try to do.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is that a Javadoc statement? Because we could have just fixed optimize() javadocs without adding API that sort of commits to something that may not happen.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think in the javadocs we should explain that forceMerge just asks&lt;br/&gt;
the MP to pick merges, passing the minSegmentCount, ie explain the&lt;br/&gt;
&quot;exception case&quot; via javadocs and let the method name explain the&lt;br/&gt;
common case.  I think this is in general how we should name our&lt;br/&gt;
methods...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How about naming it doMaintenance?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t really like that choice, for the same reason I don&apos;t like&lt;br/&gt;
defragment/compact: it implies you (the app) are expected to&lt;br/&gt;
periodically call it, whereas forced merging is very much an optional&lt;br/&gt;
operation since Lucene works so well against multi-segment indexes&lt;br/&gt;
these days.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If we took this approach... I think IW would still need a &quot;default MP&quot; that it uses to kick off natural merges over time? (Ie, after a new segment is flushed).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, we will provide the best MP for doing natural/regular merges which will be the default of IWC.&lt;/p&gt;

&lt;p&gt;I agree this route is bigger than just renaming optimize(), and I don&apos;t think that we need to change the interaction between IW and MP. But let&apos;s handle that in a separate issue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you open a new issue so we can explore the foreign-MP idea?&lt;br/&gt;
Replacing optimize/forceMerge and expungeDeletes with a new&lt;br/&gt;
&quot;merge(MP)&quot; seems compelling.&lt;/p&gt;

&lt;p&gt;Let&apos;s leave this issue on the simple renaming....&lt;/p&gt;</comment>
                    <comment id="13146842" author="shaie" created="Wed, 9 Nov 2011 08:16:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;Can you open a new issue so we can explore the foreign-MP idea?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will.&lt;/p&gt;</comment>
                    <comment id="13147625" author="mikemccand" created="Thu, 10 Nov 2011 11:50:24 +0000"  >&lt;p&gt;OK, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3569&quot; title=&quot;Consolidate IndexWriter&amp;#39;s optimize, maybeMerge and expungeDeletes under one merge(MP) method&quot;&gt;LUCENE-3569&lt;/a&gt; will explore the foreign MergePolicy approach.&lt;/p&gt;

&lt;p&gt;Back to this issue... we won&apos;t be able to find a name that everyone&lt;br/&gt;
loves, of course (this is why naming is the hardest part!).&lt;/p&gt;

&lt;p&gt;But forceMerge got at least some traction (3 people OK&apos;d it), and it&lt;br/&gt;
does explain what you get from Lucene today, out of the box.  I think&lt;br/&gt;
it&apos;s a good improvement over what we have today (optimize).  Progress&lt;br/&gt;
not perfection...&lt;/p&gt;

&lt;p&gt;Shai, are you absolutely dead set against the name &quot;forceMerge&quot;?  I&lt;br/&gt;
mean it&apos;s clear you&apos;d like to do a bigger change (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3569&quot; title=&quot;Consolidate IndexWriter&amp;#39;s optimize, maybeMerge and expungeDeletes under one merge(MP) method&quot;&gt;LUCENE-3569&lt;/a&gt;), but in&lt;br/&gt;
the mean time, forceMerge is at least better than optimize?&lt;/p&gt;

&lt;p&gt;And if you are dead set against it, can you enumerate some alternative&lt;br/&gt;
names?  We need to find a name that nobody hates (hopefully&lt;br/&gt;
possible)... not one that everybody loves (not possible).&lt;/p&gt;

&lt;p&gt;Naming is the hardest part &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13147649" author="shaie" created="Thu, 10 Nov 2011 12:58:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;Shai, are you absolutely dead set against the name &quot;forceMerge&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, I am not dead set against it. Feel free to proceed with forceMerge for now, because I don&apos;t want to hold up this issue.&lt;/p&gt;

&lt;p&gt;Obviously I&apos;m on the minority side ...&lt;/p&gt;</comment>
                    <comment id="13147665" author="mikemccand" created="Thu, 10 Nov 2011 13:19:54 +0000"  >&lt;p&gt;OK thanks Shai. I&apos;ll work up a new patch...&lt;/p&gt;</comment>
                    <comment id="13147899" author="mikemccand" created="Thu, 10 Nov 2011 18:38:04 +0000"  >&lt;p&gt;OK, new patch with &quot;forceMerge&quot;.  I think it&apos;s ready to commit!&lt;/p&gt;

&lt;p&gt;I left the MergePolicy method separate (renamed to findForcedMerges);&lt;br/&gt;
I&apos;m not sure we should merge it with the findMerges since that one&lt;br/&gt;
finds &quot;natural&quot; merges.  But we can explore on a new issue... this&lt;br/&gt;
patch is immense and &quot;rote&quot; renaming so I plan commit soon...&lt;/p&gt;

&lt;p&gt;The patch should be applyable; I generated with &quot;svn diff&lt;br/&gt;
--show-copies-as-adds&quot; (svn 1.7).&lt;/p&gt;</comment>
                    <comment id="13157777" author="thetaphi" created="Sun, 27 Nov 2011 12:29:30 +0000"  >&lt;p&gt;Bulk close after release of 3.5&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12543236">SOLR-3141</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12503267" name="LUCENE-3454.patch" size="280595" author="mikemccand" created="Thu, 10 Nov 2011 18:38:04 +0000" />
                    <attachment id="12502247" name="LUCENE-3454.patch" size="207602" author="mikemccand" created="Fri, 4 Nov 2011 00:34:16 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 25 Sep 2011 04:31:30 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2377</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24242</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>