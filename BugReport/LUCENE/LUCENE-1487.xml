<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:57:18 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1487/LUCENE-1487.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1487] FieldCacheTermsFilter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1487</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is a companion to FieldCacheRangeFilter except it operates on a set of terms rather than a range. It works best when the set is comparatively large or the terms are comparatively common.&lt;/p&gt;
</description>
                <environment></environment>
            <key id="12410404">LUCENE-1487</key>
            <summary>FieldCacheTermsFilter</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="tsturge">Tim Sturge</reporter>
                        <labels>
                    </labels>
                <created>Wed, 10 Dec 2008 21:18:19 +0000</created>
                <updated>Wed, 24 Jun 2009 00:00:02 +0100</updated>
                    <resolved>Tue, 23 Jun 2009 22:09:51 +0100</resolved>
                            <version>2.4</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12655369" author="tsturge" created="Wed, 10 Dec 2008 21:31:02 +0000"  >&lt;p&gt;FieldCacheTermsFilter  using OpenBitSet.fastGet()&lt;/p&gt;</comment>
                    <comment id="12655517" author="otis" created="Thu, 11 Dec 2008 05:22:15 +0000"  >&lt;p&gt;Would it be possible to reformat to use Lucene code style and add a bit of javadoc/unit test?  Eclipse and IDEA styles are at the bottom of &lt;a href=&quot;http://wiki.apache.org/lucene-java/HowToContribute&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/HowToContribute&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12655757" author="tsturge" created="Thu, 11 Dec 2008 19:55:02 +0000"  >&lt;p&gt;No problem at all. Should I assume this means that the idea is generally considered sound; the only question is getting something with sufficient tests/docs/level of finish?&lt;/p&gt;

&lt;p&gt;I was expecting to get comments about the implementation first; last time what ended up going in was very different (in good ways) from my initial submission. &lt;/p&gt;
</comment>
                    <comment id="12655760" author="markrmiller@gmail.com" created="Thu, 11 Dec 2008 20:10:37 +0000"  >&lt;p&gt;Hold out Tim, your likely to get further comments before it goes in. I think Otis was just suggesting we start with those changes. Once your code is in the right format, your more likely to get a committer to spend some time with it. Sometimes we just reformat and add the tests ourselves depending on a host of factors, but in general, your more likely to get good comments  faster if that work has already been done.&lt;/p&gt;

&lt;p&gt;Its a fair question to ask if the idea is sound, but just posting the work doesn&apos;t necessarily imply that you are looking for that advice before putting more work into what you have done. And many times questions do go unanswered, they are missed, people don&apos;t have the time at the moment - so its best to supply all of this stuff, unless you are prepared for a wait if their is no current interest in going over the patch.&lt;/p&gt;</comment>
                    <comment id="12655851" author="tsturge" created="Fri, 12 Dec 2008 01:50:30 +0000"  >&lt;p&gt;I&apos;m running a bit behind this week and I&apos;m out most of next week so it may be a while before I get to this.&lt;/p&gt;

&lt;p&gt;One thing I hope will be helpful in the interim is to repost here the java-dev exchange that lead to me posting this here; I suspect that many people who watch JIRA don&apos;t necessarily read java-dev as well and I hope the postings are informative.&lt;/p&gt;

&lt;p&gt;Here&apos;s the exchange:&lt;/p&gt;

&lt;p&gt;On 12/10/08 1:13 PM, &quot;Tim Sturge&quot; &amp;lt;tsturge@hi5.com&amp;gt; wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; Yes (mostly). It turns those terms into an OpenBitSet on the term array.&lt;br/&gt;
&amp;gt; Then it does a fastGet() in the next() and skipTo() loops to see if the term&lt;br/&gt;
&amp;gt; for that document is in the set.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; The issue is that fastGet() is not as fast as the two inequalities in FCRF.&lt;br/&gt;
&amp;gt; I didn&apos;t directly benchmark FCTF against FCRF because I had a different&lt;br/&gt;
&amp;gt; application in mind for FCTF (location boxes). However it wasn&apos;t as&lt;br/&gt;
&amp;gt; efficient in that case as directly realizing the bit sets. This was mostly&lt;br/&gt;
&amp;gt; because in the application I had in mind there were a lot (&amp;gt;100K) of terms&lt;br/&gt;
&amp;gt; with relatively low frequency and queries that needed only a few hundred&lt;br/&gt;
&amp;gt; terms in the set.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I tried a sorted list of terms and Arrays.binarySearch() but that is way&lt;br/&gt;
&amp;gt; slower as is Set&amp;lt;Integer&amp;gt; (no surprise there). I was thinking about a custom&lt;br/&gt;
&amp;gt; hash table implementation but I&apos;m not hopeful; it increases cycle cost and&lt;br/&gt;
&amp;gt; means &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; So it is efficient but for a more limited set of cases than FCRF. My gut&lt;br/&gt;
&amp;gt; feeling is that FCRF is a better solution for &quot;most&quot; range filters, whereas&lt;br/&gt;
&amp;gt; FCTF is a better solution for &quot;some&quot; term set filters (versus creating&lt;br/&gt;
&amp;gt; TermsFilter objects on the fly each time) It all depends on how common the&lt;br/&gt;
&amp;gt; terms are and how large the sets of terms are. Lots of terms (or a few very&lt;br/&gt;
&amp;gt; common terms) it wins. A few less common terms it loses.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;ll open a JIRA issue for it.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Tim&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; On 12/10/08 12:45 PM, &quot;Michael McCandless&quot; &amp;lt;lucene@mikemccandless.com&amp;gt;&lt;br/&gt;
&amp;gt; wrote:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; It&apos;d be great to get this into Lucene.&lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; Does FieldCacheTermsFilter let you specify a set of arbitrary terms to&lt;br/&gt;
&amp;gt;&amp;gt; filter for, like TermsFilter in contrib/queries?  And it&apos;s space/time&lt;br/&gt;
&amp;gt;&amp;gt; efficient once FieldCache is populated?&lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; Mike&lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; Tim Sturge wrote:&lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; Mike, Mike,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; I have an implementation of FieldCacheTermsFilter (which uses field&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; cache to&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; filter for a predefined set of terms) around if either of you are&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; interested. It is faster than materializing the filter roughly when&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; filter matches more than 1% of the documents.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; So it&apos;s not better for a large set of small filters (which you can&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; materialize on the spot) but it is better for a small set (but more&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; than 32)&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; large filters.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; Let me know if you&apos;re interested and I&apos;ll send it in.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; Tim&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; On 12/10/08 3:34 AM, &quot;Michael McCandless&quot;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;lt;lucene@mikemccandless.com&amp;gt; wrote:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; In your approach, roughly how many filters do you have cached?  It&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; seems like it could be quite a few (one for each color, one for each&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; type, etc)?&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; You might be able to modify the new (on Lucene trunk)&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; FieldCacheRangeFilter to achieve this same filtering without actually&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; having to materialize the full bitset for each.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; Mike&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; Michael Stoppelman wrote:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Yeah looks similar to what we&apos;ve implemented for ourselves&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; (although I&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; haven&apos;t looked at the implementation). We&apos;ve got quite a custom&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; version of&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; lucene at this point. Using Solr at this point really isn&apos;t a viable&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; option,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; but thanks for pointing this out.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; M&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; On Tue, Dec 9, 2008 at 1:47 AM, Michael McCandless &amp;lt;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; lucene@mikemccandless.com&amp;gt; wrote:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; This use case sounds alot like faceted navigation, which Solr&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; provides.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Mike&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Michael Stoppelman wrote:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Hi all,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; I&apos;m working on upgrading to Lucene 2.4.0 from 2.3.2 and was trying&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; to&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; integrate the new DodIdSet changes since&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; o.a.l.search.Filter#bits() method&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; is now depreciated. For our app we actually heavily rely on bits&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; from the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Filter to do post-query filtering (I explain why below).&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; For example, if someone searches for product: &quot;ipod&quot; and then&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; filters a&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; type: &quot;nano&quot; (e.g. mini/nano/regular) AND color: &quot;red&quot; (e.g.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; red/yellow/blue). In our current model the results are gathered in&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; following way:&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 1) &quot;ipod&quot; w/o attributes is run and the results are stored in a&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hitcollector&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 2) &quot;ipod&quot; results are now filtered for color=&quot;red&quot; AND type=&quot;mini&quot;&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; using&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; lucene Filters&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 3) The filtered results are returned to the user.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; The reason that the attributes are filtered post-query is so that&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; we can&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; return the other types and colors the user can filter by in the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; future.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Meaning the UI would be able to show &quot;blue&quot;, &quot;green&quot;, &quot;pink&quot;,&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; etc... if we&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; pre-filtered results by color and type before hand we wouldn&apos;t&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; know what&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; the&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; other filter options would be there for a broader result set.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Does anyone else have this use case? I&apos;d imagine other folks are&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; probably&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; doing similar things to accomplish this.&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; M&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; ---------------------------------------------------------------------&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; For additional commands, e-mail: java-user-help@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; ---------------------------------------------------------------------&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; For additional commands, e-mail: java-user-help@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; ---------------------------------------------------------------------&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; For additional commands, e-mail: java-user-help@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt;&amp;gt; ---------------------------------------------------------------------&lt;br/&gt;
&amp;gt;&amp;gt; To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt; For additional commands, e-mail: java-user-help@lucene.apache.org&lt;br/&gt;
&amp;gt;&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; ---------------------------------------------------------------------&lt;br/&gt;
&amp;gt; To unsubscribe, e-mail: java-user-unsubscribe@lucene.apache.org&lt;br/&gt;
&amp;gt; For additional commands, e-mail: java-user-help@lucene.apache.org&lt;br/&gt;
&amp;gt; &lt;/p&gt;</comment>
                    <comment id="12655854" author="tsturge" created="Fri, 12 Dec 2008 02:00:38 +0000"  >&lt;p&gt;Mark, Otis, looking back over the bug history I totally see where you are coming from; I do look like I&apos;ve just dumped this here without explanation which wasn&apos;t my intention.&lt;/p&gt;

&lt;p&gt;Honestly I don&apos;t really know how useful this is; I think there&apos;s a set of cases where it works very well but how comparatively large that set is I am unsure. You can think of it as adding a level of indirection (from documents to terms) to filtering. &lt;/p&gt;

&lt;p&gt;The alternative (at least as far as I can see) is to do a union by term of sorted docid lists (which is fundamentally what a DisjunctionQuery does I think). There may well be other options.&lt;/p&gt;
</comment>
                    <comment id="12655942" author="mikemccand" created="Fri, 12 Dec 2008 09:53:23 +0000"  >&lt;p&gt;I think this is a useful filter impl, and a nice companion to FCRF.&lt;br/&gt;
I&apos;d like to see it committed; formatting &amp;amp; test case are good next&lt;br/&gt;
steps.&lt;/p&gt;

&lt;p&gt;TermsFilter (in contrib/queries) does the same thing, but creates a&lt;br/&gt;
bitset by docID up front by walking the TermDocs for each term.  An OR&lt;br/&gt;
query, wrapped in QueryWrapperFilter, is another way.&lt;/p&gt;

&lt;p&gt;This impl uses FieldCache to create a bitset by term number and then&lt;br/&gt;
does a scan by docID, so it has different performance tradeoffs: for&lt;br/&gt;
&quot;enum&quot; fields (far more docs than unique terms &amp;#8211; like country, state,&lt;br/&gt;
etc.) it&apos;s fast to create this filter, and then applying the filter is&lt;br/&gt;
O(maxDocs) with a small constant factor.&lt;/p&gt;

&lt;p&gt;I think for many apps it means you do not have to cache the filter&lt;br/&gt;
because creating &amp;amp; using it &quot;on the fly&quot; is plenty fast.&lt;/p&gt;
</comment>
                    <comment id="12656043" author="yseeley@gmail.com" created="Fri, 12 Dec 2008 15:42:56 +0000"  >&lt;p&gt;I think the name should be different since it only works with single-valued fields, unlike other TermFilters and TermQueries.&lt;/p&gt;</comment>
                    <comment id="12656139" author="tsturge" created="Fri, 12 Dec 2008 19:55:25 +0000"  >&lt;p&gt;Reformatted version. I&apos;m happy to change the name if that&apos;s the consensus but I can&apos;t think of any better alternatives right now.&lt;/p&gt;</comment>
                    <comment id="12656397" author="mikemccand" created="Sun, 14 Dec 2008 15:42:11 +0000"  >&lt;p&gt;Yonik do you have any suggestions for a new name (I agree a new name would be better but can&apos;t think of one offhand).&lt;/p&gt;</comment>
                    <comment id="12656406" author="yseeley@gmail.com" created="Sun, 14 Dec 2008 16:25:15 +0000"  >&lt;p&gt;FieldCacheStringFilter?&lt;br/&gt;
FieldCacheValueFilter?&lt;br/&gt;
FieldCacheMatchFilter?&lt;/p&gt;

&lt;p&gt;Not sure if any of those are better though.  Perhaps it&apos;s enough that &quot;FieldCache&quot; is in the name to indicate that it only works on single-valued indexed fields that are able to be cached by the FieldCache.&lt;/p&gt;</comment>
                    <comment id="12657007" author="mikemccand" created="Tue, 16 Dec 2008 15:05:01 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Perhaps it&apos;s enough that &quot;FieldCache&quot; is in the name to indicate that it only works on single-valued indexed fields that are able to be cached by the FieldCache.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This&apos;d be my vote (keep the name FieldCacheTermsFilter).&lt;/p&gt;

&lt;p&gt;Tim, the new patch looks great!  Could you add some javadocs describing the tradeoffs with this filter, and maybe a unit test?  Thanks.&lt;/p&gt;</comment>
                    <comment id="12667996" author="mikemccand" created="Wed, 28 Jan 2009 11:05:45 +0000"  >&lt;p&gt;Tim, are you still looking into this?  Or if you don&apos;t have the itch/time, does anyone else want to add javadocs &amp;amp; unit test for FieldCacheTermsFilter to move this forwards?&lt;/p&gt;</comment>
                    <comment id="12668144" author="shalinmangar" created="Wed, 28 Jan 2009 20:21:14 +0000"  >&lt;p&gt;Attached a patch on trunk&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Adds Javadocs per the comments here and my understanding&lt;/li&gt;
	&lt;li&gt;TestFieldCacheTermsFilter is a simple unit test&lt;/li&gt;
&lt;/ol&gt;
</comment>
                    <comment id="12668157" author="mikemccand" created="Wed, 28 Jan 2009 20:58:05 +0000"  >&lt;p&gt;Fabulous, thanks Shalin!  I changed UN_TOKENIZED --&amp;gt; NOT_ANALYZED in the javadoc,&lt;br/&gt;
and switched to MockRAMDirectory in the test.  I&apos;ll commit shortly.&lt;/p&gt;</comment>
                    <comment id="12668161" author="mikemccand" created="Wed, 28 Jan 2009 21:06:40 +0000"  >&lt;p&gt;Committed revision 738622.  Thanks Tim &amp;amp; Shalin!&lt;/p&gt;</comment>
                    <comment id="12668173" author="markrmiller@gmail.com" created="Wed, 28 Jan 2009 21:40:56 +0000"  >&lt;p&gt;So the advantage appears to be that you can cache the field values and so calculate the filter faster for arbitrary terms, rather than having to calculate and cache a bitset for each set of terms if you used TermsFilter - Right? I think it should be easier to extract that info from the javadoc. And more clear on exactly what the tradeoffs are, and when I should choose which.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The FieldCacheTermsFilter is faster than building a TermsFilter each time.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;While I did figure it out eventually (if I figured it out right), I&apos;m thinking it could be clearer. It could just be me though. I&apos;m often a bit hazzy.&lt;/p&gt;
</comment>
                    <comment id="12668398" author="mikemccand" created="Thu, 29 Jan 2009 11:10:20 +0000"  >&lt;p&gt;I agree: the wording can be improved.  I&apos;ll take a stab at it.&lt;/p&gt;</comment>
                    <comment id="12668466" author="mikemccand" created="Thu, 29 Jan 2009 13:39:36 +0000"  >&lt;p&gt;How about this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/**
 * A {@link Filter} that only accepts documents whose single
 * term value in the specified field is contained in the
 * provided set of allowed terms.
 * 
 * &amp;lt;p/&amp;gt;
 * 
 * This is the same functionality as TermsFilter (from
 * contrib/queries), except &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; filter requires that the
 * field contains only a single term &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; all documents.
 * Because of drastically different implementations, they
 * also have different performance characteristics, as
 * described below.
 * 
 * &amp;lt;p/&amp;gt;
 * 
 * The first invocation of &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; filter on a given field will
 * be slower, since a {@link FieldCache.StringIndex} must be
 * created.  Subsequent invocations using the same field
 * will re-use &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; cache.  However, as with all
 * functionality based on {@link FieldCache}, persistent RAM
 * is consumed to hold the cache, and is not freed until the
 * {@link IndexReader} is closed.  In contrast, TermsFilter
 * has no persistent RAM consumption.
 * 
 * 
 * &amp;lt;p/&amp;gt;
 * 
 * With each search, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; filter translates the specified
 * set of Terms into a &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; {@link OpenBitSet} keyed by
 * term number per unique {@link IndexReader} (normally one
 * reader per segment).  Then, during matching, the term
 * number &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; each docID is retrieved from the cache and
 * then checked &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; inclusion using the {@link OpenBitSet}.
 * Since all testing is done using RAM resident data
 * structures, performance should be very fast, most likely
 * fast enough to not require further caching of the
 * DocIdSet &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; each possible combination of terms.
 * However, because docIDs are simply scanned linearly, an
 * index with a great many small documents may find &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;
 * linear scan too costly.
 * 
 * &amp;lt;p/&amp;gt;
 * 
 * In contrast, TermsFilter builds up an {@link OpenBitSet},
 * keyed by docID, every time it&apos;s created, by enumerating
 * through all matching docs using {@link TermDocs} to seek
 * and scan through each term&apos;s docID list.  While there is
 * no linear scan of all docIDs, besides the allocation of
 * the underlying array in the {@link OpenBitSet}, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;
 * approach requires a number of &lt;span class=&quot;code-quote&quot;&gt;&quot;disk seeks&quot;&lt;/span&gt; in proportion
 * to the number of terms, which can be exceptionally costly
 * when there are cache misses in the OS&apos;s IO cache.
 * 
 * &amp;lt;p/&amp;gt;
 * 
 * Generally, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; filter will be slower on the first
 * invocation &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; a given field, but subsequent invocations,
 * even &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; you change the allowed set of Terms, should be
 * faster than TermsFilter, especially as the number of
 * Terms being matched increases.  If you are matching only
 * a very small number of terms, and those terms in turn
 * match a very small number of documents, TermsFilter may
 * perform faster.
 *
 * &amp;lt;p/&amp;gt;
 *
 * Which filter is best is very application dependent.
 */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12668474" author="markrmiller@gmail.com" created="Thu, 29 Jan 2009 14:02:23 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12668501" author="shalinmangar" created="Thu, 29 Jan 2009 15:38:08 +0000"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;This is much more clear. Thanks Michael.&lt;/p&gt;</comment>
                    <comment id="12723308" author="thetaphi" created="Tue, 23 Jun 2009 22:09:51 +0100"  >&lt;p&gt;Sorry, I reopened the wrong issue, the correct class is FieldCacheRangeFilter.&lt;/p&gt;

&lt;p&gt;Closing again.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12395966" name="FieldCacheTermsFilter.java" size="2137" author="tsturge" created="Fri, 12 Dec 2008 19:55:25 +0000" />
                    <attachment id="12395761" name="FieldCacheTermsFilter.java" size="2149" author="tsturge" created="Wed, 10 Dec 2008 21:31:02 +0000" />
                    <attachment id="12398925" name="LUCENE-1487.patch" size="6911" author="shalinmangar" created="Wed, 28 Jan 2009 20:21:14 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 11 Dec 2008 05:22:15 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12264</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26240</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>