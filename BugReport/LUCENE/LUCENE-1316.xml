<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:25:08 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1316/LUCENE-1316.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1316] Avoidable synchronization bottleneck in MatchAlldocsQuery$MatchAllScorer</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1316</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The isDeleted() method on IndexReader has been mentioned a number of times as a potential synchronization bottleneck. However, the reason this  bottleneck occurs is actually at a higher level that wasn&apos;t focused on (at least in the threads I read).&lt;/p&gt;

&lt;p&gt;In every case I saw where a stack trace was provided to show the lock/block, higher in the stack you see the MatchAllScorer.next() method. In Solr paricularly, this scorer is used for &quot;NOT&quot; queries. We saw incredibly poor performance (order of magnitude) on our load tests for NOT queries, due to this bottleneck. The problem is that every single document is run through this isDeleted() method, which is synchronized. Having an optimized index exacerbates this issues, as there is only a single SegmentReader to synchronize on, causing a major thread pileup waiting for the lock.&lt;/p&gt;

&lt;p&gt;By simply having the MatchAllScorer see if there have been any deletions in the reader, much of this can be avoided. Especially in a read-only environment for production where you have slaves doing all the high load searching.&lt;/p&gt;

&lt;p&gt;I modified line 67 in the MatchAllDocsQuery&lt;br/&gt;
FROM:&lt;br/&gt;
  if (!reader.isDeleted(id)) {&lt;br/&gt;
TO:&lt;br/&gt;
  if (!reader.hasDeletions() || !reader.isDeleted(id)) {&lt;/p&gt;

&lt;p&gt;In our micro load test for NOT queries only, this was a major performance improvement.  We also got the same query results. I don&apos;t believe this will improve the situation for indexes that have deletions. &lt;/p&gt;

&lt;p&gt;Please consider making this adjustment for a future bug fix release.&lt;/p&gt;



</description>
                <environment>&lt;p&gt;All&lt;/p&gt;</environment>
            <key id="12399007">LUCENE-1316</key>
            <summary>Avoidable synchronization bottleneck in MatchAlldocsQuery$MatchAllScorer</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="tfeak">Todd Feak</reporter>
                        <labels>
                    </labels>
                <created>Wed, 25 Jun 2008 16:57:26 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:07 +0100</updated>
                    <resolved>Sun, 25 Jan 2009 14:39:03 +0000</resolved>
                            <version>2.3</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/query/scoring</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>2</watches>
                          <timeoriginalestimate seconds="3600">1h</timeoriginalestimate>
                    <timeestimate seconds="3600">1h</timeestimate>
                                  <comments>
                    <comment id="12608088" author="tfeak" created="Wed, 25 Jun 2008 16:58:56 +0100"  >&lt;p&gt;My version of MatchAlldocsQuery.java which has the modification in it.&lt;/p&gt;</comment>
                    <comment id="12608107" author="tfeak" created="Wed, 25 Jun 2008 17:43:09 +0100"  >&lt;p&gt;Further investigation indicates that the ValueSourceQuery$ValueSourceScorer may suffer from the same issue and benefit from a similar optimization.&lt;/p&gt;</comment>
                    <comment id="12608128" author="yseeley@gmail.com" created="Wed, 25 Jun 2008 19:00:47 +0100"  >&lt;p&gt;Although this doesn&apos;t solve the general problem, this probably still makes sense to do now for the no-deletes case.&lt;br/&gt;
Todd, can you produce a patch?  See &lt;a href=&quot;http://wiki.apache.org/lucene-java/HowToContribute&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/HowToContribute&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12608129" author="hossman" created="Wed, 25 Jun 2008 19:01:23 +0100"  >&lt;p&gt;rather then attempting localized optimizations of individual Query classes, a more generalized improvements would probably be to change SegmentReader.isDeleted so that instead of the entire method being synchronized, it first checks if the segment has any deletions, and if not then enters a synchronized block to check deletedDocs.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="12608132" author="tfeak" created="Wed, 25 Jun 2008 19:08:01 +0100"  >&lt;p&gt;I like Hoss&apos; suggestion better. I&apos;ll try that fix locally and if it provides the same improvement, I will submit a patch for you.&lt;/p&gt;</comment>
                    <comment id="12608134" author="yseeley@gmail.com" created="Wed, 25 Jun 2008 19:13:51 +0100"  >&lt;p&gt;&amp;gt; a more generalized improvements would probably be to change SegmentReader.isDeleted so that instead of the entire method being synchronized&lt;/p&gt;

&lt;p&gt;Right, but that&apos;s not totally back compatible.  Code that depended on deletes being instantly visible across threads would no longer be guaranteed.&lt;/p&gt;</comment>
                    <comment id="12608137" author="hossman" created="Wed, 25 Jun 2008 19:23:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;Code that depended on deletes being instantly visible across threads would no longer be guaranteed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;you lost me there ... why would deletes be stop being instantly visible if we changed this...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isDeleted(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n) {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (deletedDocs != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; deletedDocs.get(n));
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...to this...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isDeleted(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; == deletedDocs) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;) { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (deletedDocs.get(n)); }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;?&lt;/p&gt;</comment>
                    <comment id="12608146" author="rengels@ix.netcom.com" created="Wed, 25 Jun 2008 19:42:37 +0100"  >&lt;p&gt;According to the java memory model, hasDeletions() would need to be synchronized as well , since if another thread did perform a deletion, it would need to be up to date.&lt;/p&gt;

&lt;p&gt;This might work in later JVMs by declaring the deletedDocs variable volatile, but no guarantees.&lt;/p&gt;

&lt;p&gt;Seems better to ALLOW this behavior, that a reader might not see up to date deletions made during a query, and do a single synchronized check of deletions at the start.&lt;/p&gt;
</comment>
                    <comment id="12608147" author="yseeley@gmail.com" created="Wed, 25 Jun 2008 19:42:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;why would deletes be stop being instantly visible&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s minor, but before, if thread A deleted a document, and then thread B checked if it was deleted, thread B was guaranteed to see that it was in fact deleted.&lt;/p&gt;

&lt;p&gt;If the check for deletedDocs == null were moved outside of the synchronized, there&apos;s no guarantee when thread B will see (if ever) that deletedDocs has been set (no memory barrier).&lt;/p&gt;

&lt;p&gt;It&apos;s not a major issue since client code shouldn&apos;t be written that way IMO, but it&apos;s worth factoring into the decision.&lt;/p&gt;</comment>
                    <comment id="12608148" author="rengels@ix.netcom.com" created="Wed, 25 Jun 2008 19:44:54 +0100"  >&lt;p&gt;According to&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp06197.html&quot; class=&quot;external-link&quot;&gt;http://www.ibm.com/developerworks/java/library/j-jtp06197.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;declaring the deletedDocs volatile should do the trick.&lt;/p&gt;</comment>
                    <comment id="12608149" author="rengels@ix.netcom.com" created="Wed, 25 Jun 2008 19:49:20 +0100"  >&lt;p&gt;The Pattern#5 referenced (cheap read-write lock) is exactly what is trying to be accomplished.&lt;/p&gt;</comment>
                    <comment id="12608160" author="yseeley@gmail.com" created="Wed, 25 Jun 2008 20:23:20 +0100"  >&lt;blockquote&gt;&lt;p&gt;declaring the deletedDocs volatile should do the trick.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right... that would be cheaper when no docs were deleted.  But would it be more expensive when there were deleted docs (a volatile + a synchronized?)  I don&apos;t know if lock coarsening could do anything with this case...&lt;/p&gt;</comment>
                    <comment id="12608162" author="markrmiller@gmail.com" created="Wed, 25 Jun 2008 20:28:55 +0100"  >&lt;p&gt;If I remember correctly, volatile does not work correctly until java 1.5. At best I think it was implementation dependent with the old memory model.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;edit&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;maybe its ok under certain circumstances:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-jtp02244.html&quot; class=&quot;external-link&quot;&gt;http://www.ibm.com/developerworks/library/j-jtp02244.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Problem #2: Reordering volatile and nonvolatile stores&lt;/p&gt;</comment>
                    <comment id="12608183" author="hossman" created="Wed, 25 Jun 2008 21:49:30 +0100"  >&lt;blockquote&gt;&lt;p&gt;if thread A deleted a document, and then thread B checked if it was deleted, thread B was guaranteed to see that it was in fact deleted.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm.... i&apos;ll take your word for it, but i don&apos;t follow the rational: the current synchronization just ensured that either the isDeleted() call will complete before the delete() call started or vice versa &amp;#8211; but you have no guarantee that thread B would run after thread A and get true.   .... unless... is your point that without synchronization on the null check there&apos;s no garuntee that B will ever see the change to deletedDocs even if it does execute after delete() ?&lt;/p&gt;

&lt;p&gt;either way: robert&apos;s point about hasDeletions() needing to be synchronized seems like a bigger issue &amp;#8211; isn&apos;t that a bug in the current implementation?  assuming we fix that then it seems like the original issue is back to square one: synchro bottlenecks when there are no deletions.&lt;/p&gt;


</comment>
                    <comment id="12608187" author="rengels@ix.netcom.com" created="Wed, 25 Jun 2008 22:01:42 +0100"  >&lt;p&gt;Hoss, that is indeed the case, another thread would see deletedDocs as null, even though another thread has set it&lt;/p&gt;

&lt;p&gt;hasDeletions does not need to be synchronized if deletedDocs is volatile&lt;/p&gt;</comment>
                    <comment id="12608189" author="yseeley@gmail.com" created="Wed, 25 Jun 2008 22:03:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;is your point that without synchronization on the null check there&apos;s no garuntee that B will ever see the change to deletedDocs even if it does execute after delete()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right... it&apos;s about the memory barrier.&lt;/p&gt;

&lt;p&gt;The reality is that there is normally a need for higher level synchronization anyway.  That&apos;s why it was always silly for things like StringBuffer to be synchronized.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;assuming we fix that then it seems like the original issue is back to square one: synchro bottlenecks when there are no deletions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A scorer could just check once when initialized... there&apos;s never been any guarantees about in-flight queries immediately seeing deleted docs changes - now that &lt;b&gt;really&lt;/b&gt; doesn&apos;t make sense.  TermScorer grabs the whole bit vector at the start and never checks again.&lt;/p&gt;</comment>
                    <comment id="12608469" author="tfeak" created="Thu, 26 Jun 2008 16:25:34 +0100"  >&lt;p&gt;I wanted to share my micro load test results with you, to make sure you all understand scale of the bottleneck as we are experiencing it.&lt;/p&gt;

&lt;p&gt;For an optimized index with 4700+ documents (ie small), a NOT query varies by a factor of 35 under heavy load. Using 2.3.0 release I got 20 tps. With the volatile/synchronized fix suggested, I got 700 tps. The limiting factor on the 700 tps was the CPU on the computer throwing load, so this may be even worse. Furthermore, the more documents that exist in the index, the worse this may get, as it synchonizes on every single iteration through the loop.&lt;/p&gt;

&lt;p&gt;An argument can be made that this is just a necessary evil, and that we &lt;b&gt;must&lt;/b&gt; synchronize on this for the possibility of updates during reads. I have 2 questions regarding that.&lt;/p&gt;

&lt;p&gt;1. What is the cost of a dirty read in that case? Is it stale data, incorrect data, or a corrupted system?&lt;br/&gt;
2. What is more prevalent in a production system. Indexes with no deletes, indexes with &lt;b&gt;some&lt;/b&gt; deletes, or indexes with frequent deletes?&lt;/p&gt;

&lt;p&gt;Do we need to have 1 class that does it all, or should we consider 2 different implementation for 2 different uses. What about a read-only SegmentReader for read-only slaves in production environments?&lt;/p&gt;

</comment>
                    <comment id="12608472" author="yseeley@gmail.com" created="Thu, 26 Jun 2008 16:43:54 +0100"  >&lt;p&gt;20tps (queries per second?) for 4700 docs is &lt;b&gt;very&lt;/b&gt; slow... how many threads were you testing with?&lt;/p&gt;</comment>
                    <comment id="12608475" author="tfeak" created="Thu, 26 Jun 2008 16:54:32 +0100"  >&lt;p&gt;10 threads in JMeter throwing load at the Tomcat as fast as possible. The Tomcat was on a separate machine with more then 10 worker threads, though only 10 were in use at any one time.&lt;/p&gt;

&lt;p&gt;To eliminate any differences, the tests were run back to back. The only difference was the lucene-core JAR and a Tomcat bounce between the tests. Otherwise, the same exact test is run in both cases. What you have is threads all trying to synchronize on isDeleted() 4700+ times per request. Lock contention goes through the roof. At any point during the test I can take a thread stack snapshot and they are all blocked waiting for isDeleted().&lt;/p&gt;</comment>
                    <comment id="12608521" author="yseeley@gmail.com" created="Thu, 26 Jun 2008 18:44:18 +0100"  >&lt;p&gt;Attaching prototype patch (needs javadoc + tests if approach is acceptable) that avoids all synchronization when iterating over all documents.&lt;/p&gt;

&lt;p&gt;If IndexReader.termDocs(Term term) is called with null, a TermDocs implementation is returned that matches all documents.  This is the same approach used by TermScorer via SegmentTermDocs to avoid synchronization by grabbing the BitVector of deleted docs at instantiation.&lt;/p&gt;

&lt;p&gt;This patch also updates MatchAllDocuments to use this TermDocs to iterate over all documents.&lt;/p&gt;

&lt;p&gt;Advantages:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;adds no new methods or interfaces, simply adds extra semantics to an existing method&lt;/li&gt;
	&lt;li&gt;works from the bottom-up... no need to instantiate a big BitVector&lt;/li&gt;
	&lt;li&gt;exposes the functionality to expert users for use in custom queries&lt;/li&gt;
	&lt;li&gt;avoids a binary search to find the correct IndexReader in a MultiReader for each call (it leverages all the TermDocs code in all IndexReader implementations such as MultiTermDocs).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Disadvantages:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TermDocs instance returned cannot be used to seek to a different term.  However, this is minor and not a back compatibility concern since &quot;null&quot; was not previously a supported value.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On balance, I think it&apos;s 10% hack, 90% useful.  Thoughts?&lt;/p&gt;</comment>
                    <comment id="12608537" author="tfeak" created="Thu, 26 Jun 2008 19:21:50 +0100"  >&lt;p&gt;I applied that patch locally to a 2.3.0 build. Test results show this solution performs equally as the other solution did. I&apos;d be happy with it for that reason alone. I cannot argue as to the quality of the proposed solution. I will leave that to those more knowledgeable on Lucene itself. Thank you for the time you guys have put into this issue for me.&lt;/p&gt;</comment>
                    <comment id="12608542" author="yseeley@gmail.com" created="Thu, 26 Jun 2008 19:42:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;Test results show this solution performs equally as the other solution did.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s good news (as I assume this was for an optimized index).&lt;br/&gt;
Would it be possible for you to try the same test on a non-optimized index (multi-segment) with a couple deletions?&lt;/p&gt;</comment>
                    <comment id="12608835" author="tfeak" created="Fri, 27 Jun 2008 17:53:57 +0100"  >&lt;p&gt;I don&apos;t think that patch provides correct functionality. I went to run the load tests this morning against an un-optimized index and the query results do not match what an unpatched version does. Simply swapping the JAR and restarting returns different results for the same query. Specifically, empty (incorrect) results.&lt;/p&gt;</comment>
                    <comment id="12608841" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 18:00:19 +0100"  >&lt;p&gt;I&apos;ll look into it (that&apos;s why it was marked as &quot;prototype&quot;)&lt;/p&gt;</comment>
                    <comment id="12608844" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 18:06:36 +0100"  >&lt;p&gt;I saw and fixed a bug that would affect multireaders.... patch attached.&lt;br/&gt;
I&apos;ve not yet written tests, so no guarantees.&lt;br/&gt;
Edit: I reproduced... it still doesn&apos;t work, so hold off using this.&lt;/p&gt;</comment>
                    <comment id="12608849" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 18:25:12 +0100"  >&lt;p&gt;Sigh... the problem is that things are done in a two step process by default.&lt;br/&gt;
A TermDocs is created, and then seek is called (by which time the impl is set already). &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; TermDocs termDocs(Term term) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    ensureOpen();
    TermDocs termDocs = termDocs();
    termDocs.seek(term);
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; termDocs;
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; TermDocs termDocs() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; So a full solution down this road would be slightly more involved  (overriding termDocs(Term) in all the sublcasses rather than just termDocs())&lt;/p&gt;
</comment>
                    <comment id="12608897" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 20:47:49 +0100"  >&lt;p&gt;Here&apos;s an updated patch that should work correctly.&lt;/p&gt;</comment>
                    <comment id="12608907" author="tfeak" created="Fri, 27 Jun 2008 21:22:17 +0100"  >&lt;p&gt;I applied the patch to the 2.3.0 file. I ran against an optimized and non-optimized (12 segment) index with 4700 entries.&lt;/p&gt;

&lt;p&gt;2.3.0 non-optimized index  &lt;b&gt;104 tps&lt;/b&gt;&lt;br/&gt;
2.3.0 patched non-optimized index &lt;b&gt;482 tps&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;2.3.0 optimized index &lt;b&gt;21 tps&lt;/b&gt;&lt;br/&gt;
2.3.0 patched optimized index &lt;b&gt;718 tps&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;The patch provided improvements in both optimized and unoptimized indexes. Thanks again Yonik.&lt;/p&gt;</comment>
                    <comment id="12608956" author="hossman" created="Sat, 28 Jun 2008 01:56:56 +0100"  >&lt;blockquote&gt;&lt;p&gt;TermDocs instance returned cannot be used to seek to a different term. However, this is minor and not a back compatibility concern since &quot;null&quot; was not previously a supported value.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;so essentially this approach only improves MatchAllDocsQuery correct? .... Other use cases where lots of termDoc enumeration take place (RangeFilter and PrefixFilter type code) wouldn&apos;t&apos; benefit from this at all.&lt;/p&gt;

&lt;p&gt;Assuming the genuinely eliminating the synchronization is infeasible, the other approach that occurred to me along the lines of a &quot;read only&quot; IndexReader is that if we started providing a public method for getting the list of all deleted docs (either as a BitVector or as a DocIdSet or something) then it would be easy to implement a SnapshotFilteredIndexReader that on construction cached the current list of all deleted docs in the IndexReader it&apos;s wrapping, used it for all isDeleted() methods, and proxied all other methods to the underlying reader.&lt;/p&gt;

&lt;p&gt;then things like MatchAllDocs, RangeFilter, and PrefixFilter could (optionally?) construct one of those prior to their big iteration loops, and use it in place of the original IndexReader.  Trade the syncro bottleneck for deletion data as of the moment the query was started (a fair trade for most people)&lt;/p&gt;</comment>
                    <comment id="12610101" author="yseeley@gmail.com" created="Thu, 3 Jul 2008 02:25:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;so essentially this approach only improves MatchAllDocsQuery correct?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It would essentially simulate a term indexed for every document, and improve any query that could use that (i.e. that needed to iterate over all documents).  For things like MatchAllDocuments and FunctionQuery on a MultiReader, it should actually be superior to the elimination of all synchronization on isDeleted() since it also removes  the binary search to find the correct reader for a document.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Other use cases where lots of termDoc enumeration take place (RangeFilter and PrefixFilter type code) wouldn&apos;t&apos; benefit from this at all.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, but using TermDocs, they already have the same style of optimization and hence suffer no synchronization overhead.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the other approach that occurred to me along the lines of a &quot;read only&quot; IndexReader is that if we started providing a public method for getting the list of all deleted docs&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right... that could be more useful for someone that needs random access to isDeleted(), at the cost of greater setup cost, and greater memory usage.  However the TermDocs approach solves the use-cases we have today in lucene-core.&lt;/p&gt;</comment>
                    <comment id="12610123" author="hossman" created="Thu, 3 Jul 2008 05:48:38 +0100"  >
&lt;blockquote&gt;&lt;p&gt;Right, but using TermDocs, they already have the same style of optimization and hence suffer no synchronization overhead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Arggg.... sorry, my bad: i was thinking reader.isDeleted was used in those&lt;br/&gt;
cases as well &amp;#8211; I was totally missing that SegmentTermDocs takes care of&lt;br/&gt;
it directly.&lt;/p&gt;

&lt;p&gt;but ... thinking about how SegmentTermDocs are constructed for a moment,&lt;br/&gt;
isn&apos;t the (unsynchronized) usage of deletedDocs in SegmentTermDocs.next&lt;br/&gt;
prone to the same concern you had about removing (or reducing) the&lt;br/&gt;
synchronization in SegmentReader.isDeleted ... &quot;deletes aren&apos;t instantly&lt;br/&gt;
visible across threads&quot; ... are they?&lt;/p&gt;

&lt;p&gt;Is SegmentTermDocs.next too lax in how it deals with deletedDocs, or is&lt;br/&gt;
SegmentReader.isDeleted to paranoid?&lt;/p&gt;
</comment>
                    <comment id="12610228" author="yseeley@gmail.com" created="Thu, 3 Jul 2008 14:34:55 +0100"  >&lt;blockquote&gt;&lt;p&gt;but ... thinking about how SegmentTermDocs are constructed for a moment,&lt;br/&gt;
isn&apos;t the (unsynchronized) usage of deletedDocs in SegmentTermDocs.next&lt;br/&gt;
prone to the same concern you had about removing (or reducing) the&lt;br/&gt;
synchronization in SegmentReader.isDeleted ... &quot;deletes aren&apos;t instantly&lt;br/&gt;
visible across threads&quot; ... are they?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, deletes aren&apos;t instantly visible across threads (when one thread has started a query and the other thread does a delete).  AFAIK it&apos;s always been that way, so I think it&apos;s probably acceptable.  On a practical level, seeking on a TermDocs crosses synchronization points, so deletes won&apos;t go unrecognized by other threads forever either.&lt;/p&gt;

&lt;p&gt;But there is a thread-safety issue I&apos;ve been mulling over since I wrote this patch.&lt;br/&gt;
SegmentTermDocs.next() is fine... unsynchronized reads look benign on the BitVector class since writes just change a byte at a time.  &quot;count&quot; could be off, but that&apos;s OK too... it will simply be a stale value since updates to it are atomic.&lt;/p&gt;

&lt;p&gt;The issue is the possibility of grabbing a partially constructed BitVector object to begin with.  Notice how I synchronize to avoid this in AllTermDocs:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; AllTermDocs(SegmentReader parent) {
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (parent) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.deletedDocs = parent.deletedDocs;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.maxDoc = parent.maxDoc();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That should probably be done in SegmentTermDocs too.  Without it, a null pointer exception or an array out of bounds exception could result when checking the BitVector.&lt;/p&gt;</comment>
                    <comment id="12637186" author="rcmuir" created="Mon, 6 Oct 2008 20:22:17 +0100"  >&lt;p&gt;we use MatchAllDocs query also. In addition to what is described here we got very nice gains by overriding the Scorer.score() methods that take a HitCollector.&lt;/p&gt;

&lt;p&gt;This seems pretty dumb but I guess since it has to score every doc the method call overhead actually matters? &lt;/p&gt;</comment>
                    <comment id="12646152" author="markrmiller@gmail.com" created="Mon, 10 Nov 2008 02:45:55 +0000"  >&lt;p&gt;The new ReadOnly IndexReader option resolves this issue, correct?&lt;/p&gt;</comment>
                    <comment id="12649219" author="jasonrutherglen" created="Thu, 20 Nov 2008 00:05:09 +0000"  >&lt;p&gt;I looked at 2.4 and am surprised this patch did not make it in.  Read only IndexReader shouldn&apos;t be necessary to solve this issue.  Were there any problems in the unit tests for this patch or something?&lt;/p&gt;</comment>
                    <comment id="12656944" author="mikemccand" created="Tue, 16 Dec 2008 10:38:50 +0000"  >&lt;p&gt;Yonik is your patch here (creating an AllTermDocs) ready to commit, once you fix SegmentTermDocs to also synchronize on parent when grabbing the deletedDocs?&lt;/p&gt;</comment>
                    <comment id="12663484" author="jasonrutherglen" created="Tue, 13 Jan 2009 21:43:01 +0000"  >&lt;p&gt;Added synchronized on parent when obtaining the deleted docs in SegmentTermDocs.  &lt;/p&gt;</comment>
                    <comment id="12664276" author="mikemccand" created="Thu, 15 Jan 2009 21:35:05 +0000"  >&lt;p&gt;I think at least AllTermDocs.java is missing from the latest patch here.  When you apply a patch, make a change, and then &quot;svn diff&quot; in order to post a new patch, you have to &lt;span class=&quot;error&quot;&gt;&amp;#91;frustratingly&amp;#93;&lt;/span&gt; remember to first &quot;svn add&quot; any new files in the first patch.&lt;/p&gt;

&lt;p&gt;I think the Subversion team is working on an &quot;svn patch&quot; command that would do this (and apply properties, and maybe deal with a 3-way merge, etc) but last I checked it&apos;s not done yet.  So until then we have to workaround...&lt;/p&gt;</comment>
                    <comment id="12664404" author="yseeley@gmail.com" created="Fri, 16 Jan 2009 04:37:18 +0000"  >&lt;p&gt;In a way, this is a mirror image of Jason&apos;s request in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1476&quot; title=&quot;BitVector implement DocIdSet, IndexReader returns DocIdSet deleted docs&quot;&gt;&lt;del&gt;LUCENE-1476&lt;/del&gt;&lt;/a&gt; for a getDeletedDocs() that returned a DocIdSet... provided it also worked on a MultiReader, etc.  MatchAllDocs could be efficiently implemented with that.&lt;/p&gt;

&lt;p&gt;It does seem like having some sort of iterator over existing docs is useful to avoid the binary search cost of associating ids with segments, but there was never any feedback on what the API should be.  Instead of adding new functionality to termDocs(), we could also add a getAllDocs() that returns either a DocIdSet or an interator.&lt;/p&gt;
</comment>
                    <comment id="12664562" author="jasonrutherglen" created="Fri, 16 Jan 2009 16:53:05 +0000"  >&lt;p&gt;Patch includes AllTermDocs.  &lt;/p&gt;</comment>
                    <comment id="12664567" author="jasonrutherglen" created="Fri, 16 Jan 2009 17:09:04 +0000"  >&lt;blockquote&gt;
&lt;p&gt;In a way, this is a mirror image of Jason&apos;s request in&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1476&quot; title=&quot;BitVector implement DocIdSet, IndexReader returns DocIdSet deleted docs&quot;&gt;&lt;del&gt;LUCENE-1476&lt;/del&gt;&lt;/a&gt; for a getDeletedDocs() that returned a DocIdSet...&lt;br/&gt;
provided it also worked on a MultiReader, etc. MatchAllDocs could be&lt;br/&gt;
efficiently implemented with that. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the API of reader.termDocs(null) is fine. If we move to a&lt;br/&gt;
DocIdSet for deleteddocs we can change the all docs implementation if&lt;br/&gt;
needed. &lt;/p&gt;</comment>
                    <comment id="12667077" author="mikemccand" created="Sun, 25 Jan 2009 12:24:43 +0000"  >&lt;p&gt;OK, new patch attached:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Added more tests of *Reader.termDocs(null)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed IndexReader.termDocs javadoc to explain term=null case&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed MemoryIndex.termDocs(null) to return freq=1&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added CHANGES.txt entry&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think it&apos;s ready to commit.  I&apos;ll wait a day or two.&lt;/p&gt;</comment>
                    <comment id="12667083" author="yseeley@gmail.com" created="Sun, 25 Jan 2009 13:19:20 +0000"  >&lt;p&gt;+1 to the latest patch.&lt;br/&gt;
Much thanks for picking this up! (I&apos;ve been completely swamped.)&lt;/p&gt;</comment>
                    <comment id="12667088" author="mikemccand" created="Sun, 25 Jan 2009 14:35:23 +0000"  >&lt;p&gt;OK, no problem Yonik &amp;#8211; thanks for reviewing.  I&apos;ll commit shortly.&lt;/p&gt;</comment>
                    <comment id="12667089" author="mikemccand" created="Sun, 25 Jan 2009 14:39:03 +0000"  >&lt;p&gt;Committed revision 737513.  Thanks everyone!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12384862" name="LUCENE_1316.patch" size="9600" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 20:47:49 +0100" />
                    <attachment id="12384851" name="LUCENE_1316.patch" size="6377" author="yseeley@gmail.com" created="Fri, 27 Jun 2008 18:06:36 +0100" />
                    <attachment id="12384773" name="LUCENE_1316.patch" size="6362" author="yseeley@gmail.com" created="Thu, 26 Jun 2008 18:44:18 +0100" />
                    <attachment id="12398682" name="LUCENE-1316.patch" size="17877" author="mikemccand" created="Sun, 25 Jan 2009 12:24:43 +0000" />
                    <attachment id="12398086" name="LUCENE-1316.patch" size="10283" author="jasonrutherglen" created="Fri, 16 Jan 2009 16:53:05 +0000" />
                    <attachment id="12397819" name="LUCENE-1316.patch" size="7441" author="jasonrutherglen" created="Tue, 13 Jan 2009 21:43:01 +0000" />
                    <attachment id="12384679" name="MatchAllDocsQuery.java" size="4139" author="tfeak" created="Wed, 25 Jun 2008 16:58:56 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 25 Jun 2008 18:00:47 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12432</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26412</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>