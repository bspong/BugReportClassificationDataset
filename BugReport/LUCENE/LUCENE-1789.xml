<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:19:56 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1789/LUCENE-1789.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1789] getDocValues should provide a MultiReader DocValues abstraction</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1789</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;When scoring a ValueSourceQuery, the scoring code calls ValueSource.getValues(reader) on &lt;b&gt;each&lt;/b&gt; leaf level subreader &amp;#8211; so DocValue instances are backed by the individual FieldCache entries of the subreaders &amp;#8211; but if Client code were to inadvertently  called getValues() on a MultiReader (or DirectoryReader) they would wind up using the &quot;outer&quot; FieldCache.&lt;/p&gt;

&lt;p&gt;Since getValues(IndexReader) returns DocValues, we have an advantage here that we don&apos;t have with FieldCache API (which is required to provide direct array access). getValues(IndexReader) could be implimented so that &lt;b&gt;IF&lt;/b&gt; some a caller inadvertently passes in a reader with non-null subReaders, getValues could generate a DocValues instance for each of the subReaders, and then wrap them in a composite &quot;MultiDocValues&quot;.&lt;/p&gt;

</description>
                <environment></environment>
            <key id="12432459">LUCENE-1789</key>
            <summary>getDocValues should provide a MultiReader DocValues abstraction</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="hossman">Hoss Man</reporter>
                        <labels>
                    </labels>
                <created>Fri, 7 Aug 2009 01:31:47 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:30 +0100</updated>
                    <resolved>Thu, 13 Aug 2009 20:40:16 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12740328" author="hossman" created="Fri, 7 Aug 2009 01:35:01 +0100"  >&lt;p&gt;This idea orriginated in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1749&quot; title=&quot;FieldCache introspection API&quot;&gt;&lt;del&gt;LUCENE-1749&lt;/del&gt;&lt;/a&gt;, see these comments...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740155#action_12740155&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740155#action_12740155&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740256#action_12740256&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740256#action_12740256&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740278#action_12740278&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-1749?focusedCommentId=12740278#action_12740278&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;I&apos;ve marked this for 2.9 for now .... i think it&apos;s a &quot;nice to have&quot; in 2.9, because unlike general FieldCache usage, the API is abstract enough we can protect our users from mistakes; but i don&apos;t personally think it&apos;s critical that we do this if no one else wants to take a stab at it.&lt;/p&gt;

&lt;p&gt;(EDIT: shorter versions of URLs to prevent horizontal scroll)&lt;/p&gt;</comment>
                    <comment id="12740362" author="markrmiller@gmail.com" created="Fri, 7 Aug 2009 03:07:42 +0100"  >&lt;p&gt;Its basically what I did as a first attempt at 1771 actually (you have a glimpse into how hectic my brain is in that I didn&apos;t remember that 30 minutes ago) :&lt;/p&gt;

&lt;p&gt;(with some of this in ReaderUtil now, it can be written in half the length)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-comment&quot;&gt;// constructor
&lt;/span&gt;+    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; ValueSourceScorer(Similarity similarity, IndexReader reader, ValueSourceWeight w, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; valuesFromSubReaders) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
       &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(similarity);
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(!valuesFromSubReaders) {
+        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.weight = w;
+        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.qWeight = w.getValue();
+        &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is when/where the values are first created.
&lt;/span&gt;+        vals = valSrc.getValues(reader);
+        termDocs = reader.termDocs(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
+        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
+      }
+      
       &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.weight = w;
       &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.qWeight = w.getValue();
-      &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is when/where the values are first created.
&lt;/span&gt;-      vals = valSrc.getValues(reader);
+      List subReadersList = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList();
+      ReaderUtil.gatherSubReaders(subReadersList, reader);
+      subReaders = (IndexReader[]) subReadersList.toArray(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexReader[subReadersList.size()]);
+      valsArray = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DocValues[subReaders.length];
+      docStarts = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;[subReaders.length];
+      &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; maxDoc = 0;
+      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; subReaders.length; i++) {
+        docStarts[i] = maxDoc;
+        maxDoc += subReaders[i].maxDoc();
+        valsArray[i] = valSrc.getValues(subReaders[i]);
+      }
+      
+      vals = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; DocValues() {
+
+        &lt;span class=&quot;code-comment&quot;&gt;//@Override
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; floatVal(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc) {
+          &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n = ReaderUtil.subSearcher(doc, subReaders.length, docStarts);
+          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; valsArray[n].floatVal(doc);
+        }
+
+        &lt;span class=&quot;code-comment&quot;&gt;//@Override
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc) {
+          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Float&lt;/span&gt;.toString(floatVal(doc));
+        }
+        
+      };
       termDocs = reader.termDocs(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
     }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12740492" author="mikemccand" created="Fri, 7 Aug 2009 11:22:04 +0100"  >&lt;p&gt;It is nice that DocValues gives us the freedom to do this, but.... I&apos;m&lt;br/&gt;
not sure we should, because it&apos;s a sizable performance trap.&lt;/p&gt;

&lt;p&gt;Ie, we&apos;ll be silently inserting a call to ReaderUtil.subSearcher on&lt;br/&gt;
every doc value lookup (vs previously when it was a single top-level&lt;br/&gt;
array lookup).&lt;/p&gt;

&lt;p&gt;While client code that has relied on this in the past will nicely&lt;br/&gt;
continue to function properly, if we make this change, its performance&lt;br/&gt;
is going to silently take a &lt;span class=&quot;error&quot;&gt;&amp;#91;possibly sizable&amp;#93;&lt;/span&gt; hit.&lt;/p&gt;

&lt;p&gt;In general, with Lucene, we can do the per-segment switching &quot;up high&quot;&lt;br/&gt;
(which is what the core now does, exclusively), or we can do it &quot;down&lt;br/&gt;
low&quot; (creating MultiTermDocs, MultiTermEnum, MultiTermPositions,&lt;br/&gt;
MultiDocValues, etc.), which has sizable performance costs.  It&apos;s also&lt;br/&gt;
costly for us because we&apos;ll have N different places where we must&lt;br/&gt;
create &amp;amp; maintain a MultiXXX class.  I would love to someday deprecate&lt;br/&gt;
all of the &quot;down low&quot; switching classes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In the core I think we should always switch &quot;up high&quot;.  We&apos;ve already&lt;br/&gt;
done this w/ searching and collection/sorting.  In &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1771&quot; title=&quot;Using explain may double ram reqs for fieldcaches when using ValueSourceQuery/CustomScoreQuery or for ConstantScoreQuerys that use a caching Filter.&quot;&gt;&lt;del&gt;LUCENE-1771&lt;/del&gt;&lt;/a&gt; we&apos;re&lt;br/&gt;
fixing IndexSearcher.explain to do so as well.&lt;/p&gt;

&lt;p&gt;With external code, I&apos;d like over time to strongly encourage only&lt;br/&gt;
switching &quot;up high&quot; as well.&lt;/p&gt;

&lt;p&gt;Maybe it&apos;d be best if we could somehow allow this &quot;down low&quot; switching&lt;br/&gt;
for 2.9, but 1) warn that you&apos;ll see a performance hit right off, 2)&lt;br/&gt;
deprecate it, and 3) and somehow state that in 3.0 you&apos;ll have to send&lt;br/&gt;
only a SegmentReader to this API, instead.&lt;/p&gt;

&lt;p&gt;EG, imagine an app that created an external custom HitCollector that&lt;br/&gt;
calls say FloatFieldSource on the top reader in order to use of a&lt;br/&gt;
float value per doc in each collect() call.  On upgrading to 2.9, this&lt;br/&gt;
app will already have to make the switch to the Collector API, which&apos;d&lt;br/&gt;
be a great time for them to also then switch to pulling these float&lt;br/&gt;
values per-segment.  But, if we make the proposed change here, the app&lt;br/&gt;
could in fact just keep working off the top-level values (eg if the&lt;br/&gt;
ctor in their class is pulling these values), thinking everything is&lt;br/&gt;
fine when in fact there is a sizable, silent perf hit.  I&apos;d prefer in&lt;br/&gt;
2.9 for them to also switch their DocValues lookup to be per segment.&lt;/p&gt;

&lt;p&gt;[Aside: once we gain clarity on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt;, hopefully we can do away&lt;br/&gt;
with oal.search.function.FieldCacheSource,&lt;/p&gt;
{Byte,Short,Int,Ord,ReverseOrd}
&lt;p&gt;FieldSource, etc.  Ie these classes&lt;br/&gt;
basically copy what FieldCache does, but expose a per-doc method call&lt;br/&gt;
instead of a fixed array lookup.]&lt;/p&gt;
</comment>
                    <comment id="12740494" author="mikemccand" created="Fri, 7 Aug 2009 11:27:59 +0100"  >&lt;p&gt;Or... how about if we made a separate &quot;helper&quot; class, whose purpose&lt;br/&gt;
was to accept a top-level reader and do &quot;down low&quot; switching to this&lt;br/&gt;
new MultiDocValues class.  This class would be deprecated, ie, exist&lt;br/&gt;
only in 2.9 to help external usage of the DocValues API migrate to &quot;up&lt;br/&gt;
high&quot; switching.&lt;/p&gt;

&lt;p&gt;However, you&apos;d have to explicitly create this class.  EG, in the&lt;br/&gt;
normal DocValues classes we throw an exception if you pass in a&lt;br/&gt;
top-level reader, noting clearly that you could 1) switch to this&lt;br/&gt;
helper class (at a sizable per-lookup performance hit), or 2) switch&lt;br/&gt;
to looking up your values per-segment?&lt;/p&gt;

&lt;p&gt;This way at least it&apos;d be much clearer to the external consumer the&lt;br/&gt;
cost of using the &quot;down low&quot; switching class.  It&apos;d make the decision&lt;br/&gt;
explicit, not silent, on upgrading to 2.9.&lt;/p&gt;</comment>
                    <comment id="12740574" author="hossman" created="Fri, 7 Aug 2009 15:46:20 +0100"  >&lt;blockquote&gt;
&lt;p&gt;While client code that has relied on this in the past will nicely&lt;br/&gt;
continue to function properly, if we make this change, its performance&lt;br/&gt;
is going to silently take a &lt;span class=&quot;error&quot;&gt;&amp;#91;possibly sizable&amp;#93;&lt;/span&gt; hit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct: a change like this could cause 2.9 to introduce a &lt;em&gt;time&lt;/em&gt; based performance hit from the added method call to resolve the sub(reader|docvalue) on each method call ... but if we don&apos;t have a change like this, 2.9 could introduce a &lt;em&gt;memory&lt;/em&gt; based performance hit from the other FieldCache changes as it client code accessing DocValues for the  top level reader will create a duplication of the whole array.&lt;/p&gt;

&lt;p&gt;Incidently: I&apos;m willing to believe you that the time based perf hit would be high, but my instinct is that it wouldn&apos;t be that bad: the DocValues API already introduces at least one method call per doc lookup (two depending on datatype).  adding a second method call to delegate to a sub-DocValues isntance doesn&apos;t seem that bad (especially since a new MultDocValues class could get the subReader list and compute the docId offsets on init, and then reuse them on each method call)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the core I think we should always switch &quot;up high&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(In case there is any confusion: wasn&apos;t suggesting that we stop using &quot;up high&quot; switching on DocValues in code included in the Lucene dist, i was suggesting that if someone uses DocValues directly in their code (against a top level reader) then we help them out by giving them the &quot;down low&quot; switching ... so &quot;expected&quot; usages wouldn&apos;t pay the added time based hit, just &quot;unexpected&quot; usages (which would be saved from the memory hit))&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Maybe it&apos;d be best if we could somehow allow this &quot;down low&quot; switching&lt;br/&gt;
for 2.9, but 1) warn that you&apos;ll see a performance hit right off, 2)&lt;br/&gt;
deprecate it, and 3) and somehow state that in 3.0 you&apos;ll have to send&lt;br/&gt;
only a SegmentReader to this API, instead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;that would get into really sticky territory for people writting custom IndexReaders (or using FilteredIndexReader)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But, if we make the proposed change here, the app could in fact just keep working off the top-level values (eg if the ctor in their class is pulling these values), thinking everything is fine when in fact there is a sizable, silent perf hit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree ... but unless i&apos;m missing something about the code on the trunk, that situation already exists: the developer might switch to using the Collector API, but nothing about the   current trunk will prevent/warn him that this...&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ValueSource vs = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ValueSource(&lt;span class=&quot;code-quote&quot;&gt;&quot;aFieldIAlsoSortOn&quot;&lt;/span&gt;);
IndexReader r = getCurrentReaderThatCouldBeAMultiReader();
DocValues vals = vs.getDocValues(r);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;...could have a sizable, silent, &lt;em&gt;memory&lt;/em&gt; perf hit in 2.9&lt;/p&gt;

&lt;p&gt;(ValueSource.getValues has a javadoc indicating that caching will be done on the IndexReader passed in, but your comment suggests that if 2.9 were released today (with hte current trunk) people upgrading would have some obvious way of noticing that they need to pass a sub reader to getValues)&lt;/p&gt;



</comment>
                    <comment id="12740604" author="mikemccand" created="Fri, 7 Aug 2009 17:01:32 +0100"  >
&lt;blockquote&gt;&lt;p&gt;Correct: a change like this could cause 2.9 to introduce a time based performance hit from the added method call to resolve the sub(reader|docvalue) on each method call ... but if we don&apos;t have a change like this, 2.9 could introduce a memory based performance hit from the other FieldCache changes as it client code accessing DocValues for the top level reader will create a duplication of the whole array.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, and of the two, I agree a hidden time cost is the lesser evil.&lt;/p&gt;

&lt;p&gt;But I&apos;d prefer to not hide the cost, ie, encourage/force an explicit&lt;br/&gt;
choice when users upgrade to 2.9.  If we can&apos;t think of some realistic&lt;br/&gt;
way to do that, then I agree we should go forward with the current&lt;br/&gt;
approach...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Incidently: I&apos;m willing to believe you that the time based perf hit would be high, but my instinct is that it wouldn&apos;t be that bad: the DocValues API already introduces at least one method call per doc lookup (two depending on datatype). adding a second method call to delegate to a sub-DocValues isntance doesn&apos;t seem that bad (especially since a new MultDocValues class could get the subReader list and compute the docId offsets on init, and then reuse them on each method call)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s the added binary search in ReaderUtil.subSearcher that worries&lt;br/&gt;
me.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;In the core I think we should always switch &quot;up high&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(In case there is any confusion: wasn&apos;t suggesting that we stop using &quot;up high&quot; switching on DocValues in code included in the Lucene dist, i was suggesting that if someone uses DocValues directly in their code (against a top level reader) then we help them out by giving them the &quot;down low&quot; switching ... so &quot;expected&quot; usages wouldn&apos;t pay the added time based hit, just &quot;unexpected&quot; usages (which would be saved from the memory hit))&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Understood.  We are only talking about external usages of these APIs,&lt;br/&gt;
and even then, exceptionally advance usage.  Ie, users who make their&lt;br/&gt;
own ValueSourceQuery and then run it against an IndexSearcher will be&lt;br/&gt;
fine.  It&apos;s only people who directly invoke getValues, w/ some random&lt;br/&gt;
reader, that hit the hidden cost.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But, if we make the proposed change here, the app could in fact just keep working off the top-level values (eg if the ctor in their class is pulling these values), thinking everything is fine when in fact there is a sizable, silent perf hit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree ... but unless i&apos;m missing something about the code on the trunk, that situation already exists: the developer might switch to using the Collector API, but nothing about the current trunk will prevent/warn him that this...&lt;/p&gt;

&lt;p&gt;ValueSource vs = new ValueSource(&quot;aFieldIAlsoSortOn&quot;);&lt;br/&gt;
IndexReader r = getCurrentReaderThatCouldBeAMultiReader();&lt;br/&gt;
DocValues vals = vs.getDocValues(r);&lt;br/&gt;
...could have a sizable, silent, memory perf hit in 2.9&lt;/p&gt;

&lt;p&gt;(ValueSource.getValues has a javadoc indicating that caching will be done on the IndexReader passed in, but your comment suggests that if 2.9 were released today (with hte current trunk) people upgrading would have some obvious way of noticing that they need to pass a sub reader to getValues)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about this: we add a new param to the ctors of the value sources,&lt;br/&gt;
called (say) acceptMultiReader.  It has 3 values:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;NO means an exception is thrown on seeing a top reader (where &quot;top&lt;br/&gt;
    reader&quot; means any reader whose getSequentialSubReaders is&lt;br/&gt;
    non-null)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;YES_BURN_TIME means accept the top reader and make a&lt;br/&gt;
     MultiDocValues&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;YES_BURN_MEMORY means use the top reader against the field cache&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We deprecate the existing ctors, so on moving to 3.0 you have to make&lt;br/&gt;
an explicit choice, but default it to YES_BURN_TIME.&lt;/p&gt;

&lt;p&gt;One benefit of making the choice explicit is for those apps that have&lt;br/&gt;
memory to burn they may in fact choose to burn it.&lt;/p&gt;

&lt;p&gt;Would this give a clean migration path forward?&lt;/p&gt;</comment>
                    <comment id="12741464" author="hossman" created="Mon, 10 Aug 2009 19:19:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;How about this: we add a new param to the ctors of the value sources, called (say) acceptMultiReader. It has 3 values:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;...that would work ... but i feel like there may be a cleaner API possible here...&lt;/p&gt;

&lt;p&gt;What if we just added a new MultiValueSource wrapper class, that acted as a proxy around another ValueSource so that the only non-transparent behavior is that MultiValueSource.getDocValues returns an instance of the new MultiDocValues we&apos;ve been talking about.&lt;/p&gt;

&lt;p&gt;If you use something like FloatFieldSource directly in your code, you get what you ask for: the FieldCache is fetched agaisnt the exact reader you supply (ie: YES_BURN_MEMORY).  If you want to use a FieldSource directly in your code, and you want to get good cache reuse, and you don&apos;t want to sorry about the subreaders yourself, you wrap your FieldSource in a new MultiValueSource(myFieldSource)  (YES_BURN_TIME)&lt;/p&gt;

&lt;p&gt;The only thing this wouldn&apos;t get us is an obvious warning to developers on upgrading (like the deprecation warnings htat would come from your suggested API) ... but since nothing about backwards compatibility is actually breaking here, that doesn&apos;t seem like the end of the world &amp;#8211; we can document it in CHANGES.txt (we&apos;re going to need a nice big section there about all the FieldCache usage changes anyway) drawing their attention to the new MultiValueSource they should consider using.&lt;/p&gt;

&lt;p&gt;My thinking is this: anybody who is constructing new ValueSOurces directly is pretty deep into the code, odds are if they&apos;re using that type of code, they might be mucking with the FieldCache directly in other ways as well &amp;#8211; we can&apos;t solve all their problems, but we can give them helper code to make the transition easier)&lt;/p&gt;</comment>
                    <comment id="12741484" author="mikemccand" created="Mon, 10 Aug 2009 19:41:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;What if we just added a new MultiValueSource wrapper class, that acted as a proxy around another ValueSource&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I like this solution!&lt;/p&gt;</comment>
                    <comment id="12742460" author="hossman" created="Wed, 12 Aug 2009 18:16:36 +0100"  >&lt;p&gt;Cool... i don&apos;t suppose you have time to work on a patch? &lt;/p&gt;

&lt;p&gt;(what&apos;s the emoticon for fingers crossed?)&lt;/p&gt;</comment>
                    <comment id="12742467" author="mikemccand" created="Wed, 12 Aug 2009 18:27:15 +0100"  >&lt;p&gt;OK, I&apos;ll take a crack at this!&lt;/p&gt;</comment>
                    <comment id="12742510" author="mikemccand" created="Wed, 12 Aug 2009 19:29:45 +0100"  >&lt;p&gt;Attached patch.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12416348" name="LUCENE-1789.patch" size="16104" author="mikemccand" created="Wed, 12 Aug 2009 19:29:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 7 Aug 2009 02:07:42 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11973</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25937</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>