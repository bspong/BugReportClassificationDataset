<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:33:18 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-584/LUCENE-584.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-584] Decouple Filter from BitSet</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-584</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; org.apache.lucene.search;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class Filter &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; java.io.Serializable 
{
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; AbstractBitSet bits(IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
}

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; AbstractBitSet 
{
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; get(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; index);
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It would be useful if the method =Filter.bits()= returned an abstract interface, instead of =java.util.BitSet=.&lt;/p&gt;

&lt;p&gt;Use case: there is a very large index, and, depending on the user&apos;s privileges, only a small portion of the index is actually visible.&lt;br/&gt;
Sparsely populated =java.util.BitSet=s are not efficient and waste lots of memory. It would be desirable to have an alternative BitSet implementation with smaller memory footprint.&lt;/p&gt;

&lt;p&gt;Though it &lt;em&gt;is&lt;/em&gt; possibly to derive classes from =java.util.BitSet=, it was obviously not designed for that purpose.&lt;br/&gt;
That&apos;s why I propose to use an interface instead. The default implementation could still delegate to =java.util.BitSet=.&lt;/p&gt;
</description>
                <environment></environment>
            <key id="12343720">LUCENE-584</key>
            <summary>Decouple Filter from BitSet</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="markrmiller@gmail.com">Mark Miller</assignee>
                                <reporter username="nightrider">Peter Sch&#228;fer</reporter>
                        <labels>
                    </labels>
                <created>Wed, 31 May 2006 19:47:02 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:05 +0100</updated>
                    <resolved>Sat, 22 Aug 2009 22:18:04 +0100</resolved>
                            <version>2.1</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>11</votes>
                        <watches>4</watches>
                                                    <comments>
                    <comment id="12414046" author="eksdev" created="Wed, 31 May 2006 20:48:34 +0100"  >&lt;p&gt;Peter, &lt;/p&gt;

&lt;p&gt;there is some advanced things you are probably interested in.&lt;/p&gt;

&lt;p&gt;see:&lt;br/&gt;
&quot;some utilities for a compact sparse filter&quot; &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-328&quot; title=&quot;Some utilities for a compact sparse filter&quot;&gt;&lt;del&gt;LUCENE-328&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Also interesting:&lt;br/&gt;
&lt;a href=&quot;#SOLR-15&quot;&gt;SOLR-15&lt;/a&gt; OpenBitSet - ASF JIRA&lt;/p&gt;

&lt;p&gt;complete solr solution for Filters is one cool thing! a bit awkward bridge to lucene due to BitSet in Filter, but this is due to be resolved... &lt;/p&gt;</comment>
                    <comment id="12414224" author="nightrider" created="Thu, 1 Jun 2006 20:11:35 +0100"  >&lt;p&gt;thanks, this looks interesting.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Peter&lt;/p&gt;</comment>
                    <comment id="12417896" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:42:23 +0100"  >&lt;p&gt;As the title of this issue is as accurate as it gets, I&apos;m attaching a  series of patches and additions here  that make Scorer a subclass of Matcher, while Matcher takes the current role of the BitSet in Filter.&lt;br/&gt;
All patches against trunk revision 417299.&lt;/p&gt;</comment>
                    <comment id="12417898" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:47:19 +0100"  >&lt;p&gt;javadocs of HitCollector.java to use &apos;matching&apos; instead of &apos;non-zero score&apos;.&lt;br/&gt;
This is actually independent of the Matcher/Scorer change.&lt;/p&gt;</comment>
                    <comment id="12417900" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:49:40 +0100"  >&lt;p&gt;javadocs of Searcher.java to use &apos;matching&apos; instead of &apos;non-zero score&apos;,&lt;br/&gt;
and to describe the Filter effect more accurately.&lt;br/&gt;
This is independent of the Matcher/Scorer change.&lt;/p&gt;</comment>
                    <comment id="12417902" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:52:04 +0100"  >&lt;p&gt;MatchCollector.java with collect(int) method for org.apache.lucene.search.&lt;/p&gt;</comment>
                    <comment id="12417904" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:53:49 +0100"  >&lt;p&gt;Matcher.java, including a match(MatchCollector) method, for org.apache.lucene.search.&lt;/p&gt;</comment>
                    <comment id="12417905" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:55:06 +0100"  >&lt;p&gt;patch to Scorer.java to subclass Matcher.&lt;/p&gt;</comment>
                    <comment id="12417907" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 05:58:23 +0100"  >&lt;p&gt;patch to Filter to add getMatcher() and to deprecate getBits() in favour of getMatcher().&lt;br/&gt;
Includes commented test code to test IndexSearcher using BitsMatcher.&lt;/p&gt;</comment>
                    <comment id="12417909" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:00:26 +0100"  >&lt;p&gt;Patch to IndexSearcher.java to prefer getMatcher() over getBits() on Filter.&lt;br/&gt;
Also add method IndexSearcher.match(Query, MatchCollector).&lt;/p&gt;</comment>
                    <comment id="12417910" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:02:44 +0100"  >&lt;p&gt;A Matcher constructed from a BitSet for org.apache.lucene.util.&lt;/p&gt;</comment>
                    <comment id="12417912" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:05:25 +0100"  >&lt;p&gt;SortedVIntList.java for org.apache.lucene.util superseding the one in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-328&quot; title=&quot;Some utilities for a compact sparse filter&quot;&gt;&lt;del&gt;LUCENE-328&lt;/del&gt;&lt;/a&gt;. Has a getMatcher() method.&lt;/p&gt;</comment>
                    <comment id="12417913" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:07:18 +0100"  >&lt;p&gt;TestSortedVIntList.java, superseding the one in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-328&quot; title=&quot;Some utilities for a compact sparse filter&quot;&gt;&lt;del&gt;LUCENE-328&lt;/del&gt;&lt;/a&gt; testing the Matcher provided by a SortedVIntList.&lt;/p&gt;</comment>
                    <comment id="12417914" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:09:06 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-328&quot; title=&quot;Some utilities for a compact sparse filter&quot;&gt;&lt;del&gt;LUCENE-328&lt;/del&gt;&lt;/a&gt; is superseded by this issue.&lt;/p&gt;</comment>
                    <comment id="12417917" author="paul.elschot@xs4all.nl" created="Tue, 27 Jun 2006 06:22:26 +0100"  >&lt;p&gt;I hope I got all the attachments right, please holler in case something does not patch or compile cleanly.&lt;/p&gt;

&lt;p&gt;Some questions/remarks:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When IndexSearcher gets a BitSet from a Filter, it will not use skipTo() on the Scorer&lt;br/&gt;
of the Query being filtered.&lt;br/&gt;
This still allows to use the 1.4 BooleanScorer until Filter.getBits() is removed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Ok. not to add match() method(s) to Searcher/Searchable ?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;BitSetIterator of &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-15&quot; title=&quot;OpenBitSet&quot;&gt;&lt;del&gt;SOLR-15&lt;/del&gt;&lt;/a&gt; could implement a Matcher, and perhaps to be added to org.apache.lucene.util ?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Matcher as superclass of Scorer opens possibility to add BooleanQuery.add(Filter) method.&lt;br/&gt;
This also needs the addition of required Matchers to ConjunctionScorer and the addition of prohibited Matchers at ReqExclScorer/DisjunctionScorer.&lt;br/&gt;
Doing this filtering in ConjunctionScorer/ReqExclScorer will probably reduce the number of method calls for filtering.&lt;br/&gt;
Once such an addition is done to BooleanQuery, the filtering methods in IndexSearcher could be deprecated in favour of BooleanQuery.add(Filter).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12418141" author="paul.elschot@xs4all.nl" created="Wed, 28 Jun 2006 06:46:59 +0100"  >&lt;p&gt;I&apos;ve started to improve the javadocs of almost all code posted here, so it&apos;s probably not worthwhile to commit this as it is now.&lt;br/&gt;
I don&apos;t expect changes to the java code in the short term.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;
</comment>
                    <comment id="12418177" author="eksdev" created="Wed, 28 Jun 2006 13:47:30 +0100"  >&lt;p&gt;Any toughts on adding OpenBitSet from solr here? &lt;/p&gt;</comment>
                    <comment id="12418185" author="paul.elschot@xs4all.nl" created="Wed, 28 Jun 2006 15:19:18 +0100"  >&lt;p&gt;Patches against trunk revision 417683, current.&lt;br/&gt;
Compared to previous patches/files, there are only javadoc updates,&lt;br/&gt;
and the javadocs of Searchable are also patched.&lt;/p&gt;
</comment>
                    <comment id="12418318" author="paul.elschot@xs4all.nl" created="Thu, 29 Jun 2006 05:08:02 +0100"  >&lt;p&gt;Added some javadocs to BitsMatcher.&lt;br/&gt;
Added Matcher constructor to SortedVIntList, and extended the test for this.&lt;/p&gt;</comment>
                    <comment id="12418842" author="paul.elschot@xs4all.nl" created="Sun, 2 Jul 2006 18:53:39 +0100"  >&lt;p&gt;Perhaps the BitsMatcher class is better implemented as a static method in a new class MatcherUtils.createMatcher(BitSet).&lt;br/&gt;
Similar methods could be added for OpenBitSet, SortedVIntList, int[] and whatever data structure comes around for implementing Filter.getMatcher(IndexReader).&lt;br/&gt;
When Matcher is a superclass of Scorer, TermScorer already implements a Matcher for TermDocs.&lt;/p&gt;</comment>
                    <comment id="12431664" author="paul.elschot@xs4all.nl" created="Wed, 30 Aug 2006 20:31:00 +0100"  >&lt;p&gt;As requested on java-dev, Matcher20060830.patch is the whole thing as a single patch, relative to srv/java/org/apache/lucene in the trunk, revision 438598 of 30 August 2006.&lt;/p&gt;

&lt;p&gt;This does not contain the FIXME the earlier posted Filter-20060628.patch .&lt;br/&gt;
This FIXME code can be used to test that IndexSearcher works correctly with a BitsMatcher filter instead of with the current BitSet filter.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12431684" author="yseeley@gmail.com" created="Wed, 30 Aug 2006 21:47:37 +0100"  >&lt;p&gt;Thanks Paul,&lt;br/&gt;
I like the Matcher/Scorer relation.&lt;/p&gt;

&lt;p&gt;It looks like no Filters currently return a matcher, so the current patch just lays the groundwork, right?&lt;/p&gt;

&lt;p&gt;When some filters do start to return a matcher, it looks like support for the 1.4 BooleanScorer needs to be removed, or a check done in IndexSearcher.search() to disable skipping on the scorer if it&apos;s in use.&lt;/p&gt;

&lt;p&gt;I wonder what the performance impact is... for a dense search with a dense bitset filter, it looks like quite a bit of overhead is added (two calls in order to get the next doc, use of nextSetBit() instead of get(), checking &quot;exhausted&quot; each time and checking for -1 to set exhausted).  I suppose one can always drop back to using a HitCollector for special cases though.&lt;/p&gt;</comment>
                    <comment id="12431685" author="paul.elschot@xs4all.nl" created="Wed, 30 Aug 2006 21:52:05 +0100"  >&lt;p&gt;Matcher20060830b.patch corrects 2 mistakes in Matcher20060830.patch:&lt;br/&gt;
Searchable.java was present twice, and TestSortedVIntList was not present.&lt;br/&gt;
Thanks eks for pointing out the mistake.&lt;/p&gt;

&lt;p&gt;This patch was generated from the trunk directory.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12431696" author="paul.elschot@xs4all.nl" created="Wed, 30 Aug 2006 22:18:03 +0100"  >&lt;p&gt;Yonik, as to you questions:&lt;/p&gt;

&lt;p&gt;&amp;gt; It looks like no Filters currently return a matcher, so the current patch just lays the groundwork, right?&lt;/p&gt;

&lt;p&gt;Right. Only the previous Filter-20060628.patch contains some commented FIXME code to actually introduce a BitsMatcher in each case where a BitSet is used.&lt;/p&gt;

&lt;p&gt;&amp;gt;When some filters do start to return a matcher, it looks like support for the 1.4 BooleanScorer needs&lt;br/&gt;
&amp;gt; to be removed, or a check done in IndexSearcher.search() to disable skipping on the scorer if it&apos;s in use.&lt;/p&gt;

&lt;p&gt;Iirc the patch still supports the 1.4 BooleanScorer when a BitSet is returned by Filter. I&apos;d have to have a look at the patched IndexSearcher to be sure though.&lt;br/&gt;
A BitSet is randomly addressable, so it can work to filter the 1.4 BooleanScorer which can score documents out of order.  This case can be deprecated completely by also deprecating the possibility to use the 1.4 boolean scorer, but that is not in the patch. The patch only deprecates the Filter.bits() method.&lt;/p&gt;


&lt;p&gt;&amp;gt; I wonder what the performance impact is... for a dense search with a dense bitset&lt;br/&gt;
&amp;gt; filter, it looks like quite a bit of overhead is added (two calls in order to get the next &lt;br/&gt;
&amp;gt; doc, use of nextSetBit() instead of get(), checking &quot;exhausted&quot; each time and &lt;br/&gt;
&amp;gt; checking for -1 to set exhausted). I suppose one can always drop back to using&lt;br/&gt;
&amp;gt; a HitCollector for special cases though.&lt;/p&gt;

&lt;p&gt;BitsMatcher could also work without the &quot;exhausted&quot; flag, but then an infinite loop&lt;br/&gt;
might occur when trying to continue after the first time next() or skipTo() returned false.&lt;br/&gt;
Continuing after false was returned in these cases is a bug, however an infinite loop&lt;br/&gt;
can be difficult to debug. I&apos;d rather be on the safe side of that with the exhausted flag and wait for an actual profile to show the performance problem.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12431702" author="eksdev" created="Wed, 30 Aug 2006 22:26:10 +0100"  >&lt;p&gt;using the latest Matcher20060830.patch &lt;/p&gt;

&lt;p&gt;ant said &quot;BUILD SUCCESSFUL&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I will see how it works on some real life cases using our 50Mio collection and report back what our standard app level tests  have to say (we have standardized collection /requsts/hits so bad things should pop -up quickly). Need a day or two for this.&lt;/p&gt;

&lt;p&gt;thanks for this work. &lt;br/&gt;
e. &lt;/p&gt;</comment>
                    <comment id="12432378" author="eksdev" created="Sun, 3 Sep 2006 21:35:02 +0100"  >&lt;p&gt;Hi Paul,&lt;br/&gt;
for me, this patch did not cause any incompatibility issues. All our tests passed without noticing any difference to the previous trunk version. No performance changes as well ( we use HitCollector only, so Yoniks comment does not apply here).&lt;br/&gt;
Tests are application level, and make index hot (6hrs searches with test batch of requests with known responses), 50Mio not artificial docs, real requests...&lt;/p&gt;

&lt;p&gt;Early this week we will try to implement our first Matchers and see how they behave&lt;/p&gt;
</comment>
                    <comment id="12432435" author="paul.elschot@xs4all.nl" created="Mon, 4 Sep 2006 07:46:42 +0100"  >&lt;p&gt;&amp;gt; No performance changes as well.&lt;/p&gt;

&lt;p&gt;It&apos;s good to hear that. As mentioned earlier, this is groundwork only.&lt;br/&gt;
Once an actual Matcher is used I expect some some performance differences to show up.&lt;/p&gt;

&lt;p&gt;Which comment of Yonik related to HitCollector do you mean?&lt;/p&gt;

&lt;p&gt;&amp;gt; Early this week we will try to implement our first Matchers and see how they behave &lt;/p&gt;

&lt;p&gt;BitsMatcher and SortedVIntList could start that.&lt;br/&gt;
Also I&apos;d like to see one on Solr&apos;s OpenBitSet...&lt;/p&gt;
</comment>
                    <comment id="12432497" author="eksdev" created="Mon, 4 Sep 2006 12:41:44 +0100"  >&lt;p&gt;Paul,&lt;br/&gt;
What is exact semantics of skipTo(int) in Matcher?&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;is it OK to skip back and forth before I reach end?&lt;br/&gt;
e.g.: skipTo(0); skipTo(333); skipTo(0); &lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;once I reach end, skipTo(int) does nothing (BitsMatcher, exhausted). It is impossible to reposition Matcher after that&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Is this intended behavior, &quot;skip forward until you reach end, and then, you are at the end &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&quot; ? &lt;/p&gt;



</comment>
                    <comment id="12432547" author="eksdev" created="Mon, 4 Sep 2006 22:02:22 +0100"  >&lt;p&gt;Here are some Matcher implementations,&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;OpenBitsMatcher- the same as the code Paul wrote for BitsMatcher, with replaced OpenBitSet instead&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-DenseOpenBitsMatcher  - Using solr BitSetIterator (for skipTo() to work, one method in BitSetIterator should become public)&lt;/p&gt;

&lt;p&gt;Also attached one simple  test (just basic fuctionality) that also contains one dummy relative performance  test &lt;/p&gt;

&lt;p&gt;Perf. test simply iterates over different Matcher implementations  and measures ellapsed time (not including Matcher creation, pure forward scan to the end) for different set bit densities.&lt;/p&gt;

&lt;p&gt;imho, this code is not sufficiantly tested nor commented, needs an hour or two.  &lt;/p&gt;

&lt;p&gt;As expected, Yonik made this ButSetIterator really fast. What was surprise for me was OpenBitSet nextSetBit() comparing bad to the BitSet  (or I made some dummy mistake somewhere?)&lt;/p&gt;</comment>
                    <comment id="12434637" author="eksdev" created="Thu, 14 Sep 2006 11:12:15 +0100"  >&lt;p&gt;Paul,&lt;br/&gt;
What is next now, we did on our app enough experiments and are now sure that this patch causes no incompatibilities. &lt;br/&gt;
We also tried to replace our filters with OpenBitSet and VInt matchers and results there are more than good, our app showed crazy  30% speed-up!!! Hard to identify where from exactly, but I suspect VInt matcher in case of not too dense BitVectors increased our Filter Cache utilization significantly.&lt;/p&gt;

&lt;p&gt;I would propose to commit this patch before we go further with something that would actually utilize Matcher. Just to avoid creating monster patch on patch ... &lt;/p&gt;

&lt;p&gt;This is ground work, and now using Matcher will be pure poetry, I see a lot of places we could see beter life by using use Matchers, ConstantScoringQuery, PreffixFilter, ChainedFilter (becomes obsolete now)... actually replace all uses of BitSet with OpenBitSet (or a bit smarter with SortedIntList. VInt...)...&lt;br/&gt;
Than question here, do we create dependancy to Solr from Lucene, or we &quot;migrate&quot; OpenBitSet to Lucene (as this dependancy allready exists) or we copy-paste and have two OpenBitSets, Yonik? As far as I am concerned, makes no real diference.&lt;/p&gt;

&lt;p&gt;Do you, or someone else see now things to be done before commiting this? &lt;/p&gt;
</comment>
                    <comment id="12434763" author="paul.elschot@xs4all.nl" created="Thu, 14 Sep 2006 19:40:42 +0100"  >&lt;p&gt;&amp;gt; Do you, or someone else see now things to be done before commiting this?&lt;/p&gt;

&lt;p&gt;Yes. In the steps listed here:&lt;br/&gt;
&lt;a href=&quot;http://wiki.apache.org/jakarta-lucene/HowToContribute&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/jakarta-lucene/HowToContribute&lt;/a&gt;&lt;br/&gt;
the next step is to be patient.&lt;br/&gt;
Wether being patient is something that can be done&lt;br/&gt;
is open question...&lt;/p&gt;

&lt;p&gt;Paul Elschot.&lt;/p&gt;
</comment>
                    <comment id="12434901" author="paul.elschot@xs4all.nl" created="Fri, 15 Sep 2006 08:04:21 +0100"  >&lt;p&gt;In the inheritance from Matcher to Scorer there is an asymmetry&lt;br/&gt;
in this patch.&lt;/p&gt;

&lt;p&gt;Matcher provides a default implementation for Matcher.explain()&lt;br/&gt;
but Scorer does not, and this might lead to unexpected surprises&lt;br/&gt;
for future Scorers when the current Matcher.explain() is used.&lt;br/&gt;
One could add an abstract Scorer.explain() to catch these, or&lt;br/&gt;
provide a default implementation for Scorer.explain().&lt;/p&gt;

&lt;p&gt;With matcher implementations quite a few other implementation&lt;br/&gt;
decisions need to be taken. &lt;br/&gt;
Also any place in the current code where a Scorer is used, but none&lt;br/&gt;
of the Scorer.score() methods, is a candidate for a change from&lt;br/&gt;
Scorer to Matcher.&lt;br/&gt;
This will be mostly the current filtering implementations,&lt;br/&gt;
but ConstantScoringQuery is another nice example.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12437242" author="paul.elschot@xs4all.nl" created="Sun, 24 Sep 2006 20:27:00 +0100"  >&lt;p&gt;I wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; One could add an abstract Scorer.explain() to catch these, or&lt;br/&gt;
&amp;gt; provide a default implementation for Scorer.explain().&lt;/p&gt;

&lt;p&gt;by mistake. The good news is that the patch leaves the &lt;br/&gt;
the existing abstract Scorer.explain() method unaffected.&lt;/p&gt;</comment>
                    <comment id="12446365" author="paul.elschot@xs4all.nl" created="Wed, 1 Nov 2006 20:01:24 +0000"  >&lt;p&gt;Corrected javadoc refs to use IndexInput and IndexOutput.&lt;/p&gt;</comment>
                    <comment id="12450715" author="paul.elschot@xs4all.nl" created="Fri, 17 Nov 2006 12:26:19 +0000"  >&lt;p&gt;I have just resolved some minor local conflicts on the updated copyrights of four java  files.&lt;br/&gt;
Please holler when a fresh  patch is needed.&lt;/p&gt;</comment>
                    <comment id="12475981" author="paul.elschot@xs4all.nl" created="Mon, 26 Feb 2007 20:03:43 +0000"  >&lt;p&gt;As 2.1 is out, here is a new patch to try and revive this.&lt;br/&gt;
This replaces the pevious Matcheryyyymmdd.patch one of 2006&lt;/p&gt;</comment>
                    <comment id="12481263" author="hossman" created="Thu, 15 Mar 2007 18:06:40 +0000"  >&lt;p&gt;It&apos;s been a while since i looked at this issue, but it&apos;s come up in discussion recently so i took another glance...&lt;/p&gt;

&lt;p&gt;Paul: I notice Filter.getMatcher returns null, and IndexSearcher tests for that and uses it to decide whether or not to iterator over the (non null) Matcher, or over the BitSet from Filter.bits.  is there any reason that logic can&apos;t be put in getMatcher, so that if subclasses of Filter don&apos;t override the getMatcher method it will call bits and then return a Matcher that iterates over the set Bits?&lt;/p&gt;

&lt;p&gt;(this is the roll-out approach i advocated a while back when discussing this on email, excecept that at the time Matcher was refered to as SearchFilter: &lt;a href=&quot;http://www.nabble.com/RE%3A-Filter-p2605271.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/RE%3A-Filter-p2605271.html&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;Thinking about it now, we could even change Filter.bits so it&apos;s no longer abstract ... it could have an implementation that would call getMatcher, and iterate over all of the matched docs setting bits on a BitSet that is then returned ... the class would still be abstract, and the class javadocs  would make it clear that subclasses must override at least one of the methods ... legacy Filters will work fine because they&apos;ll already have a bits method, and people writing new Filters will see that bits is deprecated, so they&apos;ll just write a getMatcher method and be done.&lt;/p&gt;

&lt;p&gt;This appears to be the same approach taken with Analyzer.tokenStream back in 1.4.3...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lucene.apache.org/java/1_4_3/api/org/apache/lucene/analysis/Analyzer.html&quot; class=&quot;external-link&quot;&gt;http://lucene.apache.org/java/1_4_3/api/org/apache/lucene/analysis/Analyzer.html&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12481734" author="paul.elschot@xs4all.nl" created="Fri, 16 Mar 2007 19:09:25 +0000"  >&lt;p&gt;Hoss,&lt;/p&gt;

&lt;p&gt;&amp;gt;Paul: I notice Filter.getMatcher returns null, and IndexSearcher tests for that and uses&lt;br/&gt;
&amp;gt; it to decide whether or not to iterator over the (non null) Matcher, or over the BitSet&lt;br/&gt;
&amp;gt; from Filter.bits. is there any reason that logic can&apos;t be put in getMatcher, so that if&lt;br/&gt;
&amp;gt; subclasses of Filter don&apos;t override the getMatcher method it will call bits and then&lt;br/&gt;
&amp;gt; return a Matcher that iterates over the set Bits?&lt;/p&gt;

&lt;p&gt;Two reasons:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;uncertainty over performance of a Matcher instead of a BitSet,&lt;/li&gt;
	&lt;li&gt;this way backward compatibility very easily guaranteed.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There is also &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-730&quot; title=&quot;Restore top level disjunction performance&quot;&gt;&lt;del&gt;LUCENE-730&lt;/del&gt;&lt;/a&gt;, which may interfere with the removal of BitSet,&lt;br/&gt;
since it allows documents to be scored out of order. However, &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-730&quot; title=&quot;Restore top level disjunction performance&quot;&gt;&lt;del&gt;LUCENE-730&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
should only be used at the top level of a query search and without a Filter.&lt;br/&gt;
I cannot think of an actual case in which there might be interference, but&lt;br/&gt;
I may not have not looked into that deep enough.&lt;/p&gt;

&lt;p&gt;&amp;gt; we could even change Filter.bits so it&apos;s no longer abstract ... it could have&lt;br/&gt;
&amp;gt; an implementation that would call getMatcher, and iterate over all of the matched&lt;br/&gt;
&amp;gt; docs setting bits on a BitSet that is then returned ... the class would still be&lt;br/&gt;
&amp;gt; abstract, and the class javadocs would make it clear that subclasses must override&lt;br/&gt;
&amp;gt; at least one of the methods...&lt;/p&gt;

&lt;p&gt;I must say that creating a BitSet from a Matcher never occurred to me.&lt;br/&gt;
Anyway, when Filter.bits() is deprecated I have no preference about how&lt;br/&gt;
it is actually removed.&lt;/p&gt;</comment>
                    <comment id="12483724" author="otis" created="Fri, 23 Mar 2007 19:54:04 +0000"  >&lt;p&gt;Paul:&lt;br/&gt;
Applied the patch, applied cleanly, run ant test -&amp;gt; BUILD SUCCESSFUL &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m primarily interested in using this in order to get matches, but avoid scoring.  From what I can tell, I&apos;d just need to switch to using the new match(Query, MatchCollector) method in IndexSearcher.  However, I need Sort and TopFieldDocs, and I don&apos;t see a match method with those.  Is there a reason why such a match method is not in the patch?&lt;/p&gt;</comment>
                    <comment id="12483731" author="paul.elschot@xs4all.nl" created="Fri, 23 Mar 2007 20:13:25 +0000"  >&lt;p&gt;Otis:&lt;/p&gt;

&lt;p&gt;&amp;gt; However, I need Sort and TopFieldDocs, and I don&apos;t see a match method with those.&lt;br/&gt;
&amp;gt; Is there a reason why such a match method is not in the patch? &lt;/p&gt;

&lt;p&gt;A bit silly perhaps, but what sort criterion would like to have used when no score() value is available?&lt;/p&gt;

&lt;p&gt;I don&apos;t know the sorting code, but it might be possible to use a field value for sorting.&lt;br/&gt;
In that case the sorting code for a Matcher would need to check whether the sort criterion does&lt;br/&gt;
not imply the use of a score value.&lt;br/&gt;
I personally have no use for sorting by field values, so that is why I never thought of combining this with a Matcher.&lt;/p&gt;


</comment>
                    <comment id="12483868" author="yseeley@gmail.com" created="Sat, 24 Mar 2007 19:39:59 +0000"  >&lt;p&gt;&amp;gt; BitsMatcher could also work without the &quot;exhausted&quot; flag, but then an infinite loop&lt;br/&gt;
&amp;gt; might occur when trying to continue after the first time next() or skipTo() returned false.&lt;br/&gt;
&amp;gt; Continuing after false was returned in these cases is a bug, however an infinite loop&lt;br/&gt;
&amp;gt; can be difficult to debug. I&apos;d rather be on the safe side of that with the exhausted flag and wait for an actual &lt;br/&gt;
&amp;gt; profile to show the performance problem.&lt;/p&gt;

&lt;p&gt;We know that matchers will be inner-loop stuff.  It seems like any scorers that call next() after false was returned should be fixed.&lt;/p&gt;</comment>
                    <comment id="12483894" author="paul.elschot@xs4all.nl" created="Sat, 24 Mar 2007 23:15:55 +0000"  >&lt;p&gt;&amp;gt; We know that matchers will be inner-loop stuff. It seems like any scorers that call next() after false was returned should be fixed.&lt;/p&gt;

&lt;p&gt;I fully agree. The &quot;exhausted&quot; flag is not much more than a matter of taste.&lt;/p&gt;

&lt;p&gt;In case the speed advantage of removing this flag is preferred, I don&apos;t mind resolving the eventual conflict in my working copy.&lt;br/&gt;
But I don&apos;t know yet how I would resolve that conflict &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12483895" author="yseeley@gmail.com" created="Sat, 24 Mar 2007 23:22:40 +0000"  >&lt;p&gt;&amp;gt; In case the speed advantage of removing this flag is preferred, I don&apos;t mind resolving the eventual conflict in my&lt;br/&gt;
&amp;gt; working copy.  But I don&apos;t know yet how I would resolve that conflict &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Ah, that&apos;s a bit different.  You mean there are cases that are non-trivial to fix where next() is called after false is returned?&lt;/p&gt;</comment>
                    <comment id="12487106" author="otis" created="Thu, 5 Apr 2007 22:33:18 +0100"  >&lt;p&gt;Perhaps I did something wrong with the benchmark, but I didn&apos;t get any speed-up when using searcher.match(Query, MatchCollector) vs. searcher.search(Query, HitCollector).&lt;/p&gt;

&lt;p&gt;Here are the benchmark numbers (50000 queries with each), HitCollector first, MatchCollector second:&lt;/p&gt;

&lt;p&gt;HITCOLLECTOR:&lt;/p&gt;

&lt;p&gt;     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; ------------&amp;gt; Report Sum By (any) Name (11 about 41 out of 41)&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation           round mrg buf   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Rounds_4                0  10  10        1       808020        787.5    1,026.04     7,217,624     17,780,736&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Populate -  -  -  -  -  - - - - - -  -   4 -  -  - 2003 -  -   129.9 -  -  61.67 -   9,938,986 -   13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CreateIndex             -   -   -        4            1          4.4        0.91     3,937,522     10,916,864&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -  -  -   - - - - - -  -   4 -  -  - 2000 -  -   138.1 -  -  57.92 -   9,368,584 -   13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Optimize                -   -   -        4            1          1.4        2.83     9,938,218     13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CloseIndex -  -  -  -   - - - - - -  -   4 -  -  -  - 1 -  - 2,000.0 -  -   0.00 -   9,938,986 -   13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; OpenReader              -   -   -        4            1         24.0        0.17     9,957,592     13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SearchSameRdr_50000 -   - - - - - -  -   4 -  -   50000 -  - 1,070.3 -  - 186.86 -  10,500,146 -   13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CloseReader             -   -   -        4            1      4,000.0        0.00     9,059,756     13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; WarmNewRdr_50 -  -  -   - - - - - -  -   4 -  -  100000 -   16,237.7 -  -  24.63 -   9,060,268 -   13,821,952&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchNewRdr_50000        -   -   -        4        50000        265.9      752.02    10,800,006     13,821,952&lt;/p&gt;


&lt;p&gt;     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; ------------&amp;gt; Report sum by Prefix (MAddDocs) and Round (4 about 4 out of 41)&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation     round mrg buf   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000     0  10  10        1         2000         94.6       21.15     7,844,112     10,407,936&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -   1 100  10 -  -   1 -  -  - 2000 -  -   136.7 -  -  14.63 -   8,968,144 -   11,309,056&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000     2  10 100        1         2000        173.2       11.55    10,528,264     15,740,928&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -   3 100 100 -  -   1 -  -  - 2000 -  -   188.7 -  -  10.60 -  10,133,816 -   17,829,888&lt;/p&gt;


&lt;p&gt;MATCHCOLLECTOR:&lt;/p&gt;


&lt;p&gt;     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; ------------&amp;gt; Report Sum By (any) Name (11 about 41 out of 41)&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation           round mrg buf   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Rounds_4                0  10  10        1       808020        781.0    1,034.62    10,566,608     15,859,712&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Populate -  -  -  -  -  - - - - - -  -   4 -  -  - 2003 -  -   130.9 -  -  61.23 -  10,963,452 -   14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CreateIndex             -   -   -        4            1         33.9        0.12     3,616,570     11,020,288&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -  -  -   - - - - - -  -   4 -  -  - 2000 -  -   137.3 -  -  58.29 -  10,445,568 -   14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Optimize                -   -   -        4            1          1.4        2.82    10,979,398     14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CloseIndex -  -  -  -   - - - - - -  -   4 -  -  -  - 1 -  - 2,000.0 -  -   0.00 -  10,963,452 -   14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; OpenReader              -   -   -        4            1         22.0        0.18    10,982,058     14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SearchSameRdr_50000 -   - - - - - -  -   4 -  -   50000 -  - 1,064.7 -  - 187.84 -  11,060,036 -   14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; CloseReader             -   -   -        4            1      4,000.0        0.00    10,353,206     14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; WarmNewRdr_50 -  -  -   - - - - - -  -   4 -  -  100000 -   16,419.0 -  -  24.36 -  10,431,062 -   14,806,016&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchNewRdr_50000        -   -   -        4        50000        263.0      760.34    11,912,358     14,806,016&lt;/p&gt;


&lt;p&gt;     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; ------------&amp;gt; Report sum by Prefix (MAddDocs) and Round (4 about 4 out of 41)&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation     round mrg buf   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000     0  10  10        1         2000         92.2       21.69     7,844,112     10,407,936&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -   1 100  10 -  -   1 -  -  - 2000 -  -   136.6 -  -  14.64 -   7,720,352 -   10,407,936&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000     2  10 100        1         2000        167.8       11.92    11,325,952     17,571,840&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; MAddDocs_2000 -   3 100 100 -  -   1 -  -  - 2000 -  -   199.3 -  -  10.03 -  14,891,856 -   20,836,352&lt;/p&gt;



&lt;p&gt;This is what I did for the benchmark.  I used Doron&apos;s handy conf/benchmark.&lt;br/&gt;
I added a new .alg based on micro-standard.alg, here&apos;s the diff:&lt;/p&gt;


&lt;p&gt;$ diff conf/micro-standard.alg conf/matcher-micro-standard.alg &lt;br/&gt;
60c60&lt;br/&gt;
&amp;lt;     { &quot;SearchSameRdr&quot; Search &amp;gt; : 50000&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
&amp;gt;     { &quot;SearchSameRdr&quot; SearchMatch &amp;gt; : 50000&lt;br/&gt;
65c65&lt;br/&gt;
&amp;lt;     { &quot;SrchNewRdr&quot; Search &amp;gt; : 50000&lt;br/&gt;
&amp;#8212;&lt;br/&gt;
&amp;gt;     { &quot;SrchNewRdr&quot; SearchMatch &amp;gt; : 50000&lt;/p&gt;


&lt;p&gt;Then I added 2 new Tasks for benchamrking the Matcher (searcher.search(Query, MatchCollector)) and modified the ReadTask to call searcher.search(Query, HitCollector) instead of the method to get Hits.&lt;/p&gt;

&lt;p&gt;I commented out all search results traversal and doc retrieval, as I didn&apos;t care to measure that.&lt;/p&gt;</comment>
                    <comment id="12487430" author="doronc" created="Sun, 8 Apr 2007 04:59:14 +0100"  >&lt;p&gt;The benchmark does not search with filters. Is any speedup still expected? (why?)&lt;/p&gt;

&lt;p&gt;I applied the patch on current trunk and ran the benchmark - it shows that when all queries use the same reader, Match is faster while when each query opens its own reader bitset is faster. Is this an expected result? &lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Operation           round   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem
SrchMtchSamRdr_5000     -       10         5000        642.2       77.85    12,331,866     16,408,576
SrchBitsSamRdr_5000 -   - -  -  10 -  -  - 5000 -  -   586.9 -  -  85.20 -   9,515,875 -   12,009,472
SrchMtchNewRdr_500      -       10          500        134.7       37.11    13,376,113     17,171,660
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This test is using all Reuters documents and the searches rounds are repeated 10 times. The Match tasks were not included so I wrote them. The updated bench-diff.txt attached contains these task classes and the algorithm.  (When you use this, note that once the index is created you can comment the first part - the &quot;Populate&quot; part - and then only rerun the querying part.)&lt;/p&gt;</comment>
                    <comment id="12487431" author="doronc" created="Sun, 8 Apr 2007 05:07:42 +0100"  >&lt;p&gt;One line was cut out - here are the four lines again&lt;/p&gt;

&lt;p&gt;Operation           round   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
SrchMtchSamRdr_5000     -       10         5000        642.2       77.85    12,331,866     16,408,576&lt;br/&gt;
SrchBitsSamRdr_5000 -   - -  -  10 -  -  - 5000 -  -   586.9 -  -  85.20 -   9,515,875 -   12,009,472&lt;br/&gt;
SrchMtchNewRdr_500      -       10          500        134.7       37.11    13,376,113     17,171,660&lt;br/&gt;
SrchBitsNewRdr_500 -  - - -  -  10 -  -  -  500 -  -   154.0 -  -  32.47 -  15,351,395 -   17,522,688&lt;/p&gt;</comment>
                    <comment id="12487432" author="otis" created="Sun, 8 Apr 2007 06:21:02 +0100"  >&lt;p&gt;Doron, thanks for jumping on this!&lt;/p&gt;

&lt;p&gt;1. I thought I&apos;d see better performance with the Matcher because it skips scoring.  While Paul&apos;s patch does make changes to the Filtering code, I&apos;m more focused on HitCollector vs. MatchCollector performance here.  Am I missing something here?  If scoring is skipped, we should see at least some speed improvement, and your results show that.&lt;/p&gt;

&lt;p&gt;2. You said you &lt;b&gt;did&lt;/b&gt; see MatchCollector was faster than HitCollector.  Hmmm, weird, not in my 4 runs:&lt;/p&gt;

&lt;p&gt;Matcher:&lt;br/&gt;
 &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SearchSameRdr_50000 - - - - - - - - 4 - - 50000 - - 1,064.7 - - 187.84 - 11,060,036 - 14,806,016 &lt;br/&gt;
HitCollector: &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SearchSameRdr_50000 - - - - - - - - 4 - - 50000 - - 1,070.3 - - 186.86 - 10,500,146 - 13,821,952 &lt;/p&gt;

&lt;p&gt;I&apos;ll try it again on a different computer.  My previous runs were on a Mac with OSX.&lt;/p&gt;

&lt;p&gt;3. My bench-diff.txt did include Match tasks:&lt;/p&gt;

&lt;p&gt;$ grep Match bench-diff.txt | grep class&lt;br/&gt;
public class SearchMatchTask extends MatchTask {&lt;br/&gt;
public abstract class MatchTask extends ReadTask {&lt;/p&gt;

&lt;p&gt;... but I didn&apos;t svn add them, so I produced the &quot;diff&quot; by simply cat-ing the new tasks to bench-diff.txt .  So if you used my bench-diff.txt as a patch, it wouldn&apos;t have worked.  Not a big deal, just clarifying.&lt;/p&gt;</comment>
                    <comment id="12487456" author="doronc" created="Sun, 8 Apr 2007 21:20:29 +0100"  >&lt;p&gt;...right, your diff-txt had the Match tasks - I missed that - checked it, it is exactly what I did, so we&apos;re ok here. &lt;/p&gt;

&lt;p&gt;When you rerun, you may want to use my alg - to compare the two approaches in one run. You can run this by something like:&lt;br/&gt;
     ant run-task -Dtask.mem=256M -Dtask.alg=conf\matcher-vs-bitset.alg&lt;/p&gt;

&lt;p&gt;Also, to get cleaner results, add the line:&lt;br/&gt;
     ResetSystemSoft&lt;br/&gt;
just in the beginning of the &quot;search round&quot; - this resets the (query) inputs and also calls GC.&lt;/p&gt;

&lt;p&gt;I tried like this twice, and got inconsistent results:&lt;/p&gt;

&lt;p&gt;When the bitset searches preceded the match searches:&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation           round   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchBitsSamRdr_5000     -       10         5000        706.4       70.78     7,511,219     16,573,645&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchMtchSamRdr_5000 -   - -  -  10 -  -  - 5000 -  -   689.6 -  -  72.50 -   8,223,005 -   11,926,323&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchBitsNewRdr_500      -       10          500        152.5       32.80    14,360,618     16,962,356&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchMtchNewRdr_500 -  - - -  -  10 -  -  -  500 -  -   171.3 -  -  29.19 -  15,150,797 -   17,395,712&lt;/p&gt;

&lt;p&gt;When the match searches preceded the bitset searches:&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; Operation           round   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchMtchSamRdr_5000     -       10         5000        763.5       65.49     9,563,243     17,128,244&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchBitsSamRdr_5000 -   - -  -  10 -  -  - 5000 -  -   729.3 -  -  68.56 -  10,003,775 -   13,001,114&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchMtchNewRdr_500      -       10          500        175.7       28.46    12,068,559     17,524,326&lt;br/&gt;
     &lt;span class=&quot;error&quot;&gt;&amp;#91;java&amp;#93;&lt;/span&gt; SrchBitsNewRdr_500 -  - - -  -  10 -  -  -  500 -  -   183.7 -  -  27.22 -  15,098,480 -   17,974,476&lt;/p&gt;

&lt;p&gt;My conclusion from this is that the speed-up, if exists, is minor, at least for the setup of this test. &lt;/p&gt;

&lt;p&gt;There are only 15 unique queries in this test - also printed in the log - are these the queries you would expect to save in? &lt;/p&gt;

&lt;p&gt;I didn&apos;t follow this issue very closely so I don&apos;t know where the saving is expected here. Both SearchTask and MatchTask now do nothing in collect, so no difference at the actual collect() call.&lt;/p&gt;

&lt;p&gt;Also, Scorer.score(HitCollector) and Matcher.match(MatchCollector) are very similar:&lt;br/&gt;
  public void score(HitCollector hc) throws IOException {&lt;br/&gt;
    while (next()) &lt;/p&gt;
{
      hc.collect(doc(), score());
    }
&lt;p&gt;  }&lt;br/&gt;
  public void match(MatchCollector mc) throws IOException {&lt;br/&gt;
    while (next()) &lt;/p&gt;
{
      mc.collect(doc());
    }
&lt;p&gt;  }&lt;br/&gt;
Especially for the case that the collect() method is doing nothing, as in this test.&lt;/p&gt;

&lt;p&gt;I think there is a potential gain for large boolean OR queries, because score() would have to call next() on all TermScorers and collect/sum their scores, while match() could use skipTo(last+1) because any match encountered is a match and there is no need to sum the individual scores for the same doc by other scorers. However as far as I can tell, current match() implementation does not take advantage of this, but I may be overlooking something?&lt;/p&gt;</comment>
                    <comment id="12487594" author="yseeley@gmail.com" created="Mon, 9 Apr 2007 19:32:48 +0100"  >&lt;p&gt;&amp;gt; When you rerun, you may want to use my alg - to compare the two approaches in one run.&lt;/p&gt;

&lt;p&gt;This is more dangerous though.  GC from one method&apos;s garbage can penalize the 2nd methods performance.&lt;br/&gt;
Also, hotspot effects are hard to account for (if method1 and method2 use common methods, method2 will often execute faster than method one because more optimization has been done on those common methods).&lt;/p&gt;

&lt;p&gt;The hotspot effect can be minimized by running the test multiple times in the same JVM instance and discarding the first runs, but it&apos;s not so easy for GC.&lt;/p&gt;</comment>
                    <comment id="12487613" author="klaasm" created="Mon, 9 Apr 2007 20:27:38 +0100"  >&lt;p&gt;Instead of discarding the first run, the approach I usually take is to run 3-4 times and pick the minimum.  You can then run several of these &quot;sets&quot; and average over the minimum of each.  GC is still an issues, though.  It is hard to get around when it is a mark&amp;amp;sweep collector (reference counting is much friendlier in this regard)&lt;/p&gt;</comment>
                    <comment id="12487616" author="doronc" created="Mon, 9 Apr 2007 20:34:13 +0100"  >&lt;p&gt;&amp;gt; &amp;gt; When you rerun, you may want to use my alg - to compare the two approaches in one run. &lt;br/&gt;
&amp;gt; This is more dangerous though. &lt;/p&gt;

&lt;p&gt;Agree. I was trying to get rid of this by splitting each round to 3: - gc(), warm(), work() - when work() and warm() are the same, just that warm()&apos;s stats are disregarded. Still switching the order of &quot;by match&quot; and &quot;by bits&quot; yield different results. &lt;/p&gt;

&lt;p&gt;Sometimes we would like not to disregard GC - in particular if one approach is creating more (or more complex) garbage than another approach. &lt;/p&gt;

&lt;p&gt;Perhaps we should look at two measures: best &amp;amp; avg/sum (2nd ignoring first run, for hotspot). &lt;/p&gt;</comment>
                    <comment id="12487631" author="otis" created="Mon, 9 Apr 2007 22:02:44 +0100"  >&lt;p&gt;Doron: just to address your question from Apr/7 - I expect/hope to see an improvement in performance because of this difference:&lt;/p&gt;

&lt;p&gt;      hc.collect(doc(), score()); &lt;br/&gt;
      mc.collect(doc()); &lt;/p&gt;

&lt;p&gt;the delta being the cost of the score() call that does the scoring.  If I understand things correctly, that means that what grant described at the bottom of &lt;a href=&quot;http://lucene.apache.org/java/docs/scoring.html&quot; class=&quot;external-link&quot;&gt;http://lucene.apache.org/java/docs/scoring.html&lt;/a&gt; will all be skipped.  No Scorer, no BooleanScorer(2), no ConjunctionScorer...&lt;/p&gt;</comment>
                    <comment id="12487667" author="doronc" created="Tue, 10 Apr 2007 02:14:12 +0100"  >&lt;p&gt;&amp;gt; No Scorer, no BooleanScorer(2), no ConjunctionScorer... &lt;/p&gt;

&lt;p&gt;Thanks, I was reading &quot;score&quot; instead of &quot;score()&quot;...&lt;/p&gt;

&lt;p&gt;But there is a scorer in the process, it is used for next()-ing to matched docs. So most of the work - preparing to be able to compute the scores - was done already. The scorer doc queue is created and populated. Not calling score() is saving the (final) looping on the scorers for aggregating their scores, multiplying by coord factor, etc. I assume this is why only a small speed up is seen. &lt;/p&gt;</comment>
                    <comment id="12487674" author="otis" created="Tue, 10 Apr 2007 03:35:47 +0100"  >&lt;p&gt;Ahhhh.  I&apos;ll look at the patch again tomorrow and follow what you said.  All this time I was under the impression that one of the points or at least side-effects of the Matcher was that scoring was skipped, which would be perfect where matches are ordered by anything other than relevance.&lt;/p&gt;
</comment>
                    <comment id="12487675" author="creamyg" created="Tue, 10 Apr 2007 03:54:55 +0100"  >&lt;p&gt;DisjunctionSumScorer (the ORScorer) actually calls Scorer.score() on all of the matching scorers in the ScorerDocQueue during next(), in order to accumulate an aggregate score.  The MatchCollector can&apos;t save you from that.&lt;/p&gt;</comment>
                    <comment id="12487706" author="paul.elschot@xs4all.nl" created="Tue, 10 Apr 2007 08:22:59 +0100"  >&lt;p&gt;That could be improved in a DisjunctionMatcher.&lt;br/&gt;
With a bit of bookkeeping DisjunctionSumScorer could also delay calling score() on the subscorers&lt;br/&gt;
but the bookkeeping would affect performance for the normal case.&lt;/p&gt;

&lt;p&gt;For the usual queries the score() call will never have much of a performance impact.&lt;br/&gt;
The reason for this is that TermScorer.score() is really very efficient, iirc it caches&lt;br/&gt;
weighted tf() values for low term frequencies.&lt;br/&gt;
All the rest is mostly additions, and occasionally a multiplication for a coordination factor.&lt;/p&gt;

&lt;p&gt;To determine which documents match the query, the index need to be accessed,&lt;br/&gt;
and that takes more time than score value computations because the complete index&lt;br/&gt;
almost never fits in the fastest cache.&lt;/p&gt;
</comment>
                    <comment id="12487789" author="otis" created="Tue, 10 Apr 2007 16:10:53 +0100"  >&lt;p&gt;Ah, too bad. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Last time I benchmarked Lucene searching on Sun&apos;s Niagara vs. non-massive Intel boxes, Intel boxes with Linux on them actually won, and my impression was that this was due to Niagara&apos;s weak FPU (a known weakness in Niagara, I believe).  Thus, I thought, if we could just skip scoring and various floating point calculations, we&apos;d see better performance, esp. on Niagara boxes.&lt;/p&gt;

&lt;p&gt;Paul, when you say &quot;fastest cache&quot;, what exactly are you referring to?  The Niagara I tested things on had 32GB of RAM, and I gave the JVM 20+GB, so at least the JVM had plenty of RAM to work with.&lt;/p&gt;</comment>
                    <comment id="12487882" author="paul.elschot@xs4all.nl" created="Tue, 10 Apr 2007 19:59:48 +0100"  >&lt;p&gt;By fastest cache I meant the L1 cache of the processor. The size is normally in tens of kilobytes.&lt;br/&gt;
An array lookup hitting that cache takes about as much time as a floating point addition.&lt;/p&gt;

&lt;p&gt;During a query search the use of a.o. the term frequencies, the proximity data, and the document weights normally cause an L1 cache miss.&lt;/p&gt;

&lt;p&gt;I would expect that by not doing the score value computations, only the cache misses for document weights can be saved.&lt;/p&gt;</comment>
                    <comment id="12487940" author="hossman" created="Tue, 10 Apr 2007 23:24:15 +0100"  >&lt;p&gt;I&apos;m a little behind on following this issue, but if i can attempt to sum up the recent discussion about performance...&lt;/p&gt;

&lt;p&gt;   &quot;Migrating towards a &quot;Matcher&quot; API &lt;b&gt;may&lt;/b&gt; allow some types of Queries to be faster in situations where clients can use a MatchCollector instead of a HitCollector, but this won&apos;t be a silver bullet performance win for all Query classes &amp;#8211; just those where some of the score calculations is (or can be) isolated to the score method (as opposed to skipTO or next)&quot;&lt;/p&gt;

&lt;p&gt;I think it&apos;s important to remember the motivation of this issue wasn&apos;t to improve the speed performance of non-scoring searchers, it was to decouple the concept of &quot;Filtering&quot; results away from needing to populate a (potentially large) BitSet when the logic neccessary for Filtering can easily be expressed in terms of a doc iterator (aka: a Matcher) &amp;#8211; opening up the possibility of memory performance improvements.  &lt;/p&gt;

&lt;p&gt;A second benefit that has arisen as the issue evolved, has been the API generalization of the &quot;Matcher&quot; concept to be a super class of Scorer for simpler APIs moving forward.&lt;/p&gt;

</comment>
                    <comment id="12487966" author="otis" created="Wed, 11 Apr 2007 03:07:53 +0100"  >&lt;p&gt;Right.  I was under the wrong impression that the Matcher also happens to avoid scoring.  However, now that we&apos;ve all looked at this patch (still applies cleanly and unit tests all pass), and nobody had any criticisms, I think we should commit it, say this Friday.&lt;/p&gt;

&lt;p&gt;As I&apos;m in the performance squeezing mode, I&apos;ll go look at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-730&quot; title=&quot;Restore top level disjunction performance&quot;&gt;&lt;del&gt;LUCENE-730&lt;/del&gt;&lt;/a&gt;, another one of Paul&apos;s great patches, and see if I can measure performance improvement there.&lt;/p&gt;</comment>
                    <comment id="12488733" author="hossman" created="Fri, 13 Apr 2007 19:00:44 +0100"  >&lt;p&gt;I&apos;m still behind on following this issue, but Otis: if you are interested in moving forward with this, you might consider trying the cahnges i proposed in my &quot;15/Mar/07 11:06 AM&quot; Comment...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-584#action_12481263&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-584#action_12481263&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;...I think it would keep IndexSearcher a little cleaner, and make it easier for people to migrate existing Filter&apos;s gradually (without requiring extra work for people writing new &quot;Matcher&quot; style Filters from scratch)&lt;/p&gt;</comment>
                    <comment id="12511186" author="paul.elschot@xs4all.nl" created="Mon, 9 Jul 2007 18:31:58 +0100"  >&lt;p&gt;With 2.2 out, and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-730&quot; title=&quot;Restore top level disjunction performance&quot;&gt;&lt;del&gt;LUCENE-730&lt;/del&gt;&lt;/a&gt; out of the way, wouldn&apos;t this be a good moment for some progress with this issue?&lt;br/&gt;
The patch still applies cleanly, and I&apos;d like to start working on a skipping extension of SortedVIntList, much like the latest index format for document lists.&lt;/p&gt;</comment>
                    <comment id="12515248" author="paul.elschot@xs4all.nl" created="Wed, 25 Jul 2007 11:21:05 +0100"  >&lt;p&gt;This DefaultMatcher2007072.patch adds a default Matcher to be used in Filter instead of the BitSet . It contains static methods that create a default Matcher from a BitSet and from an OpenBitSet. The patch also add OpenBitSet to org.apache.lucene.util; it was taken from a recent solr revision.&lt;/p&gt;

&lt;p&gt;In this way the deprecation of Filter.bits(IndexReader) can be done by replacing implementations of that method by Filter.getMatcher(IndexReader) and adding the above default Matcher in the return statement:&lt;br/&gt;
return DefaultMatcher.defaultMatcher(bits);&lt;/p&gt;

&lt;p&gt;The idea is to have this hook available so that a sensible default Matcher is easily available, that can also be adapted to use better Matcher implementations when these become available.&lt;br/&gt;
The current implementation uses a SortedVIntList when it is smaller than an (Open)BitSet.&lt;/p&gt;

&lt;p&gt;I have begun introducing the default matcher in my working copy of the core, but as expected, that turns out to be quite a bit of work.&lt;br/&gt;
Before I continue with that, I&apos;d like to have comments on this default matcher approach.&lt;/p&gt;</comment>
                    <comment id="12515313" author="paul.elschot@xs4all.nl" created="Wed, 25 Jul 2007 16:10:30 +0100"  >&lt;p&gt;There is some code in contrib where a Filter is assumed to have BitSet available:&lt;/p&gt;

&lt;p&gt;contrib/queries/src/java/org/apache/lucene/search/BooleanFilter.java&lt;br/&gt;
contrib/miscellaneous/src/java/org/apache/lucene/misc/ChainedFilter.java&lt;/p&gt;

&lt;p&gt;When Filter is going to move from BitSet to Matcher, these will have to be reimplemented.&lt;br/&gt;
They basically use Filters to provide BitSets, but it seems to me that they also&lt;br/&gt;
could use lists of BitSets, for example.&lt;/p&gt;</comment>
                    <comment id="12515372" author="paul.elschot@xs4all.nl" created="Wed, 25 Jul 2007 19:12:36 +0100"  >&lt;p&gt;The whole thing in three patches:&lt;/p&gt;

&lt;p&gt;The Matcher-ground patch is the groundwork, which should be very similar to the earlier groundwork patch.&lt;/p&gt;

&lt;p&gt;The Matcher-default patch provides a default implementation, the same as the one I posted earlier today. Among others, It includes OpenBitSet from solr in org.apache.lucene.util .&lt;/p&gt;

&lt;p&gt;The Matcher-core uses the default implementation inside the rest of the lucene core and test code. It replaces Filter.bits() methods with Filter.getMatcher() methods in the subclasses of Filter.&lt;/p&gt;


&lt;p&gt;All core tests pass with these patches aplied., except the one below.&lt;br/&gt;
I could not determine why this test fails, and the only&lt;br/&gt;
reason I can think of now is that Matcher is not serializable.&lt;br/&gt;
Could someone give me a clue on this?&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testsuite: org.apache.lucene.search.TestRemoteCachingWrapperFilter&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 1.32 sec&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase: testTermRemoteFilter(org.apache.lucene.search.TestRemoteCachingWrapperFilter):    FAIL&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; expected:&amp;lt;1&amp;gt; but was:&amp;lt;0&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: expected:&amp;lt;1&amp;gt; but was:&amp;lt;0&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;     at org.apache.lucene.search.TestRemoteCachingWrapperFilter.search(TestRemoteCachingWrapperFiava:84)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;     at org.apache.lucene.search.TestRemoteCachingWrapperFilter.testTermRemoteFilter(TestRemoteCarapperFilter.java:109)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Test org.apache.lucene.search.TestRemoteCachingWrapperFilter FAILED&lt;/p&gt;


&lt;p&gt;Finally, contrib may not even compile with the patches applied.&lt;br/&gt;
I used a version of Filter with an abstract getMatcher() method for the Matcher-core patch,&lt;br/&gt;
and I also used that to cut the explicit BitSet things from my contrib working copy.&lt;br/&gt;
However, I don&apos;t want to provide a patch for contrib yet, it&apos;s too far from ready here,&lt;br/&gt;
and I&apos;d like some comments on how to go about that first.&lt;/p&gt;</comment>
                    <comment id="12515395" author="markh" created="Wed, 25 Jul 2007 20:48:34 +0100"  >&lt;p&gt;Hi Paul,&lt;br/&gt;
Not sure if I&apos;m missing something but I think this patch may not work for scenarios other than the simple option of a single filter being used on a search.&lt;/p&gt;

&lt;p&gt;A Matcher does not have the same utility as a BitSet because using a BitSet you can:&lt;/p&gt;

&lt;p&gt;1) iterate across it using multiple threads.&lt;br/&gt;
2) Clone it.&lt;br/&gt;
3) Merge it quickly with other bitsets using Boolean logic .&lt;br/&gt;
4) Use it more than once.&lt;/p&gt;

&lt;p&gt;I think these differences become important in the following scenarios :&lt;/p&gt;

&lt;p&gt;In CachingWrapperFilter I don&apos;t think you can cache Matchers instead of bitsets - because Matchers don&apos;t have features 1 and 4&lt;/p&gt;

&lt;p&gt;BooleanFilter and ChainedFilter in contrib don&apos;t work with Matchers because there is no support  for 3) &lt;/p&gt;

&lt;p&gt;Is there something obvious I&apos;ve missed?&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12515434" author="paul.elschot@xs4all.nl" created="Wed, 25 Jul 2007 22:54:08 +0100"  >&lt;p&gt;Have a look at BitSetMatcher in the -default patch. It is constructed from a BitSet, and it has a method getMatcher() that returns a Matcher that acts as a searching iterator over the BitSet.&lt;/p&gt;

&lt;p&gt;So that is 1) to 4), at least potentially. A clone() method is currently not implemented iirc, but each call to getMatcher() will return a new iterator over the underlying BitSet. And when guaranteed non modifyability is needed, a constructor can take a copy of the given document set, in whatever form.&lt;/p&gt;

&lt;p&gt;The point of Matcher is that it allows other implementations than BitSet, like OpenBitSet and SortedVIntList. Both have the properties that you are looking for. SortedVIntList can&lt;br/&gt;
save a lot of memory when compared to (Open)BitSet, and OpenBitSet is somewhat faster than BitSet. &lt;/p&gt;

&lt;p&gt;I&apos;d like to have a skip list version of SortedVIntList, too. This would be slightly larger than SortedVIntList, but more efficient on skipTo().&lt;/p&gt;

&lt;p&gt;But the first thing that is necessary is to have Filter independent from BitSet.&lt;/p&gt;

&lt;p&gt;The real pain with that is going to be the code that currently implements Filters&lt;br/&gt;
outside the lucene code base, and a default implementation of a Matcher&lt;br/&gt;
should be of help there, just as it is in the -core patch now.&lt;/p&gt;

&lt;p&gt;The default implementation will probably need to be improved from its current&lt;br/&gt;
state, but that can be done later. For example, one could also use OpenBitSet&lt;br/&gt;
in all cases, and even collect the filtered documents directly in that.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12515437" author="paul.elschot@xs4all.nl" created="Wed, 25 Jul 2007 23:05:03 +0100"  >&lt;p&gt;I forgot to mention that boolean logic on Matchers is already in present in BooleanScorer2.&lt;br/&gt;
This is because each Scorer is a Matcher.&lt;/p&gt;</comment>
                    <comment id="12515494" author="markh" created="Thu, 26 Jul 2007 05:08:47 +0100"  >&lt;p&gt;Thanks for the reply, Paul.&lt;/p&gt;

&lt;p&gt;I saw BitSetMatcher etc and appreciate the motivation behind the design for alternative implementations . What concerns me with the Matcher API in general is that Matchers have non-threadsafe safe state (i.e. the current position required to support next() )and as such aren&apos;t safely cachable in the same way as BitSets. I see the searcher code uses the safer skipTo() rather than next()  but there&apos;s still the &quot;if(exhausted)&quot; thread safety problem to worry about which is why I raised points 1 and 4.&lt;/p&gt;

&lt;p&gt;Additionally, combining Bitsets using Booolean logic is one method call whereas combining heterogenous Matchers using Boolean logic requires iteration across them and therefore potentially many method calls (point 3). I haven&apos;t benchmarked this but I imagine it to be significantly slower?&lt;br/&gt;
I use BooleanFilter a lot for security where many large sets are cached and combined on the fly - caching all the possible combinations as single bitsets would lead to too many possible combinations. &lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12515630" author="paul.elschot@xs4all.nl" created="Thu, 26 Jul 2007 09:47:08 +0100"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;p&gt;The exhausted flag is only in the iterator/Matcher, not in the underlying set data structure. One can use as many iterators as necessary, for example one per thread, and then there is never a threadsafety problem. (See BitSetMatcher.getMatcher() which uses a local class for the resulting Matcher.)&lt;/p&gt;

&lt;p&gt;You wrote: I use BooleanFilter a lot for security where many large sets are cached and combined on the fly - caching all the possible combinations as single bitsets would lead to too many possible combinations.&lt;/p&gt;

&lt;p&gt;That can still be done, but one needs to get to the BitSets for example by caching them outside the Filters and constructing the resulting BitSetMatcher for the combined Filter on the fly.&lt;/p&gt;

&lt;p&gt;An alternative would be to have a BooleanQuery.add(Matcher, Occur), where the occurrence can only be required or prohibited. Then there is no need to construct any resulting filter because the boolean logic will be executed during the search.  This might even be more efficient than combining the full BitSets ahead of the search.&lt;/p&gt;

&lt;p&gt;And with many large BitSets cache memory savings from more compact implementations can also be helpful.&lt;/p&gt;
</comment>
                    <comment id="12516154" author="paul.elschot@xs4all.nl" created="Sat, 28 Jul 2007 10:16:51 +0100"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;p&gt;An easy way to keep things like BooleanFilter working could be to&lt;br/&gt;
introduce a subclass of Filter, say BitsFilter that adds a bits(IndexReader) method.&lt;br/&gt;
This class should also implement getMatcher(), the default implementation could&lt;br/&gt;
be used for that initially.&lt;br/&gt;
Then BooleanFilter could simply be a subclass of BitsFilter, possibly without further&lt;br/&gt;
modifications, although I would prefer to rename it to BooleanBitsFilter.&lt;/p&gt;

&lt;p&gt;That would only involve some deprecation warnings in BitsFilter for the period&lt;br/&gt;
that Filter.bits() is deprecated.&lt;/p&gt;

&lt;p&gt;I would not even mind cooking this up as patch to contrib.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12516487" author="paul.elschot@xs4all.nl" created="Mon, 30 Jul 2007 20:15:38 +0100"  >&lt;p&gt;A different take in the patches of 20070730.&lt;/p&gt;

&lt;p&gt;In this version class Filter has only one method:&lt;br/&gt;
public abstract Matcher getMatcher(IndexReader).&lt;/p&gt;

&lt;p&gt;Class BitSetFilter is added as a subclass of Filter, and it has the familiar&lt;br/&gt;
public abstract BitSet bits(IndexReader),&lt;br/&gt;
as well as a default implementation of the getMatcher() method.&lt;/p&gt;

&lt;p&gt;In the ..core.. patch, and in the ..contrib.. patches (to follow), most uses of Filter simply replaced by BitSetFilter. This turned out to be an easy way of dealing&lt;br/&gt;
with this API change in Filter.&lt;/p&gt;

&lt;p&gt;This change to Filter and its replacement by BitSetFilter could well be taking&lt;br/&gt;
things too far for now, and I&apos;d like to know whether other approaches&lt;br/&gt;
are preferred.&lt;/p&gt;

&lt;p&gt;The ..default.. patch contains a default implementation of a Matcher from a BitSet, and it has OpenBitSet and friends from solr, as well as SortedVIntList as posted earlier.&lt;/p&gt;




</comment>
                    <comment id="12516490" author="paul.elschot@xs4all.nl" created="Mon, 30 Jul 2007 20:24:50 +0100"  >&lt;p&gt;Some 20070730 patches to contrib using BitSetFilter.&lt;br/&gt;
The contrib-misc and contrib-queries patches are reasonbly good,&lt;br/&gt;
their tests pass and replacing Filter by BitSetFilter is right for them.&lt;/p&gt;

&lt;p&gt;However, I&apos;m not happy with the contrib-xml patch to the xml-query parser.&lt;br/&gt;
I had to criple some of the code and to disable the TestQueryTemplateManager test.&lt;br/&gt;
I don&apos;t know how to get around this, basically because I don&apos;t know whether&lt;br/&gt;
it is a good idea at all to move the xml-query-parser to BitSetFilter. It might be&lt;br/&gt;
better to move it to Filter.getMatcher() instead, but I have no idea how to do this.&lt;/p&gt;</comment>
                    <comment id="12516491" author="paul.elschot@xs4all.nl" created="Mon, 30 Jul 2007 20:27:06 +0100"  >&lt;p&gt;Uploading the patches again, this time with the ASF license.&lt;/p&gt;</comment>
                    <comment id="12516502" author="paul.elschot@xs4all.nl" created="Mon, 30 Jul 2007 20:50:31 +0100"  >&lt;p&gt;Some more remarks on the 20070730 patches.&lt;/p&gt;

&lt;p&gt;To recap, this introduces Matcher as a superclass of Scorer to take the role that BitSet currently has in Filter.&lt;/p&gt;

&lt;p&gt;The total number of java files changed/added by these patches is 47, so some extra care will be needed.&lt;br/&gt;
The following issues are still pending:&lt;/p&gt;

&lt;p&gt;What approach should be taken for the API change to Filter (see above, 2 comments up)?&lt;/p&gt;

&lt;p&gt;I&apos;d like to get all test cases to pass again. TestRemoteCachingWrapperFilter still does not pass, and&lt;br/&gt;
I don&apos;t know why.&lt;/p&gt;

&lt;p&gt;For xml-query-parser in contrib I&apos;d like to know in which direction to proceed (see 1 comment up).&lt;br/&gt;
Does it make sense to try and get the TestQueryTemplateManager test to pass again?&lt;/p&gt;

&lt;p&gt;The ..default.. patch has taken OpenBitSet and friends from solr to have a default implementation.&lt;br/&gt;
However, I have not checked whether there is unused code in there, so some trimming may still&lt;br/&gt;
be appropriate.&lt;/p&gt;

&lt;p&gt;Once these issues have been resolved far enough, I would recommend to introduce this shortly after a release so there is some time to let things settle.&lt;/p&gt;
</comment>
                    <comment id="12518569" author="markh" created="Wed, 8 Aug 2007 23:55:38 +0100"  >&lt;p&gt;Hi Paul,&lt;br/&gt;
Many thanks for your responses.&lt;br/&gt;
Sorry for the delay in communications - just got back from 2 weeks holiday and slowly picking my way through this patch. &lt;/p&gt;

&lt;p&gt;You said: &quot;there is never a threadsafety problem. (See BitSetMatcher.getMatcher() which uses a local class for the resulting Matcher.)&quot;&lt;/p&gt;

&lt;p&gt;Did you mean BitSetFilter.getMatcher()? BitSetMatcher has no getMatcher method.&lt;/p&gt;

&lt;p&gt;If so, doesn&apos;t my original thread safety issue still stand? - CachingWrapperFilter is caching Matchers (not Filters which are factories for matchers). &lt;/p&gt;

&lt;p&gt;The existing approach of adding a &amp;lt;CachedFilter&amp;gt; tag around my XML-based query templates offers a major speed up in my applications and I don&apos;t see this supported in this patch currently which gives me some concern. This existing caching technique is based on the use of CachingWrapperFilter.&lt;/p&gt;

&lt;p&gt;The proposed framework seems to be missing a means of caching reusable, threadsafe  Matchers in a type-independent fashion. One solution (which I think you may be suggesting with the &quot;getMatcher&quot; comment) is to cache Filter objects and use Filter.getMatcher(reader) as a factory method for thread-specific, single-use Matchers but this would suggest that any caching then becomes an implied responsibility/overhead of each Filter implementation. Not too great. CachingWrapperFilter is an example of a better design where the caching policy has been implemented in a single class and it can be used to decorate any Filter implementation (RangeFilter etc) with the required caching behaviour. Unfortunately with this proposed patch there is no way that any such single caching policy can work with any Filter because Matcher is not reusable/cachable. Time to remove any  thread-specific state from Matcher?&lt;/p&gt;


&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;










</comment>
                    <comment id="12518642" author="markh" created="Thu, 9 Aug 2007 08:09:29 +0100"  >&lt;p&gt;Some further thought on the roles/responsibilities of the various components:&lt;/p&gt;

&lt;p&gt;Given a blank sheet of paper (a luxury we may not have) the minimum requirements I would have could be met with the following:&lt;br/&gt;
(note that use of the words &quot;Matcher&quot; and &quot;Filter&quot; etc have been removed because sets of doc IDs have applications outside of filtering/querying e.g. category counts)&lt;/p&gt;

&lt;p&gt;interface DocIdSetFactory&lt;br/&gt;
{&lt;br/&gt;
    DocIdSet getDocIdSet(IndexReader reader)&lt;br/&gt;
}&lt;br/&gt;
This is more or less equivalent to the purpose of the existing &quot;Filter&quot; - different implementations define their own selection criteria and produce a set of matching doc Ids e.g. equivalent of RangeFilter. Each implementation must implement &quot;hashcode&quot; and &quot;equals&quot; methods based on it&apos;s criteria so the factory can be cached and reused (in the same way Query objects are expected to). The existing CachedFilterBuilder in the XMLQueryParser provides one example of a strategy for caching Filters using this facility. &lt;/p&gt;


&lt;p&gt;interface DocIdSet&lt;br/&gt;
{&lt;br/&gt;
    DocIdSetIterator getIterator();&lt;br/&gt;
}&lt;br/&gt;
This interface defines an immutable, threadsafe (and therefore cachable) collection of doc IDs. Different implementations provide space-efficient alternatives for sparse or heavily populated sets e.g. BitSet, OpenBitSet, SortedVIntList. As an example caching strategy - the existing CachingWrapperFilter would cache these objects in a WeakHashMap keyed on IndexReader.&lt;/p&gt;

&lt;p&gt;interface DocIdSetIterator&lt;br/&gt;
{&lt;br/&gt;
    boolean next();&lt;br/&gt;
    int getDoc();&lt;br/&gt;
   ....etc&lt;br/&gt;
}&lt;br/&gt;
A thread unsafe, single use object, (probably with only one implementation) that is used to iterate across any DocIdSet. Not cachable and used by Scorers.&lt;/p&gt;

&lt;p&gt;In the existing proposal it feels like DocIdSet and DocIdSetIterator are rolled into one in the form of the Matcher which complicates/prevents caching strategies.&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;

</comment>
                    <comment id="12518825" author="paul.elschot@xs4all.nl" created="Thu, 9 Aug 2007 20:45:10 +0100"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;p&gt;I said: &quot;there is never a threadsafety problem. (See BitSetMatcher.getMatcher() which uses a local class for the resulting Matcher.)&quot;&lt;br/&gt;
That was a mistake. BitSetMatcher is a Matcher constructed from a BitSet, and SortedVIntList has a getMatcher() method, and I confused the two.&lt;/p&gt;

&lt;p&gt;A Matcher is intended to be used in a single thread, so I don&apos;t expect thread safety problems.&lt;/p&gt;

&lt;p&gt;The problem for the XML parser is that with this patch, the implementing data structure of a Filter becomes&lt;br/&gt;
unaccessible from the Filter class, so it cannot be cached from there.&lt;br/&gt;
That means that some cached data structure will have to be chosen, and one way to do&lt;br/&gt;
that is by using class BitSetFilter from the patch. This has a bits() method just like the current Filter class.&lt;br/&gt;
CachingWrapperFilter could then become a cache for BitSetFilter.&lt;/p&gt;

&lt;p&gt;There is indeed no caching of filters in this patch.&lt;br/&gt;
The reason for that is that some Filters do not need a cache. For example:&lt;br/&gt;
class TermFilter {&lt;br/&gt;
  TermFilter(Term t) &lt;/p&gt;
{this.term = t;}
&lt;p&gt;  Matcher getMatcher(reader) &lt;/p&gt;
{return new TermMatcher( reader.termDocs(this.term);}
&lt;p&gt;}&lt;br/&gt;
TermMatcher does not exist (yet), but it could be easily introduced by leaving all the&lt;br/&gt;
scoring out of the current TermScorer.&lt;/p&gt;

&lt;p&gt;As for DocIdSet, as long as this provides a Matcher as an iterator, it can be used to&lt;br/&gt;
implement a (caching) filter.&lt;/p&gt;

&lt;p&gt;I don&apos;t think this patch complicates the implementation of caching strategies.&lt;br/&gt;
For example one could define:&lt;br/&gt;
class CachableFilter extends Filter {&lt;br/&gt;
  ... some methods to access the underlying data structure to be cached. ...&lt;br/&gt;
}&lt;br/&gt;
or write a similar adapter for some subclass of Filter and then write a FilterCache that caches these.&lt;/p&gt;

&lt;p&gt;I did consider defining Matcher as an interface, but I preferred not to do that because&lt;br/&gt;
of the default explain() method in the Matcher class of the patch.&lt;/p&gt;</comment>
                    <comment id="12518845" author="markh" created="Thu, 9 Aug 2007 22:32:26 +0100"  >&lt;p&gt;Hi Paul,&lt;/p&gt;

&lt;p&gt;Not sure we&apos;ve reached a common understanding here yet.&lt;/p&gt;

&lt;p&gt;You said &quot;That was a mistake. BitSetMatcher is a Matcher constructed from a BitSet, and SortedVIntList has a getMatcher() method, and I confused the two. &quot;&lt;br/&gt;
Ok, thanks for the clarification. I still feel uncomfortable because the method getMatcher() is not abstracted to a common interface. This was the thinking behind my &quot;getIterator&quot; method on DocIdSet.&lt;/p&gt;

&lt;p&gt;I too made a mistake in my earlier comments. DocIdSetIterator does NOT have &quot;probably one implementation&quot;. There would be an implementation for each different type of DocIdSet (Bitset/OpenBitSet/VIntList).&lt;/p&gt;

&lt;p&gt;You said &quot;some Filters do not need a cache. For example: TermFilter&quot;.  I&apos;m not sure why that has been singled out as not worthy of caching. I have certain terms (e.g. gender:male) where the TermDocs is very large (50% of all docs in the index!) so multiple calls to TermDocs for term &quot;gender:male&quot; (if that is what you are suggesting) is highly undesirable. These are typically handled in the XMLQueryParser using syntax like this:&lt;br/&gt;
  &amp;lt;CachedFilter&amp;gt;&lt;br/&gt;
        &amp;lt;TermsFilter fieldName=&quot;gender&quot;&amp;gt;male&amp;lt;/TermsFilter&amp;gt;&lt;br/&gt;
  &amp;lt;/CachedFilter&amp;gt;&lt;/p&gt;

&lt;p&gt;You said: &quot;CachingWrapperFilter could then become a cache for BitSetFilter. &quot;&lt;br/&gt;
This means that the only caching strategy is one based on bitsets - does this not lose perhaps the main benefit of your whole proposal? - the ability to have alternative space efficient storage of sets of document ids e.g. SortedVIntList.&lt;/p&gt;

&lt;p&gt;If this is undesirable (my guess is &quot;yes&quot;) then the proposal in my previous comment is a solution which allows for caching of any/all types of the new sets (openBitSet,BitSet,SortedVIntList etc) Regardless of my choice of class names or decisions over interfaces vs abstract classes do you not at least agree the need for 3 types of functionality:&lt;/p&gt;

&lt;p&gt;1) A factory for instantiating sets of document ids matching a particular set of criteria (which can be costly to call). While the factory is not expected to implement a caching  strategy it is expected to implement hashcode/equals simply to aid any caching services which would need this help to identify previously instantiated sets which share the same criteria as ant new requests (This service I identified as my &quot;DocIdSetFactory&quot; and TermsFilter/RangeFilter would be example implementations). &lt;br/&gt;
2) An object representing an instantiated set of document ids which can be cached and can create iterators for use in seperate threads (identified as my DocIdSet -  example implementations being called something like BitSetDocSet, SortedVIntList) &lt;br/&gt;
3) An iterator for a set of document ids (my DocIdSetIterator - example impls being called something like BitSetDocSetIterator SortedVIntListIterator)&lt;/p&gt;

&lt;p&gt;Each type of functionality can have different implementations so the functionality must be defined using an interface or abstract class. &lt;br/&gt;
If we can agree this much as a set of responsibilities then we can begin to map these services onto something more concrete.&lt;/p&gt;


&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;



</comment>
                    <comment id="12518858" author="paul.elschot@xs4all.nl" created="Thu, 9 Aug 2007 23:28:26 +0100"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;p&gt;I think we are one the same line, it&apos;s just that I don&apos;t want to go that far now.&lt;br/&gt;
Have another look at the title of this issue, it may be in your title bar, but otherwise &lt;br/&gt;
it&apos;s quite a bit of scrolling so I&apos;ll repeat it here: &quot;Decouple Filter from BitSet&quot;. &lt;br/&gt;
That is the main thing that this patch tries to do.&lt;/p&gt;

&lt;p&gt;And that also makes it a starting point for caching of different data structures for Filters.&lt;br/&gt;
Caching of Filters is very much needed, but I&apos;d rather see that as another issue.&lt;/p&gt;

&lt;p&gt;The DefaultMatcher class tries to do some compression by using a SortedVIntList when that is smaller than a BitSet, and that is about as far as I&apos;d like to go now.&lt;/p&gt;

&lt;p&gt;Proost,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12518868" author="markh" created="Fri, 10 Aug 2007 00:14:32 +0100"  >&lt;p&gt;OK, I appreciate caching may not be a top priority in this proposal but I have live systems in production using XMLQueryParser and which use the existing core facilities for caching. As it stands this proposal breaks this functionality (see &quot;FIXME&quot; in contrib&apos;s CachedFilterBuilder and my concerns over use of  unthreadsafe Matcher in the core class CachingWrapperFilter)&lt;/p&gt;

&lt;p&gt;I am obviously concerned by this and keen to help shape a solution which preserves the existing capabilities while adding your new functionality. I&apos;m not sure I share your view that support for caching can be treated as a separate issue to be dealt with at a later date. There are a larger number of changes proposed in this patch and if the design does not at least consider future caching issues now, I suspect much will have to be reworked later. The change I can envisage most clearly is expressed in my concern that the DocIdSet and DocIdSetIterator services I outlined are being combined in Matcher as it stands now and these functions will have to be separated.&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12522030" author="hossman" created="Thu, 23 Aug 2007 06:55:50 +0100"  >&lt;p&gt;I, unfortunately, haven&apos;t had the time to read through everything in the latest patches, but catching up on my jira mail one of Paul&apos;s comments jumped out at me, so i wanted to make sure it&apos;s completley clear: this latest set of patches completely breaks backwards compatibility for any clients who have Filter subclasses, or methods that take a Filter as a param, since the Filter class now has an abstract getMatcher method and no longer supports an abstract BitSet method &amp;#8211; presumably the expectation being that all client code should have a search/replace done from Filter=&amp;gt;BitSetFilter&lt;/p&gt;

&lt;p&gt;which begs the question: why not eliminate BitSetFilter and move it&apos;s getMatcher impl to the Filter class?  (if the concern is just that there be a &quot;higher level&quot; class in which both methods are abstract, why not insert a parent with some new name above the Filter class?)&lt;/p&gt;




&lt;p&gt;For the record: it really bothers me that the old attachments got deleted ... the inability to refresh my memory by looking at the older patches and compare them with the current patches is extremely frustrating&lt;/p&gt;</comment>
                    <comment id="12523917" author="paul.elschot@xs4all.nl" created="Thu, 30 Aug 2007 20:11:48 +0100"  >&lt;p&gt;This set of patches indeed break backward compatibility with the current Filter class.&lt;br/&gt;
That was done to show the ideal end situation, and to make sure that the patched code is indeed there.&lt;/p&gt;

&lt;p&gt;To get backward compatibility I&apos;d prefer to temporarily copy the functionality from BitSetFilter into the Filter class, while still leaving BitSetFilter as it is:&lt;/p&gt;

&lt;p&gt;public class Filter {&lt;br/&gt;
   /** @deprecated use class BitSetFilter instead */&lt;br/&gt;
  public abstract BitSet bits(IndexReader reader);&lt;/p&gt;

&lt;p&gt;  /** this method will become abstract once the bits() method is removed from Filter: */&lt;br/&gt;
  public Matcher getMatcher(IndexReader reader) &lt;/p&gt;
{return DefaultFilter.defaultFilter(bits(reader));}
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;The main difference between the current set of patches and the removed patches is indicated&lt;br/&gt;
in my first comment of 25 July 2007 above.&lt;br/&gt;
I still have the older versions of the patch lying around here, so if you need a particular one, just indicated the date, and I&apos;ll repost or send it.&lt;/p&gt;</comment>
                    <comment id="12524301" author="paul.elschot@xs4all.nl" created="Sat, 1 Sep 2007 21:21:09 +0100"  >&lt;p&gt;Another way to decouple from BitSet would be to keep introduce a new superclass of Filter that only has an abstract getMatcher() method, and to add an implementation of that method in the current Filter class.&lt;br/&gt;
That would boil down to the current patch with two classes renamed:&lt;br/&gt;
Filter -&amp;gt;  new class with abstract getMatcher() method.&lt;br/&gt;
BitSetFilter -&amp;gt; Filter.&lt;/p&gt;

&lt;p&gt;This would avoid all backward compatibility issues, except for the unlikely case in which a getMatcher() method is already implemented in an existing subclass of Filter.&lt;br/&gt;
Also, to take advantage of the independence of BitSet in other implementations, only this new class would need to be used.&lt;br/&gt;
The only disadvantage I can see is that Filter is not renamed to BitSetFilter, which it actually is. But that can be fixed by making the javadoc of Filter explicit about the use of BitSet.&lt;/p&gt;

&lt;p&gt;For the lucene core and some of the contrib, this would mean that it would move to this new superclass of Filter. Again, I don&apos;t expect backward compatibility issues there.&lt;/p&gt;

&lt;p&gt;Does anyone see any problems with this approach?&lt;br/&gt;
When not, what name should this new superclass of Filter have? I&apos;m thinking of MatchFilter, any other suggestions?&lt;/p&gt;</comment>
                    <comment id="12525223" author="paul.elschot@xs4all.nl" created="Wed, 5 Sep 2007 22:27:49 +0100"  >&lt;p&gt;This time (20070905), as indicated in the previous post, a set of patches that add MatchFilter as the new superclass of Filter. Backward compatibility is quite good, no changes at all are necessary in contrib.&lt;/p&gt;

&lt;p&gt;In the 1ground patch, the current core API is moved from Filter to MatchFilter. Since Filter is a subclass of MatchFilter, I do not expect backward compatibility issues with this, but it is a quite extensive API change.&lt;/p&gt;

&lt;p&gt;In the 2default patch, some support for MatchFilter caching was added in classes DefaultMatcher and MatcherProvider. OpenBitSet and some support for that was added from solr here, but OpenBitSet is not used (yet). SortedVIntList is also added, and this is used for caching in CachingWrapperFilter as below.&lt;/p&gt;

&lt;p&gt;In the 3core patch, this caching support is used in CachingWrapperFilter. See also java-dev of yesterday and today for a fixed thread safety problem there.&lt;br/&gt;
The remainder of the core code is also adapted to the use of Matcher in the 3core patch. ConstantScoreQuery is a nice example.&lt;/p&gt;

&lt;p&gt;I also added the Apache Licence to all new files.&lt;/p&gt;

&lt;p&gt;All tests pass with the patches applied, core and contrib.&lt;br/&gt;
Quite a bit of javadoc is included, and the javadocs build with only one (unrelated) warning.&lt;/p&gt;

&lt;p&gt;These 3 patches modify 35 source code files, so please tread carefully. They were generated against revision 573048.&lt;br/&gt;
I did some local svn mv, svn add, and svn rm, and I hope I got&lt;br/&gt;
that right in the end. In case the patches do not apply cleanly, please holler.&lt;/p&gt;

&lt;p&gt;I will remove my previous patch set in a week or so.&lt;/p&gt;</comment>
                    <comment id="12528420" author="rengels@ix.netcom.com" created="Tue, 18 Sep 2007 16:51:41 +0100"  >&lt;p&gt;I don&apos;t think &lt;/p&gt;

&lt;p&gt;public interface AbstractBitSet&lt;/p&gt;

&lt;p&gt;is according to standards.&lt;/p&gt;

&lt;p&gt;It should just be&lt;/p&gt;

&lt;p&gt;public interface BitSet&lt;/p&gt;

&lt;p&gt;possibly&lt;/p&gt;

&lt;p&gt;public interface IBitSet&lt;/p&gt;

&lt;p&gt;if coming from the Windows world.&lt;/p&gt;

&lt;p&gt;Since it is in a different package, there is no collision with the standard BitSet class.&lt;/p&gt;</comment>
                    <comment id="12528539" author="paul.elschot@xs4all.nl" created="Tue, 18 Sep 2007 21:13:52 +0100"  >&lt;p&gt;The posted patch proposes to use this class to determine which documents should be filtered:&lt;/p&gt;

&lt;p&gt;public abstract class Matcher {&lt;br/&gt;
  public abstract boolean next() throws IOException;&lt;br/&gt;
  public abstract boolean skipTo(int target) throws IOException;&lt;br/&gt;
  public abstract int doc();&lt;br/&gt;
  // plus a few more methods&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;This class is then used as a superclass of org.apache.lucene.search.Scorer.&lt;/p&gt;</comment>
                    <comment id="12529632" author="paul.elschot@xs4all.nl" created="Sat, 22 Sep 2007 09:15:11 +0100"  >&lt;p&gt;As the current patch set is large, I&apos;ve been pondering how to do this in a series of smaller patches that can each be applied by itself. This is possible in the following way:&lt;/p&gt;

&lt;p&gt;1. introduce Matcher as superclass of Scorer and adapt javadocs to use matching consistently.&lt;br/&gt;
2. introduce MatchFilter as superclass of Filter and add a minimal DefaultMatcher to be used in IndexSearcher, i.e. add BitSetMatcher&lt;br/&gt;
3. change the current Searcher/Searchable API to use MatchFilter instead of Filter.&lt;/p&gt;

&lt;p&gt;Step 1 can be reasonably done before a new a release.&lt;br/&gt;
After step 2 this issue might be closed, and all the rest could be treated as new issues.&lt;/p&gt;

&lt;p&gt;After that three (almost) independent paths can be followed:&lt;br/&gt;
4. add more data structures to be used for filter caches.&lt;br/&gt;
5. adapt CachingWrapperFilter to provide a Matcher from a cached datastructure, for example SortedVIntList or BitSet or OpenBitSet.&lt;br/&gt;
6. further use of Matcher, mostly in BooleanScorer2.&lt;/p&gt;

&lt;p&gt;My question is: shall I go ahead and provide a patch for step 1?&lt;/p&gt;

&lt;p&gt;At the moment I&apos;m refining BooleanScorer2. to use Matcher. This is for the case of multiple prohibited clauses, and also to allow the use of required and prohibited Matchers to allow adding filtering clauses to BooleanQuery.&lt;/p&gt;</comment>
                    <comment id="12533178" author="paul.elschot@xs4all.nl" created="Mon, 8 Oct 2007 19:13:08 +0100"  >&lt;p&gt;This Matcher-20071008-1ground.patch replaces the previous version because in between there was a conclict with the javadocs of Scorer for document ordering.&lt;/p&gt;

&lt;p&gt;In today&apos;s version, Scorer is unchanged, except for the superclass Matcher, and Matcher reuses the javadocs of Scorer as much as possible.&lt;/p&gt;</comment>
                    <comment id="12533179" author="paul.elschot@xs4all.nl" created="Mon, 8 Oct 2007 19:15:30 +0100"  >&lt;p&gt;Attached once more, this time with licence granted to ASF.&lt;/p&gt;</comment>
                    <comment id="12544863" author="paul.elschot@xs4all.nl" created="Thu, 22 Nov 2007 18:31:27 +0000"  >&lt;p&gt;Resolved a local conflict in the javadocs of HitCollector.&lt;/p&gt;</comment>
                    <comment id="12544865" author="paul.elschot@xs4all.nl" created="Thu, 22 Nov 2007 18:33:37 +0000"  >&lt;p&gt;Resolved a local conflict in the javadocs of HitCollector. This time with licence granted to ASF.&lt;/p&gt;</comment>
                    <comment id="12546148" author="michaelbusch" created="Wed, 28 Nov 2007 07:57:40 +0000"  >&lt;blockquote&gt;
&lt;p&gt;1. introduce Matcher as superclass of Scorer and adapt javadocs to use matching consistently.&lt;br/&gt;
2. introduce MatchFilter as superclass of Filter and add a minimal DefaultMatcher to be used in IndexSearcher, i.e. add BitSetMatcher&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Paul, I like the iterative plan you suggested. I started reviewing the&lt;br/&gt;
Matcher-20071122-1ground.patch. I&apos;ve some question:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Is the API fully backwards compatible?&lt;/li&gt;
	&lt;li&gt;Did you make performance tests to check whether BitSetMatcher is&lt;br/&gt;
slower than using a bitset directly?&lt;/li&gt;
	&lt;li&gt;With just the mentioned patch applied I get compile errors,&lt;br/&gt;
because the DefaultMatcher is missing. Could you provide a patch that&lt;br/&gt;
also includes the BitSetMatcher and Filter#getMatcher() returns it?&lt;br/&gt;
Also I believe the patch should modify Hits.java to use MatchFilter &lt;br/&gt;
instead of Filter? And a unit test that tests the BitSetMatcher &lt;br/&gt;
would be nice!&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12546166" author="paul.elschot@xs4all.nl" created="Wed, 28 Nov 2007 08:43:29 +0000"  >&lt;p&gt;The patch is backwards compatible, except for current subclasses of Filter already have a getMatcher method. The fact that no changes are needed to contrib confirms the compatibility.&lt;/p&gt;

&lt;p&gt;I have made no performance tests on BitSetMatcher for two reasons.&lt;br/&gt;
The first reason is that OpenBitSet is actually faster than BitSet (have a look at the graph in the SomeMatchers.zip file attachment by Eks Dev), so it seems to be better to go in that direction.&lt;br/&gt;
The second is that it is easy to do the skipping in IndexSearcher on a BitSet directly by using nextSetBit on the BitSet instead of skipTo on the BitSetMatcher. For this it would only be necessary to check whether the given MatchFilter is a Filter.&lt;br/&gt;
Anyway, I prefer to see where the real performance bottlenecks are before optimizing for performance.&lt;/p&gt;

&lt;p&gt;DefaultMatcher should be in the ...2default... patch.&lt;br/&gt;
The change in Hits to use MatchFilter should be in the ...3core.. patch.&lt;/p&gt;

&lt;p&gt;So far, I never tried to use these patches on their own, I have only split them for a better overview. Splitting the combined patches to iterate would need a different split, as you found out. It might even be necessary to split within a single class, but I&apos;ll gladly do that.&lt;/p&gt;</comment>
                    <comment id="12546174" author="michaelbusch" created="Wed, 28 Nov 2007 09:25:07 +0000"  >&lt;p&gt;OK, here&apos;s a patch that compiles cleanly on current trunk and all tests &lt;br/&gt;
pass. It includes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;all changes from Matcher-20071122-1ground.patch&lt;/li&gt;
	&lt;li&gt;util/BitSetMatcher.java from Matcher-20070905-2default.patch&lt;/li&gt;
	&lt;li&gt;Hits.java changes from Matcher-20070905-3core.patch&lt;/li&gt;
	&lt;li&gt;Filter#getMatcher() returns the BitSetMatcher&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Would you be up for providing testcases?&lt;/p&gt;

&lt;p&gt;As I said I haven&apos;t fully reviewed the patch, but I&apos;m planning to do &lt;br/&gt;
that soon. I can vouch that all tests pass after applying the patch.&lt;/p&gt;</comment>
                    <comment id="12546393" author="paul.elschot@xs4all.nl" created="Wed, 28 Nov 2007 20:58:17 +0000"  >&lt;p&gt;With the full patch applied, the following test cases use a BitSetMatcher:&lt;/p&gt;

&lt;p&gt;TestQueryParser&lt;br/&gt;
TestComplexExplanations&lt;br/&gt;
TestComplexExplanationsOfNonMatches&lt;br/&gt;
TestConstantScoreRangeQuery&lt;br/&gt;
TestDateFilter&lt;br/&gt;
TestFilteredQuery&lt;br/&gt;
TestMultiSearcherRanking&lt;br/&gt;
TestPrefixFilter&lt;br/&gt;
TestRangeFilter&lt;br/&gt;
TestRemoteCachingWrapperFilter&lt;br/&gt;
TestRemoteSearchable&lt;br/&gt;
TestScorerPerf&lt;br/&gt;
TestSimpleExplanations&lt;br/&gt;
TestSimpleExplanationsOfNonMatches&lt;br/&gt;
TestSort&lt;/p&gt;

&lt;p&gt;so I don&apos;t think it is necessary to provide seperate test cases.&lt;/p&gt;</comment>
                    <comment id="12546420" author="michaelbusch" created="Wed, 28 Nov 2007 21:45:57 +0000"  >&lt;p&gt;Yes you&apos;re right, I ran the tests w/ code coverage analysis enabled, and the&lt;br/&gt;
BitSetMatcher is fully covered. Good!&lt;/p&gt;</comment>
                    <comment id="12547524" author="michaelbusch" created="Sat, 1 Dec 2007 22:19:13 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The patch is backwards compatible,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that custom Searcher or Searchable implementations won&apos;t compile anymore?&lt;br/&gt;
Because the signature of some abstract methods changed, e. g. in Searchable:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@@ -86,13 +86,14 @@
    * &amp;lt;p&amp;gt;Called by {@link Hits}.
    *
    * &amp;lt;p&amp;gt;Applications should usually call {@link Searcher#search(Query)} or
-   * {@link Searcher#search(Query,Filter)} instead.
+   * {@link Searcher#search(Query,MatchFilter)} instead.
    * @&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; BooleanQuery.TooManyClauses
    */
-  TopDocs search(Weight weight, Filter filter, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
+  TopDocs search(Weight weight, MatchFilter filter, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12547612" author="paul.elschot@xs4all.nl" created="Sun, 2 Dec 2007 10:56:20 +0000"  >&lt;p&gt;I tried implementing a Searchable, and indeed ran into compilation errors.&lt;br/&gt;
So, backward compatibility is indeed not complete.&lt;/p&gt;

&lt;p&gt;Also, Searchable is an interface, so it should not be changed.&lt;br/&gt;
In case there are other interfaces affected by the patch these should not be changed either.&lt;/p&gt;

&lt;p&gt;There are two ways out of this:&lt;/p&gt;

&lt;p&gt;Do a name change on MatcherFilter/Filter -&amp;gt; Filter/BitSetFilter.&lt;br/&gt;
Changing the current Filter to BitSetFilter gives other problems with contrib packages.&lt;br/&gt;
I tried this some time ago, see above, but I could not make it work.&lt;/p&gt;

&lt;p&gt;I&apos;d prefer to add an interface (or abstract class?) like Searchable that uses MatchFilter for those implementers that want to take advantage of MatchFilter.&lt;br/&gt;
I don&apos;t expect problems from leaving the Searchable interface available unchanged.&lt;br/&gt;
Other interfaces that use Filter can be treated the same way, in case there are any.&lt;/p&gt;

</comment>
                    <comment id="12547681" author="michaelbusch" created="Sun, 2 Dec 2007 22:31:54 +0000"  >&lt;p&gt;Why do we actually need the new MatchFilter class at all?&lt;br/&gt;
Filter is an abstract class, not an interface. So I think we could&lt;br/&gt;
simply add the new method getMatcher() like you already did&lt;br/&gt;
in your patch:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  /**
   * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; A Matcher constructed from the provided BitSet.
   * @see    DefaultMatcher#defaultMatcher(BitSet)
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Matcher getMatcher(IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BitSetMatcher(bits(reader));
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This shouldn&apos;t break existing Filter implementations? &lt;br/&gt;
Maybe I&apos;m missing an apparent reason why we need the MatchFilter&lt;br/&gt;
class?&lt;/p&gt;</comment>
                    <comment id="12547686" author="paul.elschot@xs4all.nl" created="Sun, 2 Dec 2007 23:03:21 +0000"  >&lt;p&gt;For example, OpenBitSetFilter would like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;class OpenBitSetFilter  /* ... */ {
  OpenBitSet bits(reader) { ... }
  Matcher getMatcher(reader) { ... }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Since the only thing needed by an IndexSearcher would be the Matcher,&lt;br/&gt;
MatchFilteris  what Filter and OpenBitSetFilter have in common:&lt;br/&gt;
the getMatcher() method.&lt;/p&gt;
</comment>
                    <comment id="12547689" author="michaelbusch" created="Sun, 2 Dec 2007 23:16:54 +0000"  >&lt;p&gt;What about adding the getMatcher() method to Filter and&lt;br/&gt;
deprecating bits(IndexReader)? Then when we release&lt;br/&gt;
3.0 we can remove bits() and the only method in Filter&lt;br/&gt;
will be getMatcher().&lt;/p&gt;

&lt;p&gt;Then this patch should be backwards compatible&lt;br/&gt;
and we&apos;d do the API change with the next major release.&lt;br/&gt;
Any objections?&lt;/p&gt;</comment>
                    <comment id="12547691" author="paul.elschot@xs4all.nl" created="Sun, 2 Dec 2007 23:33:36 +0000"  >&lt;p&gt;I had not thought about deprecating yet, but it should work nicely.&lt;br/&gt;
I suppose you want to add a class BitSetFilter (subclass of Filter) as the preferred alternative&lt;br/&gt;
to the deprecated method?&lt;br/&gt;
Initially Filter and BitSetFilter would  be very similar, except that Filter.bits() would be deprecated.&lt;br/&gt;
Later, after  removal of Filter.bits(), Filter.getMatcher() would be declared abstract.&lt;/p&gt;

&lt;p&gt;I tried to do something pretty close to this for contrib/xml-query-parser, but I could not make that work,&lt;br/&gt;
which is why I changed to adding a new superclass MatchFilter.&lt;br/&gt;
Nevertheless, I think the deprecation above should work, but at the moment I can&apos;t foresee the consequences.&lt;/p&gt;</comment>
                    <comment id="12547734" author="michaelbusch" created="Mon, 3 Dec 2007 05:53:34 +0000"  >&lt;p&gt;OK, here&apos;s a new version of the patch.&lt;br/&gt;
Changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Removed MatchFilter entirely.&lt;/li&gt;
	&lt;li&gt;Filter.bits(IndexReader) is now deprecated and not abstract anymore.&lt;br/&gt;
Filter.bits(IndexReader) returns null, and Filter.matcher(IndexReader)&lt;br/&gt;
returns the new BitSetMatcher. This allows to create new Filters that &lt;br/&gt;
only implement the new getMatcher(IndexReader) method. Existing filters&lt;br/&gt;
on the other hand will still work together with the BitSetMatcher.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The new class BitSetFilter extends Filter and defines the abstract&lt;br/&gt;
method bits(IndexReader), just as Filter did before this patch.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I deprecated also CachingWrapperFilter and RemoteCachingWrapperFilter&lt;br/&gt;
and added corresponding CachingBitSetFilter and RemoteCachingBitSetFilter&lt;br/&gt;
which do essentially the same but only accept BitSetFilters.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All testcases pass and believe this should be fully backwards compatible.&lt;br/&gt;
Also, all core classes that call Filter.bits() are deprecated themselves.&lt;/p&gt;

&lt;p&gt;In Lucene 3.0 we should make the following changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Remove Filter.bits() and define Filter.getMatcher() abstract.&lt;/li&gt;
	&lt;li&gt;Remove CachingWrapperFilter and RemoteCachingWrapperFilter&lt;br/&gt;
(and corresponding testcases)&lt;/li&gt;
	&lt;li&gt;Add new matchers, like the OpenBitSetMatcher and SortedVIntMatcher&lt;br/&gt;
and add the DefaultMatcher class. (these classes are all located in&lt;br/&gt;
Paul&apos;s patch files)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12547895" author="paul.elschot@xs4all.nl" created="Mon, 3 Dec 2007 16:47:59 +0000"  >&lt;p&gt;A few remarks on the lucene-584-take2 patch:&lt;/p&gt;

&lt;p&gt;In the @deprecated javadoc at Filter.bits() a reference to BitSetFilter could be added.&lt;/p&gt;

&lt;p&gt;While Filter.bits() is still deprecated, one could also use the BitSet in IndexSearcher&lt;br/&gt;
in case this turns out to be performance sensitive; see also my remark of 28 November.&lt;/p&gt;

&lt;p&gt;A few complete (test) classes are deprecated, it might be good to add the target release&lt;br/&gt;
for removal there.&lt;/p&gt;

&lt;p&gt;For the rest this patch looks good to me. Did you also run ant test-contrib ?&lt;/p&gt;</comment>
                    <comment id="12547901" author="markh" created="Mon, 3 Dec 2007 17:05:24 +0000"  >&lt;p&gt;To go back to post #1 on this topic:&lt;/p&gt;

&lt;p&gt;   &lt;em&gt;&quot;Sparsely populated =java.util.BitSet=s are not efficient and waste lots of memory. It would be desirable to have an alternative BitSet implementation with smaller memory footprint.&quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Given the motivation to move to more memory efficient structures  why is the only attempt at caching dedicated exclusively to caching the very structures we were trying to move away from?.....&lt;/p&gt;

&lt;p&gt;       &lt;em&gt;&quot;I deprecated also CachingWrapperFilter and RemoteCachingWrapperFilter and added corresponding CachingBitSetFilter and RemoteCachingBitSetFilter&quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Does this suggest we are to have type-specific CachingXxxxxFilters and RemoteCachingXxxxxFilters created for every new filter type? Why not provide a single caching mechanism that works for all those other, new, more memory-efficient structures? I beleive the reason this hasn&apos;t been done is due to the issue I highlighted earlier - the cachable artefacts (what I chose to call &quot;DocIdSet&quot; here: &lt;a href=&quot;#action_12518642&quot;&gt;action_12518642&lt;/a&gt; ) are not modelled in  a way which promotes re-use. That&apos;s why we would end up needing a specialised caching implementations for each type. &lt;/p&gt;

&lt;p&gt;If we are to move forward from the existing Lucene implementation it&apos;s important to note the change:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Filters currently produce, at great cost, BitSets. Bitsets provide both a cachable data structure and a thread-safe, reusable  means of iterating across the contents.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;By replacing BitSets with Matchers this proposal has removed an important aspect of the existing design -  the visibility (and therefore cachability) of these expensive-to-recreate data structures. Matchers are single-use, non-threadsafe objects and hide the data structure over which they iterate. With this change if I want to implement a caching mechanism in my application I need to know the Filter type and what sort of data structure it returns and get it from it directly:&lt;br/&gt;
  if(myFilter instanceof BitSetFilter)    wrap specific data structure using CachingBitSetFilter&lt;br/&gt;
  else&lt;br/&gt;
  if(myFilter instanceof OpenBitSetFilter)   wrap specific data structure using CachingXxxxxFilter&lt;br/&gt;
  else...&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;...looks like an Anti-pattern to me. Worse, this ties the choice of datastructure to the type of Filter that produces it. Why can&apos;t my RangeFilter be free to create a SortedVIntList or a BitSet depending on the sparseness of matches for a particular set of criteria?&lt;/p&gt;

&lt;p&gt;I&apos;m not saying &quot;lets just stick with Bitsets&quot;, just consider caching more in the design. Post &lt;a href=&quot;#action_12518642&quot;&gt;action_12518642&lt;/a&gt; lays out how this could be modelled with the introduction of DocIdSet and DocIdSetIterator as separate responsibilities (whereas Matcher currently combines them both).&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;











</comment>
                    <comment id="12547958" author="paul.elschot@xs4all.nl" created="Mon, 3 Dec 2007 19:34:54 +0000"  >&lt;p&gt;Mark, in the latest Matcher....-2default.patch there is the org.apache.lucene.MatcherProvider interface with this javadoc:&lt;/p&gt;

&lt;p&gt;/** To be used in a cache to implement caching for a MatchFilter. */&lt;/p&gt;

&lt;p&gt;This interface has only one method:&lt;/p&gt;

&lt;p&gt;public Matcher getMatcher();&lt;/p&gt;


&lt;p&gt;There is also a cache for filters in the Matcher....3core.patch in the class CachingWrapperFilter .&lt;/p&gt;

&lt;p&gt;Would those be a good starting point?&lt;/p&gt;</comment>
                    <comment id="12547988" author="markh" created="Mon, 3 Dec 2007 21:13:13 +0000"  >&lt;p&gt;I&apos;m getting lost as to which patches we&apos;re considering here. I was looking at lucene-584-take2 patch.&lt;/p&gt;

&lt;p&gt;MatcherProvider in the earlier patch does look like something that will help with caching.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;Would those be a good starting point?&lt;/p&gt;

&lt;p&gt;Overall I feel uncomfortable with a lot of the classnames. I think the use of &quot;Matcher&quot; says more about what you want to do with the class in this particular case rather than what &lt;em&gt;it&lt;/em&gt; does generally. I have other uses in mind for these classes that are outside of filtering search results. For me, these classes can be thought of much more simply as utility classes in the same mould as the java Collections API. Fundamentally, they are efficient implementations of sets/lists of integers with support for iterators. The whole thing would be a lot cleaner if classes were named around this scheme.&lt;br/&gt;
&quot;MatcherProvider&quot; for example is essentially a DocIdSet  which creates forms of DocIdSetIterators (Matchers) and could also usefully have a size() method. &lt;/p&gt;
</comment>
                    <comment id="12548030" author="paul.elschot@xs4all.nl" created="Mon, 3 Dec 2007 22:50:06 +0000"  >&lt;p&gt;In case there is a better name than Matcher for a Scorer without a score() method (and maybe without an explain() method), I&apos;m all ears. Names are important, and at this point they can still be changed very easily.&lt;/p&gt;

&lt;p&gt;For Matcher I&apos;d rather have a method to estimate the number of matching docs than a size() method. This estimate would be useful in implementing conjunctions, as the Matchers with the lowest estimates could be used first. However, this is another issue.&lt;/p&gt;</comment>
                    <comment id="12548208" author="markh" created="Tue, 4 Dec 2007 10:49:56 +0000"  >&lt;p&gt;For the data structures (bitset/openbitset/sorted VintList/) I would suggest one of these: IntSet, IntegerSet or IntegerSequence as names for the common interface.&lt;br/&gt;
I did a quick Google for IntegerSet and you are in the number one spot, Paul &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;a href=&quot;http://www.google.com/search?hl=en&amp;amp;q=integerset+bitset&quot; class=&quot;external-link&quot;&gt;http://www.google.com/search?hl=en&amp;amp;q=integerset+bitset&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;// A cachable, immutable, sorted, threadsafe collection of ints.&lt;br/&gt;
interface IntegerSet&lt;br/&gt;
{&lt;br/&gt;
   IntegerSetIterator getIterator();&lt;br/&gt;
   int size(); //negative numbers could be used to represent estimates?&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;// A single-use thread-unsafe iterator.&lt;br/&gt;
interface IntegerSetIterator&lt;br/&gt;
{&lt;br/&gt;
    boolean next();&lt;br/&gt;
    boolean skipTo(int next);&lt;br/&gt;
    int currentValue();&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;If &lt;em&gt;detailed&lt;/em&gt; explanations of hits are required these should really sit with the source not the result- i.e. with the Filters. They contain all the match criteria used to populate IntegerSets  and can be thought of more generically as IntegerSetBuilder. &lt;/p&gt;

&lt;p&gt;//Contains criteria to create a set of matching documents. MUST implement hashcode and equals based on this criteria to enable use as cache keys for IntegerSets.&lt;br/&gt;
interface IntegerSetBuilder extends Serializable&lt;br/&gt;
{&lt;br/&gt;
      IntegerSet build (IndexReader reader)&lt;br/&gt;
      Explanation explain(int docNr);&lt;br/&gt;
}&lt;/p&gt;



&lt;p&gt;A single CachingIntegerSetBuilder class would be able to take ANY IntegerSetBuilder as a source, cache ANY type of IntegerSet they produced and defer back to the original IntegerSetBuilder for a full and thorough explanation of a match even when the match occurred on a cached IntegerSet, if required.&lt;/p&gt;

&lt;p&gt;class CachingIntegerSetBuilder implements IntegerSetBuilder&lt;br/&gt;
{&lt;br/&gt;
     private WeakHashMap perIndexReaderCache;&lt;br/&gt;
     public CachingIntegerSetBuilder(IntegerSetBuilder delegate) &lt;/p&gt;
{....}
&lt;p&gt;     .....&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;The reason for introducing IntegerSetBuilder as a more generic name than &quot;Filter&quot; is IntegerSets have uses outside of  filtering e.g. to do category counts or clustering. In these use cases they don&apos;t actually perform anything to do with filtering.  It may actually be better named DocIdSetBuilder given that it is tied to Lucene&apos;s IndexReader and therefore limited to producing sets of document ids.&lt;/p&gt;</comment>
                    <comment id="12548341" author="paul.elschot@xs4all.nl" created="Tue, 4 Dec 2007 18:40:31 +0000"  >&lt;p&gt;For the moment a DocId is an int, but that might change to long sooner than we think. So DocIdSet... would be a better name than IntegerSet..., and it&apos;s better to use an abstract superclass than an interface:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class DocIdSetIterator {
  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; next();
  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; skipTo(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; next);
  &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc();
}

&lt;span class=&quot;code-comment&quot;&gt;// and the &lt;span class=&quot;code-keyword&quot;&gt;rest&lt;/span&gt; is in the patch, except the superclass &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; Matcher:
&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class Matcher &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; DocIdSetIterator {
  Explanation explain(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc);
}

&lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class Scorer &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Matcher {
  &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; score();
  ...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Would this DocIdSetIterator be close enough to the IntegerSetIterator?&lt;/p&gt;</comment>
                    <comment id="12557566" author="michaelbusch" created="Thu, 10 Jan 2008 08:04:46 +0000"  >&lt;p&gt;OK, I created a new patch based on the recent feedback.&lt;/p&gt;

&lt;p&gt;This patch introduces two new abstract classes:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/**
 * A DocIdSet contains a set of doc ids. Implementing classes must provide
 * a {@link DocIdSetIterator} to access the set. 
 */
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class DocIdSet {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; DocIdSetIterator iterator();
}

/**
 * This &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class defines methods to iterate over a set of
 * non-decreasing doc ids.
 */
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class DocIdSetIterator {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc();
  
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; next() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; skipTo(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; target) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additional changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Scorer extends DocIdSetIterator now.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Filter.bits(IndexReader) is not abstract anymore. It is deprecated and&lt;br/&gt;
returns null. Added method Filter.getDocIdSet(IndexReader) which returns&lt;br/&gt;
new DocIdBitSet(bits(reader)) for backwards compatibility.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added getDocIdSet(IndexReader) implementations to all core readers and&lt;br/&gt;
deprecated bits(IndexReader). The Filters (e. g. RangeFilter) are now&lt;br/&gt;
using OpenBitSet instead of BitSet.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Made according changes to the SpanFilter classes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Fixed a bug in OpenBitSetIterator. It has an integer curDocId now, which&lt;br/&gt;
doc() returns. Before doc() sometimes returned wrong values. I also added&lt;br/&gt;
TestOpenBitSet (take from current Solr trunk).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I haven&apos;t changed the contrib Filter implementations yet, they still use &lt;br/&gt;
the old (deprecated) API. We should address this with a different issue.&lt;/p&gt;

&lt;p&gt;All core &amp;amp; contrib tests pass. This patch should also be fully backwards&lt;br/&gt;
compatible.&lt;/p&gt;</comment>
                    <comment id="12557595" author="paul.elschot@xs4all.nl" created="Thu, 10 Jan 2008 11:21:31 +0000"  >&lt;p&gt;On the take3 patch of 10 Jan 2008:&lt;/p&gt;

&lt;p&gt;SortedVIntList extends DocIdSet: nice, thanks.&lt;/p&gt;

&lt;p&gt;PrefixGenerator is used but not defined in the patch, so it will not compile.&lt;/p&gt;

&lt;p&gt;Nevertheless, with all tests passing, I think this is a good way to&lt;br/&gt;
make Filter independent of BitSet.&lt;/p&gt;


&lt;p&gt;Minor concerns:&lt;/p&gt;

&lt;p&gt;There is neither a BitSetFilter nor an OpenBitSetFilter in the patch.&lt;br/&gt;
These might be useful for existing code currently implementing Filter&lt;br/&gt;
to overcome the deprecation of Filter.bits().&lt;br/&gt;
With the current core moving to OpenBitSet, it might also use an&lt;br/&gt;
explicit OpenBitSetFilter.&lt;/p&gt;

&lt;p&gt;Some javadoc changes did not make it into the take3 patch, I&apos;ll check these later.&lt;/p&gt;

&lt;p&gt;FilteredQuery.explain(): When a document does not pass the Filter&lt;br/&gt;
I think it would be better not to use setValue(0.0f) on the resulting&lt;br/&gt;
Explanation. However, this may be necessary for backward compatibility.&lt;/p&gt;


&lt;p&gt;For the future:&lt;/p&gt;

&lt;p&gt;About adding a Filter as a clause to BooleanScorer, and adding&lt;br/&gt;
DocSetIdIterator as a &quot;Scorer&quot; to ConjunctionScorer:&lt;br/&gt;
This is the reason for the CHECKME in IndexSearcher for using&lt;br/&gt;
ConjunctionScorer when a filter is given.&lt;br/&gt;
A ConjunctionScorer that accepts a DocIdSetIterator could also be used in&lt;br/&gt;
FilteredQuery.&lt;/p&gt;</comment>
                    <comment id="12557755" author="michaelbusch" created="Thu, 10 Jan 2008 19:18:12 +0000"  >&lt;blockquote&gt;
&lt;p&gt;On the take3 patch of 10 Jan 2008:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks for the review!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PrefixGenerator is used but not defined in the patch, so it will not compile.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure I understand what you mean. PrefixGenerator is (and was) &lt;br/&gt;
defined in PrefixFilter.java. It compiles for me.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There is neither a BitSetFilter nor an OpenBitSetFilter in the patch.&lt;br/&gt;
These might be useful for existing code currently implementing Filter&lt;br/&gt;
to overcome the deprecation of Filter.bits().&lt;br/&gt;
With the current core moving to OpenBitSet, it might also use an&lt;br/&gt;
explicit OpenBitSetFilter.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that it should be straightforward for users having filters that use&lt;br/&gt;
BitSets to wrap the new DocIdBitSet around the BitSet, just as Filter currently &lt;br/&gt;
does for backwards compatibility?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Some javadoc changes did not make it into the take3 patch, I&apos;ll check these later.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh, which ones?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FilteredQuery.explain(): When a document does not pass the Filter&lt;br/&gt;
I think it would be better not to use setValue(0.0f) on the resulting&lt;br/&gt;
Explanation. However, this may be necessary for backward compatibility.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, it used to work this way, that&apos;s why I didn&apos;t change it for backwards-&lt;br/&gt;
compatibility reasons.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;About adding a Filter as a clause to BooleanScorer, and adding&lt;br/&gt;
DocSetIdIterator as a &quot;Scorer&quot; to ConjunctionScorer:&lt;br/&gt;
This is the reason for the CHECKME in IndexSearcher for using&lt;br/&gt;
ConjunctionScorer when a filter is given.&lt;br/&gt;
A ConjunctionScorer that accepts a DocIdSetIterator could also be used in&lt;br/&gt;
FilteredQuery.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, let&apos;s address this with a different issue after this one is committed.&lt;br/&gt;
I might have some concerns here, but I&apos;ve to further think about it.&lt;/p&gt;</comment>
                    <comment id="12557814" author="paul.elschot@xs4all.nl" created="Thu, 10 Jan 2008 22:05:02 +0000"  >&lt;p&gt;As for PrefixGenerator:&lt;br/&gt;
in my (up to date) trunk directory, this command: find . -name &apos;&lt;b&gt;PrefixGenerator&lt;/b&gt;&apos;&lt;br/&gt;
only gave this result: ./build/classes/java/org/apache/lucene/search/PrefixGenerator.class&lt;br/&gt;
and that disappeared after ant clean.&lt;br/&gt;
It seems that the source class was removed from the trunk.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think that it should be straightforward for users having filters that use&lt;br/&gt;
BitSets to wrap the new DocIdBitSet around the BitSet, just as Filter currently&lt;br/&gt;
does for backwards compatibility?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;BitSetFilter would inherit from Filter, and have an abstract bits() method, not deprecated.&lt;br/&gt;
This would be useful for people that don&apos;t what to move to OpenBitSet yet.&lt;br/&gt;
A rename (and maybe a package change) from Filter to BitSetFilter should be sufficient&lt;br/&gt;
in their code to get rid of the deprecation warning for Filter.bits().&lt;/p&gt;

&lt;p&gt;OpenBitSetFilter similar, and that could be used in a few places in the patch iirc.&lt;/p&gt;

&lt;p&gt;The javadoc changes I meant came with Matcher and use &apos;match&apos; consistently for documents&lt;br/&gt;
that are collected during a query search.&lt;/p&gt;
</comment>
                    <comment id="12557935" author="michaelbusch" created="Fri, 11 Jan 2008 08:44:14 +0000"  >&lt;blockquote&gt;
&lt;p&gt;As for PrefixGenerator:&lt;br/&gt;
in my (up to date) trunk directory, this command: find . -name &apos;PrefixGenerator&apos;&lt;br/&gt;
only gave this result: ./build/classes/java/org/apache/lucene/search/PrefixGenerator.class&lt;br/&gt;
and that disappeared after ant clean.&lt;br/&gt;
It seems that the source class was removed from the trunk.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As I said, PrefixGenerator is defined in PrefixFilter.java.&lt;/p&gt;</comment>
                    <comment id="12557936" author="michaelbusch" created="Fri, 11 Jan 2008 08:58:06 +0000"  >&lt;blockquote&gt;
&lt;p&gt;BitSetFilter would inherit from Filter, and have an abstract bits() method, not deprecated.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I added a BitSetFilter. The rest of the patch is identical to take3.&lt;/p&gt;

&lt;p&gt;I thought that I copied all your javadoc changes that still applied (after the removal of Matcher, MatchFilter, etc.) over into this patch. But well, if you think I missed any important ones let me know or feel free to update the patch!&lt;/p&gt;</comment>
                    <comment id="12557955" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 10:30:18 +0000"  >&lt;p&gt;I&apos;m sorry about my PrefixGenerator remarks, I did not read your answer accurately.&lt;/p&gt;

&lt;p&gt;On the take4 patch of 11 Jan 2008:&lt;/p&gt;

&lt;p&gt;I have started in a fresh trunk checkout that passed all tests.&lt;br/&gt;
Both parts of take4 apply cleanly, using patch -p0 &amp;lt; ... .&lt;br/&gt;
ant jar, ant test-core and ant test-contrib all pass nicely.&lt;/p&gt;

&lt;p&gt;I remember having problems with moving contrib/xml-queryparser from Filter&lt;br/&gt;
to BitSetFilter, see my comment of 30 July 2007.&lt;br/&gt;
So I&apos;d like to verify that this can be done, and I hope Mark Harwood can give&lt;br/&gt;
some hints as to how to do this.&lt;/p&gt;

&lt;p&gt;For me, this was the main reason to make this move:&lt;br/&gt;
from Filter with subclass BitSetFilter (as in the take4 patch, and in my first attempts)&lt;br/&gt;
to MatchFilter with subclass Filter (as in Matcher... patches of Sep and Nov 2007).&lt;br/&gt;
In these Matcher... patches no changes were necessary to contrib/xml-queryparser.&lt;/p&gt;


&lt;p&gt;Less important for now:&lt;/p&gt;

&lt;p&gt;The test classes extend TestCase, but iirc there is also a LuceneTestCase for this.&lt;/p&gt;

&lt;p&gt;On the take4 patch ant javadocs-core gives this:&lt;br/&gt;
BitSetFilter.java:40: warning - Tag @link: reference not found: DocIdBitSetIterator&lt;/p&gt;</comment>
                    <comment id="12557992" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 14:06:24 +0000"  >&lt;p&gt;I tried to move contrib from Filter.bits() to BitSetFilter.bits().&lt;/p&gt;

&lt;p&gt;The ContribQueries20080111.patch does that with contrib/queries,&lt;br/&gt;
and with that applied the xml-query-parser tests still pass.&lt;br/&gt;
I don&apos;t expect changes will be needed to xml-query-parser because it&lt;br/&gt;
does not use Filter.bits().&lt;br/&gt;
At the moment I don&apos;t know why I had problems with it half a year ago.&lt;/p&gt;


&lt;p&gt;For contrib/miscellaneous the changes needed to ChainedFilter are more involved:&lt;/p&gt;

&lt;p&gt;To make the tests pass, I had to make RangeFilter and QueryFilter subclasses of BitSetFilter, and to remove the final keyword from BitSetFilter.getDocIdSet().&lt;br/&gt;
The alternative would be to add BitSet versions of RangeFilter and QueryFilter&lt;br/&gt;
to ChainedFilterTest.&lt;br/&gt;
So it can be made to work, but ChainedFilter and/or ChainedFilterTest will need to be changed.&lt;/p&gt;

&lt;p&gt;Stepping back a bit, I think ChainedFilter might better move to OpenBitSetFilter.&lt;br/&gt;
No patch for contrib/miscelleneous, it&apos;s too ugly at the moment here.&lt;/p&gt;

&lt;p&gt;The conclusion is that I see no real problems with the take4 patch to move contrib&lt;br/&gt;
from Filter.bits to BitSetFilter.bits.&lt;/p&gt;</comment>
                    <comment id="12557999" author="eksdev" created="Fri, 11 Jan 2008 14:44:59 +0000"  >&lt;p&gt;it looks like  ChainedFilter could  become obsolete if Filter/DocSetIdIterator gets added as a Clause to the  BooleanQuery? I am thinking along the lines: ChainedFilter evaluates boolean expression of docId-s, that is exactly what BooleanQuery does plus &quot;a bit&quot; more (scoring)... &lt;/p&gt;</comment>
                    <comment id="12558076" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 19:24:19 +0000"  >&lt;blockquote&gt;
&lt;p&gt;it looks like ChainedFilter could become obsolete if Filter/DocSetIdIterator gets added as a Clause to the BooleanQuery?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The function is indeed the same, but ChainedFilter works directly on BitSets and BooleanQuery works on input Scorers/DocIdSetIterators and outputs collected docids (and score values). Working directly on  (Open)BitSets is normally faster, so ChainedFilter can have a good use.&lt;br/&gt;
And boolean operations on DocIdSets are not (yet) directly available in Lucene. The various boolean scorers have the logic, but currently only for Scorers.&lt;/p&gt;

&lt;p&gt;That leaves the question on what to do with ChainedFilter here. Any ideas?&lt;br/&gt;
The easiest way is to open another issue for it. This will have to be resolved before Filter.bits() is removed.&lt;/p&gt;</comment>
                    <comment id="12558115" author="eksdev" created="Fri, 11 Jan 2008 20:40:26 +0000"  >&lt;p&gt;hmm, in order to have fast and/or operations we need to know the type of the underlaying object in Filter, and sometimes we must use iterators (e.g. case where one Filter/DocSetId is int list and another Hash bit set ). I guess, knowing type of DocIdSet is the trick to pool. &lt;/p&gt;

&lt;p&gt;Default implementation of ChainedFilter (there is also BooleanFilter somewhere in contrib, I like it more) should be using iterator (like scorers), and at a few key points checking if(first instance of SomeInstanceOfDocIdSet &amp;amp;&amp;amp; second  SomeInstanceOfDocIdSet) first.doFastOR/AND(second);&lt;/p&gt;

&lt;p&gt;something in that direction looks reasonable to me for ChainedFilter &lt;br/&gt;
If it proves to be really better to have it around. I am still of an opinion that it would be better to integrate DocIdSet into BooleanQuery as a clause, somehow, that would be some kind of ConstantBoolean(MUST/SHOULD/NOT)Clause, much cleaner from design/usability point of view, even at some minor penalty in performance (anyhow, you can always combine filters before you enter scorers) but you are right that is another issue... let us stop polluting this issue &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &lt;/p&gt;
</comment>
                    <comment id="12558118" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 20:47:02 +0000"  >&lt;p&gt;I moved Filter &quot;forward&quot; by removing the deprecated bits() method&lt;br/&gt;
and declaring the getDocIdSet() method abstract.&lt;/p&gt;

&lt;p&gt;To get ant test-core passing with this it was necessary to&lt;br/&gt;
update some test code to implement Filter.getDocIdSet(),&lt;br/&gt;
and a patch for that is attached: Test20080111.patch .&lt;/p&gt;

&lt;p&gt;The change to Filter is not included in the patch.&lt;br/&gt;
Also, in a few places in the take4 patch Filter.bits() is used&lt;br/&gt;
deprecated methods. These methods had to be removed, but this&lt;br/&gt;
removal is not included in the patch.&lt;/p&gt;</comment>
                    <comment id="12558121" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 20:48:26 +0000"  >&lt;p&gt;Upload once more, this time with licence.&lt;/p&gt;</comment>
                    <comment id="12558856" author="michaelbusch" created="Tue, 15 Jan 2008 00:02:46 +0000"  >&lt;p&gt;I think I understand now which problems you had when you wanted to &lt;br/&gt;
change BooleanFilter and xml-query-parser to use the new Filter APIs.&lt;/p&gt;

&lt;p&gt;BooleanFilter is optimized to utilize BitSets for performing boolean&lt;br/&gt;
operations fast. Now if we change BooleanFilter to use the new &lt;br/&gt;
DocIdSetIterator, then it can&apos;t use the fast BitSet operations (e. g.&lt;br/&gt;
union for or, intersect for and) anymore. &lt;/p&gt;

&lt;p&gt;Now we can introduce BitSetFilter as you suggested and what I did in&lt;br/&gt;
the take4 patch. But here&apos;s the problem: Introducing subclasses of &lt;br/&gt;
Filter doesn&apos;t play nicely with the caching mechanism in Lucene.&lt;br/&gt;
For example: if we change BooleanFilter to only work with &lt;br/&gt;
BitSetFilters, then it won&apos;t work with a CachingWrapperFilter anymore,&lt;br/&gt;
because CachingWrapperFilter extends Filter. Then we would have to&lt;br/&gt;
introduce new CachingWrapper***Filter, for the different kinds of&lt;br/&gt;
Filter subclasses, which is a bad design as Mark pointed out in his&lt;br/&gt;
comment: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-584?focusedCommentId=12547901#action_12547901&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-584?focusedCommentId=12547901#action_12547901&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One solution would be to add a getBitSet() method to DocIdBitSet.&lt;br/&gt;
DocIdBitSet is a new class that is basically just a wrapper around a&lt;br/&gt;
Java BitSet and provides a DocIdSetIterator to access the BitSet.&lt;/p&gt;

&lt;p&gt;Then BooleanFilter could do something like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;DocIdSet docIdSet = filter.getDocIdSet();
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (docIdSet &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; DocIdBitSet) {
  BitSet bits = ((DocIdBitSet) docIdSet).getBitSet();
  ... &lt;span class=&quot;code-comment&quot;&gt;// existing code
&lt;/span&gt;} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
  &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; UnsupportedOperationException(&quot;BooleanFilter only 
  supports Filters that use DocIdBitSet.&quot;);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But then, changing the core filters to use OpenBitSets instead of&lt;br/&gt;
Java BitSets is technically an API change, because BooleanFilter&lt;br/&gt;
would not work anymore with the core filters.&lt;/p&gt;

&lt;p&gt;So if we took this approach we would have to wait until 3.0 to move&lt;br/&gt;
the core from BitSet to OpenBitSet and also change BooleanFilter &lt;br/&gt;
then to use OpenBitSets. BooleanFilter could then also work with&lt;br/&gt;
either of the two BitSet implementions, but probably not with those&lt;br/&gt;
two mixed.&lt;/p&gt;

&lt;p&gt;Any feedback about this is very welcome. I&apos;ll try to further think&lt;br/&gt;
about how to marry the new Filter API, caching mechanism and Filter&lt;br/&gt;
implementations like BooleanFilter nicely.&lt;/p&gt;</comment>
                    <comment id="12558997" author="eksdev" created="Tue, 15 Jan 2008 09:44:19 +0000"  >&lt;p&gt;Michal, would this work? &lt;br/&gt;
1. providing default implementation for basic methods that is using skipping iterator(always there), so it works by default for &lt;b&gt;all&lt;/b&gt; implementations, something along the lines:&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A DocIdSet contains a set of doc ids. Implementing classes must provide&lt;/li&gt;
	&lt;li&gt;a 
{@link DocIdSetIterator}
&lt;p&gt; to access the set.&lt;br/&gt;
 */&lt;br/&gt;
public abstract class DocIdSet {&lt;br/&gt;
	public abstract DocIdSetIterator iterator();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;public  DocIdSet and(DocIdSet){&lt;br/&gt;
// default implementation using &lt;b&gt;iterator&lt;/b&gt;;&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;public  DocIdSet or(DocIdSet)&lt;/p&gt;
{
// default implementation using iterator;
}

}

&lt;p&gt;2.  And then we &lt;b&gt;optimize&lt;/b&gt; particular cases, e.g&lt;/p&gt;

&lt;p&gt;public class DocIdBitSet extends DocIdSet{   &lt;br/&gt;
        BitSet bits; // Must be there in order for iterator to work....&lt;/p&gt;

&lt;p&gt;	public DocIdSetIterator iterator()&lt;/p&gt;
{
		//this is easy...
	}

&lt;p&gt;public  DocIdSet and(DocIdSet dis){&lt;br/&gt;
	if (dois instanceof DocIdBitSet) &lt;/p&gt;
{
                //not exactly like this, but the idea is there
  		 this.bits.and(((DocIdBitSet) dis));
		 return this;
 	}
&lt;p&gt;	return super.and(DocIdSet);&lt;/p&gt;

&lt;p&gt; }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;So it works always, and it works fast if need be, one instanceof check does not hurt there. Did I miss something obvious?&lt;/p&gt;


</comment>
                    <comment id="12559168" author="paul.elschot@xs4all.nl" created="Tue, 15 Jan 2008 18:52:34 +0000"  >&lt;p&gt;I indeed recall having an problem with remote filter caching. At the time I thought it was related to serialization but I could not resolve it that way. Never mind, it does not matter anymore.&lt;/p&gt;

&lt;p&gt;BooleanFilter and ChainedFilter have the same issue here. As they provide just about the same functionality, could they perhaps be merged?&lt;/p&gt;

&lt;p&gt;The solution using DocIdSet.and() and DocIdSet.or() looks good to me, but it will require some form of collector for the results, much like HitCollector.collect(doc, score) now and MatchCollector.collect(doc) in the Matcher...patch.&lt;br/&gt;
The boolean operations could then be accumulated into a BitSet or into an OpenBitSet, using a special case for DocId(Open)BitSet.&lt;/p&gt;

&lt;p&gt;I&apos;d like these boolean operations on DocIdSets to be general enough for use in Scorers, for example for the conjunctions in ConjunctionScorer, PhraseScorer and in the two NearSpans. But that is another issue.&lt;/p&gt;
</comment>
                    <comment id="12564415" author="markh" created="Thu, 31 Jan 2008 17:27:40 +0000"  >&lt;p&gt;Hi Paul,&lt;br/&gt;
Just eyeballed the code but not had a chance to patch and run it yet.&lt;/p&gt;

&lt;p&gt;I was wondering about the return type for skipTo() after looking at these types of calls:&lt;br/&gt;
       if (docIdSetIterator.skipTo&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &amp;amp;&amp;amp; (docIdSetIterator.doc() == i))&lt;/p&gt;

&lt;p&gt;You could save a method invocation in cases like this if skipTo() returned the next doc id rather than a boolean. Returning a -1 would be the equivalent of what used to be &quot;false&quot;.&lt;br/&gt;
Not tried benchmarking it but does this seem like something worth considering?&lt;/p&gt;

&lt;p&gt;Cheers&lt;br/&gt;
Mark&lt;/p&gt;</comment>
                    <comment id="12564620" author="michaelbusch" created="Fri, 1 Feb 2008 03:46:33 +0000"  >&lt;blockquote&gt;
&lt;p&gt;You could save a method invocation in cases like this if skipTo() returned the next doc id rather than a boolean. Returning a -1 would be the equivalent of what used to be &quot;false&quot;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;To change the signature of skipTo()  would be an API change, because with this patch Scorer extends DocIdSetIterator.&lt;/p&gt;

&lt;p&gt;-Michael&lt;/p&gt;</comment>
                    <comment id="12564622" author="michaelbusch" created="Fri, 1 Feb 2008 03:54:24 +0000"  >&lt;p&gt;OK here&apos;s a new version of the patch.&lt;/p&gt;

&lt;p&gt;It&apos;s based on the take4 patch with the following changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removed BitSetFilter&lt;/li&gt;
	&lt;li&gt;added getBitSet() method to DocIdBitSet&lt;/li&gt;
	&lt;li&gt;added Paul&apos;s Test20080111.patch&lt;/li&gt;
	&lt;li&gt;changed TestScorerPerf to use a DocIdBitSet&lt;/li&gt;
	&lt;li&gt;changed ChainedFilterTest, CachedFilterBuilder, TestRemoteSearchable&lt;br/&gt;
to use QueryWrapperFilter instead of deprecated QueryFilter&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;As mentioned in my previous comment it&apos;s not possible to wrap a&lt;br/&gt;
CachingWrapperFilter around a BitSetFilter and then retrieve the BitSet &lt;br/&gt;
from the CachingWrapperFilter. That&apos;s the reason why I removed &lt;br/&gt;
BitSetFilter and added the getBitSet() method to DocIdBitSet instead.&lt;br/&gt;
So you can do something like this:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;DocIdSet docIdSet = filter.getDocIdSet();
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (docIdSet &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; DocIdBitSet) {
  BitSet bits = ((DocIdBitSet) docIdSet).getBitSet();
  ...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;I didn&apos;t include Paul&apos;s ContribQueries20080111.patch because it only&lt;br/&gt;
changes some contrib filters to extend BitSetFilter instead of Filter.&lt;/li&gt;
	&lt;li&gt;I like Eks&apos; suggestion of implementing the BooleanFilter in a way that&lt;br/&gt;
it can use any DocIdSetIterator and optimize special cases, when DocIdSet &lt;br/&gt;
is a DocIdBitSet, OpenBitSet, etc. We should do this with a different JIRA &lt;br/&gt;
issue - this patch is already big enough.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;All core &amp;amp; contrib tests pass.&lt;/p&gt;

&lt;p&gt;I&apos;d like to commit this in a couple of days if nobody objects.&lt;/p&gt;</comment>
                    <comment id="12564875" author="paul.elschot@xs4all.nl" created="Fri, 1 Feb 2008 18:57:50 +0000"  >&lt;p&gt;The take5 patch tests ok here.&lt;/p&gt;

&lt;p&gt;One very minor remark: the javadoc at RangeFilter.getDocIdSet still mentions BitSet.&lt;/p&gt;</comment>
                    <comment id="12564878" author="michaelbusch" created="Fri, 1 Feb 2008 19:03:26 +0000"  >&lt;p&gt;Thanks, Paul for testing and reviewing.&lt;/p&gt;

&lt;p&gt;I&apos;ll correct the javadocs.&lt;/p&gt;

&lt;p&gt;OK, I will commit this tomorrow if nobody objects!&lt;/p&gt;</comment>
                    <comment id="12565101" author="michaelbusch" created="Sat, 2 Feb 2008 19:16:38 +0000"  >&lt;p&gt;Committed.&lt;/p&gt;

&lt;p&gt;I looked again at all the comments here - wow this issue was open for a long time and at lot of work was done here.&lt;/p&gt;

&lt;p&gt;Paul, thanks for your patience and all your hard work!!&lt;/p&gt;</comment>
                    <comment id="12565156" author="paul.elschot@xs4all.nl" created="Sun, 3 Feb 2008 08:57:06 +0000"  >&lt;p&gt;Thanks, my pleasure.&lt;/p&gt;

&lt;p&gt;I have attached a patch to CHANGES.txt to explicitly state that filters outside the lucene code base will need to be adapted.&lt;/p&gt;</comment>
                    <comment id="12565285" author="michaelbusch" created="Mon, 4 Feb 2008 07:43:20 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I have attached a patch to CHANGES.txt to explicitly state that filters outside the lucene code base will need to be adapted.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I added your comment to CHANGES.txt, Paul. Thanks again!&lt;/p&gt;</comment>
                    <comment id="12577207" author="markrmiller@gmail.com" created="Mon, 10 Mar 2008 21:31:52 +0000"  >&lt;p&gt;I think there is still an issue here. The code below just broke for me.&lt;/p&gt;

&lt;p&gt;java.lang.ClassCastException: org.apache.lucene.util.OpenBitSet cannot be cast to java.util.BitSet&lt;br/&gt;
	at org.apache.lucene.search.CachingWrapperFilter.bits(CachingWrapperFilter.java:55)&lt;br/&gt;
	at org.apache.lucene.misc.ChainedFilter.bits(ChainedFilter.java:177)&lt;br/&gt;
	at org.apache.lucene.misc.ChainedFilter.bits(ChainedFilter.java:152)&lt;br/&gt;
	at org.apache.lucene.search.Filter.getDocIdSet(Filter.java:49)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testChainedCachedQueryFilter() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException, ParseException {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; path = &lt;span class=&quot;code-quote&quot;&gt;&quot;c:/TestIndex&quot;&lt;/span&gt;;
    Analyzer analyzer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; WhitespaceAnalyzer();
    IndexWriter writer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(path, analyzer, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);

    Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;category&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;red&quot;&lt;/span&gt;, Store.YES, Index.TOKENIZED));
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;the big bad fox&quot;&lt;/span&gt;, Store.NO, Index.TOKENIZED));
    writer.addDocument(doc);
    doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;category&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;red&quot;&lt;/span&gt;, Store.YES, Index.TOKENIZED));
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;the big bad pig&quot;&lt;/span&gt;, Store.NO, Index.TOKENIZED));
    writer.addDocument(doc);
    doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;category&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;red&quot;&lt;/span&gt;, Store.YES, Index.TOKENIZED));
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;the horrific girl&quot;&lt;/span&gt;, Store.NO, Index.TOKENIZED));
    writer.addDocument(doc);
    doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;category&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;blue&quot;&lt;/span&gt;, Store.YES, Index.TOKENIZED));
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;the dirty boy&quot;&lt;/span&gt;, Store.NO, Index.TOKENIZED));
    writer.addDocument(doc);
    doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;category&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;blue&quot;&lt;/span&gt;, Store.YES, Index.TOKENIZED));
    doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;content&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;the careful bad fox&quot;&lt;/span&gt;, Store.NO, Index.TOKENIZED));
    writer.addDocument(doc);

    writer.close();

    Searcher searcher = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;

    searcher = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(path);

    QueryParser qp = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryParser(&lt;span class=&quot;code-quote&quot;&gt;&quot;field&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KeywordAnalyzer());
    Query query = qp.parse(&lt;span class=&quot;code-quote&quot;&gt;&quot;content:fox&quot;&lt;/span&gt;);
    QueryWrapperFilter queryFilter = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryWrapperFilter(query);
    CachingWrapperFilter cwf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CachingWrapperFilter(queryFilter);

    TopDocs hits = searcher.search(query, cwf, 1);
    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;hits:&quot;&lt;/span&gt; + hits.totalHits);

    queryFilter = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryWrapperFilter(qp.parse(&lt;span class=&quot;code-quote&quot;&gt;&quot;category:red&quot;&lt;/span&gt;));
    CachingWrapperFilter fcwf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CachingWrapperFilter(queryFilter);
    Filter[] chain = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Filter[2];
    chain[0] = cwf;
    chain[1] = fcwf;
    ChainedFilter cf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ChainedFilter(chain, ChainedFilter.AND);

    hits = searcher.search(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MatchAllDocsQuery(), cf, 1);

    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;red:&quot;&lt;/span&gt; + hits.totalHits);

    queryFilter = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryWrapperFilter(qp.parse(&lt;span class=&quot;code-quote&quot;&gt;&quot;category:blue&quot;&lt;/span&gt;));
    CachingWrapperFilter fbcwf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CachingWrapperFilter(queryFilter);
    chain = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Filter[2];
    chain[0] = cwf;
    chain[1] = fbcwf;
    cf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ChainedFilter(chain, ChainedFilter.AND);

    hits = searcher.search(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MatchAllDocsQuery(), cf, 1);

    &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;blue:&quot;&lt;/span&gt; + hits.totalHits);

  }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                    <comment id="12577326" author="paul.elschot@xs4all.nl" created="Tue, 11 Mar 2008 07:58:43 +0000"  >&lt;p&gt;From the traceback I suppose this happened at the end, using the ChainedFilter?&lt;br/&gt;
Iirc ChainedFilter is from contrib/..., and it is mentioned at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1187&quot; title=&quot;Things to be done now that Filter is independent from BitSet&quot;&gt;&lt;del&gt;LUCENE-1187&lt;/del&gt;&lt;/a&gt; as one of the things to be done.&lt;br/&gt;
Could you contribute this code as a contrib/... test case there?&lt;br/&gt;
Sorry, I don&apos;t remember exactly from which contrib module ChainedFilter is.&lt;/p&gt;</comment>
                    <comment id="12643495" author="wheijke" created="Wed, 29 Oct 2008 14:20:26 +0000"  >&lt;p&gt;We got the same error here on a 15Gb index with Lucene 2.4.0:&lt;/p&gt;

&lt;p&gt;java.lang.ClassCastException: java.util.BitSet cannot be cast to org.apache.lucene.search.DocIdSet&lt;br/&gt;
 org.apache.lucene.search.CachingWrapperFilter.getDocIdSet(CachingWrapperFilter.java:76)&lt;br/&gt;
 org.apache.lucene.misc.ChainedFilter.getDocIdSet(ChainedFilter.java:200)&lt;br/&gt;
 org.apache.lucene.misc.ChainedFilter.getDocIdSet(ChainedFilter.java:145)&lt;br/&gt;
 org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:140)&lt;br/&gt;
 org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:112)&lt;br/&gt;
 org.apache.lucene.search.Searcher.search(Searcher.java:136)&lt;/p&gt;</comment>
                    <comment id="12643767" author="paul.elschot@xs4all.nl" created="Thu, 30 Oct 2008 07:18:22 +0000"  >&lt;p&gt;Wouter, about this:&lt;br/&gt;
&lt;tt&gt;java.lang.ClassCastException: java.util.BitSet cannot be cast to org.apache.lucene.search.DocIdSet&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1187&quot; title=&quot;Things to be done now that Filter is independent from BitSet&quot;&gt;&lt;del&gt;LUCENE-1187&lt;/del&gt;&lt;/a&gt; should have fixed this, so could you file a bug report?&lt;br/&gt;
In case you need a workaround, also have a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1296&quot; title=&quot;Allow use of compact DocIdSet in CachingWrapperFilter&quot;&gt;&lt;del&gt;LUCENE-1296&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

</comment>
                    <comment id="12745763" author="markrmiller@gmail.com" created="Fri, 21 Aug 2009 02:27:10 +0100"  >&lt;p&gt;I think I have tracked down this issue as the one changing things most regarding Scorer documentation in org.apache.lucene.search.package.html.&lt;/p&gt;

&lt;p&gt;I&apos;ve started updating it, but it needs a tad more work I think - reopening this issue as a convenient marker for this work.&lt;/p&gt;</comment>
                    <comment id="12746017" author="michaelbusch" created="Fri, 21 Aug 2009 16:27:14 +0100"  >&lt;p&gt;Mark, are you working on this? Wanna assign this to you?&lt;/p&gt;</comment>
                    <comment id="12746507" author="markrmiller@gmail.com" created="Sat, 22 Aug 2009 22:18:04 +0100"  >&lt;p&gt;Its better now I think - could prob be improved still (by someone who has sunk their head into the new Scorer stuff more than I have) - but I read over the code and did what I could. At the least, its no longer wildly out of whack.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12314478">LUCENE-328</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12355127" name="bench-diff.txt" size="8515" author="doronc" created="Sun, 8 Apr 2007 04:59:13 +0100" />
                    <attachment id="12355042" name="bench-diff.txt" size="7180" author="otis" created="Thu, 5 Apr 2007 22:33:18 +0100" />
                    <attachment id="12374632" name="CHANGES.txt.patch" size="672" author="paul.elschot@xs4all.nl" created="Sun, 3 Feb 2008 08:57:06 +0000" />
                    <attachment id="12372978" name="ContribQueries20080111.patch" size="1907" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 14:06:23 +0000" />
                    <attachment id="12370398" name="lucene-584.patch" size="34623" author="michaelbusch" created="Wed, 28 Nov 2007 09:25:07 +0000" />
                    <attachment id="12370809" name="lucene-584-take2.patch" size="53065" author="michaelbusch" created="Mon, 3 Dec 2007 05:53:33 +0000" />
                    <attachment id="12372886" name="lucene-584-take3-part1.patch" size="37826" author="michaelbusch" created="Thu, 10 Jan 2008 08:04:46 +0000" />
                    <attachment id="12372887" name="lucene-584-take3-part2.patch" size="79181" author="michaelbusch" created="Thu, 10 Jan 2008 08:04:46 +0000" />
                    <attachment id="12372964" name="lucene-584-take4-part1.patch" size="40199" author="michaelbusch" created="Fri, 11 Jan 2008 08:58:06 +0000" />
                    <attachment id="12372965" name="lucene-584-take4-part2.patch" size="79181" author="michaelbusch" created="Fri, 11 Jan 2008 08:58:06 +0000" />
                    <attachment id="12374524" name="lucene-584-take5-part1.patch" size="47701" author="michaelbusch" created="Fri, 1 Feb 2008 03:54:24 +0000" />
                    <attachment id="12374525" name="lucene-584-take5-part2.patch" size="78122" author="michaelbusch" created="Fri, 1 Feb 2008 03:54:24 +0000" />
                    <attachment id="12365212" name="Matcher-20070905-2default.patch" size="76345" author="paul.elschot@xs4all.nl" created="Wed, 5 Sep 2007 22:27:49 +0100" />
                    <attachment id="12365213" name="Matcher-20070905-3core.patch" size="18837" author="paul.elschot@xs4all.nl" created="Wed, 5 Sep 2007 22:27:49 +0100" />
                    <attachment id="12370084" name="Matcher-20071122-1ground.patch" size="32296" author="paul.elschot@xs4all.nl" created="Thu, 22 Nov 2007 18:33:37 +0000" />
                    <attachment id="12340162" name="Some Matchers.zip" size="9447" author="eksdev" created="Mon, 4 Sep 2006 22:02:22 +0100" />
                    <attachment id="12373008" name="Test20080111.patch" size="5817" author="paul.elschot@xs4all.nl" created="Fri, 11 Jan 2008 20:48:26 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>17.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 31 May 2006 19:48:34 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13166</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27143</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>