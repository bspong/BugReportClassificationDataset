<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:19:57 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2755/LUCENE-2755.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2755] Some improvements to CMS</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2755</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;While running optimize on a large index, I&apos;ve noticed several things that got me to read CMS code more carefully, and find these issues:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;CMS may hold onto a merge if maxMergeCount is hit. That results in the MergeThreads taking merges from the IndexWriter until they are exhausted, and only then that blocked merge will run. I think it&apos;s unnecessary that that merge will be blocked.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;CMS sorts merges by segments size, doc-based and not bytes-based. Since the default MP is LogByteSizeMP, and I hardly believe people care about doc-based size segments anymore, I think we should switch the default impl. There are two ways to make it extensible, if we want:
	&lt;ul&gt;
		&lt;li&gt;Have an overridable member/method in CMS that you can extend and override - easy.&lt;/li&gt;
		&lt;li&gt;Have OneMerge be comparable and let the MP determine the order (e.g. by bytes, docs, calibrate deletes etc.). Better, but will need to tap into several places in the code, so more risky and complicated.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On the go, I&apos;d like to add some documentation to CMS - it&apos;s not very easy to read and follow.&lt;/p&gt;

&lt;p&gt;I&apos;ll work on a patch.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12479704">LUCENE-2755</key>
            <summary>Some improvements to CMS</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="shaie">Shai Erera</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Nov 2010 13:45:45 +0000</created>
                <updated>Wed, 30 Mar 2011 16:49:51 +0100</updated>
                    <resolved>Tue, 18 Jan 2011 23:31:45 +0000</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12931015" author="yseeley@gmail.com" created="Thu, 11 Nov 2010 14:04:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;CMS sorts merges by segments size, doc-based and not bytes-based. Since the default MP is LogByteSizeMP, and I hardly believe people care about doc-based size segments anymore, I think we should switch the default impl.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s probably a good idea.&lt;br/&gt;
We should also scale this by the number of deleted docs... so if a segment has 10,000 documents, is 10MB in size, and has 2000 deleted documents, then we should consider it as 8MB for the purposes of selecting to merge?&lt;/p&gt;</comment>
                    <comment id="12931086" author="shaie" created="Thu, 11 Nov 2010 17:11:03 +0000"  >&lt;p&gt;Right! Hence why I wrote it is best determined by MP. LogMP already does it by default (can be disabled).&lt;/p&gt;</comment>
                    <comment id="12931468" author="shaie" created="Fri, 12 Nov 2010 17:52:25 +0000"  >&lt;p&gt;Ok, so not calling IndexWriter.getNextMerge() before we know we can register that merge is problematic. The reason is we want to know if there is a next merge before we check if it can be registered. If not, the method returns immediately. Otherwise, we&apos;ll wait until any merge can be registered, just to discover there are no more merge.&lt;/p&gt;

&lt;p&gt;So one solution can be to add to IW a hasMerges() and in CMS wait for room to become available only if there are merges.&lt;/p&gt;

&lt;p&gt;Another solution is to do a larger change to CMS and introduce an ExecutorService - this has been raised in the past, so perhaps it&apos;s time to finally do it? By using a blocking queue, we don&apos;t need to implement any waiting logic - Java will do it for us.&lt;/p&gt;

&lt;p&gt;The downside of that is that I&apos;m not sure we can control which of the merges runs and which isn&apos;t. Perhaps we can hack this through - I&apos;ll need to start the process to tell for sure. This feature is important - today CMS guarantees the smaller merges run first - so it might be that a larger merge was registered before a smaller merge, and we&apos;d still want to execute the smaller one before the larger.&lt;/p&gt;

&lt;p&gt;A third solution would be to not do anything and keep things as they are - namely let some merge be held by CMS until it can be executed.&lt;/p&gt;

&lt;p&gt;Just summarizing my thoughts for now.&lt;/p&gt;</comment>
                    <comment id="12931796" author="shaie" created="Sun, 14 Nov 2010 09:25:04 +0000"  >&lt;p&gt;I&apos;ve looked into integrating an ExecutorService and I think it can really simplify things, as long as we can let go of CMS sorting merges by their size. And I think - why should it? What if we make it to MP&apos;s decision? Namely, if you care about which merges run first, have your MP sort them the way you want, before you return them. If we make OneMerge comparable, that should be a very trivial extension one has to make to MP (extend MP, override the methods, call super.method() and then sort accordingly).&lt;/p&gt;

&lt;p&gt;If we do that, then SMS and CMS will work the same - execute the merges in the order returned by MP, only CMS will do so in parallel and SMS will do so synchronously. By reading that you can already see that later (in a separate issue), we can let go of SMS entirely - it will be a single-threaded ExecutorService, w/ an implementation to wait until the work competes (unlike CMS which returns immediately). But that&apos;s for another day.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12931809" author="mikemccand" created="Sun, 14 Nov 2010 11:10:02 +0000"  >&lt;p&gt;Cutting over to ExecutorService and letting MergePolicy dictate how OneMerge compares sounds great!&lt;/p&gt;

&lt;p&gt;Will CMS still have the ability to pause running big merges in order to let smaller ones complete?  Seems like these changes should still allow that to work correctly.&lt;/p&gt;</comment>
                    <comment id="12931916" author="earwin" created="Sun, 14 Nov 2010 23:07:58 +0000"  >&lt;p&gt;Is there any reason at all to be concerned with merge execution order (not even starting about pausing)? Sounds like a fat bit of overengineering.&lt;br/&gt;
Merging (with CMS) happens outside of index/search loop anyway so whatever the order, you&apos;re not affecting latencies.&lt;/p&gt;</comment>
                    <comment id="12932072" author="shaie" created="Mon, 15 Nov 2010 15:07:23 +0000"  >&lt;p&gt;The problem with ThreadPoolExecutor is that its submit() doesn&apos;t block on the queue, even if you pass a bounded ArrayBlockingQueue (which is really silly IMO). I was hoping we can super simplify CMS logic by letting a BlockingQueue throttle the number of merges we &apos;register&apos; before CMS itself waits, and the ExecutorService instead of the MergeThreads and their management.&lt;/p&gt;

&lt;p&gt;Unfortunately this does not look to be the case. Here is an alternative solution which looks a nice workaround: &lt;a href=&quot;http://stackoverflow.com/questions/2001086/how-to-make-threadpoolexecutors-submit-method-block-if-it-is-saturated&quot; class=&quot;external-link&quot;&gt;http://stackoverflow.com/questions/2001086/how-to-make-threadpoolexecutors-submit-method-block-if-it-is-saturated&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The idea is to block the call to ExecutorService.execute() through a Semaphore. In that case, I think it&apos;s safe to not use a blocking queue at all, because the throttling will be handled by the Semaphore.&lt;/p&gt;

&lt;p&gt;Another alternative is to use a CallerRunsPolicy as the rejection policy, which has many disadvantages (such as potentially starving the other threads if the caller gets to execute the heavy task, or risking running the tasks by N+1 threads etc.).&lt;/p&gt;

&lt;p&gt;Earwin - if we make OneMerge comparable, we give any MP the freedom to decide the order merges will run. In my case it is important because I&apos;m getting a certain time frame to run index optimization, and prefer to reduce as many segments as possible, therefore I choose to run the smaller merges first. I think it&apos;s a reasonable decision anyway as a default, because even if you call close(false) (not waiting for merges), then it&apos;s better if some merges have already finished and committed, thereby you&apos;re making forward progress all the time, vs. if you run merges in arbitrary order you mind not finish any merge.&lt;/p&gt;

&lt;p&gt;I agree though that in some situations apps won&apos;t care, in which case sorting by merge size will be as good as random ordering.&lt;/p&gt;

&lt;p&gt;Pausing large merges is something that I consider less important though, but I don&apos;t want to break back-compat behavior. IMO if a merge started - let it finish. You don&apos;t know how much work it has completed, how much work is left, and how much work does the &apos;smaller&apos; merge has (what if say it&apos;s smaller by 1 byte/doc?). In different situations the best decision might be different, therefore IMO we shouldn&apos;t pause threads - rather let the MP decide up front the order of the merges (if it wants to) and then execute them in that order.&lt;/p&gt;</comment>
                    <comment id="12932124" author="earwin" created="Mon, 15 Nov 2010 17:55:45 +0000"  >&lt;p&gt;Whatever solution for block-on-add you employ, I think it is important to implement it as an Executor. I think, people can benefit from threading policy being pluggable.&lt;/p&gt;

&lt;p&gt;I&apos;m not against sorting merges, it&apos;s so simple, even if useless. Though maybe it&apos;s better to use Comparator, so you can redefine the order? Pausing large merges is another issue - that&apos;s a freakload of complexity for zero gain.&lt;/p&gt;

&lt;p&gt;Another issue to ponder - what about slightly uncluttering IW &amp;lt;-&amp;gt; MS interaction?&lt;br/&gt;
We drop IW.getNextMerge, MS.merge(IW), and replace them with MS.scheduleMerge(MP.OM), so instead of IW asking MS to pull all merges from itself, it simply pushes them.&lt;br/&gt;
Also, let&apos;s kill this weeeird IW.mergeInit that is called from CMS, but not SMS &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;


&lt;p&gt;But oh, well. With introduction of executors, and SMS being folded as a special case of CMS, we might as well drop MS completely and move what little code is left straight to IW, which will now accept an executor.&lt;/p&gt;</comment>
                    <comment id="12932162" author="mikemccand" created="Mon, 15 Nov 2010 19:36:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;We drop IW.getNextMerge, MS.merge(IW), and replace them with MS.scheduleMerge(MP.OM), so instead of IW asking MS to pull all merges from itself, it simply pushes them.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds like a great simplification!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m not against sorting merges, it&apos;s so simple, even if useless. Though maybe it&apos;s better to use Comparator, so you can redefine the order? Pausing large merges is another issue - that&apos;s a freakload of complexity for zero gain.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pausing large merges is (unfortunately) important for full use of available concurrency.  Otherwise, when a laaarge merge is taking place, it causes to to fully stop your indexing threads unnecessarily.  Turn on infoStream when building a large index and you&apos;ll see...&lt;/p&gt;

&lt;p&gt;An OS CPU scheduler will lower the priority of long-running CPU hogging processes, for the same reason (so that newly started CPU hog processes that are short running get nearly 100% of the CPU so they finish fast).  It&apos;s just that we don&apos;t have the &quot;freedom&quot; to allow an unbounded number of merges that we must &quot;approximate&quot; this by explicitly pausing the long running merges.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, let&apos;s kill this weeeird IW.mergeInit that is called from CMS, but not SMS&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There was some reason why this needed to be called by CMS but not SMS but I can&apos;t remember why.  (It&apos;s re-called by IW.merge in case the MS didn&apos;t already call it).  But it&apos;d be great to not call it from CMS if it&apos;s not necessary... I can&apos;t remember the reason.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;With introduction of executors, and SMS being folded as a special case of CMS, we might as well drop MS completely and move what little code is left straight to IW, which will now accept an executor.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s tempting... but people use MSs eg to schedule big merges at different times.  I don&apos;t think we should outright drop MS.&lt;/p&gt;</comment>
                    <comment id="12932182" author="jasonrutherglen" created="Mon, 15 Nov 2010 20:33:30 +0000"  >&lt;p&gt;A good feature for Solr could be the ability to via an HTTP call kick-off pending large merges.  They could then be scheduled via a cron job and based on other factors, such as whether or not other indexing tasks are running.&lt;/p&gt;</comment>
                    <comment id="12932200" author="earwin" created="Mon, 15 Nov 2010 21:09:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;There was some reason why this needed to be called by CMS but not SMS but I can&apos;t remember why.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That has something to do with assigning new segment names, if you believe the comments.&lt;br/&gt;
But IW.mergeInit does a freakload of other stuff! I think assigning names can happen in a separate place, before OneMerge is submitted to MS.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Otherwise, when a laaarge merge is taking place, it causes to to fully stop your indexing threads unnecessarily&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I still think this can be mitigated in more appropriate ways. Like allocating big enough pending merges queue to wait until the long one finishes.&lt;br/&gt;
Indexing threads push merges into the queue (with CMS) and don&apos;t block.&lt;br/&gt;
Plus to that, you can use nice policies like BalancedSegmentMergePolicy, that prevent UBER-merges from occuring at all.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;That&apos;s tempting... but people use MSs eg to schedule big merges at different times. I don&apos;t think we should outright drop MS.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That exact use case is totally wrong. MergePolicy decides which merges should run NOW, MergeScheduler executes them.&lt;br/&gt;
If a certain big merge should run only within some specific timeframe, MergePolicy should not return it when asked for eligible merges.&lt;/p&gt;

&lt;p&gt;In your sample, when decision-making is smeared across classes, the merges created by MP and deferred by MS are stale when their&lt;br/&gt;
time comes. If asked now, MP would include some additional segments in the merge that MS stalled around for ages.&lt;/p&gt;

&lt;p&gt;For a glance of things done relatively right, take a look at BSMP - it has setPartialExpunge method, that alters its&lt;br/&gt;
behaviour to include some expensive housecleaning. It is supposed you do setPartialExpunge(true) at the beginning of your quiet period, and&lt;br/&gt;
setPartialExpunge(false) when it ends.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A good feature for Solr could be the ability to via an HTTP call kick-off pending large merges.  They could then be scheduled via a cron job and based on other factors, such as whether or not other indexing tasks are running.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Same argument here. The place for such decisions is MergePolicy.&lt;/p&gt;</comment>
                    <comment id="12932234" author="mikemccand" created="Mon, 15 Nov 2010 22:29:44 +0000"  >&lt;blockquote&gt;
&lt;p&gt;That has something to do with assigning new segment names, if you believe the comments.&lt;br/&gt;
But IW.mergeInit does a freakload of other stuff! I think assigning names can happen in a separate place, before OneMerge is submitted to MS.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If indeed that&apos;s all then I agree, let&apos;s just assign the name up front and then CMS need not call mergeInit.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Otherwise, when a laaarge merge is taking place, it causes to to fully stop your indexing threads unnecessarily&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I still think this can be mitigated in more appropriate ways. Like allocating big enough pending merges queue to wait until the long one finishes.&lt;br/&gt;
Indexing threads push merges into the queue (with CMS) and don&apos;t block.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But then you accumulate too many tiny merges, while waiting for the big one to finish?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Plus to that, you can use nice policies like BalancedSegmentMergePolicy, that prevent UBER-merges from occuring at all.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe we should move BSMP to core and make it the default?&lt;/p&gt;

&lt;p&gt;But I don&apos;t fully understand how it chooses merges.  EG does it pick lopsided merges (where the segments differ substantially in size), as long as they are &quot;small&quot; segments?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MergePolicy decides which merges should run NOW, MergeScheduler executes them.&lt;br/&gt;
If a certain big merge should run only within some specific timeframe, MergePolicy should not return it when asked for eligible merges.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree there is ambiguity here, which is not good.  It is tempting to nuke MergeScheduler (absorb CMS into IW, w/ SMS a special case) and define MergePolicy to only return merges which should run right now... that would be a nice simplification.&lt;/p&gt;</comment>
                    <comment id="12932266" author="earwin" created="Mon, 15 Nov 2010 23:54:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;But then you accumulate too many tiny merges, while waiting for the big one to finish?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You say this, as if it was something terribly wrong. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Big merges aren&apos;t heffalumps, they don&apos;t usually stalk IW in droves. Big merge ends sooner or later, and tiny ones go out in a flash.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe we should move BSMP to core and make it the default?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Dunno. The index you end up with is larger than with LogWhateverMP.&lt;br/&gt;
But you get a nice benefit of having roughly equal-sized big segments, which is cool for running collection in parallel.&lt;br/&gt;
Everyone has his own requirements.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But I don&apos;t fully understand how it chooses merges. EG does it pick lopsided merges (where the segments differ substantially in size), as long as they are &quot;small&quot; segments?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Docs say small-sized segments are treated as with LogByteSizeMP.&lt;/p&gt;



&lt;p&gt;Another thought I had looking through the code. We have seriously inefficient &quot;merge conflict&quot; resolution algorithm on our hands.&lt;br/&gt;
We just damn drop all new merges that have segments in common with the merges already queued (but not yet running!!).&lt;br/&gt;
What does that mean?&lt;/p&gt;

&lt;p&gt;Imagine we&apos;re producing a slew of mini-segments with decent speed and our MergeScheduler is lagging behind:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;new seg1&lt;/li&gt;
	&lt;li&gt;new seg2&lt;/li&gt;
	&lt;li&gt;queue merge seg1+seg2&lt;/li&gt;
	&lt;li&gt;start merge seg1+seg2&lt;/li&gt;
	&lt;li&gt;new seg3&lt;/li&gt;
	&lt;li&gt;new seg4&lt;/li&gt;
	&lt;li&gt;queue merge seg3+seg4&lt;/li&gt;
	&lt;li&gt;new seg5&lt;/li&gt;
	&lt;li&gt;FAIL queue merge seg3+seg4+seg5&lt;/li&gt;
	&lt;li&gt;new seg6&lt;/li&gt;
	&lt;li&gt;FAIL queue merge seg3+seg4+seg5+seg6&lt;/li&gt;
	&lt;li&gt;finish merge seg1+seg2&lt;/li&gt;
	&lt;li&gt;start merge seg3+seg4&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;By that point we should really start merging of all four last segments (maybe together with the result of seg1+seg2).&lt;br/&gt;
But in reality we&apos;ll merge seg3+seg4, than seg5+seg6 and then all of three merge results together (provided no new mini-segments are added).&lt;/p&gt;

&lt;p&gt;If we throw large merges into the loop (whether pausable or not) the situation is amplified.&lt;/p&gt;

&lt;p&gt;Ugly solution - when MP suggests a merge that is a strict superset of a queued, but not yet running merge - drop the old one, use the new.&lt;br/&gt;
Better solution - instead of asking MP for all the merges it deems reasonable on current index, we only ask it for &quot;most important&quot; one.&lt;br/&gt;
And we do it each time MS has an open slot for execution. This way each merge happening is the best merge possible at that moment.&lt;/p&gt;

&lt;p&gt;Please, correct my wrongs, if any.&lt;/p&gt;</comment>
                    <comment id="12932356" author="shaie" created="Tue, 16 Nov 2010 07:00:32 +0000"  >&lt;p&gt;I have to say I totally agree w/ Earwin - in my mind, the MP should be the one deciding what merges to run, and in what order, the MS should be the one executing them. Hack, we should really call MS a MergeExecutor, since it doesn&apos;t really schedule anything, just does what it&apos;s told, based on the execution policy (parallel or blocking).&lt;/p&gt;

&lt;p&gt;In my app, it&apos;s the MP which decides which merges to run, based on their sizes, time of the day and allotted time to run. I expect MS to faithfully do what it&apos;s told and don&apos;t play tricks on me (like pausing merges I&apos;ve asked it to run), &apos;cause otherwise I&apos;ll need to write a MS too.&lt;/p&gt;

&lt;p&gt;Another question that was brought up here is who should register the merges. Today there are two entities - one is the MS which repeatedly calls IW.getNextMerge() and in the CMS case, MergeThread does so too. The disadvantage of that is that IW.getNextMerge() (and mergeInit()) is called from two places, but the advantage is that it allows executing all of MP merges, even if they come in several rounds. Example, you have 4 segs of level 0 and 3 segs of level 1 (mergeFactor=4). MP returns a single merge (4 segs level 0), and IW.getNextMerge() returns null &apos;cause there are no merges left). However, after completing this merge, if asked, MP will return a follow on merge of 4 segs level 1. That will be picked up by the MergeThread that calls IW.getNextMerge().&lt;/p&gt;

&lt;p&gt;The thing is - the second round of merges may only be detected by MP after most if not all of the merges from the previous round ended. Therefore, if we dim that functionality important (and I do), we must have the MergeThreads query MP as well.&lt;/p&gt;

&lt;p&gt;About mergeInit, I took a look too and discovered a 140 lines method, so I doubt it does only &quot;new segment name registration&quot;. But perhaps I&apos;m wrong and those are redundant 140 lines ...&lt;/p&gt;

&lt;p&gt;I think that having a MS entity (or MergeExecutor) is important - it still gives an app the ability to override things if it wants to. Also, putting the MS code inside IW will only add code to it, and I think that we should really start refactoring it down to smaller, more readable and focused, pieces. So I&apos;m against adding more logic to it. For 3x we can choose to improve things internally, or leave them as they are. For 4.0 I&apos;d suggest we do the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create a new MergeExecutor entity receives an Executor(Service?) to run with, but also defaults to one (like CMS is today). That replaces CMS.
	&lt;ul&gt;
		&lt;li&gt;You can control the number of threads it runs with (1 for almost-SMS-like behavior and more for CMS).&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;We create a BlockingMergeExecutor, which regardless of how many threads you allow it to run with, blocks until all merges finish.
	&lt;ul&gt;
		&lt;li&gt;That is an improved SMS - I&apos;ve always thought that blocking until merges finish is not related to how many threads you&apos;d like to execute merges with. E.g., if you set CMS&apos;s # threads to 1, you get a sort of an SMS behavior, only the call is non-blocking.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;We define MP as the one responsible for returning the merges in the order it wants, and provide the necessary support by making OneMerge comparable (Earwin, MP can still sort by using a custom Comparator, we only provide a default comparison method for merges). That definition will be mostly in javadocs.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12932479" author="mikemccand" created="Tue, 16 Nov 2010 14:36:22 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But then you accumulate too many tiny merges, while waiting for the big one to finish?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You say this, as if it was something terribly wrong. &lt;br/&gt;
Big merges aren&apos;t heffalumps, they don&apos;t usually stalk IW in droves. Big merge ends sooner or later, and tiny ones go out in a flash.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In fact there is something wrong: without us explicitly scheduling the&lt;br/&gt;
running merges (ie setting thread priorities, stopping the big merges&lt;br/&gt;
when there are too many small ones), CMS will pause the incoming&lt;br/&gt;
threads.&lt;/p&gt;

&lt;p&gt;I first saw this happen when testing our NRT reopen perf (which is&lt;br/&gt;
merge intensive).  Normally the turnaround is very fast (eg 5 msec)&lt;br/&gt;
but if you&apos;re at your max merge count then CMS will stall you and the&lt;br/&gt;
turnaround time easily becomes seconds, which is awful.&lt;/p&gt;

&lt;p&gt;It&apos;s like an OS that refuses to schedule your &quot;ls&quot; command because&lt;br/&gt;
there&apos;s still some long running process...&lt;/p&gt;

&lt;p&gt;CMS&apos;s explicit thread scheduling fixes that problem &amp;#8211; a big merge no&lt;br/&gt;
longer causes seconds of delay in opening a new NRT reader.  That is,&lt;br/&gt;
as long as net/net you&apos;ve allocated enough CPUs (maxThreadCount) to do&lt;br/&gt;
the merging.  If merging is too slow vs indexing rate + reopen rate&lt;br/&gt;
then there&apos;s no hope: at some point reopen must be blocked (it&apos;s&lt;br/&gt;
a zero sum game).&lt;/p&gt;

&lt;p&gt;In the ideal world the OS/JRE would do a better job scheduling, ie&lt;br/&gt;
realize that there are looong running threads and down prioritize them&lt;br/&gt;
(like the OS does to processes), but in practice it&apos;s nowhere close to&lt;br/&gt;
doing this right for our use case, so I don&apos;t see a choice here.  If&lt;br/&gt;
we want to keep our fast NRT reopen time, we have to manually schedule&lt;br/&gt;
our merge threads.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Maybe we should move BSMP to core and make it the default?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Dunno. The index you end up with is larger than with LogWhateverMP.&lt;br/&gt;
But you get a nice benefit of having roughly equal-sized big segments, which is cool for running collection in parallel.&lt;br/&gt;
Everyone has his own requirements.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fair enough...&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;But I don&apos;t fully understand how it chooses merges. EG does it pick lopsided merges (where the segments differ substantially in size), as long as they are &quot;small&quot; segments?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Docs say small-sized segments are treated as with LogByteSizeMP.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm... but then how does this differ from setting a maxMergeMB/Docs?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We have seriously inefficient &quot;merge conflict&quot; resolution algorithm on our hands.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right!  Though, I think this typically isn&apos;t a problem for&lt;br/&gt;
LogMP since it doesn&apos;t normally pick future merges that conflict with&lt;br/&gt;
past ones.&lt;/p&gt;

&lt;p&gt;Also the problem is bounded by how long the merge takes to finish.&lt;/p&gt;

&lt;p&gt;But I agree we should try to fix this... other MPs could conceivably&lt;br/&gt;
do this.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ugly solution - when MP suggests a merge that is a strict superset of a queued, but not yet running merge - drop the old one, use the new.&lt;br/&gt;
Better solution - instead of asking MP for all the merges it deems reasonable on current index, we only ask it for &quot;most important&quot; one.&lt;br/&gt;
And we do it each time MS has an open slot for execution. This way each merge happening is the best merge possible at that moment.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems dangerous: what&apos;s an &quot;important&quot; merge?&lt;/p&gt;

&lt;p&gt;How about, instead, we let MP return all eligible merges (like it does&lt;br/&gt;
today) but then we replace all previously buffered but not yet running&lt;br/&gt;
merges w/ the new merges it returned?  Hmm but this would probably&lt;br/&gt;
require giving it access to the buffered-but-not-yet-running merge&lt;br/&gt;
set...&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;About mergeInit, I took a look too and discovered a 140 lines method, so I doubt it does only &quot;new segment name registration&quot;. But perhaps I&apos;m wrong and those are redundant 140 lines ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right &amp;#8211; it&apos;s doing lots of stuff.  But the question was whether CMS&lt;br/&gt;
really must be calling it itself vs leaving IW.merge to call it as SMS&lt;br/&gt;
does.  Ideally only IW.merge should call it (and it becomes private),&lt;br/&gt;
which if we take the name assignment out &quot;earlier&quot; seems feasible.&lt;/p&gt;</comment>
                    <comment id="12932486" author="shaie" created="Tue, 16 Nov 2010 14:56:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Ideally only IW.merge should call it (and it becomes private),&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wouldn&apos;t make it private. If I remember correctly, the Parallel Index overrode that method to synchronize merges across all parallels.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;but if you&apos;re at your max merge count then CMS will stall you and the turnaround time easily becomes seconds, which is awful.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But Mike, if you hit your maxMergeCount with large merges, then you won&apos;t run tiny merges at all. It&apos;s only if you have room to run any merges, that this &apos;pausing&apos; actually helps. I trust you when you say you&apos;ve observed that not pausing those merges hurt performance, but I wonder in real life, how often does that happen, and whether we should incorporate that in our code. If it&apos;s a rare case, then perhaps apps that hit it should use another MS which pauses its threads?&lt;/p&gt;</comment>
                    <comment id="12932539" author="mikemccand" created="Tue, 16 Nov 2010 17:08:24 +0000"  >
&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Ideally only IW.merge should call it (and it becomes private),&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wouldn&apos;t make it private. If I remember correctly, the Parallel Index overrode that method to synchronize merges across all parallels.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But Mike, if you hit your maxMergeCount with large merges, then you won&apos;t run tiny merges at all.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, but that&apos;s uncommon.  Ie, large merges don&apos;t happen very&lt;br/&gt;
frequently.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;s only if you have room to run any merges, that this &apos;pausing&apos; actually helps. I trust you when you say you&apos;ve observed that not pausing those merges hurt performance, but I wonder in real life, how often does that happen, and whether we should incorporate that in our code. If it&apos;s a rare case, then perhaps apps that hit it should use another MS which pauses its threads?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Remember it&apos;s not just pausing.  We also set thread priorities so that&lt;br/&gt;
smaller merges run with higher priority, and, all merges run with&lt;br/&gt;
higher priority than the indexing threads (by default).&lt;/p&gt;

&lt;p&gt;I don&apos;t think this is rare because eventually (assuming your index is&lt;br/&gt;
big enough) you&apos;ll hit a large merge and then you can fairly easily&lt;br/&gt;
see the merges stack up.  I&apos;ve seen merges stack up in the non-NRT&lt;br/&gt;
case too.  Without this explicit thread scheduling we do, that large&lt;br/&gt;
merge can easily kill your NRT reopens, ie take many seconds to get a&lt;br/&gt;
new reader.  This is non-graceful degradation because at first NRT&lt;br/&gt;
reopen time looks great but then as your index grows and you hit a&lt;br/&gt;
large merge, suddenly it&apos;s many seconds.&lt;/p&gt;

&lt;p&gt;If your app has costly merges (eg you store fields, term vectors, and&lt;br/&gt;
you use dynamic fields which means the stores cannot be bulk merged),&lt;br/&gt;
and you&apos;re not on an SSD, and your OS is memory starved so it can&apos;t do&lt;br/&gt;
as much readahead as it should be doing, your merges become far more&lt;br/&gt;
costly.  Worse, the default merge thread count (3) may in fact be too high&lt;br/&gt;
for most machines even with 4 or more cores.  There are many variables...&lt;/p&gt;

&lt;p&gt;The scheduling can only do so much, of course.  Ie it enables us to&lt;br/&gt;
soak up the &quot;spare&quot; CPU cycles in between medium, little merges to let&lt;br/&gt;
the bit merge make progress.  But if those spare cycles aren&apos;t enough&lt;br/&gt;
then inevitably the best scheduling will still have to eventually&lt;br/&gt;
pause your reopens.&lt;/p&gt;

&lt;p&gt;Still I think the other improvements we&apos;ve talked about here would be&lt;br/&gt;
great steps forward.  It&apos;s just that we still need to explicitly&lt;br/&gt;
schedule the merge threads.&lt;/p&gt;</comment>
                    <comment id="12932561" author="earwin" created="Tue, 16 Nov 2010 17:53:42 +0000"  >&lt;p&gt;Shai:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The thing is - the second round of merges may only be detected by MP after most if not all of the merges from the previous round ended. Therefore, if we dim that functionality important (and I do), we must have the MergeThreads query MP as well.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Don&apos;t turn things upside down. MergeThreads are best hidden from view inside Executor, we just feed it chunks of work in the order we want it to be done. It&apos;s quite enough to have a single place that queries MP and feeds Executor.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About mergeInit, I took a look too and discovered a 140 lines method, so I doubt it does only &quot;new segment name registration&quot;. But perhaps I&apos;m wrong and those are redundant 140 lines ...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;These are not redundant. But only a small number of them really need to be executed when a merge is added to CMS, everything else can wait until merge actually starts.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think that having a MS entity (or MergeExecutor) is important - it still gives an app the ability to override things if it wants to.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Tentatively agree on this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, putting the MS code inside IW will only add code to it, &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;But this is not true, with all the cruft thrown away, remaining code size is likely on par with current that invokes MS from within IW.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We define MP as the one responsible for returning the merges in the order it wants, and provide the necessary support by making OneMerge comparable&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;You contradict yourself here. If we make OneMerge comparable, we define order in its compareTo() method. MP can no longer return the merges in the order it wants. I suggest there&apos;s no Comparable, and MP does the sort itself and returns an ordered list of merges. Better yet - it returns only the first one of them, on each request.&lt;/p&gt;



&lt;p&gt;Mike:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In fact there is something wrong: without us explicitly scheduling the running merges (ie setting thread priorities, stopping the big merges when there are too many small ones), CMS will pause the incoming threads.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Why?? Indexing threads can drop merges into a queue, and forget about them. The blocking happens only if you explicitly want to use the same thread for merging, or if merging threads are lagging - in such a case you&apos;re in for troubles anyway.&lt;br/&gt;
All further analogies with OS scheduling are broken because we&apos;re not running &quot;ls&quot;, we&apos;re running background jobs, and don&apos;t really care which of them blocks which.&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Docs say small-sized segments are treated as with LogByteSizeMP.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hmm... but then how does this differ from setting a maxMergeMB/Docs?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;BSMP doesn&apos;t keep your segments under certain size like maxMergeMB does. It ensures you have exactly N &apos;large&apos; segments. How large they are - depends on total size of the index.&lt;br/&gt;
It also limits the maximum count of &apos;small&apos; segments, the size distribution for them is the same as with LBSMP.&lt;br/&gt;
I think the &lt;a href=&quot;http://code.google.com/p/zoie/wiki/ZoieMergePolicy&quot; class=&quot;external-link&quot;&gt;docs&lt;/a&gt; are pretty good.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This seems dangerous: what&apos;s an &quot;important&quot; merge?&lt;/p&gt;

&lt;p&gt;How about, instead, we let MP return all eligible merges (like it does&lt;br/&gt;
today) but then we replace all previously buffered but not yet running&lt;br/&gt;
merges w/ the new merges it returned? Hmm but this would probably&lt;br/&gt;
require giving it access to the buffered-but-not-yet-running merge&lt;br/&gt;
set...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We already decided that merges should be sorted? And MP gives us a bunch of them. Sort the bunch, pick the first one - that&apos;s your &quot;important&quot; merge.&lt;br/&gt;
By calling this MP.giveMeNextImportantMerge() method repeatedly we free ourselves from tons of bookkeeping you just mentioned.&lt;/p&gt;

&lt;p&gt;Ho-ho-ho! In fact, we don&apos;t need any queues, any buffering, no hard link between indexing and merging - no nothing at all &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Here&apos;s my proposal cleaned up and reiterated:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;MP has a single method - getNextMerge() (I&apos;m not taking optimize and friends into account now)
	&lt;ul&gt;
		&lt;li&gt;For current policies this method works as described before - MP decides on a list of eligible merges, sorts them by some criteria (i.e. smaller merges come first) and returns the first.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;MS repeatedly polls MP for merges (in one or more threads) and executes them.
	&lt;ul&gt;
		&lt;li&gt;If getNextMerge() returns null, MS goes to sleep - null signifies that from MP&apos;s perspective index is already in ideal state.&lt;/li&gt;
		&lt;li&gt;When some index-changing events occur, eg - indexing thread adds some docs and creates a new segment, MS is woken up and resumes polling/merging.&lt;/li&gt;
		&lt;li&gt;rinse, repeat&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;In CMS-like scenario, indexing and merging threads are completely decoupled and even lack queues that could overflow. So if some lesser merges have to wait for the big one - that&apos;s not going to bite you at all.&lt;/li&gt;
	&lt;li&gt;In SMS-like scenario, polling happens within indexing thread, and everything works as it does now.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;
&lt;p&gt;Still I think the other improvements we&apos;ve talked about here would be great steps forward.&lt;br/&gt;
It&apos;s just that we still need to explicitly schedule the merge threads.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;As I just described - we don&apos;t have to &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
And if you really want to preserve that monster of pausing and priority control (largely broken for java anyway), forget about Executors - they don&apos;t support this.&lt;/p&gt;</comment>
                    <comment id="12932599" author="jasonrutherglen" created="Tue, 16 Nov 2010 18:52:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;large merge can easily kill your NRT reopens&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When RT is implemented, these small segments (that require merging) go&lt;br/&gt;
away because we&apos;ll be flushing relatively medium sized segments the size&lt;br/&gt;
of the RAM buffer.&lt;/p&gt;

&lt;p&gt;I&apos;d prefer to have more control of large merges from an external process&lt;br/&gt;
so that they may be scheduled according to application demand, ie, during&lt;br/&gt;
non-peak hours. This is actually what I&apos;ve implemented in production using&lt;br/&gt;
things like optimize num segments = 5 and/or expunge deletes during the&lt;br/&gt;
early morning hours. However the external control is doable today using an&lt;br/&gt;
existing merge policy such as LogByteSizeMergePolicy, where during the day&lt;br/&gt;
for example, the maximum segment size could be lower, and in the early&lt;br/&gt;
morning, it&apos;d be set to something much higher, or nullified altogether. &lt;/p&gt;

&lt;p&gt;Also the problems associated with merge interleaving only affects systems&lt;br/&gt;
that are not using replication because the merging is occurring on an&lt;br/&gt;
index-only server. The newly merged files are transferred over as is, and&lt;br/&gt;
that&apos;s something that can easily be interleaved with other IO processes.&lt;/p&gt;</comment>
                    <comment id="12932807" author="shaie" created="Wed, 17 Nov 2010 04:20:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;You contradict yourself here. If we make OneMerge comparable, we define order in its compareTo() method. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it&apos;s convenient to have OneMerge comparable somehow. But we can have MP sort them using its own Comparator. By making them Comparable I intended to say &apos;this is the default order&apos; - but we can have a DefaultComparator instead.&lt;/p&gt;

&lt;p&gt;If we proceed w/ your proposal, that is basically the MS/ME polling MP, and not IW doing so, how would IW know about the running merges and pending ones? Today IW tracks those two lists so that if you need to abort merges, it knows which ones to abort.&lt;/p&gt;

&lt;p&gt;We can workaround aborting the running merges by introducing a MS.abort()-like method. But what about MP? Now the lists are divided between too entities (MP and MS), and aborting a MP does not make sense (doable, but I don&apos;t think it belongs there). Maybe we can have MS.abort() poll MP for next merges until it returns null, and throwing all the returned ones away - that can be done. Aborting an Executor is easy, and I think can be faster than our current way of doing so.&lt;/p&gt;

&lt;p&gt;I would still love to see the merge code (as much as possible) going away from IW. This may not be doable now, but could be in the future, if we factor out a SegmentsMerger/IndexMerger entity which encapsulates the merge execution and policy inside. But this is for another day.&lt;/p&gt;

&lt;p&gt;BTW, MS.merge() takes an IW, as if you could call merge() w/ two IW instances and things will work ok. It does in SMS but doesn&apos;t in CMS. Should we, in the scope of this issue, make IW a required settable parameter on MS, like we do w/ MP?&lt;/p&gt;</comment>
                    <comment id="12932864" author="earwin" created="Wed, 17 Nov 2010 08:52:36 +0000"  >&lt;blockquote&gt;
&lt;p&gt;If we proceed w/ your proposal, that is basically the MS/ME polling MP, and not IW doing so, how would IW know about the running merges and pending ones? Today IW tracks those two lists so that if you need to abort merges, it knows which ones to abort.&lt;/p&gt;

&lt;p&gt;We can workaround aborting the running merges by introducing a MS.abort()-like method. But what about MP? Now the lists are divided between too entities (MP and MS), and aborting a MP does not make sense (doable, but I don&apos;t think it belongs there). &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There are no lists at all with my approach. At least no &quot;pending&quot; list, that one gets recalculated each time we poll MP and it never gets out, neither gets stored inside.&lt;br/&gt;
There&apos;s a kind of implicit &quot;in flight&quot; list - MS has the knowledge of its threads that are currently doing things. And if you want to go around aborting things, MS is probably the right place to do this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe we can have MS.abort() poll MP for next merges until it returns null, and throwing all the returned ones away - that can be done.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;So, just I said - that&apos;s not needed. MP is empty, it has no state.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should we, in the scope of this issue, make IW a required settable parameter on MS, like we do w/ MP?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;For the love of God, no. I&apos;d like to see it removed from MP too.&lt;br/&gt;
It&apos;s only natural to pass the same instance of Policy or Scheduler to different Writers, so they have the same behaviour and share Scheduler resources (insanely important if you have fifteen indexes like I do and don&apos;t want them to rape hardware with fifteen simultaneous merges).&lt;br/&gt;
It is against the nature to pass Writer to Policy. Does the Policy need to write anything on its own, when it decides to? No. It should advice, not act.&lt;/p&gt;</comment>
                    <comment id="12932982" author="shaie" created="Wed, 17 Nov 2010 15:17:24 +0000"  >&lt;p&gt;Earwin, the way CMS currently handles the writer instance makes it entirely not thread-safe. If you e.g. pass different writers to merge(), the class member changes, and MTs will start merging other segments, and in the worse case attempt to merge segments of a different writer.&lt;/p&gt;

&lt;p&gt;I myself thinks it&apos;s ok to have a MP and MS per writer, but I don&apos;t have too strong feelings for/against it - so if we want to allow this, we should fix CMS.&lt;/p&gt;

&lt;p&gt;As for the other comments, I&apos;ll need to check more closely what IW does w/ those merges - as it checks all sorts of things (e.g. whether it&apos;s an optimize merge or not, see one of the latest bugs Mike resolved). So getting it entirely outside of IndexWriter and into MP/MS is risky - at least, I don&apos;t understand the code well enough (yet) to say whether it&apos;s doable at all and if we don&apos;t miss something.&lt;/p&gt;</comment>
                    <comment id="12935327" author="shaie" created="Wed, 24 Nov 2010 14:03:30 +0000"  >&lt;p&gt;There are several points addressed by this issue:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Refactor IW, MS and MP so that MS pulls merges directly from MP, instead from IW.&lt;/li&gt;
	&lt;li&gt;Rewrite CMS to take advantage of ThreadPoolExecutor instead of managing the threads on its own, in addition to using a blocking queue instead of us coding the blocking directly.&lt;/li&gt;
	&lt;li&gt;One should be able to reuse CMS across several IndexWriters, which is not possible today, to e.g., allow one controlling the total # of merges happening in the JVM.&lt;/li&gt;
	&lt;li&gt;Merges should be sorted by their size in bytes and not by their # of docs &amp;#8211; or actually, merges should be sorted by a criteria the MP determines.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All the while maintaining the following requirements, in no particular order:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;MergeThreads&apos; priority needs to be controllable - this is the current behavior of CMS that we&apos;d like to keep.&lt;/li&gt;
	&lt;li&gt;When there are too many merges to execute, small ones should be preferred to large ones, and we need the ability to pause large merges in favor of small ones.&lt;/li&gt;
	&lt;li&gt;The user needs to be able to control:
	&lt;ol&gt;
		&lt;li&gt;The max number of running merges&lt;/li&gt;
		&lt;li&gt;The max number of merges, above which scheduling more merges should be blocked.&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
	&lt;li&gt;We should keep the sync() API, which lets the user wait for all scheduled merges to complete.&lt;/li&gt;
	&lt;li&gt;The MP needs to be aware of the type of merges that are requested (regular, optimize, expunge).&lt;/li&gt;
	&lt;li&gt;The user should be able to fast-close the index, aborting all merges (running and pending).&lt;/li&gt;
	&lt;li&gt;If there are cascading merges (i.e., a result of several other merges), they should all be executed following the call to MS.merge() &amp;#8211; that is, it could be that CMS itself, or its MergeThreads will encounter merges not returned by MP at first, but as a subsequent round due to changes done to the index.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;After investigating the code and going over the proposed plan, I feel that we cannot accomplish all that we&apos;d like to do, given the above requirements. And just to be clear, those are not &lt;b&gt;any&lt;/b&gt; application requirements, but the default ones we&apos;d like Lucene to offer OOtB. One can still write a MS/MP which doesn&apos;t guarantee all that.&lt;/p&gt;

&lt;p&gt;Using ThreadPoolExecutor looks like will only complicate CMS instead of simplifying it:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Because of all the requirements I&apos;ve listed above, we&apos;d need to trick TPE into starting more threads than we intend to run, while we pause some of them.&lt;/li&gt;
	&lt;li&gt;In order to set threads&apos; priorities, we need to write our own ThreadFactory to pass to TPE, and inside it keep track of the allocated Threads and those that still run, so that we can control their priority.&lt;/li&gt;
	&lt;li&gt;There&apos;s no trivial way to impl sync(), as TPE does not provide API we can rely on (e.g. checking when all threads are done). There are ways to impl that, using Semaphore (see next bullet).&lt;/li&gt;
	&lt;li&gt;In order to block the app on too many merges being scheduled, we&apos;d need to use a Semaphore, because even if we use a BlockingQueue w/ TPE, the submit() call won&apos;t block, but simply reject the item.&lt;/li&gt;
	&lt;li&gt;In order to execute cascading merges as well, we&apos;d need the TPE threads (or the Runnable we submit) to poll getNextMerge() until null is returned. This breaks the concepts of Executors, where a task is submitted, done and that&apos;s it. I wouldn&apos;t mind if we did it still though.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;All of these make me think that TPE, at this point at least, is not suitable for CMS. While it&apos;s doable, it&apos;s not going to make CMS code any simpler. And it looks more as if we&apos;ll enforce TPE in CMS, than it is really useful.&lt;/p&gt;

&lt;p&gt;Refactoring IW, MS and MP seems to not simplify anything, really:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;We&apos;d still need IW telling MP which merges are needed (optimize, regular or expunge), so the three findMergesForXYZ will need to remain.&lt;/li&gt;
	&lt;li&gt;The proposal will add a getNextMerge() to MP, instead of IW, which IMO will only complicate matters for MP implementers. E.g., what should MP do if findRegularMerges was called, then getNext() was called and then findOptimizeMerges is called? It&apos;s not a critical decision we leave in the MP developers, but IMO it&apos;s unnecessary. Today MP is a stateless object - it receives SegmentInfos and returns a MergeSpec. It doesn&apos;t need to &apos;remember&apos; anything. But if we move the getNextMerge() to it, we make it stateful, for no good reasons&lt;/li&gt;
	&lt;li&gt;We don&apos;t really take IW outside the loop really - it would still need to instruct MP which merges to &apos;prepare&apos;, so that MS can take.&lt;/li&gt;
	&lt;li&gt;We&apos;d need to introduce an abort/cancel() API on MS, which adds another responsibility for MS, but doesn&apos;t remove much from IW.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;All in all, I don&apos;t think this refactoring simplifies IW-MS-MP communication a lot or allows custom MS and MPs have more control over what&apos;s going on. IW, as the mediator, is nothing but the mediator, which happens to know (as it should) which merges finish and if the state of the index changed, ask MP for more merges. That that it keeps track of pending and running merges, to me, is not a big deal. In fact, due to IW.waitForMerges() it either must continue to keep track of pending/running merges, or we add a sync() API to every MS.&lt;/p&gt;

&lt;p&gt;Fixing CMS to allow sharing across multiple IndexWriter instances is important IMO, so I&apos;ll look into fixing it. To allow for MP dependent sort, I suggest we add to MP a getMergesComparator and use it in CMS. The default (to not break back-compat) can be ByDocsComparator and we override it in the existing MPs.&lt;/p&gt;

&lt;p&gt;I must say that the more I went over the details, the more I was convinced that the proposals made will change the current API for no great benefits. But I may have looked too deeply into the impl, that I lost the ability to think about it &apos;from above&apos; - so I&apos;d appreciate if someone can go over what I wrote and offer comments &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;</comment>
                    <comment id="12935400" author="earwin" created="Wed, 24 Nov 2010 17:08:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;Refactor IW, MS and MP so that MS pulls merges directly from MP, instead from IW.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Directly or through IW - this is not important. Important point is pulling merges one-by-one, when you have the resources to execute them.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Rewrite CMS to take advantage of ThreadPoolExecutor instead of managing the threads on its own, in addition to using a blocking queue instead of us coding the blocking directly.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Using ThreadPoolExecutor looks like will only complicate CMS instead of simplifying it:&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I ended up with same conclusion, while taking my first stabs. But for different reasons.&lt;br/&gt;
The philosphy of Executors is that you schedule (push) a number of tasks, and then some magic black box runs them for you, resolving threading issues itself.&lt;br/&gt;
My suggestion requires pulling tasks when computing resources become available, and that doesn&apos;t map on scheduling model at all.&lt;br/&gt;
All priority/pausing/breaking issues are largely irrelevant.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;MergeThreads&apos; priority needs to be controllable, and we need the ability to pause large merges in favor of small ones&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;These, and the likes - are not requirements.&lt;br/&gt;
These are but one of the possible solutions to our real requirements, which look like&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;don&apos;t run out of file handles on fast indexation&lt;/li&gt;
	&lt;li&gt;don&apos;t degrade search performance and NRT turnaround&lt;/li&gt;
	&lt;li&gt;don&apos;t kill the disk with too much random IOs.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;If there are cascading merges (i.e., a result of several other merges), they should all be executed following the call to MS.merge() - that is, it could be that CMS itself, or its MergeThreads will encounter merges not returned by MP at first, but as a subsequent round due to changes done to the index.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is trivially solved with my pulling model. We pull until nothing is left. Period. Instead of getting batches of merges from MP and then reconciling them with reality we do the same operation over and over again, until MP is satisfied - very simple.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The proposal will add a getNextMerge() to MP, instead of IW, which IMO will only complicate matters for MP implementers. E.g., what should MP do if findRegularMerges was called, then getNext() was called and then findOptimizeMerges is called? It&apos;s not a critical decision we leave in the MP developers, but IMO it&apos;s unnecessary. Today MP is a stateless object - it receives SegmentInfos and returns a MergeSpec. It doesn&apos;t need to &apos;remember&apos; anything. But if we move the getNextMerge() to it, we make it stateful, for no good reasons&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;We don&apos;t really take IW outside the loop really - it would still need to instruct MP which merges to &apos;prepare&apos;, so that MS can take.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There will be, most probably, getNext(Normal/Optimize/Expunge)Merge() methods. findWhatever methods will be removed, noone needs to call them, so - no state, no &apos;preparations&apos;.&lt;br/&gt;
MP will recieve SegmentInfos and return OneMerge.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;To allow for MP dependent sort, I suggest we add to MP a getMergesComparator and use it in CMS.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;MP should return merges sorted, that&apos;s all. Why do you need to expose its Comparator or whatever it uses for sorting?&lt;/p&gt;


&lt;p&gt;Whatever I didn&apos;t mention from your post - I either missed, or agree with &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I think I&apos;ll stop trying to explain it in Jira comments. It took great time discussing everything with Mike over IRC, and here it&apos;ll take ages.&lt;br/&gt;
The proper route is to take a handful of dirt and sticks and slap together some working code to illustrate my point. And that&apos;s what I&apos;m gonna do.&lt;/p&gt;</comment>
                    <comment id="12966029" author="shaie" created="Thu, 2 Dec 2010 09:11:12 +0000"  >&lt;p&gt;Getting rid of the IndexWriter member in CMS is not trivial w/o API change. The IndexWriter member is used for verbosing purposes, which is accessed by some public/protected API, like sync() and doMerge(). So on 3x it&apos;d mean to deprecate methods, which IMO does not justify it. On trunk it&apos;s easier.&lt;/p&gt;

&lt;p&gt;On the other hand, we can consider two things:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Make IndexWriter ThreadLocal &amp;#8211; the thread who calls merge() will own its ThreadLocal, and if different threads index to different indexes, then it should work. But it won&apos;t help in case the indexing threads are taken from a pool.&lt;/li&gt;
	&lt;li&gt;Think whether we want CMS to be shareable across several IndexWriters at all. I haven&apos;t heard that requirement coming up on the list, and definitely if someone attempted to do it, things would break, so I guess no one really does it. Therefore maybe we should leave it to the users to develop something like that on their own, and maybe even contribute back. A MS which might even be simplified by not implementing all of CMS functionality today (controlling threads&apos; priority, pause merge threads etc.).&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;bq, The proper route is to take a handful of dirt and sticks and slap together some working code to illustrate my point. And that&apos;s what I&apos;m gonna do.&lt;/p&gt;

&lt;p&gt;It&apos;d be great if you will do that ! Sometimes it&apos;s indeed easier to fight over a concrete example then theoretical &quot;can and can&apos;t work&quot; arguments.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;MP will recieve SegmentInfos and return OneMerge.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;From whom will it receive it? In the case of cascading merges, the merge threads need to continuously pull MP for getNextMerge(MergeType), but they don&apos;t have the global picture IW holds about the existing segments (SegmentInfos). Also, IW keeps track of the segments that existed when you first called optimize() and doesn&apos;t allow the cascading merges to include segments that didn&apos;t exist at the time. Who will do that accounting now?&lt;/p&gt;</comment>
                    <comment id="12982531" author="shaie" created="Mon, 17 Jan 2011 09:01:16 +0000"  >&lt;p&gt;Patch includes some formatting changes and documentation addition. I&apos;m not sure if eventually we will be able to refactor the whole MP-MS-IW interaction like we said. Earwin, if you still want to work on it, the I can keep the issue open and mark it 3.2 (unless you want to give it a try in 3.1).&lt;/p&gt;

&lt;p&gt;And I think those tiny mods/formatting are worth checking in, because they at least add some documentation to CMS.&lt;/p&gt;</comment>
                    <comment id="12982564" author="earwin" created="Mon, 17 Jan 2011 09:46:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;if you still want to work on it, the I can keep the issue open and mark it 3.2 (unless you want to give it a try in 3.1). &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;ll start another later, so please, go on.&lt;/p&gt;</comment>
                    <comment id="12982621" author="shaie" created="Mon, 17 Jan 2011 12:49:53 +0000"  >&lt;p&gt;Committed revision 1059904 (3x).&lt;br/&gt;
Committed revision 1059905 (trunk).&lt;/p&gt;</comment>
                    <comment id="12983240" author="mikemccand" created="Tue, 18 Jan 2011 16:05:55 +0000"  >&lt;p&gt;The cosmetic change committed here accidentally reverted part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2820&quot; title=&quot;CMS fails to cleanly stop threads&quot;&gt;&lt;del&gt;LUCENE-2820&lt;/del&gt;&lt;/a&gt;, which now causes CMS to deadlock!  Specifically the change in mergeThreadCount()...&lt;/p&gt;

&lt;p&gt;I&apos;ll fix shortly.&lt;/p&gt;</comment>
                    <comment id="12983359" author="rcmuir" created="Tue, 18 Jan 2011 20:19:08 +0000"  >&lt;p&gt;Mike, fyi it looks like we are hung again in hudson:&lt;br/&gt;
&lt;a href=&quot;https://hudson.apache.org/hudson/job/Lucene-Solr-tests-only-3.x/3866/&quot; class=&quot;external-link&quot;&gt;https://hudson.apache.org/hudson/job/Lucene-Solr-tests-only-3.x/3866/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Not sure if its the same deadlock you found.&lt;/p&gt;</comment>
                    <comment id="12983361" author="rcmuir" created="Tue, 18 Jan 2011 20:20:52 +0000"  >&lt;p&gt;I am reopening just so we don&apos;t miss fixing the deadlock... its hung in the same exact part of the tests as earlier&lt;br/&gt;
today so I think its somehow related...&lt;/p&gt;</comment>
                    <comment id="12983439" author="rcmuir" created="Tue, 18 Jan 2011 23:31:45 +0000"  >&lt;p&gt;sorry, hudson just slowed to a crawl apparently... it wasn&apos;t hung.&lt;/p&gt;

&lt;p&gt;when i looked at its console it seemed stuck in the same place... but wasn&apos;t.&lt;/p&gt;</comment>
                    <comment id="13013277" author="gsingers" created="Wed, 30 Mar 2011 16:49:51 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12468539" name="LUCENE-2755.patch" size="4139" author="shaie" created="Mon, 17 Jan 2011 09:01:16 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 11 Nov 2010 14:04:30 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11096</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24937</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>