<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:26:36 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2649/LUCENE-2649.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2649] FieldCache should include a BitSet for matching docs</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2649</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The FieldCache returns an array representing the values for each doc.  However there is no way to know if the doc actually has a value.&lt;/p&gt;

&lt;p&gt;This should be changed to return an object representing the values &lt;b&gt;and&lt;/b&gt; a BitSet for all valid docs.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12474349">LUCENE-2649</key>
            <summary>FieldCache should include a BitSet for matching docs</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="ryantxu">Ryan McKinley</assignee>
                                <reporter username="ryantxu">Ryan McKinley</reporter>
                        <labels>
                    </labels>
                <created>Fri, 17 Sep 2010 04:23:40 +0100</created>
                <updated>Fri, 10 May 2013 11:44:40 +0100</updated>
                    <resolved>Fri, 25 Mar 2011 19:48:13 +0000</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12910446" author="ryantxu" created="Fri, 17 Sep 2010 05:49:31 +0100"  >&lt;p&gt;See some discussion here:&lt;br/&gt;
&lt;a href=&quot;http://search.lucidimagination.com/search/document/b6a531f7b73621f1/trie_fields_and_sortmissinglast&quot; class=&quot;external-link&quot;&gt;http://search.lucidimagination.com/search/document/b6a531f7b73621f1/trie_fields_and_sortmissinglast&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12910447" author="ryantxu" created="Fri, 17 Sep 2010 05:56:10 +0100"  >&lt;p&gt;This patch replaces the cached primitive[] with a CachedObject.  The object heiarch looks like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class CachedObject { 
    
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class CachedArray &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; CachedObject {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bits valid;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; CachedArray( Bits valid ) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.valid = valid;
    }
  };

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; class ByteValues &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; CachedArray {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] values;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues( &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] values, Bits valid ) {
      &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;( valid );
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.values = values;
    }
  };
  ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then this @deprecates the getBytes() classes and replaces them with getByteValues()&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues getByteValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field)
  &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues getByteValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, ByteParser parser)
  &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
  
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then repeat for all the other types!&lt;/p&gt;

&lt;p&gt;All tests pass with this patch, but i have not added any tests for the BitSet (yet)&lt;/p&gt;

&lt;p&gt;If people like the general look of this approach, I will clean it up and add some tests, javadoc cleanup etc&lt;/p&gt;</comment>
                    <comment id="12910460" author="ryantxu" created="Fri, 17 Sep 2010 06:20:55 +0100"  >&lt;p&gt;A slightly simplified version&lt;/p&gt;</comment>
                    <comment id="12910461" author="thetaphi" created="Fri, 17 Sep 2010 06:25:10 +0100"  >&lt;p&gt;That looks exactly like I proposed it!&lt;/p&gt;

&lt;p&gt;The only thing: For DocTerms the approach is not needed? You can check for null, so the Bits interface is not needed. As the OpenBitSets are created with the exact size and don&apos;t need to grow, you can use fastSet to speed up creation by doing no bounds checks.&lt;/p&gt;</comment>
                    <comment id="12910464" author="thetaphi" created="Fri, 17 Sep 2010 06:30:13 +0100"  >&lt;p&gt;When this is committed, we can improve also some Lucene parts: FieldCacheRangeFilter does not need to do extra deletion checks and instead use the Bits interface to find missing/non-valued documents. Lucene&apos;s sorting Collectors can be improved to have a consistent behaviour for missing values (like Solr&apos;s sortMissingFirst/Last).&lt;/p&gt;</comment>
                    <comment id="12910513" author="mikemccand" created="Fri, 17 Sep 2010 10:20:37 +0100"  >&lt;p&gt;Looks great!&lt;/p&gt;

&lt;p&gt;Should we make it optional, whether the valid bitset should be computed?  Many apps wouldn&apos;t need it, so it just ties up (admittedly smallish amounts of) RAM unnecessarily?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Lucene&apos;s sorting Collectors can be improved to have a consistent behaviour for missing values (like Solr&apos;s sortMissingFirst/Last).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Shouldn&apos;t we pull Solr&apos;s sortMissingFirst/Last down into Lucene?&lt;/p&gt;</comment>
                    <comment id="12910539" author="simonw" created="Fri, 17 Sep 2010 12:09:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;Should we make it optional, whether the valid bitset should be computed? Many apps wouldn&apos;t need it, so it just ties up (admittedly smallish amounts of) RAM unnecessarily?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1 we can save that overhead and high level apps can enable it by default if needed.&lt;/p&gt;
</comment>
                    <comment id="12910554" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 13:47:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;Should we make it optional, whether the valid bitset should be computed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The trick is how to implement that (unless you mean just set it to true/false for all fields at once).  Putting a flag on the FieldCache.getXXX methods is insufficient.&lt;br/&gt;
Only the application knows if some of it&apos;s future uses of that field will require the bitset for matching docs, but it&apos;s Lucene that&apos;s often making the calls to the field cache.&lt;/p&gt;

&lt;p&gt;Perhaps FieldCache.Parser was originally just too narrow in scope - it should have been a factory method for handling all decisions about creating and populating a field cache entry?&lt;/p&gt;</comment>
                    <comment id="12910568" author="simonw" created="Fri, 17 Sep 2010 14:24:43 +0100"  >&lt;blockquote&gt;&lt;p&gt;Perhaps FieldCache.Parser was originally just too narrow in scope - it should have been a factory method for handling all decisions about creating and populating a field cache entry?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I guess we need to be able to manually configure FieldCache with some kind of FieldType. There have been several issues mentioning this and it keeps coming up again and again. I think it is just time to rethink Fieldable / Field and move towards some kind of flexible type definition for Fields in Lucene. A FieldType could then have a FieldCache Attribute which contains all necessary info including the parser and flags like the one we are talking about. Yet, before I get too excieted about FieldType, yeah something with a wider scope than FieldCache.Parser would work in this case. I don&apos;t know how far the FieldType is away but it can eventually replace whatever is going to be implemented here in regards to that flag. &lt;/p&gt;

&lt;p&gt;I think by default we should not enable the Bits feature but it must be explicitly set via whatever mechanism we gonna use.&lt;/p&gt;
</comment>
                    <comment id="12910576" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 14:40:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I guess we need to be able to manually configure FieldCache with some kind of FieldType.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know how well that would work.  For one, there&apos;s only one FieldCache, so configuring it with anything seems problematic.&lt;br/&gt;
Also, if I have to list out all the fields I&apos;m going to use, that&apos;s another big step backwards.&lt;/p&gt;

&lt;p&gt;A factory would be a pretty straightforward way to increase the power, by allowing users to populate the entry through any mechanism, and optionally do extra calculations when the entry is populated (think statistics, sum-of-squares, etc).&lt;/p&gt;</comment>
                    <comment id="12910589" author="simonw" created="Fri, 17 Sep 2010 14:59:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;Also, if I have to list out all the fields I&apos;m going to use, that&apos;s another big step backwards.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I don&apos;t think that this is needed at all neither would it be a step backwards - not even near to that. But since we aren&apos;t on an issue about FieldType lets just drop it...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A factory would be a pretty straightforward way to increase the power, by allowing users to populate the entry through any mechanism, and optionally do extra calculations when the entry is populated (think statistics, sum-of-squares, etc).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Whatever you call it (using Factory is fine) but isn&apos;t that what you mentioned to be insufficient? I mean this is something you would pass to a FieldCache.getXXX, right? &lt;/p&gt;</comment>
                    <comment id="12910591" author="shaie" created="Fri, 17 Sep 2010 15:01:30 +0100"  >&lt;p&gt;One thing I&apos;ve wanted to do for a long time, but didn&apos;t get to doing it, is open up FieldCache to allow the application to populate the entries from other sources - specifically pyloads. I wrote a sorting solution which relies solely on payloads, and wanted to contribute it to Lucene, but due to lack&apos;s of FieldCache hook points, I didn&apos;t find the time to do the necessary refactoring.&lt;/p&gt;

&lt;p&gt;Sorting based on payloads-data has several advantages:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;It&apos;s much faster to read than iterating on the lexicon and parsing the term values into sortable values.&lt;/li&gt;
	&lt;li&gt;If your application needs to cater sort over 10s of millions of documents, or if it needs to keep its RAM usage low, you can do the sort while reading the payload data as the search happens. It&apos;s faster than if it was in RAM, but the current FieldCache does not allow you to sort w/o RAM consumption.&lt;/li&gt;
	&lt;li&gt;You don&apos;t inflate your lexicon w/ sort values, affecting other searches. In some situations, you can add a unique term per document for the sort values (such as when sorting by date and require up to a millisecond precision).&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I&apos;m bringing it up so that if you consider any refactoring to FieldCache, I&apos;d appreciate if you can keep that in mind. If the right hooks will open up, I&apos;ll make time to contribute my sort-by-payload package. If you don&apos;t, then it&apos;ll need to wait until I can find the time to do the refactoring.&lt;/p&gt;
</comment>
                    <comment id="12910598" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 15:09:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;Whatever you call it (using Factory is fine) but isn&apos;t that what you mentioned to be insufficient? I mean this is something you would pass to a FieldCache.getXXX, right? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was suggesting handling it the same way as FieldCache.Parser - it&apos;s set on the SortField.  But instead of just being able to control parsing of a term (which is too limited), it needs to be able to control everything. (This would solve Shai&apos;s needs too)&lt;/p&gt;</comment>
                    <comment id="12910599" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 15:14:19 +0100"  >&lt;blockquote&gt;&lt;p&gt;open up FieldCache to allow the application to populate the entries from other sources&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;specifically payloads&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If CSF did not exist, I&apos;d be totally on board with this...  but it looks to be right around the corner now.  Are there any advantages to using payloads over CSF for fieldcache population?&lt;/p&gt;</comment>
                    <comment id="12910618" author="ryantxu" created="Fri, 17 Sep 2010 16:12:52 +0100"  >&lt;p&gt;This is a band-aid, but we could consider adding something like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setCacheValidBitsForFields( Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; names );
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;on FieldCache, then checking if the field is in that set before making the BitSet&lt;/p&gt;

&lt;p&gt;When solr reads the schema, it could look for any fields have sortMissingLast and then call:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  FieldCache.DEFAULT.setCacheValidBitsForFields()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The factory idea also sounds good, but i don&apos;t see how would work without big big changes&lt;/p&gt;</comment>
                    <comment id="12910625" author="shaie" created="Fri, 17 Sep 2010 16:20:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;Are there any advantages to using payloads over CSF for fieldcache population?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well .. payloads already exist (in my code &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;), while CSF is &quot;just around the corner&quot; for a long time. While the two ultimately achieve the same goal, CSF is more generic than just payloads, and if we&apos;d want to take advantage of it w/ FieldCache, I assume we&apos;ll need to make more changes to FieldCache, because w/ CSF, people can store arbitrary byte[] and request to cache them. So sorting data is a subset of CSF indeed, but I think the road to CSF + CSF-FieldCache integration is long. But perhaps I&apos;m not up-to-date and there is progress / someone actually working on CSF?&lt;/p&gt;

&lt;p&gt;Anyway, opening up FC to read from payloads seems to me a much easier solution, because besides reading the stuff from the payload, the rest of the classes continue to work the same (TopFieldCollector, Comparators etc.).&lt;/p&gt;

&lt;p&gt;Maybe a slight change to SortField will be required as well though, not sure yet.&lt;/p&gt;</comment>
                    <comment id="12910628" author="ryantxu" created="Fri, 17 Sep 2010 16:23:12 +0100"  >&lt;p&gt;Uwe: &quot;For DocTerms the approach is not needed...&quot;&lt;/p&gt;

&lt;p&gt;Ya I realized this after looking at the patch I first submitted.  In the first patch, the cache holds a CachedObject rather then just an Object.  In the second, I changed back to just an Object so it does not need to wrap the DocTerms or DocTermsIndex&lt;/p&gt;

&lt;p&gt;For the RangeFilter, with optional Bits calculation, that could would look somethign like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

        LongValues cached = FieldCache.DEFAULT.getLongValues(reader, field, (FieldCache.LongParser) parser);
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;[] values = cached.values;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( cached.valid == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
          &lt;span class=&quot;code-comment&quot;&gt;// ignore deleted docs &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; range doesn&apos;t contain 0
&lt;/span&gt;          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FieldCacheDocIdSet(reader, !(inclusiveLowerPoint &amp;lt;= 0L &amp;amp;&amp;amp; inclusiveUpperPoint &amp;gt;= 0L)) {
            @Override
            &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; matchDoc(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc) {
              &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; values[doc] &amp;gt;= inclusiveLowerPoint &amp;amp;&amp;amp; values[doc] &amp;lt;= inclusiveUpperPoint;
            }
          };
        }
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
          &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bits valid = cached.valid;
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FieldCacheDocIdSet(reader, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
            @Override
            &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; matchDoc(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc) {
              &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; valid.get(doc) &amp;amp;&amp;amp; values[doc] &amp;gt;= inclusiveLowerPoint &amp;amp;&amp;amp; values[doc] &amp;lt;= inclusiveUpperPoint;
            }
          };
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12910635" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 16:41:21 +0100"  >&lt;blockquote&gt;&lt;p&gt;public void setCacheValidBitsForFields( Set&amp;lt;String&amp;gt; names );&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Solr doesn&apos;t even know all of the fields at the time it reads it&apos;s schema.  And even if it did... this would seem to break multi-core or anything trying to have more than one index where the fields are different.  Seems like this needs to be passed down via SortField, just like FieldCache.Parser.  A factory makes this a more generic method than adding additional params to SortField every time we think of something like this... then we can add stuff like getFieldCacheParser() and other stuff to the factory.&lt;/p&gt;</comment>
                    <comment id="12910640" author="ryantxu" created="Fri, 17 Sep 2010 16:52:38 +0100"  >&lt;p&gt;oh right &amp;#8211; thats true.  Is a global flag sufficient?  &lt;/p&gt;

&lt;p&gt;In lucene it could default to false and in solr default to true.&lt;/p&gt;

&lt;p&gt;I know we don&apos;t want to just keep adding more things to memory, but I&apos;m not sure there is a huge win by selectively enabling and disabling some fields.&lt;/p&gt;</comment>
                    <comment id="12910645" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 17:00:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;oh right - thats true. Is a global flag sufficient? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, solr could just always default it to on.  We don&apos;t know what kind of ad-hoc queries people will throw at solr and the 3% size increase (general case 1/32) seems completely worth it.&lt;/p&gt;</comment>
                    <comment id="12910652" author="ryantxu" created="Fri, 17 Sep 2010 17:31:54 +0100"  >&lt;p&gt;I added a static flag to CachedArray:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class CachedArray {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; CACHE_VALID_ARRAY_BITS = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bits valid;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; CachedArray( Bits valid ) {
      &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.valid = valid;
    }
  };
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and then set it to true in the SolrCore static initalizer.&lt;/p&gt;

&lt;p&gt;If folks are ok with this approach, I&apos;ll clean up the javadocs etc&lt;/p&gt;</comment>
                    <comment id="12910653" author="ryantxu" created="Fri, 17 Sep 2010 17:33:19 +0100"  >&lt;p&gt;FYI, I like the idea of revisiting the FieldCache, but i don&apos;t see a straightforward path.&lt;/p&gt;</comment>
                    <comment id="12910654" author="thetaphi" created="Fri, 17 Sep 2010 17:43:55 +0100"  >&lt;p&gt;I am against the configuration option to enable the additional BitSet. The problem is that you cannot control it for each usage for the FieldCache, as it is a static flag. We agreed in the past that we will remove all static defaults from Lucene (e.g. BQ.maxClauseCount) together with sytem properties. This flag can cause strange problems with 3rd party code (like when you lower the BQ maxClauseCount and suddenly your queries fail).&lt;/p&gt;

&lt;p&gt;The overhead by the OpenBitSet is very marginal (for integers only 1/32, as Yonik said). If you have memory problems with the FieldCache, these 1/32 would not hurt you, as you should think about your whole configuration then (liek moving from ints to shorts or something like that).&lt;/p&gt;

&lt;p&gt;So: Please don&apos;t add any static defaults or sysprops! Please, please, please!&lt;/p&gt;</comment>
                    <comment id="12910660" author="markrmiller@gmail.com" created="Fri, 17 Sep 2010 17:56:44 +0100"  >&lt;blockquote&gt;&lt;p&gt;I was suggesting handling it the same way as FieldCache.Parser - it&apos;s set on the SortField. But instead of just being able to control parsing of a term (which is too limited), it needs to be able to control everything. (This would solve Shai&apos;s needs too)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We started down this path with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; - you could pass some *UnInverter on the sort field if i remember right, so that pretty much everything could be overridden. It has come up a lot - we really need this level of customizability eventually.&lt;/p&gt;</comment>
                    <comment id="12910663" author="ryantxu" created="Fri, 17 Sep 2010 18:00:46 +0100"  >&lt;p&gt;I&apos;m all for dropping the static flag and always calculating the valid bits &amp;#8211; it makes things accurate with minimal cost.  &lt;/p&gt;

&lt;p&gt;I am sympathetic to folks who don&apos;t want this, and I&apos;m not sure the cleanest way to support both options, or even if it is actually worthwhile.&lt;/p&gt;

&lt;p&gt;Do people see this &apos;option&apos; as a showstopper?  If so, is there an easy way to configure?  without statics, the flag would need to be fetched from each parser, and the parser does not know what FieldCache it is used from (using FieldCache.DEFAULT is just as bad as the static flag IIUC)&lt;/p&gt;
</comment>
                    <comment id="12910668" author="creamyg" created="Fri, 17 Sep 2010 18:11:47 +0100"  >&lt;p&gt;&amp;gt; So: Please don&apos;t add any static defaults or sysprops! Please, please, please!&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;No global variables which control behavior, please.&lt;/p&gt;</comment>
                    <comment id="12910677" author="mikemccand" created="Fri, 17 Sep 2010 18:28:26 +0100"  >&lt;p&gt;I know it&apos;s only 3% (for ints... 12.5% for bytes), but, 3% here, 3% there and suddenly we&apos;re talking real money.&lt;/p&gt;

&lt;p&gt;Lucene can only stay lean and mean if we don&apos;t allow these little 3% losses here and there!!&lt;/p&gt;

&lt;p&gt;Let&apos;s try to find some baby-step (even if not clean &amp;#8211; we know FieldCache, somehow, needs to be fixed more generally) for today?&lt;/p&gt;</comment>
                    <comment id="12910699" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 19:01:14 +0100"  >&lt;blockquote&gt;&lt;p&gt;Let&apos;s try to find some baby-step (even if not clean - we know FieldCache, somehow, needs to be fixed more generally) for today?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The cheapest option might be:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; Parser &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Serializable {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; recordMissing();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A better option is to replace FieldCache.Parser in SortField to be FieldCache.EntryCreator.&lt;/p&gt;

&lt;p&gt;Oh, and if we&apos;re recording all the set bits, it would be really nice to record both&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the number of values set&lt;/li&gt;
	&lt;li&gt;the number of unique values encountered&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Both should be zero or non-measurable cost (a counter++ that does not produce a data dependency can be executed in parallel on a free int execution unit)&lt;/p&gt;</comment>
                    <comment id="12910700" author="ryantxu" created="Fri, 17 Sep 2010 19:02:10 +0100"  >&lt;p&gt;Are people generally ok with the idea of global on/off?  I think that is a reasonable approach... I agree that we should avoid static fields to control behavior.  But do we avoid it at the cost of not allowing the option, or waiting till we rework FieldCache?&lt;/p&gt;

&lt;p&gt;If the consensus is that FieldCache needs to be reworked &lt;b&gt;before&lt;/b&gt; somethign like this could be added, that&apos;s fine... i&apos;ll move on to other things.  Any relatively easy suggestions for how to enable the option without a global static?  (Note that FieldCache is already a global static &amp;#8211; at leaset FieldCache.DEFAULT is referenced a lot)&lt;/p&gt;

&lt;p&gt;Perhaps this could/should live in /trunk until a cleaner solution is viable?&lt;/p&gt;


</comment>
                    <comment id="12910707" author="thetaphi" created="Fri, 17 Sep 2010 19:11:14 +0100"  >&lt;p&gt;I am against that option! No static defaults! (and if it &lt;b&gt;must&lt;/b&gt; be there - default it to true on Lucene, too).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the number of values set &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is OpenBitSet.cardinality() ? I dont think we should add this extra cost during creation, as it can be retrieved quite easy if really needed.&lt;/p&gt;</comment>
                    <comment id="12910711" author="ryantxu" created="Fri, 17 Sep 2010 19:15:49 +0100"  >&lt;p&gt;I like the idea of optionally caching the numdocs and unique values &amp;#8211; that would make sorting by this field faster &amp;#8211; the ArrayValues class could be easily augmented with this.&lt;/p&gt;

&lt;p&gt;The problem with augmenting the Parser class as you suggest is that we would have to rejiggy everything that touches parser.  We would need different default classes for things that want or don&apos;t want the missing records.  How do we handle this big:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (parser == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; wrapper.getIntValues(reader, field, DEFAULT_INT_PARSER);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (NumberFormatException ne) {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; wrapper.getIntValues(reader, field, NUMERIC_UTILS_INT_PARSER);      
        }
      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;yuck&lt;/p&gt;</comment>
                    <comment id="12910717" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 19:26:58 +0100"  >&lt;p&gt;If ya care - don&apos;t pass a null parser!  Otherwise you get the default.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This is OpenBitSet.cardinality()&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which isn&apos;t free... and calculating it over and over again is silly if you care about those numbers.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I dont think we should add this extra cost during creation,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think it will add extra cost.  I could be wrong, but I don&apos;t think it will be measurable.&lt;/p&gt;</comment>
                    <comment id="12910728" author="ryantxu" created="Fri, 17 Sep 2010 19:49:44 +0100"  >&lt;blockquote&gt;&lt;p&gt;If ya care - don&apos;t pass a null parser! Otherwise you get the default. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What if I care, but somethign else (that does not care) asks for the value first?  Seems odd to have so much depend on &lt;b&gt;who&lt;/b&gt; asks for the value first&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;A better option is to replace FieldCache.Parser in SortField to be FieldCache.EntryCreator.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How would that work?  What if a filter creates the cache before the SortField?  &lt;/p&gt;</comment>
                    <comment id="12910736" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 20:04:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;What if I care, but somethign else (that does not care) asks for the value first? Seems odd to have so much depend on who asks for the value first&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As long as it &lt;b&gt;can&lt;/b&gt; be passed everywhere that matters, then it&apos;s up to the application - which knows if it ever needs the missing values or not for that field.  For solr, we could make it configurable per-field... but I&apos;d prob default it to ON to avoid unpredictable weirdness.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What if a filter creates the cache before the SortField?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we have a filter that uses the field cache, then it should also be able to specify the same stuff that SortField can.&lt;/p&gt;</comment>
                    <comment id="12910740" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 20:17:06 +0100"  >&lt;blockquote&gt;&lt;p&gt;I agree that we should avoid static fields to control behavior. But do we avoid it at the cost of not allowing the option, or waiting till we rework FieldCache?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree with this sentiment - progress, not perfection.  Being able to turn it on or off for everything in the process is better than nothing at all.&lt;/p&gt;</comment>
                    <comment id="12910746" author="yseeley@gmail.com" created="Fri, 17 Sep 2010 20:34:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;How would that work?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could start off simple - add only recordMissing functionallity and punt on the rest, while still leaving a place to add it.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class FieldCache {

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class EntryCreator {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; recordMissing() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }
    
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; Parser getParser();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Not even sure if a whole hierarchy is needed at this point... in the future, we&apos;d prob want&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; EntryCreatorInt &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; EntryCreator {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; IntValues getIntValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field) {... code currently in FieldCacheImpl that fills the fieldCahe...}
    ...
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12910803" author="ryantxu" created="Fri, 17 Sep 2010 22:45:15 +0100"  >&lt;p&gt;Maybe, but I&apos;m still not sure this cleans things up enough to be worth the trouble &amp;#8211; ideally the API should be easy to have consistent results.  I don&apos;t like that it would be too easy to mess things up if you the application does not use the same parser from various components (that may be in different libraries etc).  Conceptually it makes sense to have settings about what is or is not cached attached to the FieldCache itself, not to the things that ask the FieldCache for its values &amp;#8211; and letting whoever asks first set the behavior for the next guy who asks (regardless of what they ask for!).  &lt;/p&gt;

&lt;p&gt;If we are going to make it essentially required to always pass in the right Parser/EntryCreator, we should at least remove all the ways of not passing one in &amp;#8211; since that call is saying &quot;use what ever is there, and the next guy who asks should be ok with it too&quot;&lt;/p&gt;

&lt;p&gt;Does something like the EntryCreator idea fix &amp;#8211; or at least begin to fix &amp;#8211; the other FieldCache issues?  If not, is it really worth introducing just to avoid a static variable?&lt;/p&gt;

&lt;p&gt;I think the best near term option is live with the static initializer, and fix it when the we rework the FieldCache to fix a host of other issues.  For solr the default will be set to always calculate, for lucene... we will let Mike and Uwe duke it out &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;






</comment>
                    <comment id="12910805" author="thetaphi" created="Fri, 17 Sep 2010 22:51:07 +0100"  >&lt;p&gt;Supporting different parsers is not an issue at all. You can call getBytes() with different parsers, you simply create two entries in the cache, as each parser produces a different cache instance. And getBytes() without parser is also fine, as then you get the default parser from the cache (which would not create a third instance!). - &lt;span class=&quot;error&quot;&gt;&amp;#91;Parser is part of the cache key&amp;#93;&lt;/span&gt;&lt;/p&gt;</comment>
                    <comment id="12911128" author="ryantxu" created="Sun, 19 Sep 2010 01:21:34 +0100"  >&lt;p&gt;I thought of  an optimization that could reduce memory usage...  &lt;/p&gt;

&lt;p&gt;If all non-deleted documents have a value, we don&apos;t need a real BitSet &amp;#8211; just a Bits implementation that always returns true.&lt;/p&gt;

&lt;p&gt;That should save 3% (or 12.5%) here and there.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On other thing to consider... do we want to remove the getXXXX functions that do not pass in a Parser?  passing in null, is equivalent?&lt;/p&gt;</comment>
                    <comment id="12911157" author="ryantxu" created="Sun, 19 Sep 2010 04:44:12 +0100"  >&lt;p&gt;Here is the code for ByteValues that:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;optionally stores the BitSet via static config&lt;/li&gt;
	&lt;li&gt;does not cache a real BitSet unless only some docs match&lt;/li&gt;
	&lt;li&gt;calculates numDocs/numTerms&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; ByteValues createValue(IndexReader reader, Entry entryKey) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
      Entry entry = entryKey;
      &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field = entry.field;
      ByteParser parser = (ByteParser) entry.custom;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (parser == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; wrapper.getByteValues(reader, field, FieldCache.DEFAULT_BYTE_PARSER);
      }
      &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numDocs = 0;
      &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numTerms = 0;
      &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; maxDoc = reader.maxDoc();
      &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] retArray = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[maxDoc];
      Bits valid = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
      Terms terms = MultiFields.getTerms(reader, field);
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (terms != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; TermsEnum termsEnum = terms.iterator();
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bits delDocs = MultiFields.getDeletedDocs(reader);
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; OpenBitSet validBits = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OpenBitSet( maxDoc );
        DocsEnum docs = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
          &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; BytesRef term = termsEnum.next();
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (term == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
              &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
            }
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; termval = parser.parseByte(term);
            docs = termsEnum.docs(delDocs, docs);
            &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
              &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docID = docs.nextDoc();
              &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (docID == DocsEnum.NO_MORE_DOCS) {
                &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
              }
              retArray[docID] = termval;
              validBits.set( docID );
              numDocs++;
            }
            numTerms++;
          }
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (StopFillCacheException stop) {}
        
        &lt;span class=&quot;code-comment&quot;&gt;// If all non-deleted docs are valid we don&apos;t need the bitset in memory
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( numDocs &amp;gt; 0 &amp;amp;&amp;amp; CachedArray.CACHE_VALID_ARRAY_BITS ) {
          &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; matchesAllDocs = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
          &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0; i&amp;lt;maxDoc; i++ ) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( !delDocs.get(i) &amp;amp;&amp;amp; !validBits.get(i) ) {
              matchesAllDocs = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
              &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
            }
          }
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( matchesAllDocs ) {
            valid = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Bits.MatchAllBits( maxDoc );
          }
          &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            valid = validBits;
          }
        }
      }
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( numDocs &amp;lt; 1 ) {
        valid = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Bits.MatchNoBits( maxDoc );
      }
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteValues( retArray, valid, numDocs, numTerms );
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12913347" author="ryantxu" created="Wed, 22 Sep 2010 03:02:08 +0100"  >&lt;p&gt;Any thoughts on this?&lt;/p&gt;

&lt;p&gt;I think the best move forward is to:&lt;br/&gt;
a. optimize as much as possible&lt;br/&gt;
b. drop the no-parser function option&lt;br/&gt;
c. optionally store the bitset via static config (ugly, but lesser of many ugly options)&lt;br/&gt;
d. set lucene default=false (actually I don&apos;t care)&lt;br/&gt;
e. set solr default=true&lt;/p&gt;

&lt;p&gt;Unless there are objections, I will clean up the patch, fix javadoc, tests, etc&lt;/p&gt;</comment>
                    <comment id="12913353" author="thetaphi" created="Wed, 22 Sep 2010 03:15:17 +0100"  >&lt;p&gt;Also set the Lucene default to true, as I want to improve sorting and FCRF.&lt;/p&gt;</comment>
                    <comment id="12913418" author="ryantxu" created="Wed, 22 Sep 2010 07:36:01 +0100"  >&lt;p&gt;Here is a (hopefully) final patch that adds a bunch of tests to exercise the the &apos;valid&apos; bits (and check that MatchAll is used when appropriate)&lt;/p&gt;</comment>
                    <comment id="12913428" author="thetaphi" created="Wed, 22 Sep 2010 07:59:47 +0100"  >&lt;p&gt;Hi Ryan,&lt;/p&gt;

&lt;p&gt;few comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the tests if all/no bits are set and so the special Bits implementations are returned are fine, but the special case for all bits are valid may be a little bit ineffective and seldom&lt;/li&gt;
	&lt;li&gt;please use the correct Java code style (&quot;{&quot; should be at the end of previous line and not in separate line for method declarations), the Eclipse code style is available in Wiki&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12913485" author="mikemccand" created="Wed, 22 Sep 2010 11:18:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;Also set the Lucene default to true&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Please don&apos;t!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;as I want to improve sorting and FCRF.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But: sorting, FCRF must continue to work if the app chooses not to&lt;br/&gt;
load valid bits, right?&lt;/p&gt;

&lt;p&gt;Other feedback on current patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;We don&apos;t have to @Deprecate for 4.0 &amp;#8211; just remove it, and note&lt;br/&gt;
    this in MIGRATE.txt.  (Though for 3.x we need the deprecation, so&lt;br/&gt;
    maybe do 3.x patch first, then remove deprecations for 4.0?).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;FieldCache.EntryCreator looks orphan&apos;d?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It looks like the valid bits will not reflect deletions (by design),&lt;br/&gt;
right?  Ie caller cannot rely on valid always incorporating deleted&lt;br/&gt;
docs.  (Eg the MatchAll opto disregards deletions, and, a reopened&lt;br/&gt;
segment can have new deletions yet shares the FC entry).&lt;/p&gt;

&lt;p&gt;The static config still also bothers me... and, going that route means&lt;br/&gt;
we must agree on a default (which is looking hard!).&lt;/p&gt;

&lt;p&gt;What if we:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Allow specifying &quot;loadValidBits&quot; on each load (eg via Parser or&lt;br/&gt;
    separate arg to FC.getXXValues), but,&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We separately cache the valid bits (we&apos;d still have the XXXValues&lt;br/&gt;
    returned, to include the valid bits &amp;amp; values).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This way if an app &quot;messes up&quot;, they do not end up double-storing the&lt;br/&gt;
actual values, ie the worst that happens is they have to re-invert&lt;br/&gt;
just to generate the valid bits.  Even that should be fairly rare, ie,&lt;br/&gt;
if they use MissingStringLastComparator it&apos;ll init both values &amp;amp; valid&lt;br/&gt;
bits entries in the cache on the first go.&lt;/p&gt;</comment>
                    <comment id="12913503" author="rcmuir" created="Wed, 22 Sep 2010 12:29:21 +0100"  >&lt;blockquote&gt;&lt;p&gt;Also set the Lucene default to true, as I want to improve sorting and FCRF.&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;I know it&apos;s only 3% (for ints... 12.5% for bytes), but, 3% here, 3% there and suddenly we&apos;re talking real money.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m having trouble understanding the use case for this bitset.&lt;/p&gt;

&lt;p&gt;The jira issue says to add a bitset, but doesnt explain why.&lt;/p&gt;

&lt;p&gt;The linked thread talks about this being useful for sorting missing values last, but I don&apos;t think this justifies&lt;br/&gt;
increasing the size of fieldcache by default.&lt;/p&gt;</comment>
                    <comment id="12913623" author="ryantxu" created="Wed, 22 Sep 2010 16:36:35 +0100"  >&lt;p&gt;Here is a new patch that removes the static config.  Rather then put a property on Parser class, I added a class:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class CacheConfig {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cacheValidBits();
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and this gets passed to the getXXXValues function:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ByteValues getByteValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, ByteParser parser, CacheConfig config)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think this is a better option then adding a parameter to Parser since we can have an easy upgrade path.  Parser is an interface, so we can not just add to it without breaking compatibility.  To change things in 4.x, 3.x should have an upgrade path.&lt;/p&gt;

&lt;p&gt;I took Mike&apos;s suggestion and include the CacheConfig hashcode in the Cache key &amp;#8211; however, I don&apos;t cache the Bits separately since this is an edge case that &lt;b&gt;should&lt;/b&gt; be avoided, but at least does not fail if you are not consistent.&lt;/p&gt;

&lt;p&gt;This does cache a MatchAllBits even when &apos;cacheValidBits&apos; is false, since that is small (a small class with one int)&lt;/p&gt;

&lt;p&gt;-----------&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;*  We don&apos;t have to @Deprecate for 4.0 - just remove it, and note this in MIGRATE.txt. (Though for 3.x we need the deprecation, so maybe do 3.x patch first, then remove deprecations for 4.0?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My plan was to apply with deprecations to 4.x, then merge with 3.x.  Then replace the calls in 4.x, then remove the old functions.  Does this sound reasonable?&lt;/p&gt;

&lt;p&gt;I would like this to get in 3.x since we could then remove many solr types in 4.x and have a 3.x migration path.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;* FieldCache.EntryCreator looks orphan&apos;d?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;dooh, thanks&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;It looks like the valid bits will not reflect deletions (by design), right? Ie caller cannot rely on valid always incorporating deleted docs. (Eg the MatchAll opto disregards deletions, and, a reopened segment can have new deletions yet shares the FC entry).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, the ValidBits are only checked for docs that exists (and the FC values are only set for docs that exists &amp;#8211; this has not changed), and may contain false positives for deleted docs.  I think this is OK since most use cases (i can think of) deal with deletions anyway.   Any ideas how/if we should change this?  (I did not realize that the FC is reused after deletions &amp;#8211; so clever)&lt;/p&gt;

&lt;p&gt;----------------&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m having trouble understanding the use case for this bitset.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My motivation is for supporting the supportMissingLast feature in solr sorting (that could now be pushed to lucene).  For example if I have a bunch of documents and only some have the field &quot;bytes&quot; &amp;#8211; sorting &apos;bytes desc&apos; works great, but sorting &apos;bytes asc&apos; puts all the documents that do not have the field &apos;bytes&apos; first since the FieldCache thinks they are all zero.&lt;/p&gt;

&lt;p&gt;If we get this working in solr, we can deprecate and delete all the &quot;sortable&quot; number fields and have that same functionality on Trie* fields.&lt;/p&gt;




</comment>
                    <comment id="12913633" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 17:00:44 +0100"  >&lt;p&gt;If folks think that being able to tell a real &quot;0&quot; from a missing value is not useful for Lucene, we&lt;br/&gt;
could extend Ryan&apos;s CacheConfig to include a factory method that creates / populates ByteValues, IntValues, etc.&lt;br/&gt;
Then all the bitset stuff could be kept in Solr only.  I&apos;m sensitive about pushing stuff into Lucene that is &lt;b&gt;only&lt;/b&gt; useful for Solr.&lt;/p&gt;
</comment>
                    <comment id="12913646" author="mikemccand" created="Wed, 22 Sep 2010 17:23:22 +0100"  >
&lt;blockquote&gt;&lt;p&gt;I think this is a better option then adding a parameter to Parser since we can have an easy upgrade path. Parser is an interface, so we can not just add to it without breaking compatibility. To change things in 4.x, 3.x should have an upgrade path.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm... I&apos;d rather make an exception to 3.x, ie, allow the addition of&lt;br/&gt;
this method to the interface, than confuse the 4.x API, going forward,&lt;br/&gt;
with 2 classes?&lt;/p&gt;

&lt;p&gt;Creating a custom FieldCache parser is an extremely advanced use&lt;br/&gt;
case... very few users do this, and those that do will grok this&lt;br/&gt;
method?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;However, I don&apos;t cache the Bits separately since this is an edge case that should be avoided, but at least does not fail if you are not consistent.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This makes me nervous since it can now lead to further cases of field&lt;br/&gt;
cache insanity, ie, you loaded it once w/o the valid bits, and again&lt;br/&gt;
w/ the valid bits, and now your values array is taking up 2X the RAM.&lt;/p&gt;

&lt;p&gt;It&apos;s already bad enough that FC allows one kind of insanity &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This does cache a MatchAllBits even when &apos;cacheValidBits&apos; is false, since that is small (a small class with one int)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm... but if I pass false here, it shouldn&apos;t spend any time&lt;br/&gt;
allocating the bit set, building it, checking the bit set for &quot;all&lt;br/&gt;
bits set&quot;, etc.?&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;*  We don&apos;t have to @Deprecate for 4.0 - just remove it, and note this in MIGRATE.txt. (Though for 3.x we need the deprecation, so maybe do 3.x patch first, then remove deprecations for 4.0?).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My plan was to apply with deprecations to 4.x, then merge with 3.x.  Then replace the calls in 4.x, then remove the old functions.  Does this sound reasonable?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK that sounds like a good plan!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Right, the ValidBits are only checked for docs that exists (and the FC values are only set for docs that exists &amp;#8211; this has not changed), and may contain false positives for deleted docs.  I think this is OK since most use cases (i can think of) deal with deletions anyway.   Any ideas how/if we should change this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is the right approach &amp;#8211; expecting FC&apos;s valid bits to&lt;br/&gt;
take deletions into account is too much.  We have IR.getDeletedDocs&lt;br/&gt;
for this.&lt;/p&gt;

&lt;p&gt;But, eg this means classes like FCRF will still have to consult&lt;br/&gt;
deleted docs.&lt;/p&gt;

&lt;p&gt;Really, &quot;in general&quot; we need a better way for the query execution path&lt;br/&gt;
to enforce deleted docs.  Eg if the FCRF will be AND&apos;d w/ a query&lt;br/&gt;
that&apos;s already excluding del docs then it need not be careful about&lt;br/&gt;
deletions...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(I did not realize that the FC is reused after deletions &amp;#8211; so clever)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ha!  There was a time when it didn&apos;t &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12913647" author="mikemccand" created="Wed, 22 Sep 2010 17:24:51 +0100"  >&lt;blockquote&gt;&lt;p&gt;My motivation is for supporting the supportMissingLast feature in solr sorting (that could now be pushed to lucene).&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;If folks think that being able to tell a real &quot;0&quot; from a missing value is not useful for Lucene, we&lt;br/&gt;
could extend Ryan&apos;s CacheConfig to include a factory method that creates / populates ByteValues, IntValues, etc.&lt;br/&gt;
Then all the bitset stuff could be kept in Solr only.  I&apos;m sensitive about pushing stuff into Lucene that is &lt;b&gt;only&lt;/b&gt; useful for Solr.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m very much +1 for making this (exposing thea valid bitset) possible&lt;br/&gt;
in Lucene.&lt;/p&gt;

&lt;p&gt;Users have asked over time how they can tell if a given doc has a field value.&lt;/p&gt;

&lt;p&gt;And being able to distinguish missing values, eg to sort them last, or&lt;br/&gt;
to do something else, is useful.  Once we do this we should also&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;eventually&amp;#93;&lt;/span&gt; move &quot;sort missing last&quot; capability into Lucene&apos;s&lt;br/&gt;
comparators.&lt;/p&gt;</comment>
                    <comment id="12913659" author="thetaphi" created="Wed, 22 Sep 2010 17:47:55 +0100"  >&lt;p&gt;I am also strongly +1 for the additional Bits interface (as Ryan did, it does not always need to be a real OpenBitSet, so when no deletions and all things set, we can use a dummy one).&lt;br/&gt;
I had often use cases where i needed the information, if this document really has a value set or not, and i don&apos;t use Solr so much.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;And being able to distinguish missing values, eg to sort them last, or&lt;br/&gt;
to do something else, is useful. Once we do this we should also&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;eventually&amp;#93;&lt;/span&gt; move &quot;sort missing last&quot; capability into Lucene&apos;s&lt;br/&gt;
comparators.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think this is the right approach - expecting FC&apos;s valid bits to&lt;br/&gt;
take deletions into account is too much. We have IR.getDeletedDocs&lt;br/&gt;
for this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We don&apos;t need to AND them together, maybe simply wrap the OpenBitset by a custom Bits impl, that ands in the getter? But as deletions are separated in IndexReader and the cache can reuse the cache even when new deletions are added, i think keeping it separate is fine.&lt;/p&gt;

&lt;p&gt;About the whole bit set: Do we really need to couple the Bits interface to the type? Because if you exchange the parser/native type (e.g. parse ints as byte), the valid docs are still the same, only the native type representation is different. So how about we add a getBits(field) method to FieldCache that returns the valid docs. If field was not yet retrieved as a native type it could throw IllegalStateEx, else it would return the Bits interface (globally, but per field, but not per parser/datatype) created during the last FC polulation run? We have then also the possibility to disable the default generation of Bits and do it lazily (which should run faster, as it does not need to parse the values, only enumerate terms and termdocs).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Really, &quot;in general&quot; we need a better way for the query execution path&lt;br/&gt;
to enforce deleted docs. Eg if the FCRF will be AND&apos;d w/ a query&lt;br/&gt;
that&apos;s already excluding del docs then it need not be careful about&lt;br/&gt;
deletions...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thats another thing, but maybe we remove deleted docs completely from query processing and simply apply it like a filter before the collector. Not sure about the implications and performance.&lt;/p&gt;</comment>
                    <comment id="12913672" author="ryantxu" created="Wed, 22 Sep 2010 18:29:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;Hmm... I&apos;d rather make an exception to 3.x, ie, allow the addition of this method to the interface, than confuse the 4.x API, going forward, with 2 classes?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is OK with me.  Would be cleaner and simpler.  (though semantically it does not make sense to me &amp;#8211; why ask the parser what to cache?)&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;&amp;gt;&amp;gt;    This does cache a MatchAllBits even when &apos;cacheValidBits&apos; is false, since that is small (a small class with one int)&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hmm... but if I pass false here, it shouldn&apos;t spend any time allocating the bit set, building it, checking the bit set for &quot;all bits set&quot;, etc.?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well it does not try &lt;b&gt;hard&lt;/b&gt;, only if numDocs==maxDocs, it does not look at anything.  If the cost of caching new MatchAllBits( maxDocs ) isn&apos;t worth occasional win by knowing all the values are valid, then I will remove it.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;So how about we add a getBits(field)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Interesting... i&apos;ll mess for a bit and let you know what I think &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;rather then throwing an exception, that might be a flag, since I could imagin many thigns would use the Bits if they exist and do something else if they dont&lt;/p&gt;



</comment>
                    <comment id="12913675" author="thetaphi" created="Wed, 22 Sep 2010 18:34:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;Hmm... I&apos;d rather make an exception to 3.x, ie, allow the addition of this method to the interface, than confuse the 4.x API, going forward, with 2 classes?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Same here, we already defined the FieldCache &quot;interface&quot; as subject to change. Mabye we should simply remove it in trunk and only have a class? This interface was never of any use, because you were not able to supply any other field cache implementation (the DEFAULT field is &lt;b&gt;final&lt;/b&gt; because all fields in interfaces are defined as &lt;b&gt;final&lt;/b&gt; by the Java Language Spec.&lt;/p&gt;</comment>
                    <comment id="12913677" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 18:35:27 +0100"  >&lt;p&gt;Regardless of if there is a separate getBits(field), I think we should add/use ByteValues, IntValues, etc.  It&apos;s just so much more extensible going forward.&lt;/p&gt;</comment>
                    <comment id="12913679" author="mikemccand" created="Wed, 22 Sep 2010 18:39:35 +0100"  >&lt;blockquote&gt;&lt;p&gt;Regardless of if there is a separate getBits(field), I think we should add/use ByteValues, IntValues, etc. It&apos;s just so much more extensible going forward.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12913680" author="mikemccand" created="Wed, 22 Sep 2010 18:41:30 +0100"  >&lt;blockquote&gt;&lt;p&gt;So how about we add a getBits(field) method to FieldCache that returns the valid docs. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would be great!&lt;/p&gt;

&lt;p&gt;Assuming we separately cache the valid docs, we could then allow caching &lt;b&gt;only&lt;/b&gt; valid docs, for apps that want to know if a doc has a value but do not need the full array of values RAM resident.&lt;/p&gt;</comment>
                    <comment id="12913685" author="mikemccand" created="Wed, 22 Sep 2010 18:49:20 +0100"  >&lt;blockquote&gt;&lt;p&gt;That is OK with me. Would be cleaner and simpler. (though semantically it does not make sense to me - why ask the parser what to cache?)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah that is weird.  Maybe we rename Parser -&amp;gt; EntryCreator?&lt;/p&gt;</comment>
                    <comment id="12913688" author="thetaphi" created="Wed, 22 Sep 2010 18:52:18 +0100"  >&lt;p&gt;We should also allow the parser to stop iterating term without the strange StopFillCacheException (needed for Numeric fields).&lt;/p&gt;</comment>
                    <comment id="12913695" author="ryantxu" created="Wed, 22 Sep 2010 19:11:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;Regardless of if there is a separate getBits(field), I think we should add/use ByteValues, IntValues, etc. It&apos;s just so much more extensible going forward.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we have a separate getBits( field ) call, should the Bits be added to the XxxValues class?  I suspect not.&lt;/p&gt;

</comment>
                    <comment id="12913698" author="mikemccand" created="Wed, 22 Sep 2010 19:19:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we have a separate getBits( field ) call, should the Bits be added to the XxxValues class? I suspect not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I think it need not be.&lt;/p&gt;

&lt;p&gt;But, EntryCreator still should be able to state that it&apos;d like the bits computed &amp;amp; cached as a side effect?  And, if the bits wasn&apos;t already computed, then they&apos;d be computed on-demand?  (This enables caching only valid bits and not the values array).&lt;/p&gt;

&lt;p&gt;If we do this then we can leave cutover to XXXValues (still a good idea) as a separate issue?&lt;/p&gt;</comment>
                    <comment id="12913699" author="thetaphi" created="Wed, 22 Sep 2010 19:22:20 +0100"  >&lt;p&gt;I think it should be a separate entry in the cache. Only that its only regenerated, if it does not already exist for the field/IR combination. So there are these combinations:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;cache is purged (inititially)&lt;/li&gt;
	&lt;li&gt;user calls getBytes(field) -&amp;gt; bytes[] is filled, also the Bits&lt;/li&gt;
	&lt;li&gt;user calls additionally getInts(field) for some reason -&amp;gt; int[] is filled, but as Bits already exit they dont need to be filled&lt;/li&gt;
	&lt;li&gt;user calls getBits(field) -&amp;gt; returns the pre-filled bits from one of the previous calls&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Alternatively:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Cache is purged (initially)&lt;/li&gt;
	&lt;li&gt;User calls getBits(field), there are no bits available until now, bits are populated from TermEnum/TermDocs, but no byte[] or int[], as not requested&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;With a config option, one could switch automatic polulation of Bits off, so in the first combination, only the last call to getBits() would populate bit set.&lt;/p&gt;

&lt;p&gt;I all cases this is easily possible by having a separate cache with separate population method for the bits. If some method like getBytes() also populates the Bits, it should simply add the created Bits manually to the cache.&lt;/p&gt;

&lt;p&gt;Instead of a global config option, we could simply add a Boolean to the getXxx methods, to tell the cache if it should also populate Bits (if not already done?). The default would maybe false for Lucene, but solr would always pass true.&lt;/p&gt;

&lt;p&gt;Does this sound like a plan?&lt;/p&gt;</comment>
                    <comment id="12913700" author="ryantxu" created="Wed, 22 Sep 2010 19:23:32 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we do this then we can leave cutover to XXXValues (still a good idea) as a separate issue?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m already in deep... I&apos;d like to keep the XxxValues in this patch, and use a different one to bring everything up-to-date with the new API in 3.x/4.x&lt;/p&gt;
</comment>
                    <comment id="12913701" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 19:24:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we have a separate getBits( field ) call, should the Bits be added to the XxxValues class? I suspect not.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Seems a lot easier just to put all the optional stuff on the *Values class - more performant too (and avoid more synchronizing lookups)&lt;/p&gt;</comment>
                    <comment id="12913703" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 19:27:19 +0100"  >&lt;blockquote&gt;&lt;p&gt;I all cases this is easily possible by having a separate cache with separate population method for the bits.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems more complex, and less extensible.  What&apos;s the issue with just putting the bits reference down on CachedArray?&lt;/p&gt;</comment>
                    <comment id="12913709" author="thetaphi" created="Wed, 22 Sep 2010 19:34:38 +0100"  >&lt;p&gt;It&apos;s not more complicated its easier. The Bits are a real separate thing, its just a cache of the information, if values are assigned or not. It does not depend on the data type like byte, int,... Its just separate. And as said before, if somebody requests the same field in different types, it would only have one bits. Also one could request the Bits alone, or could first request a field without bits (using a boolean) and later again with bits, in which case those are lazily loaded&lt;/p&gt;

&lt;p&gt;Th implementation would be simple, similar to the way, how the caches are filled for NumericFields (it adds the values two times to the cache, with the null parser and the real used parser). I this case youl would simply request the bits cache on e.g. the int[] creation, if not availabe, also build the bits in parallel and add to bits cache.&lt;/p&gt;</comment>
                    <comment id="12913710" author="mikemccand" created="Wed, 22 Sep 2010 19:37:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;What&apos;s the issue with just putting the bits reference down on CachedArray?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One risk was added insanity cases, ie you looked up once w/ the bits and later w/o and it double-stores the values array.&lt;/p&gt;

&lt;p&gt;Another gain of separating the bits retrieval is it becomes possible to get only the valid bits (ie, w/o a value array), for apps that just want to know if a given doc had a field.&lt;/p&gt;

&lt;p&gt;But we could probably still achieve these two benefits while using a single class for looking up everything &quot;cached&quot; about a field?  Ie, the CachedArray could return non-null bits but null values?&lt;/p&gt;</comment>
                    <comment id="12913712" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 19:41:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;But we could probably still achieve these two benefits while using a single class for looking up everything &quot;cached&quot; about a field? Ie, the CachedArray could return non-null bits but null values?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly.&lt;br/&gt;
And with NRT and increasing number of segments, the number of synchronized lookups per segment could really start to matter.&lt;/p&gt;</comment>
                    <comment id="12913734" author="ryantxu" created="Wed, 22 Sep 2010 20:33:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;more performant too (and avoid more synchronizing lookups)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was my motivation for putting it all together and using the options as part of the key.  But yes, inconsistent usage will eat up RAM.  That is better then my original fear that inconsistent usage would give you unpredictable results!&lt;/p&gt;

&lt;p&gt;Also, with the current Cache implementaion, we would need to somehow be able to add two cache entries from within Cache.createEntry() &amp;#8211; either rewrite all that or hack in some way to pass the FieldCache to the createEntry method.&lt;/p&gt;

&lt;p&gt;Keeping the values and bits in different cache entries is pretty ugly (especially for the normal case where we want them both all the time)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteValues() {
      (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[])caches.get(&lt;span class=&quot;code-object&quot;&gt;Byte&lt;/span&gt;.TYPE).get(reader, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Entry(field, parser??)),
      (Bits)caches.get(&lt;span class=&quot;code-object&quot;&gt;Byte&lt;/span&gt;.TYPE).get(reader, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Entry(field, parser??)),
    };
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;blockquote&gt;&lt;p&gt;But we could probably still achieve these two benefits while using a single class for looking up everything &quot;cached&quot; about a field? Ie, the CachedArray could return non-null bits but null values?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Brainstorming here...  if Parser -&amp;gt; EnteryCreator and the &apos;EntryCreator.hashCode()&apos; is used as the map key (as it is now)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class EntryCreator &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Serializable {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cacheValidBits() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cacheValues() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The trick would be to use the same &lt;b&gt;key&lt;/b&gt; regardless of what we ask for (values but no bits - bits but no values - bits and values, etc) and then fill up whatever is missing if it is not in the existing cache.&lt;/p&gt;

&lt;p&gt;That might suggest that the &apos;class&apos; could be the key, but setting the cacheValidBits/values would need to get implemented by inheratance, so that is out.&lt;/p&gt;

&lt;p&gt;other ideas?  directions I am not thinking about?&lt;/p&gt;



</comment>
                    <comment id="12913740" author="skeptikos" created="Wed, 22 Sep 2010 20:41:27 +0100"  >&lt;p&gt;I only just waded through this thread, so apologies in advance if this is redundant or off-topic...&lt;/p&gt;

&lt;p&gt;It seems to me that there could and should be a standalone enhancement to FieldCache/FCImpl to support Boolean-valued fields. &lt;/p&gt;

&lt;p&gt;Since there is no native array-of-bits in Java, it could have the signature:&lt;/p&gt;

&lt;p&gt;    BitSet getBits(IndexReader reader, String field, BooleanParser parser)  &lt;span class=&quot;error&quot;&gt;&amp;#91;implementation returning an OpenBitSet for efficiency&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;A pre-supplied BooleanParser implementation StringMatchBooleanParser could map any of one of a set of uncased strings to true, and a default subclass eg. DefaultStringMatchBooleanParser could supply &lt;/p&gt;
{ &quot;T&quot;, &quot;TRUE&quot;, &quot;1&quot;, &quot;Y&quot;, &quot;YES&quot; }
&lt;p&gt; for the set of strings.  So the defaulted and typical case getBits( ir, &quot;field&quot; ) would do what one typically expects of boolean-valued fields.&lt;/p&gt;

&lt;p&gt;With that in place, then couldn&apos;t one simply define a parser that indicates value present for a docID regardless of what the term value is:&lt;/p&gt;

&lt;p&gt;    public static BooleanParser AlwaysReturnTrueBooleanParser = new BooleanParser() { public boolean parseByte(BytesRef term) &lt;/p&gt;
{ return true; }
&lt;p&gt; }&lt;/p&gt;

&lt;p&gt;    BitSet getValueExists(IndexReader reader, String field) &lt;/p&gt;
{
       return  getBits( ir, field, AlwaysReturnTrueBooleanParser );
    }

&lt;p&gt;Then a client (e.g. FieldComparator implementation) interested in ValueExists values could ask for them, and they would be independently cached from whatever other field type cache(s) were requested on that field by the same or different clients.  The only cost would be iterating the Term/docID iterators a second time (as for additional cache variants on the same field) - minor.&lt;/p&gt;

&lt;p&gt;Does this make sense?&lt;/p&gt;</comment>
                    <comment id="12913742" author="yseeley@gmail.com" created="Wed, 22 Sep 2010 20:49:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;The only cost would be iterating the Term/docID iterators a second time&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, that&apos;s major - otherwise I would have already just done that and stored it in a separate cache for Solr&apos;s needs.&lt;/p&gt;</comment>
                    <comment id="12913795" author="skeptikos" created="Wed, 22 Sep 2010 22:13:37 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Actually, that&apos;s major - otherwise I would have already just done that and stored it in a separate cache for Solr&apos;s needs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is the one-time-per-IndexReader-lifecycle cost of multiplying the cache load time by some factor &amp;lt; 2.0 (since the term values don&apos;t need to be decoded), really so terrible that one has to contemplate global state variables, or a constant increase in cache memory, or significant API changes, or the potential for double-allocation (with then an additional 1x cache load time), or increased code complexity, ...?  Even with all the lovely Solr support for parallel pre-warming?&lt;/p&gt;</comment>
                    <comment id="12913857" author="ryantxu" created="Thu, 23 Sep 2010 01:02:20 +0100"  >&lt;p&gt;bq Is the one-time-per-IndexReader-lifecycle cost of multiplying the cache load time by some factor &amp;lt; 2.0 ... really so terrible &lt;/p&gt;

&lt;p&gt;it can be... on a big index just iterating all the terms/docs take a long time.  Try the LukeRequestHandler on an index with a million+ docs!&lt;/p&gt;

&lt;p&gt;-------------&lt;/p&gt;

&lt;p&gt;Here is different variation, it changes &lt;b&gt;lots&lt;/b&gt; but if we are talking about changing Parser from interface to class, then I guess the cat can be out of the bag.&lt;/p&gt;

&lt;p&gt;What about something like: &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;FieldCache.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  ...

  
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class EntryConfig &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Serializable 
  {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Parser getParser() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cacheValidBits() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cacheValues() {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    }
    
    /**
     * The HashCode is used as part of the Cache Key (along with the field name).  
     * To allow multiple calls with different parameters, make sure the hashCode 
     * does not include the specific instance and parameters.
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode()
    {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; EntryConfig.class.hashCode();
    }
  }
  
  
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class CachePopulator 
  {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillValidBits(  CachedArray vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig creator ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillByteValues( CachedArray vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig creator ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    ...
  }

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; CachePopulator getCachePopulator();

...

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues getByteValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig creator )

...

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;The field cache implementation would make sure what you asked for is filled up before passing it back (though i think this has some concurrency issue)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues getByteValues(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException
  {
    ByteValues vals = (ByteValues) caches.get(&lt;span class=&quot;code-object&quot;&gt;Byte&lt;/span&gt;.TYPE).get(reader, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Entry(field, config));
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( vals.values == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; config.cacheValues() ) {
      populator.fillByteValues(vals, reader, field, config);
    }
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( vals.valid == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; config.cacheValidBits() ) {
      populator.fillValidBits(vals, reader, field, config);
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; vals;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Cache would then delegate the creation to the populator:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ByteValues createValue(IndexReader reader, Entry entry, CachePopulator populator) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
      &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field = entry.field;
      EntryConfig config = (EntryConfig)entry.custom;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (config == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; wrapper.getByteValues(reader, field, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; EntryConfig() );
      }
      ByteValues vals = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteValues();
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( config.cacheValues() ) {
        populator.fillByteValues(vals, reader, field, config);
      }
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( config.cacheValidBits() ) {
        populator.fillValidBits(vals, reader, field, config);
      }
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException( &lt;span class=&quot;code-quote&quot;&gt;&quot;the config must cache values and/or bits&quot;&lt;/span&gt; );
      }
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; vals;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The fillByteValues would be the same code as always, but I think the CachedArray should make sure the same parser is used everytime&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void fillByteValues( CachedArray vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException
    {
      ByteParser parser = (ByteParser) config.getParser();
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( parser == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
        parser = FieldCache.DEFAULT_BYTE_PARSER;
      }
      &lt;span class=&quot;code-comment&quot;&gt;// Make sure it is the same parser
&lt;/span&gt;      &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; parserHashCode = parser.hashCode();
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( vals.parserHashCode != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; vals.parserHashCode != parserHashCode ) {
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException( &lt;span class=&quot;code-quote&quot;&gt;&quot;Subsequent calls with different parser!&quot;&lt;/span&gt; );
      }
      vals.parserHashCode = parserHashCode;
     ...
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is different then the current code where asking for the cached values with two different parsers (that return different hashcodes) will make two entries in the cache.&lt;/p&gt;

&lt;p&gt;This approach would let us:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;cache values and bits independently or together&lt;/li&gt;
	&lt;li&gt;subsequent calls with different parameters should behave reasonably&lt;/li&gt;
	&lt;li&gt;If CachePopulator is pluggable/extendable that may make some other issues easier&lt;/li&gt;
	&lt;li&gt;lets us use CachePopulator outside of the cache context (perhaps useful)&lt;/li&gt;
&lt;/ul&gt;



</comment>
                    <comment id="12914044" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 15:28:59 +0100"  >&lt;p&gt;Now we&apos;re talking!&lt;/p&gt;

&lt;p&gt;Q: why aren&apos;t the CachePopulator methods just directly on EntryConfig - was it easier to share implementations that way or something?&lt;/p&gt;

&lt;p&gt;Also:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It doesn&apos;t seem like we need two methods fillValidBits , fillByteValues - shouldn&apos;t it just be one method that looks at the config and fills in the appropriate entries based on cacheValidBits() and cacheValues()?&lt;/li&gt;
	&lt;li&gt;We should allow an implementation to create subclasses of ByteValues, etc...  what about this method:&lt;br/&gt;
   public abstract CachedArray  fillEntry( CachedArray vals, IndexReader reader, String field, EntryConfig creator )&lt;br/&gt;
That way, an existing entry can be filled in (i.e. vals != null) or a new entry can be created.&lt;br/&gt;
Oh, wait, I see further down a &quot;ByteValues createValue()&quot; - if that&apos;s meant to be a method on CachePopulator, I guess it&apos;s all good - my main concern was being able to create subclasses of ByteValues and frields.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Anyway, all that&apos;s off the top of my head - I&apos;m sure you&apos;ve thought about it more at this point.&lt;/p&gt;</comment>
                    <comment id="12914082" author="ryantxu" created="Thu, 23 Sep 2010 17:19:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;Q: why aren&apos;t the CachePopulator methods just directly on EntryConfig - was it easier to share implementations that way or something?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Two reasons (but I can be talked out of it)&lt;br/&gt;
1. this approach separates what you are asking for (bits/values/etc) from how they are actually generated (the &quot;populator&quot;).  Something makes me uncomfortable about the caller asking for Values needing to also know how they are generated.  Seems easy to mess up.  With this approach the &apos;populator&apos; is attached to the field cache, and defines how stuff is read, vs the &apos;EntryConfig&apos; that defines what the user is asking for (particulary since they may change what they are asking for in subsequent calls)&lt;/p&gt;

&lt;p&gt;2. The &apos;populator&apos; is attached to the FieldCache so it has consistent behavior across subsequet calls to getXxxxValues().  Note that with this approach, if you ask the field cache for just the &apos;values&apos; then later want the &apos;bits&apos; it uses the same populator and adds the results to the existing CachedArray value.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;It doesn&apos;t seem like we need two methods fillValidBits , fillByteValues&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The &apos;fillValidBits&apos; just fills up the valid bits w/o actually parsing (or caching) the values.  This is useful when:&lt;br/&gt;
1. you only want the ValidBits, but not the values (Mike seems to want this)&lt;br/&gt;
2. you first ask for just values, then later want the bits.  &lt;/p&gt;

&lt;p&gt;Thinking some more, I think the populator should look like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; class CachePopulator 
  {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; ByteValues   createByteValues(   IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; ShortValues  createShortValues(  IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; IntValues    createIntValues(    IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; FloatValues  createFloatValues(  IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; DoubleValues createDoubleValues( IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillByteValues(   ByteValues   vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillShortValues(  ShortValues  vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillIntValues(    IntValues    vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillFloatValues(  FloatValues  vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillDoubleValues( DoubleValues vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;

    &lt;span class=&quot;code-comment&quot;&gt;// This will only fill in the ValidBits w/o parsing any actual values
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void fillValidBits( CachedArray  vals, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The default &apos;create&apos; implementation could look something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ShortValues createShortValues( IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryConfig config ) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException 
    {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( config == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
        config = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SimpleEntryConfig();
      }
      ShortValues vals = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ShortValues();
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( config.cacheValues() ) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.fillShortValues(vals, reader, field, config);
      }
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( config.cacheValidBits() ) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.fillValidBits(vals, reader, field, config);
      }
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException( &lt;span class=&quot;code-quote&quot;&gt;&quot;the config must cache values and/or bits&quot;&lt;/span&gt; );
      }
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; vals;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And the Cache &apos;createValue&apos; would looks somethign like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; class ByteCache &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Cache {
    ByteCache(FieldCache wrapper) {
      &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(wrapper);
    }
    
    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ByteValues createValue(IndexReader reader, Entry entry, CachePopulator populator) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
      &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field = entry.field;
      EntryConfig config = (EntryConfig)entry.custom;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (config == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; wrapper.getByteValues(reader, field, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SimpleEntryConfig() );
      }
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; populator.createByteValues(reader, field, config);
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;thoughts?  This would open up lots more of the field cache... so if we go this route, lets make sure it addresses the other issues people have with FieldCache.  IIUC, the other big request is to load the values from an external source &amp;#8211; that should be possible with this approach.&lt;/p&gt;</comment>
                    <comment id="12914089" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 17:29:19 +0100"  >&lt;p&gt;Oh... I mis-matched the parens when I was looking at your proposal (hence the confusion).&lt;/p&gt;

&lt;p&gt;I think getCachePopulator() should be under EntryConfig - that way people can provide their own (and extend ByteValues to include more info)&lt;br/&gt;
Otherwise, we&apos;ll forever be locked into a lowest common denominator of only adding info that everyone can agree on.&lt;/p&gt;</comment>
                    <comment id="12914095" author="ryantxu" created="Thu, 23 Sep 2010 17:43:13 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I think getCachePopulator() should be under EntryConfig - that way people can provide their own (and extend ByteValues to include more info)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you think it is better for &lt;b&gt;each&lt;/b&gt; call to define how the cache works rather then having that as an attribute of the FieldCache (that could be extended).  The on thing that concerns me is that that forces all users of the FieldCache to be in sync.&lt;/p&gt;

&lt;p&gt;In this proposal, you could set the CachePopulator on the FieldCache. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Otherwise, we&apos;ll forever be locked into a lowest common denominator of only adding info that everyone can agree on.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is why I just added the &apos;createXxxxValues&apos; functions on CachePopulator &amp;#8211; a subclass could add other values.&lt;/p&gt;

&lt;p&gt;------------&lt;/p&gt;

&lt;p&gt;It looks like the basic difference between what we are thinking is that the Populator is attached to the FieldCache rather then each call to the FieldCache.  From my point of view, this would make it easier for system with a schema (like solr) have consistent results across all calls, rather then making each request to the FieldCache need to know about the schema -&amp;gt; parsers -&amp;gt; populator&lt;/p&gt;

&lt;p&gt;but I can always be convinced &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12914100" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 18:07:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;In this proposal, you could set the CachePopulator on the FieldCache. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm, OK, as long as it&apos;s possible.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;From my point of view, this would make it easier for system with a schema (like solr) have consistent results across all calls, rather then making each request to the FieldCache need to know about the schema -&amp;gt; parsers -&amp;gt; populator&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this may make it a lot harder from Solr&apos;s point of view.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it&apos;s essentially a static... so it had better not ever be configurable from the schema or solrconfig, or it will break multi-core.&lt;/li&gt;
	&lt;li&gt;if we ever &lt;b&gt;did&lt;/b&gt; want to treat fields differently (load some values from a DB, etc), we&apos;d want to look that up in the schema - but we don&apos;t have a reference to the scema in the populator, and we wouldn&apos;t want to store one there (again, we have multiple schemas).  So... we could essentially create custom EntryConfig object and then our custom CachePopulator could delegate to the entry config  (and we&apos;ve essentially re-invented a way to be able to specify the populator on a per-field basis).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Are EntryConfig objects stored as keys anywhere?   We need to be very careful about memory leaks.&lt;/p&gt;</comment>
                    <comment id="12914109" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 18:19:34 +0100"  >&lt;p&gt;It&apos;s all doable though I guess - even if EntryConfig objects are used as cache keys, we could store a weak reference to the solr core.&lt;br/&gt;
So I say, proceed with what you think will make it easy for Lucene users - and don&apos;t focus on what will be easy for Solr.&lt;/p&gt;</comment>
                    <comment id="12914115" author="ryantxu" created="Thu, 23 Sep 2010 18:37:49 +0100"  >&lt;p&gt;preface, I don&apos;t really know how FieldCache is used, so my assumptions could be way off...&lt;/p&gt;

&lt;p&gt;In solr, is there one FieldCache for all all cores, or does each core get its own FieldCache?  &lt;/p&gt;

&lt;p&gt;I figured each core would create a single CachePopulator (with a reference to the schema) and attach it to the FieldCache.  If that is not possible, then ya, it will be better to put that in the request.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Are EntryConfig objects stored as keys anywhere? We need to be very careful about memory leaks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, the EntryConfig is part of the &apos;Entry&apos; and gets stored as a key.  &lt;/p&gt;</comment>
                    <comment id="12914123" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 18:52:32 +0100"  >&lt;blockquote&gt;&lt;p&gt;In solr, is there one FieldCache for all all cores, or does each core get its own FieldCache? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There is a single FieldCache for all cores (same as in Lucene).&lt;/p&gt;</comment>
                    <comment id="12914136" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 19:10:23 +0100"  >&lt;p&gt;Passing it in would also allow a way to get rid of the StopFillCacheException hack for NumericField in the future.&lt;/p&gt;</comment>
                    <comment id="12914163" author="ryantxu" created="Thu, 23 Sep 2010 19:55:19 +0100"  >&lt;p&gt;Ok, as I look more, I think it may be worth some even bigger changes!  &lt;/p&gt;

&lt;p&gt;Is there any advantage to having a different map for each Type?  The double (and triple) cache can get a bit crazy and lead to so much duplication&lt;/p&gt;

&lt;p&gt;What about moving to a FieldCache that is centered around the very basic API:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T get(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, EntryCreator&amp;lt;T&amp;gt; creator)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Entry creator would be something like&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class EntryCreator&amp;lt;T&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Serializable 
  {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; T create( IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field );
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; void validate( T entry, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field );
    
    /**
     * NOTE: the hashCode is used as part of the cache Key, so make sure it 
     * only changes &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; you want different entries &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the same field
     */
    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode()
    {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; EntryCreator.class.hashCode();
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We could add all the utility functions that cast stuff to ByteValues etc.  We would also make sure that the Map does not use the EntryCreator as a key, but uses it to generate a key.&lt;/p&gt;

&lt;p&gt;A sample EntryCreator would look like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

class BytesEntryCreator &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; FieldCache.EntryCreator&amp;lt;ByteValues&amp;gt; {

  @Override
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; ByteValues create(IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field) 
  {
    &lt;span class=&quot;code-comment&quot;&gt;// all the normal walking stuff using whatever parameters we have specified
&lt;/span&gt;  }

  @Override
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void validate(ByteValues entry, IndexReader reader, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field) 
  {
    &lt;span class=&quot;code-comment&quot;&gt;// all the normal walking stuff using whatever parameters we have specified
&lt;/span&gt;  }  
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thoughts on this approach?  &lt;/p&gt;


&lt;p&gt;Crazy how a seemingly simple issue just explodes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12914169" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 20:05:29 +0100"  >&lt;p&gt;Hmmm, that would also seem to transform the FieldCache into a more generic index reader cache - not a bad idea!&lt;/p&gt;</comment>
                    <comment id="12914175" author="thetaphi" created="Thu, 23 Sep 2010 20:16:13 +0100"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Maybe we should also look at CSF again and what Simon did (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2186&quot; title=&quot;First cut at column-stride fields (index values storage)&quot;&gt;&lt;del&gt;LUCENE-2186&lt;/del&gt;&lt;/a&gt;). In my opinion, the field cache&apos;s public API should not look different from CSF, so one can simply also sort against a CSF.&lt;/p&gt;

&lt;p&gt;I know, some people here will hurt me if I suggest to remove tha native arrays and instead provide getter methods like in the ValueSource approach. The native arrays are unflexible and Java 6 will hopefully optimize away the additional method call (at least I have seen no speed penalty when trying with CSF&apos;s getter API). Cool things could be done like materializing the FieldCache to disk using mmap by e.g. FileChannel.map(...).order(ByteOrder.BIG_ENDIAN).asFloatBuffer() which is then accessible using get(docId). I tested this and works very fine for sorting in Lucene! Java uses internally source code specialization to return different classes depending on native byte order that access the underlying ByteBuffer directly (not manually combining 4 bytes into a float). So the get(docId) call is only bounds checks and &lt;b&gt;one&lt;/b&gt; mmaped memory access.&lt;/p&gt;</comment>
                    <comment id="12914177" author="ryantxu" created="Thu, 23 Sep 2010 20:17:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;Hmmm, that would also seem to transform the FieldCache into a more generic index reader cache - not a bad idea! &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But is it a good one?!  This would let the FieldCache just focus on the synchronized cache mechenism, and the each EntryCreator would need to do its own Parsing etc&lt;/p&gt;


&lt;p&gt;Anyone know what the deal is with IndexReader:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /** Expert */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; getCoreCacheKey() {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                    <comment id="12914178" author="thetaphi" created="Thu, 23 Sep 2010 20:22:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;Anyone know what the deal is with IndexReader:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is to share the cache for clones of IndexReaders or when SegmentReaders are reopended with different deleted docs. In this case the underlying Reader is the same, so it should use its cache (e.g. when deleted docs are added, you dont need to invalidate the cache).&lt;/p&gt;

&lt;p&gt;For more info, ask Mike McCandless!&lt;/p&gt;</comment>
                    <comment id="12914179" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 20:23:02 +0100"  >&lt;p&gt;Uwe, I think we need to keep the native arrays.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Java 6 will hopefully optimize away the additional method call&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It only does if you have &lt;b&gt;one&lt;/b&gt; implementation at the point where it is used.  We just got done specializing the ord sorting code with native arrays because of this - the speed hit was really non-trivial, and it happened with the latest versions of all of the JVMs I tested (oracle 1.6, oracle 1.7, ibm 1.6).  I see no relief for this issue on the horizon.&lt;/p&gt;</comment>
                    <comment id="12914184" author="ryantxu" created="Thu, 23 Sep 2010 20:34:54 +0100"  >&lt;blockquote&gt;&lt;p&gt;remove tha native arrays and instead provide getter methods like in the ValueSource approach&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What would this look like?  Are you suggesting rather then having:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class ByteValues {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] values;
};
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;we have:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class ByteValues {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt; getValue( &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc )
};
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or are you suggesting like DocValues that has, intVal, longVal, floatVal, even though only one &lt;b&gt;really&lt;/b&gt; makes sense?&lt;/p&gt;

&lt;p&gt;Is this something that wold need the proposed FieldCache API to change?  or could it be implemented via EntryCreator?&lt;/p&gt;

&lt;p&gt;If we like the more general cache, that probably needs its own issue (wow scope creep!)&lt;/p&gt;






</comment>
                    <comment id="12914185" author="thetaphi" created="Thu, 23 Sep 2010 20:35:29 +0100"  >&lt;p&gt;Yonik: I was expecting this answer...&lt;/p&gt;

&lt;p&gt;The reason is that my current contact (it&apos;s also your&apos;s) has exactly that problem also with norms (but also FC), that they want to lazily load values for sorting/norms (see the very old issue &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-505&quot; title=&quot;MultiReader.norm() takes up too much memory: norms byte[] should be made into an Object&quot;&gt;&lt;del&gt;LUCENE-505&lt;/del&gt;&lt;/a&gt;). At least we should have a TopFieldDocCollector that can alternatively to native arrays also use a ValueSource-like aproach with getter methods - so you could sort against a CSF. Even if it is 20% slower, in some cases thats the only way to get a suitable search experience. Not always speed is the most important thing, sometimes also space requirements or warmup times. I would have no problem with providing both and chosing the implementation that is most speed-effective. So if no native arrays are provided by the FieldCache use getter methods.&lt;/p&gt;</comment>
                    <comment id="12914188" author="mikemccand" created="Thu, 23 Sep 2010 20:40:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;I see no relief for this issue on the horizon.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We need to specialize the code... either manually or automatically...&lt;/p&gt;</comment>
                    <comment id="12914191" author="yseeley@gmail.com" created="Thu, 23 Sep 2010 20:43:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we like the more general cache, that probably needs its own issue&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct - with a more general fieldCache, one could implement alternatives that MMAP files, etc.  But those alternative implementations certainly should not be included in this issue.&lt;/p&gt;</comment>
                    <comment id="12914194" author="thetaphi" created="Thu, 23 Sep 2010 20:48:43 +0100"  >&lt;p&gt;I just wanted to mention that, so the design of the new FC is more flexible in that case. I am just pissed of because of these arrays and no flexibility &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The FC impl should be in line with the CSF aproach from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2186&quot; title=&quot;First cut at column-stride fields (index values storage)&quot;&gt;&lt;del&gt;LUCENE-2186&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12914398" author="mikemccand" created="Fri, 24 Sep 2010 11:10:34 +0100"  >&lt;p&gt;I like where this all is going!!  We can finally fix FC!!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In my opinion, the field cache&apos;s public API should not look different from CSF, so one can simply also sort against a CSF.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;From the consumption standpoint, they (FC and CSF) really ought to be&lt;br/&gt;
one and the same.&lt;/p&gt;

&lt;p&gt;What&apos;s &quot;unique&quot; about FieldCache is that it derives its values via&lt;br/&gt;
uninversion... this is nice because there&apos;s no index change, but it&apos;s&lt;br/&gt;
slow at reader open time.  It&apos;s also error-proned (you may hit&lt;br/&gt;
multiple values per doc, these values may have gone through analysis,&lt;br/&gt;
etc.)&lt;/p&gt;

&lt;p&gt;CSF, instead, actually computes the values during indexing and stores&lt;br/&gt;
the raw, pre-computed array, in the index.&lt;/p&gt;

&lt;p&gt;They are both just different sources for the same thing.&lt;/p&gt;

&lt;p&gt;Also, an app should be free to plugin its own external source, and it&lt;br/&gt;
should present this same &quot;values source&quot; API.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Uwe, I think we need to keep the native arrays.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the API should allow for optional retrieval of the backing&lt;br/&gt;
array (and we should &lt;span class=&quot;error&quot;&gt;&amp;#91;manually, for today&amp;#93;&lt;/span&gt; specialize the sort&lt;br/&gt;
comparators), but primary access should be a method call eg&lt;br/&gt;
ByteValues.getValue(int docID).&lt;/p&gt;</comment>
                    <comment id="12914508" author="thetaphi" created="Fri, 24 Sep 2010 16:56:54 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Uwe, I think we need to keep the native arrays.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the API should allow for optional retrieval of the backing&lt;br/&gt;
array (and we should &lt;span class=&quot;error&quot;&gt;&amp;#91;manually, for today&amp;#93;&lt;/span&gt; specialize the sort&lt;br/&gt;
comparators), but primary access should be a method call eg&lt;br/&gt;
ByteValues.getValue(int docID).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly. Maybe do it like with NIO buffers: they have methods hasArray(), array() and arrayOffset(), the two last ones throw UnsupportedOp, if first is false. We already have quite a lot TopFieldDocCollectors impls as inner classes, a few more choosen by hasArray()... haha &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12914515" author="yseeley@gmail.com" created="Fri, 24 Sep 2010 17:21:29 +0100"  >&lt;p&gt;It feels like incremental improvement keeps being held hostage...&lt;br/&gt;
Can&apos;t we first just allow the retrieval of ByteValues, etc, that also have Bits on it?&lt;br/&gt;
Changing everything to go through getValue() should be a separate issue (and CSF isn&apos;t even finalized/committed yet).&lt;/p&gt;</comment>
                    <comment id="12914551" author="ryantxu" created="Fri, 24 Sep 2010 18:28:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can&apos;t we first just allow the retrieval of ByteValues, etc, that also have Bits on it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I sure &lt;b&gt;hope&lt;/b&gt; so... otherwise, I doubt anything will move forward.  &lt;/p&gt;

&lt;p&gt;My hope with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;, is to fix the basic problem &amp;#8211; in a way that does not close the door to the improvements we want to make in the future.  I think/hope we are close.  &lt;/p&gt;

&lt;p&gt;If I&apos;m missing something let me know, so I can stop wasting my time.&lt;/p&gt;

&lt;p&gt;(I don&apos;t even know what CSF is, and do not want to learn right now)&lt;/p&gt;</comment>
                    <comment id="12914861" author="ryantxu" created="Sat, 25 Sep 2010 20:10:11 +0100"  >&lt;p&gt;Here is a new patch that incorporates most of the ideas we have discussed.  I tried addressing the larger issue of the FieldCache mess in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;, but that is too big to tackle in one go.  After getting something to &lt;b&gt;almost&lt;/b&gt; work for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;, I then just took the EntryCreator stuff and am adding that to &apos;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2649&quot; title=&quot;FieldCache should include a BitSet for matching docs&quot;&gt;&lt;del&gt;LUCENE-2649&lt;/del&gt;&lt;/a&gt;&apos;&lt;/p&gt;

&lt;p&gt;As such, some of the choices about how EntryCreator works are based on future plans, and my feel akward today.  Speciffically:&lt;/p&gt;

&lt;p&gt;1. In the future, a Cache on the IndexReader should not necessarily be tied to a field name.  To do this, the field name parameter should be part of the EntryCreator.  In this first pass, we will need to pass the field name twice:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
IntValues  vals = cache.getInts(reader, &lt;span class=&quot;code-quote&quot;&gt;&quot;fieldName&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IntValuesCreator( &lt;span class=&quot;code-quote&quot;&gt;&quot;fieldName&quot;&lt;/span&gt;, parser, flags ) )
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I think the tradeoff is OK, and makes fewer changes in the future.&lt;/p&gt;

&lt;p&gt;2. In the future, the EntryCreator.getCacheKey() should be the only key stored.  To fall within the existing structure, the entire EntryCreator is stored on the &apos;custom&apos; field on the internal cache, but the equals and hashCode values are bubbled up.  This makes more sense for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;.  For now we need to be careful that the EntryCreator classes are reasonable things to store as Keys (it includes the Parser, etc)&lt;/p&gt;

&lt;p&gt;-----------------------------&lt;/p&gt;

&lt;p&gt;I added a bunch of tests to exercise how sequential calls with different options behave.&lt;/p&gt;

&lt;p&gt;I think this patch is ready to commit to /trunk &amp;#8211; when it is in, I&apos;ll make a patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since /trunk is now a bit more experimental, and I feel pretty good about the feedback this has had I will probably jump the gun and commit soon&lt;/p&gt;</comment>
                    <comment id="12914959" author="mikemccand" created="Sun, 26 Sep 2010 11:49:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;Apologies for &apos;CTR&apos; rather then &apos;RTC&apos; &amp;#8211; we can always revert if I jumped the gun!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Better to ask forgiveness than permission &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;In fact I&apos;m +1 on switching Lucene&apos;s trunk to CTR model instead, now&lt;br/&gt;
that we have 3.x as the stable branch.  We have enough &quot;policemen&quot;&lt;br/&gt;
around here that I think this&apos;d work well.&lt;/p&gt;

&lt;p&gt;The changes look great Ryan &amp;#8211; nice work!&lt;/p&gt;

&lt;p&gt;Some smallish feedback:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I see some windows eol&apos;s snuck in... can you change the&lt;br/&gt;
    svn:eol-style of all the new sources to &quot;native&quot;?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Some classes are missing copyright header (at least EntryKey,&lt;br/&gt;
    SimpleEntryKey)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Shouldn&apos;t we only incr .numDocs if the bit wasn&apos;t already set?&lt;br/&gt;
    (To be robust if docs have more than one value).  Ie we can use&lt;br/&gt;
    OpenBits.getAndSet.  Maybe then add and assert that numDoc &amp;lt;=&lt;br/&gt;
    maxDoc in the end...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Then, we can pass null for the delDocs to the enums, and then we&lt;br/&gt;
    don&apos;t need a 2nd pass to detect matchAllDocs (just test if&lt;br/&gt;
    .numDocs == maxDoc())?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think we should hold off on backport to 3.x until we stabilize&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;It looks like you&apos;ve also fixed &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2527&quot; title=&quot;FieldCache.getTermsIndex should cache fasterButMoreRAM=true|false to the same cache key&quot;&gt;LUCENE-2527&lt;/a&gt; with this?  Ie the&lt;br/&gt;
fasterButMoreRAM=true|false now cache to the same key?  It&apos;s just that&lt;br/&gt;
perhaps we should &quot;upgrade&quot; the entry, if it was first created w/&lt;br/&gt;
false and then the current call passes true?&lt;/p&gt;</comment>
                    <comment id="12914960" author="mikemccand" created="Sun, 26 Sep 2010 12:01:52 +0100"  >&lt;p&gt;I think we have a synchronization issue on the call to validate?  Ie, more than 1 thread can enter validate, and eg compute the valid bits (if they weren&apos;t computed on the first create())?&lt;/p&gt;</comment>
                    <comment id="12914973" author="yseeley@gmail.com" created="Sun, 26 Sep 2010 14:30:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s just that perhaps we should &quot;upgrade&quot; the entry, if it was first created w/false and then the current call passes true?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We just need to watch the thread safety of stuff like this.&lt;br/&gt;
For Bits, it should be trivial... if you didn&apos;t ask for bits, you shouldn&apos;t be looking at it.&lt;br/&gt;
fasterButMoreRAM is different... upgrading an existing entry could be tricky.&lt;/p&gt;</comment>
                    <comment id="12914989" author="mikemccand" created="Sun, 26 Sep 2010 17:08:12 +0100"  >&lt;blockquote&gt;
&lt;p&gt;We just need to watch the thread safety of stuff like this.&lt;br/&gt;
For Bits, it should be trivial... if you didn&apos;t ask for bits, you shouldn&apos;t be looking at it.&lt;br/&gt;
fasterButMoreRAM is different... upgrading an existing entry could be tricky.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And, also, we need to decide the policy.  Ie I think it&apos;s best if whoever gets there first, wins, for this case.  Ie we should not in fact upgrade to fasterButMoreRAM if the existing entry isn&apos;t...&lt;/p&gt;</comment>
                    <comment id="12915039" author="ryantxu" created="Sun, 26 Sep 2010 22:17:05 +0100"  >&lt;p&gt;Thanks Mike, I&apos;ll take a look and fix the small issues later tonight.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think we should hold off on backport to 3.x until we stabilize &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2665&quot; title=&quot;Rework FieldCache to be more flexible/general&quot;&gt;&lt;del&gt;LUCENE-2665&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1, I think it makes sense to backport to 3.x when there is a clear upgrade path.  &lt;/p&gt;



&lt;blockquote&gt;&lt;p&gt;I think we have a synchronization issue on the call to validate?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Looks like it.  There are two approaches we could take.  &lt;/p&gt;

&lt;p&gt;1. synchronize from the cache:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( key.creator.shouldValidate() ) {
        &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;( key ) {
          key.creator.validate( (T)value, reader);
        }
      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2. make each creator responcible for validation.  For example, the DoubleValuesEntryCreator would look like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

  @Override
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; DoubleValues validate(DoubleValues entry, IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; ok = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( hasOption(OPTION_CACHE_VALUES) ) {
      ok = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( entry.values == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
        &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;( &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; ) {
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( entry.values == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
            fillDoubleValues(entry, reader, field);
          }
        }
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( hasOption(OPTION_CACHE_BITS) ) {
      ok = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( entry.valid == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
        &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;( &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; ) {
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( entry.valid == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ) {
            fillValidBits(entry, reader, field);
          }
        }
      }
    }
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;( !ok ) {
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException( &lt;span class=&quot;code-quote&quot;&gt;&quot;the config must cache values and/or bits&quot;&lt;/span&gt; );
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; entry;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That is a bit more complicated, but avoids synchonization when things are valid.  Thoughts?&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;I think it&apos;s best if whoever gets there first, wins, for this case&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, this is the current behavior &amp;#8211; the validate method does not do anything:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; T validate(T entry, IndexReader reader) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-comment&quot;&gt;// TODO? nothing? perhaps subsequent call with FASTER_BUT_MORE_RAM?
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; entry;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;- - - - - - -&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The other key behavior that we should note is that with CachedArrayEntryCreators, if you pass a different parser for the same field, it will give you an error.  Previously this created two cache entries (and then added something to the insanity log).  If someone wants to do that, they could override the XxxEntryCreator.getCacheKey() to return key that includes the Parser.  By default this seems like an error to me.&lt;/p&gt;


</comment>
                    <comment id="12915072" author="yseeley@gmail.com" created="Mon, 27 Sep 2010 00:21:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;if you pass a different parser for the same field, it will give you an error.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If that were true, it would have broken solr in multiple places.  It may not be ideal - but it&apos;s not an error.&lt;br/&gt;
So I&apos;m a little confused - why does solr still work fine?&lt;/p&gt;</comment>
                    <comment id="12915074" author="ryantxu" created="Mon, 27 Sep 2010 00:33:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;If that were true, it would have broken solr in multiple places&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What is an example?  The only thing I have seen is stuff that tries one parser and if it throws an exception, tries another (that is supported)&lt;/p&gt;

&lt;p&gt;As is, the cached value keeps the hash code for the parser created the values.  If we validate (true by default) then it checks that the passed in hash code matches the one that is stored.  Perhaps different Parsers are returning the same hashCode?    &lt;/p&gt;

&lt;p&gt;Does it make sense to create a different key depending on what Parser we use?  Is it normal to interpret the same field multiple different ways?&lt;/p&gt;</comment>
                    <comment id="12915077" author="yseeley@gmail.com" created="Mon, 27 Sep 2010 00:47:14 +0100"  >&lt;blockquote&gt;&lt;p&gt;What is an example?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Facet component, query elevation component, stats component, and sorting.&lt;br/&gt;
For example, if you facet on the popularity field, it will currently use strings - but if you sort on the popularity field, it will ask the FieldCache for ints.&lt;/p&gt;

&lt;p&gt;But all of these instances in Solr involve treating the same field as both a string and as a number - perhaps you actually need to ask for numbers, but with different parsers, to trigger the exception?&lt;/p&gt;
</comment>
                    <comment id="12915080" author="ryantxu" created="Mon, 27 Sep 2010 00:59:25 +0100"  >&lt;p&gt;Ok, that makes sense &amp;#8211; what I mean is that you can not ask for the same &lt;b&gt;type&lt;/b&gt; with different parsers.  Bytes, vs Strings, vs Ints all have different keys and within the FieldCache, they are even stored in different Maps&lt;/p&gt;

&lt;p&gt;What you can not do is as for a IntValues using: FieldCache.DEFAULT_INT_PARSER, then switch to FieldCache.NUMERIC_UTILS_INT_PARSER for the same field.&lt;/p&gt;

&lt;p&gt;make sense?&lt;/p&gt;</comment>
                    <comment id="12915084" author="yseeley@gmail.com" created="Mon, 27 Sep 2010 01:32:48 +0100"  >&lt;blockquote&gt;&lt;p&gt;Ok, that makes sense - what I mean is that you can not ask for the same type with different parsers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yep, seems fine since people can work around it if they need to.&lt;/p&gt;</comment>
                    <comment id="12915106" author="thetaphi" created="Mon, 27 Sep 2010 04:46:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;What you can not do is as for a IntValues using: FieldCache.DEFAULT_INT_PARSER, then switch to FieldCache.NUMERIC_UTILS_INT_PARSER for the same field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Just to note, my previous FieldCache impl did this correctly. When you requested a FieldCache without parser it created the parser=null entry and additionally the real used parser as two separate entries. When you later use directly (instead of automatics) passing in the trie parser, it returns the additionally created entry in the cache. If you request using another parser, it creates a new entry. So i was (theoretically) possible to parse the same field as int or long and additionally as trie or plain number (but the latter throwed of couse some NFE), so not really useful.&lt;/p&gt;</comment>
                    <comment id="12932242" author="yseeley@gmail.com" created="Mon, 15 Nov 2010 22:42:41 +0000"  >&lt;p&gt;Prompted by Robert&apos;s pointer to non-thread-safety of parser changing in numeric classes, I did a quick review of IntValuesCreator.  It isn&apos;t thread safe if you don&apos;t specify a parser yourself and let it auto-detect, but I&apos;ll leave that part for another time.&lt;/p&gt;

&lt;p&gt;I was going to point out that using deletedDocs when enumerating docs is probably a waste, since all readers that only differ by deletedDocs (generated by reopen, etc) will share the same cache entry.  But then I realized that this is perhaps a bug - not just in this issue, but in all FieldCache implementations since we went away from using &quot;reader&quot; as the key?&lt;/p&gt;


&lt;p&gt;Other stuff we can do:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;use fastSet (as uwe said)&lt;/li&gt;
	&lt;li&gt;use bulk API&lt;/li&gt;
	&lt;li&gt;we instantiate vals.values lazily for some reason... and then at the end, if it still hasn&apos;t been instantiated, we do it anyway?&lt;/li&gt;
	&lt;li&gt;I&apos;m still trying to grok the logic of calling checkMatchAllBits only if vals.valid == null... seems like it will always return null in that case?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12968451" author="yseeley@gmail.com" created="Mon, 6 Dec 2010 22:20:55 +0000"  >&lt;p&gt;For the sort-missing-last type of functionality, the current comparator code looks like this (see IntComparator for more context):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; v2 = (checkMissing &amp;amp;&amp;amp; !cached.valid.get(doc)) 
   ? missingValue : cached.values[doc];
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And I was thinking of changing it to this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; v2 = cached.values[doc];
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (valid != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; v2==0 &amp;amp;&amp;amp; !valid.get(doc))
  v2 = missingValue;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This should make the common case faster by both eliminating an unneeded variable (checkMissing)&lt;br/&gt;
and checking that the value is the Java default value before checking the bitset.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12968458" author="ryantxu" created="Mon, 6 Dec 2010 22:36:10 +0000"  >&lt;p&gt;looks good to me&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;we instantiate vals.values lazily for some reason... and then at the end, if it still hasn&apos;t been instantiated, we do it anyway?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know about this, I just copied from the existing code...  &lt;/p&gt;

&lt;p&gt;We could make the case where Bits.MatchNoBits( maxDoc ), have a null array.  This would make your proposed change invalid though since it checks the array first.&lt;/p&gt;


&lt;blockquote&gt;&lt;p&gt;I&apos;m still trying to grok the logic of calling checkMatchAllBits only if vals.valid == null... seems like it will always return null in that case?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The assumption is that once vals.valid is set, it should not be recalculated.&lt;/p&gt;

&lt;p&gt;The reasons for the if vals.valie == null in the validate function are:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;the vals.valid Bits may have been set in fillXXValues&lt;/li&gt;
	&lt;li&gt;the first call may have excluded checkMatchAllBits, and  a subsequet call has it set&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Are you asking about in the validate function?  If so, fillXXXValues can set the vals.valid, so it does not do it again.  &lt;/p&gt;</comment>
                    <comment id="12969364" author="yseeley@gmail.com" created="Wed, 8 Dec 2010 16:29:33 +0000"  >&lt;blockquote&gt;&lt;p&gt;looks good to me &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Cool - I&apos;ll work up a patch.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The assumption is that once vals.valid is set, it should not be recalculated.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh, tricky.  We should comment that.&lt;/p&gt;

&lt;p&gt;And we can then also change this:&lt;br/&gt;
     OpenBitSet validBits = (hasOption(OPTION_CACHE_BITS)) ? new OpenBitSet( maxDoc ) : null;&lt;br/&gt;
To this: &lt;br/&gt;
    OpenBitSet validBits = (hasOption(OPTION_CACHE_BITS) &amp;amp;&amp;amp; valid.vals==null) ? new OpenBitSet( maxDoc ) : null;&lt;/p&gt;</comment>
                    <comment id="12969382" author="yseeley@gmail.com" created="Wed, 8 Dec 2010 17:16:44 +0000"  >&lt;p&gt;Here&apos;s a draft patch.&lt;br/&gt;
edit: move to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2671&quot; title=&quot;Add sort missing first/last ability to SortField and ValueComparator&quot;&gt;&lt;del&gt;LUCENE-2671&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13011393" author="ryantxu" created="Fri, 25 Mar 2011 19:48:13 +0000"  >&lt;p&gt;This has been done for a while... any problems should now get their own issue&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12474983">LUCENE-2665</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12523855">LUCENE-3443</issuekey>
        </issuelink>
                    </outwardlinks>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12519669">LUCENE-3390</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12444498">LUCENE-2186</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12455573" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="118926" author="ryantxu" created="Sat, 25 Sep 2010 20:10:11 +0100" />
                    <attachment id="12455275" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="42831" author="ryantxu" created="Wed, 22 Sep 2010 16:36:35 +0100" />
                    <attachment id="12455239" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="38868" author="ryantxu" created="Wed, 22 Sep 2010 07:36:01 +0100" />
                    <attachment id="12454867" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="25659" author="ryantxu" created="Fri, 17 Sep 2010 17:31:54 +0100" />
                    <attachment id="12454827" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="24196" author="ryantxu" created="Fri, 17 Sep 2010 06:20:55 +0100" />
                    <attachment id="12454825" name="LUCENE-2649-FieldCacheWithBitSet.patch" size="28678" author="ryantxu" created="Fri, 17 Sep 2010 05:56:10 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 17 Sep 2010 05:25:10 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11189</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25043</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>