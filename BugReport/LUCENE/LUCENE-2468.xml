<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:18:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2468/LUCENE-2468.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2468] reopen on NRT reader should share readers w/ unchanged segments</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2468</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;A repoen on an NRT reader doesn&apos;t seem to share readers for those segments that are unchanged.&lt;br/&gt;
&lt;a href=&quot;http://search.lucidimagination.com/search/document/9f0335d480d2e637/nrt_and_caching_based_on_indexreader&quot; class=&quot;external-link&quot;&gt;http://search.lucidimagination.com/search/document/9f0335d480d2e637/nrt_and_caching_based_on_indexreader&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12464738">LUCENE-2468</key>
            <summary>reopen on NRT reader should share readers w/ unchanged segments</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Tue, 18 May 2010 01:56:22 +0100</created>
                <updated>Fri, 18 Jun 2010 09:04:07 +0100</updated>
                    <resolved>Wed, 2 Jun 2010 17:03:49 +0100</resolved>
                                            <fixVersion>2.9.3</fixVersion>
                <fixVersion>3.0.2</fixVersion>
                <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>1</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12868471" author="yseeley@gmail.com" created="Tue, 18 May 2010 01:58:12 +0100"  >&lt;p&gt;Attached simple test case demonstrating the issue.&lt;/p&gt;</comment>
                    <comment id="12868571" author="earwin" created="Tue, 18 May 2010 10:33:04 +0100"  >&lt;p&gt;Or, you do it so various caches are preserved across clone()&lt;/p&gt;</comment>
                    <comment id="12868585" author="mikemccand" created="Tue, 18 May 2010 10:55:23 +0100"  >&lt;p&gt;Indeed, right now the newly returned NRT reader will always provide a&lt;br/&gt;
shallow clone for any segments that have not changed vs the previous&lt;br/&gt;
NRT reader.&lt;/p&gt;

&lt;p&gt;FieldCache is unaffected by this (it always keys on the &quot;core&quot;&lt;br/&gt;
readers, getFieldCacheKey, which is the same for shallow clones) &amp;#8211;&lt;br/&gt;
such shallow clones will share the same field cache entry.&lt;/p&gt;

&lt;p&gt;But other caches (CachingWrapperFilter, CachingSpanFilter) don&apos;t use&lt;br/&gt;
this key, and so they&apos;ll now get multiple entries for the shallow&lt;br/&gt;
clones.  So we need to fix that.&lt;/p&gt;

&lt;p&gt;However, when new deletions have arrived, a new shallow clone must be&lt;br/&gt;
created.  In this case the FieldCache entries are shared.&lt;/p&gt;

&lt;p&gt;So, should these other caches share an entry for that clone, or not?&lt;br/&gt;
It&apos;s tempting to do so &amp;#8211; all that&apos;s changed is new docs got deleted,&lt;br/&gt;
and any time these filters are applied for searching, they are AND&apos;d&lt;br/&gt;
with &quot;not deleted&quot;.&lt;/p&gt;

&lt;p&gt;But, this is technically shaky ground, since the new deletions will in&lt;br/&gt;
fact mean some docs that previously passed the filter (bit was set)&lt;br/&gt;
will now have the bit un-set.&lt;/p&gt;

&lt;p&gt;I would lean towards letting the caches share the filter in these&lt;br/&gt;
cases, and advertising in these classes javadocs that this will&lt;br/&gt;
happen.  Thoughts?&lt;/p&gt;</comment>
                    <comment id="12868604" author="earwin" created="Tue, 18 May 2010 11:59:38 +0100"  >&lt;p&gt;Reusing fieldCacheKey is probably a good temporary solution? (possibly renaming it in the process to just cacheKey)&lt;br/&gt;
NRT.reopen() is not the only case when we&apos;re getting shallow clones, IR.clone() explicitly does that, so with cacheKey we&apos;re getting all the bases covered.&lt;/p&gt;</comment>
                    <comment id="12868617" author="kimchy" created="Tue, 18 May 2010 13:17:00 +0100"  >&lt;p&gt;Sounds like a good solution for me. I just noticed in trunk that there is also explicit purge from FieldCache when possible. I think it would be great to enable to do this for other caches that are based on it (like the CachingWrapperFilter, but externally written ones as well).&lt;/p&gt;

&lt;p&gt;I was thinking of an expert API to allow to add a &quot;CacheEvictionListener&quot; or something similar, which will be called when this happens. What do you think?&lt;/p&gt;</comment>
                    <comment id="12868630" author="yseeley@gmail.com" created="Tue, 18 May 2010 13:48:31 +0100"  >&lt;p&gt;bq, I would lean towards letting the caches share the filter in these cases, and advertising in these classes javadocs that this will happen. Thoughts?&lt;/p&gt;

&lt;p&gt;I think that&apos;s prob OK - users won&apos;t notice when using filters to search, but may get different behavior if they use it for other purposes.&lt;/p&gt;

&lt;p&gt;Shay, as far as CachingWrapperFilter and CacheEvictionListener, it seems more powerful to just let apps create a new query type themselves?  That&apos;s the nice part of lucene&apos;s openness to user query types - start with the code for CachingWrapperFilter and hook up your own caching logic.&lt;/p&gt;</comment>
                    <comment id="12868647" author="kimchy" created="Tue, 18 May 2010 14:47:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;Shay, as far as CachingWrapperFilter and CacheEvictionListener, it seems more powerful to just let apps create a new query type themselves? That&apos;s the nice part of lucene&apos;s openness to user query types - start with the code for CachingWrapperFilter and hook up your own caching logic.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yea, but it would be great to know when an IndexReader has decided to actually close, so caches can be eagerly cleaned. Even if one will write a custom implementation, it would benefit it.&lt;/p&gt;</comment>
                    <comment id="12868659" author="kimchy" created="Tue, 18 May 2010 15:31:33 +0100"  >&lt;p&gt;I think that the solution suggested, to use the FieldCacheKey is not good enough, sadly. I am attaching a simpel test that shows that this does not work for cases when a query is passed to a searcher, without a filter, but that query, is, for example, a ConstantScoreQuery. I have simply taken the CachingWrapperFiler and changed it to use the getFieldCacheKey instead of using the IndexReader.&lt;/p&gt;

&lt;p&gt;This is problematic, since a filter can be used somewhere in the query tree, and wrapped for caching. I am running against 3.0.1.&lt;/p&gt;</comment>
                    <comment id="12868660" author="mikemccand" created="Tue, 18 May 2010 15:33:37 +0100"  >&lt;p&gt;Renaming to cacheKey makes me a bit nervous.... since... this key is the same even when deletions change.  How about coreCacheKey?  The javadocs should make it clear that new deletions can show up yet have the identical (==) coreCacheKey.&lt;/p&gt;

&lt;p&gt;OK I&apos;ll take this approach.&lt;/p&gt;</comment>
                    <comment id="12868673" author="mikemccand" created="Tue, 18 May 2010 16:03:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;This is problematic, since a filter can be used somewhere in the query tree, and wrapped for caching&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right so the issue here is that ConstantScoreQuery&apos;s scorer does not check deleted docs when it runs &amp;#8211; it just relies entirely on what the filter said was set.&lt;/p&gt;

&lt;p&gt;But I expect this is the exception not the rule.&lt;/p&gt;

&lt;p&gt;Ie most uses of a filter will see to it that deleted docs are already removed.&lt;/p&gt;

&lt;p&gt;It&apos;s as if, somehow, when a caller wants the scorer or DocIdSet, it should express whether it&apos;s OK that deleted docs are not removed... I think this&apos;d be another boolean arg (mustContainDeletions or some such) to scorer and getDocIdSet.&lt;/p&gt;

&lt;p&gt;Or, for a less invasive change, we could that you tell ConstantScoreQuery that it must fully enforce deletions (if your app runs a query tree that has a path involving ConstantScoreQuery not AND&apos;d with some other query that&apos;d enforce deletions).&lt;/p&gt;</comment>
                    <comment id="12868680" author="kimchy" created="Tue, 18 May 2010 16:25:55 +0100"  >&lt;p&gt;Agreed, seems like ConstantScoreQuery is the only problematic one... .&lt;/p&gt;</comment>
                    <comment id="12868800" author="mikemccand" created="Tue, 18 May 2010 20:30:42 +0100"  >&lt;p&gt;Attached patch &amp;#8211; renames IR.getFieldCacheKey -&amp;gt; IR.getCoreCacheKey, fixes CachingWrapperFilter and CachingSpanFilter to, by default, disregard deletions when checking the cache.  But I added expert ctors to each to force deletions to be &quot;respected&quot; at a perf hit.&lt;/p&gt;</comment>
                    <comment id="12868816" author="kimchy" created="Tue, 18 May 2010 21:25:54 +0100"  >&lt;p&gt;Thanks for the work Michael!. Is this issue going to include the ConstantSoreQuery, or should I open a different issue for this?&lt;/p&gt;</comment>
                    <comment id="12868855" author="mikemccand" created="Tue, 18 May 2010 22:59:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;Is this issue going to include the ConstantSoreQuery, or should I open a different issue for this?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry &amp;#8211; what change is needed to ConstantScoreQuery?&lt;/p&gt;</comment>
                    <comment id="12868869" author="kimchy" created="Tue, 18 May 2010 23:17:46 +0100"  >&lt;p&gt;Check two comments above &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, we discussed it. Basically, it does not work with your change and it using a cached filter.&lt;/p&gt;</comment>
                    <comment id="12868909" author="mikemccand" created="Wed, 19 May 2010 00:46:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;Basically, it does not work with your change and it using a cached filter.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m still confused &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  My patch has your test case (which uses ConstantScoreQuery).  I tweaked the test case a bit, eg to not rely on TermsFilter (which is in contrib).&lt;/p&gt;

&lt;p&gt;The test failed when I first made the change (as expected).&lt;/p&gt;

&lt;p&gt;Then I modified CachingWrapperFilter to take the optional boolean &quot;enforceDeletions&quot;.&lt;/p&gt;

&lt;p&gt;Then I changed the test to pass &quot;true&quot; for enforceDeletions, and the test now passes.&lt;/p&gt;

&lt;p&gt;I don&apos;t think any change is needed to ConstantScoreQuery?  (Ie, I took the &quot;less invasive&quot; option in my comment above).&lt;/p&gt;</comment>
                    <comment id="12868923" author="kimchy" created="Wed, 19 May 2010 01:10:47 +0100"  >&lt;p&gt;Ahh, now I see that, sorry I missed it. But, basically, enforcing deletions means that we are back to the original problem... . I think it would be quite confusing for users, to be honest. Out of the filters, the problematic ones are the ones that can be converted to queries. From what I can see, the FilteredQuery is ok, so, maybe the ConstantScore can be changed (if possible) to do that... .&lt;/p&gt;</comment>
                    <comment id="12868941" author="kimchy" created="Wed, 19 May 2010 01:52:19 +0100"  >&lt;p&gt;Here is a go at making ConstantScoreQuery deletion aware. I named it differently, but it can replace ConstantScoreQuery with a flag making it deletion aware. What do you think?&lt;/p&gt;</comment>
                    <comment id="12868959" author="kimchy" created="Wed, 19 May 2010 03:07:52 +0100"  >&lt;p&gt;Another quick question Mike, what do you think about the ability to know when a &quot;cache key&quot; is actually closed so it can be removed from a cache? Similar in concept to the eviction done from the field cache in trunk by readers, but open so other Reader#cacheKey based caches (which is the simplest way to do caching in Lucene) can use.&lt;/p&gt;</comment>
                    <comment id="12869233" author="mikemccand" created="Wed, 19 May 2010 19:04:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;Here is a go at making ConstantScoreQuery deletion aware. I named it differently, but it can replace ConstantScoreQuery with a flag making it deletion aware. What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we need to fix ConstantScoreQuery to be deletions&lt;br/&gt;
aware?&lt;/p&gt;

&lt;p&gt;With the perf fix we are doing here, the problem (not correctly&lt;br/&gt;
&quot;seeing&quot; deletes on a reopened reader) is isolated to&lt;br/&gt;
CachingWrapperFilter/CachingSpanFilter, right?&lt;/p&gt;

&lt;p&gt;Why fix ConstantScoreQuery, when so many other Filter impls will&lt;br/&gt;
properly apply deletions?&lt;/p&gt;</comment>
                    <comment id="12869235" author="mikemccand" created="Wed, 19 May 2010 19:07:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;Another quick question Mike, what do you think about the ability to know when a &quot;cache key&quot; is actually closed so it can be removed from a cache? Similar in concept to the eviction done from the field cache in trunk by readers, but open so other Reader#cacheKey based caches (which is the simplest way to do caching in Lucene) can use.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this would be a good change &amp;#8211; it would make eviction immediate instead of just when GC gets around to pruning the WeakHashMap.  Can you open a separate issue and maybe work out a patch?&lt;/p&gt;

&lt;p&gt;Or, the other alternative would be to have IR hold such caches, as a service, to &quot;things&quot; that need caching.&lt;/p&gt;</comment>
                    <comment id="12869253" author="kimchy" created="Wed, 19 May 2010 19:31:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;With the perf fix we are doing here, the problem (not correctly&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&quot;seeing&quot; deletes on a reopened reader) is isolated to&lt;br/&gt;
CachingWrapperFilter/CachingSpanFilter, right?&lt;/p&gt;

&lt;p&gt;Yes, but, this means that ConstantScoreQuery should basically not be cached when using NRT (even with using IndexReader as key...), because of the excessive readers created. With the one that is deletion aware, you can cache it based on the cache key.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think this would be a good change - it would make eviction immediate instead of just when GC gets around to pruning the WeakHashMap. Can you open a separate issue and maybe work out a patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure, I will do it.&lt;/p&gt;</comment>
                    <comment id="12869276" author="mikemccand" created="Wed, 19 May 2010 20:19:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;Yes, but, this means that ConstantScoreQuery should basically not be cached when using NRT (even with using IndexReader as key...), because of the excessive readers created. With the one that is deletion aware, you can cache it based on the cache key.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, now (finally) I understand the problem!&lt;/p&gt;

&lt;p&gt;You want to be able to cache the original filter and reuse it even when deletions have changed, but then dynamically apply the deletions so they are properly enforced (rather than discarding the cache entry).&lt;/p&gt;

&lt;p&gt;So... why not do this in CachingWrapper/SpanFilter, but, instead of discarding the cache entry when deletions must be enforced, we dynamically apply the deletions?  (I think we could use FilteredDocIdSet).&lt;/p&gt;

&lt;p&gt;Really... we need a more generic solution here (but, it&apos;s a much bigger change), where somehow in creating the scorer per-segment we dynamically determine who/where the deletions are enforced.  A Filter need not care about deletions if it&apos;s AND&apos;d w/ a query that already enforces the deletions.&lt;/p&gt;</comment>
                    <comment id="12869369" author="kimchy" created="Wed, 19 May 2010 22:47:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;So... why not do this in CachingWrapper/SpanFilter, but, instead of discarding the cache entry when deletions must be enforced, we dynamically apply the deletions? (I think we could use FilteredDocIdSet).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yea, that would work well. You will need to somehow still know when to enable or disable this based on the filter you use (it should basically only be enabled ones that are passed to constant score... .&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Really... we need a more generic solution here (but, it&apos;s a much bigger change), where somehow in creating the scorer per-segment we dynamically determine who/where the deletions are enforced. A Filter need not care about deletions if it&apos;s AND&apos;d w/ a query that already enforces the deletions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed. As I see it, caching based on IndexReader is key in Lucene, and with NRT, it should feel the same way as it is without it. NRT should not change the way you build your system.&lt;/p&gt;</comment>
                    <comment id="12869562" author="mikemccand" created="Thu, 20 May 2010 12:05:07 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;So... why not do this in CachingWrapper/SpanFilter, but, instead of discarding the cache entry when deletions must be enforced, we dynamically apply the deletions? (I think we could use FilteredDocIdSet).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yea, that would work well. You will need to somehow still know when to enable or disable this based on the filter you use (it should basically only be enabled ones that are passed to constant score... &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I&apos;ll take that approach on next iter.&lt;/p&gt;

&lt;p&gt;But: I think this may need to be enabled in other cases where the&lt;br/&gt;
filter is used (ie not only CSQ).  Sure, CSQ is the one example we&lt;br/&gt;
have today, where if you pass a Filter that ignores &quot;recent&quot; deletions&lt;br/&gt;
you&apos;ll be in trouble... but who knows what other uses of a Filter&lt;br/&gt;
might trip up on this intentional cache-incoherence we&apos;re introducing.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Agreed. As I see it, caching based on IndexReader is key in Lucene, and with NRT, it should feel the same way as it is without it. NRT should not change the way you build your system.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... NRT and up-to-date deletions will always present a challenge.&lt;/p&gt;

&lt;p&gt;Really, this tradeoff we are making here, where a cached filter can be&lt;br/&gt;
set to either 1) ignore new deletions, 2) discard its cache entry and&lt;br/&gt;
fully regenerate itself, or 3) dynamically intersect the deletions, is&lt;br/&gt;
similar to the discussions we&apos;ve had about just how an NRT segment&lt;br/&gt;
reader should enforce recent deletions.&lt;/p&gt;

&lt;p&gt;Ie, ignoring option 1 (which of course gives the best perf), option 2,&lt;br/&gt;
while making a reopen more costly, gets you the best search&lt;br/&gt;
performance (since only one bit set is checked during searches).&lt;/p&gt;

&lt;p&gt;Option 3 makes reopens much faster, but then search peformance takes a&lt;br/&gt;
hit (since you&apos;re checking 2 bit sets).&lt;/p&gt;

&lt;p&gt;Option 2 is analogous to how Lucene now handles the per-segment&lt;br/&gt;
deleted docs bit vector (it&apos;s fully recreated on each reopen), while&lt;br/&gt;
option 3 is analogous to how Zoie handles deletions (new deletions are&lt;br/&gt;
dynamically applied to all search hits).&lt;/p&gt;</comment>
                    <comment id="12869779" author="kimchy" created="Thu, 20 May 2010 22:32:01 +0100"  >&lt;p&gt;Hi Mike, &lt;/p&gt;

&lt;p&gt;First, I opened and attached a patch regarding the Cache eviction listeners to IndexReader: &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2474&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-2474&lt;/a&gt;, tell me what you think.&lt;/p&gt;

&lt;p&gt;Regarding your last comment, I agree. Though, trying to streamline its usage in terms of having all built in components and possible extensions work well with it make sense. Thats what you suggest in with the filtered doc set, which is cool.&lt;/p&gt;</comment>
                    <comment id="12870205" author="mikemccand" created="Fri, 21 May 2010 23:37:15 +0100"  >&lt;p&gt;OK, I attached another go at this.&lt;/p&gt;

&lt;p&gt;I added a DeletesMode enum to CachingWrapperFilter: IGNORE (default)&lt;br/&gt;
means just re-use the cache entry when the reader is reopened w/ new&lt;br/&gt;
deletions; RECACHE (fully recreate the cache entry); DYNAMIC (re-use&lt;br/&gt;
the cache entry, but use FilteredDocIdSet to dynamically re-filter it&lt;br/&gt;
against the current deletions).&lt;/p&gt;

&lt;p&gt;I did the same for CachingSpanFilter, but I don&apos;t allow DYNAMIC for&lt;br/&gt;
that one &amp;#8211; I punted on it because it&apos;s kinda hairy (I&apos;d have to copy&lt;br/&gt;
the List&amp;lt;PositionInfo&amp;gt; and remove entries corresponding to deleted&lt;br/&gt;
docs).  IGNORE and RECACHE are allowed.&lt;/p&gt;</comment>
                    <comment id="12873417" author="mikemccand" created="Sun, 30 May 2010 13:32:59 +0100"  >&lt;p&gt;backport&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12444799" name="CacheTest.java" size="5655" author="kimchy" created="Tue, 18 May 2010 15:32:32 +0100" />
                    <attachment id="12444867" name="DeletionAwareConstantScoreQuery.java" size="6245" author="kimchy" created="Wed, 19 May 2010 01:52:18 +0100" />
                    <attachment id="12445218" name="LUCENE-2468.patch" size="28726" author="mikemccand" created="Fri, 21 May 2010 23:37:15 +0100" />
                    <attachment id="12444826" name="LUCENE-2468.patch" size="16122" author="mikemccand" created="Tue, 18 May 2010 20:30:42 +0100" />
                    <attachment id="12444751" name="LUCENE-2468.patch" size="1100" author="yseeley@gmail.com" created="Tue, 18 May 2010 01:58:12 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 18 May 2010 09:33:04 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11351</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25224</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>