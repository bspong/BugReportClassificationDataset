<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:11:29 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2198/LUCENE-2198.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2198] support protected words in Stemming TokenFilters</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2198</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1515&quot; title=&quot;Improved(?) Swedish snowball stemmer&quot;&gt;LUCENE-1515&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I propose that all stemming TokenFilters have an &apos;exclusion set&apos; that bypasses any stemming for words in this set.&lt;br/&gt;
Some stemming tokenfilters have this, some do not.&lt;/p&gt;

&lt;p&gt;This would be one way for Karl to implement his new swedish stemmer (as a text file of ignore words).&lt;br/&gt;
Additionally, it would remove duplication between lucene and solr, as they reimplement snowballfilter since it does not have this functionality.&lt;br/&gt;
Finally, I think this is a pretty common use case, where people want to ignore things like proper nouns in the stemming.&lt;/p&gt;

&lt;p&gt;As an alternative design I considered a case where we generalized this to CharArrayMap (and ignoring words would mean mapping them to themselves), which would also provide a mechanism to override the stemming algorithm. But I think this is too expert, could be its own filter, and the only example of this i can find is in the Dutch stemmer.&lt;/p&gt;

&lt;p&gt;So I think we should just provide ignore with CharArraySet, but if you feel otherwise please comment.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12445051">LUCENE-2198</key>
            <summary>support protected words in Stemming TokenFilters</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Fri, 8 Jan 2010 17:38:11 +0000</created>
                <updated>Fri, 10 May 2013 11:43:00 +0100</updated>
                    <resolved>Wed, 27 Jan 2010 11:19:52 +0000</resolved>
                            <version>3.0</version>
                                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>modules/analysis</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12798388" author="simonw" created="Sat, 9 Jan 2010 18:39:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;So I think we should just provide ignore with CharArraySet, but if you feel otherwise please comment.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;While I read your proposal a possibly more flexible design came to my mind. We could introduce a StemAttribute that has a method public boolean stem() used by every stemmer to decide if a token should be stemmed. That way we decouple the decision if a token should be stemmed from the stemming algorithm. This also enables custom filters to set the values based on other reasons aside from a term being in a set. &lt;br/&gt;
The default value for sure it true but can be set on any condition. inside an analyzer we can add a filter right before the stemmer based on a CharArraySet. Yet if the set is empty or null we simply leave the filter out. &lt;/p&gt;
</comment>
                    <comment id="12799819" author="rcmuir" created="Wed, 13 Jan 2010 16:51:30 +0000"  >&lt;p&gt;hi Simon, the more i think about it, the more i like your design.&lt;/p&gt;

&lt;p&gt;this way, for example, if someone has pos tagging/named entity recognition or a similar sophisticated NLP process, they could change the value of this attribute and prevent these from being stemmed at runtime. with static sets this is not possible.&lt;/p&gt;</comment>
                    <comment id="12799839" author="ehatcher" created="Wed, 13 Jan 2010 17:44:23 +0000"  >&lt;p&gt;+1 on the StemAttribute approach.  I&apos;ve just encountered this exact need in some custom code I&apos;ve been reviewing, where the decision to stem or not is dynamic per term (with the approach I&apos;m looking at using a custom term type string and a custom stem filter).&lt;/p&gt;</comment>
                    <comment id="12799867" author="simonw" created="Wed, 13 Jan 2010 18:49:23 +0000"  >&lt;p&gt;This patch contains an intial design proposal. I tried to name the new attribute a little bit more generic as this could easily be used outside of the stemming domain.&lt;/p&gt;

&lt;p&gt;all tests pass &amp;#8211; comments welcome.&lt;/p&gt;</comment>
                    <comment id="12799873" author="rcmuir" created="Wed, 13 Jan 2010 19:05:37 +0000"  >&lt;p&gt;the patch looks great to me Simon. I especially like the naming.&lt;/p&gt;</comment>
                    <comment id="12801423" author="simonw" created="Sun, 17 Jan 2010 15:44:21 +0000"  >&lt;p&gt;This patch ports all stemmers in core and contrib/analyzers to make use of the KeywordAttribute. &lt;br/&gt;
I did not include snowball yet.&lt;/p&gt;</comment>
                    <comment id="12801426" author="thetaphi" created="Sun, 17 Jan 2010 15:55:20 +0000"  >&lt;p&gt;The KeywordAttribute and *Impl looks correct. copyTo() behaves also correctly (this is important in some cases!).&lt;/p&gt;</comment>
                    <comment id="12801437" author="yseeley@gmail.com" created="Sun, 17 Jan 2010 16:57:17 +0000"  >&lt;p&gt;One random thought is to wonder how much this adds to the cost of  capturing state - and if we should &quot;bundle&quot; this with other (future) binary flags into a word (this is what the original &quot;flags&quot; field on Token was for).&lt;/p&gt;</comment>
                    <comment id="12801438" author="thetaphi" created="Sun, 17 Jan 2010 17:04:30 +0000"  >&lt;p&gt;If we start to discuss about such topics, we should not have used Attributes at all.&lt;/p&gt;

&lt;p&gt;There is no additional cost, because with 3.0, the FlagAttribute is used nowhere, so it is not captured, too. We would just move this to another attribute, the cost is the same. And capturing a boolean costs no much. Because the State object is build internally before and just cloned. So the number of attributes vs. the size of the captured states do not affect performance in neglectible manner.&lt;/p&gt;</comment>
                    <comment id="12801442" author="yseeley@gmail.com" created="Sun, 17 Jan 2010 17:25:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;If we start to discuss about such topics, we should not have used Attributes at all. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Attributes are great for allowing extensions.  But for attributes that often appear together, it seems like we should at least consider bundling them.&lt;br/&gt;
You seem to be implying that we shouldn&apos;t question the cost of doing things one way vs another?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There is no additional cost&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Surely the native clone() invoked for every additional attribute counts for something?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Because the State object is build internally before and just cloned. So the number of attributes vs. the size of the captured states do not affect performance in neglectible manner.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Not sure I understand... if captureState() is invoked, isn&apos;t .clone() called on each attribute?&lt;/p&gt;</comment>
                    <comment id="12801446" author="simonw" created="Sun, 17 Jan 2010 17:35:09 +0000"  >&lt;p&gt;I kind of agree with both of you. When I started implementing this attribute I had FlagAttribute in mind but I didn&apos;t choose it because users can randomly choose a bit of the word which might lead to unexpected behavior. &lt;/p&gt;

&lt;p&gt;Another solution I had in mind is to introduce another Attribute (or extend FlagAttribute) holding a Lucene private (not the java visibility keyword) Enum that can be extended in the future. Internally this could use a word or a Bitset (a word will do I guess) where bits can be set according to the enum ord. That way we could encode way more than only one single boolean and the cost of adding new &quot;flags&quot; / enum values would be minimal.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
booleanAttribute.isSet(BooelanAttributeEnum.Keyword)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;something like that, thoughts?&lt;/p&gt;</comment>
                    <comment id="12801448" author="thetaphi" created="Sun, 17 Jan 2010 17:44:46 +0000"  >&lt;p&gt;My problem with FlagsAttribute is missing &quot;type safety&quot;. You have to choose an bit mask for &quot;your&quot; attribute but another TokenFilter in your streanm could use the same bit mask. So in my opinion, FlagsAttribute should be deprectated and replaced by simple boolean attributes everybody can define type safe.&lt;/p&gt;

&lt;p&gt;About the speed of cloning: Clone was slow in old java versions, but now it is done directly in the JVM. Cloning an Attribute using the following code is much slower than invoking clone() [please note, not because of the reflections, it there to show how it should be implemented):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
AttributeImpl clone = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.getClass().newInstance();
&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.copyTo(clone);
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; clone;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Michi Busch and me are currently investigating fast Attribute Proxies (needed for flex MultiEnums) and also fast capturing of states using CGLIB.&lt;/p&gt;</comment>
                    <comment id="12801450" author="rcmuir" created="Sun, 17 Jan 2010 17:48:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;Surely the native clone() invoked for every additional attribute counts for something?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But it looks to me like only each Attribute*Impl* is cloned, so if you are worried about this and using a lot of attributes you could use your own AttributeFactory, similar to Token.TOKEN_ATTRIBUTE_FACTORY to pack everything however you see fit, right?&lt;/p&gt;

&lt;p&gt;I think the interface as boolean is correct, and I think the reference implementation is correct too.&lt;/p&gt;</comment>
                    <comment id="12801451" author="thetaphi" created="Sun, 17 Jan 2010 17:51:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;Surely the native clone() invoked for every additional attribute counts for something?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;FlagsAttribute is not used anywhere in Lucene. So it does not matter if you have a separate attribute or the FlagsAttribute for cloning in this issue. Only in the case that having multiple boolean attributes in the same stream, there is additional cost. But this is really seldom, so type safety is more important and helps preventing bugs.&lt;/p&gt;

&lt;p&gt;And by the way, you can combine all attributes using a special AttributeFactory into the same AttributeImpl if you need speed (e.g. Token). Then you can have lots of boolean attributes with getters/setters, but all use the same AttributeImpl with the same bitset. If we have more than one boolean attribute in lucene in future, we can extend DEFAULT_ATTRIBUTE_FACTORY to support this.&lt;/p&gt;</comment>
                    <comment id="12801457" author="yseeley@gmail.com" created="Sun, 17 Jan 2010 18:07:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;Only in the case that having multiple boolean attributes in the same stream, there is additional cost. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that&apos;s exactly what I was talking about when I said &quot;if we should &quot;bundle&quot; this with other (future) binary flags&quot;.  No, it doesn&apos;t look like we have any others now, I was talking about if we were going to have any others in the future.&lt;/p&gt;

&lt;p&gt;I also don&apos;t understand the arguments about type safety.  Token bundles multiple attributes together w/o loss of type safety, right?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If we have more than one boolean attribute in lucene in future, we can extend DEFAULT_ATTRIBUTE_FACTORY to support this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, ok - that was really my only concern - the number of clone() calls due to increasing numbers of attributes.&lt;/p&gt;</comment>
                    <comment id="12801734" author="thetaphi" created="Mon, 18 Jan 2010 11:03:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;I also don&apos;t understand the arguments about type safety. Token bundles multiple attributes together w/o loss of type safety, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;With &quot;type safety&quot; I mean, not attributes in general (they are type safe withy any impl). FlagAttribute itsself is not type safe, because everybody can store/update any bit in this integer. If you have two different filters updating the same bit but mean something other with the bit, it gets broken. Maybe other Filters just update the flags using no bit operations (because we have no support for these in the API).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If we have more than one boolean attribute in lucene in future, we can extend DEFAULT_ATTRIBUTE_FACTORY to support this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My idea is to have a default AttributeImpl for boolean attributes that support things like set/get of a bit (like BitSet). You subclass it e.g. to generate a combined impl for 4 boolean interfaces we may have in futrure in Lucene core. In the ctor you pass the bitmasks and the impl of all boolean get/setters delegate to the generic BitSet-like methods. Clone and copyTo it then simple, as it only copies the word if the target AttributeImpl is the same class (like Token.copyTo).&lt;/p&gt;</comment>
                    <comment id="12804536" author="thetaphi" created="Mon, 25 Jan 2010 13:44:58 +0000"  >&lt;p&gt;I take this one and will commit this in a day or two.&lt;/p&gt;

&lt;p&gt;When we get additional boolean attributes, I can open an issue, to provide an &quot;combined&quot; AttributeImpl for them to support heavy cloning.&lt;/p&gt;</comment>
                    <comment id="12805480" author="thetaphi" created="Wed, 27 Jan 2010 11:19:52 +0000"  >&lt;p&gt;Committed revision: 903608&lt;/p&gt;

&lt;p&gt;Thanks Simon!&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                                <inwardlinks description="is depended upon by">
                            <issuelink>
            <issuekey id="12440420">LUCENE-2055</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12430558" name="LUCENE-2198.patch" size="75958" author="simonw" created="Sun, 17 Jan 2010 15:44:21 +0000" />
                    <attachment id="12430162" name="LUCENE-2198.patch" size="15984" author="simonw" created="Wed, 13 Jan 2010 18:49:22 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 9 Jan 2010 18:39:22 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11588</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25527</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>