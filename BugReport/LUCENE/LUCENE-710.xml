<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:07:35 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-710/LUCENE-710.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-710] Implement &quot;point in time&quot; searching without relying on filesystem semantics</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-710</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This was touched on in recent discussion on dev list:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/41700#41700&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/41700#41700&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;and then more recently on the user list:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-user/42088&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-user/42088&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lucene&apos;s &quot;point in time&quot; searching currently relies on how the&lt;br/&gt;
underlying storage handles deletion files that are held open for&lt;br/&gt;
reading.&lt;/p&gt;

&lt;p&gt;This is highly variable across filesystems.  For example, UNIX-like&lt;br/&gt;
filesystems usually do &quot;close on last delete&quot;, and Windows filesystem&lt;br/&gt;
typically refuses to delete a file open for reading (so Lucene retries&lt;br/&gt;
later).  But NFS just removes the file out from under the reader, and&lt;br/&gt;
for that reason &quot;point in time&quot; searching doesn&apos;t work on NFS&lt;br/&gt;
(see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-673&quot; title=&quot;Exceptions when using Lucene over NFS&quot;&gt;&lt;del&gt;LUCENE-673&lt;/del&gt;&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;With the lockless commits changes (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-701&quot; title=&quot;Lock-less commits&quot;&gt;&lt;del&gt;LUCENE-701&lt;/del&gt;&lt;/a&gt; ), it&apos;s quite simple to&lt;br/&gt;
re-implement &quot;point in time searching&quot; so as to not rely on filesystem&lt;br/&gt;
semantics: we can just keep more than the last segments_N file (as&lt;br/&gt;
well as all files they reference).&lt;/p&gt;

&lt;p&gt;This is also in keeping with the design goal of &quot;rely on as little as&lt;br/&gt;
possible from the filesystem&quot;.  EG with lockless we no longer re-use&lt;br/&gt;
filenames (don&apos;t rely on filesystem cache being coherent) and we no&lt;br/&gt;
longer use file renaming (because on Windows it can fails).  This&lt;br/&gt;
would be another step of not relying on semantics of &quot;deleting open&lt;br/&gt;
files&quot;.  The less we require from filesystem the more portable Lucene&lt;br/&gt;
will be!&lt;/p&gt;

&lt;p&gt;Where it gets interesting is what &quot;policy&quot; we would then use for&lt;br/&gt;
removing segments_N files.  The policy now is &quot;remove all but the last&lt;br/&gt;
one&quot;.  I think we would keep this policy as the default.  Then you&lt;br/&gt;
could imagine other policies:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Keep past N day&apos;s worth&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Keep the last N&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Keep only those in active use by a reader somewhere (note: tricky&lt;br/&gt;
    how to reliably figure this out when readers have crashed, etc.)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Keep those &quot;marked&quot; as rollback points by some transaction, or&lt;br/&gt;
    marked explicitly as a &quot;snaphshot&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Or, roll your own: the &quot;policy&quot; would be an interface or abstract&lt;br/&gt;
    class and you could make your own implementation.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think for this issue we could just create the framework&lt;br/&gt;
(interface/abstract class for &quot;policy&quot; and invoke it from&lt;br/&gt;
IndexFileDeleter) and then implement the current policy (delete all&lt;br/&gt;
but most recent segments_N) as the default policy.&lt;/p&gt;

&lt;p&gt;In separate issue(s) we could then create the above more interesting&lt;br/&gt;
policies.&lt;/p&gt;

&lt;p&gt;I think there are some important advantages to doing this:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;&quot;Point in time&quot; searching would work on NFS (it doesn&apos;t now&lt;br/&gt;
    because NFS doesn&apos;t do &quot;delete on last close&quot;; see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-673&quot; title=&quot;Exceptions when using Lucene over NFS&quot;&gt;&lt;del&gt;LUCENE-673&lt;/del&gt;&lt;/a&gt; )&lt;br/&gt;
    and any other Directory implementations that don&apos;t work&lt;br/&gt;
    currently.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Transactional semantics become a possibility: you can set a&lt;br/&gt;
    snapshot, do a bunch of stuff to your index, and then rollback to&lt;br/&gt;
    the snapshot at a later time.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If a reader crashes or machine gets rebooted, etc, it could choose&lt;br/&gt;
    to re-open the snapshot it had previously been using, whereas now&lt;br/&gt;
    the reader must always switch to the last commit point.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Searchers could search the same snapshot for follow-on actions.&lt;br/&gt;
    Meaning, user does search, then next page, drill down (Solr),&lt;br/&gt;
    drill up, etc.  These are each separate trips to the server and if&lt;br/&gt;
    searcher has been re-opened, user can get inconsistent results (=&lt;br/&gt;
    lost trust).  But with, one series of search interactions could&lt;br/&gt;
    explicitly stay on the snapshot it had started with.&lt;/li&gt;
&lt;/ul&gt;

</description>
                <environment></environment>
            <key id="12355631">LUCENE-710</key>
            <summary>Implement &quot;point in time&quot; searching without relying on filesystem semantics</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 14 Nov 2006 19:46:22 +0000</created>
                <updated>Thu, 15 Mar 2007 22:31:12 +0000</updated>
                    <resolved>Tue, 13 Mar 2007 09:11:58 +0000</resolved>
                            <version>2.1</version>
                                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12466073" author="mikemccand" created="Fri, 19 Jan 2007 15:09:01 +0000"  >&lt;p&gt;There has been some great design discussions / iterations recently&lt;br/&gt;
on how to approach this:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/44162&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/44162&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/44236&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/44236&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;I think we&apos;ve iterated to a good approach now.  Here&apos;s the summary:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;First, add an option to IndexWriter to &quot;commit (write segments_N)&lt;br/&gt;
    only on close&quot; vs writing a segments_N every time there is a&lt;br/&gt;
    flush, merge, etc., during a single IndexWriter session.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This means a reader won&apos;t see anything a writer has been doing&lt;br/&gt;
    until it&apos;s closed.&lt;/p&gt;

&lt;p&gt;    We would still have an &quot;autoCommit&quot; true/false (default true) to&lt;br/&gt;
    keep backwards compatibility.  If true, the IndexWriter writes a&lt;br/&gt;
    new segments_N every time it flushes, merges segments, etc.; else&lt;br/&gt;
    it only writes one on close.&lt;/p&gt;

&lt;p&gt;    We would add an &quot;abort()&quot; to IndexWriter to not commit, clean up&lt;br/&gt;
    any temp files created, and rollback.&lt;/p&gt;

&lt;p&gt;    &quot;Commit on close&quot; will also address / enable fixes for other&lt;br/&gt;
    issues like prevent readers from refreshing half way through&lt;br/&gt;
    something like &quot;bulk delete then bulk add&quot;, preventing readers&lt;br/&gt;
    from refreshing during optimize() thus tying up lots of disk&lt;br/&gt;
    space, enabling a write session to be transactional (all or&lt;br/&gt;
    none), etc.&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;Second, change how IndexFileDeleter works: have it keep track of&lt;br/&gt;
    which commits are still live and which one is pending (as the&lt;br/&gt;
    SegmentInfos in IndexWriter, not yet written to disk).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Allow IndexFileDeleter to be subclassed to implement different&lt;br/&gt;
    &quot;deletion policies&quot;.&lt;/p&gt;

&lt;p&gt;    The base IndexFileDeleter class will use ref counts to figure out&lt;br/&gt;
    which individual index files are still referenced by one or more&lt;br/&gt;
    &quot;segments_N&quot; commits or by the uncommitted &quot;in-memory&quot;&lt;br/&gt;
    SegmentInfos.  Then the policy is invoked on commit (and also on&lt;br/&gt;
    init) and can choose which commits (if any) to now remove.&lt;/p&gt;

&lt;p&gt;    Add constructors to IndexWriter allowing you to pass in your own&lt;br/&gt;
    deleter. The default policy would still be &quot;delete all past&lt;br/&gt;
    commits as soon as a new commit is written&quot; (this is how deleting&lt;br/&gt;
    happens today).&lt;/p&gt;

&lt;p&gt;    For NFS we can then try different policies as discussed on those&lt;br/&gt;
    threads above (there were at least 4 proposals).  They all have&lt;br/&gt;
    different tradeoffs.  I would open separate issues for these&lt;br/&gt;
    policies after this issue is resolved.&lt;/p&gt;</comment>
                    <comment id="12466117" author="creamyg" created="Fri, 19 Jan 2007 18:25:43 +0000"  >&lt;p&gt;(This is a continuation of the discussion from one of the threads quoted in the previous comment, with some summations to provide context.)&lt;/p&gt;

&lt;p&gt;Referring to a proposal to implement advisory locking where possible, and prevent index creation on volumes/systems where the delete mechanism fails, Michael McCandless wrote:&lt;/p&gt;

&lt;p&gt;But what I don&apos;t like about it is it doesn&apos;t &quot;gracefully degrade&quot; to&lt;br/&gt;
the common NFS case where locking does not work.  And, this is often&lt;br/&gt;
outside our user&apos;s control. &lt;/p&gt;

&lt;p&gt;The stratagem of publicly exposing IndexFileDeleter does not &quot;degrade gracefully&quot;, either.  &lt;/p&gt;

&lt;p&gt;If today&apos;s default deletions policy remains the default, then when an index is put on an NFS system, at some point search-time exceptions will occur after an update to an index.  The user has to 1) detect this scenario without Lucene&apos;s help, probably from logs or user complaints 2) diagnose it without the aid of a meaningful error message, and 3) either implement their own IndexFileDeleter or choose an appropriate provided subclass, a task which will require that they grok both the innards of Lucene and the subtleties of NFS.&lt;/p&gt;

&lt;p&gt;The first step to graceful degradation is a meaningful error message.  That means detecting a problem which normally requires both a indexing process and a search process to trigger, so we have to simulate it artificially with a test.&lt;/p&gt;

&lt;p&gt;   1) Open a file for read/write and write a few bytes to it.&lt;br/&gt;
   2) Delete the test file (without closing the handle).&lt;br/&gt;
   3) Try to read from the handle and if a &quot;stale NFS filehandle&quot; &lt;br/&gt;
      exception is caught, throw something more informative.&lt;/p&gt;

&lt;p&gt;Our first opportunity to perform this test occurs at index-creation time.  This is essentially cost free.&lt;/p&gt;

&lt;p&gt;A second opportunity arises whenever deletions are performed.  Here, there&apos;s a small cost involved, and it may not be worth it, as this would only catch cases where an index was copied onto an NFS volume rather than created there, then subsequently modified.&lt;/p&gt;

&lt;p&gt;There&apos;s also another stratagem available to us: we can have IndexReaders establish advisory read locks against their relevant segments_N files on systems which support such locks.  This won&apos;t help us to &quot;degrade gracefully&quot;.  However, it will help us degrade less often, as modern versions of NFS support file locking - but still do NOT support the &quot;delete-on-last-close&quot; mechanism Lucene depends on.&lt;/p&gt;

&lt;p&gt;Implementing advisory read locks is orthogonal to the addition of IndexFileDeleter, but diminishes the justification for adding it as a public API.&lt;/p&gt;

&lt;p&gt;But the good news is since we will allow subclassing to make your own&lt;br/&gt;
deletion policy, we can eventually do both of these approaches and our&lt;br/&gt;
users can pick one or do their own.&lt;/p&gt;

&lt;p&gt;The number of users this class will serve is diminishingly small.    Other mitigation strategies are available.    &lt;/p&gt;

&lt;p&gt;1) If we implement advisory read locks, many people who see this error will no longer see it.  For those who do, the best option is to upgrade the OS to a version which supports advisory locks over NFS.  Then an index on an NFS volume will behave as any other.&lt;br/&gt;
2) If you don&apos;t actually need to put the index on an NFS volume, put it somewhere else.&lt;br/&gt;
3) Catch stale NFS filehandle exceptions in your search application and refresh the reader when they occur.&lt;br/&gt;
4) Maintain two copies of an index and do an rsync/switch.&lt;br/&gt;
5) Hack Lucene.&lt;/p&gt;

&lt;p&gt;Flexibility is not free.  There have been recent lamentations on java-dev about how difficult it will be to merge the write interfaces of IndexReader and IndexWriter to provide a single, unified class through which all index modifications can be performed.  The exposure of the IndexFileDeleter mechanism contributes to this problem &amp;#8211; it&apos;s one more small step in the wrong direction.  &lt;/p&gt;

&lt;p&gt;Providing a subclassing/callback API is often an elegant strategy, and it is surely better in this case than it would be to provide a list of deletion policies for the user to select from.  However, whenever possible, &lt;em&gt;no&lt;/em&gt; API is always a better solution &amp;#8211; especially in a case like this one, where the functionality provided has nothing to do with Lucene&apos;s core mission and is there solely to work around an implmentation-specific bug.  &lt;/p&gt;</comment>
                    <comment id="12466122" author="creamyg" created="Fri, 19 Jan 2007 18:33:27 +0000"  >&lt;p&gt;There are two sections in the previous comment that are supposed to be quoted, but which are not because JIRA ate the email-style &quot;greater than&quot; quoting.  They are:&lt;/p&gt;

&lt;p&gt;  &quot;But what I don&apos;t like about it is it doesn&apos;t &quot;gracefully degrade&quot; to&lt;br/&gt;
   the common NFS case where locking does not work. And, this is often&lt;br/&gt;
   outside our user&apos;s control.&quot;&lt;/p&gt;

&lt;p&gt; &quot;But the good news is since we will allow subclassing to make your own&lt;br/&gt;
  deletion policy, we can eventually do both of these approaches and our&lt;br/&gt;
  users can pick one or do their own.&quot;&lt;/p&gt;

&lt;p&gt;I wish  it were possible to edit that note, as it&apos;s really confusing as things stand.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  A preview mechanism would have been handy.&lt;/p&gt;
</comment>
                    <comment id="12466126" author="doronc" created="Fri, 19 Jan 2007 18:55:21 +0000"  >&lt;p&gt;&amp;gt;   * Second, change how IndexFileDeleter works: have it keep track of&lt;br/&gt;
&amp;gt;     which commits are still live and which one is pending (as the&lt;br/&gt;
&amp;gt;     SegmentInfos in IndexWriter, not yet written to disk).&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     Allow IndexFileDeleter to be subclassed to implement different&lt;br/&gt;
&amp;gt;     &quot;deletion policies&quot;.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     The base IndexFileDeleter class will use ref counts to figure out&lt;br/&gt;
&amp;gt;     which individual index files are still referenced by one or more&lt;br/&gt;
&amp;gt;     &quot;segments_N&quot; commits or by the uncommitted &quot;in-memory&quot;&lt;br/&gt;
&amp;gt;     SegmentInfos.  Then the policy is invoked on commit (and also on&lt;br/&gt;
&amp;gt;     init) and can choose which commits (if any) to now remove.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     Add constructors to IndexWriter allowing you to pass in your own&lt;br/&gt;
&amp;gt;     deleter. The default policy would still be &quot;delete all past&lt;br/&gt;
&amp;gt;     commits as soon as a new commit is written&quot; (this is how deleting&lt;br/&gt;
&amp;gt;     happens today).&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     For NFS we can then try different policies as discussed on those&lt;br/&gt;
&amp;gt;     threads above (there were at least 4 proposals).  They all have&lt;br/&gt;
&amp;gt;     different tradeoffs.  I would open separate issues for these&lt;br/&gt;
&amp;gt;     policies after this issue is resolved.&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;This ties solving the NFS issue with an extendable-file-deletion policy.&lt;br/&gt;
I am wondering is this the right way, or, perhaps, should the reference &lt;br/&gt;
counting be considered alone, apart from the deletion policy.&lt;br/&gt;
(Would modifying IndexFileDeleter to base on ref-count make it simpler&lt;br/&gt;
or harder to maintain?)&lt;/p&gt;

&lt;p&gt;Also, IndexFileDeleter is doing delicate work - not sure you want &lt;br/&gt;
applications to mess with it. Better let applications control some&lt;br/&gt;
simple well defined behavior, maybe the same way that a sorter &lt;br/&gt;
allows applications to provide a comparator, but keeps the sorting &lt;br/&gt;
algorithm for itself.&lt;/p&gt;

&lt;p&gt;Back to reference counting,- how about the following approach:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Add to Directory a FileReferenceCounter data member, get()/set() etc.&lt;/li&gt;
	&lt;li&gt;Add a class FileReferenceCounter with simple general methods:&lt;br/&gt;
  void increment (String name)&lt;br/&gt;
  void decrement (String name)&lt;br/&gt;
  int getRefCount (String name)&lt;/li&gt;
	&lt;li&gt;Default implementation would do nothing, i.e. would not record&lt;br/&gt;
  references, and always return 0.&lt;/li&gt;
	&lt;li&gt;IndexReader, upon opening a segment, would call increment(segName)&lt;/li&gt;
	&lt;li&gt;IndexReader, upon closing a segment, would call decrement(segName)&lt;/li&gt;
	&lt;li&gt;IndexFileDeleter, before removing a file belonging to a certain segment,&lt;br/&gt;
  would verify getRefCount(segName)==0.&lt;/li&gt;
	&lt;li&gt;Notice that the FilereferenceCounter is available from the Directory,&lt;br/&gt;
  so no constructors should be added to IndexWriter/Reader.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So, this is adding to Directory a general file utility, no knowledge of &lt;br/&gt;
index structure required in Directory. Also, IndexFileDeleter can remain &lt;br/&gt;
as today, and at some later point can be made more powerful with various &lt;br/&gt;
deletion policies - but those policies remain unrelated to the NFS &lt;br/&gt;
issue - they can focus on point-in-time issues, where I think it &lt;br/&gt;
stemmed from. &lt;/p&gt;

&lt;p&gt;An NFS geared FileReferenceCounter would then be able to keep alive &lt;br/&gt;
&quot;counter files&quot;, name those files based on counted fileName plus&lt;br/&gt;
processID plus machID, base getRefCount on safety window since file &lt;br/&gt;
was last touched, etc. All this is left out from point-in-time &lt;br/&gt;
policies (how many/time points-in-time should be retained).&lt;/p&gt;</comment>
                    <comment id="12466164" author="mikemccand" created="Fri, 19 Jan 2007 22:03:30 +0000"  >&lt;p&gt;OK, a few top level summary comments and then some specifics below:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I don&apos;t want to modify the Lucene core (adding advisory read&lt;br/&gt;
     locks, etc) just to handle the NFS case.  That risks hurting the&lt;br/&gt;
     non-NFS cases.  &quot;First do no harm.&quot;  &quot;Keep it simple.&quot;  We&apos;ve been&lt;br/&gt;
     working hard to remove locking lately (lockless commits) and I&lt;br/&gt;
     rather not add more locking back.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     By implementing each approach (I think there are now 5 different&lt;br/&gt;
     ideas now) instead as its own deletion policy (subclass of&lt;br/&gt;
     IndexFileDeleter) we contain the added complexity of locking,&lt;br/&gt;
     file-based ref counts, etc, to just that one subclass of&lt;br/&gt;
     IndexFileDeleter.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I think NFS support is part of Lucene&apos;s core mission.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     Lucene should try hard to be as portable as possible.&lt;/p&gt;

&lt;p&gt;     NFS is used &lt;b&gt;alot&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;     It&apos;s tempting to tell users to &quot;upgrade OS&quot;, &quot;upgrade NFS server&lt;br/&gt;
     and/or client&quot;, etc, but taking that approach will only hurt our&lt;br/&gt;
     users because typically this is not something they can control.&lt;/p&gt;

&lt;p&gt;     Now, if we had to bend over backwards for NFS, then I would agree&lt;br/&gt;
     it&apos;s not worth it.  But, we don&apos;t have to: by allowing custom&lt;br/&gt;
     deletion policies (which is a minor change) we can try out all of&lt;br/&gt;
     the approaches suggested so far on this thread.&lt;/p&gt;

&lt;p&gt;     Rather than baking any one of these approaches into the Lucene&lt;br/&gt;
     core, I&apos;d rather just enable &quot;custom deletion policies&quot; then&lt;br/&gt;
     people can build out these polices outside of the core (eg in&lt;br/&gt;
     &quot;contrib&quot; first).&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I agree that &quot;giving a good error message when index is on NFS&quot; is&lt;br/&gt;
     really important and that custom deletion policy alone doesn&apos;t&lt;br/&gt;
     address this.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     Marvin I don&apos;t think your test will work either (see below).&lt;/p&gt;

&lt;p&gt;     But I really like this direction: does anyone know how (Java&lt;br/&gt;
     friendly way) to determine that a given directory is on an NFS&lt;br/&gt;
     mount?  That would be wonderful.  I will spin off a new thread&lt;br/&gt;
     here.&lt;/p&gt;


&lt;p&gt;Some specifics below:&lt;/p&gt;

&lt;p&gt;Marvin Humphrey wrote:&lt;/p&gt;

&lt;p&gt; &amp;gt; The first step to graceful degradation is a meaningful error message. &lt;br/&gt;
  That means detecting a problem which normally requires both a indexing &lt;br/&gt;
process and a search process to trigger, so we have to simulate it &lt;br/&gt;
artificially with a test.&lt;br/&gt;
 &amp;gt;&lt;br/&gt;
 &amp;gt;    1) Open a file for read/write and write a few bytes to it.&lt;br/&gt;
 &amp;gt;    2) Delete the test file (without closing the handle).&lt;br/&gt;
 &amp;gt;    3) Try to read from the handle and if a &quot;stale NFS filehandle&quot;&lt;br/&gt;
 &amp;gt;       exception is caught, throw something more informative.&lt;br/&gt;
 &amp;gt;&lt;br/&gt;
 &amp;gt; Our first opportunity to perform this test occurs at index-creation &lt;br/&gt;
time.  This is essentially cost free.&lt;br/&gt;
 &amp;gt;&lt;br/&gt;
 &amp;gt; A second opportunity arises whenever deletions are performed.  Here, &lt;br/&gt;
there&apos;s a small cost involved, and it may not be worth it, as this would &lt;br/&gt;
only catch cases where an index was copied onto an NFS volume rather &lt;br/&gt;
than created there, then subsequently modified.&lt;/p&gt;

&lt;p&gt;I think this test won&apos;t work (though I haven&apos;t tested...).  Typically&lt;br/&gt;
an NFS client will catch this case and locally emulate &quot;delete on last&lt;br/&gt;
close&quot;.  Worse, even if it doesn&apos;t, those bytes would likely be cached&lt;br/&gt;
and then would fail to hit &quot;stale NFS filehandle&quot;.&lt;/p&gt;

&lt;p&gt; &amp;gt; But the good news is since we will allow subclassing to make your own&lt;br/&gt;
 &amp;gt; deletion policy, we can eventually do both of these approaches and our&lt;br/&gt;
 &amp;gt; users can pick one or do their own.&lt;br/&gt;
 &amp;gt;&lt;br/&gt;
 &amp;gt; The number of users this class will serve is diminishingly small. &lt;br/&gt;
Other mitigation strategies are available.&lt;br/&gt;
 &amp;gt;&lt;br/&gt;
 &amp;gt; 1) If we implement advisory read locks, many people who see this &lt;br/&gt;
error will no longer see it.  For those who do, the best option is to &lt;br/&gt;
upgrade the OS to a version which supports advisory locks over NFS. &lt;br/&gt;
Then an index on an NFS volume will behave as any other.&lt;br/&gt;
 &amp;gt; 2) If you don&apos;t actually need to put the index on an NFS volume, put &lt;br/&gt;
it somewhere else.&lt;br/&gt;
 &amp;gt; 3) Catch stale NFS filehandle exceptions in your search application &lt;br/&gt;
and refresh the reader when they occur.&lt;br/&gt;
 &amp;gt; 4) Maintain two copies of an index and do an rsync/switch.&lt;br/&gt;
 &amp;gt; 5) Hack Lucene.&lt;/p&gt;

&lt;p&gt;5) isn&apos;t really a good option since we all can&apos;t even agree how to&lt;br/&gt;
&quot;hack Lucene&quot; to make this work!  1) I think is too dangerous as part&lt;br/&gt;
of the core.  2) typically this is not an option.  People choose NFS&lt;br/&gt;
because they want to share the index.  4) is a fair amount of added&lt;br/&gt;
complexity.  3) is the most viable option I see here, but it&apos;s not&lt;br/&gt;
great because you&apos;re forced to refresh &quot;right now&quot;.  What if warming&lt;br/&gt;
takes 8 minutes?  What if &quot;now&quot; is a bad time because deletes were&lt;br/&gt;
done by the writer but not yet adds?&lt;/p&gt;

&lt;p&gt; &amp;gt; Flexibility is not free.  There have been recent lamentations on &lt;br/&gt;
java-dev about how difficult it will be to merge the write interfaces of &lt;br/&gt;
IndexReader and IndexWriter to provide a single, unified class through &lt;br/&gt;
which all index modifications can be performed.  The exposure of the &lt;br/&gt;
IndexFileDeleter mechanism contributes to this problem &amp;#8211; it&apos;s one more &lt;br/&gt;
small step in the wrong direction.&lt;/p&gt;

&lt;p&gt;Yes there is an open question now on what to do about the confusion on&lt;br/&gt;
using IndexReader vs IndexWriter.  I think moving towards &quot;use&lt;br/&gt;
IndexWriter for changes, use IndexReader for reading&quot; is the best&lt;br/&gt;
solution here.  But I don&apos;t see how this relates to allowing&lt;br/&gt;
subclassing of IndexFileDeleter to make your own deletion policy.&lt;/p&gt;

&lt;p&gt; &amp;gt; Providing a subclassing/callback API is often an elegant strategy, &lt;br/&gt;
and it is surely better in this case than it would be to provide a list &lt;br/&gt;
of deletion policies for the user to select from.  However, whenever &lt;br/&gt;
possible, &lt;em&gt;no&lt;/em&gt; API is always a better solution &amp;#8211; especially in a case &lt;br/&gt;
like this one, where the functionality provided has nothing to do with &lt;br/&gt;
Lucene&apos;s core mission and is there solely to work around an &lt;br/&gt;
implmentation-specific bug.&lt;/p&gt;

&lt;p&gt;I disagree on this point (&quot;no&quot; API is better than subclassing).  As&lt;br/&gt;
you&apos;ve said, this issue won&apos;t affect that many people (though I think&lt;br/&gt;
it&apos;s a fairly large subset of our users).  Given that, I would not&lt;br/&gt;
want to add file locking &amp;amp; additional complexity into the Lucene core,&lt;br/&gt;
just to handle NFS.&lt;/p&gt;

&lt;p&gt;By allowing a different delete policy as a subclass of&lt;br/&gt;
IndexFileDeleter we keep the changes required for supporting NFS way&lt;br/&gt;
outside the Lucene core.  Since there&apos;s so much debate about which&lt;br/&gt;
deletion policy is best we should create all of these in contrib to&lt;br/&gt;
begin with and if something proves reliable we can eventually promote&lt;br/&gt;
it into core Lucene.&lt;/p&gt;

&lt;p&gt;I think subclassing is perfect for this sort of situation.  It&apos;s like&lt;br/&gt;
the various LockFactory implementations we have: there is no &quot;one size&lt;br/&gt;
fits all&quot;.&lt;/p&gt;

&lt;p&gt;Mike&lt;/p&gt;</comment>
                    <comment id="12466165" author="mikemccand" created="Fri, 19 Jan 2007 22:09:17 +0000"  >
&lt;p&gt;Doron Cohen wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; This ties solving the NFS issue with an extendable-file-deletion policy.&lt;br/&gt;
&amp;gt; I am wondering is this the right way, or, perhaps, should the reference &lt;br/&gt;
&amp;gt; counting be considered alone, apart from the deletion policy.&lt;br/&gt;
&amp;gt; (Would modifying IndexFileDeleter to base on ref-count make it simpler&lt;br/&gt;
&amp;gt; or harder to maintain?)&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Also, IndexFileDeleter is doing delicate work - not sure you want &lt;br/&gt;
&amp;gt; applications to mess with it. Better let applications control some&lt;br/&gt;
&amp;gt; simple well defined behavior, maybe the same way that a sorter &lt;br/&gt;
&amp;gt; allows applications to provide a comparator, but keeps the sorting &lt;br/&gt;
&amp;gt; algorithm for itself.&lt;/p&gt;

&lt;p&gt;The solution I have in mind abstracts away all tricky details of&lt;br/&gt;
deleting files.  EG something like:&lt;/p&gt;

&lt;p&gt;  public class OnlyLastCommitDeleter extends IndexFileDeleter {&lt;/p&gt;

&lt;p&gt;    void onInit(List commits) &lt;/p&gt;
{
      onCommit(commits);
    }

&lt;p&gt;    void onCommit(List commits) {&lt;br/&gt;
      if (commits.size() &amp;gt; 1) {&lt;br/&gt;
        for(int i=0;i&amp;lt;commits.size()-1;i++) &lt;/p&gt;
{
          deleteCommit(commits.get(i));
        }
&lt;p&gt;      }&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;Ie, the sole responsibility of the IndexFileDeleter subclass (policy)&lt;br/&gt;
is to decide when to delete a commit.  The rest of the details&lt;br/&gt;
(figuring out what actual files can be deleted now that a given commit&lt;br/&gt;
segments_N is deleted) are handled by the base class (with in-memory&lt;br/&gt;
ref counting).&lt;/p&gt;

&lt;p&gt;&amp;gt; Back to reference counting,- how about the following approach:&lt;br/&gt;
&amp;gt; - Add to Directory a FileReferenceCounter data member, get()/set() etc.&lt;br/&gt;
&amp;gt; - Add a class FileReferenceCounter with simple general methods:&lt;br/&gt;
&amp;gt;   void increment (String name)&lt;br/&gt;
&amp;gt;   void decrement (String name)&lt;br/&gt;
&amp;gt;   int getRefCount (String name)&lt;br/&gt;
&amp;gt; - Default implementation would do nothing, i.e. would not record &lt;br/&gt;
&amp;gt;   references, and always return 0.&lt;br/&gt;
&amp;gt; - IndexReader, upon opening a segment, would call increment(segName)&lt;br/&gt;
&amp;gt; - IndexReader, upon closing a segment, would call decrement(segName)&lt;br/&gt;
&amp;gt; - IndexFileDeleter, before removing a file belonging to a certain segment, &lt;br/&gt;
&amp;gt;   would verify getRefCount(segName)==0.&lt;br/&gt;
&amp;gt; - Notice that the FilereferenceCounter is available from the Directory, &lt;br/&gt;
&amp;gt;   so no constructors should be added to IndexWriter/Reader.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; So, this is adding to Directory a general file utility, no knowledge of &lt;br/&gt;
&amp;gt; index structure required in Directory. Also, IndexFileDeleter can remain &lt;br/&gt;
&amp;gt; as today, and at some later point can be made more powerful with various &lt;br/&gt;
&amp;gt; deletion policies - but those policies remain unrelated to the NFS &lt;br/&gt;
&amp;gt; issue - they can focus on point-in-time issues, where I think it &lt;br/&gt;
&amp;gt; stemmed from. &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; An NFS geared FileReferenceCounter would then be able to keep alive &lt;br/&gt;
&amp;gt; &quot;counter files&quot;, name those files based on counted fileName plus&lt;br/&gt;
&amp;gt; processID plus machID, base getRefCount on safety window since file &lt;br/&gt;
&amp;gt; was last touched, etc. All this is left out from point-in-time &lt;br/&gt;
&amp;gt; policies (how many/time points-in-time should be retained).&lt;/p&gt;

&lt;p&gt;I think this approach could work, but, rather than implementing in the&lt;br/&gt;
Lucene core (adding methods to Directory) I&apos;d like to see it tested as&lt;br/&gt;
a custom deletion policy + wrappers around IndexReader&lt;br/&gt;
creation/destruction.&lt;/p&gt;

&lt;p&gt;We have so much debate about the best &quot;deletion policy&quot; for NFS that&lt;br/&gt;
I&apos;d like to make the minimal extension to the core (ability to make&lt;br/&gt;
your own &quot;deletion policy&quot;) and then people can build their own and&lt;br/&gt;
try them out.&lt;/p&gt;

&lt;p&gt;Mike&lt;/p&gt;</comment>
                    <comment id="12466223" author="mikemccand" created="Sat, 20 Jan 2007 10:12:15 +0000"  >&lt;p&gt;One clarification on &quot;different deletion policies&quot;: to support &quot;commit&lt;br/&gt;
on close&quot; in IndexWriter, I already have to improve IndexFileDeleter&lt;br/&gt;
to give it a different deletion policy than the current one.&lt;/p&gt;

&lt;p&gt;Specifically, the deleter must not delete anything referenced by the&lt;br/&gt;
last commit nor anything referenced by the in-memory SegmentInfos.&lt;/p&gt;

&lt;p&gt;For example, if a writer is opened with autoCommit=false (&quot;commit on&lt;br/&gt;
close&quot;) on an existing index, and lots of docs are added/deleted/etc,&lt;br/&gt;
there will have been flushes &amp;amp; merges of segments.  The deletion&lt;br/&gt;
policy should not delete anything that existed &quot;at the start&quot; because&lt;br/&gt;
it&apos;s referenced by the segments_N commit, nor anything that is now&lt;br/&gt;
referenced by the in-memory SegmentInfos.  But it should delete&lt;br/&gt;
anything &quot;in between&quot; (any newly written segments that have now been&lt;br/&gt;
merged away).&lt;/p&gt;

&lt;p&gt;To the deleter this would just be a different policy, one that keeps&lt;br/&gt;
two SegmentInfos alive (one on disk and one not yet committed, in&lt;br/&gt;
memory).  And the default deletion policy would be selected depending&lt;br/&gt;
on whether the writer is in autoCommit mode or not.&lt;/p&gt;</comment>
                    <comment id="12466377" author="creamyg" created="Mon, 22 Jan 2007 01:22:49 +0000"  >
&lt;p&gt;On Jan 19, 2007, at 2:04 PM, Michael McCandless (JIRA) wrote:&lt;br/&gt;
&amp;gt;   * I think NFS support is part of Lucene&apos;s core mission.&lt;/p&gt;

&lt;p&gt;When I asserted that IndexFileDeleter had nothing to do with Lucene&apos;s core&lt;br/&gt;
mission, I meant: you don&apos;t use Lucene to build yourself an app which helps&lt;br/&gt;
you delete files.  &lt;/p&gt;

&lt;p&gt;&amp;gt; Yes there is an open question now on what to do about the confusion on using&lt;br/&gt;
&amp;gt; IndexReader vs IndexWriter.  I think moving towards &quot;use IndexWriter for&lt;br/&gt;
&amp;gt; changes, use IndexReader for reading&quot; is the best solution here.  But I&lt;br/&gt;
&amp;gt; don&apos;t see how this relates to allowing subclassing of IndexFileDeleter to&lt;br/&gt;
&amp;gt; make your own deletion policy.&lt;/p&gt;

&lt;p&gt;They&apos;re hard to refactor because they&apos;re both big, hence adding either code or&lt;br/&gt;
API commitments to them should be avoided when possible.  We&apos;re in agreement&lt;br/&gt;
about the desirability of simplicity.  We part ways in how we measure&lt;br/&gt;
simplicity: I give greater emphasis to simplicity of API design. &lt;/p&gt;

&lt;p&gt;&amp;gt; I disagree on this point (&quot;no&quot; API is better than subclassing). &lt;/p&gt;

&lt;p&gt;We&apos;re talking past each other.  I was generalizing: a 100% successful, purely&lt;br/&gt;
internal &quot;black box&quot; solution is always better than a solution that involves&lt;br/&gt;
the user.&lt;/p&gt;

&lt;p&gt;&amp;gt; I would not want to add file locking &amp;amp; additional complexity into the Lucene&lt;br/&gt;
&amp;gt; core, just to handle NFS.&lt;/p&gt;

&lt;p&gt;This is where our differing priorities manifest.  I would rather add some&lt;br/&gt;
code complexity to the Lucene &quot;core&quot; than accept the increased &lt;br/&gt;
support burden of an expanded API.&lt;/p&gt;

&lt;p&gt;Ironically, though you consider supporting NFS &quot;part of Lucene&apos;s core&lt;br/&gt;
mission&quot;, for the average user your proposal as it stands is not very&lt;br/&gt;
user-friendly.  People like Chuck, Doron, and Robert will have no trouble with&lt;br/&gt;
it, but if you&apos;re a newcomer to Lucene and you &quot;just want to put an index on&lt;br/&gt;
NFS&quot;, subclassing IndexFileDeleter will pose a challenge.&lt;/p&gt;

&lt;p&gt;I also think you may be over-estimating the amount of effort it will take to&lt;br/&gt;
exploit advisory read locks.  (The vexing problem of how to issue a warning &lt;br/&gt;
when index creation is attempted on an NFS volume is orthogonal to the &lt;br/&gt;
read-locks approach as well.) They should be easy in KS; I&apos;ll know soon enough.  &lt;br/&gt;
However, there are some OO discipline issues which complicate applying what I&lt;br/&gt;
have in mind to Java Lucene.  In KS, the public API is defined solely via&lt;br/&gt;
documentation, so I can have code in Index call methods from Store without&lt;br/&gt;
having to expose it.  With Lucene divided into multiple packages, that&apos;s a&lt;br/&gt;
problem.  &lt;/p&gt;

&lt;p&gt;&amp;gt; I think subclassing is perfect for this sort of situation.  &lt;/p&gt;

&lt;p&gt;I&apos;m not so enamored of subclassing. It&apos;s less constraining than some other&lt;br/&gt;
approaches, but it&apos;s still constraining.&lt;/p&gt;

&lt;p&gt;Case in point: it&apos;s not possible to provide a subclass of IndexFileDeleter&lt;br/&gt;
which exploits advisory read locking under your current proposal.&lt;/p&gt;

&lt;p&gt;In theory, your proposal even prevents the addition of such read locks to&lt;br/&gt;
Lucene later, because doing so could conflict with a deletions policy you&apos;ve&lt;br/&gt;
allowed the user to set.  (; Given that locks over NFS make you &quot;nervous&quot;,&lt;br/&gt;
perhaps you consider foreclosing that option a feature. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; It&apos;s like the various LockFactory implementations we have: there is no &quot;one&lt;br/&gt;
&amp;gt; size fits all&quot;.&lt;/p&gt;

&lt;p&gt;I don&apos;t think LockFactory ought to be exposed either.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Reading from an index &amp;#8211; any index, on any volume &amp;#8211; should Just Work.&lt;br/&gt;
Writing to an index from a single IndexWriter should Just Work.  In a perfect&lt;br/&gt;
world, writing from multiple writers simultaneously would Just Work, too, but&lt;br/&gt;
as that&apos;s inherently impractical given Lucene&apos;s current design, opening a&lt;br/&gt;
second writer must fail.  That failure should be the only visible evidence&lt;br/&gt;
that a locking mechanism even exists.  &lt;/p&gt;

&lt;p&gt;In my view, any deviance from that ideal API due to implementation defects&lt;br/&gt;
should be handled with exceptions rather than API additions.&lt;/p&gt;

&lt;p&gt;In keeping with this philosophy, Lock is not publicly exposed in KinoSearch.&lt;br/&gt;
In fact, nothing about the locking mechanism is publicly exposed.  So far,&lt;br/&gt;
there seem to be three bugs with the current implementation: &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Stale NFS Filehandle exceptions.&lt;/li&gt;
	&lt;li&gt;Stale lock files interfering with unattended indexing sessions.  I plan&lt;br/&gt;
    to mitigate this by moving to advisory write locks when possible.&lt;/li&gt;
	&lt;li&gt;Multiple machines can cause index corruption when attempting to write&lt;br/&gt;
    simultaneously to a shared volume.  Moving the write.lock file to the&lt;br/&gt;
    index directory, as enabled by lockless commits, solves this problem.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Once advisory file locks are in place, and if they work as expected under&lt;br/&gt;
recent versions of NFS, I expect no further problems under any common, recent&lt;br/&gt;
Unix.&lt;/p&gt;

&lt;p&gt;With the switch to lockless commits in KinoSearch, I&apos;ve able to refactor Lock&lt;br/&gt;
and eliminate all of Lock&apos;s subclasses, simplifying the KinoSearch &quot;core&quot;.&lt;br/&gt;
&quot;No more subclassing of Lock&quot; was originally a line-item in my list of&lt;br/&gt;
&quot;great stuff&quot; about lockless commits, but I had to take it out because it&lt;br/&gt;
wasn&apos;t true for Lucene!&lt;/p&gt;

&lt;p&gt;With Otis signing on to your solution, it looks like momentum is gathering for&lt;br/&gt;
it.  For the record, I don&apos;t think it&apos;s a catastrophic change, just suboptimal&lt;br/&gt;
and IMO not ready for addition until improved.  &lt;/p&gt;

&lt;p&gt;I think you can do better.&lt;/p&gt;</comment>
                    <comment id="12466592" author="mikemccand" created="Mon, 22 Jan 2007 23:30:23 +0000"  >&lt;p&gt;Quick summary first:&lt;/p&gt;

&lt;p&gt;OK, as you said (and I agree) I think we just have a difference of&lt;br/&gt;
opinion on what&apos;s the &quot;lesser evil&quot; tradeoff here.  You would prefer to&lt;br/&gt;
change the core of KinoSearch to always use advisory read locks for&lt;br/&gt;
all indices.&lt;/p&gt;

&lt;p&gt;Whereas I prefer to leave the Lucene core untouched since things work&lt;br/&gt;
fine in most cases today (&quot;if it ain&apos;t broke don&apos;t fix it&quot;), and then&lt;br/&gt;
open up an API so for those cases (NFS) where it doesn&apos;t work, users&lt;br/&gt;
at least have possible solutions to try.&lt;/p&gt;

&lt;p&gt;I think you also have a high confidence that the locking approach will&lt;br/&gt;
work fine (be perfect) on the first go and will not alienate too many&lt;br/&gt;
users, but I don&apos;t: I have had problems with locking in the past and I&lt;br/&gt;
think most users don&apos;t have the freedom to &quot;upgrade OS/fileserver&quot;.&lt;/p&gt;

&lt;p&gt;So I would prefer instead to open a minimal API in the core of Lucene&lt;br/&gt;
(so users can use different deletion policies), and then try the 5&lt;br/&gt;
different ideas proposed so far (and more later I&apos;m sure) as their own&lt;br/&gt;
deletion policy, external to Lucene&apos;s core (eg in contrib).  If one of&lt;br/&gt;
them proves to work well, universally, then sometime down the road we&lt;br/&gt;
can promote it as the default deletion policy.&lt;/p&gt;



&lt;p&gt;OK details below:&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; * I think NFS support is part of Lucene&apos;s core mission.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; When I asserted that IndexFileDeleter had nothing to do with Lucene&apos;s core&lt;br/&gt;
&amp;gt; mission, I meant: you don&apos;t use Lucene to build yourself an app which helps&lt;br/&gt;
&amp;gt; you delete files.&lt;/p&gt;

&lt;p&gt;Well, &quot;custom deletion policies&quot; is in support of the core mission of&lt;br/&gt;
&quot;working over NFS&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; Yes there is an open question now on what to do about the confusion on using&lt;br/&gt;
&amp;gt; &amp;gt; IndexReader vs IndexWriter. I think moving towards &quot;use IndexWriter for&lt;br/&gt;
&amp;gt; &amp;gt; changes, use IndexReader for reading&quot; is the best solution here. But I&lt;br/&gt;
&amp;gt; &amp;gt; don&apos;t see how this relates to allowing subclassing of IndexFileDeleter to&lt;br/&gt;
&amp;gt; &amp;gt; make your own deletion policy.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; They&apos;re hard to refactor because they&apos;re both big, hence adding either code or&lt;br/&gt;
&amp;gt; API commitments to them should be avoided when possible. We&apos;re in agreement&lt;br/&gt;
&amp;gt; about the desirability of simplicity. We part ways in how we measure&lt;br/&gt;
&amp;gt; simplicity: I give greater emphasis to simplicity of API design.&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; &amp;gt; I disagree on this point (&quot;no&quot; API is better than subclassing).&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; We&apos;re talking past each other. I was generalizing: a 100% successful, purely&lt;br/&gt;
&amp;gt; internal &quot;black box&quot; solution is always better than a solution that involves&lt;br/&gt;
&amp;gt; the user.&lt;/p&gt;

&lt;p&gt;OK, yes in the ideal case, no API is better than API if your situation&lt;br/&gt;
allows for no API.  I just don&apos;t think this is one of those&lt;br/&gt;
situations: I don&apos;t think we have a clear cut &quot;one size fits all&quot;&lt;br/&gt;
solution.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; I would not want to add file locking &amp;amp; additional complexity into the Lucene&lt;br/&gt;
&amp;gt; &amp;gt; core, just to handle NFS.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; This is where our differing priorities manifest. I would rather add some&lt;br/&gt;
&amp;gt; code complexity to the Lucene &quot;core&quot; than accept the increased&lt;br/&gt;
&amp;gt; support burden of an expanded API.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Ironically, though you consider supporting NFS &quot;part of Lucene&apos;s core&lt;br/&gt;
&amp;gt; mission&quot;, for the average user your proposal as it stands is not very&lt;br/&gt;
&amp;gt; user-friendly. People like Chuck, Doron, and Robert will have no trouble with&lt;br/&gt;
&amp;gt; it, but if you&apos;re a newcomer to Lucene and you &quot;just want to put an index on&lt;br/&gt;
&amp;gt; NFS&quot;, subclassing IndexFileDeleter will pose a challenge.&lt;/p&gt;

&lt;p&gt;Yes, but at least having the option (picking one of the deletion&lt;br/&gt;
policies in &quot;contrib&quot; once we&apos;ve built them out) is quite a bit better&lt;br/&gt;
than what we have today (no option besides &quot;you must refresh now&quot;).  I&lt;br/&gt;
would love to have the &quot;perfect&quot; solution (which you are aiming for in&lt;br/&gt;
one step), but I&apos;ll settle today for just good progress: &quot;progress not&lt;br/&gt;
perfection&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; I also think you may be over-estimating the amount of effort it will take to&lt;br/&gt;
&amp;gt; exploit advisory read locks. (The vexing problem of how to issue a warning&lt;br/&gt;
&amp;gt; when index creation is attempted on an NFS volume is orthogonal to the&lt;br/&gt;
&amp;gt; read-locks approach as well.) They should be easy in KS; I&apos;ll know soon enough.&lt;br/&gt;
&amp;gt; However, there are some OO discipline issues which complicate applying what I&lt;br/&gt;
&amp;gt; have in mind to Java Lucene. In KS, the public API is defined solely via&lt;br/&gt;
&amp;gt; documentation, so I can have code in Index call methods from Store without&lt;br/&gt;
&amp;gt; having to expose it. With Lucene divided into multiple packages, that&apos;s a&lt;br/&gt;
&amp;gt; problem.&lt;/p&gt;

&lt;p&gt;Yes detection of NFS is orthogonal and I would love to find a solution&lt;br/&gt;
here.  And yes Java&apos;s method/field protection is quite different from&lt;br/&gt;
what KS can do.&lt;/p&gt;

&lt;p&gt;&amp;gt; &amp;gt; I think subclassing is perfect for this sort of situation.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I&apos;m not so enamored of subclassing. It&apos;s less constraining than some other&lt;br/&gt;
&amp;gt; approaches, but it&apos;s still constraining.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Case in point: it&apos;s not possible to provide a subclass of IndexFileDeleter&lt;br/&gt;
&amp;gt; which exploits advisory read locking under your current proposal.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; In theory, your proposal even prevents the addition of such read locks to&lt;br/&gt;
&amp;gt; Lucene later, because doing so could conflict with a deletions policy you&apos;ve&lt;br/&gt;
&amp;gt; allowed the user to set. (; Given that locks over NFS make you &quot;nervous&quot;,&lt;br/&gt;
&amp;gt; perhaps you consider foreclosing that option a feature. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;No, I would not consider foreclosing that option a feature!&lt;/p&gt;

&lt;p&gt;Yes, I am nervous about relying on advisory read locks 100% today in&lt;br/&gt;
the Lucene core.  But, I would love to be proven wrong in the future:&lt;br/&gt;
if your lock based solution actually works out &quot;perfectly&quot; in the&lt;br/&gt;
future then users can indeed fire up Lucene/KS regardless of what&lt;br/&gt;
filesystem the index is on.  I would equally love to see file-based&lt;br/&gt;
reference counting work out, etc: if any option proves reliable enough&lt;br/&gt;
in the future then we can make it the default deletion policy.&lt;/p&gt;

&lt;p&gt;Yes users who set their own deletion policies would not get this&lt;br/&gt;
default but that&apos;s OK: such users understand what they&apos;ve done.&lt;/p&gt;

&lt;p&gt;And, I don&apos;t want to change the default policy now (&quot;first do no&lt;br/&gt;
harm&quot;).&lt;/p&gt;


&lt;p&gt;&amp;gt; &amp;gt; It&apos;s like the various LockFactory implementations we have: there is no &quot;one&lt;br/&gt;
&amp;gt; &amp;gt; size fits all&quot;.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; I don&apos;t think LockFactory ought to be exposed either. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Reading from an index &amp;#8211; any index, on any volume &amp;#8211; should Just Work.&lt;br/&gt;
&amp;gt; Writing to an index from a single IndexWriter should Just Work. In a perfect&lt;br/&gt;
&amp;gt; world, writing from multiple writers simultaneously would Just Work, too, but&lt;br/&gt;
&amp;gt; as that&apos;s inherently impractical given Lucene&apos;s current design, opening a&lt;br/&gt;
&amp;gt; second writer must fail. That failure should be the only visible evidence&lt;br/&gt;
&amp;gt; that a locking mechanism even exists.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; In my view, any deviance from that ideal API due to implementation defects&lt;br/&gt;
&amp;gt; should be handled with exceptions rather than API additions.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; In keeping with this philosophy, Lock is not publicly exposed in KinoSearch.&lt;br/&gt;
&amp;gt; In fact, nothing about the locking mechanism is publicly exposed. So far,&lt;br/&gt;
&amp;gt; there seem to be three bugs with the current implementation:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   * Stale NFS Filehandle exceptions.&lt;br/&gt;
&amp;gt;   * Stale lock files interfering with unattended indexing sessions. I plan&lt;br/&gt;
&amp;gt;     to mitigate this by moving to advisory write locks when possible.&lt;br/&gt;
&amp;gt;   * Multiple machines can cause index corruption when attempting to write&lt;br/&gt;
&amp;gt;     simultaneously to a shared volume. Moving the write.lock file to the&lt;br/&gt;
&amp;gt;     index directory, as enabled by lockless commits, solves this problem.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Once advisory file locks are in place, and if they work as expected under&lt;br/&gt;
&amp;gt; recent versions of NFS, I expect no further problems under any common, recent&lt;br/&gt;
&amp;gt; Unix.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; With the switch to lockless commits in KinoSearch, I&apos;ve able to refactor Lock&lt;br/&gt;
&amp;gt; and eliminate all of Lock&apos;s subclasses, simplifying the KinoSearch &quot;core&quot;.&lt;br/&gt;
&amp;gt; &quot;No more subclassing of Lock&quot; was originally a line-item in my list of&lt;br/&gt;
&amp;gt; &quot;great stuff&quot; about lockless commits, but I had to take it out because it&lt;br/&gt;
&amp;gt; wasn&apos;t true for Lucene!&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; With Otis signing on to your solution, it looks like momentum is gathering for&lt;br/&gt;
&amp;gt; it. For the record, I don&apos;t think it&apos;s a catastrophic change, just suboptimal&lt;br/&gt;
&amp;gt; and IMO not ready for addition until improved.&lt;/p&gt;

&lt;p&gt;I agree it would be great to reach this perfect world.  It would be&lt;br/&gt;
even better to get there in just one jump from where we are today.&lt;br/&gt;
It&apos;s just not nearly clear to me that a locking solution (or reference&lt;br/&gt;
counting, time based expiration, etc.) for NFS is or will evolve to&lt;br/&gt;
that pefect solution.  And I think &quot;not alienating users&quot; who are&lt;br/&gt;
stuck on past UNIX versions is more important than &quot;not adding any&lt;br/&gt;
API&quot;.  I think we are just picking a different &quot;lesser evil&quot;.&lt;/p&gt;

&lt;p&gt;&amp;gt; I think you can do better.&lt;/p&gt;

&lt;p&gt;With time, I hope so too.  Progress not perfection!&lt;/p&gt;</comment>
                    <comment id="12466639" author="doronc" created="Tue, 23 Jan 2007 04:25:07 +0000"  >&lt;p&gt;Michael McCandless wrote: &lt;/p&gt;

&lt;p&gt;&amp;gt; The solution I have in mind abstracts away all tricky details of&lt;br/&gt;
&amp;gt; deleting files.  EG something like:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   public class OnlyLastCommitDeleter extends IndexFileDeleter {&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;     void onInit(List commits) &lt;/p&gt;
{
&amp;gt;       onCommit(commits);
&amp;gt;     }
&lt;p&gt;&amp;gt; &lt;br/&gt;
&amp;gt;     void onCommit(List commits) {&lt;br/&gt;
&amp;gt;       if (commits.size() &amp;gt; 1) {&lt;br/&gt;
&amp;gt;         for(int i=0;i&amp;lt;commits.size()-1;i++) &lt;/p&gt;
{
&amp;gt;           deleteCommit(commits.get(i));
&amp;gt;         }
&lt;p&gt;&amp;gt;       }&lt;br/&gt;
&amp;gt;     }&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Ie, the sole responsibility of the IndexFileDeleter subclass (policy)&lt;br/&gt;
&amp;gt; is to decide when to delete a commit.  The rest of the details&lt;br/&gt;
&amp;gt; (figuring out what actual files can be deleted now that a given commit&lt;br/&gt;
&amp;gt; segments_N is deleted) are handled by the base class (with in-memory&lt;br/&gt;
&amp;gt; ref counting).&lt;br/&gt;
&amp;gt; &lt;/p&gt;

&lt;p&gt;I don&apos;t really understand this interface and so I cannot see how &lt;br/&gt;
you intend to rewrite the IndexFileDeleter as you describe, but I &lt;br/&gt;
agree that if this can be done it is a better solution. So I am &lt;br/&gt;
okay with waiting for this approach to mature into code. &lt;/p&gt;

&lt;p&gt;(I would prefer the DeletionPolicy to be a &lt;br/&gt;
pluggable &lt;b&gt;interface&lt;/b&gt; and the IndexFileDeleter to be &lt;br/&gt;
an internal &lt;b&gt;class&lt;/b&gt;, so that at least we do not expose now something &lt;br/&gt;
that would stand in our way in the future. But again, since I do not &lt;br/&gt;
fully understand your solution maybe please bear with me if this is &lt;br/&gt;
not making sense.)&lt;/p&gt;</comment>
                    <comment id="12466749" author="creamyg" created="Tue, 23 Jan 2007 15:09:15 +0000"  >&lt;p&gt;I found a flaw in my plan. If the read locks are always applied, they will&lt;br/&gt;
slow deletion of obsolete segments for everybody where delete-on-last-close&lt;br/&gt;
currently works as intended.  Right now, the files are unlinked and disappear&lt;br/&gt;
as soon as the last reader holding them open goes away.  With read locks, the&lt;br/&gt;
unlink op wouldn&apos;t take place if a reader was open.&lt;/p&gt;

&lt;p&gt;I also spent a good bit of time yesterday further researching the subtleties&lt;br/&gt;
of locks over NFS.  Summing up: flock can work, but dot-lock files are more&lt;br/&gt;
reliable.&lt;/p&gt;

&lt;p&gt;So, new proposal: &lt;/p&gt;

&lt;p&gt;Add a new public method IndexReader.aquireReadLock(String hostId), which would&lt;br/&gt;
write a dot-lock file to the index directory with hostId, a pid, and an&lt;br/&gt;
incrementing integer spliced into the file name.  The relevant segments_N file&lt;br/&gt;
name would be written to the lockfile.  Calling it would only be necessary on NFS,&lt;br/&gt;
and an exception would occur if the attempt to create the lockfile&lt;br/&gt;
failed.&lt;/p&gt;

&lt;p&gt;The deletions policy would work as in my earlier proposal, and the user&lt;br/&gt;
wouldn&apos;t have to grok its innards.  Troubleshooting stale lockfiles&lt;br/&gt;
by snooping the index directory contents would be straightforward and&lt;br/&gt;
intuitive.&lt;/p&gt;

&lt;p&gt;We might want aquireReadLock() to automatically zap any locks associated with&lt;br/&gt;
hostId for which the pid couldn&apos;t be found, or we might want to break that out&lt;br/&gt;
into another method.&lt;/p&gt;
</comment>
                    <comment id="12466840" author="mikemccand" created="Tue, 23 Jan 2007 22:00:52 +0000"  >&lt;p&gt;&amp;gt; I don&apos;t really understand this interface and so I cannot see how you&lt;br/&gt;
&amp;gt; intend to rewrite the IndexFileDeleter as you describe, but I agree&lt;br/&gt;
&amp;gt; that if this can be done it is a better solution. So I am okay with&lt;br/&gt;
&amp;gt; waiting for this approach to mature into code.&lt;/p&gt;

&lt;p&gt;The deletion policy is called on creation of a writer (onInit) and&lt;br/&gt;
once per commit (onCommit) and is given a List of existing commits (=&lt;br/&gt;
SegmentInfos instances) in the index.  The policy then decides which&lt;br/&gt;
commits should be removed and IndexFileDeleter translates that request&lt;br/&gt;
(using reference counting, because a given index file may still be&lt;br/&gt;
reference by commits that are not yet deleted) into which specific&lt;br/&gt;
files to remove.&lt;/p&gt;

&lt;p&gt;For example, onCommit you would typically see a List of length 2: the&lt;br/&gt;
prior commit and the new one.  And the default policy&lt;br/&gt;
(KeepOnlyLastCommit) would at this point remove the prior one.&lt;/p&gt;

&lt;p&gt;Realize that the &quot;commit on close&quot; mode (autoCommit=false) for&lt;br/&gt;
IndexWriter (that I&apos;m doing as part of this issue) actually keeps 2&lt;br/&gt;
SegmentInfos alive at any given time: first is the segments_N file in&lt;br/&gt;
the index, and second is the &quot;in memory&quot; SegmentInfos that haven&apos;t yet&lt;br/&gt;
been committed to a segments_N file.  It&apos;s only on close when the&lt;br/&gt;
commit takes place that the deleter then deletes the previous&lt;br/&gt;
segments_N commit.&lt;/p&gt;

&lt;p&gt;&amp;gt; (I would prefer the DeletionPolicy to be a pluggable &lt;b&gt;interface&lt;/b&gt; and&lt;br/&gt;
&amp;gt; the IndexFileDeleter to be an internal &lt;b&gt;class&lt;/b&gt;, so that at least we&lt;br/&gt;
&amp;gt; do not expose now something that would stand in our way in the&lt;br/&gt;
&amp;gt; future. But again, since I do not fully understand your solution&lt;br/&gt;
&amp;gt; maybe please bear with me if this is not making sense.)&lt;/p&gt;

&lt;p&gt;Good point: I agree an interface here is cleaner.  I will use an&lt;br/&gt;
interface (not subclass) and make IndexFileDeleter entirely internal.&lt;br/&gt;
The deletion policy doesn&apos;t need to see any details of the&lt;br/&gt;
IndexFileDeleter class.&lt;/p&gt;</comment>
                    <comment id="12466846" author="mikemccand" created="Tue, 23 Jan 2007 22:18:18 +0000"  >
&lt;p&gt;&amp;gt; I found a flaw in my plan. If the read locks are always applied,&lt;br/&gt;
&amp;gt; they will slow deletion of obsolete segments for everybody where&lt;br/&gt;
&amp;gt; delete-on-last-close currently works as intended. Right now, the&lt;br/&gt;
&amp;gt; files are unlinked and disappear as soon as the last reader holding&lt;br/&gt;
&amp;gt; them open goes away. With read locks, the unlink op wouldn&apos;t take&lt;br/&gt;
&amp;gt; place if a reader was open.&lt;/p&gt;

&lt;p&gt;Ahh good point.  This is why I don&apos;t want to risk changes to Lucene&lt;br/&gt;
core: most of the time Lucene&apos;s &quot;point in time&quot; searching works&lt;br/&gt;
perfectly now.  It&apos;s just NFS (so far) that&apos;s problematic which is why&lt;br/&gt;
I want to keep the solution &quot;external&quot; to Lucene by allowing custom&lt;br/&gt;
deletion policies.  Plus we obviously have alot of deletion policies&lt;br/&gt;
to try on NFS.  First do no harm.&lt;/p&gt;

&lt;p&gt;&amp;gt; I also spent a good bit of time yesterday further researching the&lt;br/&gt;
&amp;gt; subtleties of locks over NFS. Summing up: flock can work, but&lt;br/&gt;
&amp;gt; dot-lock files are more reliable.&lt;/p&gt;

&lt;p&gt;Well, dot-locks (= &quot;create file exclusively&quot;) have problems too.&lt;br/&gt;
There have been issues with bugs in at least certain Linux NFS&lt;br/&gt;
clients.  And Sun&apos;s Javadocs on the equivalent Java method,&lt;br/&gt;
File.createNewFile, has a warning about not relying on this for&lt;br/&gt;
locking:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile(&quot; class=&quot;external-link&quot;&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile(&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;This warning is why we created the NativeFSLockFactory for Directory&lt;br/&gt;
locking in the first place.&lt;/p&gt;

&lt;p&gt;&amp;gt; So, new proposal:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Add a new public method IndexReader.aquireReadLock(String hostId),&lt;br/&gt;
&amp;gt; which would write a dot-lock file to the index directory with&lt;br/&gt;
&amp;gt; hostId, a pid, and an incrementing integer spliced into the file&lt;br/&gt;
&amp;gt; name. The relevant segments_N file name would be written to the&lt;br/&gt;
&amp;gt; lockfile. Calling it would only be necessary on NFS, and an&lt;br/&gt;
&amp;gt; exception would occur if the attempt to create the lockfile failed.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; The deletions policy would work as in my earlier proposal, and the&lt;br/&gt;
&amp;gt; user wouldn&apos;t have to grok its innards. Troubleshooting stale&lt;br/&gt;
&amp;gt; lockfiles by snooping the index directory contents would be&lt;br/&gt;
&amp;gt; straightforward and intuitive.&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; We might want aquireReadLock() to automatically zap any locks&lt;br/&gt;
&amp;gt; associated with hostId for which the pid couldn&apos;t be found, or we&lt;br/&gt;
&amp;gt; might want to break that out into another method.&lt;/p&gt;

&lt;p&gt;OK.  You could implement this in Lucene as a custom deletion policy&lt;br/&gt;
once we get this commmitted (I think this is 6 proposals now for&lt;br/&gt;
&quot;deletion policy&quot; for NFS), plus a wrapper around IndexReader.&lt;/p&gt;
</comment>
                    <comment id="12466911" author="creamyg" created="Wed, 24 Jan 2007 05:55:36 +0000"  >&lt;p&gt;On Jan 23, 2007, at 2:19 PM, Michael McCandless (JIRA) wrote:&lt;/p&gt;

&lt;p&gt;&amp;gt; First do no harm.&lt;/p&gt;

&lt;p&gt;If that was really your guiding philosophy, you would never change anything.&lt;/p&gt;

&lt;p&gt;&amp;gt; And Sun&apos;s Javadocs on the equivalent Java method, File.createNewFile, has a&lt;br/&gt;
&amp;gt; warning about not relying on this for locking:&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile(&quot; class=&quot;external-link&quot;&gt;http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile(&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;That page recommends that you use FileLock instead, which maps to Fcntl on&lt;br/&gt;
some systems.  The FreeBSD manpage on Fcntl uses less delicate language than&lt;br/&gt;
Sun in pointing out the drawbacks:&lt;/p&gt;

&lt;p&gt;     This interface follows the completely stupid semantics of System V and&lt;br/&gt;
     IEEE Std 1003.1-1988 (``POSIX.1&apos;&apos;) that require that all locks associated&lt;br/&gt;
     with a file for a given process are removed when any file descriptor for&lt;br/&gt;
     that file is closed by that process.  This semantic means that applica-&lt;br/&gt;
     tions must be aware of any files that a subroutine library may access.&lt;/p&gt;

&lt;p&gt;Trying to guarantee that kind of discipline from library code severely limits&lt;br/&gt;
your options.&lt;/p&gt;

&lt;p&gt;&amp;gt; This warning is why we created the NativeFSLockFactory for Directory locking&lt;br/&gt;
&amp;gt; in the first place.&lt;/p&gt;

&lt;p&gt;Take a look at this bug, which explains how that warning got added.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4676183&quot; class=&quot;external-link&quot;&gt;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4676183&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Read the comment below &amp;#8211; the problem with the &quot;protocol&quot; they warn you&lt;br/&gt;
against using is with deleteOnExit(), not createNewFile().  I think you&apos;re&lt;br/&gt;
better off with dot-locks.&lt;/p&gt;

&lt;p&gt;&amp;gt; OK.  You could implement this in Lucene as a custom deletion policy once we&lt;br/&gt;
&amp;gt; get this commmitted (I think this is 6 proposals now for &quot;deletion policy&quot;&lt;br/&gt;
&amp;gt; for NFS), plus a wrapper around IndexReader.&lt;/p&gt;

&lt;p&gt;This was the response I got on the KinoSearch list:&lt;/p&gt;

&lt;p&gt;    We do not enable NFS writes, only reads (which is why Slashdot is able to&lt;br/&gt;
    reliably use NFS for its heavy load &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.  So I don&apos;t think that will work,&lt;br/&gt;
    if I understand you correctly.&lt;/p&gt;

&lt;p&gt;Lack of bulletproof support for NFS ain&apos;t gonna hold up my next release any&lt;br/&gt;
longer.  What a freakin&apos; nightmare...&lt;/p&gt;</comment>
                    <comment id="12466926" author="doronc" created="Wed, 24 Jan 2007 07:00:39 +0000"  >&lt;p&gt;&amp;gt; The deletion policy is called on creation of a writer (onInit) and&lt;br/&gt;
&amp;gt; once per commit (onCommit) and is given a List of existing commits (=&lt;br/&gt;
&amp;gt; SegmentInfos instances) in the index.  The policy then decides which&lt;br/&gt;
&amp;gt; commits should be removed and IndexFileDeleter translates that request&lt;br/&gt;
&amp;gt; (using reference counting, because a given index file may still be&lt;br/&gt;
&amp;gt; reference by commits that are not yet deleted) into which specific&lt;br/&gt;
&amp;gt; files to remove.&lt;br/&gt;
&amp;gt; ...&lt;/p&gt;

&lt;p&gt;Michael thanks for explaining this further - yes, now it makes sense to me. &lt;/p&gt;</comment>
                    <comment id="12477339" author="mikemccand" created="Fri, 2 Mar 2007 15:52:01 +0000"  >&lt;p&gt;OK, I&apos;ve attached a patch to implement &quot;commit on close&quot; and &quot;custom&lt;br/&gt;
deletion policies&quot;.  The design is exactly what&apos;s described above.&lt;/p&gt;

&lt;p&gt;There are no changes to the file format.&lt;/p&gt;

&lt;p&gt;All tests pass and I&apos;ve added additional tests for this new&lt;br/&gt;
functionality.&lt;/p&gt;

&lt;p&gt;Summary of the external changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;For &quot;commit on close&quot;:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added new IndexWriter constructors that take &quot;autoCommit&quot;&lt;br/&gt;
      boolean: if it&apos;s false, then readers will not see any actions&lt;br/&gt;
      done by this writer (no new segments_N is written) until&lt;br/&gt;
      writer.close() is called.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added IndexWriter.abort() which closes the writer without&lt;br/&gt;
      committing, cleaning up any temp files it had added to the&lt;br/&gt;
      index.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;For &quot;custom deletion policies&quot;:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Created IndexDeletionPolicy interface and added constructors to&lt;br/&gt;
      IndexReader/IndexWriter allowing you to specify a deletion&lt;br/&gt;
      policy.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Created IndexCommitPoint interface: this is passed to the&lt;br/&gt;
      deletion policy to represent each commit.  The policy calls the&lt;br/&gt;
      delete method on this interface to remove a commit.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Created one deletion policy (KeepOnlyLastCommitDeletionPolicy)&lt;br/&gt;
      and made that the default policy.  (The unit test for this has&lt;br/&gt;
      other &quot;interesting&quot; policies like &quot;delete by age since this&lt;br/&gt;
      commit was obsoleted&quot; initially discussed on java-dev.)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Summary of internal changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Created &quot;files()&quot; method in SegmentInfo (and changed&lt;br/&gt;
    SegmentReader.files() to use it).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed IndexFileDeleter to use reference counting to keep track&lt;br/&gt;
    of which files are deletable because no commit(s) (nor the&lt;br/&gt;
    in-memory SegmentInfos) reference them.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This is a nice simplification of IndexFileDeleter: previously it&lt;br/&gt;
    had detailed knowledge about which files, extensions, etc., to&lt;br/&gt;
    look for and delete.  Now it has far less of that because it&lt;br/&gt;
    relies entirely on SegmentInfo.files() to compute that.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Changed IndexReader/IndexWriter to not directly delete files and&lt;br/&gt;
    instead notify IndexFileDeleter when there has been a change to&lt;br/&gt;
    the in-memory SegmentInfos.  The deleter then incref/decref&apos;s to&lt;br/&gt;
    determine what files can safely be deleted.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This is also a nice simplification for the same reason as above:&lt;br/&gt;
    now the writers just make changes to SegmentInfo(s) without having&lt;br/&gt;
    to compute/track the consequences to specific index files.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Simplified the fix for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-702&quot; title=&quot;Disk full during addIndexes(Directory[]) can corrupt index&quot;&gt;&lt;del&gt;LUCENE-702&lt;/del&gt;&lt;/a&gt; (addIndexes corrupts index on&lt;br/&gt;
    disk full) to just temporarily set autoCommit=false if it&apos;s not&lt;br/&gt;
    already.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added get/setDefaultInfoStream to IndexWriter so you could see&lt;br/&gt;
    things that happen during IndexWriter constructor.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;No longer store/propogate persistent IndexFileDelter inside&lt;br/&gt;
    IndexReader (removed protected method get/setDeleter).  This is a&lt;br/&gt;
    nice simplification because the deleter is now only needed briefly&lt;br/&gt;
    during &quot;commit()&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Reworked the toplevel javadoc for IndexWriter.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added try/finally to remove a partially written segments_N if we&lt;br/&gt;
    hit IOException when trying to write it.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Other small change (small refactoring, fixes to javadocs, fixed&lt;br/&gt;
    spelling, etc).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12478728" author="mikemccand" created="Wed, 7 Mar 2007 09:56:35 +0000"  >&lt;p&gt;Rebased the patch to the current trunk.  I plan to commit this probably end of this week.&lt;/p&gt;</comment>
                    <comment id="12479511" author="doronc" created="Fri, 9 Mar 2007 06:26:45 +0000"  >&lt;p&gt;Mike, patching take2 on current trunk fails for IndexFileDeleter.java.&lt;br/&gt;
  patching file src/java/org/apache/lucene/index/IndexFileDeleter.java&lt;br/&gt;
    Hunk #1 FAILED at 18.&lt;br/&gt;
Also some noise in SegmentInfo.java&lt;br/&gt;
  patching file src/java/org/apache/lucene/index/SegmentInfo.java&lt;br/&gt;
    Hunk #7 succeeded at 291 (offset 3 lines).&lt;/p&gt;
</comment>
                    <comment id="12479547" author="mikemccand" created="Fri, 9 Mar 2007 09:44:04 +0000"  >&lt;p&gt;Woops, looks like the commit for &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-825&quot; title=&quot;NullPointerException from SegmentInfos.FindSegmentsFile.run() if FSDirectory.list() returns NULL &quot;&gt;&lt;del&gt;LUCENE-825&lt;/del&gt;&lt;/a&gt; messed up the patch.  OK I updated and re-diff&apos;d and attached take3.&lt;/p&gt;

&lt;p&gt;It&apos;s too bad we don&apos;t have a patch that&apos;s better integrated with svn such that if even you have a more recent svn revision checked out, applying the patch would do so back against the revision it was based on, and then svn would merge the changes committed to the trunk since then.  In this case an svn update on the checkout with the diffs produced no conflicts, so if we had such a combined patch tool, it would have worked find here.  I suppose the person applying the patch could first &quot;svn update&quot; to its base revision, apply the patch, then svn up, but that&apos;s kind of a hassle&lt;/p&gt;</comment>
                    <comment id="12481100" author="doronc" created="Thu, 15 Mar 2007 10:08:50 +0000"  >&lt;p&gt;I was too slow in reviewing this, so while I was studying the new code it was committed... &lt;/p&gt;

&lt;p&gt;Anyhow I have a few comments and a question - I think JIRA &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-710&quot; title=&quot;Implement &amp;quot;point in time&amp;quot; searching without relying on filesystem semantics&quot;&gt;&lt;del&gt;LUCENE-710&lt;/del&gt;&lt;/a&gt; is still the place for this discussion even though the issue is already resolved. &lt;/p&gt;

&lt;p&gt;The attached 710.comments.diff  implements a few suggested changes.&lt;/p&gt;

&lt;p&gt;I like the definition and use of IndexDeletePolicy and CommitPoint - this is very flexible and clear, and would indeed allow to implement NFS suited logic. These two concepts are central to implementing such logic, and I thought their Javadocs should be enhanced (included in the attached).&lt;/p&gt;

&lt;p&gt;IndexFileDeleter - it is nice that this became non public and somewhat simpler. I added some internal documentation (not javadocs) in that file as I learned how it works. I think these would be useful for others diving into this code. I also modified some variable names for clarity (in the attached). &lt;/p&gt;

&lt;p&gt;I don&apos;t understand yet why we allow a deletion policy to delete &lt;b&gt;all&lt;/b&gt; commits (including the most recent) - TestDeletionPolicy explains this as: &quot;This is useful for adding to a big index w/ autoCommit =false when you know readers are not using it.&quot; - so, would I risk losing the big index should uncommited additions fail? what does one earn by this? I first thought we should prevent (exception) deleting the most recent commit, but I must be missing something - could you elaborate on this?&lt;/p&gt;

&lt;p&gt;checkpoints() is another - more internal - new concept in this code. At writing this I don&apos;t fully understand it. IndexWriter has its own checkpoint() method, but it also calls IndexFileDeleter.checkpoint(). IndexReader only calls IndexFileDeletion.checkpoint() - it does not have a checkpoint() itself.   ...mmm... For IndexReader it makes sense since it always commits only at close(), or at explicit calls to commit(). Perhaps I understand it better now... Ok, I added some documentation for this in IndexWriter, I think it would also help others. (in the attached.)&lt;/p&gt;

&lt;p&gt;This issue also introduced constants for file names - hasSingleNorms (i.e. nrm)  and SINGLE_NORMS_EXTENSION (.fN) were confusing/collating - so I modified .fN to PLAIN_NORMS_EXTENSION.&lt;/p&gt;

&lt;p&gt;This issue moved some files logic SegmentInfo. The -1/1/0 logic and especially with norms is confusing, and at least I have to re-read the code carefully each time again and again to be convinced that it is correct. It would be nice when we can get rid of some of the backward compatibility cases here. Anyhow I added some documentation and also replaced the -1/1/0 with constants, I think this makes it easier to understand.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Doron&lt;/p&gt;</comment>
                    <comment id="12481122" author="mikemccand" created="Thu, 15 Mar 2007 12:14:57 +0000"  >&lt;p&gt;Thanks for the review Doron!&lt;/p&gt;

&lt;p&gt;Your added comments &amp;amp; improvements to the variable names are&lt;br/&gt;
excellent.  I especially like the new constants (YES, NO, CHECK_DIR,&lt;br/&gt;
etc.) in SegmentInfo.  I&apos;ve tweaked your patch here and there, and&lt;br/&gt;
attached a modified patch (710.review.take2.diff).  If you&apos;re happy&lt;br/&gt;
with that then go ahead and commit it?&lt;/p&gt;

&lt;p&gt;&amp;gt; IndexFileDeleter - it is nice that this became non public and somewhat&lt;br/&gt;
&amp;gt; simpler.&lt;/p&gt;

&lt;p&gt;I especially like that this class now has very little knowledge of&lt;br/&gt;
what files &quot;belong&quot; to an index, especially compared to before.  That&lt;br/&gt;
knowledge has now been consolidated under SegmentInfo which I think is&lt;br/&gt;
the right place for it.&lt;/p&gt;

&lt;p&gt;&amp;gt; I don&apos;t understand yet why we allow a deletion policy to delete&lt;br/&gt;
&amp;gt; &lt;b&gt;all&lt;/b&gt; commits (including the most recent) - TestDeletionPolicy&lt;br/&gt;
&amp;gt; explains this as: &quot;This is useful for adding to a big index w/&lt;br/&gt;
&amp;gt; autoCommit =false when you know readers are not using it.&quot; - so,&lt;br/&gt;
&amp;gt; would I risk losing the big index should uncommited additions fail?&lt;br/&gt;
&amp;gt; what does one earn by this? I first thought we should prevent&lt;br/&gt;
&amp;gt; (exception) deleting the most recent commit, but I must be missing&lt;br/&gt;
&amp;gt; something - could you elaborate on this?&lt;/p&gt;

&lt;p&gt;The use case I was thinking of is: say you already have a large index&lt;br/&gt;
and then you need to add a bunch more docs to it.  If you are not&lt;br/&gt;
allowed to delete the starting commit, then, you will consume&lt;br/&gt;
substantially more disk space as you are building your index because&lt;br/&gt;
the large segments at the start can&apos;t be removed.  This would have&lt;br/&gt;
made the &quot;autoCommit false&quot; case unnecessarily worse than the&lt;br/&gt;
&quot;autoCommit true&quot; case.  If for a given application the developer is&lt;br/&gt;
concerned about safety (losing index due to crash), then the normal&lt;br/&gt;
default policy should be used.&lt;/p&gt;

&lt;p&gt;&amp;gt; This issue moved some files logic SegmentInfo. The -1/1/0 logic and&lt;br/&gt;
&amp;gt; especially with norms is confusing, and at least I have to re-read&lt;br/&gt;
&amp;gt; the code carefully each time again and again to be convinced that it&lt;br/&gt;
&amp;gt; is correct. It would be nice when we can get rid of some of the&lt;br/&gt;
&amp;gt; backward compatibility cases here. Anyhow I added some documentation&lt;br/&gt;
&amp;gt; and also replaced the -1/1/0 with constants, I think this makes it&lt;br/&gt;
&amp;gt; easier to understand.&lt;/p&gt;

&lt;p&gt;Yes the backwards compatibility code (for pre-2.1 indices) is complex.&lt;br/&gt;
The good news is by the time we release this in 2.2, most indices that&lt;br/&gt;
upgrade to 2.2 will be 2.1.&lt;/p&gt;</comment>
                    <comment id="12481290" author="doronc" created="Thu, 15 Mar 2007 19:30:03 +0000"  >&lt;p&gt;&amp;gt; If for a given application the developer is concerned &lt;br/&gt;
&amp;gt; about safety (losing index due to crash), then the &lt;br/&gt;
&amp;gt; normal default policy should be used. &lt;/p&gt;

&lt;p&gt;Spooky... what if onCommit() also deletes all commits?  &lt;br/&gt;
(Might this be a pit for users to fall in...?)&lt;/p&gt;

&lt;p&gt;I added warnings about this in IndexDeletionPolicy methods.&lt;/p&gt;

&lt;p&gt;Just commiited review.take2 + these comments.&lt;/p&gt;</comment>
                    <comment id="12481346" author="mikemccand" created="Thu, 15 Mar 2007 22:31:12 +0000"  >&lt;p&gt;&amp;gt; I added warnings about this in IndexDeletionPolicy methods.&lt;/p&gt;

&lt;p&gt;I think that&apos;s good.  Thanks!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12353363" name="710.review.diff" size="26105" author="doronc" created="Thu, 15 Mar 2007 10:08:49 +0000" />
                    <attachment id="12353369" name="710.review.take2.diff" size="26270" author="mikemccand" created="Thu, 15 Mar 2007 12:14:57 +0000" />
                    <attachment id="12352438" name="LUCENE-710.patch" size="165953" author="mikemccand" created="Fri, 2 Mar 2007 15:52:01 +0000" />
                    <attachment id="12352818" name="LUCENE-710.take2.patch" size="166233" author="mikemccand" created="Wed, 7 Mar 2007 09:56:35 +0000" />
                    <attachment id="12352965" name="LUCENE-710.take3.patch" size="166591" author="mikemccand" created="Fri, 9 Mar 2007 09:44:04 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 19 Jan 2007 18:25:43 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13042</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27020</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>