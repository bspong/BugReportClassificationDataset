<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:05:37 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-690/LUCENE-690.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-690] LazyField use of IndexInput not thread safe</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-690</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Hypothetical problem: IndexInput.clone() of an active IndexInput could result in a corrupt copy.&lt;br/&gt;
LazyField clones the FieldsReader.fieldsStream, which could be in use via IndexReader.document()&lt;/p&gt;</description>
                <environment></environment>
            <key id="12353613">LUCENE-690</key>
            <summary>LazyField use of IndexInput not thread safe</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Thu, 19 Oct 2006 18:06:43 +0100</created>
                <updated>Tue, 27 Feb 2007 18:10:35 +0000</updated>
                    <resolved>Fri, 20 Oct 2006 04:07:53 +0100</resolved>
                            <version>2.1</version>
                                <fixVersion>2.1</fixVersion>
                                <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12443587" author="gsingers" created="Thu, 19 Oct 2006 18:29:29 +0100"  >&lt;p&gt;Not sure why this is different then anywhere else IndexInput.clone() is used, can you provide more details?  Isn&apos;t the whole point of cloning to make it thread safe (which is why it is stored in the ThreadLocal)&lt;/p&gt;</comment>
                    <comment id="12443595" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 18:44:08 +0100"  >&lt;p&gt;It seems to me like if you clone an object in an unknown state, you get another object in an unknown state unless it&apos;s clone() is able to explicitly put it back into a known state.&lt;/p&gt;

&lt;p&gt;Let&apos;s take TermDocs as an example of why it&apos;s use is OK:&lt;br/&gt;
SegmentTermDocs() &lt;b&gt;always&lt;/b&gt; makes a clone of the SegmentReader&apos;s freqStream, and the SegmentReader itself never directly uses the freqStream (and hence freqStream is used for nothing other than cloneing).  &lt;br/&gt;
This analysis only takes into account SegmentTermDocs and SegmentReader... if there is another class that directly uses SegmentReader.freqStream, then all bets are off again.&lt;/p&gt;

&lt;p&gt;I don&apos;t know if all other clones() of IndexInput are safe, but it does seem like LazyField&apos;s use is unsafe.&lt;/p&gt;</comment>
                    <comment id="12443600" author="gsingers" created="Thu, 19 Oct 2006 19:12:37 +0100"  >&lt;p&gt;Defnitely an issue for a closed IndexInput, but that has been discussed elsewhere and there isn&apos;t really anything satisfying to say there other than it is undeclared what will happen (although my tests on local Directories indicate that it is &quot;safe&quot; in a simple environment).&lt;/p&gt;

&lt;p&gt;Otherwise,  my understanding is that the seek() call before reading should put it into a known state, but I am guessing your not so sure on that point.  So the question is seek() sufficient to put an IndexInput into a known safe state, right?&lt;/p&gt;

&lt;p&gt;If it doesn&apos;t, what would you suggest for a fix?  I suppose maybe you could clone it as you create the LazyField (which would put it in right at the correct position and there would be no need to seek, right)  This would save a little time at the tradeoff of memory, right?&lt;/p&gt;</comment>
                    <comment id="12443611" author="gsingers" created="Thu, 19 Oct 2006 19:59:36 +0100"  >&lt;p&gt;Comment from Hoss, which I think should be on the issue:&lt;/p&gt;

&lt;p&gt;: Otherwise, my understanding is that the seek() call before reading&lt;br/&gt;
: should put it into a known state, but I am guessing your not so sure on&lt;br/&gt;
: that point.  So the question is seek() sufficient to put an IndexInput&lt;br/&gt;
: into a known safe state, right?&lt;/p&gt;

&lt;p&gt;isn&apos;t it more subtle then that? ... IndexInput.clone() states that the&lt;br/&gt;
clone will be &quot;positioned at the same point as the stream they were cloned&lt;br/&gt;
from&quot; ... that implies that the clone will be in a consistent usable state&lt;br/&gt;
even with the client calling seek on the clone() .... is that&lt;br/&gt;
invarient currently met by BufferedIndexInput in a multithreaded case?&lt;/p&gt;




&lt;p&gt;-Hoss&lt;/p&gt;</comment>
                    <comment id="12443621" author="gsingers" created="Thu, 19 Oct 2006 20:21:00 +0100"  >&lt;p&gt;Possibly reading wrong, but it seems like that invariant is not met by BufferedIndexInput, right?&lt;/p&gt;

&lt;p&gt;If clone was called while the IndexInput was in the refill() operation before readInternal() was called but after the buffer was allocated (i.e. line 64) and then clone finished it would copy an empty buffer on line 103, right?  This would be bad, b/c I don&apos;t see that it could recover from an empty buffer there when it thinks it has data.&lt;/p&gt;

&lt;p&gt;So, I guess that would argue that it is not safe and that we should aggressively clone (b/c we know it is in a good state) or that we should synchronize, right? &lt;/p&gt;
</comment>
                    <comment id="12443625" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 20:25:14 +0100"  >&lt;p&gt;: If clone was called while the IndexInput was in the refill() operation before readInternal() was called but after the buffer was allocated (i.e. line 64) and then clone finished it would copy an empty buffer on line 103, right?&lt;/p&gt;

&lt;p&gt;Correct.  BufferedIndexInput also has multiple &quot;pointers&quot;, and in the absense of synchronization, you can&apos;t guarantee the order that things will be flushed back to memory.&lt;/p&gt;

&lt;p&gt;: So, I guess that would argue that it is not safe and that we should aggressively clone (b/c we know it is in a good state) or that we should synchronize, right?&lt;/p&gt;

&lt;p&gt;Right, you either never use what you are cloning, or you synchronize.&lt;/p&gt;</comment>
                    <comment id="12443628" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 20:32:29 +0100"  >&lt;p&gt;On 10/19/06, Ning Li &amp;lt;ning.li.li@gmail.com&amp;gt; wrote:&lt;br/&gt;
&amp;gt; What makes, for example, FSIndexInput and its clones, thread-safe is&lt;br/&gt;
&amp;gt; the following.&lt;br/&gt;
&amp;gt; That is, the method is synchronized on the file object.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;   protected void readInternal(byte[] b, int offset, int len)&lt;br/&gt;
&amp;gt;        throws IOException {&lt;br/&gt;
&amp;gt;     synchronized (file) {&lt;/p&gt;

&lt;p&gt;I don&apos;t think that&apos;s sufficient in part because the IndexInput&apos;s state is manipulated outside that sync block.  The sync block is to protect the file only, not the IndexInput, which isn&apos;t thread-safe (by design).&lt;/p&gt;

&lt;p&gt;Look at BufferedIndexInput.seek() and BufferedIndexInput.refill()&lt;/p&gt;</comment>
                    <comment id="12443629" author="gsingers" created="Thu, 19 Oct 2006 20:49:14 +0100"  >&lt;p&gt;Do you have a preference on aggressive cloning vs. synching?  cloning is easier to implement, but then the Field is no longer as lazy as it could be, on the other hand synching on the fieldsStream in LazyField and doc() could be pretty expensive, too, right?&lt;/p&gt;</comment>
                    <comment id="12443638" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 21:18:00 +0100"  >&lt;p&gt;Here&apos;s one possible patch... not sure if it&apos;s the best approach or not.&lt;/p&gt;</comment>
                    <comment id="12443640" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 21:27:01 +0100"  >&lt;p&gt;&amp;gt; Do you have a preference on aggressive cloning vs. synching?&lt;/p&gt;

&lt;p&gt;Not too much... synching was presumably avoided for better concurrency.  If we wanted to sync in LazyField, it would currently need to be on the SegmentReader object, since that&apos;s the monitor protecting the fieldStream.&lt;/p&gt;

&lt;p&gt;Could also perhaps lazily create the &quot;cloneable stream&quot;  the first time a lazy field is created, since we are currently in a synchronized context when that happens.&lt;/p&gt;

&lt;p&gt;A different route would be to convert normal document() loading to also use thread-local fieldStreams for better concurrency.  It would mean a thread-local lookup per document though, and I&apos;m not sure what the expense of that would be.&lt;/p&gt;</comment>
                    <comment id="12443642" author="gsingers" created="Thu, 19 Oct 2006 21:35:47 +0100"  >&lt;p&gt;Patch seems reasonable, and your idea of waiting till we have a lazy field before cloning seems reasonable, as my guess is, at least for now, that Lazy Fields are not in widespread use just yet.&lt;/p&gt;</comment>
                    <comment id="12443650" author="paul.elschot@xs4all.nl" created="Thu, 19 Oct 2006 22:18:42 +0100"  >&lt;p&gt;I have not followed this, but some time ago I&apos;ve had a problem with cloning and BufferedIndexInput, see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-430&quot; title=&quot;Reducing buffer sizes for TermDocs.&quot;&gt;&lt;del&gt;LUCENE-430&lt;/del&gt;&lt;/a&gt;.&lt;br/&gt;
Searching jira for BufferedIndexInput gives 5 hits currently.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12443682" author="yseeley@gmail.com" created="Fri, 20 Oct 2006 04:07:53 +0100"  >&lt;p&gt;OK, I committed this fix for now.&lt;br/&gt;
For BufferedIndexInput, the buffer is allocated lazily, so the extra clone doesn&apos;t use much space.&lt;/p&gt;</comment>
                    <comment id="12443702" author="yseeley@gmail.com" created="Fri, 20 Oct 2006 06:10:35 +0100"  >&lt;p&gt;OK, this problem is no longer hypothetical!&lt;br/&gt;
I was able to produce a test that failed quickly most of the time w/o the patch.&lt;br/&gt;
I&apos;ve just committed it.&lt;/p&gt;</comment>
                    <comment id="12476268" author="mikemccand" created="Tue, 27 Feb 2007 18:10:35 +0000"  >&lt;p&gt;Closing all issues that were resolved for 2.1.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                <outwardlinks description="blocks">
                            <issuelink>
            <issuekey id="12352674">SOLR-52</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12343294" name="FieldsReader.patch" size="3113" author="yseeley@gmail.com" created="Thu, 19 Oct 2006 21:18:00 +0100" />
                    <attachment id="12343314" name="TestThreadSafe.java" size="4719" author="yseeley@gmail.com" created="Fri, 20 Oct 2006 06:10:35 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 19 Oct 2006 17:29:29 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13062</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27040</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>