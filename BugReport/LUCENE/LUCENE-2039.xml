<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:35:38 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2039/LUCENE-2039.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2039] Regex support and beyond in JavaCC QueryParser</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2039</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Since the early days the standard query parser was limited to the queries living in core, adding other queries or extending the parser in any way always forced people to change the grammar file and regenerate. Even if you change the grammar you have to be extremely careful how you modify the parser so that other parts of the standard parser are affected by customisation changes. Eventually you had to live with all the limitation the current parser has like tokenizing on whitespaces before a tokenizer / analyzer has the chance to look at the tokens. &lt;br/&gt;
I was thinking about how to overcome the limitation and add regex support to the query parser without introducing any dependency to core. I added a new special character that basically prevents the parser from interpreting any of the characters enclosed in the new special characters. I choose the forward slash  &apos;/&apos; as the delimiter so that everything in between two forward slashes is basically escaped and ignored by the parser. All chars embedded within forward slashes are treated as one token even if it contains other special chars like * []?{} or whitespaces. This token is subsequently passed to a pluggable &quot;parser extension&quot; with builds a query from the embedded string. I do not interpret the embedded string in any way but leave all the subsequent work to the parser extension. Such an extension could be another full featured query parser itself or simply a ctor call for regex query. The interface remains quiet simple but makes the parser extendible in an easy way compared to modifying the javaCC sources.&lt;/p&gt;

&lt;p&gt;The downsides of this patch is clearly that I introduce a new special char into the syntax but I guess that would not be that much of a deal as it is reflected in the escape method though. It would truly be nice to have more than once extension an have this even more flexible so treat this patch as a kickoff though.&lt;/p&gt;

&lt;p&gt;Another way of solving the problem with RegexQuery would be to move the JDK version of regex into the core and simply have another method like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; Query newRegexQuery(Term t) {
  ... 
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;which I would like better as it would be more consistent with the idea of the query parser to be a very strict and defined parser.&lt;/p&gt;

&lt;p&gt;I will upload a patch in a second which implements the extension based approach I guess I will add a second patch with regex in core soon too.&lt;/p&gt;
</description>
                <environment></environment>
            <key id="12440050">LUCENE-2039</key>
            <summary>Regex support and beyond in JavaCC QueryParser</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="simonw">Simon Willnauer</assignee>
                                <reporter username="simonw">Simon Willnauer</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 Nov 2009 18:39:59 +0000</created>
                <updated>Fri, 10 May 2013 11:34:20 +0100</updated>
                    <resolved>Sat, 22 Sep 2012 12:33:36 +0100</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                <fixVersion>4.0</fixVersion>
                                <component>core/queryparser</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>5</watches>
                                                    <comments>
                    <comment id="12774358" author="simonw" created="Fri, 6 Nov 2009 18:40:49 +0000"  >&lt;p&gt;attached extension based patch&lt;/p&gt;</comment>
                    <comment id="12774364" author="thetaphi" created="Fri, 6 Nov 2009 18:48:19 +0000"  >&lt;p&gt;I do not like this extension.&lt;/p&gt;

&lt;p&gt;In my opinion, we should simply use the new QueryParser framework for it, where it is quite easy to plugin support for RegExQueries even if they live in contrib. &lt;/p&gt;</comment>
                    <comment id="12774568" author="gsingers" created="Sat, 7 Nov 2009 08:01:07 +0000"  >&lt;p&gt;The new QP framework is not proven out and doesn&apos;t have very many people using it and is still in contrib.  This extension allows for a pretty simple way for people to add simple extensions to the current QP without having to do a whole lot of programming.&lt;/p&gt;</comment>
                    <comment id="12776023" author="lafa" created="Tue, 10 Nov 2009 19:17:45 +0000"  >&lt;p&gt;I agree with Uwe,&lt;/p&gt;

&lt;p&gt;I think we should implement this on the new queryparser using the opaque terms framework described in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1823&quot; title=&quot;QueryParser with new features for Lucene 3&quot;&gt;LUCENE-1823&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The current implementation of this patch will create backward compatibility syntax problems, for queries using &quot;/&quot; characters&lt;br/&gt;
for example &quot;file paths&quot; or &quot;urls&quot; would be affected. If we are doing this we should change the syntax to allow for opaque terms.&lt;/p&gt;

&lt;p&gt;When we have support for opaque terms in the new queryparser, we can implement regex support with it.&lt;/p&gt;

&lt;p&gt;Opaque terms, is a framework to extend the queryparser syntax to bypass parts of the query  to a smaller parsing code (not a full parser), or a analyzer, and allow extensions of the query syntax as needed, without requiring changing the lucene code.&lt;/p&gt;</comment>
                    <comment id="12776043" author="gsingers" created="Tue, 10 Nov 2009 19:45:32 +0000"  >&lt;p&gt;I have a need for this in the Lucene Query Parser.  It simply isn&apos;t practical for me to switch to using the contrib Query Parser as that would involve a fair amount of changes in the application.  As for the back compat issue, I think we can work around that by having a flag set.  I&apos;ll look into it a bit more.&lt;/p&gt;</comment>
                    <comment id="12776048" author="rcmuir" created="Tue, 10 Nov 2009 19:51:51 +0000"  >&lt;p&gt;regardless of which query parser, I think it would be nice to have regex support in some query parser available.&lt;/p&gt;

&lt;p&gt;doesn&apos;t query parser now take Version as a required argument? Maybe the back compat issue could be solved with that???&lt;/p&gt;</comment>
                    <comment id="12776050" author="simonw" created="Tue, 10 Nov 2009 19:54:14 +0000"  >&lt;p&gt;I totally see you point but on the other hand I really miss the option to extend the old-fashion query parser. I do not see the new parser being THE lucene query parser by now.Many many people are using the javaCC parser and will do so in the future. I possibly have another solution which preserves backwards compatibility and would support the query extension too.&lt;/p&gt;

&lt;p&gt;The alternative idea is to utilize the fact that queries enclosed in double quotes are passed to getFieldQuery() and are not interpreted by the grammar. Extension queries could be embedded in quotes while the content needs to be escaped. (that is already the case though. To identify which extension should be used we could utilize the field name and a pattern so that users could plug in extension mapped to some field name pattern. Something like: re_field:&quot;^.&amp;#42;$&quot; -&amp;gt; (re_field, RegexExtension) &lt;/p&gt;

&lt;p&gt;that would not change anything in the parser as long as no extension is registered. No new character and no backwards compat issues. &lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12776057" author="simonw" created="Tue, 10 Nov 2009 20:14:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think we can work around that by having a flag set. I&apos;ll look into it a bit more. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Grant, JavaCC only generates parsers, a flag is a semantic check. You need to do a lot more work to do those checks. First step would be to build a tree using jjtree. Then you need to build the symbol table and then you can traverse the tree to do your checks.&lt;/p&gt;

&lt;p&gt;One solution would be creating a parser from two javacc files one for &amp;lt; 3.0 and one or 3.0 - something like robert suggested. Then we could use the Version to choose the corresponding parser impl. &lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12776058" author="rcmuir" created="Tue, 10 Nov 2009 20:14:31 +0000"  >&lt;p&gt;Simon, personally I would prefer the Version argument used for such things.&lt;/p&gt;

&lt;p&gt;I know this isn&apos;t popular, but I&apos;d actually be for having say, a 3.0 javacc grammar file that differs from the 2.9 one, with version driving it.&lt;/p&gt;

&lt;p&gt;yeah it would be duplicated code, but its mostly auto-generated code anyway, and I think it would be simple to understand what is going on.&lt;/p&gt;</comment>
                    <comment id="12776123" author="lafa" created="Tue, 10 Nov 2009 22:30:44 +0000"  >&lt;p&gt;Hi Simon, &lt;/p&gt;

&lt;p&gt;I think one problem lucene has today, is that the queryparser code in very tightly integrated with the javacc code. If we continue to do that it will always be very difficult to create a standard way of making small changes to the current queryparser.&lt;/p&gt;

&lt;p&gt;I like the implementation proposed by Simon, is very similar to the opaque term idea, but I would prefer not to overload the fileds names.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The alternative idea is to utilize the fact that queries enclosed in double quotes are passed to getFieldQuery() and are not interpreted by the grammar. Extension queries could be embedded in quotes while the content needs to be escaped. (that is already the case though. To identify which extension should be used we could utilize the field name and a pattern so that users could plug in extension mapped to some field name pattern. Something like: re_field:&quot;^.*$&quot; -&amp;gt; (re_field, RegexExtension)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We should decouple the user extensions from the JAVACC generated code. Just like in the new queryparser framework does, the queryparser should allow for the user to register these extensions at run time, and have Interface that extensions should implement.&lt;/p&gt;

&lt;p&gt;For example, something like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
QueryParser  qp = QueryParserFactory.getInstance(&lt;span class=&quot;code-quote&quot;&gt;&quot;3.0&quot;&lt;/span&gt;);
qp.registerOpaqueTerm(&lt;span class=&quot;code-quote&quot;&gt;&quot;regexp&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryParserRegExpParser());
qp.registerOpaqueTerm(&lt;span class=&quot;code-quote&quot;&gt;&quot;complex_phrases&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryParserComplexPhraseParser());
...
qp.parser(&lt;span class=&quot;code-quote&quot;&gt;&quot; regexp:\&quot;&lt;/span&gt;/blah*/\&lt;span class=&quot;code-quote&quot;&gt;&quot; complex_phrase:\&quot;&lt;/span&gt;(sun OR sunny) sky\&lt;span class=&quot;code-quote&quot;&gt;&quot; &quot;&lt;/span&gt;,...);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Of course this is not possible with the lucene queryparser code today &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;,&lt;br/&gt;
but this is the idea I think we should try to implement.&lt;/p&gt;

&lt;p&gt;For the problem of field overload:&lt;br/&gt;
In your proposal we lose the field name information for the extensions, so we need to another solution that would allow the fieldname to be available for the extensions.&lt;/p&gt;

&lt;p&gt;Here is another idea, that would allow for fieldnames not to be overloaded,&lt;br/&gt;
and allow regular term or phrase syntax for extensions.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
syntax:
extension:fieldname:&lt;span class=&quot;code-quote&quot;&gt;&quot;syntax&quot;&lt;/span&gt;

examples:
regexp:title:&lt;span class=&quot;code-quote&quot;&gt;&quot;/blah[a-z]+[0-9]+/&quot;&lt;/span&gt;  &amp;lt;- regexp extension, title index field
complex_phrase:title:&lt;span class=&quot;code-quote&quot;&gt;&quot;(sun OR sunny) sky&quot;&lt;/span&gt; &amp;lt;- complex_phrase extension, title index field

regexp_phrase::&lt;span class=&quot;code-quote&quot;&gt;&quot;/blah[a-z]+[0-9]+/&quot;&lt;/span&gt;  &amp;lt;- regexp extension, &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; field
complex_phrase::&lt;span class=&quot;code-quote&quot;&gt;&quot;(sun OR sunny) sky&quot;&lt;/span&gt; &amp;lt;- complex_phrase extension, &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; field

title:&lt;span class=&quot;code-quote&quot;&gt;&quot;blah&quot;&lt;/span&gt; &amp;lt;- regular field query

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                    <comment id="12776139" author="lafa" created="Tue, 10 Nov 2009 23:00:20 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Grant, JavaCC only generates parsers, a flag is a semantic check. You need to do a lot more work to do those checks. &lt;br/&gt;
First step would be to build a tree using jjtree. &lt;br/&gt;
Then you need to build the symbol table and then you can traverse the tree to do your checks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the new queryparser we don&apos;t use jjtree, but the same concept is implemented in the new queryparser, &lt;br/&gt;
the ouput from the SyntaxParser interface is a syntax tree, this tree is not related with any lucene objects just like jjtree.&lt;br/&gt;
But I think this is a ugly solution.&lt;/p&gt;

&lt;p&gt;I think if we use the new queryparser, it allows for multiple SyntaxParsers to use the same Processors and the Builders.&lt;br/&gt;
And with a small implementation of a SyntaxParser(javacc, jflex, antlr, java tokenizer, etc), you can use the same Processors and Builders to create a lucene query.&lt;br/&gt;
This will avoid duplicate code and allow for multiple syntaxes.&lt;/p&gt;

&lt;p&gt;I don&apos;t want to be preacher here, but some of these problems are already solved in the new queryparser framework, we just need to keep improving it, by adding more syntaxes, extensions and features to it.&lt;/p&gt;

&lt;p&gt;I know the new queryparser is not in main, but that can be fixed in 3.1.&lt;br/&gt;
If the community thinks it is stable, we should move it to main.&lt;/p&gt;</comment>
                    <comment id="12776502" author="yseeley@gmail.com" created="Wed, 11 Nov 2009 16:32:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think one problem lucene has today, is that the queryparser code in very tightly integrated with the javacc code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This almost seems more of an issue for core lucene developers - it&apos;s an annoyance that one needs to recompile the javacc grammar when just tweaking what one of the methods does.  Seems like this could easily be solved by just separating into two files... the javacc grammar would have a base class that left things like getFieldQuery() unimplemented, and then the standard QueryParser (in a different java file) would override and implement those methods.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We should decouple the user extensions from the JAVACC generated code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It already is today via subclassing QueryParser and overriding methods like getFieldQuery... that&apos;s very simple for users to understand and to leverage.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Just like in the new queryparser framework does, the queryparser should allow for the user to register these extensions at run time, and have Interface that extensions should implement.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t understand the motivation for this - it&apos;s complex and harder for a user to understand.  Java&apos;s own extension mechanism (overriding) has worked perfectly fine in the past.&lt;/p&gt;</comment>
                    <comment id="12776668" author="lafa" created="Wed, 11 Nov 2009 21:27:21 +0000"  >&lt;p&gt;Hi Yonik,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This almost seems more of an issue for core lucene developers - it&apos;s an annoyance that one needs to recompile the javacc grammar when just tweaking what one of the methods does. Seems like this could easily be solved by just separating into two files... the javacc grammar would have a base class that left things like getFieldQuery() unimplemented, and then the standard QueryParser (in a different java file) would override and implement those methods.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This solution does not fix the problem of having multiple syntaxes sharing the same lucene processing code. For example if you have one javacc grammar and one in antlr, you can&apos;t use lucene QueryParser, to process the output of both. You will need to re-implement the QueryParser recursive logic in a diff class to be able to use antlr.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It already is today via subclassing QueryParser and overriding methods like getFieldQuery... that&apos;s very simple for users to understand and to leverage.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True. This is simple, but is not customizable.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;You can&apos;t change the syntax.&lt;/li&gt;
	&lt;li&gt;You can&apos;t reuse the QueryParser logic with other parsers&lt;/li&gt;
	&lt;li&gt;If you do have to change syntax, you can&apos;t reuse QueryParser class anymore, you need to maintain your own copy of the class.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You can read &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1567&quot; title=&quot;New flexible query parser&quot;&gt;&lt;del&gt;LUCENE-1567&lt;/del&gt;&lt;/a&gt; to understand the reasons for the new queryparser.&lt;br/&gt;
But the focus of the new queryparser is extensibility and customization,&lt;br/&gt;
without changing lucene code, but reusing lucene logic as much as possible.&lt;/p&gt;

&lt;p&gt;If you look at TestSpanQueryParserSimpleSample in queryparser contrib, or &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1938&quot; title=&quot;Precedence query parser using the contrib/queryparser framework&quot;&gt;&lt;del&gt;LUCENE-1938&lt;/del&gt;&lt;/a&gt; Precedence query parser.&lt;br/&gt;
It illustrates two cases that would be very difficult to do in the current QueryParser in lucene by overriding methods.&lt;/p&gt;

&lt;p&gt;Actually the a implementation  PrecedenceQueryParser exists today in contrib/misc. That contains a seperated javacc grammar and does not share any code with the main lucene Queryparser, and it illustrates the problem I described above (code duplication, impossible to reuse if grammar is different, easily gets outdated when the core queryparser changes)&lt;/p&gt;

&lt;p&gt;I&apos;m not trying to say the QueryParser in main is worst than the one in contrib,&lt;/p&gt;

&lt;p&gt;What I&apos;m trying to describe is that the one in contrib is more modular and if we build the modules&lt;br/&gt;
for the lucene users. The users will be able to build smarter and more sophisticated solutions using Lucene in less time.&lt;br/&gt;
Users can decide what modules to use in the queryparser and build their query pipelines with less work.&lt;/p&gt;

&lt;p&gt;Users can also use the pre-built ones like StandardQueryParser or PrecedenceQueryParser, these should be as easy to use as the old queryparser in main.&lt;/p&gt;
</comment>
                    <comment id="12776884" author="adriano_crestani" created="Thu, 12 Nov 2009 07:32:09 +0000"  >&lt;p&gt;This is a new feature already suggested by Luis and Shai (maybe others too) before, the ability to delegate to another parser the syntax processing of certain piece of the query string. This feature is a new feature to both: core QP and contrib QP.&lt;/p&gt;

&lt;p&gt;So, I think we should focus more on how/when a query substring will be delegated to another parser and not discuss about how/when any logic will be applied to it. I think in both QPs, this part is already defined.&lt;/p&gt;

&lt;p&gt;First, to identify this substring we would need a open and close token. It could be either double-quote, slash or whatever. The ideal solution would allow the user to specify these two tokens. Unfortunately, I think JavaCC is not so flexible to allow defining these tokens programatically (after parser generation by JavaCC). So we need to stick with some specific open/close token, that&apos;s one decision we need to take. Maybe we could provide a property file, where the user could specify the open/close token and regenerate Lucene QP using &apos;ant javacc&apos; (which is pretty easy today). Anyway, by default, we could use any new token. I don&apos;t agree with double-quotes (as I think someone suggested), it&apos;s already used by phrases, so, slash is fine for me, as already defined in Simon&apos;s patch.&lt;/p&gt;

&lt;p&gt;Now, about any semantic(logic) processing performed on any query substring, it will be up to the QP implementation. In the core QP, its own extension would be responsible to do this processing. In the contrib QP, the extension parser would only parse the substring and return a QueryNode, which will be later processed, after the syntax parsing is complete, by the query node processors. As I said before, this part is defined and I don&apos;t think we should discuss it on this topic.&lt;/p&gt;

&lt;p&gt;I like Simon&apos;s patch, I think the same approach can be applied to the contrib QP. The only part I disagree is when you pass the fieldname to the extension parser, I wouldn&apos;t implement that on the contrib parser, because it assumes the syntax always has field names. Anyway, for the core QP, I see the reason why you pass the fieldname, and it&apos;s completely related to the way the core QP implements the semantic (logic) processing. So, in future, if the main core QP needs to pass a new info to its extension parser, the extension parser interface would have to be changed :S...here I go again starting a new discussion about how semantic (logic) processing should be handled &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/tongue.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12777159" author="lafa" created="Thu, 12 Nov 2009 20:19:16 +0000"  >&lt;p&gt;Simon and Adriano,&lt;br/&gt;
Can you comment on the example below.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;syntax:&lt;br/&gt;
extension:fieldname:&quot;syntax&quot;&lt;/p&gt;

&lt;p&gt;examples:&lt;br/&gt;
regexp:title:&quot;/blah&lt;span class=&quot;error&quot;&gt;&amp;#91;a-z&amp;#93;&lt;/span&gt;&lt;ins&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0-9&amp;#93;&lt;/span&gt;&lt;/ins&gt;/&quot;  &amp;lt;- regexp extension, title index field&lt;br/&gt;
complex_phrase:title:&quot;(sun OR sunny) sky&quot; &amp;lt;- complex_phrase extension, title index field&lt;/p&gt;

&lt;p&gt;regexp_phrase::&quot;/blah&lt;span class=&quot;error&quot;&gt;&amp;#91;a-z&amp;#93;&lt;/span&gt;&lt;ins&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0-9&amp;#93;&lt;/span&gt;&lt;/ins&gt;/&quot;  &amp;lt;- regexp extension, default field&lt;br/&gt;
complex_phrase::&quot;(sun OR sunny) sky&quot; &amp;lt;- complex_phrase extension, default field&lt;/p&gt;

&lt;p&gt;title:&quot;blah&quot; &amp;lt;- regular field query&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This would allow the filedname and phrases or terms to be passed to a extension, and still be very compatible with the old syntax.&lt;br/&gt;
(only double quotes and backslash need to be escaped in a phrase, so it should cover a big number of future extensions)&lt;/p&gt;

&lt;p&gt;Something like this would work for base64, but it would be target at programmatic layer, since users will not be able to generate that base64 strings, and it is supported by the syntax described above.&lt;/p&gt;
&lt;blockquote&gt;

&lt;p&gt;binary:image:&quot;base64:TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For extensions that won&apos;t work well with escaping double quotes and back-slash, we probably need some other delimiter, probably more than a single character&lt;br/&gt;
some sugestions below:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xml style:&lt;br/&gt;
1) xpath:xmlfield:&amp;lt;[[ //title&lt;span class=&quot;error&quot;&gt;&amp;#91;@lang=&amp;quot;c:\windowspath\folder&amp;quot; &amp;#93;&lt;/span&gt;]&amp;gt;&lt;br/&gt;
2) xpath:xmlfield:&amp;lt;![CDATA[ //title&lt;span class=&quot;error&quot;&gt;&amp;#91;@lang=&amp;quot;c:\windowspath\folder&amp;quot; &amp;#93;&lt;/span&gt;]&amp;gt;&lt;/p&gt;

&lt;p&gt;another one&lt;br/&gt;
3) xpath:xmlfield:&amp;#33;[CDATA[ //title&lt;span class=&quot;error&quot;&gt;&amp;#91;@lang=&amp;quot;c:\windowspath\folder&amp;quot; &amp;#93;&lt;/span&gt;]!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Any of the sequences above is good OK with me. &lt;br/&gt;
This should not affect old queries very much since the new syntax tokens would be &lt;br/&gt;
&quot;:&amp;lt;[[ &quot;  and &quot;]]&amp;gt;&quot; and these shouldn&apos;t be common on any lucene queries.&lt;br/&gt;
Still not very user friendly, but better than the base64 approach.&lt;/p&gt;


</comment>
                    <comment id="12777465" author="simonw" created="Fri, 13 Nov 2009 11:36:24 +0000"  >&lt;p&gt;Luis,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;    syntax:&lt;br/&gt;
    extension:fieldname:&quot;syntax&quot;&lt;/p&gt;

&lt;p&gt;    examples:&lt;br/&gt;
    regexp:title:&quot;/blah&lt;span class=&quot;error&quot;&gt;&amp;#91;a-z&amp;#93;&lt;/span&gt;&lt;ins&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0-9&amp;#93;&lt;/span&gt;&lt;/ins&gt;/&quot; &amp;lt;- regexp extension, title index field&lt;br/&gt;
    complex_phrase:title:&quot;(sun OR sunny) sky&quot; &amp;lt;- complex_phrase extension, title index field&lt;/p&gt;

&lt;p&gt;    regexp_phrase::&quot;/blah&lt;span class=&quot;error&quot;&gt;&amp;#91;a-z&amp;#93;&lt;/span&gt;&lt;ins&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0-9&amp;#93;&lt;/span&gt;&lt;/ins&gt;/&quot; &amp;lt;- regexp extension, default field&lt;br/&gt;
    complex_phrase::&quot;(sun OR sunny) sky&quot; &amp;lt;- complex_phrase extension, default field&lt;/p&gt;

&lt;p&gt;    title:&quot;blah&quot; &amp;lt;- regular field query&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is pretty much what I suggested above. We can extend the queryparser without breaking the backwards compatibility just by adding some code which is aware of the fieldname scheme. Even this could be extendable. FieldNames are terms and therefore they can not contain unescaped special chars like : { ] ... I would not even hard code the separator into the query parser but have the field name processed by something pluggable. So If somebody wants to have a regex extension they could use re\:field: or re\:: or re_field:.... &lt;br/&gt;
Escaping a field is easy, just like you would do it with a term. &lt;br/&gt;
More interesting is that we do not change any syntax, no special character but we can add a default implementation with a default implementation for extensions. This could be a whole API which takes are of creating and escaping the field name, building the query once it is passed to the extension etc. &lt;br/&gt;
In a first step we can resolve the extension the second step calls the extension and build the query. If no extension is registered the query parser works like in previous versions so it is all up to the user.&lt;/p&gt;

&lt;p&gt;@Adriano:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The only part I disagree is when you pass the fieldname to the extension parser, I wouldn&apos;t implement that on the contrib parser, because it assumes the syntax always has field names. Anyway, for the core QP, I see the reason why you pass the fieldname&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You need the field to create you query in the extension, the field will always be set to either the default field or the explicitly defined field in the query. No reason why we should not pass it.&lt;br/&gt;
I agree with you that we should wrap the information in a class so that we do not need to change the method signature if something has to be changed in the future. Instead we just add a new member to the wrapper though.&lt;/p&gt;</comment>
                    <comment id="12777667" author="adriano_crestani" created="Fri, 13 Nov 2009 21:23:53 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This is pretty much what I suggested above. We can extend the queryparser without breaking the backwards compatibility just by adding some code which is aware of the fieldname scheme. Even this could be extendable. FieldNames are terms and therefore they can not contain unescaped special chars like : { ] ... I would not even hard code the separator into the query parser but have the field name processed by something pluggable. So If somebody wants to have a regex extension they could use re\:field: or re\:: or re_field:....&lt;br/&gt;
Escaping a field is easy, just like you would do it with a term.&lt;br/&gt;
More interesting is that we do not change any syntax, no special character but we can add a default implementation with a default implementation for extensions. This could be a whole API which takes are of creating and escaping the field name, building the query once it is passed to the extension etc.&lt;br/&gt;
In a first step we can resolve the extension the second step calls the extension and build the query. If no extension is registered the query parser works like in previous versions so it is all up to the user.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I agree with you that we should wrap the information in a class so that we do not need to change the method signature if something has to be changed in the future. Instead we just add a new member to the wrapper though.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A Map should solve this problem&lt;/p&gt;</comment>
                    <comment id="12778685" author="lafa" created="Tue, 17 Nov 2009 01:45:39 +0000"  >&lt;p&gt;+1 &lt;/p&gt;

&lt;p&gt;I&apos;m work on changing the queryparser on Contrib, to implement that syntax for the opaque terms.&lt;/p&gt;</comment>
                    <comment id="12779681" author="simonw" created="Wed, 18 Nov 2009 21:45:03 +0000"  >&lt;p&gt;This patch implements the field:ext: approach. I will do some more work on the javadoc - pushing it out for comments!&lt;/p&gt;

&lt;p&gt;Comments on class naming are welcome too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12779694" author="lafa" created="Wed, 18 Nov 2009 22:23:52 +0000"  >&lt;p&gt;Hi Simon,&lt;/p&gt;

&lt;p&gt;I also posted a patch in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1823&quot; title=&quot;QueryParser with new features for Lucene 3&quot;&gt;LUCENE-1823&lt;/a&gt;, that implements the ext:field approach, and added a junit that implements a new QParser for regex.&lt;/p&gt;

&lt;p&gt;If you have time can you take a look at the classes in the standart2 test folder, RegexQueryParser amd TestOpaqueExtensionQuery and review the testcase&lt;/p&gt;
</comment>
                    <comment id="12780193" author="dkaelbling@blackducksoftware.com" created="Thu, 19 Nov 2009 18:38:18 +0000"  >&lt;p&gt;I apologize if I haven&apos;t read the comments carefully enough, but in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2039&quot; title=&quot;Regex support and beyond in JavaCC QueryParser&quot;&gt;&lt;del&gt;LUCENE-2039&lt;/del&gt;&lt;/a&gt;_field_ext.patch why is ExtendableQueryParser final?  That means (for example) that ComplexPhraseQueryParser cannot subclass it.  In the earlier &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2039&quot; title=&quot;Regex support and beyond in JavaCC QueryParser&quot;&gt;&lt;del&gt;LUCENE-2039&lt;/del&gt;&lt;/a&gt;.patch the complex phrase parser picked up the changes for free.&lt;/p&gt;

&lt;p&gt;And would RegexParserExtension maybe be easier to use if it set the RegexCapabilities on the new RegexQuery it is returning?&lt;/p&gt;</comment>
                    <comment id="12780254" author="rcmuir" created="Thu, 19 Nov 2009 20:26:50 +0000"  >&lt;p&gt;Hi, in my opinion RegexParserExtension should not be  tied to RegexQuery/RegexCapabilities.&lt;br/&gt;
This is only one possible implementation of regex support and has some scalability problems.&lt;/p&gt;</comment>
                    <comment id="12780258" author="simonw" created="Thu, 19 Nov 2009 20:38:21 +0000"  >&lt;blockquote&gt;&lt;p&gt;That means (for example) that ComplexPhraseQueryParser cannot subclass it&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This patch was not meant to include ComplexPhraseQueryParser it is rather a proposal for the concept of field &quot;overloading&quot;. But you are right the parser should not be final at all especially if you wanna override a get*query method it should be expendable. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Hi, in my opinion RegexParserExtension should not be tied to RegexQuery/RegexCapabilities.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is only one possible implementation of regex support and has some scalability problems. &lt;/p&gt;

&lt;p&gt;Also true, but again this is just a POC to show how it would look like. Comments on the concept would be more useful by now. &lt;br/&gt;
I did write that up during a train ride and aimed to get some comments. I already have worked on it and will upload a new patch soon which includes RegexCapabilities + tests. &lt;br/&gt;
Thanks again for the pointer with the final class.&lt;/p&gt;</comment>
                    <comment id="12780267" author="simonw" created="Thu, 19 Nov 2009 21:09:51 +0000"  >&lt;p&gt;Updated the patch&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removed final modifier from ExtendableQueryParser&lt;/li&gt;
	&lt;li&gt;added RegexCapabilities ctor to RegexParserExtension&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I still need to work on the Extensions JavaDoc - and I&apos;m not too happy with the name. &lt;/p&gt;

&lt;p&gt;Comments on the concept are very welcome.&lt;/p&gt;</comment>
                    <comment id="12780316" author="markrmiller@gmail.com" created="Thu, 19 Nov 2009 22:42:01 +0000"  >&lt;p&gt;It looks like the patch puts this in core? Any compelling reason? Offhand I&apos;d think it would go in the misc contrib with the other queryparsers that extend the core queryparser.&lt;/p&gt;</comment>
                    <comment id="12781042" author="simonw" created="Sat, 21 Nov 2009 20:15:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Offhand I&apos;d think it would go in the misc contrib with the other queryparsers that extend the core queryparser. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For sure. I will attach another patch - did not thing about that too much when I moved from the first proposal which modified the core one.&lt;/p&gt;</comment>
                    <comment id="12781043" author="simonw" created="Sat, 21 Nov 2009 20:17:35 +0000"  >&lt;p&gt;moved ext parser to contrib/misc&lt;/p&gt;</comment>
                    <comment id="12782013" author="simonw" created="Tue, 24 Nov 2009 16:32:36 +0000"  >&lt;p&gt;Took over from Grant &lt;/p&gt;</comment>
                    <comment id="12782536" author="simonw" created="Wed, 25 Nov 2009 18:07:57 +0000"  >&lt;p&gt;I finished the JavaDoc, added package.html file.&lt;br/&gt;
I again refactored RegexParserExtension to use a factory method to obtain an instance of RegexCapabilities. RegexCapabilities is stateful and can not be shared so subclassing to change seems to be reasonable. JavaUtil seems to be reasonable anyway after the latest Jakarta Regexp drama &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;I had to introduce a compile time dependency from regex to misc to build the extension - should add misc as a dependency to maven in this case?&lt;/p&gt;</comment>
                    <comment id="12782540" author="rcmuir" created="Wed, 25 Nov 2009 18:14:34 +0000"  >&lt;blockquote&gt;&lt;p&gt;JavaUtil seems to be reasonable anyway after the latest Jakarta Regexp drama&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah, we shouldn&apos;t mislead anyone into believing the constant prefix with jakarta actually works even now.&lt;br/&gt;
for example the constant prefix of (ab|ac) is not &quot;a&quot; but instead empty string.&lt;/p&gt;</comment>
                    <comment id="12783588" author="simonw" created="Mon, 30 Nov 2009 09:51:41 +0000"  >&lt;p&gt;The contrib/regex dependency on contrib/misc buggs me a bit though. I have the impression that this regex default extension should not be part of this patch. The extension seems to be so trivial that users could implement it on their own. This would save us the dependency and IMO would not be a problem for users though.&lt;/p&gt;

&lt;p&gt; Any thoughts?&lt;/p&gt;</comment>
                    <comment id="12784262" author="simonw" created="Tue, 1 Dec 2009 15:27:56 +0000"  >&lt;p&gt;I removed the RegexExtension in this patch as in my opinion this is not worth the dependency. As soon as roberts automation patch is in core we won&apos;t have this problem anymore anyway.&lt;br/&gt;
Users should add trivial extensions like on their own. &lt;br/&gt;
One other thing I was thinking about is adding another ExtensionParser which subclasses ComplexPhraseQueryParser. This is a benefit from moving it into misc, I think we should do it. &lt;br/&gt;
Thoughts?&lt;/p&gt;</comment>
                    <comment id="12784266" author="markrmiller@gmail.com" created="Tue, 1 Dec 2009 15:42:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;One other thing I was thinking about is adding another ExtensionParser which subclasses ComplexPhraseQueryParser.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We should be careful here - the thought at one time was to remove ComplexPhraseQueryParser soon and replace it with one written for the new QueryParser. In that case, we might not want to add more that relies on it - the new one might not match the feature/results of the old one. Just an FYI though. In my mind, who knows if that will end up happening, and it shouldn&apos;t necessarily block other good work just because it might. Just thought I&apos;d mention it.&lt;/p&gt;</comment>
                    <comment id="12784910" author="simonw" created="Wed, 2 Dec 2009 17:32:14 +0000"  >&lt;blockquote&gt;&lt;p&gt;...was to remove ComplexPhraseQueryParser soon and replace it with one written for the new QueryParser.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Thanks Mark, I do not recall this so good that you mention it again. Either way, this was just a suggestion which came to my mind. Another suggestion for maybe a future development is to move this into the core query parser as it does not change any behavior as long as you do not explicitly specify any extension. &lt;br/&gt;
To me these ideas are future considerations which could be done in sep. issues once this is in. I plan to commit the current patch until 12/06/09 if nobody objects.&lt;/p&gt;</comment>
                    <comment id="12786247" author="simonw" created="Fri, 4 Dec 2009 23:43:50 +0000"  >&lt;p&gt;I will commit this tomorrow if nobody objects.&lt;/p&gt;</comment>
                    <comment id="12786380" author="simonw" created="Sat, 5 Dec 2009 12:30:16 +0000"  >&lt;p&gt;Commited in revision 887533&lt;/p&gt;</comment>
                    <comment id="12788340" author="dkaelbling@blackducksoftware.com" created="Wed, 9 Dec 2009 22:05:20 +0000"  >&lt;p&gt;Currently the master parser doesn&apos;t pass settings down to the extension parsers (things like setAllowLeadingWildcard, setMultiTermRewriteMethod, etc.)   Should it?&lt;/p&gt;</comment>
                    <comment id="12789260" author="simonw" created="Fri, 11 Dec 2009 12:03:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;Currently the master parser doesn&apos;t pass settings down to the extension parsers (things like setAllowLeadingWildcard, setMultiTermRewriteMethod, etc.) Should it? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;David, so some sort of parsers this would make sense though. Yet, we either reflect all of the setting from the &quot;master&quot; parser or none of it. I would suggest to modify the ExtensionQuery ctor to take a QueryParser instance and add the corresponding getters to it. That way we can maintain a consistent view on the setting even if they are reset on the master parser without overriding all setters though. Would that make sense?&lt;br/&gt;
Another way of enable this is to pass the query parser instance into ExtensionQuery and simply add a getter so extension parsers can access the parser and its utilities too.&lt;br/&gt;
Anyhow, we should open a new issue for that. I will do so&lt;/p&gt;</comment>
                    <comment id="12789374" author="dkaelbling@blackducksoftware.com" created="Fri, 11 Dec 2009 16:29:54 +0000"  >&lt;p&gt;&amp;gt; I would suggest to modify the ExtensionQuery ctor to take a QueryParser instance and add &lt;br/&gt;
&amp;gt; the corresponding getters to it. That way we can maintain a consistent view on the setting &lt;br/&gt;
&amp;gt; even if they are reset on the master parser without overriding all setters though. Would &lt;br/&gt;
&amp;gt; that make sense?&lt;/p&gt;

&lt;p&gt;Simon, it sounds like the right direction! But relying on ExtensionParser implementors to manually copy all the parent settings to the child seems like a maintenance problem.  We add new settings relatively often. Unfortunately there&apos;s nothing like the token Attribute stuff for QueryParser...&lt;/p&gt;


&lt;p&gt;&amp;gt; Another way of enable this is to pass the query parser instance into ExtensionQuery and &lt;br/&gt;
&amp;gt; simply add a getter so extension parsers can access the parser and its utilities too.&lt;/p&gt;

&lt;p&gt;Umm, I don&apos;t quite follow.  If the extension wraps an existing parser, the extension would have to subclass it, override all the getters/setters to delegate to the parent, and trust that everyone uses them?  That&apos;s not currently true &amp;#8211; for example QueryParser.getPrefixQuery() directly accesses allowLeadingWildcard, without using the getter.  There are probably other cases too, that&apos;s just the first one I checked.&lt;/p&gt;</comment>
                    <comment id="12789378" author="simonw" created="Fri, 11 Dec 2009 16:38:57 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Simon, it sounds like the right direction! But relying on ExtensionParser implementors to manually copy all the parent settings to the child seems like a maintenance problem. We add new settings relatively often. Unfortunately there&apos;s nothing like the token Attribute stuff for QueryParser...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah that is the reason why I suggested passing the top level parser instance itself to the extension and expose it there.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Umm, I don&apos;t quite follow. If the extension wraps an existing parser, the extension would have to subclass it, override all the getters/setters to delegate to the parent, and trust that everyone uses them? That&apos;s not currently true - for example QueryParser.getPrefixQuery() directly accesses allowLeadingWildcard, without using the getter. There are probably other cases too, that&apos;s just the first one I checked.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;David here is an example of what I mean by wrapping the top level parser. This would give you access to all the settings right away inside your extension.&lt;/p&gt;</comment>
                    <comment id="12790223" author="dkaelbling@blackducksoftware.com" created="Mon, 14 Dec 2009 16:12:36 +0000"  >&lt;p&gt;&amp;gt; David here is an example of what I mean by wrapping the top level parser. This would give &lt;br/&gt;
&amp;gt; you access to all the settings right away inside your extension.&lt;/p&gt;

&lt;p&gt;Maybe I&apos;m oversimplifying.  As a lazy implementor I want to write something like this:&lt;/p&gt;

&lt;p&gt;ext.add(&quot;regex&quot;, new ParserExtension() {&lt;br/&gt;
  public Query parse(ExtensionQuery q) throws ParseException &lt;/p&gt;
{
      return new RegexQuery(new Term(q.getField(), q.getRawQueryString()));
}
&lt;p&gt; } );&lt;/p&gt;

&lt;p&gt;My ParserExtension can query any top level parser settings it likes, but how do I get those&lt;br/&gt;
values down into RegexQuery?  Or whatever full parser I&apos;m invoking?&lt;/p&gt;</comment>
                    <comment id="12790233" author="simonw" created="Mon, 14 Dec 2009 16:49:12 +0000"  >&lt;p&gt;Am I missing something? Why not using the getTopLevelParser() method?&lt;br/&gt;
like that:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 extensions.add(&lt;span class=&quot;code-quote&quot;&gt;&quot;regex&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ParserExtension() {
		
		@Override
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Query parse(ExtensionQuery query) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; ParseException {
			&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; enableWildcards = query.getTopLevelParser().getAllowLeadingWildcard();
			&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RegexQuery(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(query.getField(), query.getRawQueryString()));
		}
	});

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I mean enableWildcards doesn&apos;t do anything here but you can take whatever settings you like as shown above.&lt;br/&gt;
simon&lt;/p&gt;</comment>
                    <comment id="12790270" author="dkaelbling@blackducksoftware.com" created="Mon, 14 Dec 2009 18:17:21 +0000"  >&lt;p&gt;Hi Simon &amp;#8211; sorry, an example using a full query parser rather than just RegexQuery would have been clearer.  What I&apos;m worried about is that I don&apos;t in general know all the parent settings that need to be mirrored in the nested parser.  Writing nestedParser.setFoo(topLevelParser.getFoo()) calls for all possible Foo, past, present, and future, is going to bite me eventually.&lt;/p&gt;</comment>
                    <comment id="12790321" author="simonw" created="Mon, 14 Dec 2009 20:05:01 +0000"  >&lt;p&gt;David, I assume you use a subclass of QueryParser inside your ParserExtension and your are worried about reflecting all properties of the top level parser into your sub parser?! I understand what your issues are but I do not see another way than pulling the properties from the top level parser once you need it. If you rely on an already existing parser that does not allow you to call the getters in place you probably have to set them each time if you really need all of those. I don&apos;t see another way to do it, do you?&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12790373" author="dkaelbling@blackducksoftware.com" created="Mon, 14 Dec 2009 21:15:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;I do not see another way than pulling the properties from the top level parser once you need it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Exactly! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  I don&apos;t see another way either, hence my original lament that QueryParser didn&apos;t have anything like Token attributes where all the state was extracted into a separate sharable entity.&lt;/p&gt;

&lt;p&gt;I can live with hard-coding knowledge of both the top level- and embedded-parser settings in the ParserExtension implementation.  I was just hoping for a better way.&lt;/p&gt;</comment>
                    <comment id="12790672" author="simonw" created="Tue, 15 Dec 2009 11:11:35 +0000"  >&lt;blockquote&gt;&lt;p&gt;Exactly! I don&apos;t see another way either, hence my original lament that QueryParser didn&apos;t have anything like Token attributes where all the state was extracted into a separate sharable entity.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;David, FYI  I created  a new issue for that (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2162&quot; title=&quot;ExtendableQueryParser should allow extensions to access the toplevel parser settings/ properties&quot;&gt;&lt;del&gt;LUCENE-2162&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;</comment>
                    <comment id="13449675" author="yseeley@gmail.com" created="Thu, 6 Sep 2012 14:49:34 +0100"  >&lt;p&gt;Reopening, as I believe the grammar as implemented is a bit flawed.&lt;/p&gt;

&lt;p&gt;A simple query of foo/bar will now fail since the slash in the middle of the term is seen as the start of a regex.&lt;/p&gt;</comment>
                    <comment id="13449822" author="hossman" created="Thu, 6 Sep 2012 18:15:38 +0100"  >&lt;p&gt;Yonik: strongly suggest you open a new issue to address this, since &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2039&quot; title=&quot;Regex support and beyond in JavaCC QueryParser&quot;&gt;&lt;del&gt;LUCENE-2039&lt;/del&gt;&lt;/a&gt; is already listed as a feature added in 4.0-ALPHA.&lt;/p&gt;

&lt;p&gt;if you &quot;fix&quot; this mid string slash issue, you&apos;re going to want a unique jira id to refer to when citing the bug fix as a CHANGES.txt for 4.0-final, or no one will have any clear idea what works where.&lt;/p&gt;</comment>
                    <comment id="13450601" author="arafalov" created="Fri, 7 Sep 2012 14:11:26 +0100"  >&lt;p&gt;This can be re-closed as it was fixed in beta by &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-3467&quot; title=&quot;ExtendedDismax escaping is missing several reserved characters&quot;&gt;&lt;del&gt;SOLR-3467&lt;/del&gt;&lt;/a&gt; .&lt;/p&gt;</comment>
                    <comment id="13654191" author="thetaphi" created="Fri, 10 May 2013 11:34:20 +0100"  >&lt;p&gt;Closed after release.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12433389">LUCENE-1823</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12440682">LUCENE-2066</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12443361">LUCENE-2162</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12426543" name="LUCENE-2039_field_ext.patch" size="33344" author="simonw" created="Tue, 1 Dec 2009 15:27:56 +0000" />
                    <attachment id="12426127" name="LUCENE-2039_field_ext.patch" size="45440" author="simonw" created="Wed, 25 Nov 2009 18:07:56 +0000" />
                    <attachment id="12425736" name="LUCENE-2039_field_ext.patch" size="38883" author="simonw" created="Sat, 21 Nov 2009 20:17:35 +0000" />
                    <attachment id="12425526" name="LUCENE-2039_field_ext.patch" size="38552" author="simonw" created="Thu, 19 Nov 2009 21:09:51 +0000" />
                    <attachment id="12425389" name="LUCENE-2039_field_ext.patch" size="37769" author="simonw" created="Wed, 18 Nov 2009 21:45:03 +0000" />
                    <attachment id="12424218" name="LUCENE-2039.patch" size="19446" author="simonw" created="Fri, 6 Nov 2009 18:40:49 +0000" />
                    <attachment id="12427735" name="LUCENE-2039_wrap_master_parser.patch" size="2277" author="simonw" created="Fri, 11 Dec 2009 16:38:57 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 6 Nov 2009 18:48:19 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11738</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25686</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>