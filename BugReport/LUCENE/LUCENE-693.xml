<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:06:51 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-693/LUCENE-693.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-693] ConjunctionScorer - more tuneup</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-693</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;(See also: #&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-443&quot; title=&quot;ConjunctionScorer tune-up&quot;&gt;&lt;del&gt;LUCENE-443&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
I did some profile testing with the new ConjuctionScorer in 2.1 and discovered a new bottleneck in ConjunctionScorer.sortScorers. The java.utils.Arrays.sort method is cloning the Scorers array on every sort, which is quite expensive on large indexes because of the size of the &apos;norms&apos; array within, and isn&apos;t necessary. &lt;/p&gt;

&lt;p&gt;Here is one possible solution:&lt;/p&gt;

&lt;p&gt;  private void sortScorers() {&lt;br/&gt;
// squeeze the array down for the sort&lt;br/&gt;
//    if (length != scorers.length) &lt;/p&gt;
{
//      Scorer[] temps = new Scorer[length];
//      System.arraycopy(scorers, 0, temps, 0, length);
//      scorers = temps;
//    }
&lt;p&gt;    insertionSort( scorers,length );&lt;br/&gt;
    // note that this comparator is not consistent with equals!&lt;br/&gt;
//    Arrays.sort(scorers, new Comparator() {         // sort the array&lt;br/&gt;
//        public int compare(Object o1, Object o2) &lt;/p&gt;
{
//          return ((Scorer)o1).doc() - ((Scorer)o2).doc();
//        }
&lt;p&gt;//      });&lt;/p&gt;

&lt;p&gt;    first = 0;&lt;br/&gt;
    last = length - 1;&lt;br/&gt;
  }&lt;br/&gt;
  private void insertionSort( Scorer[] scores, int len)&lt;br/&gt;
  {&lt;br/&gt;
      for (int i=0; i&amp;lt;len; i++) {&lt;br/&gt;
          for (int j=i; j&amp;gt;0 &amp;amp;&amp;amp; scores&lt;span class=&quot;error&quot;&gt;&amp;#91;j-1&amp;#93;&lt;/span&gt;.doc() &amp;gt; scores&lt;span class=&quot;error&quot;&gt;&amp;#91;j&amp;#93;&lt;/span&gt;.doc();j-- ) &lt;/p&gt;
{
              swap (scores, j, j-1);
          }
&lt;p&gt;      }&lt;br/&gt;
      return;&lt;br/&gt;
  }&lt;br/&gt;
  private void swap(Object[] x, int a, int b) &lt;/p&gt;
{
    Object t = x[a];
    x[a] = x[b];
    x[b] = t;
  }

&lt;p&gt;The squeezing of the array is no longer needed. &lt;br/&gt;
We also initialized the Scorers array to 8 (instead of 2) to avoid having to grow the array for common queries, although this probably has less performance impact.&lt;/p&gt;

&lt;p&gt;This change added about 3% to query throughput in my testing.&lt;/p&gt;

&lt;p&gt;Peter&lt;/p&gt;</description>
                <environment>&lt;p&gt;Windows Server 2003 x64, Java 1.6, pretty large index&lt;/p&gt;</environment>
            <key id="12353786">LUCENE-693</key>
            <summary>ConjunctionScorer - more tuneup</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="pkeegan">Peter Keegan</reporter>
                        <labels>
                    </labels>
                <created>Mon, 23 Oct 2006 23:36:56 +0100</created>
                <updated>Fri, 23 Nov 2007 17:01:53 +0000</updated>
                    <resolved>Fri, 23 Nov 2007 17:01:53 +0000</resolved>
                            <version>2.1</version>
                                                <component>core/search</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12444150" author="paul.elschot@xs4all.nl" created="Tue, 24 Oct 2006 00:07:17 +0100"  >&lt;p&gt;As just discussed on java-dev, the creation of an object during the call to sort could well be due to the creation&lt;br/&gt;
of a new comparator for each call to sort This might be fixed by keeping a single comparator around.&lt;br/&gt;
I wouldn&apos;t expect any java library sort to create a copy of its argument, but I&apos;m not sure.&lt;/p&gt;

&lt;p&gt;Anyway, when sorting code is going to be inlined here, I&apos;d prefer to have it non quadratic.&lt;/p&gt;
</comment>
                    <comment id="12444174" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 03:46:45 +0100"  >&lt;p&gt;It occures to me that we shouldn&apos;t even need to sort anything!&lt;br/&gt;
Stay tuned... I&apos;m coming up with a patch.&lt;/p&gt;</comment>
                    <comment id="12444193" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 06:16:25 +0100"  >&lt;p&gt;Here&apos;s a patch that:&lt;br/&gt;
1) nails things down in the constructor (removes incremental add code)&lt;br/&gt;
2) removes sorting&lt;br/&gt;
3) always skips to the highest docid seen as opposed to &quot;target&quot;&lt;/p&gt;

&lt;p&gt;It should be faster in almost all cases, but I&apos;ll make a performance test to verify tomorrow.&lt;/p&gt;

&lt;p&gt;Notes: the docs[] array could be removed... I started out with it because you can&apos;t currently depend on doc() to tell you the position because the javadoc says it&apos;s undefined at first (as opposed to -1).  So I switched to using a docs[] array and initialized that to -1, but then learned that calling skipTo() before calling next() doesn&apos;t always work.&lt;/p&gt;</comment>
                    <comment id="12444317" author="pkeegan" created="Tue, 24 Oct 2006 15:02:33 +0100"  >&lt;p&gt;Yonik,&lt;/p&gt;

&lt;p&gt;I tried out your patch, but it causes an exception on some boolean queries.&lt;br/&gt;
This one occurred on a boolean query with 3 required terms:&lt;/p&gt;

&lt;p&gt;java.lang.ArrayIndexOutOfBoundsException: 2147483647&lt;br/&gt;
    at org.apache.lucene.search.TermScorer.score(TermScorer.java:129)&lt;br/&gt;
    at org.apache.lucene.search.ConjunctionScorer.score(&lt;br/&gt;
ConjunctionScorer.java:97)&lt;br/&gt;
    at org.apache.lucene.search.BooleanScorer2$2.score(BooleanScorer2.java&lt;br/&gt;
:186)&lt;br/&gt;
    at org.apache.lucene.search.BooleanScorer2.score(BooleanScorer2.java&lt;br/&gt;
:318)&lt;br/&gt;
    at org.apache.lucene.search.BooleanScorer2.score(BooleanScorer2.java&lt;br/&gt;
:282)&lt;br/&gt;
    at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:132)&lt;br/&gt;
    at org.apache.lucene.search.Searcher.search(Searcher.java:116)&lt;br/&gt;
    at org.apache.lucene.search.Searcher.search(Searcher.java:95)&lt;/p&gt;

&lt;p&gt;It looks like the doc id has the sentinel value (Integer.MAX_VALUE).&lt;br/&gt;
Note: one of the terms had no occurrences in the index.&lt;/p&gt;

&lt;p&gt;Peter&lt;/p&gt;
</comment>
                    <comment id="12444319" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 15:16:48 +0100"  >&lt;p&gt;Thanks for trying it out Peter.&lt;br/&gt;
Odd it could fail after passing all the Lucene unit tests... I assume this was the lucene trunk you were trying?&lt;br/&gt;
So the query was just a boolean query with three required term queries?&lt;/p&gt;</comment>
                    <comment id="12444320" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 15:24:25 +0100"  >&lt;p&gt;Ah, I see the problem... in the constructor I have&lt;br/&gt;
      boolean more = scorers&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.next();&lt;br/&gt;
for each scorer... but note that the local &quot;more&quot; is masking the member &quot;more&quot;.  Doh!&lt;br/&gt;
You can just remove &quot;boolean&quot; from &quot;boolean more&quot; in the ConjunctionScorer constructor, and I&apos;ll try to see why this was never reproduced by any test cases in the meantime.&lt;/p&gt;</comment>
                    <comment id="12444334" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 16:11:52 +0100"  >&lt;p&gt;I&apos;m not sure how it&apos;s possible, but my version is &lt;b&gt;solwer&lt;/b&gt; in the performance test I came up with.&lt;br/&gt;
Very odd... I&apos;m not sure why.&lt;/p&gt;</comment>
                    <comment id="12444336" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 16:24:16 +0100"  >&lt;p&gt;Here is my current patch and test code (which currently seems to be slower with this patch).&lt;/p&gt;</comment>
                    <comment id="12444408" author="pkeegan" created="Tue, 24 Oct 2006 17:22:36 +0100"  >&lt;p&gt;Well, I&apos;m seeing a good 7% increase over the trunk version. Conjunction&lt;br/&gt;
scorer time is mostly in &apos;skipto&apos; now, which seems reasonable.&lt;/p&gt;

&lt;p&gt;Do the test cases try queries with non-existent terms? My failed query&lt;br/&gt;
contained 3 required terms, but one of the terms was misspelled and didn&apos;t&lt;br/&gt;
exist in the index.&lt;/p&gt;

&lt;p&gt;Peter&lt;/p&gt;
</comment>
                    <comment id="12444411" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 17:38:51 +0100"  >&lt;p&gt;&amp;gt; Well, I&apos;m seeing a good 7% increase over the trunk version.&lt;/p&gt;

&lt;p&gt;Yay!  Now only if I could get my random synthetic tests to show an improvement too...&lt;br/&gt;
Were you testing with -server?  My -client showed a speedup and -server showed a slowdown.&lt;/p&gt;

&lt;p&gt;I think the difference is on &lt;b&gt;which&lt;/b&gt; scorers I&apos;m skipping on, even though I&apos;m always skipping to the highest doc yet seen.  Skipping on denser scorers will be a waste of time, and if the list is sorted one is more likely to be skipping on the sparse scorers.  My code is optimal when the density of the scorers is similar.&lt;/p&gt;

&lt;p&gt;Think of the case of two sparse scorers and a dense scorer... you really want to be skipping on the two sparse scorers until they happen to agree.  Until they agree, skipping on the dense scorer is a waste.  My code round robins and throws the dense scorer into the mix.&lt;/p&gt;

&lt;p&gt;The question is, what are the real world usecases like, and what is important to speed up.&lt;br/&gt;
I&apos;d argue that the case of all dense scorers, while more rare, is more important (sparse scorers&lt;br/&gt;
will cause the queries to be faster anyway).&lt;/p&gt;

&lt;p&gt;&amp;gt; Do the test cases try queries with non-existent terms? &lt;/p&gt;

&lt;p&gt;They will.... I was able to reproduce by earlier bug with the new TestScorerPerf.testConjunctions() included in the last patch.&lt;/p&gt;</comment>
                    <comment id="12444427" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 18:17:02 +0100"  >&lt;p&gt;This version removes the docs[] array and seems to be slightly faster.&lt;br/&gt;
Still slower on the synthetic random ConstantScoreQuery tests though.&lt;/p&gt;

&lt;p&gt;If anyone else as real-world benchmarks they can try, I&apos;d appreciate the data.&lt;/p&gt;</comment>
                    <comment id="12444436" author="pkeegan" created="Tue, 24 Oct 2006 18:52:33 +0100"  >&lt;p&gt;fwiw, my tests were done using &apos;real world&apos; queries and index. Most queries&lt;br/&gt;
have several required clauses. The jvm is 1.6 beta2 with -server. I would be&lt;br/&gt;
interested to see results from others, too.&lt;/p&gt;

&lt;p&gt;thanks Yonik!&lt;/p&gt;

&lt;p&gt;Peter&lt;/p&gt;
</comment>
                    <comment id="12444487" author="paul.elschot@xs4all.nl" created="Tue, 24 Oct 2006 21:13:52 +0100"  >&lt;p&gt;Yonik,&lt;/p&gt;

&lt;p&gt;you wrote: &lt;br/&gt;
&amp;gt; but then learned that calling skipTo() before calling next() doesn&apos;t always work.&lt;/p&gt;

&lt;p&gt;Could you describe a case in which skipTo() before next()  does not work?&lt;/p&gt;

&lt;p&gt;skipTo() as first call on a scorer should work. ReqExclScorer and ReqOptSumScorer depend on that for the excluded and optional scorers.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Paul Elschot&lt;/p&gt;</comment>
                    <comment id="12444496" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 21:34:33 +0100"  >&lt;p&gt;&amp;gt; Could you describe a case in which skipTo() before next() does not work?&lt;/p&gt;

&lt;p&gt;I don&apos;t recall, but my attempt to speed up ConjunctionScorer flushed them out.&lt;br/&gt;
I&apos;ll move back to an older version of that to see what failed and put&lt;br/&gt;
details here: &lt;a href=&quot;http://issues.apache.org/jira/browse/LUCENE-696&quot; class=&quot;external-link&quot;&gt;http://issues.apache.org/jira/browse/LUCENE-696&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12444770" author="yseeley@gmail.com" created="Thu, 26 Oct 2006 04:03:43 +0100"  >&lt;p&gt;conjunction.patch.nosort1 is a slightly more elegant solution that does&lt;br/&gt;
not require any initial setup of the scorers (no calling next() in the constructor).&lt;br/&gt;
It&apos;s one of the fastest yet, but still slower in some cases, and I&apos;ve figured out why.&lt;/p&gt;

&lt;p&gt;With a conjunction at the top-level only (like my synthetic tests), only next() is called, so the sort is only done once.  The existing next() logic is simpler, and hence faster.  If a conjunction is nested somewhere, skipTo may be called on it, and that&apos;s when the current version is much faster since it avoids the sort.&lt;/p&gt;

&lt;p&gt;nosort1_time / trunk_time for certain tests (relative perf, lower is better)&lt;br/&gt;
testConjunctionPerf : 1.22   (slower, only next is called)&lt;br/&gt;
testNestedConjunctionPerf: 0.35 (much faster, skipTo() is exercized)&lt;br/&gt;
testConjunctionTerms: 1.00 (only next() called, but term scorer dominates time anyway)&lt;br/&gt;
testNestedConjunctionTerms: 0.97 (slight improvement, masked by term scorer time)&lt;/p&gt;

&lt;p&gt;This may not be the final version, but I think it&apos;s good to have it available anyway.&lt;/p&gt;</comment>
                    <comment id="12540913" author="klaasm" created="Wed, 7 Nov 2007 22:28:40 +0000"  >&lt;p&gt;Paul wrote:&lt;br/&gt;
&amp;gt; As just discussed on java-dev, the creation of an object during the call to sort could well be due to the creation&lt;br/&gt;
&amp;gt; of a new comparator for each call to sort This might be fixed by keeping a single comparator around.&lt;br/&gt;
&amp;gt; I wouldn&apos;t expect any java library sort to create a copy of its argument, but I&apos;m not sure.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#sort(java.lang.Object[&quot; class=&quot;external-link&quot;&gt;http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#sort(java.lang.Object[&lt;/a&gt;]) , java is using mergesort for this method.  I can&apos;t imagine it copying the individual &lt;em&gt;elements&lt;/em&gt;, but mergesort does require 2N space in general and so some array copying takes place.&lt;/p&gt;

&lt;p&gt;Unfortunately, top-level conjunctions are an important case.&lt;/p&gt;

&lt;p&gt;Perhaps one way to proceed is to incorporate some of the refactoring improvements (namely, determining all scorers at constructor-time) and do some trivial optimizations to the existing sortScorers method (lift out the ad-hoc Comparator, use insertion sort for N &amp;lt; 5, etc.).  It might be worthwhile to code versions for common cases, like N=2, with a factory to choose among them.&lt;/p&gt;</comment>
                    <comment id="12544177" author="yseeley@gmail.com" created="Wed, 21 Nov 2007 07:15:29 +0000"  >&lt;p&gt;Whew... I&apos;d forgotten about this issue.  I brushed up one of the last versions I had lying around from a year ago (see lastest conjunction.patch), fixed up my synthetic tests a bit, and got some decent results:&lt;/p&gt;

&lt;p&gt;1% faster in top level term conjunctions (wheee)&lt;br/&gt;
49% faster in a conjunction of nested term conjunctions (no sort per call to skipTo)&lt;br/&gt;
5% faster in a top level ConstantScoreQuery conjunction&lt;br/&gt;
144% faster in a conjunction of nested ConstantScoreQuery conjunctions&lt;/p&gt;

&lt;p&gt;A sort is done the first time, and the scorers are ordered so that the highest will skip first (the idea being that there may be a little info in the first skip about which scorer is most sparse).&lt;/p&gt;

&lt;p&gt;Michael Busch recently brought up a related idea... that one could skip on low df terms first... but that would of course require some terms in the conjunction.&lt;/p&gt;</comment>
                    <comment id="12544630" author="klaasm" created="Wed, 21 Nov 2007 23:04:32 +0000"  >&lt;p&gt;Yonik: this is great!  I applied and tested the patch and everything looks good.&lt;/p&gt;

&lt;p&gt;Running the tests on my system (FC5/java 6.0.01), I got&lt;/p&gt;

&lt;p&gt;testConjunctionPerf: 20% faster&lt;br/&gt;
testNestedConjunction: 60% faster / 2.5x speed up&lt;br/&gt;
testConjunctionTerms: 18% faster&lt;br/&gt;
testNestedConjunction: 50% faster / 2x speed up&lt;/p&gt;

&lt;p&gt;(where XX% faster = (difference in times/old time*100))&lt;/p&gt;</comment>
                    <comment id="12545082" author="yseeley@gmail.com" created="Fri, 23 Nov 2007 17:01:31 +0000"  >&lt;p&gt;Cool, I guess the differences are probably  due to a different processor type (I was using a P4).&lt;/p&gt;</comment>
                    <comment id="12545083" author="yseeley@gmail.com" created="Fri, 23 Nov 2007 17:01:53 +0000"  >&lt;p&gt;committed.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12369954" name="conjunction.patch" size="16158" author="yseeley@gmail.com" created="Wed, 21 Nov 2007 07:15:29 +0000" />
                    <attachment id="12343561" name="conjunction.patch" size="14852" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 18:17:02 +0100" />
                    <attachment id="12343552" name="conjunction.patch" size="15594" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 16:24:16 +0100" />
                    <attachment id="12343495" name="conjunction.patch" size="10459" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 06:16:25 +0100" />
                    <attachment id="12343665" name="conjunction.patch.nosort1" size="9412" author="yseeley@gmail.com" created="Thu, 26 Oct 2006 03:52:46 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 23 Oct 2006 23:07:17 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13059</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27037</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>