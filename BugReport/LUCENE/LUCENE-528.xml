<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:13:15 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-528/LUCENE-528.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-528] Optimization for IndexWriter.addIndexes()</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-528</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;One big performance problem with IndexWriter.addIndexes() is that it has to optimize the index both before and after adding the segments.  When you have a very large index, to which you are adding batches of small updates, these calls to optimize make using addIndexes() impossible.  It makes parallel updates very frustrating.&lt;/p&gt;

&lt;p&gt;Here is an optimized function that helps out by calling mergeSegments only on the newly added documents.  It will try to avoid calling mergeSegments until the end, unless you&apos;re adding a lot of documents at once.&lt;/p&gt;

&lt;p&gt;I also have an extensive unit test that verifies that this function works correctly if people are interested.  I gave it a different name because it has very different performance characteristics which can make querying take longer.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12330526">LUCENE-528</key>
            <summary>Optimization for IndexWriter.addIndexes()</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                <reporter username="tamm">Steven Tamm</reporter>
                        <labels>
                    </labels>
                <created>Wed, 22 Mar 2006 06:14:24 +0000</created>
                <updated>Thu, 26 Oct 2006 23:56:26 +0100</updated>
                    <resolved>Thu, 26 Oct 2006 23:56:26 +0100</resolved>
                                                            <component>core/index</component>
                        <due></due>
                    <votes>2</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12428478" author="ninglili" created="Wed, 16 Aug 2006 20:27:23 +0100"  >&lt;p&gt;In an email thread titled &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-528&quot; title=&quot;Optimization for IndexWriter.addIndexes()&quot;&gt;&lt;del&gt;LUCENE-528&lt;/del&gt;&lt;/a&gt; and 565&quot;, I described a weakness of the proposed solution:&lt;/p&gt;

&lt;p&gt;&quot;I&apos;m totally for a version of addIndexes() where optimize() is not always called. However, with the one proposed in the patch, we could end up with an index where: segment 0 has 1000 docs, 1 has 2000, 2 has 4000, 3 has 8000, etc. while Lucene desires the reverse. Or we could have a sandwich index where: segment 0 has 4000 docs, 1 has 100, 2 has 100, 3 has 4000. While neither of these will occur if you use addIndexesNoOpt() carefully, there should be a more robust merge policy.&quot;&lt;/p&gt;

&lt;p&gt;Here is an alternative solution which merges segements so that the docCount of segment i is at least twice as big as the docCount of segment i+1. If we are willing to make it a bit more complicated, we can take merge factor into consideration.&lt;/p&gt;


&lt;p&gt;  public synchronized void addIndexesNoOpt(Directory[] dirs) throws IOException {&lt;br/&gt;
    for (int i = 0; i &amp;lt; dirs.length; i++) {&lt;br/&gt;
      SegmentInfos sis = new SegmentInfos(); // read infos from dir&lt;br/&gt;
      sis.read(dirs&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;);&lt;br/&gt;
      for (int j = 0; j &amp;lt; sis.size(); j++) &lt;/p&gt;
{
        segmentInfos.addElement(sis.info(j)); // add each info
      }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    int start = 0;&lt;br/&gt;
    int docCountFromStart = docCount();&lt;/p&gt;

&lt;p&gt;    while (start &amp;lt; segmentInfos.size()) {&lt;br/&gt;
      int end;&lt;br/&gt;
      int docCountToMerge = 0;&lt;/p&gt;

&lt;p&gt;      if (docCountFromStart &amp;lt;= minMergeDocs) &lt;/p&gt;
{
        // if the total docCount of the remaining segments
        // is lte minMergeDocs, merge all of them
        end = segmentInfos.size() - 1;
        docCountToMerge = docCountFromStart;
      }
&lt;p&gt;      else {&lt;br/&gt;
        // otherwise, merge some segments so that the docCount&lt;br/&gt;
        // of these segments is at least half of the remaining&lt;br/&gt;
        for (end = start; end &amp;lt; segmentInfos.size(); end++) {&lt;br/&gt;
          docCountToMerge += segmentInfos.info(end).docCount;&lt;br/&gt;
          if (docCountToMerge &amp;gt;= docCountFromStart / 2) &lt;/p&gt;
{
            break;
          }
&lt;p&gt;        }&lt;br/&gt;
      }&lt;/p&gt;

&lt;p&gt;      mergeSegments(start, end + 1);&lt;br/&gt;
      start++;&lt;br/&gt;
      docCountFromStart -= docCountToMerge;&lt;br/&gt;
    }&lt;br/&gt;
  }&lt;/p&gt;</comment>
                    <comment id="12443723" author="ninglili" created="Fri, 20 Oct 2006 08:00:25 +0100"  >&lt;p&gt;We want a robust algorithm for the version of addIndexes() which&lt;br/&gt;
does not call optimize().&lt;/p&gt;

&lt;p&gt;The robustness can be expressed as the two invariants guaranteed&lt;br/&gt;
by the merge policy for adding documents (if mergeFactor M does not&lt;br/&gt;
change and segment doc count is not reaching maxMergeDocs):&lt;br/&gt;
      B for maxBufferedDocs, f&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; defined as ceil(log_M(ceil(n/B)))&lt;br/&gt;
      1: If i (left*) and i+1 (right*) are two consecutive segments of doc&lt;br/&gt;
          counts x and y, then f&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &amp;gt;= f&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;br/&gt;
      2: The number of committed segments on the same level (f&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) &amp;lt;= M.&lt;/p&gt;

&lt;p&gt;References are at &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-dev/35147&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-dev/35147&lt;/a&gt;,&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-565&quot; title=&quot;Supporting deleteDocuments in IndexWriter (Code and Performance Results Provided)&quot;&gt;&lt;del&gt;LUCENE-565&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-672&quot; title=&quot;new merge policy&quot;&gt;&lt;del&gt;LUCENE-672&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;AddIndexes() can be viewed as adding a sequence of segments S to&lt;br/&gt;
a sequence of segments T. Segments in T follow the invariants but&lt;br/&gt;
segments in S may not since they could come from multiple indexes.&lt;br/&gt;
Here is the merge algorithm for addIndexes():&lt;/p&gt;

&lt;p&gt;1. Flush ram segments.&lt;/p&gt;

&lt;p&gt;2. Consider a combined sequence with segments from T followed&lt;br/&gt;
    by segments from S (same as current addIndexes()).&lt;/p&gt;

&lt;p&gt;3. Assume the highest level for segments in S is h. Call maybeMergeSegments(),&lt;br/&gt;
    but instead of starting w/ lowerBound = -1 and upperBound = maxBufferedDocs,&lt;br/&gt;
    start w/ lowerBound = -1 and upperBound = upperBound of level h.&lt;br/&gt;
    After this, the invariants are guaranteed except for the last &amp;lt; M segments&lt;br/&gt;
    whose levels &amp;lt;= h.&lt;/p&gt;

&lt;p&gt;4. If the invariants hold for the last &amp;lt; M segments whose levels &amp;lt;= h, done.&lt;br/&gt;
    Otherwise, simply merge those segments. If the merge results in&lt;br/&gt;
    a segment of level &amp;lt;= h, done. Otherwise, it&apos;s of level h+1 and call&lt;br/&gt;
    maybeMergeSegments() starting w/ upperBound = upperBound of level h+1.&lt;/p&gt;

&lt;p&gt;Suggestions?&lt;/p&gt;</comment>
                    <comment id="12443841" author="yseeley@gmail.com" created="Fri, 20 Oct 2006 14:34:05 +0100"  >&lt;p&gt;I think you need to ensure that no segments from the source index &quot;S&quot; remain after the call, right?&lt;/p&gt;</comment>
                    <comment id="12443911" author="ninglili" created="Fri, 20 Oct 2006 18:47:09 +0100"  >&lt;p&gt;&amp;gt; I think you need to ensure that no segments from the source index &quot;S&quot; remain after the call, right?&lt;/p&gt;

&lt;p&gt;Correct. And thanks!&lt;/p&gt;

&lt;p&gt;So in step 4, in the case where the invariants hold for the last &amp;lt; M segments whose levels &amp;lt;= h,&lt;br/&gt;
if some of those &amp;lt; M segments are from S (not merged in step 3), properly copy them over.&lt;/p&gt;

&lt;p&gt;Algorithm looks good?&lt;/p&gt;

&lt;p&gt;This makes me notice a bug in current addIndexes(Directory[]). In current addIndexes(Directory[]),&lt;br/&gt;
segment infos in S are added to T&apos;s &quot;segmentInfos&quot; upfront. Then segments in S are merged to T&lt;br/&gt;
several at a time. Every merge is committed with T&apos;s &quot;segmentInfos&quot;. So if a reader is opened on T&lt;br/&gt;
while addIndexes() is going on, it could see an inconsistent index.&lt;/p&gt;</comment>
                    <comment id="12443940" author="yseeley@gmail.com" created="Fri, 20 Oct 2006 22:05:59 +0100"  >&lt;p&gt;&amp;gt; Algorithm looks good? &lt;/p&gt;

&lt;p&gt;Yep, looks good.&lt;/p&gt;

&lt;p&gt;A possible optimization &lt;b&gt;far&lt;/b&gt; down the road for segments that need copying could be to &quot;steal&quot; the segments if rename/mv is supported (if they are both of the same Directory type, on the same partition for FSDirectories, etc), and if the caller indicated it was OK.  Rather than try to detect when it&apos;s safe, there could be an attachSegments(Directory[]) call.&lt;/p&gt;</comment>
                    <comment id="12443978" author="ninglili" created="Sat, 21 Oct 2006 01:00:32 +0100"  >&lt;p&gt;I&apos;ll submit a patch next week.&lt;/p&gt;</comment>
                    <comment id="12444541" author="ninglili" created="Tue, 24 Oct 2006 23:26:49 +0100"  >&lt;p&gt;This patch implements addIndexesNoOptimize() following the algorithm described earlier.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The patch is based on the latest version from trunk.&lt;/li&gt;
	&lt;li&gt;AddIndexesNoOptimize() is implemented. The algorithm description is included as comment and the code is commented.&lt;/li&gt;
	&lt;li&gt;The patch includes a test called TestAddIndexesNoOptimize which covers all the code in addIndexesNoOptimize().&lt;/li&gt;
	&lt;li&gt;maybeMergeSegments() was conservative and checked for more merges only when &quot;upperBound * mergeFactor &amp;lt;= maxMergeDocs&quot;. Change it to check for more merges when &quot;upperBound &amp;lt; maxMergeDocs&quot;.&lt;/li&gt;
	&lt;li&gt;Minor changes in TestIndexWriterMergePolicy to better verify merge invariants.&lt;/li&gt;
	&lt;li&gt;The patch passes all unit tests.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One more comment on the implementation:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;When we copy un-merged segments from S in step 4, ideally, we want to simply copy&lt;br/&gt;
    those segments. However, directory does not support copy yet. In addition, source may&lt;br/&gt;
    use compound file or not and target may use compound file or not. So we use&lt;br/&gt;
    mergeSegments() to copy each segment, which may cause doc count to change&lt;br/&gt;
    because deleted docs are garbage collected. That case is handled properly.  &lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12445041" author="yseeley@gmail.com" created="Thu, 26 Oct 2006 23:56:26 +0100"  >&lt;p&gt;Thanks Ning, I just committed this.&lt;br/&gt;
Wish I had had it some time ago &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.mail-archive.com/lucene-user@jakarta.apache.org/msg10758.html&quot; class=&quot;external-link&quot;&gt;http://www.mail-archive.com/lucene-user@jakarta.apache.org/msg10758.html&lt;/a&gt;&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12343586" name="AddIndexesNoOptimize.patch" size="20302" author="ninglili" created="Tue, 24 Oct 2006 23:26:48 +0100" />
                    <attachment id="12324426" name="AddIndexes.patch" size="9196" author="tamm" created="Wed, 22 Mar 2006 06:16:01 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 16 Aug 2006 19:27:23 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13222</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27199</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>