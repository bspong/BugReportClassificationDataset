<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:18:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2110/LUCENE-2110.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2110] Refactoring of FilteredTermsEnum and MultiTermQuery</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2110</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;FilteredTermsEnum is confusing as it is initially positioned to the first term. It should instead work like an uninitialized TermsEnum for a field before the first call to next() or seek().&lt;br/&gt;
FilteredTermsEnums cannot implement seek() as eg. NRQ or Automaton are not able to support this. Seeking is also not needed for MTQ at all, so seek can just throw UOE.&lt;br/&gt;
This issue changes some of the internal behaviour of MTQ and FilteredTermsEnum to allow also seeking in NRQ and Automaton (see comments below).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12442399">LUCENE-2110</key>
            <summary>Refactoring of FilteredTermsEnum and MultiTermQuery</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="thetaphi">Uwe Schindler</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Dec 2009 22:35:42 +0000</created>
                <updated>Fri, 10 May 2013 11:43:40 +0100</updated>
                    <resolved>Sun, 6 Dec 2009 21:32:40 +0000</resolved>
                            <version>4.0-ALPHA</version>
                                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12785645" author="thetaphi" created="Thu, 3 Dec 2009 23:46:07 +0000"  >&lt;p&gt;I will work on this tomorrow and provide a patch. I will also update the patch in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1606&quot; title=&quot;Automaton Query/Filter (scalable regex)&quot;&gt;&lt;del&gt;LUCENE-1606&lt;/del&gt;&lt;/a&gt; to move the initial seek out of ctor (its easy, see below).&lt;/p&gt;

&lt;p&gt;The setEnum method should be renamed in something like setInitialTermRef(). So the default impl of next() will seek to the correct term and do not seek by default (iterate all terms of field).&lt;/p&gt;</comment>
                    <comment id="12785983" author="thetaphi" created="Fri, 4 Dec 2009 16:18:52 +0000"  >&lt;p&gt;Here my patch for this.&lt;/p&gt;

&lt;p&gt;I rewrote the whole FilteredTermsEnum and made it natively support seeking needed for NRQ and Automaton.&lt;/p&gt;

&lt;p&gt;This initial patch is for review only, but all tests pass. I will try to modify Robert&apos;s patch, as soon as he provided me an updated Patch for Automaton flex branch.&lt;/p&gt;

&lt;p&gt;The enum works different than before:&lt;br/&gt;
It is positioned before the first term (like it should), seeking is no longer supported (as not needed for MTQ) and not implementable for seeking enums like NRQ or Automaton.&lt;/p&gt;

&lt;p&gt;In the constructor you give index reader and field name, as TermsEnum can only iterate one field in flex, this is no limitation.&lt;/p&gt;

&lt;p&gt;For non-seeking enums you can set the initial term to seek to with setInitialSeekTerm(TermRef) in the ctor. The rest of the enum then behaves as before.&lt;/p&gt;

&lt;p&gt;For seeking enums like Automaton/NRQ you override a secondary iterator method nextSeekTerm() that returns the next TermRef the underlying iterator should seek to. This method is called, when accept() returns END (and also on the first next() call, of course). The default impl of this method just returns the initial seek term as explained above one time and then null.&lt;/p&gt;

&lt;p&gt;Everything else stands in the javadocs.&lt;/p&gt;</comment>
                    <comment id="12785990" author="rcmuir" created="Fri, 4 Dec 2009 16:32:14 +0000"  >&lt;p&gt;Uwe, I will look at re-porting automaton to flex so you can test this. (now it has good tests and sort order/unicode crap is fixed and they should all pass).&lt;/p&gt;</comment>
                    <comment id="12785996" author="mikemccand" created="Fri, 4 Dec 2009 16:50:05 +0000"  >&lt;p&gt;This is a great improvement Uwe... I like it.&lt;/p&gt;

&lt;p&gt;Is an MTQ allowed to return nextSeekTerm&apos;s out of order?  (I know NRQ/automaton don&apos;t need to do so, but, if it&apos;s fine we should maybe call that out in the javadocs...).  Though, FilteredTermsEnum, being a &quot;TermsEnum&quot;, is &quot;supposed&quot; to return terms in getTermComparator() order... however its consumers (the rewrite methods for MTQ) usually don&apos;t in fact care.  Hmm I wonder if it should even subclass TermsEnum?  It doesn&apos;t seek and it&apos;s free to return terms in a different order...&lt;/p&gt;</comment>
                    <comment id="12786054" author="thetaphi" created="Fri, 4 Dec 2009 18:25:33 +0000"  >&lt;p&gt;Updated patch also incorporating the needed changes for SingleTermsEnum to make it work with new API. Now it is at least a 5-code-liner &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I also fixed a method call instead of parameter usage in TermRangeTermsEnum. Also added Mike&apos;s comment In my opinion, we should keep it as TermsEnum, even when seeking does not work, which is documented. In my code I often use PrefixTerm(s)Enum for autocomplete cases - works good - and for that it is only handles as a Term(s)Enum for iterating making it simplier to reuse code working on Term(s)Enums. Also made some mebers final, I forgot this during restructuring the code.&lt;/p&gt;

&lt;p&gt;What I forgot to mention: I made the abstract methods in FilteredTermsEnum also throw IOException, so maybe subclasses, doing strange things, would compile.&lt;/p&gt;</comment>
                    <comment id="12786072" author="mikemccand" created="Fri, 4 Dec 2009 18:54:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;In my opinion, we should keep it as TermsEnum, even when seeking does not work, which is documented&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, let&apos;s keep it as subclassing TermsEnum.  Maybe we should relax the docs for TermsEnum to state that each subclass determines order.  Nothing in TermsEnum itself requires a particular order.&lt;/p&gt;</comment>
                    <comment id="12786362" author="thetaphi" created="Sat, 5 Dec 2009 09:22:08 +0000"  >&lt;p&gt;New patch with the attribute support of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2109&quot; title=&quot;Make DocsEnum subclass of DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-2109&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Also fixes a bug in the BW compatibility layer of MTQ (if clause wrong).&lt;/li&gt;
	&lt;li&gt;Some code cleanup in FilteredTermsEnum (now easier to read, as next() and seekNextTerm is complicated).&lt;/li&gt;
	&lt;li&gt;Added EmptyTermsEnum for shortcuts (used by NRQ and TRQ on inverse ranges). This enum never does any disk I/O to terms dict, it is just empty. EmptyTermsEnum again supports seeking (although subclass of FilteredTermsEnum), but it is simple there, it returns just END &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will now port Automaton and apply will provide a combined patch there.&lt;/p&gt;</comment>
                    <comment id="12786411" author="markrmiller@gmail.com" created="Sat, 5 Dec 2009 14:21:38 +0000"  >&lt;p&gt;Hey Uwe, since your editing this code anyway, wanna add a comment fix for the ref of TermInfo here?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+          &lt;span class=&quot;code-comment&quot;&gt;// Loading the TermInfo from the terms dict here
&lt;/span&gt;+          &lt;span class=&quot;code-comment&quot;&gt;// should not be costly, because 1) the
&lt;/span&gt;+          &lt;span class=&quot;code-comment&quot;&gt;// query/filter will load the TermInfo when it
&lt;/span&gt;+          &lt;span class=&quot;code-comment&quot;&gt;// runs, and 2) the terms dict has a cache:&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12786425" author="thetaphi" created="Sat, 5 Dec 2009 15:02:13 +0000"  >&lt;p&gt;After porting Automaton, I realized, that the seeking code should be changed and made a little bit more flexible.&lt;/p&gt;

&lt;p&gt;AcceptStatus can now return 5 stati:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;YES, NO: Accept / not accept the term and go forward, the simple linear case that iterates until the end and filters terms (FuzzyQuery case, linear Automaton)&lt;/li&gt;
	&lt;li&gt;YES_AND_SEEK, NO_AND_SEEK: the same like above, but instead of simply going forward, nextSeekTerm() is called to retrieve a new term to seek to. This method is now supposed to always return a greater term than before, if not, the enumeration can end too early (see below).&lt;/li&gt;
	&lt;li&gt;END: end the enumeration, so seeking. This status is used by TermRangeQuery and PrefixQuery as before.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;nextSeekTerm() should always return a greater term that the last one before seeking. This is asserted by NRQ. It is not bad to do this, but after that the enum is no longer correctly sorted. Also, if the consumer reaches the last term of the underlying enum, call next() will end enumeration and so further terms in the nextSeekTerm() interation will not consulted (the same happens when END is returned in accept, of course).&lt;/p&gt;

&lt;p&gt;If nextSeekTerm() returns null, the enumeration is also ended, so it is not required to return AcceptStatus.END instead of X_AND_SEEK.&lt;/p&gt;</comment>
                    <comment id="12786426" author="thetaphi" created="Sat, 5 Dec 2009 15:04:04 +0000"  >&lt;p&gt;Mark: I do not know about what you are talking about (sorry, my brain is fuming after automaton).&lt;/p&gt;</comment>
                    <comment id="12786433" author="markrmiller@gmail.com" created="Sat, 5 Dec 2009 15:21:01 +0000"  >&lt;p&gt;No problem, we can get it after - its not really related, just figured since you were patching here anyway and I happened to notice it will taking a look at the patch:&lt;/p&gt;

&lt;p&gt;TermInfo is no longer used in flex, but its referenced in the above comment, in MTQ.&lt;/p&gt;
</comment>
                    <comment id="12786439" author="rcmuir" created="Sat, 5 Dec 2009 16:21:23 +0000"  >&lt;p&gt;Uwe, I really like what you have done here (as commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1606&quot; title=&quot;Automaton Query/Filter (scalable regex)&quot;&gt;&lt;del&gt;LUCENE-1606&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Seeking around in a filteredtermsenum is even simpler here. (in my opinion, this thing is very tricky with trunk and it is good to simplify)&lt;/p&gt;</comment>
                    <comment id="12786451" author="mikemccand" created="Sat, 5 Dec 2009 17:20:51 +0000"  >&lt;blockquote&gt;&lt;p&gt;nextSeekTerm() should always return a greater term that the last one before seeking. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Uwe, why was this constraint needed?  What goes wrong if we allow terms to be returned out of order?  The consumers of this (MTQ&apos;s rewrite methods) don&apos;t mind if terms are out of order, right?&lt;/p&gt;</comment>
                    <comment id="12786452" author="thetaphi" created="Sat, 5 Dec 2009 17:27:05 +0000"  >&lt;p&gt;It will work (theoretically) but can fail:&lt;br/&gt;
if you seek to the last term and accept it, the next call to next() will end the enum, even if there may be more positions to seek. You cannot rely on the fact that all seek terms are visited. Because of that it &lt;b&gt;should&lt;/b&gt; be foreward only, if other, you must know what you do&lt;/p&gt;</comment>
                    <comment id="12786457" author="thetaphi" created="Sat, 5 Dec 2009 18:10:35 +0000"  >&lt;p&gt;I have a solution for this problem: If the end of the enum is reached i just asks for a new term is seek==true (that is what iwas before). But nextPrefixTerm() gets the information that the end was already finished and &lt;b&gt;could&lt;/b&gt; return null then. This is important for automaton, because it would loop endless else (because it would produce terms and terms and terms... in nextSeekTerm).&lt;/p&gt;</comment>
                    <comment id="12786471" author="thetaphi" created="Sat, 5 Dec 2009 19:50:47 +0000"  >&lt;p&gt;Attached is patch that allows the TermsEnum to go backwards and not break if end of underlying TermsEnum is reached after next() or seek().&lt;/p&gt;

&lt;p&gt;The method nextSeekTerm() gets a boolean if the underlying TermsEnum is exhausted. Enums that work in order can the simply return null to break iteration. But they are free to reposition to a term before.&lt;/p&gt;</comment>
                    <comment id="12786475" author="thetaphi" created="Sat, 5 Dec 2009 20:01:16 +0000"  >&lt;p&gt;fixed patch - i have to stop for today.&lt;/p&gt;</comment>
                    <comment id="12786480" author="thetaphi" created="Sat, 5 Dec 2009 20:07:32 +0000"  >&lt;p&gt;Stop everything I get a collaps!!!!! Again wrong patch.&lt;/p&gt;</comment>
                    <comment id="12786482" author="thetaphi" created="Sat, 5 Dec 2009 20:19:22 +0000"  >&lt;p&gt;Now the final one.&lt;/p&gt;

&lt;p&gt;I somehow need a test enum which does very strange things like seeking forward and backwards and returning all strange stati.&lt;/p&gt;

&lt;p&gt;Will think about one tomorrow.&lt;/p&gt;</comment>
                    <comment id="12786486" author="thetaphi" created="Sat, 5 Dec 2009 20:35:28 +0000"  >&lt;p&gt;Robert and me analyzed the latest change. It is so complex and I am really not sure, if we should do this. It is impossible to maintain this.&lt;/p&gt;

&lt;p&gt;We should enforce only seeking forwards (even if MTQ could accept terms out of order). Violating TermsEnums order stupid, so we should use the patch before. NRQ and also Automaton enforce stepping forwards only.&lt;/p&gt;

&lt;p&gt;Mike?&lt;/p&gt;</comment>
                    <comment id="12786487" author="rcmuir" created="Sat, 5 Dec 2009 20:38:51 +0000"  >&lt;p&gt;yeah compared to the last patch, the backwards seeking makes the code more complex in my opinion.&lt;/p&gt;

&lt;p&gt;i do not understand why a MTQ would need to backwards seek? Can we say instead if you want to do such a thing with flexible indexing, that the way is to instead define custom sort order in your codec?&lt;/p&gt;
</comment>
                    <comment id="12786494" author="thetaphi" created="Sat, 5 Dec 2009 20:48:50 +0000"  >&lt;p&gt;+1, I reverted it here completely. It is not senseful to support unordered filtered enums. If somebody wants to implement that he should do it otherwise by overriding next() himself and not use nextSeekTerm() and accept().&lt;/p&gt;</comment>
                    <comment id="12786587" author="mikemccand" created="Sun, 6 Dec 2009 09:40:49 +0000"  >&lt;blockquote&gt;&lt;p&gt;We should enforce only seeking forwards (even if MTQ could accept terms out of order). Violating TermsEnums order stupid, so we should use the patch before. NRQ and also Automaton enforce stepping forwards only.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, I hadn&apos;t realized this was adding so much complexity to the code, so I agree let&apos;s revert it and require FTE to always move forward according to getTermComparator its actualEnum.  We don&apos;t have a need for this today, anyway.  Design for today &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12786610" author="thetaphi" created="Sun, 6 Dec 2009 12:18:40 +0000"  >&lt;p&gt;From our IRC chat between Mike and me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; ThetaPhi_: mike: any further comments for 2110?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: am just trying to look at it &amp;#8211; waiting on a sloooooow svn up.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; ThetaPhi_: this out of order is not trivial and makes code for automaton and NRQ more complicated&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: the change is a great step forward&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: yeah forget it &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; ThetaPhi_: you understood the problem&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: i had thought it was nearly free&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: i don&apos;t fully understand the problem&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:19&amp;#93;&lt;/span&gt; mikemccand: impossible to keep up with you!!&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:20&amp;#93;&lt;/span&gt; ThetaPhi_: when the underlying enum is exhausted (I was exhausted yesterday, too), it stops processing, even if there are more nextSeelkTerms&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:20&amp;#93;&lt;/span&gt; mikemccand: yes I saw your exhausted pun &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:20&amp;#93;&lt;/span&gt; mikemccand: wait &amp;#8211; if a TermsEnum becomes exhaused, you&apos;re unable to seek it again?  is that the issue?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:20&amp;#93;&lt;/span&gt; ThetaPhi_: waht you could do is, that after the underlying enum is exhausted, that you call nextSeekTerm and reposition&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:21&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:21&amp;#93;&lt;/span&gt; ThetaPhi_: you could seek it&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:21&amp;#93;&lt;/span&gt; ThetaPhi_: and this worked at the beginning (first patch without the additional enum constants)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:21&amp;#93;&lt;/span&gt; ThetaPhi_: what it did was: when the underlying enum was exhausted it simply called nextSeekTerm and seeked&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:22&amp;#93;&lt;/span&gt; mikemccand: so TermsEnum API allows seeks after next()&apos;ing to exhaustion, right?  (I think it should but maybe it&apos; doesn&apos;t somewhere?)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:22&amp;#93;&lt;/span&gt; ThetaPhi_: which was ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:22&amp;#93;&lt;/span&gt; ThetaPhi_: mikemccand: your enums works perfect&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:22&amp;#93;&lt;/span&gt; ThetaPhi_: they can be seeked everytime even when exhausted&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:22&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:23&amp;#93;&lt;/span&gt; ThetaPhi_: the problem is logic in filteredtermsenum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:23&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:23&amp;#93;&lt;/span&gt; ThetaPhi_: it gets very complicated when you want to support two things:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:23&amp;#93;&lt;/span&gt; ThetaPhi_: a) seeking on request (NO_AND_SEEK, YES_AND_SEEK)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:24&amp;#93;&lt;/span&gt; ThetaPhi_: b) and want to consume all nextSeekTerms()&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:24&amp;#93;&lt;/span&gt; ThetaPhi_: if somebody seeks after _AND_SEEK to e.g. the last term of the enum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:24&amp;#93;&lt;/span&gt; ThetaPhi_: in the current impl it will read that term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:25&amp;#93;&lt;/span&gt; ThetaPhi_: call termCompare and so on&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:25&amp;#93;&lt;/span&gt; ThetaPhi_: if this accepts the term or not accepts the term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:25&amp;#93;&lt;/span&gt; ThetaPhi_: it will call next() on the underlying enum again&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:25&amp;#93;&lt;/span&gt; ThetaPhi_: which then returns null&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; ThetaPhi_: with the current patch it will then also end the filteredtermsenum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; mikemccand: ok &amp;#8211; so the termination logic inside FTE.next() got really hairy if on getting null from the actualEnum you had to consider going back for another seek term?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; ThetaPhi_: i tried it yesterday&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; mikemccand: we certainly don&apos;t need to support thist oday&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:26&amp;#93;&lt;/span&gt; ThetaPhi_: and I had no good test&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:27&amp;#93;&lt;/span&gt; ThetaPhi_: yes exactly&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:27&amp;#93;&lt;/span&gt; mikemccand: if somehow this ever becomes needed then we add it then&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:27&amp;#93;&lt;/span&gt; mikemccand: the new FTE looks great&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:27&amp;#93;&lt;/span&gt; ThetaPhi_: the idea was to provide a param to nextSeekTerm which denotes if the underlying enum ended&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:27&amp;#93;&lt;/span&gt; mikemccand: NRQ is soooo much simpler &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:28&amp;#93;&lt;/span&gt; ThetaPhi_: the idea was to call even on exit nextSeekTerm(true), where triue meant exhausted&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:28&amp;#93;&lt;/span&gt; mikemccand: i see &amp;#8211; so it involved different API&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:28&amp;#93;&lt;/span&gt; ThetaPhi_: TEnums like NRQ or automaton only going forward then know, not to provide seek terms again&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:28&amp;#93;&lt;/span&gt; ThetaPhi_: this was important for Automaton not to fall into endless loops&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:29&amp;#93;&lt;/span&gt; mikemccand: this is hairy stuff &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:29&amp;#93;&lt;/span&gt; ThetaPhi_: and good for NRQ to not provide any further terms&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:30&amp;#93;&lt;/span&gt; ThetaPhi_: when I tried to implement there was always a problem and you were not able to correctly define waht should happen then&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:30&amp;#93;&lt;/span&gt; mikemccand: how come the switch in FTE.next doesn&apos;t have &quot;case NO&quot; on the return from accept(term)?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:31&amp;#93;&lt;/span&gt; ThetaPhi_: thats not needed it just falls through and loops to next term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:31&amp;#93;&lt;/span&gt; ThetaPhi_: you could add it as NO: break;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:31&amp;#93;&lt;/span&gt; * mikemccand ahh got it &amp;#8211; maybe just add comment saying so&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:31&amp;#93;&lt;/span&gt; ThetaPhi_: good idea, will do&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:32&amp;#93;&lt;/span&gt; ThetaPhi_: the NO_AND_seek case is the same it just says doSeek = true&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:32&amp;#93;&lt;/span&gt; ThetaPhi_: and for yes it returns the term in both cases, but records doSeek for the next time next() is called&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:32&amp;#93;&lt;/span&gt; mikemccand: i wonder if we could simply add a seek term to AcceptStatus?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:33&amp;#93;&lt;/span&gt; mikemccand: vs calling the separate nextSeekTerm method&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:33&amp;#93;&lt;/span&gt; ThetaPhi_: enum&apos;s contents are final&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:33&amp;#93;&lt;/span&gt; mikemccand: not sure it&apos;d be better... just wondering&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:33&amp;#93;&lt;/span&gt; ThetaPhi_: because each constant is a singleton, they should be unmodifiable&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:34&amp;#93;&lt;/span&gt; mikemccand: ie, fix AcceptStatus to be like TermsEnum.SeekResult&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:34&amp;#93;&lt;/span&gt; mikemccand: so it returns status, but also an optional seekTerm which if null means no seeking&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:34&amp;#93;&lt;/span&gt; ThetaPhi_: and how to do this, not with an enum constant&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:34&amp;#93;&lt;/span&gt; ThetaPhi_: because they are constants&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:35&amp;#93;&lt;/span&gt; ThetaPhi_: and createing a new object on each accept call seems not ideal&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:35&amp;#93;&lt;/span&gt; mikemccand: sorry, i was confused &amp;#8211; SeekStatus used to be a class that had two attrs &amp;#8211; a TermRef, and the enum; i simplified that a while ago&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; ThetaPhi_: aaaah&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; ThetaPhi_: now its an enum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; ThetaPhi_: i do not think its a ood idea to return new objects&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; mikemccand: right.  for a while I had no TermsEnum.term()&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; mikemccand: the enums would reuse their status object&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:36&amp;#93;&lt;/span&gt; mikemccand: ie API would require that this is fine&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:37&amp;#93;&lt;/span&gt; ThetaPhi_: but enums are singleton&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:37&amp;#93;&lt;/span&gt; ThetaPhi_: for the whole JVM&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:37&amp;#93;&lt;/span&gt; mikemccand: if we did that... then we could go back to YES/NO/END, and, and seekTerm is then orthogonal&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:37&amp;#93;&lt;/span&gt; ThetaPhi_: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:37&amp;#93;&lt;/span&gt; ThetaPhi_: so a protected setSeekTerm&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:38&amp;#93;&lt;/span&gt; mikemccand: we&apos;d make a new &quot;AcceptResult&quot; class.  has &quot;AcceptStatus status&quot; member, and also &quot;TermRef seekTerm&quot;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:38&amp;#93;&lt;/span&gt; ThetaPhi_: then we are back at the state before, we should ask robert&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:38&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:38&amp;#93;&lt;/span&gt; ThetaPhi_: for him the separation of accept and nextSeekTerm was good&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:38&amp;#93;&lt;/span&gt; mikemccand: ahh i see&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; ThetaPhi_: but he could do the calculation of the next sring in accept, too&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; mikemccand: though, can&apos;t he simply emulate?  ie, internally call a private nextSeekTerm, stick it on the returned AcceptResult, and return that?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; mikemccand: right&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; ThetaPhi_: telephone...&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; mikemccand: do we ever call nextSeekTerm, unless AcceptStatus was XXX_AND_SEEK?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; mikemccand: hah real world interrupts&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:40&amp;#93;&lt;/span&gt; ThetaPhi_: thats what is done currentl&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:40&amp;#93;&lt;/span&gt; ThetaPhi_: brb&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:41&amp;#93;&lt;/span&gt; mikemccand: man all of infra seems slow right now... jira giving me intermittent Internal Server Error... svn really slow&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;10:41&amp;#93;&lt;/span&gt; mikemccand: git is tempting&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:04&amp;#93;&lt;/span&gt; *** jwtoddii has joined #lucene.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:15&amp;#93;&lt;/span&gt; *** jwtoddii has signed off IRC ().&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:15&amp;#93;&lt;/span&gt; ThetaPhi_: re&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:15&amp;#93;&lt;/span&gt; mikemccand: hello&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:15&amp;#93;&lt;/span&gt; ThetaPhi_: for me infra works normal&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; mikemccand: hmmm&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; ThetaPhi_: but maybe because i am on the euorpe svn&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; mikemccand: you use the eu mirrors?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; ThetaPhi_: but for jira i do not know&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; mikemccand: jira is on/off for me now&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:16&amp;#93;&lt;/span&gt; ThetaPhi_: do not think there is a mirror&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:17&amp;#93;&lt;/span&gt; ThetaPhi_: &lt;span class=&quot;error&quot;&gt;&amp;#91;10:39&amp;#93;&lt;/span&gt; mikemccand: do we ever call nextSeekTerm, unless AcceptStatus was XXX_AND_SEEK?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:17&amp;#93;&lt;/span&gt; ThetaPhi_: no&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:18&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:18&amp;#93;&lt;/span&gt; ThetaPhi_: and doSeek is always reset to false whenever a seek occured&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:19&amp;#93;&lt;/span&gt; ThetaPhi_: the global doSeek is just for the YES_AND_SEEK case&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:19&amp;#93;&lt;/span&gt; ThetaPhi_: because it exits the loop and returns the term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:19&amp;#93;&lt;/span&gt; ThetaPhi_: so on the next call to next() doSeek is true and we seek&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:20&amp;#93;&lt;/span&gt; mikemccand: got it&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:21&amp;#93;&lt;/span&gt; ThetaPhi_: an idea about the nextSeekTerm:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:21&amp;#93;&lt;/span&gt; ThetaPhi_: we add a protected setSeekTerm(TermRef)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:21&amp;#93;&lt;/span&gt; ThetaPhi_: this sets a private var&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:22&amp;#93;&lt;/span&gt; ThetaPhi_: accept can set this and return YES or no wahtever&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:22&amp;#93;&lt;/span&gt; ThetaPhi_: in the case of END it is ignored&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:22&amp;#93;&lt;/span&gt; ThetaPhi_: but when next() is then called again, if this internal seek varaible is != null it seeks, else it goes forward with next&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:22&amp;#93;&lt;/span&gt; ThetaPhi_: and after seek it is set to null&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:23&amp;#93;&lt;/span&gt; ThetaPhi_: and we could add an assert inside this method to check if only seeking forward&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:24&amp;#93;&lt;/span&gt; ThetaPhi_: to inform implementors of errors&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:24&amp;#93;&lt;/span&gt; ThetaPhi_: assert termComp.compare(seekTerm, term()) &amp;gt; 0;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:24&amp;#93;&lt;/span&gt; mikemccand: why not simply return the optional seek term along w/ AcceptStatus?  it&apos;d require no additional methods, and makes it clear that seeking part of accepting. &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:25&amp;#93;&lt;/span&gt; mikemccand: ie the existince of new methods in the api (setSeekTerm, nextSeekTerm) enrich the api &amp;#8211; make you wonder when you can call them.  eg can ctor call setSeekTerm?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:25&amp;#93;&lt;/span&gt; ThetaPhi_: because accept status is an enum constant which is final, singleton and &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:25&amp;#93;&lt;/span&gt; ThetaPhi_: yes ctor can do it at the moment&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:25&amp;#93;&lt;/span&gt; ThetaPhi_: its already there its only called setinitialseekterm&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:26&amp;#93;&lt;/span&gt; ThetaPhi_: (see docs)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:26&amp;#93;&lt;/span&gt; mikemccand: i mean make a new class (AcceptResult), like i described.  it contains an AcceptResult.Status (the enum), and a TermRef.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:26&amp;#93;&lt;/span&gt; ThetaPhi_: the problem is lots of object creation&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:26&amp;#93;&lt;/span&gt; mikemccand: there would be no object creation &amp;#8211; we&apos;d reuse?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:26&amp;#93;&lt;/span&gt; ThetaPhi_: in my opinion setSeekTerm is simplier to use&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:27&amp;#93;&lt;/span&gt; ThetaPhi_: it would be the same like the reuse case&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:27&amp;#93;&lt;/span&gt; ThetaPhi_: and setseekterm can also be used in ctor&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:27&amp;#93;&lt;/span&gt; mikemccand: yeah the fact that ctor needs to set initial term does seem to require the extra method&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:28&amp;#93;&lt;/span&gt; mikemccand: though i also don&apos;t like side-effect methods &amp;#8211; you change the internal state of the class, vs returning the seek term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:28&amp;#93;&lt;/span&gt; mikemccand: ie it makes the api stateful, which except for the initial case, is overkill&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:29&amp;#93;&lt;/span&gt; ThetaPhi_: its an iterator it always has an internal state&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:29&amp;#93;&lt;/span&gt; ThetaPhi_: i understand your problem&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:29&amp;#93;&lt;/span&gt; ThetaPhi_: you call in a method that should only accept something a method that changes state&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:30&amp;#93;&lt;/span&gt; mikemccand: the internal state is handled by FTE; my subclass is mostly stateless, if i return the seek term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:30&amp;#93;&lt;/span&gt; ThetaPhi_: so you cannot call it from outside (which would not wrok, because it is protected)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:30&amp;#93;&lt;/span&gt; ThetaPhi_: NRQ also has a state and also automaton&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:31&amp;#93;&lt;/span&gt; ThetaPhi_: in NRQ it is the linkedlist with seek terms&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:31&amp;#93;&lt;/span&gt; ThetaPhi_: in Automaton the nextString()&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:31&amp;#93;&lt;/span&gt; mikemccand: right, they have their own state because of how they iterate.  it&apos;s just that seek term need not be stateful.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:32&amp;#93;&lt;/span&gt; ThetaPhi_: i think we should ask robert, at the moment i would know how to change his code to support both cases&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:33&amp;#93;&lt;/span&gt; mikemccand: in fact, instead of setInitialSeekTerm, could we have getInitialSeekTerm?  ie FTE would invoke that once on start&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:33&amp;#93;&lt;/span&gt; mikemccand: ok &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:33&amp;#93;&lt;/span&gt; mikemccand: automaton is scary&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:33&amp;#93;&lt;/span&gt; mikemccand: and, powerful&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:33&amp;#93;&lt;/span&gt; ThetaPhi_: the getInitialSeek term in the current api is hidden behind the iterator&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:34&amp;#93;&lt;/span&gt; ThetaPhi_: setInitialSeekTerm for the ctor is just a convenience&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:34&amp;#93;&lt;/span&gt; ThetaPhi_: to prevent subclasses like prefixtermsenum from overrideing and implementing the singleton itertor&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:34&amp;#93;&lt;/span&gt; * mikemccand w/ getInitialSeekTerm, there is no sneaky shared state w/ FTE.  i mean, FTE keeps track of its state, and each subclass tracks its own state.  subclassing wouldn&apos;t even be necessary anymore &amp;#8211; one could provdie a standonalone TermsEnumFilter, that just has getInitialSeekTerm and accept&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:34&amp;#93;&lt;/span&gt; ThetaPhi_: (see docs)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:36&amp;#93;&lt;/span&gt; mikemccand: in general I don&apos;t like subclassing APIs &amp;#8211; it&apos;s a bigger surface area (how child works w/ parent, stateful methods, when can i call each method, etc.)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:36&amp;#93;&lt;/span&gt; ThetaPhi_: we could remove that also in the current api&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; ThetaPhi_: only abstract classes should be subclassable&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; ThetaPhi_: thats asked very often&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; mikemccand: gonna be a cold run this AM &amp;#8211; 28F out there&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; ThetaPhi_: &lt;b&gt;calculating&lt;/b&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; mikemccand: &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:37&amp;#93;&lt;/span&gt; mikemccand: invert 32 + 9/5 * C&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:38&amp;#93;&lt;/span&gt; ThetaPhi_: or ask google&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:38&amp;#93;&lt;/span&gt; ThetaPhi_: -2.22 &#176;C &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:39&amp;#93;&lt;/span&gt; ThetaPhi_: (Link: &lt;a href=&quot;http://www.google.de/search?hl=de&amp;amp;safe=off&amp;amp;q=28+fahrenheit+in+celsius&amp;amp;meta=&amp;amp;aq=f&amp;amp;oq=)http://www.google.de/search?hl=de&amp;amp;safe=off&amp;amp;q=28+fahrenheit+in+celsius&amp;amp;meta=&amp;amp;aq=f&amp;amp;oq=&quot; class=&quot;external-link&quot;&gt;http://www.google.de/search?hl=de&amp;amp;safe=off&amp;amp;q=28+fahrenheit+in+celsius&amp;amp;meta=&amp;amp;aq=f&amp;amp;oq=)http://www.google.de/search?hl=de&amp;amp;safe=off&amp;amp;q=28+fahrenheit+in+celsius&amp;amp;meta=&amp;amp;aq=f&amp;amp;oq=&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:39&amp;#93;&lt;/span&gt; mikemccand: if i jump in and see that, to use FTE i only have to implement to an interface (TermsEnumFilter) that has getInitialTerm/accept... I think that&apos;s more approachable than figuring out the relationship  (methods, state) to an abstract parent class&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:39&amp;#93;&lt;/span&gt; mikemccand: nice&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:40&amp;#93;&lt;/span&gt; mikemccand: ugh, zillions of conflicts on backporting thread safe spellchecker&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:40&amp;#93;&lt;/span&gt; ThetaPhi_: if the abstract parent class makes all other methods final its the same&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:41&amp;#93;&lt;/span&gt; ThetaPhi_: but ok, you could change MTQ to just return the interface&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:41&amp;#93;&lt;/span&gt; mikemccand: not really the same &amp;#8211; you have to define when each overridden method is allowed/supposed to invoke the methods from the parent&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:42&amp;#93;&lt;/span&gt; mikemccand: once (if) we make the interaction stateless,we suddenly have the freedom to make it a separate interface...&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:43&amp;#93;&lt;/span&gt; ThetaPhi_: you mean calling next() inside accept() -&amp;gt; loops forever&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:43&amp;#93;&lt;/span&gt; mikemccand: yeah &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:43&amp;#93;&lt;/span&gt; mikemccand: of course... that freedom of the orig FilteredTermEnum is what made NRQ sneakiness possible in the first place &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:44&amp;#93;&lt;/span&gt; ThetaPhi_: (which was a hack, you have seen the comment: something like: this relys on how setEnum() works, if this changes in the superclass this enum will no longer work)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; ThetaPhi_: this was a comment before i removed the recursion in one of this issues&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; mikemccand: right &amp;#8211; but it was the right hting to do at the time&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; mikemccand: sure was tricky to undertsand &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; ThetaPhi_: (ore remove the recursion, like it is now in trunk)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; mikemccand: you were bound by FTE&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; mikemccand: yes, that&apos;s better&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:45&amp;#93;&lt;/span&gt; mikemccand: but i like separate interface best &amp;#8211; it removes all shared state &amp;#8211; one thing describes what&apos;s filtered, the other implements according to that&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:46&amp;#93;&lt;/span&gt; mikemccand: then MTQ could almost simply accept a TermsEnum.  the only difference is difference() &amp;#8211; ha&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:46&amp;#93;&lt;/span&gt; mikemccand: it&apos;s only fuzzy that uses difference() right?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:46&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:46&amp;#93;&lt;/span&gt; ThetaPhi_: i was thinking about that&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; ThetaPhi_: because a empty prefix filter could simply return the termsenum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; mikemccand: ahh yes nice opto&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; ThetaPhi_: PrefixQuery(&quot;&quot;)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; ThetaPhi_: would match all documents that have at least any term&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; mikemccand: actually how come contrib/queries&apos; TermsFilter isn&apos;t a query filter wrapper around an MTQ?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; ThetaPhi_: in automaton we need this for the catch all .* case&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:47&amp;#93;&lt;/span&gt; mikemccand: ahh&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:48&amp;#93;&lt;/span&gt; ThetaPhi_: at the moment it generates a PrefixTermsEnum(&quot;&quot;)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:48&amp;#93;&lt;/span&gt; mikemccand: so maybe AcceptResult has a float difference?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:48&amp;#93;&lt;/span&gt; ThetaPhi_: which is slower than just returning the TermsEnum of the reader, just because of difference&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; ThetaPhi_: because it calls startsWith for each term (which in fact does nothing because termref.length==0&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; mikemccand: ugh&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; ThetaPhi_: so not that bad&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; mikemccand: much better to simple return .terms() for field.  or, rewrite to MatchAllDocs&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; ThetaPhi_: or a termrangequery(null,null) (often used in solr)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; ThetaPhi_: no&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:49&amp;#93;&lt;/span&gt; ThetaPhi_: MatchAllDocs is different&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; ThetaPhi_: because the Prefix(&quot;&quot;) case only returns document that have at least one term of that field&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; mikemccand: ahhh yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; ThetaPhi_: this is needed for facetting i think in Solr&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; ThetaPhi_: not sure&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; mikemccand: got it&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:50&amp;#93;&lt;/span&gt; ThetaPhi_: in NRQ its fast, it just enumerates all low-prec terms&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:51&amp;#93;&lt;/span&gt; ThetaPhi_: 16 for precStep=4&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:51&amp;#93;&lt;/span&gt; mikemccand: nice&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:51&amp;#93;&lt;/span&gt; mikemccand: NRQ is a great step forward for lucene&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:51&amp;#93;&lt;/span&gt; mikemccand: would be nice if MTQ could simply accept a TermsEnum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; mikemccand: problem is difference()&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; ThetaPhi_: and is only used by fuzzy&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; mikemccand: yes, annoying for just that one case&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; mikemccand: contrib&apos;s TermsFilter really ought to be an MTQ&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:52&amp;#93;&lt;/span&gt; ThetaPhi_: because robert asked for a alltermsenum, which is stupied&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:53&amp;#93;&lt;/span&gt; mikemccand: yeah&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:53&amp;#93;&lt;/span&gt; ThetaPhi_: i only said, user prefix(&quot;&quot;) whoich is ok, the overhead is minimal, but in this case it would be zero&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:53&amp;#93;&lt;/span&gt; mikemccand: we could allow MTQ to accept either a TersmsEnum, or, a TermsEnumFilter (this new stateless interface, with AcceptResult also having a float difference field)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:53&amp;#93;&lt;/span&gt; ThetaPhi_: aaaah&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:54&amp;#93;&lt;/span&gt; ThetaPhi_: but that looks like attributesource&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:54&amp;#93;&lt;/span&gt; ThetaPhi_: differenceattribute&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:54&amp;#93;&lt;/span&gt; mikemccand: yeah that&apos;s true&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:54&amp;#93;&lt;/span&gt; ThetaPhi_: termsenums are already with attributes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:54&amp;#93;&lt;/span&gt; mikemccand: curious.  so then MTQ could accept only TermsEnum, but, ask for its attrs, and if that&apos;s non-null, as for differenceattr, and if htat&apos;s non null, use it&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; ThetaPhi_: fuzzyenum just add this attribute&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; mikemccand: i like that!&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; ThetaPhi_: and fuzzyquery requests it&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; mikemccand: and MTQ respects it too&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; ThetaPhi_: and the default of this attribute is 1.0&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; mikemccand: ye&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; mikemccand: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:55&amp;#93;&lt;/span&gt; ThetaPhi_: so mtq just asks always for this attribute in scoring boolean rewrite&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:56&amp;#93;&lt;/span&gt; mikemccand: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:56&amp;#93;&lt;/span&gt; mikemccand: and, MTQ is much simplified to accept a TermsEnum for its terms&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:56&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:56&amp;#93;&lt;/span&gt; mikemccand: and we can make a stateless API for filtering a TermsEnum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:57&amp;#93;&lt;/span&gt; ThetaPhi_: by the way, I did not check ever&amp;lt;ything in flex&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:57&amp;#93;&lt;/span&gt; mikemccand: that&apos;s ok &amp;#8211; it&apos;s an immense number of changes!&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:57&amp;#93;&lt;/span&gt; ThetaPhi_: but if you wrap an enum, you must override attributes() to return the attributes of the delegate&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:57&amp;#93;&lt;/span&gt; mikemccand: i still keep finding bugs in the emulation layers.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:57&amp;#93;&lt;/span&gt; mikemccand: hmm you&apos;re right&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: so UnionTermsEnum or like so must override attributes() and call delegate.attributes()&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; mikemccand: or, fuzzy query could be the only one that does htis&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: no&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: let it in MTQ&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: we yesterday talked, normally rewrite should be final in MTQ&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; mikemccand: that sounds good&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; ThetaPhi_: you should only change behaviour in getEnum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:58&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:59&amp;#93;&lt;/span&gt; ThetaPhi_: in trunk we currently rewrite WildCardQuery to PrefixQuery which is itsself an MTQ&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:59&amp;#93;&lt;/span&gt; ThetaPhi_: totally useless&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:59&amp;#93;&lt;/span&gt; ThetaPhi_: just return PrefixEnum in getEnum&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;11:59&amp;#93;&lt;/span&gt; mikemccand: ahh right&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:00&amp;#93;&lt;/span&gt; ThetaPhi_: in flex i changed&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:00&amp;#93;&lt;/span&gt; ThetaPhi_: the problem are bw tests in trunk, because they check the rewritten thing, but we could simply remove the tests&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; mikemccand: tests shouldn&apos;t check internals like that&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; ThetaPhi_: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; ThetaPhi_: or these checks should be marked&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; mikemccand: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; ThetaPhi_: in Junit4 with an annotation&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; mikemccand: ahh what annotation?&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:01&amp;#93;&lt;/span&gt; ThetaPhi_: and the bw tests only run tests without that annotation&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:02&amp;#93;&lt;/span&gt; mikemccand: that sounds great&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:02&amp;#93;&lt;/span&gt; ThetaPhi_: the problem may then still compilation&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; ThetaPhi_: if it checks package protected fields and so on&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; ThetaPhi_: brrr&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; ThetaPhi_: we have such tests&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; mikemccand: sigh.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; mikemccand: yes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; mikemccand: i remember committing them &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; *** mikemccand has left #lucene.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:03&amp;#93;&lt;/span&gt; ThetaPhi_: you always have to remove them&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:22&amp;#93;&lt;/span&gt; *** mikemccand has joined #lucene.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:22&amp;#93;&lt;/span&gt; mikemccand: sorry, dropped off&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:25&amp;#93;&lt;/span&gt; ThetaPhi_: ok i said&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:25&amp;#93;&lt;/span&gt; ThetaPhi_: i will try out a little bit&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:25&amp;#93;&lt;/span&gt; ThetaPhi_: and post in the automaton&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:25&amp;#93;&lt;/span&gt; mikemccand: ok&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:25&amp;#93;&lt;/span&gt; ThetaPhi_: its hard to always generate both pacthes&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:26&amp;#93;&lt;/span&gt; ThetaPhi_: when we are happy, i will post a patch to 2110 and then we commit&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;12:26&amp;#93;&lt;/span&gt; ThetaPhi_: in automaton there is more special cases to test&lt;/p&gt;&lt;/blockquote&gt;</comment>
                    <comment id="12786613" author="rcmuir" created="Sun, 6 Dec 2009 12:39:07 +0000"  >&lt;p&gt;Hey guys, in my opinion it would make it easier if we could somehow iterate in the flex branch under this issue.&lt;/p&gt;

&lt;p&gt;Do we really need a monster patch right now that is 100% perfect or can we exploit having this branch available to make discussions and review easier?&lt;/p&gt;

&lt;p&gt;For example, it seems everyone agrees the current patch here is a good &quot;step forward&quot;.&lt;/p&gt;</comment>
                    <comment id="12786660" author="thetaphi" created="Sun, 6 Dec 2009 17:47:01 +0000"  >&lt;p&gt;New patch that implements the Attributes implementation to power scoring BooleanQuery searches. It changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;MTQ.getTermsEnum now returns TermsEnum no longer a filtered one&lt;/li&gt;
	&lt;li&gt;As in flex, MTQ can only work on one field (because TermsEnum is limited to one Field), it gets a getField() method (highlighter is happy) and a ctor to set this final field (protected). Removed all thoise methods from sub classes. Old classes that still use TermEnum and call the deprec default ctor, still work (because the field is returned in the FilteredTermEnum), but highligter gots no field then (null). Whne BW is removed, highlighter do not need to use FakeIndexReader anymore.&lt;/li&gt;
	&lt;li&gt;WildcardQuery/PrefixQuery/TermRangeQuery was optimized to no longer rewrite, but just return the correct enum in getEnum/getTermsEnum(). The special cases for these queries are match all (directly return the enum from reader - new!!!, nothing EmptyTermsEnum, or SingleTermsEnum)&lt;/li&gt;
	&lt;li&gt;Fixed Highlighter for MTQ.getField()&lt;/li&gt;
	&lt;li&gt;FuzzyQuery now uses an attribute for the term difference: MTQ.TermDifferenceAttribute. For scoring booolean rewrite it is added by the consumer and keeps 1 per default, but fuzzy enum also adds it in its ctor and sets in accept()). Also the PQ boolean rewrite mode is now a RewriteMode.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think thats all. Happy reviewing.&lt;/p&gt;</comment>
                    <comment id="12786663" author="mikemccand" created="Sun, 6 Dec 2009 18:08:14 +0000"  >&lt;p&gt;Patch looks good Uwe &amp;#8211; just TestWildcard.testPrefixTerm, on back-compat tests, that&apos;s failing.  This is a nice simplification of MTQs...&lt;/p&gt;

&lt;p&gt;I&apos;m wondering if we can further simplify the &quot;seek&quot; case in FilteredTermsEnum so that it&apos;s not a 2 step process (FTE.accept returns YES|NO_AND_SEEK, then, FTE.next calls nextSeekTerm), ie instead accept would return the new seek term in the returned status.  This would also make the interaction between FTE and its subclass stateless.  But let&apos;s take that up under a separate issue.  I think this one is ready to go into flex branch?&lt;/p&gt;</comment>
                    <comment id="12786671" author="thetaphi" created="Sun, 6 Dec 2009 19:01:30 +0000"  >&lt;p&gt;New patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;better error message in NPE&lt;/li&gt;
	&lt;li&gt;change TermDifferenceAttribute to BoostAttribute and also its method names.&lt;/li&gt;
	&lt;li&gt;added Javadocs to FilteredTermEnum to deprec difference and explian that you should use BoostAttribute&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this is committable &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12786705" author="thetaphi" created="Sun, 6 Dec 2009 21:16:52 +0000"  >&lt;p&gt;I&apos;ll commit this soon after I added some javadocs to BoostAttribute.&lt;/p&gt;</comment>
                    <comment id="12786709" author="thetaphi" created="Sun, 6 Dec 2009 21:32:39 +0000"  >&lt;p&gt;Committed revision: 887779&lt;/p&gt;</comment>
                    <comment id="12786717" author="thetaphi" created="Sun, 6 Dec 2009 22:02:30 +0000"  >&lt;p&gt;I forgot: Thank you all, Mike, Robert, Mark for all your suggestions in chat!&lt;/p&gt;</comment>
                    <comment id="12787401" author="thetaphi" created="Tue, 8 Dec 2009 10:40:32 +0000"  >&lt;p&gt;Here a small update that changed nextSeekTerm to also provide the current TermRef. It will be null on first call. This removes the ugly if (unitialized) code in Automaton.&lt;/p&gt;

&lt;p&gt;Also the delegate enum is now private, as its state should be unchangeable by subclasses.&lt;/p&gt;

&lt;p&gt;I will now work on a better approach with only accept using an extended AcceptStatus with next seek term). The current patch will now be committed.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                <outwardlinks description="blocks">
                            <issuelink>
            <issuekey id="12442406">LUCENE-2111</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12422990">LUCENE-1606</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12427321" name="LUCENE-2110-nextSeekTermUpd.patch" size="3289" author="thetaphi" created="Tue, 8 Dec 2009 10:40:32 +0000" />
                    <attachment id="12427107" name="LUCENE-2110.patch" size="81132" author="thetaphi" created="Sun, 6 Dec 2009 19:01:30 +0000" />
                    <attachment id="12427105" name="LUCENE-2110.patch" size="80110" author="thetaphi" created="Sun, 6 Dec 2009 17:47:01 +0000" />
                    <attachment id="12427048" name="LUCENE-2110.patch" size="43112" author="thetaphi" created="Sat, 5 Dec 2009 15:02:13 +0000" />
                    <attachment id="12427037" name="LUCENE-2110.patch" size="42879" author="thetaphi" created="Sat, 5 Dec 2009 09:22:08 +0000" />
                    <attachment id="12426931" name="LUCENE-2110.patch" size="36959" author="thetaphi" created="Fri, 4 Dec 2009 18:25:33 +0000" />
                    <attachment id="12426911" name="LUCENE-2110.patch" size="35328" author="thetaphi" created="Fri, 4 Dec 2009 16:18:52 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 4 Dec 2009 16:32:14 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11669</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25615</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>