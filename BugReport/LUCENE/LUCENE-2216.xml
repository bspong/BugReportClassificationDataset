<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:57:19 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2216/LUCENE-2216.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2216] OpenBitSet#hashCode() may return false for identical sets.</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2216</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;OpenBitSet uses an internal buffer of long variables to store set bits and an additional &apos;wlen&apos; index that points &lt;br/&gt;
to the highest used component inside &lt;/p&gt;
{@link #bits}
&lt;p&gt; buffer.&lt;/p&gt;

&lt;p&gt;Unlike in JDK, the wlen field is not continuously maintained (on clearing bits, for example). This leads to a situation when wlen may point&lt;br/&gt;
far beyond the last set bit. &lt;/p&gt;

&lt;p&gt;The hashCode implementation iterates over all long components of the bits buffer, rotating the hash even for empty components. This is against the contract of hashCode-equals. The following test case illustrates this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// initialize two bitsets with different capacity (bits length).
&lt;/span&gt;BitSet bs1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BitSet(200);
BitSet bs2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; BitSet(64);
&lt;span class=&quot;code-comment&quot;&gt;// set the same bit.
&lt;/span&gt;bs1.set(3);
bs2.set(3);
        
&lt;span class=&quot;code-comment&quot;&gt;// equals returns &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; (passes).
&lt;/span&gt;assertEquals(bs1, bs2);
&lt;span class=&quot;code-comment&quot;&gt;// hashCode returns &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; (against contract).
&lt;/span&gt;assertEquals(bs1.hashCode(), bs2.hashCode());
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fix and test case attached.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12445729">LUCENE-2216</key>
            <summary>OpenBitSet#hashCode() may return false for identical sets.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="dawidweiss">Dawid Weiss</reporter>
                        <labels>
                    </labels>
                <created>Sat, 16 Jan 2010 12:20:55 +0000</created>
                <updated>Wed, 1 Dec 2010 14:49:50 +0000</updated>
                    <resolved>Tue, 23 Nov 2010 13:21:34 +0000</resolved>
                            <version>2.9</version>
                <version>2.9.1</version>
                <version>3.0</version>
                                <fixVersion>2.9.4</fixVersion>
                <fixVersion>3.0.3</fixVersion>
                                <component>core/other</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12801182" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 15:10:44 +0000"  >&lt;p&gt;Thanks Dawid!&lt;/p&gt;

&lt;p&gt;hashCode and equals probably shouldn&apos;t be modifying the state of the object though, right?&lt;br/&gt;
It&apos;s also not thread safe, so a lot of weird things could happen... the simplest example is that two threads could check that the last word is all zeros and both decrement wlen.&lt;/p&gt;

&lt;p&gt;I like the spirit of your change though, as it only adds to the cost of hashCode/equals (which are already very expensive with large bitsets and should be avoided if possible anyway).&lt;/p&gt;</comment>
                    <comment id="12801183" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 15:14:59 +0000"  >&lt;p&gt;I haven&apos;t tested this patch, but this seems like a simple solution.  Start with a zero hashcode while iterating backward and the trailing zeros won&apos;t affect the hashcode.&lt;/p&gt;</comment>
                    <comment id="12801195" author="dawidweiss" created="Sat, 16 Jan 2010 15:43:35 +0000"  >&lt;p&gt;Hi Yonik,&lt;/p&gt;

&lt;p&gt;This class is not thread-safe anyway (there are no memory barriers of any kind anywhere in the code).&lt;/p&gt;

&lt;p&gt;From a single-thread perspective, yes, you are modifying the internal state of this object, but it&apos;s not really affecting anything other than possibly speeding up further interaction with this object (any other operation no OpenBitSets is affected by the value inside wlen).&lt;/p&gt;

&lt;p&gt;Your patch also solves the issue, of course. I just don&apos;t see the point in &lt;em&gt;not&lt;/em&gt; updating wlen since you&apos;re scanning through memory anyway... The implementation of OpenBitSet is different in this regard to java.util.BitSet, which always maintains the last non-empty index. I&apos;ve been thinking about it a bit and there are pros and cons to both implementations, but lazily moving wlen when memory is scanned anyway seems like a better alternative than keeping wlen unnecessarily large (which affects ORs, ANDs and other set operations).&lt;/p&gt;

&lt;p&gt;To me this implementation cannot be used in a multi-threaded application anyway, am I wrong here?&lt;/p&gt;

&lt;p&gt;D.&lt;/p&gt;</comment>
                    <comment id="12801198" author="dawidweiss" created="Sat, 16 Jan 2010 15:47:49 +0000"  >&lt;p&gt;Perhaps this is for another patch, but BitUtil contains several bit-counting methods (pop, ntz) that have been implemented in the JDK in the same way (Hacker&apos;s Delight) and will come with HotSpot intrinsics for the new Intels (&lt;a href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6823354&quot; class=&quot;external-link&quot;&gt;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6823354&lt;/a&gt;). On the other hand, Lucene&apos;s implementation may be useful for folks with older VMs...&lt;/p&gt;</comment>
                    <comment id="12801200" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 15:57:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;To me this implementation cannot be used in a multi-threaded application anyway, am I wrong here?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pretty much any mutable object may be safely shared with other threads after it&apos;s done being modified.  So one thread could create, and many threads could read.  I don&apos;t know how explicitly it&apos;s spelled out in Java, but hashCode and  equals shouldn&apos;t modify the object&apos;s state in any meaningful way.&lt;/p&gt;</comment>
                    <comment id="12801221" author="dawidweiss" created="Sat, 16 Jan 2010 16:59:18 +0000"  >&lt;p&gt;This is only true if there is happens-before between the reads and the modifications to the object. In any other case other threads may be reading stale values (i.e., from their own cache), at least if my understanding of the jmm is correct here. Whether you want to rely on such a deep semantics of interaction between threads is something to consider deeply, at least in my personal opinion.&lt;/p&gt;</comment>
                    <comment id="12801230" author="dawidweiss" created="Sat, 16 Jan 2010 17:25:35 +0000"  >&lt;p&gt;This is not entirely what I had in mind (it&apos;s not cache, but HotSpot optimisation), but similar situation applies (the value of the field that&apos;s never modified from the perspective of the current thread is never re-read).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class Example10 {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; Holder holder;

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void startThread() {
        &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;() {
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
                &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; { sleep(2000); } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) { /* ignore */ }
                holder.ready = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;Setting ready to &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;.&quot;&lt;/span&gt;);
            }
        }.start();
    }

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; [] args) {
        holder = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Holder();
        startThread();
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!holder.ready) {
            &lt;span class=&quot;code-comment&quot;&gt;// Do nothing.
&lt;/span&gt;        }
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m ready.&quot;&lt;/span&gt;);
    }
}

class Holder {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; ready;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you run it with -server, it will (should... or does on two machines I own) deadlock. Client mode and interpreted mode are not optimized, so it passes.&lt;/p&gt;</comment>
                    <comment id="12801235" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 17:34:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;This is only true if there is happens-before between the reads and the modifications to the object. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Of course... I said &quot;may be safely shared&apos;, not that any method one chooses to share it is correct.&lt;br/&gt;
It still seems that promoting hashCode and equals to mutating operations is wrong, no?&lt;/p&gt;</comment>
                    <comment id="12801240" author="dawidweiss" created="Sat, 16 Jan 2010 17:54:32 +0000"  >&lt;p&gt;uff, I started having doubts in my own understanding, thanks for being patient with me.&lt;/p&gt;

&lt;p&gt;I agree that having hashCode mutate the object&apos;s state is weird. I had some thoughts about it &amp;#8211; this particular mutation seems to be &quot;safe&quot; even from multi-threaded point of view. If another thread sees a stale value of wlen, then the only thing that is going to happen is it will scan more memory; for ands, ors and other types of operations this will have no effect. So assuming hashCode/equals is the ONLY method you&apos;re calling concurrently, it shouldn&apos;t break things. A similar kind of trickery goes on in String#hashCode (caching to a non-volatile field), although that object is immutable, so it&apos;s a slightly different scenario.&lt;/p&gt;

&lt;p&gt;To be honest, my preference for this would be to either maintain the wlen field during all operations (like java.util.BitSet) or at least to clearly state (JavaDoc?) that trimTrailingZeros() should be invoked prior to publishing the object for other threads for increased performance (in case you fiddle with bits and clear the tail). In the second options, your patch does a fine job of not mutating the object and correcting the bug.&lt;/p&gt;

&lt;p&gt;Thanks for an interesting discussion.&lt;/p&gt;</comment>
                    <comment id="12801249" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 18:31:36 +0000"  >&lt;blockquote&gt;&lt;p&gt;I agree that having hashCode mutate the object&apos;s state is weird. I had some thoughts about it - this particular mutation seems to be &quot;safe&quot; even from multi-threaded point of view. If another thread sees a stale value of wlen, then the only thing that is going to happen is it will scan more memory;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There are still quite a few things that can go wrong I think.  If all threads &lt;b&gt;only&lt;/b&gt; called hashCode and equals, then you &lt;b&gt;might&lt;/b&gt; be right... it&apos;s very specific to the implementation of trimTrailingZeros()&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void trimTrailingZeros() {
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; idx = wlen-1;
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (idx&amp;gt;=0 &amp;amp;&amp;amp; bits[idx]==0) idx--;
    wlen = idx+1;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;What could make that work is the fact that wlen is an integer, is never directly used as the loop counter, or as an index into the array.&lt;/p&gt;

&lt;p&gt;But the other big questions: are other read operations tolerant of wlen changing out from under them?  My guess would be no.&lt;br/&gt;
Look at xorCount for example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (a.wlen &amp;lt; b.wlen) {
      tot += BitUtil.pop_array(b.bits, a.wlen, b.wlen-a.wlen);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;hashCode and equals changing wlen could cause a negative value to be passed to pop_array.&lt;/p&gt;

&lt;p&gt;edit: deleted second example, which isn&apos;t different from the first (the issue is safety with other read ops).&lt;/p&gt;</comment>
                    <comment id="12801263" author="dawidweiss" created="Sat, 16 Jan 2010 20:05:08 +0000"  >&lt;p&gt;Chances of this happening are really slim (this would probably be a single inlined read as soon as the compilation takes place, but you&apos;re right in the general case. I am not arguing changing the object in hashCode is good &amp;#8211; my argument is that ideally it should be fixed elsewhere (as in my previous suggestion &amp;#8211; either updating wlen every time the tail changes, or make explicit changes to the documentation that inform about suboptimal performance for zero-tailed sets).&lt;/p&gt;</comment>
                    <comment id="12801265" author="dawidweiss" created="Sat, 16 Jan 2010 20:10:04 +0000"  >&lt;p&gt;For what it&apos;s worth, I checked the mentioned BitUtil methods &amp;#8211; ntz/pop; the same implementation is included from Java 1.5 upward. Do you want me to file another patch for this, Yonik, or are we leaving this as-is? I&apos;d redirect from BitUtil to Long/Integer, deprecate BitUtil methods and replace the places in the code where they are used.&lt;/p&gt;</comment>
                    <comment id="12801266" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 20:23:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;my argument is that ideally it should be fixed elsewhere&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is an expert-level class... I don&apos;t think that every call to clear() should be checking if it completely cleared the last word.  It&apos;s easy enough to call trimTrailingZeros after you did a bunch of modifications... but not so easy to regain the lost performance for the code doing redundant checking you didn&apos;t want.&lt;/p&gt;</comment>
                    <comment id="12801269" author="dawidweiss" created="Sat, 16 Jan 2010 20:38:46 +0000"  >&lt;p&gt;Ok, argument accepted.&lt;/p&gt;</comment>
                    <comment id="12801270" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 20:42:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;For what it&apos;s worth, I checked the mentioned BitUtil methods - ntz/pop; the same implementation is included from Java 1.5 upward.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Huh - I didn&apos;t realize that Java5 had the same pop impl as I did... it will be cool if it finally starts using native POPCNT instructions.&lt;/p&gt;

&lt;p&gt;As far as ntz, I went though a lot of micro-optimizations and different implementations before I settled on the one used in BitUtil, so it would be nice to do some benchmarks to see if it&apos;s truly faster now (and also what the performance difference is for users of JVMs before this optimization was implemented).&lt;/p&gt;</comment>
                    <comment id="12801272" author="dawidweiss" created="Sat, 16 Jan 2010 21:01:34 +0000"  >&lt;p&gt;Ah, ok &amp;#8211; I thought ntz in BitUtils is the same as in hacker&apos;s delight, but it isn&apos;t. Microbenchmarks will always be misleading as they depend a lot on how you test, but I can do it out of sheer curiosity &amp;#8211; will report tomorrow.&lt;/p&gt;</comment>
                    <comment id="12801275" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 21:11:03 +0000"  >&lt;p&gt;Microbenchmarks will always be misleading as they depend a lot on how you test, but I can do it out of sheer curiosity - will report tomorrow.&lt;/p&gt;

&lt;p&gt;Cool.  I&apos;d recommend testing in the context of OpenBitSet (i.e. don&apos;t try testing ntz directly).&lt;br/&gt;
Perhaps just create a large random set (~1M bits) with a certain percent of bits set, and then iterate over those set bits.&lt;/p&gt;</comment>
                    <comment id="12801285" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 22:14:33 +0000"  >&lt;p&gt;Committed in trunk.  Thanks for bringing this up!&lt;/p&gt;</comment>
                    <comment id="12926252" author="rcmuir" created="Fri, 29 Oct 2010 13:57:41 +0100"  >&lt;p&gt;reopening for possible 2.9.4/3.0.3 backport.&lt;/p&gt;</comment>
                    <comment id="12934826" author="thetaphi" created="Tue, 23 Nov 2010 13:21:34 +0000"  >&lt;p&gt;Backported 3.0 revision: 1038096&lt;br/&gt;
Backported 2.9 revision: 1038098&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12430511" name="LUCENE-2216.patch" size="912" author="yseeley@gmail.com" created="Sat, 16 Jan 2010 15:14:59 +0000" />
                    <attachment id="12430504" name="openbitset.patch" size="1978" author="dawidweiss" created="Sat, 16 Jan 2010 12:45:14 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 16 Jan 2010 15:10:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11572</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25509</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>