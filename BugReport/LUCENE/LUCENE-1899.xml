<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:09:04 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1899/LUCENE-1899.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1899] Inefficient growth of OpenBitSet</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1899</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Hi, I found a potentially serious efficiency problem with OpenBitSet.&lt;/p&gt;

&lt;p&gt;One typical (I think) way to build a bit set is to set() the bits one by one -&lt;br/&gt;
e.g., have a HitCollector set() the bit for each matching document.&lt;br/&gt;
The underlying array of longs needs to grow as more as more bits are set, of&lt;br/&gt;
course.&lt;/p&gt;

&lt;p&gt;But looking at the code, it appears to me that the array grows very&lt;br/&gt;
ineefficiently - in the worst case (when doc ids are sorted, as they would&lt;br/&gt;
normally be in the HitCollector case for example), copying the array again&lt;br/&gt;
and again for every added bit... The relevant code in OpenBitSet.java is:&lt;/p&gt;

&lt;p&gt;  public void set(long index) &lt;/p&gt;
{
    int wordNum = expandingWordNum(index);
    ...
  }

&lt;p&gt;  protected int expandingWordNum(long index) {&lt;br/&gt;
    int wordNum = (int)(index &amp;gt;&amp;gt; 6);&lt;br/&gt;
    if (wordNum&amp;gt;=wlen) &lt;/p&gt;
{
      ensureCapacity(index+1);
    ...
  }
&lt;p&gt;  public void ensureCapacityWords(int numWords) {&lt;br/&gt;
    if (bits.length &amp;lt; numWords) &lt;/p&gt;
{
      long[] newBits = new long[numWords];
      System.arraycopy(bits,0,newBits,0,wlen);
      bits = newBits;
    }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;As you can see, if the bits array is not long enough, a new one is&lt;br/&gt;
allocated at exactly the right size - and in the worst case it can grow&lt;br/&gt;
just one word every time...&lt;/p&gt;

&lt;p&gt;Shouldn&apos;t the growth be more exponential in nature, e.g., grow to the maximum&lt;br/&gt;
of index+1 and twice the existing size?&lt;/p&gt;

&lt;p&gt;Alternatively, if the growth is so inefficient, this should be documented,&lt;br/&gt;
and it should be recommended to use the variant of the constructor with the&lt;br/&gt;
correct initial size (e.g., in the HitCollector case, the number of documents&lt;br/&gt;
in the index). and the fastSet() method instead of set().&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Nadav.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12435107">LUCENE-1899</key>
            <summary>Inefficient growth of OpenBitSet</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="nyh">Nadav Har&apos;El</reporter>
                        <labels>
                    </labels>
                <created>Tue, 8 Sep 2009 14:31:05 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:38 +0100</updated>
                    <resolved>Wed, 9 Sep 2009 12:52:05 +0100</resolved>
                            <version>2.9</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12752518" author="shaie" created="Tue, 8 Sep 2009 14:41:43 +0100"  >&lt;p&gt;I don&apos;t know about doubling the array size every time. There&apos;s ArrayUtil.getNextSize (a Lucene class) which seems to grow arrays in a mild fashion. the method is well documented, and I think it should be used by ensureCapacityWords.&lt;/p&gt;</comment>
                    <comment id="12752532" author="mikemccand" created="Tue, 8 Sep 2009 15:13:54 +0100"  >&lt;blockquote&gt;&lt;p&gt;There&apos;s ArrayUtil.getNextSize (a Lucene class) which seems to grow arrays in a mild fashion. the method is well documented, and I think it should be used by ensureCapacityWords.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12752931" author="nyh" created="Wed, 9 Sep 2009 07:28:45 +0100"  >&lt;p&gt;Hi Shai, I guess you&apos;re right that if there&apos;s such a utility function, we should probably use it.&lt;br/&gt;
I just wonder what is the rationale behind the specific formula in this function - basically newsize = oldsize * 1.125 + 6. This formula ensures that at worst case, just 6% of the array space is wasted (instead of 50% in the doubling approach), but the number of reallocations and copies is 8 times higher, and performance is proportionally slower (although obviously, both are linear in amortized time - which the current code isn&apos;t). Was there any thought given to why the factor 0.125 is better than 0.25, 0.5, 0.01 or 1.0? I&apos;m not saying that 1.0 (doubling) is best, just that I don&apos;t know why 0.125 is.&lt;/p&gt;</comment>
                    <comment id="12752994" author="mikemccand" created="Wed, 9 Sep 2009 10:20:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;This formula ensures that at worst case, just 6% of the array space is wasted&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean 12.5% right?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I just wonder what is the rationale behind the specific formula in this function&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s just a standard time/space tradeoff, that favors not wasting too much space.  This code was &quot;borrowed&quot; from Python&apos;s &quot;listobject.c&quot; sources, ie, it governs how Python over-allocates the storage for its list type.&lt;/p&gt;

&lt;p&gt;We could explore different constants though I&apos;d be nervous about making this value much higher.  Often the consumer of this API will see rapid growth initially, and then the collection stops growing and is re-used for a long time, in which case the long-term wasted RAM is (I think) more important than the one-time short-term CPU cost of finding the &quot;natural&quot; size.&lt;/p&gt;</comment>
                    <comment id="12753000" author="mikemccand" created="Wed, 9 Sep 2009 10:35:49 +0100"  >&lt;p&gt;Attached trivial patch.  I plan to commit soon...&lt;/p&gt;</comment>
                    <comment id="12753019" author="nyh" created="Wed, 9 Sep 2009 11:36:47 +0100"  >&lt;p&gt;Yes, you&apos;re right, 12.5%. Or actually, 11%=0.125/(1+0.125) of the space after an elargment is wasted. I don&apos;t know where I got this 6% from &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12753046" author="mikemccand" created="Wed, 9 Sep 2009 12:52:05 +0100"  >&lt;p&gt;Thanks Nadav!&lt;/p&gt;</comment>
                    <comment id="12753048" author="thetaphi" created="Wed, 9 Sep 2009 12:58:51 +0100"  >&lt;p&gt;I wanted to add just one comment:&lt;br/&gt;
For nomal Lucene usage, the auto-grow of the array is not needed. All internal Lucene code (collectors, filters) use IndexReader.maxDoc() as initial size param to the ctor. If you write own HitCollectors/Collectors(2.9), use the maxDoc() of the current IndexReader. With the new 2.9 Collectors, you would initialize the OpenBitSet in Collector.setNextReader().&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12419038" name="LUCENE-1899.patch" size="1384" author="mikemccand" created="Wed, 9 Sep 2009 10:35:49 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 8 Sep 2009 13:41:43 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11868</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25826</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>