<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:11:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2090/LUCENE-2090.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2090] convert automaton to char[] based processing and TermRef / TermsEnum api</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2090</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The automaton processing is currently done with String, mostly because TermEnum is based on String.&lt;br/&gt;
it is easy to change the processing to work with char[], since behind the scenes this is used anyway.&lt;/p&gt;

&lt;p&gt;in general I think we should make sure char[] based processing is exposed in the automaton pkg anyway, for things like pattern-based tokenizers and such.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12441407">LUCENE-2090</key>
            <summary>convert automaton to char[] based processing and TermRef / TermsEnum api</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Sun, 22 Nov 2009 21:03:08 +0000</created>
                <updated>Fri, 10 May 2013 11:44:12 +0100</updated>
                    <resolved>Thu, 10 Dec 2009 01:43:43 +0000</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12781222" author="mikemccand" created="Sun, 22 Nov 2009 21:32:05 +0000"  >&lt;p&gt;Spinoff from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1606&quot; title=&quot;Automaton Query/Filter (scalable regex)&quot;&gt;&lt;del&gt;LUCENE-1606&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12781233" author="rcmuir" created="Sun, 22 Nov 2009 22:01:09 +0000"  >&lt;p&gt;Michael, here is one idea that isn&apos;t too crazy.&lt;/p&gt;

&lt;p&gt;separately i think we should make it convenient for a MTQ to get a char[], this should not change.&lt;/p&gt;

&lt;p&gt;however, lets consider this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * Returns &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the given string is accepted by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; automaton.
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; run(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; p = initial;
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; l = s.length();
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; l; i++) {
      p = step(p, s.charAt(i));
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (p == -1) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; accept[p];
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;checking a string, is really just stepping thru one char at a time.&lt;br/&gt;
would &apos;incremental, one char at a time&apos; conversion actually help, or do you think it would just be slower?&lt;/p&gt;

&lt;p&gt;conceptually, this isn&apos;t that much different than using a Reader with java i/o, at a much smaller scale.&lt;br/&gt;
i am not familiar with decoding performance, but I thought I would mention this, just in the case there is a way to do it clean.&lt;/p&gt;</comment>
                    <comment id="12781249" author="rcmuir" created="Sun, 22 Nov 2009 23:29:15 +0000"  >&lt;p&gt;I changed only the accept(final TermRef term) method from Mike&apos;s flex patch of this enum to use char[], instead of string.&lt;br/&gt;
I did not modify the &quot;smart&quot; part, its more complex, but will probably help the ????NNN case.&lt;/p&gt;

&lt;p&gt;the results change significantly for the *N case (i used my old benchmark, just because it was already setup in my eclipse)&lt;/p&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Pattern&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Iter&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;AvgHits&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;AvgMS (String)&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;AvgMS (char[])&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;N?N?N?N&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;36.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;34.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;?NNNNNN&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;4.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;5.1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;??NNNNN&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;8.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;11.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;???NNNN&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;35.4&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;34.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;????NNN&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;250.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;230.9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;NN??NNN&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;9.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;5.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;NN?N*&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;8.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;7.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;?NN*&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;63.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;28.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;*N&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1000000.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3027.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1922.7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;NNNNN??&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;100.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</comment>
                    <comment id="12781344" author="mikemccand" created="Mon, 23 Nov 2009 09:30:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;would &apos;incremental, one char at a time&apos; conversion actually help, or do you think it would just be slower?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this idea!  It&apos;s worth exploring a Reader-like interface from UnicodeUtil?  Is this a hotspot in automaton&apos;s processing?  Ie, could we save much conversion by only doing it on demand?&lt;/p&gt;</comment>
                    <comment id="12781365" author="rcmuir" created="Mon, 23 Nov 2009 11:15:23 +0000"  >&lt;p&gt;Michael, I think i would have to profile things to determine this?&lt;br/&gt;
I guess it would be a close one, because strings in term dictionary are pretty short.&lt;br/&gt;
just an idea, i think moving all the code to char[] first would be the best for starters.&lt;/p&gt;</comment>
                    <comment id="12781694" author="rcmuir" created="Mon, 23 Nov 2009 23:07:20 +0000"  >&lt;p&gt;Hi Mike, I think an easier win is to perhaps add endsWith() byte[] comparison in TermRef.&lt;br/&gt;
(for now, I can use regular endsWith(), or run the machine backwards, or something like that).&lt;/p&gt;

&lt;p&gt;I can use this in &quot;dumb mode&quot;, i.e. *N, where I know the first part of the machine is a loop.&lt;br/&gt;
for whatever reason dumb mode checks &quot;constant prefix&quot; right now, which is useless, it will always be 0 in dumb mode.&lt;br/&gt;
instead I should build &quot;constant suffix&quot; in dumb mode. this would be much more useful for a quick comparison.&lt;/p&gt;</comment>
                    <comment id="12781710" author="mikemccand" created="Tue, 24 Nov 2009 00:17:27 +0000"  >&lt;p&gt;That sounds compelling &amp;#8211; you&apos;d still do the full scan, but testing each term is much faster?&lt;/p&gt;</comment>
                    <comment id="12781718" author="rcmuir" created="Tue, 24 Nov 2009 00:46:25 +0000"  >&lt;p&gt;right, we could use constant suffix to stay with bytes. &lt;br/&gt;
for example *N in this test, well 90% of the charset conversion of TermRefs disappears, because they can be eliminated by comparing bytes.&lt;/p&gt;</comment>
                    <comment id="12782065" author="rcmuir" created="Tue, 24 Nov 2009 18:12:47 +0000"  >&lt;p&gt;Mike, I implemented this common suffix, but only for dumb mode, it does not help smart mode.&lt;br/&gt;
so i got rid of common prefix entirely, as its useless, and just replaced it.&lt;br/&gt;
I also take measures to ensure the suffix is well-formed UTF-8 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;on my *N trunk tests its now 5700/5800ms on average versus 6000ms, just using String.endsWith() before checking the DFA.&lt;br/&gt;
its a consistent gain, so I think for really crappy worst-case wildcards and regular expressions, &lt;br/&gt;
we have a lot to gain by doing this with bytes, before converting to char[] and running against the DFA.&lt;/p&gt;

&lt;p&gt;I guess since TermRef exposes all the bytes, I could implement endsWith myself in AutomatonTermsEnum in the future, &lt;br/&gt;
but it seems like it would be a nice complement to startsWith() ?&lt;/p&gt;</comment>
                    <comment id="12782075" author="rcmuir" created="Tue, 24 Nov 2009 18:36:08 +0000"  >&lt;p&gt;I guess now you have me starting to think about byte[] contains()&lt;br/&gt;
Because really the real worst case, which I bet a lot of users do, are not things like *foobar but instead *foobar&amp;#42; !&lt;br/&gt;
in UTF-8 you can do such things safely, I would have to sucker out the &quot;longest common constant sequence&quot; out of a DFA.&lt;br/&gt;
This might be more generally applicable.&lt;/p&gt;

&lt;p&gt;commonSuffix is easy... at least it makes progress for now, even slightly later in trunk. &lt;/p&gt;

&lt;p&gt;this could be a later improvement.&lt;/p&gt;</comment>
                    <comment id="12782314" author="rcmuir" created="Wed, 25 Nov 2009 05:57:11 +0000"  >&lt;p&gt;Attached is a patch to TermRef to implement endsWith()&lt;/p&gt;

&lt;p&gt;this is a huge win on flex, even though constant suffix gain is very minor on trunk, because it avoids unicode conversion (char[]) for the worst cases that must do lots of comparisons.&lt;/p&gt;

&lt;p&gt;*N	1705.7ms avg -&amp;gt; 1195.4ms avg&lt;br/&gt;
*NNNNNN	1844.9ms avg -&amp;gt; 1192.3ms avg&lt;/p&gt;

&lt;p&gt;it doesn&apos;t really matter if the suffix is short, if there is a way in FilteredTermsEnum.accept() for a multitermquery to accept/reject a term without unicode conversion, it helps a lot.&lt;/p&gt;

&lt;p&gt;in my opinion, this is the cleanest way to improve these cases, other crazy ideas i have tossed around out here like the iterative &quot;reader-like&quot; conversion or even TermRef substring matching will probably not gain much more over this, will be a lot more complex, and only apply to automatonquery.&lt;/p&gt;

&lt;p&gt;Mike, if you get a chance to review, this, I&apos;ll commit it to flex branch (the tests pass).&lt;/p&gt;</comment>
                    <comment id="12782353" author="mikemccand" created="Wed, 25 Nov 2009 10:23:32 +0000"  >&lt;p&gt;Patch looks good, except, I think I wouldn&apos;t factor startsWith/endsWith to share any code, to save the &quot;+ pos&quot; inside startsWith&apos;s loop?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;*N	1705.7ms avg -&amp;gt; 1195.4ms avg&lt;br/&gt;
*NNNNNN	1844.9ms avg -&amp;gt; 1192.3ms avg&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa &amp;#8211; those are great results!&lt;/p&gt;</comment>
                    <comment id="12782384" author="rcmuir" created="Wed, 25 Nov 2009 12:13:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;Patch looks good, except, I think I wouldn&apos;t factor startsWith/endsWith to share any code, to save the &quot;+ pos&quot; inside startsWith&apos;s loop? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;forgive my ignorance, but shouldnt the JRE hoist this constant additive to the array index out anyway?&lt;br/&gt;
I checked, this is how harmony, etc implement startsWith/endsWith even for String...&lt;br/&gt;
(I will change it, just curious)&lt;/p&gt;</comment>
                    <comment id="12782395" author="rcmuir" created="Wed, 25 Nov 2009 12:37:30 +0000"  >&lt;p&gt;alternative patch for if you do not trust your compiler &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
I think the do the same thing though...&lt;/p&gt;</comment>
                    <comment id="12782401" author="mikemccand" created="Wed, 25 Nov 2009 12:57:01 +0000"  >&lt;blockquote&gt;&lt;p&gt;shouldnt the JRE hoist this constant additive to the array index out anyway?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;alternative patch for if you do not trust your compiler&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12782409" author="mikemccand" created="Wed, 25 Nov 2009 13:04:55 +0000"  >&lt;p&gt;BTW, we&apos;ve discussed someday having a codec whose terms dict (or maybe just terms index) is represented as an FST, at which point AutomatonTermsEnum would be an intersection + walk of two FSTs.  Because suffix&apos;s are also shared in the FST, you could more easily (more efficiently) handle &amp;#42;XXX cases as well (it&apos;d just be symmetic with the XXX&amp;#42; cases).&lt;/p&gt;</comment>
                    <comment id="12782412" author="mikemccand" created="Wed, 25 Nov 2009 13:06:49 +0000"  >&lt;p&gt;Maybe also make TermRef final in the patch?&lt;/p&gt;</comment>
                    <comment id="12782414" author="rcmuir" created="Wed, 25 Nov 2009 13:11:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;BTW, we&apos;ve discussed someday having a codec whose terms dict (or maybe just terms index) is represented as an FST&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;this would open up more opportunities.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe also make TermRef final in the patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;ok&lt;/p&gt;</comment>
                    <comment id="12782431" author="rcmuir" created="Wed, 25 Nov 2009 13:37:16 +0000"  >&lt;p&gt;Mike, here TermRef is final also. This doesn&apos;t remove any flexibility does it?&lt;br/&gt;
if the term dictionary is encoded in a different way (i.e. BOCU-1), will TermRef still be UTF-8 byte[] ?&lt;/p&gt;</comment>
                    <comment id="12782476" author="mikemccand" created="Wed, 25 Nov 2009 16:06:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;Mike, here TermRef is final also. This doesn&apos;t remove any flexibility does it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d actually rather lock it down for now, and then only open up flexibility when/if we get there... patch looks good!&lt;/p&gt;</comment>
                    <comment id="12782479" author="rcmuir" created="Wed, 25 Nov 2009 16:11:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;d actually rather lock it down for now, and then only open up flexibility when/if we get there... patch looks good!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok, I will commit it.&lt;/p&gt;

&lt;p&gt;Just as a side note, maybe i can add a comment if you need it... the existing startsWith(), and now the new endsWith() are correct against byte[] for any Unicode encoding form.&lt;br/&gt;
However, some other encodings (including alternate encodings someone might flex to), do not have the properties of non-overlap, etc.&lt;/p&gt;

&lt;p&gt;if someone was to implement a codec to store the index in one of those other encodings, they would have to write significantly more complex code that is aware of character boundaries, depending upon the properties of said encoding.&lt;br/&gt;
oh yeah, and their sort order would be different, too... (I suppose we should also fix compareTerm here for UTF-16 ordering at some point?)&lt;/p&gt;</comment>
                    <comment id="12782482" author="mikemccand" created="Wed, 25 Nov 2009 16:14:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;I suppose we should also fix compareTerm here for UTF-16 ordering at some point?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes... I&apos;m &lt;span class=&quot;error&quot;&gt;&amp;#91;slowly&amp;#93;&lt;/span&gt; working towards that.&lt;/p&gt;</comment>
                    <comment id="12782495" author="rcmuir" created="Wed, 25 Nov 2009 16:43:58 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yes... I&apos;m &lt;span class=&quot;error&quot;&gt;&amp;#91;slowly&amp;#93;&lt;/span&gt; working towards that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Glad it is you working on it instead of me. If I wrote it, it would be very slow.&lt;/p&gt;

&lt;p&gt;Committed revision 884190 for TermRef&lt;/p&gt;</comment>
                    <comment id="12782503" author="rcmuir" created="Wed, 25 Nov 2009 16:56:56 +0000"  >&lt;p&gt;Mike, by the way, looking at this code, I don&apos;t see a way to expose the UnicodeUtil / char[] functionality in a clean way via TermRef/FilteredTermsEnum.&lt;/p&gt;

&lt;p&gt;Once I see that most of the other enums survive with TermRef alone, and don&apos;t need it, and its handy to have multiple TermRefs around in the same enum,&lt;br/&gt;
it doesn&apos;t make sense I guess.&lt;/p&gt;

&lt;p&gt;Also I guess people in general aren&apos;t writing MultiTermQueries every day, so I think this is ok?&lt;br/&gt;
The rest of this issue should only involve automaton code itself...&lt;/p&gt;</comment>
                    <comment id="12782565" author="mikemccand" created="Wed, 25 Nov 2009 19:16:15 +0000"  >&lt;p&gt;OK I&apos;ll first focus on making sure DW flushes in UTF-16 sort order...&lt;/p&gt;</comment>
                    <comment id="12787175" author="rcmuir" created="Mon, 7 Dec 2009 22:29:51 +0000"  >&lt;p&gt;Mike, I converted this to char[] api (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1606&quot; title=&quot;Automaton Query/Filter (scalable regex)&quot;&gt;&lt;del&gt;LUCENE-1606&lt;/del&gt;&lt;/a&gt; for the patch).&lt;/p&gt;

&lt;p&gt;In order for this to work, I needed to expose UnicodeUtil.nextUTF16ValidString(UTF16Result). &lt;br/&gt;
The code is not duplicated, the String based method is just a wrapper for this, take a look if you get a chance.&lt;/p&gt;

&lt;p&gt;the other thing I forgot, I think TermRef.copy(UTF8Result) would be handy... is there anywhere you could use this too?&lt;/p&gt;

&lt;p&gt;edit: i meant utf-8 result, sorry&lt;/p&gt;</comment>
                    <comment id="12787389" author="mikemccand" created="Tue, 8 Dec 2009 10:13:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;Mike, I converted this to char[] api&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nice!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;the other thing I forgot, I think TermRef.copy(UTF8Result) would be handy... is there anywhere you could use this too?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds reasonable &amp;#8211; maybe just add it?  Or... we could also deprecate UTF8Result, entirely, replacing it w/ TermRef...?  Hmmm.&lt;/p&gt;</comment>
                    <comment id="12788444" author="rcmuir" created="Thu, 10 Dec 2009 01:43:42 +0000"  >&lt;p&gt;i am marking this one resolved, the goals have been met (char[]/byte[] based processing and TermRef/TermsEnum api)&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12422990">LUCENE-1606</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12426095" name="LUCENE-2090_TermRef_flex2.patch" size="1239" author="rcmuir" created="Wed, 25 Nov 2009 12:37:30 +0000" />
                    <attachment id="12426099" name="LUCENE-2090_TermRef_flex3.patch" size="1515" author="rcmuir" created="Wed, 25 Nov 2009 13:37:16 +0000" />
                    <attachment id="12426074" name="LUCENE-2090_TermRef_flex.patch" size="1128" author="rcmuir" created="Wed, 25 Nov 2009 05:57:11 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 22 Nov 2009 21:32:05 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11689</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25635</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>