<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:03:49 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-937/LUCENE-937.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-937] Make CachingTokenFilter faster</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-937</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The LinkedList used by CachingTokenFilter is accessed using the get() method. Direct access on a LinkedList is slow and an Iterator should be used instead. For more than a handful of tokens, the difference in speed grows exponentially.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12372166">LUCENE-937</key>
            <summary>Make CachingTokenFilter faster</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="markrmiller@gmail.com">Mark Miller</reporter>
                        <labels>
                    </labels>
                <created>Thu, 21 Jun 2007 22:21:54 +0100</created>
                <updated>Sat, 23 Jun 2007 16:57:21 +0100</updated>
                    <resolved>Sat, 23 Jun 2007 16:57:21 +0100</resolved>
                                                                    <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12507033" author="markrmiller@gmail.com" created="Thu, 21 Jun 2007 22:25:58 +0100"  >&lt;p&gt;Actually, I think the starting size should probably be upped as well. I will do some tests.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507044" author="doronc" created="Thu, 21 Jun 2007 22:58:29 +0100"  >&lt;p&gt;Good catch, patch look good to me.&lt;br/&gt;
It makes sense to modify anyhow, but just wondering, - what is the performance difference?&lt;/p&gt;

&lt;p&gt;While we&apos;re looking at this, I noticed three other uses of LinkedList that can be changed to ArrayList: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DocumentWriter&lt;/li&gt;
	&lt;li&gt;CompoundFileWriter&lt;/li&gt;
	&lt;li&gt;MultipleTermPositions&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507071" author="michaelbusch" created="Fri, 22 Jun 2007 00:37:39 +0100"  >&lt;p&gt;&amp;gt; While we&apos;re looking at this, I noticed three other uses of LinkedList &lt;br/&gt;
&amp;gt; that can be changed to ArrayList: &lt;/p&gt;

&lt;p&gt;Well, an ArrayList is not always faster than a LinkedList, is it? &lt;br/&gt;
A LinkedList should be faster for insertions and removals in the middle &lt;br/&gt;
of the list compared to an ArrayList. So I think we have to understand &lt;br/&gt;
how the lists are used in the different spots before we replace them.&lt;/p&gt;

&lt;p&gt;To this patch: I actually chose LinkedList here intentionally because&lt;br/&gt;
random-access to the list is not needed here. We only iterate over the&lt;br/&gt;
list and I expected the performance to be comparable to the ArrayList.&lt;br/&gt;
But inconsequently I used the get() method instead of a list iterator,&lt;br/&gt;
which is for sure slower compared to the ArrayList. I wonder how the &lt;br/&gt;
LinkedList would perform if we changed this class to use an iterator?&lt;/p&gt;

&lt;p&gt;Thanks Mark your efforts here!&lt;/p&gt;</comment>
                    <comment id="12507080" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 02:03:19 +0100"  >&lt;p&gt;My tests early must have gotten out of whack. I was measuring a much bigger difference than I see now.&lt;/p&gt;

&lt;p&gt;As a result, I started from scratch, carefully creating and lableing a new Lucene core jar for each case and averaging the performance over 15,000 calls creating and reading TokenStreams off the Reuters data.&lt;/p&gt;

&lt;p&gt;After very thorough testing (I was in quite a hurry this morning), I have come up with the following:&lt;/p&gt;

&lt;p&gt;LinkedList() using get, LinkedList() using iterator, and ArrayList() are practically identical in speed.&lt;/p&gt;

&lt;p&gt;ArrayList(30) gave a 47% increase in speed. Above 30-60 gave no more returns.&lt;/p&gt;

&lt;p&gt;This patch should not go through as is. What do you think given these results? I assumed that an ArrayList would be faster as all of the data is guaranteed contiguous, but it surprised me that the resizing was not enough to slow things down to LinkedList speed (unless you start with too low an initial size &amp;#8211; default is 10).&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507088" author="doronc" created="Fri, 22 Jun 2007 02:31:22 +0100"  >&lt;p&gt;&amp;gt; Mark: I assumed that an AL would be faster as all of the data is guaranteed contiguous&lt;/p&gt;

&lt;p&gt;Only the pointers to the objects are contiguous, right? The tokens themselves are, well, where they are. But with LinkedList there are new objects created, containing the tokens and the pointers to the other list members. So it may be safe to say that if you can estimate the list size (avoiding array grow), AL is preferable if there&apos;s no add/remove not at the end. &lt;/p&gt;

&lt;p&gt;&amp;gt; Michael: (~)  LL iterator comparable to AL&lt;/p&gt;

&lt;p&gt;That&apos;s a good point. I had the impression that AL is always simpler than LL and unless removing or adding not at the end, it is preferable. (that&apos;s why I excluded the NgramTokenFiltrers that use LL.removeFirst()).  Now you&apos;re saying that with iteration (instead of direct access) LinkedList is supposed to be faster - could be, since then there&apos;s no need to grow the array. (however you have more &quot;pointers&quot;). &lt;/p&gt;

&lt;p&gt;With this reasoning - &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;CompoundFileWriter - using iterator, no direct access.&lt;/li&gt;
	&lt;li&gt;MultipleTermPositions -  same.&lt;/li&gt;
	&lt;li&gt;DocumentWRiter - same.&lt;br/&gt;
So I am not so sure anymore about needing to change in these classes.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;---------------&lt;/p&gt;

&lt;p&gt;In summary since we can&apos;t assume estimating the size in advance, I think the best change would be as Michael suggested to use Iterator in CachingTokenFilter. &lt;/p&gt;</comment>
                    <comment id="12507089" author="michaelbusch" created="Fri, 22 Jun 2007 02:40:49 +0100"  >&lt;p&gt;&amp;gt; This patch should not go through as is. What do you think given these &lt;br/&gt;
&amp;gt; results? I assumed that an ArrayList would be faster as all of the data &lt;br/&gt;
&amp;gt; is guaranteed contiguous, but it surprised me that the resizing was not &lt;br/&gt;
&amp;gt; enough to slow things down to LinkedList speed (unless you start with &lt;br/&gt;
&amp;gt; too low an initial size &amp;#8211; default is 10).&lt;/p&gt;

&lt;p&gt;I think an ArrayList also has higher initialization costs. Your test&lt;br/&gt;
actually tests the performance for a single document. It would be &lt;br/&gt;
interesting to know how the different implementations perform when you &lt;br/&gt;
run the tests with more than one document. I would think that LinkedList() &lt;br/&gt;
is probably better if you have lots of very small documents, whereas&lt;br/&gt;
ArrayList(30) is faster if you have bigger docs with lots of Tokens.&lt;/p&gt;
</comment>
                    <comment id="12507092" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 03:01:55 +0100"  >&lt;p&gt;The 15,000 calls are each on a separate document. The documents are reletivley small...newspapers articles from Reuters. Anything smaller would have to be very small.&lt;/p&gt;

&lt;p&gt;I have again carefully tested LinkedList get VS LinkedList iterator and the performance is identical as far as I can tell.&lt;/p&gt;

&lt;p&gt;I&apos;ll do more work to prove my case when I get a free moment, but just to be clear:&lt;/p&gt;

&lt;p&gt;I am using small documents (15,000 different varying sized docs), measuring the total time and dividing by 15,000. The results show a 43% improvement using ArrayList(30). I will run a test will even smaller docs when I get a chance. In my work with a new Span based Highlighter, I need this speed or my implementation is slower than the old Highlighter. With this boost, my Span based Highlighter is actually (very)slightly faster. If you decide to keep things as they are I will have to roll an alternate CachingTokenFilter for my Highlighter (no problem of course &amp;lt;g&amp;gt;).&lt;/p&gt;

&lt;p&gt;Perhaps it is best to just leave things as they are and if you need more performance on docs with more than a handful of tokens, make your own Caching Filter. If the common case is closer to docs the size of newspaper articles or larger, a 43% gain is hard to ignore. &lt;/p&gt;

&lt;p&gt;I will get back about the speed when using very short documents.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;Only the pointers to the objects are contiguous, right? &lt;br/&gt;
One of these days I will actually make that transition from C++ to Java &amp;lt;g&amp;gt; I don&apos;t know where the speed is coming from then...but its a heck of a difference.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507093" author="michaelbusch" created="Fri, 22 Jun 2007 03:15:37 +0100"  >&lt;p&gt;&amp;gt; If you decide to keep things as they are I will have to roll an &lt;br/&gt;
&amp;gt; alternate CachingTokenFilter for my Highlighter (no problem of &lt;br/&gt;
&amp;gt; course &amp;lt;g&amp;gt;).&lt;/p&gt;

&lt;p&gt;I&apos;m certainly up to make a change here if it improves performance&lt;br/&gt;
significantly (and yes, 43% is significant). I just want to be &lt;br/&gt;
sure that we don&apos;t optimize a special case. So yes, it would be &lt;br/&gt;
great if you could vary the parameters in your tests. &lt;/p&gt;

&lt;p&gt;Btw. which JVM version are you using? &lt;/p&gt;</comment>
                    <comment id="12507094" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 03:19:27 +0100"  >&lt;p&gt;&amp;gt; So it may be safe to say that if you can estimate the list size (avoiding array grow), AL is preferable if there&apos;s no add/remove not at the end.&lt;/p&gt;

&lt;p&gt;In the CachingTokenFilter case I don&apos;t even believe it is really necessary to estimate the list size. Many of the documents I used had way more than 30 tokens, but initializing the Array larger gave no benefits. I believe this is because the ArrayList doubles each time it grows (not guaranteed, but how it is implemented), and so a small increase in size can dramatically lower the number of resizes needed even when the List must grow &lt;b&gt;much&lt;/b&gt; bigger than the init size. 10 just doesn&apos;t cut it, but 30 works great. A LinkedList (iterator or get()) seems to perform no better than an ArrayList(10).&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507233" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 13:50:12 +0100"  >&lt;p&gt;I am testing on Java 1.5&lt;/p&gt;

&lt;p&gt;I tested with LinkedList using get, LinkedList using iterator, ArrayList() (defaults to 10), ArrayList(16), ArrayList(30), ArrayList(60)&lt;/p&gt;

&lt;p&gt;For a handful of tokens, all methods are about the same speed. (3-10 tokens) LinkedList, ArrayList(16) and ArrayList are a smidgen faster than ArrayList(30-60) though.&lt;/p&gt;

&lt;p&gt;At 15-40 tokens all of the methods are still about the same speed, though ArrayList(30) may be a hair faster (than even ArrayList(10))&lt;/p&gt;

&lt;p&gt;At 50-300 tokens (weighted towards 50), you see a 47% increase in speed using ArrayList(16 or 30) and ArrayList(60), the other methods are about the same speed.&lt;/p&gt;

&lt;p&gt;At 150-900 tokens (weighted towards 150), you see a 100% increase in speed using ArrayList(30) &amp;#8211; ArrayList(60) is no better,&lt;br/&gt;
the other methods take twice as long (even ArrayList(10)).&lt;/p&gt;


&lt;p&gt;I used Reuters data, shortening it and stiching it together for the various sizes.&lt;/p&gt;

&lt;p&gt;The first test was the average speed of about 21,000 runs on 21,000 different docs.&lt;/p&gt;

&lt;p&gt;The second test was the average speed of about 21,000 runs on 21,000 different docs.&lt;/p&gt;

&lt;p&gt;The third test was the average speed of about 15,000 runs on 15,000 different docs.&lt;/p&gt;

&lt;p&gt;The fourth test was the average speed of about 5,000 runs on 5,000 different docs.&lt;/p&gt;


&lt;p&gt;I don&apos;t completely understand why, but ArrayList(30) or ArrayList(16) blow everything else out of the water. ArrayList(16) is a smidgen faster at very low&lt;br/&gt;
token counts, while ArrayList(30) is a smidgen faster above 50 or so tokens. The differences are almost negligible though.&lt;/p&gt;

&lt;p&gt;ArrayList(30) or ArrayList(16) are approx the same speed as LinkedList (get and iterator are always approx the same speed)&lt;br/&gt;
 at low numbers and get better and better VERY quickly as the number of tokens goes up.&lt;/p&gt;

&lt;p&gt;I&apos;d recommend ArrayList(16) as the best choice for this class. It is no worse than LinkedList on very small documents, and much better than LinkedList on small to large documents.&lt;/p&gt;

&lt;p&gt;A friend was recently telling me that ArrayList defaulted to 16, but it does not &amp;#8211; it defaults to 10. He must have been confused and known that it &lt;b&gt;should&lt;/b&gt; default to 16. 16 is a much better default number than 10 due to the exponential growth when doubling the array on resize. It may take a bit more memory, but it gets a LOT more speed.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12507334" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 15:12:23 +0100"  >&lt;p&gt;Well this is embarrassing. I messed up the implementation of the iterator approach. Egg on my face moment. At least now things make more sense. LinkedList using an iterator is as fast as ArrayList(16). It does not appear to be any faster, but it is more memory efficient. Michael was absolutely right and the mistake is the direct access over the iterator.&lt;/p&gt;

&lt;p&gt;Sorry about the major misdirection on this...youthful exuberance always gets the best of me...&amp;lt;g&amp;gt;&lt;/p&gt;

&lt;p&gt;I suggest the change is just to change from get() to Iterator usage.&lt;/p&gt;</comment>
                    <comment id="12507408" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 15:49:37 +0100"  >&lt;p&gt;I have the reset method check if the cache is null before creating a new Iterator because it would not throw an exception before if you called reset before calling next. I don&apos;t know how you feel about this.&lt;/p&gt;</comment>
                    <comment id="12507560" author="michaelbusch" created="Sat, 23 Jun 2007 05:17:31 +0100"  >&lt;p&gt;Mark,&lt;/p&gt;

&lt;p&gt;the new patch looks good to me! I&apos;m going to commit this soon.&lt;/p&gt;

&lt;p&gt;And you certainly don&apos;t have to apologize - thanks to your efforts &lt;br/&gt;
I feel that I understand these data structures better now...&lt;/p&gt;

&lt;p&gt;Thank you very much for investigating this so thoroughly!&lt;/p&gt;
</comment>
                    <comment id="12507617" author="michaelbusch" created="Sat, 23 Jun 2007 16:57:21 +0100"  >&lt;p&gt;Committed. Thanks, Mark.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12360324" name="CachingTokenFilter.patch" size="676" author="markrmiller@gmail.com" created="Thu, 21 Jun 2007 22:23:14 +0100" />
                    <attachment id="12360368" name="CachingTokenFilterRev2.patch" size="1272" author="markrmiller@gmail.com" created="Fri, 22 Jun 2007 15:49:36 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 21 Jun 2007 21:58:29 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12805</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26792</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>