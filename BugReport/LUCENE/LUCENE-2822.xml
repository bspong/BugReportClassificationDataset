<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:26:21 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2822/LUCENE-2822.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2822] TimeLimitingCollector starts thread in static {} with no way to stop them</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2822</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;See the comment in LuceneTestCase.&lt;/p&gt;

&lt;p&gt;If you even do Class.forName(&quot;TimeLimitingCollector&quot;) it starts up a thread in a static method, and there isn&apos;t a way to kill it.&lt;/p&gt;

&lt;p&gt;This is broken.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12493610">LUCENE-2822</key>
            <summary>TimeLimitingCollector starts thread in static {} with no way to stop them</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="simonw">Simon Willnauer</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Sat, 18 Dec 2010 21:23:44 +0000</created>
                <updated>Sun, 27 Nov 2011 12:29:33 +0000</updated>
                    <resolved>Sat, 12 Nov 2011 18:02:14 +0000</resolved>
                                            <fixVersion>3.5</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12988085" author="shaie" created="Fri, 28 Jan 2011 13:48:41 +0000"  >&lt;p&gt;Same issue. &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2237&quot; title=&quot;allow TimeLimitedCollector timer thread to be shutdown&quot;&gt;&lt;del&gt;LUCENE-2237&lt;/del&gt;&lt;/a&gt; includes a patch we can apply to allow shutting down the thread.&lt;/p&gt;</comment>
                    <comment id="12988089" author="shaie" created="Fri, 28 Jan 2011 14:11:45 +0000"  >&lt;p&gt;For reference, TimeLimitedCollector was added in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-997&quot; title=&quot;Add search timeout support to Lucene&quot;&gt;&lt;del&gt;LUCENE-997&lt;/del&gt;&lt;/a&gt;, where TimerThread&apos;s functionality is discussed.&lt;/p&gt;

&lt;p&gt;When we resolve this one, I think &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-1735&quot; title=&quot;shut down TimeLimitedCollection timer thread on application unload&quot;&gt;&lt;del&gt;SOLR-1735&lt;/del&gt;&lt;/a&gt; can be resolved as well.&lt;/p&gt;

&lt;p&gt;From &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-997&quot; title=&quot;Add search timeout support to Lucene&quot;&gt;&lt;del&gt;LUCENE-997&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;TimerThread provides a pseudo-clock service to all searching threads, so that they can count elapsed time with less overhead than repeatedly calling System.currentTimeMillis. A single thread should be created to be used for all searches.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The opinions about the effectiveness of TimerThread went both ways. For example, in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1720&quot; title=&quot;TimeLimitedIndexReader and associated utility class&quot;&gt;LUCENE-1720&lt;/a&gt;, the timeout mechanism works differently, and I wonder if we can apply the same logic here, or something very similar.&lt;/p&gt;

&lt;p&gt;Instead of having a static TimerThread, we can have start()/finish() API on TimeLimitingCollector(). start() will start a Thread that will sleep in nanosecs granularity until timeout exceeds. When it exceeds, it raises a flag. In collect() (and in setNextReader/Scorer too, to increase accuracy) all we do is check the flag and if it&apos;s on, we fail, just like collect() is impled today. App can call finish() that will signal the thread to stop.&lt;/p&gt;

&lt;p&gt;I think it&apos;s simple and shouldn&apos;t reduce accuracy of current impl (maybe only improve it). Assuming apps don&apos;t set timeout to 20 msec, Thread.sleep w/ nanosec granularity should be very accurate. Also, today timeout is counted from the moment you create TLC, but the app may do few more things before IndexSearcher.search() is actually called. start/finish will allow the app to time the search() method (or whatever it wants).&lt;/p&gt;

&lt;p&gt;Also, TimerThread was intended to serve all search requests, hence why it is static, but TLC itself cannot be shared across searches at all ...&lt;/p&gt;

&lt;p&gt;This will solve this issue, as well as simplify TLC IMO.&lt;/p&gt;</comment>
                    <comment id="13001879" author="hossman" created="Thu, 3 Mar 2011 06:03:21 +0000"  >&lt;p&gt;linking related issues&lt;/p&gt;</comment>
                    <comment id="13001883" author="hossman" created="Thu, 3 Mar 2011 06:12:19 +0000"  >
&lt;p&gt;Having read through all of the comments in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-997&quot; title=&quot;Add search timeout support to Lucene&quot;&gt;&lt;del&gt;LUCENE-997&lt;/del&gt;&lt;/a&gt; I fail to see why any Threads are needed in TimeLimitedCollector at all &amp;#8211; repeatedly folks mention that the use of a Timer thread is purely because System.currentTimeMillis isn&apos;t reliable enough and/or not efficient enough, but if we could use Java 1.5, System.nanoTime would be exactly what we need.&lt;/p&gt;

&lt;p&gt;It&apos;s 2011. &lt;br/&gt;
We can use Java 1.5 now in core Lucene. &lt;br/&gt;
so why don&apos;t we just rip out the TimerThread and use System.nanoTime() ?&lt;/p&gt;</comment>
                    <comment id="13001889" author="thetaphi" created="Thu, 3 Mar 2011 06:34:41 +0000"  >&lt;blockquote&gt;
&lt;p&gt;It&apos;s 2011. &lt;br/&gt;
We can use Java 1.5 now in core Lucene. &lt;br/&gt;
so why don&apos;t we just rip out the TimerThread and use System.nanoTime() ?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One of our large customers used System.currentTimeMillies() in their own TLC collector implementation, which led to a immense slowdown as then on every hit you get a quite expensive system call to the kernel. This would not be more efficient with nanoTime, as its still a system call (at least on lot&apos;s of JVMs like on Windows).&lt;/p&gt;

&lt;p&gt;So the thread is much more effective (its only reading a volatile field), so we need some shutdown. Another idea is to change this collector to not call nanoTime or currentTimeMillies on every hit (as hit collection should be fast), to maybe do this only every 1000 hit. The granularity could be a ctor param. This saves the thread and its still controlable how exact the measurement should be. A default of 1000 or maybe 10000 should be fine. Of course on the first collect hit (modulo 0) it should already check the timeout (because lots of queries do most work before the collection of hits).&lt;/p&gt;</comment>
                    <comment id="13001896" author="shaie" created="Thu, 3 Mar 2011 07:24:06 +0000"  >&lt;p&gt;I don&apos;t think we should check for time every N hits &amp;#8211; finding the next hit can take some time, and currently TimeLimitingCollector is not accurate b/c of that. I.e., it guarantees that when the time threshold has elapsed, it will stop the query processing, but it doesn&apos;t guarantee how accurate it is.&lt;/p&gt;

&lt;p&gt;The TimerThread was indeed included because a system call on every hit was too expensive. I think that my proposal above, introducing start/finish API on TLC will solve the thread kept alive issue, won&apos;t affect performance, and keep TLC&apos;s accuracy as it is today (not perfect, but better than &apos;check every N hits&apos;).&lt;/p&gt;</comment>
                    <comment id="13001967" author="mikemccand" created="Thu, 3 Mar 2011 11:58:28 +0000"  >&lt;p&gt;I think we should stick with our private timer thread (and we should definitely make it stop-able).&lt;/p&gt;

&lt;p&gt;I&apos;ve seen too many problems associated with relying on the system&apos;s time for &quot;important&quot; things like timing out queries, eg when daylight savings time strikes, or the clock is being &quot;aggressively corrected&quot;, and suddenly a bunch of queries are truncated.  In theory System.nanoTime should be immune to this (it&apos;s the system&apos;s timer and not any notion of &quot;wall clock time&quot;), but in practice, I don&apos;t think we should risk it.&lt;/p&gt;</comment>
                    <comment id="13002002" author="rcmuir" created="Thu, 3 Mar 2011 14:31:41 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think we should stick with our private timer thread (and we should definitely make it stop-able).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And no private thread should start in the static initializer... its fine for all instances to share a single private timer thread but this should be lazy-loaded.&lt;/p&gt;</comment>
                    <comment id="13002071" author="thetaphi" created="Thu, 3 Mar 2011 17:01:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think we should stick with our private timer thread (and we should definitely make it stop-able).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is still the best variant, as both System.nanoTime() and currentTimeMillies use system calls that are really expensive. nanoTime() has no wallclock problems, thats true, but is still a no-go for every collected hit!&lt;/p&gt;</comment>
                    <comment id="13002115" author="markh" created="Thu, 3 Mar 2011 18:07:58 +0000"  >&lt;p&gt;FYI - I visited a site today using Lucene 1720 live on a large index (&amp;gt;2 billion docs, sharded with 5 minute update intervals). They haven&apos;t noticed any significant degrading of search performance as a result of using this approach.&lt;/p&gt;</comment>
                    <comment id="13002129" author="thetaphi" created="Thu, 3 Mar 2011 18:30:30 +0000"  >&lt;p&gt;Mark: But &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1720&quot; title=&quot;TimeLimitedIndexReader and associated utility class&quot;&gt;LUCENE-1720&lt;/a&gt; does not use a System.nanoTime()/System.currentTimeMillis(), so what is your comment about?&lt;/p&gt;</comment>
                    <comment id="13002141" author="markh" created="Thu, 3 Mar 2011 19:04:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;does not use a System.nanoTime()/System.currentTimeMillis(), so what is your comment about?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There&apos;s already a solution that was designed to avoid any overhead related to making either of these calls.&lt;/p&gt;</comment>
                    <comment id="13002260" author="rcmuir" created="Thu, 3 Mar 2011 21:47:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think this is still the best variant, as both System.nanoTime() and currentTimeMillies use system calls that are really expensive. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry its too funny, playing with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2948&quot; title=&quot;Make var gap terms index a partial prefix trie&quot;&gt;&lt;del&gt;LUCENE-2948&lt;/del&gt;&lt;/a&gt; I saw a big slowdown on windows that mike didn&apos;t see on linux... finally tracked it down to an uncommented nanoTime &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13043535" author="rcmuir" created="Fri, 3 Jun 2011 17:40:38 +0100"  >&lt;p&gt;bulk move 3.2 -&amp;gt; 3.3&lt;/p&gt;</comment>
                    <comment id="13135749" author="tkrah" created="Wed, 26 Oct 2011 07:35:11 +0100"  >&lt;p&gt;Some workaround - until this one is resolved - to stop the thread (e.g. in a container shutdown callback) may be this one using reflection:&lt;/p&gt;

&lt;p&gt;Thread t = (Thread) FieldUtils.readDeclaredStaticField(TimeLimitingCollector.class, &quot;TIMER_THREAD&quot;, true);&lt;br/&gt;
      if (t != null &amp;amp;&amp;amp; t.isAlive()) &lt;/p&gt;
{
        t.interrupt();
        t.join(1000);
      }

&lt;p&gt;Little bit ugly but theres no other way yet.&lt;/p&gt;</comment>
                    <comment id="13147956" author="simonw" created="Thu, 10 Nov 2011 19:39:19 +0000"  >&lt;p&gt;catching up here... I wonder if we can make this TLC simply use a o.a.l.utils.Counter so people can implement this on to of TLC. there could be a ThreadedCounter in TLC people can pull and use their own static variable?&lt;/p&gt;</comment>
                    <comment id="13148137" author="simonw" created="Fri, 11 Nov 2011 00:10:54 +0000"  >&lt;p&gt;here is a first version of what I have in mind. I&apos;d like completely divorce the thread from the collector eventually and let the application create the thread. Solr should take care of this stuff itself. For now I used a little workaround for this.  &lt;/p&gt;</comment>
                    <comment id="13148227" author="simonw" created="Fri, 11 Nov 2011 02:54:23 +0000"  >&lt;p&gt;next iteration &lt;/p&gt;</comment>
                    <comment id="13148651" author="simonw" created="Fri, 11 Nov 2011 18:42:37 +0000"  >&lt;p&gt;I added a changes entry and opened up setting a baseline for the collector manually. Now by default we set the baseline once the first reader is set instead of during construction time. I think we are close here?!&lt;/p&gt;</comment>
                    <comment id="13148680" author="simonw" created="Fri, 11 Nov 2011 19:30:52 +0000"  >&lt;p&gt;If nobody objects I am going to commit this later today and backport to 3.x - this will break bw compat for time limiting collector but I think we should do that in this particular case&lt;/p&gt;</comment>
                    <comment id="13148813" author="simonw" created="Fri, 11 Nov 2011 23:03:23 +0000"  >&lt;p&gt;update patch to trunk&lt;/p&gt;</comment>
                    <comment id="13149117" author="simonw" created="Sat, 12 Nov 2011 18:02:14 +0000"  >&lt;p&gt;committed to trunk &amp;amp; backported to 3.x&lt;/p&gt;</comment>
                    <comment id="13157795" author="thetaphi" created="Sun, 27 Nov 2011 12:29:33 +0000"  >&lt;p&gt;Bulk close after release of 3.5&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310000">
                <name>Duplicate</name>
                                <outwardlinks description="duplicates">
                            <issuelink>
            <issuekey id="12446742">LUCENE-2237</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12378204">LUCENE-997</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12446745">SOLR-1735</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12503437" name="LUCENE-2822.patch" size="21547" author="simonw" created="Fri, 11 Nov 2011 23:03:23 +0000" />
                    <attachment id="12503399" name="LUCENE-2822.patch" size="26850" author="simonw" created="Fri, 11 Nov 2011 18:42:37 +0000" />
                    <attachment id="12503332" name="LUCENE-2822.patch" size="19170" author="simonw" created="Fri, 11 Nov 2011 02:54:23 +0000" />
                    <attachment id="12503311" name="LUCENE-2822.patch" size="14925" author="simonw" created="Fri, 11 Nov 2011 00:10:54 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 28 Jan 2011 13:48:41 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2962</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24870</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>