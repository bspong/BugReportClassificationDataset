<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:04:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1478/LUCENE-1478.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1478] Missing possibility to supply custom FieldParser when sorting search results</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1478</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;When implementing the new TrieRangeQuery for contrib (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1470&quot; title=&quot;Add TrieRangeFilter to contrib&quot;&gt;&lt;del&gt;LUCENE-1470&lt;/del&gt;&lt;/a&gt;), I was confronted by the problem that the special trie-encoded values (which are longs in a special encoding) cannot be sorted by Searcher.search() and SortField. The problem is: If you use SortField.LONG, you get NumberFormatExceptions. The trie encoded values may be sorted using SortField.String (as the encoding is in such a way, that they are sortable as Strings), but this is very memory ineffective.&lt;/p&gt;

&lt;p&gt;ExtendedFieldCache gives the possibility to specify a custom LongParser when retrieving the cached values. But you cannot use this during searching, because there is no possibility to supply this custom LongParser to the SortField.&lt;/p&gt;

&lt;p&gt;I propose a change in the sort classes:&lt;br/&gt;
Include a pointer to the parser instance to be used in SortField (if not given use the default). My idea is to create a SortField using a new constructor&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;SortField(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; type, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; parser, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; reverse)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The parser is &quot;object&quot; because all current parsers have no super-interface. The ideal solution would be to have:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;SortField(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; type, FieldCache.Parser parser, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; reverse)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and FieldCache.Parser is a super-interface (just empty, more like a marker-interface) of all other parsers (like LongParser...). The sort implementation then must be changed to respect the given parser (if not NULL), else use the default FieldCache.getXXXX without parser.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12409977">LUCENE-1478</key>
            <summary>Missing possibility to supply custom FieldParser when sorting search results</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="thetaphi">Uwe Schindler</reporter>
                        <labels>
                    </labels>
                <created>Thu, 4 Dec 2008 16:49:17 +0000</created>
                <updated>Fri, 25 Sep 2009 17:23:14 +0100</updated>
                    <resolved>Mon, 8 Dec 2008 21:08:43 +0000</resolved>
                            <version>2.4</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12653490" author="thetaphi" created="Thu, 4 Dec 2008 21:25:12 +0000"  >&lt;p&gt;Attached is a patch that implements the first variant (without super interface for all FieldParsers). All current tests pass. A special test case for a custum field parser was not implemented.&lt;/p&gt;

&lt;p&gt;For testing, I modified one of my contrib TrieRangeQuery test cases locally to sort using a custom LongParser that decoded the encoded longs in the cache &lt;span class=&quot;error&quot;&gt;&amp;#91;parseLong(value) returns TrieUtils.trieCodedToLong(value)&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;A good test case would be to store some dates in ISO format in a field and then sort it as longs after parsing using SimpleDateFormat. This would be another typical use case (sorting by date, but not using SortField.STRING to minimize memory usage).&lt;/p&gt;

&lt;p&gt;If you like my patch, we could also discuss about using a super-interface for all Parsers. The modifications are rather simple (only the SortField constructor would be affected and some casts, and of course: the superinterface in all declarations inside FieldCache, ExtendedFieldCache)&lt;/p&gt;</comment>
                    <comment id="12653741" author="mikemccand" created="Fri, 5 Dec 2008 10:55:23 +0000"  >&lt;p&gt;Patch looks good, thanks Uwe!  Back compat looks preserved; while some&lt;br/&gt;
APIs (FieldSortedHitQueue.getCachedComparator) were changed, they are&lt;br/&gt;
package private.&lt;/p&gt;

&lt;p&gt;Back-compat tests (&quot;ant test-tag&quot;) pass as well.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For testing, I modified one of my contrib TrieRangeQuery test cases locally to sort using a custom LongParser that decoded the encoded longs in the cache &lt;span class=&quot;error&quot;&gt;&amp;#91;parseLong(value) returns TrieUtils.trieCodedToLong(value)&amp;#93;&lt;/span&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It looks like this didn&apos;t make it into the patch &amp;#8211; could you add it?&lt;/p&gt;

&lt;p&gt;Actually, adding a core test case would also be good.  It could be&lt;br/&gt;
something silly, eg that parses ints but negates them, and then assert&lt;br/&gt;
that this yields the same result as the default IntParser with&lt;br/&gt;
reverse=true (assuming no ties).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you like my patch, we could also discuss about using a super-interface for all Parsers. The modifications are rather simple (only the SortField constructor would be affected and some casts, and of course: the superinterface in all declarations inside FieldCache, ExtendedFieldCache)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, I would like to at least get some minimal static typing into&lt;br/&gt;
the API (Object is not ideal) even if it&apos;s simply a &quot;marker&quot; interface&lt;br/&gt;
If you&apos;re sure this can be done, such that all changes to&lt;br/&gt;
FieldCache/ExtendedFieldCache remain back compatibitle, then let&apos;s do&lt;br/&gt;
it?  And I think I do now agree: this can be done w/o breaking back&lt;br/&gt;
compat.  The only affected public methods should be your new SortField&lt;br/&gt;
methods, which is fine (no public methods take &quot;Object parser&quot; as far&lt;br/&gt;
as I can tell).&lt;/p&gt;</comment>
                    <comment id="12654056" author="thetaphi" created="Sat, 6 Dec 2008 12:08:52 +0000"  >&lt;p&gt;I found a hidden bug in FieldSortedHitQueue that materialized when writing a TestCase for a SortField.BYTE sorting with custom parser (it took me a long time to find out whats happening). The problem is, that the comparator for byte fields returned SortField.INT in sortType() instead of SortField.BYTE. The effect of this was, that my new code crahsed when generating the new SortField in the constructor because of the incorrect Parser/SortField type. The other problem was, that on later calling the cache again, it would return another hit, because the type was different. The problem is, that this does not affect correctness of the previous implementation, but may coud lead to errors, like with my new impl.&lt;/p&gt;

&lt;p&gt;I fix this bug (its just one line) in my next patch (I will supply it shortly). Is it OK, or should I open a separate bug report?&lt;/p&gt;</comment>
                    <comment id="12654061" author="thetaphi" created="Sat, 6 Dec 2008 12:59:06 +0000"  >&lt;p&gt;Here is the patch using the superinterface for all field parsers. The patch also provides a test case in &quot;TestSort&quot; that uses a custom parser, that maps a simple char value from &apos;A&apos; to &apos;J&apos; to a byte, short, int, long, float, double with some crazy algorithm &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; to test sorting.&lt;/p&gt;

&lt;p&gt;Also fixed is the bug with the sortType() in comparator as mentioned before, without this, the test case for bytes would not pass.&lt;/p&gt;

&lt;p&gt;Additionally the new SortField constructor checks the sort type and corresponding parser for consistency and throws IllegalArgumentException, if not correct (e.g. using a LongParser with SortField.BYTE). During inventing this patch I had another idea to fix the issue with not to have a new super-interface: SortField could have separate constructors for each parser type without type parameter (as type is forced by parser instance &amp;#8211; we could also remove the type parameter in the current patch, as the type maybe set by  instanceof operator). Changing this would require some more work in the FieldSortedHitQueue, as copying the SortField would require more work (but could be fixed better as is is currently: a new SortField instance in the constructor is only needed, if SortField.AUTO or CUSTOM was used, in all other cases, the SortField instance can just be directly used).&lt;/p&gt;

&lt;p&gt;Just give some comments!&lt;/p&gt;</comment>
                    <comment id="12654062" author="thetaphi" created="Sat, 6 Dec 2008 13:03:15 +0000"  >&lt;p&gt;I forget to mention, this patch also extends contrib&apos;s TrieUtils and test cases to support a static trie-tolong/double-parser and a SortField factory to handle trie-encoded fields very simple using the long fieldcache (for sorting, there need to be no difference between long/double, it will work for all 3 trie encodings and long is the simpliest to handle an compare) - for which this patch was mainly invented. The double parser instance is only supplied for other usages of FieldCache from TrieUtils.&lt;/p&gt;</comment>
                    <comment id="12654068" author="mikemccand" created="Sat, 6 Dec 2008 13:47:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;The problem is, that the comparator for byte fields returned SortField.INT in sortType() instead of SortField.BYTE.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa, nice catch!  I think it&apos;s fine to include the fix here (it was not manifesting as a bug w/o your changes).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The patch also provides a test case in &quot;TestSort&quot; that uses a custom parser, that maps a simple char value from &apos;A&apos; to &apos;J&apos; to a byte, short, int, long, float, double with some crazy algorithm  to test sorting. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Awesome, I like the new test!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Additionally the new SortField constructor checks the sort type and corresponding parser for consistency and throws IllegalArgumentException, if not correct&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this stronger typing.  Could you change the message thrown exception to detail the type that was given and what parser was provided (better transparency)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;SortField could have separate constructors for each parser type without type parameter&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is a good idea, I think.  The two args are redundant &amp;amp; therefore a source of confusion/error.  It is annoying how we keep having to &quot;multiply by N&quot; so many places in Lucene that want to switch on the different builtin types (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt; has this too).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Changing this would require some more work in the FieldSortedHitQueue, as copying the SortField would require more work&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can we just SortField.clone() instead of &quot;new SortField(lots-of-tricky-args)&quot; in FieldSortedHitQueue?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;this patch also extends contrib&apos;s TrieUtils and test cases to support a static trie-tolong/double-parser and a SortField factory to handle trie-encoded fields very simple using the long fieldcache&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Great!&lt;/p&gt;</comment>
                    <comment id="12654201" author="thetaphi" created="Sun, 7 Dec 2008 14:51:57 +0000"  >&lt;p&gt;New patch that integrates Mike&apos;s comments. This version still uses a super-interface. If we want to remove it, we can create 6*2 new constructors (for each parser with and without reverse) and use Object for the internal member variable holding the parser. In FieldSortedHitQueue, the parser is stored in the CacheEntry&apos;s custom member which is also Object..., so the supertype is only used in SortField.&lt;/p&gt;

&lt;p&gt;12 new constructors are (in my eyes) very bad and from the JavaDoc side very heavy. The only advantage of them is:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;removing the super-interface&lt;/li&gt;
	&lt;li&gt;the if-queue of instanceof tests can be removed because of stronger typing&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12654436" author="thetaphi" created="Mon, 8 Dec 2008 15:49:39 +0000"  >&lt;p&gt;As &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1481&quot; title=&quot;Sort and SortField does not have equals() and hashCode()&quot;&gt;&lt;del&gt;LUCENE-1481&lt;/del&gt;&lt;/a&gt; is committed, here the updated patch with SortField.hashCode() and equals()&lt;/p&gt;</comment>
                    <comment id="12654498" author="mikemccand" created="Mon, 8 Dec 2008 18:21:38 +0000"  >&lt;p&gt;OK I made a few small changes to the patch: added CHANGES entry, touched up javadocs, and added null check for field in the new SortField ctors.  I think it&apos;s ready to commit!&lt;/p&gt;

&lt;p&gt;Uwe can you look over my changes?  Thanks.&lt;/p&gt;</comment>
                    <comment id="12654537" author="thetaphi" created="Mon, 8 Dec 2008 19:33:40 +0000"  >&lt;p&gt;Hi Mike,&lt;/p&gt;

&lt;p&gt;patch looks good, checked each change of you with TortoiseMerge. All tests pass including Trie ones.&lt;/p&gt;

&lt;p&gt;The only comments: You added this java docs to hashCode() and equals() in the patch of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1481&quot; title=&quot;Sort and SortField does not have equals() and hashCode()&quot;&gt;&lt;del&gt;LUCENE-1481&lt;/del&gt;&lt;/a&gt;. Maybe you should add the parser here, too.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  /** Returns a hash code value &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; object.  If a
   *  {@link SortComparatorSource} was provided, it must
   *  properly implement hashCode. */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;But on the other hand side: If the parser and/or comparator are static singletons (like it is done by the TrieUtils factories) they are not needed to implement equals and hashcode. The default Object equals/hashcode is enough for singletons. And I think most parsers and comparators are singletons. A short not should be enough.&lt;/p&gt;

&lt;p&gt;The additional null check is OK but in my opinion not needed, because field!=null when not one of the special RELEVANCE/DOCORDER sorts. For consistency we may add the check to the other ctors, too.&lt;/p&gt;</comment>
                    <comment id="12654556" author="mikemccand" created="Mon, 8 Dec 2008 20:21:29 +0000"  >&lt;p&gt;New patch attached:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Maybe you should add the parser here, too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK done.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The default Object equals/hashcode is enough for singletons.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I updated javadoc to add &quot;unless a singleton is always used&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The additional null check is OK but in my opinion not needed, because field!=null when not one of the special RELEVANCE/DOCORDER sorts. For consistency we may add the check to the other ctors, too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I added that because the javadoc had previously said field could&lt;br/&gt;
be null for DOC/SCORE sort type.  OK I added that check for all ctors&lt;br/&gt;
(added initFieldType private utility method).&lt;/p&gt;</comment>
                    <comment id="12654569" author="thetaphi" created="Mon, 8 Dec 2008 21:00:59 +0000"  >&lt;p&gt;Hi Mike,&lt;br/&gt;
all is ok. The extra check is better than before! I think its ready for commit.&lt;br/&gt;
Thanks for the discussions!&lt;/p&gt;</comment>
                    <comment id="12654573" author="mikemccand" created="Mon, 8 Dec 2008 21:08:43 +0000"  >&lt;p&gt;Committed revision 724484.&lt;/p&gt;

&lt;p&gt;Thanks Uwe!&lt;/p&gt;</comment>
                    <comment id="12654625" author="thetaphi" created="Mon, 8 Dec 2008 22:54:30 +0000"  >&lt;p&gt;Hi Mike,&lt;br/&gt;
sorry, after looking a second time into the new SortField ctors, I chaged two cosmetic things:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The ctor for parser assigns this.type=type and later calls the init method with the member variable type. The init method assigns so the meber to the member agian. Cleaner is just call the initFieldType() method in the correct instanceof clause hit.&lt;/li&gt;
	&lt;li&gt;Moved the initFieldType() behind all ctors.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But this is only cosmetic &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12654637" author="mikemccand" created="Mon, 8 Dec 2008 23:27:53 +0000"  >&lt;p&gt;No problem &amp;#8211; Committed revision 724552.  Thanks!&lt;/p&gt;</comment>
                    <comment id="12655002" author="thetaphi" created="Tue, 9 Dec 2008 22:52:33 +0000"  >&lt;p&gt;Just a note:&lt;br/&gt;
For the FieldCache it is also important, that the parser is a singleton or implements hashCode() and equals(). If not, each call to sort with another SortField using a different parser instance (but from the same class) would create a new FieldCache. This is why I said, that SortComparators and Parsers should generally be made static final members (and so singletons) like I have done it in TrieUtils. With that you can be sure, that all SortFields hit the same cache entry when looking up using FieldCacheImpl.Entry. The implementation of hashCode and equals for parsers is the other variant, but it does not make really sense (as long as parsers and comparators do not have an instance-specific state).&lt;/p&gt;</comment>
                    <comment id="12668747" author="yseeley@gmail.com" created="Fri, 30 Jan 2009 04:58:43 +0000"  >&lt;p&gt;I tracked down how this patch was causing Solr failures:&lt;/p&gt;

&lt;p&gt;ExternalFileField in Solr maps from a uniqueKey to a float value from a separate file.&lt;br/&gt;
There is a cache that is essentially keyed by (IndexReader,field) that gives back a float[].&lt;/p&gt;

&lt;p&gt;Any change in the index used to cause all values to be updated  (cache miss because the MultiReader was a different instance).  Now, since it&apos;s called segment-at-a-time, only new segments are reloaded from the file, leaving older segments with stale values.&lt;/p&gt;

&lt;p&gt;It&apos;s certainly in the very gray area... but perhaps Solr won&apos;t be the only one affected by this - maybe apps that implement security filters, etc?&lt;/p&gt;</comment>
                    <comment id="12668772" author="thetaphi" created="Fri, 30 Jan 2009 07:50:29 +0000"  >&lt;p&gt;I am not really sure, how this patch can can change this. Maybe you have more a problem with the new MultiReaderHitCollector patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt;) - your comment looks like this? The current patch does not change anything, as long as you use the old SortField constructors.&lt;/p&gt;

&lt;p&gt;Can you explain a little bit more, maybe a test?&lt;/p&gt;</comment>
                    <comment id="12668777" author="thetaphi" created="Fri, 30 Jan 2009 08:16:46 +0000"  >&lt;p&gt;After reading your comment several times and looking into ExternalFileField, the problem can maybe fixed using this issue:&lt;/p&gt;

&lt;p&gt;You problem may come from the fact, that you instantated this own FieldCache implementation, keyed it with the parent MultiReader and the new Sort implementation does not use it.&lt;/p&gt;

&lt;p&gt;Write a FloatParser that maps the the uniqueKey to a float value using the external file. If you want to use it with the new MultiReaderHitCollector sorting (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt;), create the SortField using the parser interface parameter from this issue. When the field caches for searching are now rebuild (even only for one of them in a Multi(Segment)Reader)), the new Lucene search API will re-read the changed segments and build several new FieldCaches (standard ones) using the suplied parser. There is no longer the need for a extra FieldCache implementation with this issue.&lt;/p&gt;

&lt;p&gt;Is this your problem? Maybe this is why you wrote the comment here.&lt;/p&gt;</comment>
                    <comment id="12668799" author="mikemccand" created="Fri, 30 Jan 2009 10:11:56 +0000"  >&lt;p&gt;Yonik, why was the failure so intermittent?&lt;/p&gt;

&lt;p&gt;So it sounds like Solr was relying on Lucene loading the entire&lt;br/&gt;
float[] for all docs in the MultiSegmentReader, when only some&lt;br/&gt;
segments were new?  (And so it was &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt; that caused the&lt;br/&gt;
failure).&lt;/p&gt;

&lt;p&gt;Lucene implicitly assumes that a FieldCache&apos;s arrays do not change for&lt;br/&gt;
a given segment; this is normally safe since the arrays are derived&lt;br/&gt;
from the postings in the field (which are write once).&lt;/p&gt;

&lt;p&gt;But it sounds like Solr changed that assumption, and the values in the&lt;br/&gt;
(Solr-subclass of) FieldCache&apos;s arrays are now derived from something&lt;br/&gt;
external, which is no longer write once.&lt;/p&gt;

&lt;p&gt;How do you plan to fix it with Solr?  It seems like, since you are&lt;br/&gt;
maintaining a private cache, you could forcefully evict entries from&lt;br/&gt;
the cache for all SegmentReaders whenever the external file has&lt;br/&gt;
changed (or a new MultiSegmentReader had been opened)?&lt;/p&gt;</comment>
                    <comment id="12668802" author="mikemccand" created="Fri, 30 Jan 2009 10:17:25 +0000"  >&lt;blockquote&gt;&lt;p&gt;Write a FloatParser that maps the the uniqueKey to a float value using the external file.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Uwe, would that result in a memory leak?  Ie, a single long-lived segment would accumulate multiple entries for each new XXXParser instance used during sorting?  (Unless there&apos;s logic to evict the &quot;stale&quot; entries).&lt;/p&gt;

&lt;p&gt;It seems like &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt;, which would expose / allow custom control over FieldCache&apos;s caching impl, would help here too.&lt;/p&gt;</comment>
                    <comment id="12668812" author="thetaphi" created="Fri, 30 Jan 2009 10:51:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;Uwe, would that result in a memory leak? Ie, a single long-lived segment would accumulate multiple entries for each new XXXParser instance used during sorting? (Unless there&apos;s logic to evict the &quot;stale&quot; entries).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As noted before on Dec 9, 08, the parser should be a singleton for all field caches or have hashCode()/equals(). You create a FloatParser and supply it to SortField. When then sorting against this field, the new sort implementation would create a FieldCache for each segment. When one segment is reloaded, the FieldCache gets unused and a new one for the replacement segment is created (this is the same like with the standard field parser). The FieldCache is using (IndexReader,SortField.type,Parser) as key.&lt;/p&gt;

&lt;p&gt;If the FieldCache is used for CachingFilters, there is also no problem: The new search algorithm executes each filter&apos;s getDocIDSet() for each single SegmentReader.&lt;/p&gt;

&lt;p&gt;So the only problem is, that with the new search implementation, you cannot rely anymore on the fact, that for a MultiReader only one FieldCache exists and every filter&apos;s getDocIdSet() is executed only one time. So injecting a custom FieldCache into the cache for the whole MultiReader before search (by getting it) is not possible anymore.&lt;/p&gt;

&lt;p&gt;I tested the new search impl with trie fields, sorting works perfect using TrieUtils.getSortField()/TrieUtils.LONG_PARSER, no leaks (because FieldParser is singleton). I had to only modify the test case (Revision: 737079), because with an unoptimized index, the statistics for retrieving the number of visited terms did not work anymore (because the Filter was called more than once per search).&lt;/p&gt;

&lt;p&gt;The problem with stale entries, if the external file changes is another problem, that also happend before the new sort impl.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It seems like &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-831&quot; title=&quot;Complete overhaul of FieldCache API/Implementation&quot;&gt;LUCENE-831&lt;/a&gt;, which would expose / allow custom control over FieldCache&apos;s caching impl, would help here too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes!&lt;/p&gt;</comment>
                    <comment id="12668815" author="thetaphi" created="Fri, 30 Jan 2009 11:02:43 +0000"  >&lt;p&gt;By the way: The Cache of FieldCache instances in FieldCacheImpl is a WeakHashMap, so unused FieldCache instances for no longer used readers/parsers are GC&apos;ed.&lt;/p&gt;</comment>
                    <comment id="12668818" author="mikemccand" created="Fri, 30 Jan 2009 11:20:32 +0000"  >
&lt;blockquote&gt;&lt;p&gt;the parser should be a singleton for all field caches or have hashCode()/equals().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I guess I don&apos;t understand your proposed workaround then &amp;#8211; I thought&lt;br/&gt;
you were explicitly proposing &lt;b&gt;not&lt;/b&gt; using a singleton, so that you&lt;br/&gt;
could force re-parsing of all values (even for old segments) when a&lt;br/&gt;
new external file was being used.&lt;/p&gt;

&lt;p&gt;(Also likely my lack of understanding of Solr&apos;s ExternalFileField is&lt;br/&gt;
adding to my confusion here &amp;#8211; I haven&apos;t yet looked at it.)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The Cache of FieldCache instances in FieldCacheImpl is a WeakHashMap, so unused FieldCache instances for no longer used readers/parsers are GC&apos;ed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The WeakHashMap is keyed by the IndexReader, and then there&apos;s a normal&lt;br/&gt;
HashMap (innerCache) keyed on field,Parser.  So it&apos;s only when the&lt;br/&gt;
IndexReader (SegmentReader) is no longer referenced elsewhere that the&lt;br/&gt;
innerCache, in entirety, can be GCd.  There&apos;s no reclaiming of stale&lt;br/&gt;
entries in the innerCache.&lt;/p&gt;</comment>
                    <comment id="12668822" author="thetaphi" created="Fri, 30 Jan 2009 11:33:03 +0000"  >&lt;p&gt;Ah, now I understand (by the way, I do not understand Solrs ExternalFileField in complete, too):&lt;/p&gt;

&lt;p&gt;With my workaround, I did not want to work around the problem of a changed external file. I propsed, not to implement a own FieldCache for the whole thing and just use the new SortField&apos;s parser to fill the standard FloatCache during searching/filtering. Just use the external (static) file and convert the the values from the index using the HashMap in ExternalFileField to the floats. This parser is a singleton for each ExternalFileField.&lt;/p&gt;

&lt;p&gt;But I think we should wait, until Yonik explains us the problem more detail.&lt;/p&gt;</comment>
                    <comment id="12668889" author="yseeley@gmail.com" created="Fri, 30 Jan 2009 14:57:24 +0000"  >&lt;p&gt;Apologies, I meant to post in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                                <inwardlinks description="is blocked by">
                            <issuelink>
            <issuekey id="12410135">LUCENE-1481</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12395599" name="LUCENE-1478-cleanup.patch" size="3020" author="thetaphi" created="Mon, 8 Dec 2008 22:54:30 +0000" />
                    <attachment id="12395332" name="LUCENE-1478-no-superinterface.patch" size="13787" author="thetaphi" created="Thu, 4 Dec 2008 21:25:12 +0000" />
                    <attachment id="12395589" name="LUCENE-1478.patch" size="37459" author="mikemccand" created="Mon, 8 Dec 2008 20:21:28 +0000" />
                    <attachment id="12395581" name="LUCENE-1478.patch" size="34523" author="mikemccand" created="Mon, 8 Dec 2008 18:21:38 +0000" />
                    <attachment id="12395564" name="LUCENE-1478.patch" size="32892" author="thetaphi" created="Mon, 8 Dec 2008 15:49:39 +0000" />
                    <attachment id="12395507" name="LUCENE-1478.patch" size="32243" author="thetaphi" created="Sun, 7 Dec 2008 14:51:57 +0000" />
                    <attachment id="12395484" name="LUCENE-1478.patch" size="32171" author="thetaphi" created="Sat, 6 Dec 2008 12:59:06 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>7.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 5 Dec 2008 10:55:23 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12273</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26249</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>