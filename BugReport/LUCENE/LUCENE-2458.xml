<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:57:23 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2458/LUCENE-2458.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2458] queryparser makes all CJK queries phrase queries regardless of analyzer</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2458</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The queryparser automatically makes &lt;b&gt;ALL&lt;/b&gt; CJK, Thai, Lao, Myanmar, Tibetan, ... queries into phrase queries, even though you didn&apos;t ask for one, and there isn&apos;t a way to turn this off.&lt;/p&gt;

&lt;p&gt;This completely breaks lucene for these languages, as it treats all queries like &apos;grep&apos;.&lt;/p&gt;

&lt;p&gt;Example: if you query for f:abcd with standardanalyzer, where a,b,c,d are chinese characters, you get a phrasequery of &quot;a b c d&quot;. if you use cjk analyzer, its no better, its a phrasequery of  &quot;ab bc cd&quot;, and if you use smartchinese analyzer, you get a phrasequery like &quot;ab cd&quot;. But the user didn&apos;t ask for one, and they cannot turn it off.&lt;/p&gt;

&lt;p&gt;The reason is that the code to form phrase queries is not internationally appropriate and assumes whitespace tokenization. If more than one token comes out of whitespace delimited text, its automatically a phrase query no matter what.&lt;/p&gt;

&lt;p&gt;The proposed patch fixes the core queryparser (with all backwards compat kept) to only form phrase queries when the double quote operator is used. &lt;/p&gt;

&lt;p&gt;Implementing subclasses can always extend the QP and auto-generate whatever kind of queries they want that might completely break search for languages they don&apos;t care about, but core general-purpose QPs should be language independent.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12464288">LUCENE-2458</key>
            <summary>queryparser makes all CJK queries phrase queries regardless of analyzer</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.png">Blocker</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="rcmuir">Robert Muir</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Tue, 11 May 2010 20:55:18 +0100</created>
                <updated>Wed, 4 May 2011 07:40:06 +0100</updated>
                    <resolved>Mon, 19 Jul 2010 20:25:33 +0100</resolved>
                                            <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/queryparser</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12866341" author="hossman" created="Tue, 11 May 2010 22:22:14 +0100"  >&lt;p&gt;Robter: do you have a specific suggestion for what QueryParser should do if a single &quot;chunk&quot; of input causes the Analyzer to produce multiple tokens that are not at the same position (ie: the current case where QueryParser produces a PhraseQuery even if there are no quotes)&lt;/p&gt;

&lt;p&gt;Ie: if the query parser is asked to parse... &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;fieldName:A-Field-Value&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;...and the Analyzer produces three tokens...&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A (at position 0)&lt;/li&gt;
	&lt;li&gt;Field (at position 1)&lt;/li&gt;
	&lt;li&gt;Value (at position 2)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;...what should the resulting Query object be?&lt;/p&gt;</comment>
                    <comment id="12866353" author="rcmuir" created="Tue, 11 May 2010 22:38:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;...what should the resulting Query object be?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;a Boolean Query formed with the default operator.&lt;/p&gt;</comment>
                    <comment id="12866363" author="hossman" created="Tue, 11 May 2010 22:54:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;a Boolean Query formed with the default operator.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That seems like equally bad default behavior &amp;#8211; lots of existing TokenFilters produce chains of tokens for situations where the user creating the query string clearly intended to be searching for a single &quot;word&quot; and has no idea that as an implementation detail multiple tokens were produced under the covers (ie: WordDelimiterFilter, Ngrams, etc...)&lt;/p&gt;

&lt;p&gt;I haven&apos;t thought this through very well, but perhaps this is an area where (the new) Token Attributes could be used to instruct QueryParser as to the intent behind a stream of multiple tokens?  A new Attribute could be used on each token to convey when that token should be combined with teh previous token, and in what way: as a phrase, as a conjunction or as a disjunction.  (this could still be orthogonal to the position, which would indicate slop/span type information like it does currently)&lt;/p&gt;

&lt;p&gt;Stock Analysys components that produce multiple tokens could be modified to add this attribute fairly easily (it should be a relatively static value for any component that currently &quot;splits&quot; tokens) and QueryParser could have an option controlling what to do if  it encounters a token w/o this attribute (perhaps even two options: one for quoted input chunks and one for unquoted input chunks).&lt;/p&gt;

&lt;p&gt;that way the default could still work in a back compatible way, but people using languages that don&apos;t use whitespace separation &lt;b&gt;and&lt;/b&gt; are using older (or custom) analyzers that don&apos;t know about this attribute could set a simple query parser property to force this behavior.&lt;/p&gt;

&lt;p&gt;would that make sense? (asks the man who only vaguely understands Token Attributes at this point)&lt;/p&gt;</comment>
                    <comment id="12866368" author="rcmuir" created="Tue, 11 May 2010 23:20:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;That seems like equally bad default behavior&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Do you have measurements to support this? Because they show its 10x better to use this operator for Chinese &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I haven&apos;t thought this through very well, but perhaps this is an area where (the new) Token Attributes&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree. Instead the queryparser should only form phrasequeries when you use double quotes, just like the documentation says.&lt;/p&gt;</comment>
                    <comment id="12866374" author="rcmuir" created="Tue, 11 May 2010 23:38:03 +0100"  >&lt;p&gt;by the way hoss man you said it best yourself:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;lots of existing TokenFilters produce chains of tokens for situations where the user creating the query string clearly intended to be searching for a single &quot;word&quot; and has no idea that as an implementation detail multiple tokens were produced under the covers (ie: WordDelimiterFilter, Ngrams, etc...)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;User clearly intended is wrong. WordDelimiterFilter will break tibetan text in a similar manner (it uses no spaces between words), yet no user &quot;clearly intended&quot; to form phrase queries.&lt;/p&gt;

&lt;p&gt;Users clearly intend to form phrase queries only when they use the phrase query operator, thats how the query parser is documented to work, and its a bug that it doesnt work that way.&lt;/p&gt;</comment>
                    <comment id="12866528" author="mikemccand" created="Wed, 12 May 2010 10:52:42 +0100"  >&lt;p&gt;This is sneaky behavior on QueryParser&apos;s part!  I didn&apos;t realize it did this.&lt;/p&gt;

&lt;p&gt;What are some real use-cases where this is &quot;good&quot;?  WordDelmiterFilter seems like a good example (eg, Wi-Fi -&amp;gt; Wi Fi).&lt;/p&gt;

&lt;p&gt;It sounds like it&apos;s a very bad default for non-whitespace languages.&lt;/p&gt;

&lt;p&gt;It seems like we should make it controllable, switch it under Version, and change the default going forward to not do this?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Token Attributes could be used to instruct QueryParser as to the intent behind a stream of multiple tokens?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This seems like a good idea (since we seem to have real-world cases where it&apos;s very useful and others where it&apos;s very bad)?  Could/should it be per-analyzer?  (ie, WDF would always do this but, say, ICUAnalyzer would never).  Or, per-token created?&lt;/p&gt;</comment>
                    <comment id="12866557" author="rcmuir" created="Wed, 12 May 2010 14:01:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;What are some real use-cases where this is &quot;good&quot;? WordDelmiterFilter seems like a good example (eg, Wi-Fi -&amp;gt; Wi Fi).&lt;br/&gt;
It sounds like it&apos;s a very bad default for non-whitespace languages.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Its a horrible bug! And to boot, i don&apos;t think it helps english much as a default either.&lt;br/&gt;
Here&apos;s a comparison on an english test collection (Telegraph collection with standardAnalyzer + porter):&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;measure&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;T&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;TD&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;TDN&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;% of queries affected&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;6%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;14%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;32%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;positionfilter improvement&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;+1.704%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;+0.213%&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;+0.805%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;So, turning it off certainly doesn&apos;t hurt (I won&apos;t try to argue that this small &quot;improvement&quot; by turning it off means anything).&lt;br/&gt;
For chinese, its a 10x improvement on TREC5/TREC6: obviously the bug is horrible there because its generating phrase queries all the time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This seems like a good idea (since we seem to have real-world cases where it&apos;s very useful and others where it&apos;s very bad)? Could/should it be per-analyzer? (ie, WDF would always do this but, say, ICUAnalyzer would never). Or, per-token created?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am strongly opposed to this. My tibetan example with WDF or whatever above is an easy example.&lt;br/&gt;
I haven&apos;t seen any measured real-world example where this helps, subjectively saying &quot;I like this bug&quot; isnt convincing me.&lt;/p&gt;

&lt;p&gt;We don&apos;t need to push &quot;what should be phrase query&quot; onto analysis, it doesn&apos;t know from unicode properties etc, what the user wanted.&lt;br/&gt;
We don&apos;t need to put hairy logic into things like StandardTokenizer, to determine if &quot;the user wanted a phrase query&quot; or not in certain contexts.&lt;/p&gt;

&lt;p&gt;Instead we should just do what the documentation says, and only issue phrase queries when the user asks for one!!!!!!&lt;/p&gt;</comment>
                    <comment id="12866595" author="creamyg" created="Wed, 12 May 2010 16:32:39 +0100"  >&lt;p&gt;I have mixed feelings about this for English.  It&apos;s a weakness of our engine&lt;br/&gt;
that we do not take position of terms within a query string into account.  At&lt;br/&gt;
times I&apos;ve tried to modify the scoring hierarchy to improve the situation, but&lt;br/&gt;
I gave up because it was too difficult.  This behavior of QueryParser is a&lt;br/&gt;
sneaky way of getting around that limitation by turning stuff which should&lt;br/&gt;
almost certainly be treated as phrase queries as such.  It&apos;s the one place &lt;br/&gt;
where we actually exploit position data within the query string.&lt;/p&gt;

&lt;p&gt;Mike&apos;s &quot;wi-fi&quot; example, though, wouldn&apos;t suffer that badly.  The terms &quot;wi&quot;&lt;br/&gt;
and &quot;fi&quot; are unlikely to occur much outside the context of &apos;wi-fi/wi fi/wifi&apos;.&lt;br/&gt;
And treating &quot;wi-fi&quot; as a phrase still won&apos;t conflate results with &quot;wifi&quot; as&lt;br/&gt;
it would ideally.  &lt;/p&gt;

&lt;p&gt;The example I would use doesn&apos;t typically apply to Lucene.  Lucene&apos;s&lt;br/&gt;
StandardAnalyzer tokenizes URLs as wholes, but KinoSearch&apos;s analogous analyzer&lt;br/&gt;
breaks them up into individual components.  As described in another recent&lt;br/&gt;
thread, this allows a search for &apos;example.com&apos; to match a document which&lt;br/&gt;
contains the URL &apos;http://www.example.com/index.html&apos;.  It would suck if all of&lt;br/&gt;
a sudden a search for &apos;example.com&apos; started matching every document that&lt;br/&gt;
contained &apos;com&apos;. &lt;/p&gt;

&lt;p&gt;You could, and theoretically should, address this problem with sophisticated&lt;br/&gt;
analysis.  But it does make it harder to write a good Analyzer.  You make it&lt;br/&gt;
more important to solve what Yonik calls the &apos;e space mail&apos; problem by making&lt;br/&gt;
it worse.&lt;/p&gt;</comment>
                    <comment id="12866603" author="creamyg" created="Wed, 12 May 2010 17:01:29 +0100"  >&lt;p&gt;&amp;gt; Because they show its 10x better to use this operator for Chinese&lt;/p&gt;

&lt;p&gt;Another way to achieve this 10x improvement is to change how QP performs its&lt;br/&gt;
first stage of tokenization, as you and I discussed at ApacheCon Oakland.&lt;/p&gt;

&lt;p&gt;Right now QP splits on whitespace.  If that behavior were customizable, e.g.&lt;br/&gt;
via a &quot;splitter&quot; Analyzer, then individual Han characters would get submitted&lt;br/&gt;
to getFieldQuery() &amp;#8211; and thus getFieldQuery() would no longer turn long&lt;br/&gt;
strings of Han characters into a PhraseQuery.  It seems wrong to continue to&lt;br/&gt;
push entire query strings from non-whitespace-delimited languages down into&lt;br/&gt;
getFieldQuery().&lt;/p&gt;</comment>
                    <comment id="12866648" author="rcmuir" created="Wed, 12 May 2010 18:39:09 +0100"  >&lt;p&gt;edit: s/control/contrib. I apologize for the typo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As described in another recent&lt;br/&gt;
thread, this allows a search for &apos;example.com&apos; to match a document which&lt;br/&gt;
contains the URL &apos;http://www.example.com/index.html&apos;. It would suck if all of&lt;br/&gt;
a sudden a search for &apos;example.com&apos; started matching every document that&lt;br/&gt;
contained &apos;com&apos;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You could solve this with better analysis, for example recognizing the full URL and decomposing it into its parts (forming n-grams of them).&lt;br/&gt;
This would be more performant than the current &quot;english hacking&quot; anyway.&lt;/p&gt;

&lt;p&gt;I&apos;m honestly having a tough time seeing where to proceed on this issue.&lt;/p&gt;

&lt;p&gt;Lucene&apos;s queryparsing is completely broken for several languages due to this bug, and such language-specific hacking (heuristically forming phrase queries based on things that people subjectively feel helps for english) really doesn&apos;t belong in core lucene, but instead elsewhere, perhaps in some special optional pass to the contrib query parser.&lt;/p&gt;

&lt;p&gt;The queryparser really should be language-independent and work well on average, this would fix it for several languages.&lt;/p&gt;

&lt;p&gt;However, given the &lt;b&gt;huge&lt;/b&gt; english bias I see here, i have a tough time seeing what concrete direction (e.g. code) i can work on to try to fix it. I feel such work would only be rejected since so many people seem opposed to simplifying the query parser and removing this language-specific hack.&lt;/p&gt;

&lt;p&gt;If someone brings up an issue with the query parser (for instance i brought up several language-specific problems at apachecon), then people are quick to say that this doesn&apos;t belong in the queryparser, but should be dealt with on a special case. Why isn&apos;t english treated this way too? I don&apos;t consider this bias towards english &quot;at all costs&quot; including preventing languages such as Chinese from working at all very fair, I think its a really ugly stance for Lucene to take.&lt;/p&gt;
</comment>
                    <comment id="12866665" author="iprovalo" created="Wed, 12 May 2010 19:01:04 +0100"  >&lt;p&gt;Robert has asked me to post our test results on the Chinese Collection. We used the following data collection from TREC:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://trec.nist.gov/data/qrels_noneng/index.html&quot; class=&quot;external-link&quot;&gt;http://trec.nist.gov/data/qrels_noneng/index.html&lt;/a&gt;&lt;br/&gt;
qrels.trec6.29-54.chinese.gz&lt;br/&gt;
qrels.1-28.chinese.gz&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://trec.nist.gov/data/topics_noneng&quot; class=&quot;external-link&quot;&gt;http://trec.nist.gov/data/topics_noneng&lt;/a&gt;&lt;br/&gt;
TREC-6 Chinese topics (.gz)&lt;br/&gt;
TREC-5 Chinese topics (.gz)&lt;/p&gt;

&lt;p&gt;Mandarin Data Collection&lt;br/&gt;
&lt;a href=&quot;http://www.ldc.upenn.edu/Catalog/CatalogEntry.jsp?catalogId=LDC2000T52&quot; class=&quot;external-link&quot;&gt;http://www.ldc.upenn.edu/Catalog/CatalogEntry.jsp?catalogId=LDC2000T52&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Analyzer Name Plain analyzers Added PositionFilter (only at query time)&lt;br/&gt;
ChineseAnalyzer 0.028 0.264&lt;br/&gt;
CJKAnalyzer 0.027 0.284&lt;br/&gt;
SmartChinese 0.027 0.265&lt;br/&gt;
IKAnalyzer 0.028 0.259&lt;/p&gt;

&lt;p&gt;(Note: IKAnalyzer has its own IKQueryParser which yields 0.084 for the average precision)&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Ivan Provalov&lt;/p&gt;</comment>
                    <comment id="12866693" author="creamyg" created="Wed, 12 May 2010 20:03:58 +0100"  >&lt;p&gt;&amp;gt; I&apos;m honestly having a tough time seeing where to proceed on this issue.&lt;/p&gt;

&lt;p&gt;Change the initial split on whitespace to be customizable.  Override the&lt;br/&gt;
splitting behavior for non-whitespace-delimited languages and feed&lt;br/&gt;
getFieldQuery() smaller chunks.&lt;/p&gt;

&lt;p&gt;That solves your problem without removing behavior most people believe to be&lt;br/&gt;
helpful.  Insisting on that orthogonal change is what is holding things up.&lt;/p&gt;</comment>
                    <comment id="12866695" author="rcmuir" created="Wed, 12 May 2010 20:09:39 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Change the initial split on whitespace to be customizable. Override the&lt;br/&gt;
splitting behavior for non-whitespace-delimited languages and feed&lt;br/&gt;
getFieldQuery() smaller chunks.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whitespace doesn&apos;t separate words in the majority of the world&apos;s languages, including english.&lt;/p&gt;

&lt;p&gt;The responsibility should be instead on english to do its language-specific processing, not on everyone else to dodge it.&lt;/p&gt;</comment>
                    <comment id="12866696" author="hossman" created="Wed, 12 May 2010 20:10:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;Instead the queryparser should only form phrasequeries when you use double quotes, just like the documentation says.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;i&apos;ll grant you that the documentation is wrong &amp;#8211; i view that as a bug in the documentation, not the code.  &lt;/p&gt;

&lt;p&gt;Saying that a PhraseQuery object should only ever be constructed if the user uses quotes is like saying that a BooleanQuery should only ever be constructed if the user specifies boolean operators &amp;#8211; there is no rule that the syntax must match the query structure, the same Query classes can serve multiple purposes.  The parser syntax should be what makes sense  for hte user, and the query structure constructed should be what makes sense for hte index, based on the syntax used by the user.&lt;/p&gt;

&lt;p&gt;If i have built an index consisting entirely of ngrams, the end user shouldn&apos;t have to know that &amp;#8211; they shouldn&apos;t have to put every individual word in quotes to force a PhraseQuery to be constructed out of the ngram tokenstream produced by an individual word.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why isn&apos;t english treated this way too? I don&apos;t consider this bias towards english &quot;at all costs&quot; including preventing languages such as Chinese from working at all very fair, I think its a really ugly stance for Lucene to take.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I personally don&apos;t view it as an &quot;english bias&quot; ... to be it is a &quot;backwards compatibility bias&quot;  &lt;/p&gt;

&lt;p&gt;I&apos;m totally happy to make things onfigurable, but if two diametrically opposed behaviors are both equally useful, and If there is a choice needs to be made between leaving the default configuration the way the current hardcoded behavior is, or make the default the exact opposite of what the current hardcoded behavior is, it is then i would prefer to leave the default alone &amp;#8211; especially since this beahior has been around for so long, and many Analyzers and TOkenFilters, have been written with this behavior specificly in mind (several examples of this are in the Lucene code base &amp;#8211; and if we have them in our own code, you can be sure they exist &quot;in the wild&quot; of client code that would break if this behavior changes by default)&lt;/p&gt;

&lt;p&gt;Once again: if this is a problem that can be solved &quot;per instance&quot; with token attributes, then by all means let&apos;s make &lt;b&gt;all&lt;/b&gt; of the TokenFIlters that come &quot;out of the box&quot; implement this appropriately (english and non-english alike) so that people who change the default settings on the queryparser get the &quot;correct&quot; behavior regardless of langauge.  but all other things being equal lets keep the behavior working the way it has to avoid suprises.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What are some real use-cases where this is &quot;good&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
	&lt;li&gt;WordDelimiterFilter (&quot;wi-fi&quot; is a pathalogicaly bad example for this issue because as robert pointed out &quot;wi&quot; and &quot;fi&quot; don&apos;t tend to exist independently in english, but people tend to get anoyed when &quot;race-horse&quot; matches all docs containing &quot;race&quot; or &quot;horse&quot;)&lt;/li&gt;
	&lt;li&gt;single word to multiword synonym expansion/transformation (particularly acronym expansion: GE =&amp;gt; General Electric)&lt;/li&gt;
	&lt;li&gt;Ngram indexing for fuzzy matching (if someone searches for the word billionaire they&apos;re going to be surprised to get documents containing &quot;lion&quot;)&lt;/li&gt;
&lt;/ul&gt;


</comment>
                    <comment id="12866698" author="rcmuir" created="Wed, 12 May 2010 20:13:06 +0100"  >&lt;blockquote&gt;&lt;p&gt;but all other things being equal lets keep the behavior working the way it has to avoid suprises.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This attitude makes me sick. The surprise is to the CJK users that get no results due to undocumented, english-specific hacks that people refuse to let go of.&lt;/p&gt;</comment>
                    <comment id="12866954" author="dmsmith" created="Thu, 13 May 2010 05:04:54 +0100"  >&lt;p&gt;As I see it there are two issues:&lt;br/&gt;
1) Backward compatibility. &lt;br/&gt;
2) Correctness according to the syntax definition of a query.&lt;/p&gt;

&lt;p&gt;Let me preface the following by saying I have not studied the query parser in Lucene. Over 20 years ago I got an MS in compiler writing. I&apos;ve been away from it for quite a while.&lt;/p&gt;

&lt;p&gt;So, IMHO as a former compiler writer:&lt;/p&gt;

&lt;p&gt;Maybe I&apos;m just not &quot;getting it&quot; but it should be trivial to define the grammar (w/ precedence for any ambiguity, if necessary) and implement it. The tokenizer for the parser should have the responsibility to break the input into sequences of meta and non-meta. This tokenizer should not be anything more than what the parser requires.&lt;/p&gt;

&lt;p&gt;The non-meta reasonably is subject to further tokenization/analysis. This further analysis should be entirely under the user&apos;s control. It should not be part of the parser.&lt;/p&gt;

&lt;p&gt;Regarding the issue, I think it would be best if a quotation was the sole criteria for the determination of what is a phrase, not some heuristical analysis of the token stream.&lt;/p&gt;</comment>
                    <comment id="12867093" author="mikemccand" created="Thu, 13 May 2010 10:38:05 +0100"  >&lt;p&gt;I&apos;d like a solution that lets us have our cake and eat it too...&lt;/p&gt;

&lt;p&gt;Ie, we clearly have to fix the disastrous out-of-the-box experience&lt;br/&gt;
that non-whitespace languages (CJK) now have with Lucene.  This is&lt;br/&gt;
clear.&lt;/p&gt;

&lt;p&gt;But, when an analyzer that splits English-like compound words (eg&lt;br/&gt;
e-mail -&amp;gt; e mail) is used, I think this should also continue to create&lt;br/&gt;
a PhraseQuery, out-of-the-box.&lt;/p&gt;

&lt;p&gt;Today when a user searches for &quot;e-mail&quot;, s/he will correctly see only&lt;br/&gt;
&quot;email/e-mail&quot; hit &amp;amp; highlighted in the search results.  If we break&lt;br/&gt;
this behaviour, ie no longer produce a PQ out-of-the-box, suddenly&lt;br/&gt;
hits with just &quot;mail&quot; will be returned, which is bad.&lt;/p&gt;

&lt;p&gt;So a single setter on QueryParser w/ a global default is not a good&lt;br/&gt;
enough solution &amp;#8211; it means either CJK or English-like compound words&lt;br/&gt;
will be bad.&lt;/p&gt;

&lt;p&gt;This is why I like the token attr based solution &amp;#8211; those analyzers&lt;br/&gt;
that are doing &quot;English-like&quot; de-compounding can mark the tokens as&lt;br/&gt;
such.  Then QueryParser can notice this attr and (if configured to do so, via&lt;br/&gt;
setter), create a PhraseQuery out of that sequence of tokens.&lt;/p&gt;

&lt;p&gt;This then pushes the decision of which series of Tokens are produced&lt;br/&gt;
via &quot;English-like&quot; de-compounding.  EG I think WordDelimiterFilter&lt;br/&gt;
should be default mark its tokens as such (the majority of users use&lt;br/&gt;
it this way).  When StandardAnalyzer splits a part-number-like token,&lt;br/&gt;
it should do so as well.&lt;/p&gt;

&lt;p&gt;This isn&apos;t a perfect solution: it&apos;s not easy, in general, for an&lt;br/&gt;
analyzer to &quot;know&quot; its splits are &quot;English-like&quot; de-compounding, but&lt;br/&gt;
this would still give us a solid step forward (progress not&lt;br/&gt;
perfection).  And, since the decision point is now in the analyzer,&lt;br/&gt;
per-token, it gives users complete flexibility to customize as needed.&lt;/p&gt;

&lt;p&gt;BTW, this appears to not be an English-only need; this page&lt;br/&gt;
(&lt;a href=&quot;http://www.seobythesea.com/?p=1206&quot; class=&quot;external-link&quot;&gt;http://www.seobythesea.com/?p=1206&lt;/a&gt;) lists these example languages as&lt;br/&gt;
also using &quot;English-like&quot; compound words: &quot;Some example languages that&lt;br/&gt;
use compound words include: Afrikaans, Danish, Dutch-Flemish, English,&lt;br/&gt;
Faroese, Frisian, High German, Gutnish, Icelandic, Low German,&lt;br/&gt;
Norwegian, Swedish, and Yiddish.&quot;&lt;/p&gt;
</comment>
                    <comment id="12867112" author="rcmuir" created="Thu, 13 May 2010 12:29:57 +0100"  >&lt;blockquote&gt;
&lt;p&gt;This is why I like the token attr based solution&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I am, and will always be, -1 to this solution. Why can&apos;t we try to think about lucene from a proper internationalization architecture perspective? &lt;/p&gt;

&lt;p&gt;You shouldnt design apis around &quot;e-mail&quot; phenomena in english, thats absurd.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BTW, this appears to not be an English-only need; this page&lt;br/&gt;
(&lt;a href=&quot;http://www.seobythesea.com/?p=1206&quot; class=&quot;external-link&quot;&gt;http://www.seobythesea.com/?p=1206&lt;/a&gt;) lists these example languages as&lt;br/&gt;
also using &quot;English-like&quot; compound words: &quot;Some example languages that&lt;br/&gt;
use compound words include: Afrikaans, Danish, Dutch-Flemish, English,&lt;br/&gt;
Faroese, Frisian, High German, Gutnish, Icelandic, Low German,&lt;br/&gt;
Norwegian, Swedish, and Yiddish.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Please don&apos;t try to insinuate that phrases are the way you should handle compound terms in these languages unless you have some actual evidence that they should be used instead of &quot;normal decompounding&quot;.&lt;/p&gt;

&lt;p&gt;These languages have different syntax and word formation, and its simply not appropriate.&lt;/p&gt;</comment>
                    <comment id="12867117" author="thetaphi" created="Thu, 13 May 2010 12:48:01 +0100"  >&lt;p&gt;Sorry for intervening,&lt;/p&gt;

&lt;p&gt;I am in the same opinion like Hoss:&lt;br/&gt;
A lot of people are common to be able to create phrases in search engines by appending words with dashes (which StandardAnalyzer is perfectly doing with the current query parser impl). As quotes are slower to write, I e.g. always use this approach to search for phrases in Google this-is-a-phrase, which works always and brings identical results like &quot;this is a phrase&quot; (only ranking is sometimes slightly different in Google).&lt;/p&gt;

&lt;p&gt;So we should have at least some possibility to switch the behavior on that creates phrase queries out of multiple tokens with posIncr&amp;gt;0 &amp;#8211; but I am +1 on fixing the problem for non-whitespace languages like cjk. Its also broken, that QueryParser parses whitespace in its javacc grammar, in my opinion, this should be done by the analyzer (and not partly by analyzer and QP grammar).&lt;/p&gt;

&lt;p&gt;In addition: I just bring in again non-compounds like product ids...&lt;/p&gt;</comment>
                    <comment id="12867122" author="rcmuir" created="Thu, 13 May 2010 13:25:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;When StandardAnalyzer splits a part-number-like token, it should do so as well.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think StandardAnalyzer should do any such thing. Maybe in some screwed up search engine biased towards english and analyzers have to work around it, then EnglishAnalyzer would do this, but not StandardAnalyzer.&lt;/p&gt;

&lt;p&gt;And now you see why this is no solution at all, we will only then end up arguing about the toggle for this aweful hack in more places!&lt;/p&gt;

&lt;p&gt;Instead, the tokenizer used for English should tokenize English better, rather than hacking &lt;b&gt;the entire search engine&lt;/b&gt; around it.&lt;/p&gt;</comment>
                    <comment id="12867143" author="yseeley@gmail.com" created="Thu, 13 May 2010 15:23:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;Instead the queryparser should only form phrasequeries when you use double quotes, just like the documentation says.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;re conflating high level user syntax and the underlying implementation.&lt;/p&gt;

&lt;p&gt;&apos;text:Ready&apos; says &quot;search for the word &apos;ready&apos; in the field &apos;text&apos;&quot;... the fact that an underlying term query of &apos;text:readi&apos; (after lowercasing, stemming, etc) is not incorrect, it&apos;s simply the closest match to what the user is asking for given the details of analysis.  Likewise, a user query of &apos;text:ak-47&apos;  may end up as a phrase query of &quot;ak 47&quot; because that&apos;s the closest representation in the index (the user doesn&apos;t necessarily know that the analysis of the field splits on dashes).&lt;/p&gt;

&lt;p&gt;Likewise, a user query of text:&quot;foo bar&quot; is a high level way of saying &quot;search for the word foo immediately followed by the word bar&quot;.  It is &lt;b&gt;not&lt;/b&gt; saying &quot;make a Lucene phrase query object with 2 terms&quot;.  Synonyms, common grams, or other analysis methods may in fact turn this into a single term query.&lt;/p&gt;</comment>
                    <comment id="12867147" author="yseeley@gmail.com" created="Thu, 13 May 2010 15:37:48 +0100"  >&lt;p&gt;bq This is why I like the token attr based solution&lt;/p&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Although I think it&apos;s more general than &quot;de-compounding&quot;.&lt;br/&gt;
An attribute that says &quot;these tokens go together&quot; or &quot;these tokens should be considered one unit&quot; seems like nice generic functionality, and is unrelated to any specific language or search feature.&lt;/p&gt;</comment>
                    <comment id="12867149" author="rcmuir" created="Thu, 13 May 2010 15:40:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;We&apos;re conflating high level user syntax and the underlying implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Then you have no problem if we form phrase queries for all adjacent english words, like we do for chinese.&lt;/p&gt;

&lt;p&gt;Perhaps then you will aware of how wrong this is, this hack designed to make open compounds match hyphenated compounds in english, or whatever it is.&lt;/p&gt;

&lt;p&gt;You are conflating english syntax and word formation into the query parser itself.&lt;/p&gt;</comment>
                    <comment id="12867151" author="rcmuir" created="Thu, 13 May 2010 15:47:24 +0100"  >&lt;blockquote&gt;
&lt;p&gt;An attribute that says &quot;these tokens go together&quot; or &quot;these tokens should be considered one unit&quot; seems like nice generic functionality, and is unrelated to any specific language or search feature.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No,  if they are one unit for search, they are one token.&lt;/p&gt;

&lt;p&gt;Instead the tokenizer should be fixed so that they are one token, instead of making all languages suffer for the lack of a crappy english tokenizer.&lt;/p&gt;</comment>
                    <comment id="12869280" author="mikemccand" created="Wed, 19 May 2010 20:33:34 +0100"  >&lt;p&gt;OK mulling some more on this one...&lt;/p&gt;

&lt;p&gt;Even for english, the QP hack (pre-splitting on whitespace, then&lt;br/&gt;
turning any text that analyzers to multiple tokens into a&lt;br/&gt;
PhraseQuery), doesn&apos;t work right.&lt;/p&gt;

&lt;p&gt;EG, say I want ice-cream, ice cream and icecream to mean the same&lt;br/&gt;
thing.  Really I should do this (handling compounds) during indexing&lt;br/&gt;
&amp;#8211; I&apos;ll get better relevance and performance.  But say for some reason&lt;br/&gt;
I&apos;m doing it at search time...&lt;/p&gt;

&lt;p&gt;I would want an analyzer that detects all three forms and in turn&lt;br/&gt;
expands to all three forms in the query.&lt;/p&gt;

&lt;p&gt;But there&apos;s no way to do this today, because QP pre-splits on&lt;br/&gt;
whitespace, for ice cream the analyzer would separately receive ice&lt;br/&gt;
and cream, so it never has a chance to detect this form of the&lt;br/&gt;
compound.&lt;/p&gt;

&lt;p&gt;So... first, I think we should fix QP to not pre-split on whitespace.&lt;br/&gt;
QP really should be as language neutral as possible.  It should only&lt;br/&gt;
split on syntax chars, and send the whole string in between syntax&lt;br/&gt;
chars to the analyzer.&lt;/p&gt;

&lt;p&gt;And, second, the QP should not create PhraseQuery when it sees&lt;br/&gt;
multiple tokens come back.  This obliterates the OOTB experience for&lt;br/&gt;
non-whitespace languages.  And, it doesn&apos;t work right for&lt;br/&gt;
english... so I think we should deprecate the option and default it to&lt;br/&gt;
&quot;off&quot;.&lt;/p&gt;

&lt;p&gt;Really the contrib queryparser is a better fit for doing rewrites like&lt;br/&gt;
this: it&apos;s able to operate on the abstract query tree, and can easily&lt;br/&gt;
do things like rewriting the query to add phrase queries...&lt;/p&gt;</comment>
                    <comment id="12869885" author="rcmuir" created="Fri, 21 May 2010 06:57:34 +0100"  >&lt;p&gt;Attached is a patch that addresses most of the issue:&lt;/p&gt;

&lt;p&gt;NOTE: I do not tackle the &apos;split on whitespace&apos; issue as this is a larger change and would require changes to the actual grammar itself. We can open a separate JIRA issue for this. This issue is about not generating phrase queries based on how many terms come out of the hardcoded whitespace-tokenizer in QueryParser.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;The bug is preserved based on both Version and subclassing, so previous subclasses overriding getFieldQuery work just fine as before.&lt;/li&gt;
	&lt;li&gt;All lucene/solr tests pass, the backwards/ still uses LUCENE_CURRENT so i had to add a TEST_VERSION_CURRENT there, so that it runs the tests as LUCENE_30 (this is a problem in general).&lt;/li&gt;
	&lt;li&gt;This fixes a host of issues for CJK, not only do we let normal queries work, but phrase/sloppy phrase work correctly too if you use the double quotes. (because if you use PositionFilter hack you disable these!)&lt;/li&gt;
	&lt;li&gt;Normal CJK queries also get coord(), which if you use the PositionFilter hack is disabled too, because it treates the entire query as synonyms. CJK users should get coord() too, like english users, thanks to Ivan for testing this (additional 12% relevance boost on their test collection).&lt;/li&gt;
	&lt;li&gt;Normal CJK queries are formed by the queryparser default operator, same as english queries.&lt;/li&gt;
	&lt;li&gt;English synonym queries (1 term followed by multiple positions) still get coord() disabled as they should.&lt;/li&gt;
	&lt;li&gt;I only migrated one subclass to the new API, the &quot;Extendable Query Parser&quot;, and only because its TestExtendable actually extends TestQueryParser from core (so it had to be done).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The coord-disabled-BQ code for english synonyms need to be generalized in case CJK users use synonyms, single terms followed by posinc=0 terms should form coord-disabled-BQ&apos;s just like they do for english.&lt;/li&gt;
	&lt;li&gt;Add some nice explicit tests for CJK queries, phrase queries, sloppy phrase queries, CJK queries with synonyms, etc.&lt;/li&gt;
	&lt;li&gt;Cutover remaining queryparsers&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;edit: by the way this patch is for 3x, not trunk yet, because 3x has back-compat tests enabled&lt;/p&gt;</comment>
                    <comment id="12869899" author="rcmuir" created="Fri, 21 May 2010 07:48:44 +0100"  >&lt;blockquote&gt;
&lt;p&gt;But there&apos;s no way to do this today, because QP pre-splits on&lt;br/&gt;
whitespace, for ice cream the analyzer would separately receive ice&lt;br/&gt;
and cream, so it never has a chance to detect this form of the&lt;br/&gt;
compound.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I completely agree with this... the hack hurts english too!&lt;/p&gt;

&lt;p&gt;But i ask that we open a separate issue for this, &lt;br/&gt;
as providing backwards compat for this separate problem seems like&lt;br/&gt;
it might need &quot;sophisticated backwards layer&quot;.&lt;/p&gt;

&lt;p&gt;Solving this first problem can be done without any grammar modifications.&lt;/p&gt;</comment>
                    <comment id="12869935" author="mikemccand" created="Fri, 21 May 2010 11:40:35 +0100"  >&lt;blockquote&gt;
&lt;p&gt;But i ask that we open a separate issue for this, &lt;br/&gt;
as providing backwards compat for this separate problem seems like&lt;br/&gt;
it might need &quot;sophisticated backwards layer&quot;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I agree, let&apos;s handle this (&quot;QP should not pre-split on whitespace but instead leave that to the analyzer since it&apos;s language specific&quot;) as a separate issue.&lt;/p&gt;</comment>
                    <comment id="12869941" author="mikemccand" created="Fri, 21 May 2010 11:58:24 +0100"  >&lt;p&gt;Patch looks good Robert!&lt;/p&gt;

&lt;p&gt;You&apos;ve added a new &quot;boolean quoted&quot; param, to getFieldQuery.&lt;/p&gt;

&lt;p&gt;It&apos;s true if the search has double quotes, to force a PhraseQuery.  But if there are no double quotes, it&apos;s true when Version &amp;lt; 31, else false.&lt;/p&gt;

&lt;p&gt;And, when it&apos;s not quoted, you also fixed coord to be enabled for the BQ created, and for the operator to be respected in the BQ that&apos;s created (for the &quot;Chinese&quot; cases).  The getFieldQuery method is now very scary &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  But I don&apos;t think we can improve that much (the logic is must implement is fundamentally hairy).&lt;/p&gt;

&lt;p&gt;So users who want to emulate the English-optimized &quot;forced PhraseQuery even when user didn&apos;t say so explicitly&quot; can create QP with VERSION_30.&lt;/p&gt;</comment>
                    <comment id="12869971" author="rcmuir" created="Fri, 21 May 2010 13:46:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;But I don&apos;t think we can improve that much (the logic is must implement is fundamentally hairy).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I do have some suggestions for the future (we could do when we can get rid of the deprecated behavior).&lt;br/&gt;
But I couldn&apos;t implement anything below, because this change I am working on is already hairy enough itself &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;The problem with getFieldQuery is that it does too much. One of the things it does is a bunch of query rewrites. &lt;br/&gt;
I think a lot of this is silly, and I think if you search on &quot;foo&quot; its ok for the QP to call newPhraseQuery and return a 1-term PhraseQuery.&lt;br/&gt;
This is, after all, what the query was, and it should be closer to a simple parser.&lt;br/&gt;
PhraseQuery already has its own code to later rewrite() to a single TermQuery in this case.&lt;/p&gt;

&lt;p&gt;The other problem with this method is that it is trying to abuse a CachingTokenFilter to work with a TokenStream in &apos;extra dimensions&apos; that it doesnt have.&lt;br/&gt;
In my opinion, instead of doing this, it should just put the terms from the TokenStream in a more suitable data structure that allows the code to be less hairy,&lt;br/&gt;
instead of using a CachingTokenFilter and reset()&apos;ing it.&lt;/p&gt;
</comment>
                    <comment id="12870188" author="rcmuir" created="Fri, 21 May 2010 23:07:53 +0100"  >&lt;p&gt;i added tests for CJK, and cut over all ? extends QueryParser classes.&lt;/p&gt;

&lt;p&gt;TODO still:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;shouldnt depend on whitespace/term count for coord (so cjk synonyms work nice)&lt;/li&gt;
	&lt;li&gt;fix flexible and precedence queryparsers.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12870317" author="markrmiller@gmail.com" created="Sat, 22 May 2010 21:59:24 +0100"  >&lt;p&gt;I still don&apos;t think this falls under bug territory myself - which leads me to thinking that Version is not the correct way to handle it.&lt;/p&gt;

&lt;p&gt;The icecream example showing that this is not a &apos;perfect&apos; solution even for english does not show its a bug in my opinion either. &lt;/p&gt;

&lt;p&gt;I still vote to make this an option. Or make another QueryParser that works with more languages, and I guess with less &apos;biased&apos; english language operators. The whole idea of the new QP was to make that type of thing easy if I remember right.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So users who want to emulate the English-optimized &quot;forced PhraseQuery even when user didn&apos;t say so explicitly&quot; can create QP&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This should be an option, not an emulation.&lt;/p&gt;</comment>
                    <comment id="12870353" author="shaie" created="Sun, 23 May 2010 05:37:55 +0100"  >&lt;p&gt;FWIW, I agree w/ Mark. I don&apos;t think it&apos;s a bug, but more of a user option. Whether it should be specified by a setter, or an extension of QP - I have no strong feelings for either of them, so either would be fine by me.&lt;/p&gt;

&lt;p&gt;And for what&apos;s it&apos;s also worth, we&apos;ve once worked w/ a Japanese linguist, who suggested that we always convert queries like &lt;span class=&quot;error&quot;&gt;&amp;#91;abcd&amp;#93;&lt;/span&gt; to &lt;span class=&quot;error&quot;&gt;&amp;#91;abcd &amp;quot;abcd&amp;quot;&amp;#93;&lt;/span&gt; or just &lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;abcd&amp;quot;&amp;#93;&lt;/span&gt; because if someone had already bothered to write them like that, then phrase matching should contribute to the rank of the documents. IMO, if someone had gone even further by writing &lt;span class=&quot;error&quot;&gt;&amp;#91;field:abcd&amp;#93;&lt;/span&gt;, then even if the query should be &lt;span class=&quot;error&quot;&gt;&amp;#91;field:a field:b field:c field:d&amp;#93;&lt;/span&gt;, executing the query &lt;span class=&quot;error&quot;&gt;&amp;#91;field:&amp;quot;abcd&amp;quot;&amp;#93;&lt;/span&gt; is still important and better.&lt;/p&gt;

&lt;p&gt;So .. I&apos;m not trying to argue what should be the default behavior, because that is subject to personal flavor and apps requirements &amp;#8211; only to emphasize that there are many user cases out there, and we should cater for such scenarios.&lt;/p&gt;

&lt;p&gt;The extension way is already supported, right? So perhaps we just need to document the current behavior, and not change anything? Or, introduce a setter, that will do the simple thing - either keep it as a phrase or break it down to terms. More sophisticated scenarios can be dealt through extension.&lt;/p&gt;</comment>
                    <comment id="12870374" author="simonw" created="Sun, 23 May 2010 10:08:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;FWIW, I agree w/ Mark. I don&apos;t think it&apos;s a bug, but more of a user option&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would rather agree with Shai and Mark here but it is also not the behavior I would expect if I come to lucene the first time and use query parser. I still don&apos;t understand why this should not be done by using version. Exactly stuff like that where the reason to introduce it. Using Version to change runtime behavior has been done before (see CharTokenizer, CharacterUtils, LowerCaseFilter). IMO this is a totally valid usage and makes people aware of that something has changed. I also figured that Version seriously got adopted in the Community, people start using and appreciating it which somewhat changed my mind on Version.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And for what&apos;s it&apos;s also worth, we&apos;ve once worked w/ a Japanese linguist,&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;There will be tons of different opinions to that around linguists around the world but this parser is not for linguists in the first place. It should give the majority of users a good DEFAULT and has never aimed to be a perfect solution. I usually recommend to misplease everybody equally than being biased towards a certain usergroup when providing an API which is not super special purpose.&lt;/p&gt;

&lt;p&gt;It seems to me making this behavior available with Version is the right way to go. I don&apos;t care if people call it a bug or a good default for US text - what count is to give people a good default no matter what they index or where they come from. (sounds like this is close to discriminating people - just kidding)&lt;/p&gt;

&lt;p&gt;Another thing i wanna mention is that QueryParser should really be in contrib / modules rather than in core. I don&apos;t know how many parsers we have in the meanwhile but we should really consolidate them in a new module for 4.0. Get the stuff out there, make a copy of the current parser, name it &quot;SmartENBiasedAutomaticPhraseGeneratingQueryParser&quot;, fix that in the other one and provide people a good default.&lt;/p&gt;

&lt;p&gt;just my $0.05&lt;/p&gt;</comment>
                    <comment id="12870376" author="markrmiller@gmail.com" created="Sun, 23 May 2010 10:25:31 +0100"  >&lt;blockquote&gt;
&lt;p&gt;It seems to me making this behavior available with Version is the right way to go. I don&apos;t care if people call it a bug or a good default for US text - what count is to give people a good default no matter what they index or where they come from. (sounds like this is close to discriminating people - just kidding)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Using Version or not is orthogonal to what the default is IMO though. That&apos;s why its important whether its considered a bug or an option - Version is not a good option selector at all.&lt;/p&gt;

&lt;p&gt;This is part of the goodness of stable/unstable - default options can change in unstable. &lt;/p&gt;</comment>
                    <comment id="12870377" author="simonw" created="Sun, 23 May 2010 10:40:28 +0100"  >&lt;blockquote&gt;&lt;p&gt;Using Version or not is orthogonal to what the default is IMO though. That&apos;s why its important whether its considered a bug or an option - Version is not a good option selector at all.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree, if you upgrade to a new version of lucene and you already deal with version you wanna pass in the version you are upgradeing from and get the same behavior. On the other hand you wanna have a good default when you are new to lucene so Version &amp;gt;=3.1 should give you the new behavior. I guess having a hybrid approach where the given version sets the option sounds like a good compromise - or was that what you where alluding to? I am not saying that this should not be optional just wanna make sure we are consistent with what version is supposed to be used for.&lt;/p&gt;</comment>
                    <comment id="12870384" author="shaie" created="Sun, 23 May 2010 11:37:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;There will be tons of different opinions to that around linguists around the world but this parser is not for linguists in the first place.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure. I&apos;ve pointed that out just to show there are different opinions around that particular problem.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It seems to me making this behavior available with Version is the right way to go&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I disagree (and agree w/ Mark). Version can only control default behavior. This particular issue should be a setter IMO. Irregardless of what the default behavior is, I may want to set it differently. It doesn&apos;t make sense to &lt;b&gt;guess&lt;/b&gt; what Version should I use in order to get that behavior.&lt;/p&gt;

&lt;p&gt;That&apos;s why I don&apos;t mind leaving the current behavior as default, and introduce a setter for whoever wants to change it. The current behavior is not applicable for just English - I bet there&apos;s a whole list of languages which would interpret that query the same (i.e. require a phrase to be generated).&lt;/p&gt;

&lt;p&gt;And I don&apos;t know the distribution of Lucene users around the world, but I&apos;m not sure that CJK users are more common that say English ones, or other European languages. So who knows what a good default is? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I suggest we leave the default as it is now, and introduce a setter. People have been working w/ the parser and that default for a long time. Why suddenly change it?&lt;/p&gt;</comment>
                    <comment id="12870410" author="thetaphi" created="Sun, 23 May 2010 15:59:18 +0100"  >&lt;p&gt;Hi Robert,&lt;/p&gt;

&lt;p&gt;I also agree with Mark (as you know). We can have both:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Version for a good default (3.1 will get the new non-phrase-query behavior)&lt;/li&gt;
	&lt;li&gt;A separate getsetter for this option (set/getCreatePhraseQueryOnConcenattedTerms or whatever)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This would give you the best from both worlds.&lt;/p&gt;</comment>
                    <comment id="12870792" author="rcmuir" created="Mon, 24 May 2010 20:16:36 +0100"  >&lt;p&gt;updated patch that cuts over the remaining two qps: the flexible queryparser and precedence queryparser&lt;/p&gt;</comment>
                    <comment id="12871500" author="rcmuir" created="Wed, 26 May 2010 05:28:05 +0100"  >&lt;p&gt;editing this issue to make it easier to understand.&lt;/p&gt;</comment>
                    <comment id="12871501" author="rcmuir" created="Wed, 26 May 2010 05:35:03 +0100"  >&lt;p&gt;This patch fixes the bug in all queryparsers. I plan to commit soon.&lt;/p&gt;

&lt;p&gt;If desired, someone can make their own euro-centric queryparser in the contrib section and I have no objection, as long as its clearly documented that its unsuitable for many languages (just like the JDK does).&lt;/p&gt;</comment>
                    <comment id="12871510" author="rcmuir" created="Wed, 26 May 2010 06:43:12 +0100"  >&lt;p&gt;Committed revision 948326 (trunk) / 948325 (3x)&lt;/p&gt;</comment>
                    <comment id="12871574" author="markrmiller@gmail.com" created="Wed, 26 May 2010 09:59:06 +0100"  >&lt;p&gt;For all the debate around this change, that was a pretty fast commit IMO ...&lt;/p&gt;</comment>
                    <comment id="12871581" author="markrmiller@gmail.com" created="Wed, 26 May 2010 10:17:04 +0100"  >&lt;p&gt;I know there was more discussion on this in IRC, but I don&apos;t see consensus in the issue. I also don&apos;t see the issues brought up having been addressed or worked out.&lt;/p&gt;

&lt;p&gt;I&apos;ve got to -1 this commit. I even think I may be convinced that making this an option will make future improvements we may want too difficult - but nothing has been hammered out in this JIRA issue. It looks like those that have brought up various points have just been ignored.&lt;/p&gt;

&lt;p&gt;-1.&lt;/p&gt;</comment>
                    <comment id="12871582" author="thetaphi" created="Wed, 26 May 2010 10:18:55 +0100"  >&lt;p&gt;Revert! Revert! Revert!&lt;/p&gt;

&lt;p&gt;By the way, matchVersion should be final. I also like to have a separate setter for the auto-phrase functionality. That should be easy possible!&lt;/p&gt;</comment>
                    <comment id="12871625" author="koji" created="Wed, 26 May 2010 12:16:56 +0100"  >&lt;p&gt;+1 to revert. Though I am a late comer (as always &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  ) and I just read the updated Description, the example behavior of QueryParser for CJK (abcd -&amp;gt; &quot;ab bc cd&quot;) looks correct to me and I&apos;m using QP with CJK as is.&lt;/p&gt;</comment>
                    <comment id="12871642" author="rcmuir" created="Wed, 26 May 2010 13:13:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ve got to -1 this commit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As mentioned on apache&apos;s website:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
To prevent vetos from being used capriciously, they must be accompanied by a technical justification showing why the change is bad (opens a security exposure, negatively affects performance, etc.). A veto without a justification is invalid and has no weight.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;No one has been able to provide any technical justifications, only subjective opinions.&lt;/p&gt;

&lt;p&gt;When standard test collections were used, it was shown that this behavior significant hurts CJK and delivers only 10% of standard IR techniques (not generating phrases but using boolean word/bigram queries). See Ivan&apos;s results above. This isn&apos;t surprising since CJK IR has been pretty well studied, there is nothing new here.&lt;/p&gt;

&lt;p&gt;At the same time, when english test collections were used, there was no difference, on the contrary, it only tended to slightly improve relevance for english, too.&lt;/p&gt;

&lt;p&gt;Why do we even bother trying to start an openrelevance project if people do not want to go with the scientific method but prefer subjective opinion?&lt;/p&gt;
</comment>
                    <comment id="12871737" author="markrmiller@gmail.com" created="Wed, 26 May 2010 14:16:55 +0100"  >&lt;p&gt;I think we should continue working out what&apos;s best here.&lt;/p&gt;

&lt;p&gt;I don&apos;t think its wise to try and bully through contentious issues. There should be consensus before something happens here - barring that, some kind of vote makes sense IMO.&lt;/p&gt;

</comment>
                    <comment id="12871738" author="yseeley@gmail.com" created="Wed, 26 May 2010 14:25:25 +0100"  >&lt;p&gt;Let&apos;s remember that the bug is  &quot;queryparser makes all CJK queries phrase queries regardless of analyzer&quot;.&lt;br/&gt;
The ability of an analysis chain to create phrase queries in conjunction with the query parser is a feature.&lt;br/&gt;
The obvious way to reconcile these opposing statements is to make it configurable.&lt;br/&gt;
Per-parser is a bare minimum... per-field would be better... and per-token would be best.&lt;/p&gt;

&lt;p&gt;I won&apos;t repeat my previous comments in this thread - however those arguments are still valid.&lt;/p&gt;</comment>
                    <comment id="12871907" author="mikemccand" created="Wed, 26 May 2010 20:40:40 +0100"  >&lt;p&gt;I think the latest patch is an OK step forward.  Yeah it&apos;s not&lt;br/&gt;
perfect, but it&apos;s better than what we have today.  Progress not&lt;br/&gt;
perfection.&lt;/p&gt;

&lt;p&gt;QP (and more generally all of Lucene&apos;s core) should aim to be language&lt;br/&gt;
neutral, and it&apos;s not now.  This patch improves that (defaulting the&lt;br/&gt;
auto-PhraseQuery to off, by version).&lt;/p&gt;

&lt;p&gt;Yes, compound/syn handling in English should be available, but the way&lt;br/&gt;
QP does this is really quite broken (the analyzer can&apos;t do multi-words&lt;br/&gt;
syns).&lt;/p&gt;

&lt;p&gt;There are deep questions/ideas about how to properly do multi-words&lt;br/&gt;
syns/compounds (see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1622&quot; title=&quot;Multi-word synonym filter (synonym expansion at indexing time).&quot;&gt;LUCENE-1622&lt;/a&gt; &amp;#8211; we really need to change the index,&lt;br/&gt;
to store &quot;span&quot; of a token).  I&apos;m no longer sure that having analyzer&lt;br/&gt;
mark tokens that should be made into PhraseQuery is the right&lt;br/&gt;
approach... eg with the contrib QP, a plugin could directly tweak the&lt;br/&gt;
query tree, instead of being forced to use a token stream to&lt;br/&gt;
communicate this.&lt;/p&gt;</comment>
                    <comment id="12871909" author="mikemccand" created="Wed, 26 May 2010 20:46:14 +0100"  >&lt;p&gt;How about making the setting (&quot;if analyzer returns more than 1 token for a&lt;br/&gt;
single chunk of whitespace-separated text, make a PhraseQuery&quot;)&lt;br/&gt;
configurable (instead of hardwired according to Version)?  And defaulting it&lt;br/&gt;
to off for Version &amp;gt;= 31 (so CJK, etc., work out of the box)?&lt;/p&gt;</comment>
                    <comment id="12871961" author="markrmiller@gmail.com" created="Wed, 26 May 2010 22:38:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;How about making the setting (&quot;if analyzer returns more than 1 token for a&lt;br/&gt;
single chunk of whitespace-separated text, make a PhraseQuery&quot;)&lt;br/&gt;
configurable (instead of hardwired according to Version)? And defaulting it&lt;br/&gt;
to off for Version &amp;gt;= 31 (so CJK, etc., work out of the box)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think its pretty clear this would make most people happy.&lt;/p&gt;

&lt;p&gt;Personally, I&apos;m somewhat on board with Robert that this may really hamstring us when it comes to further fixes that are needed/wanted in the future.&lt;/p&gt;

&lt;p&gt;To note though - I think in general, most who have commented on this issue are into making CJK work out of the box. But I really think we need to nail down more consensus on this first.&lt;/p&gt;

&lt;p&gt;At a minimum, I think making the behavior configurable, while defaulting to CJK &apos;betterness&apos; by default has pretty much everyone on board.&lt;/p&gt;

&lt;p&gt;But I&apos;d really like to discuss whether doing that will only lead to losing that option as we do things like stop qp from splitting on whitespace in the future...&lt;/p&gt;

&lt;p&gt;Something I was thinking, and it might be more of a maintenance headache than its worth, but we could demote this queryparser from the core query parser, and rename it something like ClassicQueryParser (or whatever), and make a new QueryParser that is better for more languages across the board (originally basing it on the classic parser eg this patch to start). People that like the older more english biased QueryParser can still use it, and by default, new users will likely pick up the default QueryParser that works better with more languages out of the box?&lt;/p&gt;

&lt;p&gt;Just an idea.&lt;/p&gt;

&lt;p&gt;In any event - I think this patch is a step forward too - but it looks to me like there are still open concerns and objections.&lt;/p&gt;</comment>
                    <comment id="12873010" author="rcmuir" created="Fri, 28 May 2010 16:21:18 +0100"  >&lt;p&gt;i would suggest the following, a combination of mike, mark&apos;s, and yonik&apos;s ideas:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;in 3.1 we supply a patch that looks like this one, except, there is a toggle too. this toggle can be per-field.&lt;/li&gt;
	&lt;li&gt;in 4.0 we do the same thing, for now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;we open a separate issue where we replace the QP with something better (that does not split on whitespace &lt;br/&gt;
at all and allows multi-word syns, n-gram tokenization, vietnamese, etc to work) &lt;/p&gt;

&lt;p&gt;as part of that issue take the existing one (with per-field toggle) and call it classicqueryparser or whatever.&lt;/p&gt;

&lt;p&gt;i think we should consider the second separate issue carefully and take more time. I personally would prefer&lt;br/&gt;
if somehow we could &quot;tone down&quot; the flexible queryparser (as far as number of classes, attributes, etc) and &lt;br/&gt;
use that as a base. There are things about it I like, and things I don&apos;t like, but overall it seems to be a better&lt;br/&gt;
starting point for such a thing.&lt;/p&gt;</comment>
                    <comment id="12873022" author="yseeley@gmail.com" created="Fri, 28 May 2010 16:56:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;in 3.1 we supply a patch that looks like this one, except, there is a toggle too. this toggle can be per-field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The easiest way might be to just make it configurable per-parser but changeable at any point in time (i.e. just a getter and a setter).&lt;br/&gt;
Per-field can be handled via subclassing (same way per-field differences are handled for everything else with this QP).&lt;/p&gt;</comment>
                    <comment id="12873024" author="thetaphi" created="Fri, 28 May 2010 17:00:22 +0100"  >&lt;p&gt;+1 @ rmuir &amp;amp; yonik&lt;/p&gt;

&lt;p&gt;I tend to make the per field thing also only by subclassing. If we add a per field property here, we also need things like: switch on date format, numeric type per field.&lt;/p&gt;

&lt;p&gt;A new syntax for the parser in 4.0 is essential in my opinion!&lt;/p&gt;</comment>
                    <comment id="12873025" author="rcmuir" created="Fri, 28 May 2010 17:01:40 +0100"  >&lt;blockquote&gt;
&lt;p&gt;The easiest way might be to just make it configurable per-parser but changeable at any point in time (i.e. just a getter and a setter).&lt;br/&gt;
Per-field can be handled via subclassing (same way per-field differences are handled for everything else with this QP).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, but I thought there was something about dealing with this via subclassing you didnt like?&lt;/p&gt;

&lt;p&gt;With the current patch (with no option at all) you could do this per-field behavior with subclassing already:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Query getFieldQuery(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; text, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; quoted) {
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (field.equals(&lt;span class=&quot;code-quote&quot;&gt;&quot;foobar&quot;&lt;/span&gt;))
   &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getFieldQuery(field, text, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; /* treat it as &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it were quoted */ );
 &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getFieldQuery(field, text, quoted);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12873030" author="yseeley@gmail.com" created="Fri, 28 May 2010 17:05:04 +0100"  >&lt;blockquote&gt;
&lt;p&gt;True, but I thought there was something about dealing with this via subclassing you didnt like?&lt;br/&gt;
With the current patch (with no option at all) you could do this per-field behavior with subclassing already:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True... I&apos;m  fine with subclassing - I guess the only diff is if the default is configurable or set only via version.&lt;/p&gt;</comment>
                    <comment id="12873031" author="rcmuir" created="Fri, 28 May 2010 17:07:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;True... I&apos;m fine with subclassing - I guess the only diff is if the default is configurable or set only via version.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In this case, too, you could override the default with subclassing.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Query getFieldQuery(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; field, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; text, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; quoted) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getFieldQuery(field, text, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; /* treat it as &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it were quoted */);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;but we can add an explicit boolean option for those that don&apos;t subclass?&lt;/p&gt;</comment>
                    <comment id="12873034" author="yseeley@gmail.com" created="Fri, 28 May 2010 17:14:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;In this case, too, you could override the default with subclassing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True - but I think some were saying the default should be configurable w/o subclassing.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;but we can add an explicit boolean option for those that don&apos;t subclass?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right.  I think everyone is essentially saying the same thing at this point (at the high level)?&lt;br/&gt;
Make it configurable (per-parser), and allow the user to handle per-field variations via subclassing.&lt;/p&gt;</comment>
                    <comment id="12873035" author="rcmuir" created="Fri, 28 May 2010 17:17:42 +0100"  >&lt;p&gt;ok i revised the idea here:&lt;/p&gt;

&lt;p&gt;in 3.1 we supply a patch that looks like this one, except, there is a simple boolean toggle too. &lt;br/&gt;
if you want per-field behavior or more explicit customization, you can subclass.&lt;br/&gt;
the simple toggle is for non-subclassers.&lt;/p&gt;

&lt;p&gt;in 4.0 we do the same thing, for now.&lt;/p&gt;

&lt;p&gt;we open a separate issue where we replace the QP with something better (that does not split on whitespace &lt;br/&gt;
at all and allows multi-word syns, n-gram tokenization, vietnamese, etc to work)&lt;/p&gt;

&lt;p&gt;as part of that issue take the existing one (with per-field toggle) and call it classicqueryparser or whatever.&lt;/p&gt;</comment>
                    <comment id="12873038" author="thetaphi" created="Fri, 28 May 2010 17:21:02 +0100"  >&lt;p&gt;+1 to latest proposal!&lt;/p&gt;</comment>
                    <comment id="12873040" author="mikemccand" created="Fri, 28 May 2010 17:28:53 +0100"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12873050" author="markrmiller@gmail.com" created="Fri, 28 May 2010 17:44:28 +0100"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12873645" author="rcmuir" created="Mon, 31 May 2010 14:29:59 +0100"  >&lt;p&gt;attached is an updated patch, with the latest proposal (for 3x branch).&lt;/p&gt;

&lt;p&gt;A boolean option, getter, and setter is added, and it defaults to false only for &amp;gt;= 3.1&lt;br/&gt;
Also added a test for the toggle and some javadocs.&lt;/p&gt;

&lt;p&gt;all tests pass.&lt;/p&gt;</comment>
                    <comment id="12883531" author="rcmuir" created="Tue, 29 Jun 2010 13:37:39 +0100"  >&lt;p&gt;ok, will commit this in a few days.&lt;/p&gt;</comment>
                    <comment id="12889982" author="rcmuir" created="Mon, 19 Jul 2010 20:25:33 +0100"  >&lt;p&gt;Committed revision 965585 / 965592 (3x)&lt;/p&gt;</comment>
                    <comment id="12891914" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 04:20:50 +0100"  >&lt;p&gt;As Koji noticed, it looks like what was committed accidentally changed the default behavior of solr (i.e. the last attached patch didn&apos;t but what was committed did).&lt;br/&gt;
A query of pdp-11 now results in text:pdp OR text:11 instead of text:&quot;pdp 11&quot;&lt;/p&gt;

&lt;p&gt;Perhaps we should switch the SolrQueryParser back to using version==LUCENE_24 (or LUCENE_29 would work too)?&lt;/p&gt;</comment>
                    <comment id="12891915" author="rcmuir" created="Sat, 24 Jul 2010 04:22:50 +0100"  >&lt;p&gt;The change is backwards compatible... it fully respects the version in solrconfig.xml (as it should)&lt;/p&gt;</comment>
                    <comment id="12891916" author="rcmuir" created="Sat, 24 Jul 2010 04:35:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;Perhaps we should switch the SolrQueryParser back to using version==LUCENE_24 (or LUCENE_29 would work too)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I dont think we should do this. the whole &lt;b&gt;point&lt;/b&gt; of this issue was that this auto-generation is a bad default, e.g. &lt;b&gt;every&lt;/b&gt; thai query is a phrase query.&lt;br/&gt;
I agree with Koji&apos;s idea of adding a config hook for autoGeneratePhraseQueries for those that want it though, but i don&apos;t think it should be on by default either.&lt;/p&gt;</comment>
                    <comment id="12891917" author="koji" created="Sat, 24 Jul 2010 04:41:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;I agree with Koji&apos;s idea of adding a config hook for autoGeneratePhraseQueries for those that want it though, but i don&apos;t think it should be on by default either.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks. I&apos;ll open a ticket for it.&lt;/p&gt;</comment>
                    <comment id="12891945" author="thetaphi" created="Sat, 24 Jul 2010 08:00:22 +0100"  >&lt;p&gt;QP has now a public final void setAutoGeneratePhraseQueries(boolean value). The default value is the one coming from Version parameter, but you can easily change it (like e.g. me, often working with such type of product numbers but never CJK text) can easily use this behaviour. Lucene&apos;s problem is, that it does not take position for scoring into account, so documents where the tokens appear next to each other do not score higher (in contract to google, which supports those combined tokens).&lt;/p&gt;</comment>
                    <comment id="12891969" author="rcmuir" created="Sat, 24 Jul 2010 12:55:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;Lucene&apos;s problem is, that it does not take position for scoring into account, so documents where the tokens appear next to each other do not score higher (in contract to google, which supports those combined tokens).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually no, the problem is, this autogeneration never really worked anyway, it was broken from the beginning.&lt;br/&gt;
e.g. &lt;a href=&quot;http://www.lucidimagination.com/search/document/bacf34995067e3cb/worddelimiterfilter_and_phrase_queries&quot; class=&quot;external-link&quot;&gt;http://www.lucidimagination.com/search/document/bacf34995067e3cb/worddelimiterfilter_and_phrase_queries&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12891985" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 15:43:57 +0100"  >&lt;p&gt;I&apos;ve reverted just the change of default behavior to Solr&apos;s QP.&lt;br/&gt;
There are too many negative side-effects to change this given the way Solr is currently used (and documented to behave).&lt;br/&gt;
We need to work on (at a minimum) a per-field config for Solr, but it seems like per-token is still the right way long term.&lt;/p&gt;</comment>
                    <comment id="12891990" author="rcmuir" created="Sat, 24 Jul 2010 16:56:13 +0100"  >&lt;p&gt;Please revert.&lt;/p&gt;</comment>
                    <comment id="12891991" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 17:04:20 +0100"  >&lt;p&gt;The previous patches posted in this issue did not change Solr&apos;s default (else I would have objected earlier).&lt;br/&gt;
From past discussions, it seems like a majority of people feel like the default should be the old behavior for Solr (this default matters much less for Lucene developers).&lt;br/&gt;
We need to find a way to enable the new behavior per-field (although I feel that&apos;s a bit of a hack too... it really should be per-token).&lt;/p&gt;</comment>
                    <comment id="12891993" author="rcmuir" created="Sat, 24 Jul 2010 17:09:55 +0100"  >&lt;p&gt;The patch doesnt change solr&apos;s default, it instead causes SolrQueryParser to respect the version parameter in the solrconfig in &lt;b&gt;both&lt;/b&gt; ctors.&lt;br/&gt;
Before, one ctor used the version specified, the other hardcoded LUCENE_24.&lt;/p&gt;

&lt;p&gt;As i said before, this shouldnt and cannot be &quot;per-token&quot; and such english centric hacks do not belong in the analysis api.&lt;/p&gt;

&lt;p&gt;Separately, I think what Koji is doing on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-2015&quot; title=&quot;add a config hook for autoGeneratePhraseQueries&quot;&gt;&lt;del&gt;SOLR-2015&lt;/del&gt;&lt;/a&gt; is the way to go, not hardcoding LUCENE_24 as a version despite what is in the config.&lt;/p&gt;

&lt;p&gt;I don&apos;t think this english-centric hack should be the default for Solr. It &lt;b&gt;does&lt;/b&gt; completely respect old schemas and is completely backwards compatible,&lt;br/&gt;
such that if you have no version in your schema it will be LUCENE_24 and get the old behavior, &lt;br/&gt;
if you made your own queryparser and subclassed the old API, you get the old behavior, and it respects the version set in the solrconfig rather than overriding it to 2.4 in just one ctor.&lt;/p&gt;</comment>
                    <comment id="12891994" author="thetaphi" created="Sat, 24 Jul 2010 17:11:15 +0100"  >&lt;p&gt;I don&apos;t userstand the backwards issue. We did not change backwards, as the default for luceneMatchVersion is still 2.4 (so anybody using his old solrconfig will get exactly the same behaviour). New users are new and can use the new default. If they don&apos;t like it, they can change the default version or Koji&apos;s parameter.&lt;/p&gt;

&lt;p&gt;The idea about having this in the TS is not bad, but in my opinion too special. But you are right, the tokenizer should report suche concenated words. But on the other hand, you can simply use another tokenizer, that does not split your product numbers.&lt;/p&gt;</comment>
                    <comment id="12891998" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 17:35:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;Before, one ctor used the version specified, the other hardcoded LUCENE_24.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah.... and that constructor is the one that&apos;s used everywhere in Solr (leading me to believe that leaving Solr&apos;s default alone was deliberate).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As i said before, this shouldnt and cannot be &quot;per-token&quot; and such english centric hacks do not belong in the analysis api.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The ability of a filter to say &quot;this token is actually indexed as two adjacent tokens&quot; is fundamental and not related to any specific language.&lt;br/&gt;
It can be &lt;b&gt;used&lt;/b&gt; for language specific hacks perhaps... but it is not a hack itself.&lt;/p&gt;

&lt;p&gt;I never mentioned issues of back compat, but of changes to Solr&apos;s default behavior, which I continue to think is the best.&lt;br/&gt;
I think the best way forward is to add a CJK field to solr that defaults to the opposite behavior (i.e. treats split tokens as completely separate).&lt;/p&gt;</comment>
                    <comment id="12892001" author="rcmuir" created="Sat, 24 Jul 2010 17:40:16 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think the best way forward is to add a CJK field to solr that defaults to the opposite behavior (i.e. treats split tokens as completely separate).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is completely wrong (besides its way more than CJK affected)&lt;/p&gt;

&lt;p&gt;You should consider a &quot;european&quot; field instead.&lt;/p&gt;

&lt;p&gt;Furthermore, you should check if its set to index with &quot;omitTF&quot; and not autogenerate in that case either.&lt;br/&gt;
In trunk I think phrasequery will actually throw an exception in this case instead of silently failing: &lt;br/&gt;
so the autogenerated queries can be very dangerous even for english.&lt;/p&gt;</comment>
                    <comment id="12892002" author="rcmuir" created="Sat, 24 Jul 2010 17:54:30 +0100"  >&lt;p&gt;Please stop committing all these wrong changes.&lt;/p&gt;

&lt;p&gt;Now i have to go revert 2 more commits.&lt;/p&gt;</comment>
                    <comment id="12892003" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 17:58:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;Furthermore, you should check if its set to index with &quot;omitTF&quot; and not autogenerate in that case either.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Solr doesn&apos;t currently allow ommitting TF for text fields.&lt;br/&gt;
It&apos;s good to keep in mind if we ever enable that though.&lt;/p&gt;</comment>
                    <comment id="12892005" author="yseeley@gmail.com" created="Sat, 24 Jul 2010 18:11:27 +0100"  >&lt;p&gt;Robert, it was your commit that changed the default behavior of Solr, and I disagree with that change.&lt;br/&gt;
Technically, I could VETO - but I don&apos;t believe I have ever done a code-change veto, and I don&apos;t want to start now.&lt;br/&gt;
Instead, I&apos;ll try and be constructive by going to work on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-2015&quot; title=&quot;add a config hook for autoGeneratePhraseQueries&quot;&gt;&lt;del&gt;SOLR-2015&lt;/del&gt;&lt;/a&gt; so we can at least configure it per-field.&lt;/p&gt;</comment>
                    <comment id="12892006" author="thetaphi" created="Sat, 24 Jul 2010 18:14:26 +0100"  >&lt;p&gt;It&apos;s a new major version! Even 2 steps major 1.5 -&amp;gt; 3.1 and three steps to 4.0&lt;/p&gt;</comment>
                    <comment id="12892007" author="rcmuir" created="Sat, 24 Jul 2010 18:17:23 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Robert, it was your commit that changed the default behavior of Solr, and I disagree with that change.&lt;br/&gt;
Technically, I could VETO - but I don&apos;t believe I have ever done a code-change veto, and I don&apos;t want to start now&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yonik, i would rather you just VETO than heavy-commit the wrong changes.&lt;br/&gt;
For example, if you said &quot;robert, its annoying that for users with LUCENE_31 version in their solrconfig, &lt;br/&gt;
I don&apos;t feel they don&apos;t have enough flexibility yet without going setting version to LUCENE_30. I feel that&lt;br/&gt;
the parameter setting in &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-2015&quot; title=&quot;add a config hook for autoGeneratePhraseQueries&quot;&gt;&lt;del&gt;SOLR-2015&lt;/del&gt;&lt;/a&gt; should be incorporated into this issue&quot;&lt;/p&gt;

&lt;p&gt;I mean, thats completely constructive!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Instead, I&apos;ll try and be constructive by going to work on &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-2015&quot; title=&quot;add a config hook for autoGeneratePhraseQueries&quot;&gt;&lt;del&gt;SOLR-2015&lt;/del&gt;&lt;/a&gt; so we can at least configure it per-field.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Man, I am willing to help with that also (though, i am not particularly a solr queryparser expert, I think we&lt;br/&gt;
should expose these options to users that want them, instead of requiring them to depend on version-specific&lt;br/&gt;
defaults). Just let me know how I can help, I want constructive progress.&lt;/p&gt;</comment>
                    <comment id="13013456" author="gsingers" created="Wed, 30 Mar 2011 16:50:22 +0100"  >&lt;p&gt;Bulk close for 3.1&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310050">
                <name>Regression</name>
                                <outwardlinks description="breaks">
                            <issuelink>
            <issuekey id="12506129">SOLR-2493</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12445937" name="LUCENE-2458.patch" size="63808" author="rcmuir" created="Mon, 31 May 2010 14:29:59 +0100" />
                    <attachment id="12445369" name="LUCENE-2458.patch" size="58854" author="rcmuir" created="Mon, 24 May 2010 20:16:36 +0100" />
                    <attachment id="12445208" name="LUCENE-2458.patch" size="34263" author="rcmuir" created="Fri, 21 May 2010 23:07:53 +0100" />
                    <attachment id="12445136" name="LUCENE-2458.patch" size="24074" author="rcmuir" created="Fri, 21 May 2010 06:57:34 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 11 May 2010 21:22:14 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11361</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25234</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>