<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:23:29 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1596/LUCENE-1596.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1596] optimize MultiTermEnum/MultiTermDocs</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1596</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Optimize MultiTermEnum and MultiTermDocs to avoid seeks on TermDocs that don&apos;t match the term.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12422641">LUCENE-1596</key>
            <summary>optimize MultiTermEnum/MultiTermDocs</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                <reporter username="yseeley@gmail.com">Yonik Seeley</reporter>
                        <labels>
                    </labels>
                <created>Sat, 11 Apr 2009 21:42:59 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:22 +0100</updated>
                    <resolved>Fri, 15 May 2009 16:56:15 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12698136" author="yseeley@gmail.com" created="Sat, 11 Apr 2009 22:13:09 +0100"  >&lt;p&gt;Attaching optimization patch.  Results up front:&lt;br/&gt;
  random seeks to common terms with term enumerator:  58% improvement&lt;br/&gt;
  full iteration over all docs matching relatively unique terms: 1595% improvement&lt;/p&gt;

&lt;p&gt;The optimizations:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;MultiTermEnum keeps track of which segments match... if termDocs.seek(termEnum) is used, then MultiTermDocs will only visit segments that matched the term.&lt;/li&gt;
	&lt;li&gt;MultiTermEnum defers calling next() on sub enumerators until needed.  This allows MultiTermDocs to use the faster seek(enum) since the enumerator is still on the correct term.  This also avoids unnecessary calls to next() that may never be used, as well as unnecessary insertions into the priority queue.  Using seek(enum) in the sub TermDocs also allows cascading of these optimizations (in the event that one has a MultiReader of MultiReaders).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Test index: this was obviously stacked to show best-case performance for these optimizations.  999,999 documents with maxBufferedDocs=10, resulting in 46 segments.  The full iteration test used relatively unique terms (1 or 2 docs matching each), and the random seeks test used very common terms (if rare terms are used in this test, the initial seek dominates and swamps any improvement from the deferral of calls to next().)&lt;/p&gt;</comment>
                    <comment id="12698140" author="paul.elschot@xs4all.nl" created="Sat, 11 Apr 2009 22:30:26 +0100"  >&lt;p&gt;Do I interpret correctly that getting the docIds for terms that are (almost) primary keys on a non optimized index will become a &lt;em&gt;lot&lt;/em&gt; faster with this patch?&lt;/p&gt;</comment>
                    <comment id="12698142" author="yseeley@gmail.com" created="Sat, 11 Apr 2009 22:46:54 +0100"  >&lt;p&gt;Yes, &lt;b&gt;if&lt;/b&gt; you are doing low level stuff directly on the MultiReader, like using TermEnum/TermDocs.  Or calling Filter.getBits(multiReader).  As you probably know, if you pass Filters or Queries to an IndexSearcher, it&apos;s now dropping down to the segment level already (a scorer is created per-segment) so it won&apos;t hit the MultiTermEnum code.&lt;/p&gt;
</comment>
                    <comment id="12698197" author="mikemccand" created="Sun, 12 Apr 2009 10:40:48 +0100"  >&lt;p&gt;Patch look good Yonik!&lt;/p&gt;</comment>
                    <comment id="12698220" author="yseeley@gmail.com" created="Sun, 12 Apr 2009 14:47:41 +0100"  >&lt;p&gt;Hmmm, unfortunately, this patch does nothing for RangeFilter.getDocIdSet(MultiReader), as the term enumerator used there is no longer a MultiTermEnum.&lt;/p&gt;</comment>
                    <comment id="12698221" author="thetaphi" created="Sun, 12 Apr 2009 14:56:34 +0100"  >&lt;p&gt;Really? It&apos;s just a FilteredTermEnum on top of the TermEnum returned by MultiReader - so even when the filtered enum filters some terms, it should use the MultiTermEnum methods to iterate the terms.&lt;/p&gt;</comment>
                    <comment id="12698382" author="yseeley@gmail.com" created="Mon, 13 Apr 2009 13:31:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s just a FilteredTermEnum on top of the TermEnum returned by MultiReader&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, but the MultiTermEnum has the internal knowledge about what segments matched the term, and actually has the sub-TermEnums positioned on that term.&lt;/p&gt;</comment>
                    <comment id="12698402" author="thetaphi" created="Mon, 13 Apr 2009 15:52:45 +0100"  >&lt;p&gt;Yes I understand, the problematic call is TermDocs.seek(TermEnum) which does an instanceof check. If it is a FilteredTermEnum or anything other, which is wrapped, the optimization is not used.&lt;/p&gt;</comment>
                    <comment id="12709244" author="yseeley@gmail.com" created="Thu, 14 May 2009 02:56:31 +0100"  >&lt;p&gt;Getting back to this... although this unfortunately won&apos;t currently help classes like RangeFilter used directly on a MultiReader because a MultiTermEnum is no longer used, I still think this is worth committing as-is for users of MultiTermEnum.&lt;/p&gt;

&lt;p&gt;Thoughts/objections?&lt;/p&gt;</comment>
                    <comment id="12709349" author="mikemccand" created="Thu, 14 May 2009 11:28:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;although this unfortunately won&apos;t currently help classes like RangeFilter used directly on a MultiReader because a MultiTermEnum is no longer used, I still think this is worth committing as-is for users of MultiTermEnum.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;It&apos;d be great to somehow have the optimization apply to RangeFilter as well, though since Lucene has now moved to per-segment searching, it&apos;s low priority.&lt;/p&gt;</comment>
                    <comment id="12709476" author="yseeley@gmail.com" created="Thu, 14 May 2009 18:25:10 +0100"  >&lt;p&gt;Committed.&lt;/p&gt;</comment>
                    <comment id="12709792" author="mikemccand" created="Fri, 15 May 2009 11:00:09 +0100"  >&lt;p&gt;I&apos;m seeing this new AIOOBE when tracking down the intermittent failure&lt;br/&gt;
in TestStressIndexing2:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
1) testRandomIWReader(org.apache.lucene.index.TestStressIndexing2)
java.lang.ArrayIndexOutOfBoundsException: 6
	at org.apache.lucene.index.MultiSegmentReader$MultiTermDocs.next(MultiSegmentReader.java:672)
	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:292)
	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:250)
	at org.apache.lucene.index.TestStressIndexing2.testRandomIWReader(TestStressIndexing2.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:168)
	at org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)
	at junit.framework.TestCase.runBare(TestCase.java:134)
	at junit.framework.TestResult$1.protect(TestResult.java:110)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at junit.framework.TestResult.run(TestResult.java:113)
	at junit.framework.TestCase.run(TestCase.java:124)
	at junit.framework.TestSuite.runTest(TestSuite.java:232)
	at junit.framework.TestSuite.run(TestSuite.java:227)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:81)
	at org.junit.internal.runners.CompositeRunner.runChildren(CompositeRunner.java:33)
	at org.junit.internal.runners.CompositeRunner.run(CompositeRunner.java:28)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:130)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:109)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:100)
	at org.junit.runner.JUnitCore.runMain(JUnitCore.java:81)
	at org.junit.runner.JUnitCore.main(JUnitCore.java:44)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think it&apos;s because this optimization isn&apos;t admissible in the case&lt;br/&gt;
when one calls MultiTermDocs.seek on a MultiTermEnum derived from a&lt;br/&gt;
different MultiSegmentReader.  Ie, I think there needs to be another&lt;br/&gt;
check that verifies in fact the MultiTermEnum passed to&lt;br/&gt;
MultiTermDocs.seek share the same MultiSegmentReader?&lt;/p&gt;

&lt;p&gt;Before this optimiztion, this was OK (only the term was used from the&lt;br/&gt;
MultiTermEnum).&lt;/p&gt;</comment>
                    <comment id="12709854" author="yseeley@gmail.com" created="Fri, 15 May 2009 15:28:20 +0100"  >&lt;p&gt;Gah... I forgot it was permissible (or at least not disallowed) to pass an Enum not derived from the same reader.&lt;br/&gt;
I&apos;ll fix.&lt;/p&gt;</comment>
                    <comment id="12709890" author="yseeley@gmail.com" created="Fri, 15 May 2009 16:56:15 +0100"  >&lt;p&gt;I just committed the fix (since trunk was broken) and a test that failed w/o the fix, but if anyone has a better idea how to handle/fix, we can certainly still discuss.    I just did the obvious - store the multi-reader in the TermEnum and TermDocs instances and compare in TermDocs.seek(TermEnum)&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12405241" name="LUCENE-1596.patch" size="5819" author="yseeley@gmail.com" created="Sat, 11 Apr 2009 22:13:09 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 11 Apr 2009 21:30:26 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12159</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26132</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>