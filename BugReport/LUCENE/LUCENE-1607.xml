<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:08:48 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1607/LUCENE-1607.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1607] String.intern() faster alternative</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1607</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;By using our own interned string pool on top of default, String.intern() can be greatly optimized.&lt;/p&gt;

&lt;p&gt;On my setup (java 6) this alternative runs ~15.8x faster for already interned strings, and ~2.2x faster for &apos;new String(interned)&apos;&lt;br/&gt;
For java 5 and 4 speedup is lower, but still considerable.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12423227">LUCENE-1607</key>
            <summary>String.intern() faster alternative</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="yseeley@gmail.com">Yonik Seeley</assignee>
                                <reporter username="earwin">Earwin Burrfoot</reporter>
                        <labels>
                    </labels>
                <created>Sun, 19 Apr 2009 16:22:06 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:22 +0100</updated>
                    <resolved>Wed, 5 Aug 2009 19:05:17 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                        <due></due>
                    <votes>1</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12700593" author="markrmiller@gmail.com" created="Sun, 19 Apr 2009 17:52:02 +0100"  >&lt;p&gt;What was the field count? Is it still a considerable speedup with hundreds of fields without slowing anything else down ?(I would assume so, but would be nice to know considering a new hashmap is made per add - it is a one time hit though and the number of fields is not likely to exceed hundreds at the extreme)?&lt;/p&gt;

&lt;p&gt;Also would be great to get the speedup numbers for Java 4 and 5.&lt;/p&gt;

&lt;p&gt;I&apos;ll relate this to the 3 or 4 other field intern issues out there in a bit.&lt;/p&gt;</comment>
                    <comment id="12700598" author="yseeley@gmail.com" created="Sun, 19 Apr 2009 19:17:52 +0100"  >&lt;p&gt;Here&apos;s a completely lockless and memory barrier free intern() cache.&lt;br/&gt;
This default would be more back compatible since programs may rely on String instances being interned via String.intern().&lt;/p&gt;

&lt;p&gt;It does not yet include corresponding Lucene code changes to use the StringInterner.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                    <comment id="12700599" author="yseeley@gmail.com" created="Sun, 19 Apr 2009 19:22:54 +0100"  >&lt;p&gt;Earwin, I took a quick look at your implementation just now, but it doesn&apos;t look thread-safe.&lt;/p&gt;</comment>
                    <comment id="12700600" author="markrmiller@gmail.com" created="Sun, 19 Apr 2009 19:55:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;Earwin, I took a quick look at your implementation just now, but it doesn&apos;t look thread-safe. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That was my first impression too, but I couldnt pin down the issue. The access will either be against the old pool, or it will be against the new pool, and the instance switch should be atomic? I figured it was a clever trick of some kind (though I did wonder about the cost of making the new hashmap every add). The HashMaps are read only right (once they can be accessed by multiple threads)? And they are popped in with an atomic variable assignment?&lt;/p&gt;</comment>
                    <comment id="12700601" author="earwin" created="Sun, 19 Apr 2009 20:11:32 +0100"  >&lt;blockquote&gt;&lt;p&gt;This default would be more back compatible since programs may rely on String instances being interned via String.intern(). &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;My version is also String.intern()-compatible&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Earwin, I took a quick look at your implementation just now, but it doesn&apos;t look thread-safe.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;unlock for one thread happens-before lock on the same monitor for the other thread, inside each thread each action happens-before the next one&lt;br/&gt;
Since I get pool reference for the second time after the lock, and write pool reference before unlocking, everything&apos;s fine. As for the other threads, if they find what they need in the pool, it doesn&apos;t matter if they&apos;re seeing a stale pool, or not. If they don&apos;t find what they need, they hit the lock, re-retrieve pool reference, getting the latest one and either find what they need there, or write.&lt;br/&gt;
Correct me if I&apos;m wrong?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;though I did wonder about the cost of making the new hashmap every add&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It&apos;s COSTLY &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But you&apos;re going to pay all of it at startup.&lt;/p&gt;

&lt;p&gt;I think we can introduce the class (without any interfaces, why should we need one here?), and then try to make it faster by switching storage. I tried GNU Trove THashMap, but on Java 6 it was slower than stock HashMap.&lt;/p&gt;</comment>
                    <comment id="12700604" author="earwin" created="Sun, 19 Apr 2009 20:39:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;What was the field count? Is it still a considerable speedup with hundreds of fields without slowing anything else down ?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The field count was 1 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I rewrote the benchmark, with extra code Java6 speedup on single already interned field became 12.5x.&lt;br/&gt;
Results for three java varieties, and different sets of keys follow:&lt;/p&gt;

&lt;p&gt;Java 6 (64, server):&lt;/p&gt;

&lt;p&gt;  1 key&lt;br/&gt;
interned 12.47x&lt;br/&gt;
uninterned 3.76x&lt;/p&gt;

&lt;p&gt;  10 keys&lt;br/&gt;
interned 8.03x&lt;br/&gt;
uninterned 3.08x&lt;/p&gt;

&lt;p&gt;  100 keys&lt;br/&gt;
interned 6.58x&lt;br/&gt;
uninterned 2.55x&lt;/p&gt;

&lt;p&gt;  1000 keys&lt;br/&gt;
interned 5.39x&lt;br/&gt;
uninterned 2.69x&lt;/p&gt;

&lt;p&gt;Java 5 (64, server):&lt;/p&gt;

&lt;p&gt;  1 key&lt;br/&gt;
interned 9.84x&lt;br/&gt;
uninterned 5.03x&lt;/p&gt;

&lt;p&gt;  10 keys&lt;br/&gt;
interned 7.00x&lt;br/&gt;
uninterned 4.61x&lt;/p&gt;

&lt;p&gt;  100 keys&lt;br/&gt;
interned 6.61x&lt;br/&gt;
uninterned 2.28x&lt;/p&gt;

&lt;p&gt;  1000 keys&lt;br/&gt;
interned 4.73x&lt;br/&gt;
uninterned 2.73x&lt;/p&gt;

&lt;p&gt;Java 4 (32, client):&lt;/p&gt;

&lt;p&gt;  1 key&lt;br/&gt;
interned 4.90x&lt;br/&gt;
uninterned 2.88x&lt;/p&gt;

&lt;p&gt;  10 keys&lt;br/&gt;
interned 4.08x&lt;br/&gt;
uninterned 2.67x&lt;/p&gt;

&lt;p&gt;  100 keys&lt;br/&gt;
interned 3.88x&lt;br/&gt;
uninterned 2.52x&lt;/p&gt;

&lt;p&gt;  1000 keys&lt;br/&gt;
interned 3.44x&lt;br/&gt;
uninterned 2.31x&lt;/p&gt;</comment>
                    <comment id="12700618" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 01:33:04 +0100"  >&lt;p&gt;The thread safety problem has to do with safe object publication (making an object visible to a different thread).  Mutable objects generally can&apos;t be safely published w/o synchronization.... it has to do with CPU caches in multi-CPU systems.&lt;/p&gt;

&lt;p&gt;IIRC, current x86 architectures will see fewer problems since read barriers are no-ops.. caches are guaranteed to be coherent.  But even on x86, you aren&apos;t guaranteed that instructions and writes won&apos;t be reordered...  so the assignment to pool could be visible &lt;b&gt;before&lt;/b&gt; all the memory changes that newPool.put() could cause.&lt;/p&gt;</comment>
                    <comment id="12700629" author="css145hs" created="Mon, 20 Apr 2009 02:36:02 +0100"  >&lt;p&gt;Good point Yonik.  Making pool volatile should take care of it, but only on JVMs 1.5+, as before that volatile didn&apos;t prevent reordering of non-volatile reads/writes around it.&lt;/p&gt;</comment>
                    <comment id="12700696" author="earwin" created="Mon, 20 Apr 2009 09:28:48 +0100"  >&lt;p&gt;Okay, you&apos;re probably right. It&apos;s not that hashmap can be corrupted on subsequent write, it&apos;s that reader threads can possibly see not-yet-built hashmap.&lt;br/&gt;
And volatile works, while simple sync doesn&apos;t, because volatile also orders reads. &lt;br/&gt;
Hm. Hm. Hm.&lt;br/&gt;
Than, as you suggested, all we need is our own hash implementation that remains usable even being partially updated. I skipped through your patch and something looks suspicious to me. Like lack of collision resolve and that line:&lt;br/&gt;
int slot = h &amp;amp; (cache.length-1);&lt;br/&gt;
It&apos;ll break on non-power-of-two sizes.&lt;/p&gt;</comment>
                    <comment id="12700784" author="markrmiller@gmail.com" created="Mon, 20 Apr 2009 13:19:18 +0100"  >&lt;blockquote&gt;&lt;p&gt;The thread safety problem has to do with safe object publication&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh, great, you mean basic concurrency competency &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Well thats an embarrassing erosion of knowledge. Back to the books. Thread a has no happens before relationship with thread b unless they share the lock. I trained myself to just synchronize or use volatile long ago (and then let the knowledge begin seeping I guess), but even still, every time I see one of these double lock check type tricks I go, eh, this one must work or something.&lt;/p&gt;</comment>
                    <comment id="12700827" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 16:49:55 +0100"  >&lt;blockquote&gt;&lt;p&gt;lack of collision resolve&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My version was the most basic... a simple cache that is not guaranteed to always hit.  I also wanted to keep the overhead very low in case of misses (hence no re-probing).  In the best case, I don&apos;t think one can get much faster... and in the worst case it won&apos;t be much slower than simple String.intern().  There could be other implementations that do resizing of course.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It&apos;ll break on non-power-of-two sizes. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The size is guaranteed to be a power of two by the constructor.&lt;/p&gt;</comment>
                    <comment id="12700921" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 21:30:41 +0100"  >&lt;p&gt;Here&apos;s another version that uses closed hashing and table resizes to cache all interned strings requested.  It remains lock free and memory barrier free on the read side.&lt;/p&gt;</comment>
                    <comment id="12700924" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 21:36:29 +0100"  >&lt;p&gt;corrected load factor check (the previous code actually calculated 80%, not 75%).&lt;/p&gt;</comment>
                    <comment id="12700926" author="earwin" created="Mon, 20 Apr 2009 21:40:54 +0100"  >&lt;p&gt;Okay, I thought more about that. Yonik is amazing.&lt;/p&gt;

&lt;p&gt;The fastest hash we can get, should have no collisions. This is achievable by resizing on each new collision. Then we should introduce an upper bound for this process, for it not to blow up. Finally, we can use our upper bound for hash size from the start.&lt;/p&gt;

&lt;p&gt;I benchmarked a bit, it works better than HashTable.&lt;br/&gt;
Somewhat better for already interned strings, much better for noninterned strings.&lt;br/&gt;
&quot;s1==s2 || s1.compareTo(s2) == 0&quot; combo amazingly works faster than s1.equals(s2).&lt;br/&gt;
Additional hashcode check makes sparse hash access a bit slower and doesn&apos;t really help with crowded hash.&lt;br/&gt;
Having a crowded hash degrades performance a lot. &lt;/p&gt;

&lt;p&gt;I updated my patch with Yonik&apos;s algorithm. Kept everything in statics (faster), allowed to change cache size through system property for adventurous types, default is 16k (works well for 100 values)&lt;/p&gt;</comment>
                    <comment id="12700928" author="earwin" created="Mon, 20 Apr 2009 22:00:07 +0100"  >&lt;p&gt;Hehe, ten minute difference. Take over this issue, since you&apos;re obviously better at it than I?&lt;/p&gt;</comment>
                    <comment id="12700931" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 22:02:28 +0100"  >&lt;blockquote&gt;&lt;p&gt;The fastest hash we can get, should have no collisions. This is achievable by resizing on each new collision.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;b&gt;edit&lt;/b&gt;: agree, for the first version that was only a cache where collisions invalidate the entry and cause another String.intern() to be called... my comments below are with respect to the second version of my code where interned strings are never dropped from the table.&lt;/p&gt;

&lt;p&gt;Hmmm, in my quick&apos;n&apos;dirty tests of about 256 unique strings, a smaller hash table was actually quicker (initialized with 32 and let it resize vs starting at 1024).  I imagine that this would be due to a larger part of the table fitting in smaller and faster processor caches.  YMMV.  Collisions should also be very quick to skip by comparing the hash code (which is cached for Strings).&lt;/p&gt;
</comment>
                    <comment id="12700935" author="earwin" created="Mon, 20 Apr 2009 22:10:52 +0100"  >&lt;blockquote&gt;&lt;p&gt;Collisions should also be very quick to skip by comparing the hash code (which is cached for Strings).&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;In no-collision resolution scheme, if you detect a collision early with hashcode, you still call String.intern(). That kills any benefit gained from hashcode check vs compareTo. And if no collision is detected, introducing this check slows things down a little. Yes, that surprised me too.&lt;/p&gt;</comment>
                    <comment id="12700942" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 22:22:14 +0100"  >&lt;blockquote&gt;&lt;p&gt;In no-collision resolution scheme, if you detect a collision early with hashcode, you still call String.intern(). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In the old code, yes... that&apos;s why I left it commented out there.  In the latest code, we re-probe on a collision w/o calling compareTo (assuming hashCodes are unequal) and only call intern() if it&apos;s really a String we haven&apos;t seen before.  The new code is a real hash table that will store all the Strings requested through it, unlike the first variant that was a simple cache.&lt;/p&gt;</comment>
                    <comment id="12701626" author="earwin" created="Wed, 22 Apr 2009 19:39:31 +0100"  >&lt;p&gt;I tried it out. Works a little bit better than simple cache (no stray interns must&apos;ve paid off), doesn&apos;t degrade at all.&lt;br/&gt;
I&apos;d like to change starter value to something 256-1024, it works way better for 10-20 fields.&lt;/p&gt;

&lt;p&gt;Why h &amp;gt;&amp;gt; 7? I understand that you&apos;re sacking collision-guilty bits, but why not exact amount that was used (have to store it?), or a whole byte or two?&lt;/p&gt;</comment>
                    <comment id="12704225" author="earwin" created="Wed, 29 Apr 2009 19:01:35 +0100"  >&lt;p&gt;Mmm.. what&apos;s the status of this one?&lt;br/&gt;
Should I add a patch with Yonik&apos;s last hash impl and all calls to String.intern() replaced to get it moving?&lt;/p&gt;</comment>
                    <comment id="12704246" author="peger@automotive.com" created="Wed, 29 Apr 2009 19:40:05 +0100"  >&lt;p&gt;As a quick comment on the implementation, i notice that it is possible (with reasonable probability) for hash collisions to result in re-interning a pair of strings multiple times. For example, a codepath that traverses across 32 unique string datapoints (say, in an inner loop somewhere), would have a minimum 3% probability of colliding and re-interning 2 strings every time through the loop. Because of the birthday paradox, it becomes likely to have such a situation (50% probability with ~150 unique values).&lt;/p&gt;

&lt;p&gt;These are the probabilities of collision, assuming random distribution and perfect hashing. In real life the distribution will not be so random (string.hashCode() &amp;amp; MASK) so these will be &quot;best case&quot;.&lt;br/&gt;
2 datapoints: collision prob = 0.006104%&lt;br/&gt;
4 datapoints: collision prob = 0.036617%&lt;br/&gt;
8 datapoints: collision prob = 0.170779%&lt;br/&gt;
16 datapoints: collision prob = 0.729976%&lt;br/&gt;
32 datapoints: collision prob = 2.983863%&lt;br/&gt;
64 datapoints: collision prob = 11.591861%&lt;br/&gt;
128 datapoints: collision prob = 39.188158%&lt;br/&gt;
256 datapoints: collision prob = 86.501947%&lt;/p&gt;


&lt;p&gt;Practically this may or may not matter. My thought is that some sort of fast LRU structure would be better, but of course creating something like this without locking may be tricky. Another idea might be to support some form of limited hash-chaining or probing in the table, which would mitigate the damage of a collision significantly.&lt;/p&gt;


&lt;p&gt;for reference, python code for calculating birthday/hash collisions, shamelessly stolen:&lt;br/&gt;
--------------------&lt;br/&gt;
def bp(n, d):&lt;br/&gt;
	v = 1.0&lt;br/&gt;
	for i in range&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;:&lt;br/&gt;
		v = v * (1 - float&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;/d)&lt;br/&gt;
	return 1 - v&lt;/p&gt;

&lt;p&gt;for n in &lt;span class=&quot;error&quot;&gt;&amp;#91;2, 4, 8, 16, 32, 64, 128, 256&amp;#93;&lt;/span&gt;:&lt;br/&gt;
	print &quot;%i datapoints: collision prob = %f%%&quot; % (n, bp(n, 16*1024)*100)&lt;/p&gt;</comment>
                    <comment id="12704247" author="yseeley@gmail.com" created="Wed, 29 Apr 2009 19:42:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;why h &amp;gt;&amp;gt; 7?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Was copied from Solr&apos;s hashing of doc ids... we didn&apos;t want to throw away too many lower bits since they were likely to be the most random.  In string hashes, the rightmost bits also have the most entropy.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should I add a patch with Yonik&apos;s last hash impl and all calls to String.intern() replaced to get it moving? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That would be helpful, thanks!&lt;/p&gt;</comment>
                    <comment id="12704252" author="yseeley@gmail.com" created="Wed, 29 Apr 2009 19:56:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;As a quick comment on the implementation, i notice that it is possible (with reasonable probability) for hash collisions to result in re-interning a pair of strings multiple times.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For the first implementation, yes.  The latest implementation is guaranteed to only intern a string once ( the hashtable does probing and resizing.)&lt;/p&gt;</comment>
                    <comment id="12704261" author="peger@automotive.com" created="Wed, 29 Apr 2009 20:09:08 +0100"  >&lt;p&gt;Ah I see thanks. Was looking at the most recent patch (by  date).&lt;/p&gt;</comment>
                    <comment id="12704278" author="earwin" created="Wed, 29 Apr 2009 20:30:55 +0100"  >&lt;p&gt;This should do.&lt;br/&gt;
I replaced a pair of intern()s that appeared on trunk after last patch, initial cache size is 1024 and won&apos;t probably go up for most people.&lt;br/&gt;
Also renamed some variables while trying to understand the code, can revert them back if it&apos;s important for anyone.&lt;/p&gt;</comment>
                    <comment id="12704306" author="yseeley@gmail.com" created="Wed, 29 Apr 2009 21:06:55 +0100"  >&lt;p&gt;The last patch removed the ability to plug a different implementation, but I guess we don&apos;t need that until we have another implementation (and it&apos;s not clear if the benefits of dumping String.intern() compatability in the future outweigh the disadvantages of breaking back compatibility).&lt;/p&gt;

&lt;p&gt;Rethinking what possible problems this could have... I&apos;m not sure it should be committed in it&apos;s current form.  One problem is potentially unlimited growth where there was not before.  This could happen in a long running search system where users enter a variety of field names that don&apos;t even exist.&lt;/p&gt;

&lt;p&gt;A WeakReference based approach would work (as String.intern() uses), but that&apos;s more heavyweight and could need synchronization since we are dealing with more complex objects.&lt;br/&gt;
Another option is to go back to a simple cache based approach which could still pin otherwise unreferenced Strings in memory, but would have a bounded size.  Perhaps this argues for reinstating the pluggability of the intern implementation.&lt;/p&gt;</comment>
                    <comment id="12704313" author="earwin" created="Wed, 29 Apr 2009 21:24:13 +0100"  >&lt;p&gt;Is there &apos;any&apos; benefit of dumping String.intern() compatibility? All those interns happen at startup anyway.&lt;br/&gt;
If future brings us something better (which I doubt in this case), we&apos;ll just swap the impl, which is all-private.&lt;/p&gt;

&lt;p&gt;All in all I consider a practice of system-property-driven pluggable implementations a sickening one. Take MMapDirectory that was impossible to use until now without twiddling with startup keys, take SegmentReader/ReadonlySegmentReader - resulting code is ugly and nobody&apos;s going to override defaults anyway, all important dependencies are package-private.&lt;/p&gt;</comment>
                    <comment id="12704315" author="earwin" created="Wed, 29 Apr 2009 21:29:58 +0100"  >&lt;p&gt;A top bound on cache size will do? If you&apos;re fed too much unique strings it&apos;ll end up with characteristics of simple cache.&lt;/p&gt;</comment>
                    <comment id="12704448" author="yseeley@gmail.com" created="Thu, 30 Apr 2009 03:41:11 +0100"  >&lt;p&gt;Here is another alternative that is limited in size to prevent unbounded growth, and should still handle collisions acceptably.  It&apos;s completely lockless (even for updates) and uses open hashing.  Each bucket is an insertion-order cache (inserts at the head) and is limited to a certain length.&lt;/p&gt;</comment>
                    <comment id="12704484" author="shalinmangar" created="Thu, 30 Apr 2009 06:44:51 +0100"  >&lt;p&gt;Yonik, the string is being interned twice in your latest patch&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (e==&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
+        s = s.intern();
+        arr[slot] = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Entry(s.intern(), h, first);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12704638" author="yseeley@gmail.com" created="Thu, 30 Apr 2009 14:49:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;Yonik, the string is being interned twice in your latest patch &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks - I had actually fixed that... but it didn&apos;t make it into the patch apparently &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12706129" author="earwin" created="Tue, 5 May 2009 19:03:35 +0100"  >&lt;p&gt;Bug in previous algo (unbounded hash):&lt;/p&gt;

&lt;p&gt;      // check cached hashCode first, and use compareTo to avoid&lt;br/&gt;
      // dynamic type checking in equals().&lt;br/&gt;
      if (h == other.hashCode() &amp;amp;&amp;amp; s.compareTo(other)==0) &lt;/p&gt;
{
        return s;          &amp;lt;--- here we should return &apos;other&apos;
      }</comment>
                    <comment id="12709234" author="yseeley@gmail.com" created="Thu, 14 May 2009 01:52:54 +0100"  >&lt;p&gt;Here&apos;s a slightly updated patch (javadoc and StringHelper.intern() convenience method).&lt;/p&gt;

&lt;p&gt;The method of plugging a different StringInterner implementation would be to simply assign to the static in StringHelper.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  /**
   * Expert:
   * The StringInterner implementation used by Lucene.
   * This should never be changed after other Lucene APIs have been used.
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; StringInterner interner = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SimpleStringInterner(1024,8);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Are people comfortable with this approach?  How about the defaults?  This should speed up anyone with under thousands of field, and only slightly slow down someone with over thousands of fields (until they plugged in a new interner with a bigger table size).&lt;/p&gt;
</comment>
                    <comment id="12718181" author="mikemccand" created="Wed, 10 Jun 2009 21:13:20 +0100"  >&lt;p&gt;Yonik is this ready to go in...?&lt;/p&gt;</comment>
                    <comment id="12718188" author="yseeley@gmail.com" created="Wed, 10 Jun 2009 21:29:17 +0100"  >&lt;p&gt;I think so... but I was waiting for some kind of feedback if people in general thought it was the right approach.  It introduces another static, and people tend to not like that.  I accidentally didn&apos;t upload the latest version with the javadoc + helper method.  I&apos;ll do that now.&lt;/p&gt;</comment>
                    <comment id="12718189" author="yseeley@gmail.com" created="Wed, 10 Jun 2009 21:33:31 +0100"  >&lt;p&gt;latest patch - could use a multi-threaded testcase to ensure no exceptions are thrown and that intern() always returns the same instance.&lt;/p&gt;</comment>
                    <comment id="12718198" author="earwin" created="Wed, 10 Jun 2009 22:02:15 +0100"  >&lt;blockquote&gt;&lt;p&gt;but I was waiting for some kind of feedback if people in general thought it was the right approach. It introduces another static, and people tend to not like that.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Just forgot somehow about this issue.&lt;br/&gt;
You&apos;re right about static, it&apos;s not clear how and when to initialize it, plus you introduce some public classes we&apos;ll be unable to change/remove later.&lt;br/&gt;
I still have a feeling we should expose a single static method - intern() and hide implementation away, possibly tuning it to be advantageous for &amp;lt;thousands of fields, and degrading to raw String.intern() level if there are more fields.&lt;/p&gt;

&lt;p&gt;I&apos;m going to be away from AC power for three days starting now, so I won&apos;t be able to reply until then.&lt;/p&gt;</comment>
                    <comment id="12718598" author="yseeley@gmail.com" created="Thu, 11 Jun 2009 20:29:53 +0100"  >&lt;p&gt;Latest patch attached with multi-threaded test.&lt;/p&gt;

&lt;p&gt;Some quick performance tests:&lt;br/&gt;
10240 unique strings, 100 threads:  29% faster  (larger than the cache capacity - will lead to evictions)&lt;br/&gt;
100 unique strings, 100 threads: 147% faster&lt;br/&gt;
100 unique strings, 2 threads: 152% faster&lt;/p&gt;

&lt;p&gt;Times were simply the time it took the junit test to run - includes other overhead like random number generation and error checking.&lt;/p&gt;</comment>
                    <comment id="12718650" author="yseeley@gmail.com" created="Thu, 11 Jun 2009 22:52:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;I still have a feeling we should expose a single static method - intern() and hide implementation away&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;While the default should be beneficial for most users, I&apos;d hate to lock away a users ability to either expand or remove the cache. &lt;/p&gt;</comment>
                    <comment id="12720266" author="markrmiller@gmail.com" created="Tue, 16 Jun 2009 18:57:23 +0100"  >&lt;p&gt;I assume we can assign this one to you Yonik?&lt;/p&gt;</comment>
                    <comment id="12720274" author="yseeley@gmail.com" created="Tue, 16 Jun 2009 19:09:37 +0100"  >&lt;p&gt;I&apos;ve held off because of a lack of consensus, but I suppose I can do the old &quot;i&apos;ll commit in a few days&quot; thing.&lt;/p&gt;</comment>
                    <comment id="12720275" author="markrmiller@gmail.com" created="Tue, 16 Jun 2009 19:15:19 +0100"  >&lt;p&gt;Or push to 3.1. I have no preference if it goes in as is, just looking for it to be managed one way or another for 2.9 release.&lt;/p&gt;</comment>
                    <comment id="12720291" author="mikemccand" created="Tue, 16 Jun 2009 19:45:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ve held off because of a lack of consensus&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Silence = consensus!&lt;/p&gt;</comment>
                    <comment id="12723352" author="earwin" created="Wed, 24 Jun 2009 00:13:47 +0100"  >&lt;p&gt;Okay, let&apos;s have an extra class and ability to switch impls. I liked that static method could get inlined (at least its short-path), but that&apos;s not necessary.&lt;/p&gt;

&lt;p&gt;Except I&apos;d like the javadoc demand each impl to be String.intern()-compatible. There&apos;s nothing bad in it, as in any decent impl an unique string will be String.intern()&apos;ed one time at most. And the case when you get an infinite flow of unique strings is degenerate anyway, you have to fix something, not deal with it. On the other hand, we can remove &quot;This should never be changed after other Lucene APIs have been used&quot; clause.&lt;/p&gt;

&lt;p&gt;rewrite &apos;for&apos; as &apos;for (Entry e = first;e != null;e = e.next)&apos; for clarity?&lt;br/&gt;
&apos;Entry[] arr = cache;&apos; - this can be skipped? &apos;cache&apos; is already final and optimizer loves finals. Plus further down the method you use both cache&lt;span class=&quot;error&quot;&gt;&amp;#91;slot&amp;#93;&lt;/span&gt; and arr&lt;span class=&quot;error&quot;&gt;&amp;#91;slot&amp;#93;&lt;/span&gt;. Or am I missing some voodoo?&lt;br/&gt;
If check around &apos;nextToLast = e&apos; can also be removed?&lt;br/&gt;
&apos;public String intern(char[] arr, int offset, int len)&apos; - is this needed?&lt;/p&gt;</comment>
                    <comment id="12731185" author="markrmiller@gmail.com" created="Tue, 14 Jul 2009 23:55:36 +0100"  >&lt;p&gt;looks like this is so close ...&lt;/p&gt;</comment>
                    <comment id="12739628" author="yseeley@gmail.com" created="Wed, 5 Aug 2009 18:20:04 +0100"  >&lt;blockquote&gt;&lt;p&gt;Except I&apos;d like the javadoc demand each impl to be String.intern()-compatible.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If &lt;b&gt;everything&lt;/b&gt; went through the same intern, it wouldn&apos;t matter. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;rewrite &apos;for&apos; as &apos;for (Entry e = first;e != null;e = e.next)&apos; for clarity?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;done.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If check around &apos;nextToLast = e&apos; can also be removed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t see how...&lt;/p&gt;</comment>
                    <comment id="12739649" author="yseeley@gmail.com" created="Wed, 5 Aug 2009 19:05:17 +0100"  >&lt;p&gt;committed.&lt;/p&gt;</comment>
                    <comment id="12739920" author="thetaphi" created="Thu, 6 Aug 2009 07:46:55 +0100"  >&lt;p&gt;I found one real occurrence of intern() in crontrib and a now obsolete discussion in one comment.&lt;/p&gt;

&lt;p&gt;Attached is a simple patch.&lt;/p&gt;

&lt;p&gt;What I currently do not like is that there are still a lot of intern()s in the Javadocs/comments elsewhere, maybe this should also be changed (code refactoring is not able to do that, but a simple grep).&lt;/p&gt;</comment>
                    <comment id="12740638" author="thetaphi" created="Fri, 7 Aug 2009 18:20:37 +0100"  >&lt;p&gt;Committed rev 802095.&lt;/p&gt;</comment>
                    <comment id="12746773" author="noble.paul" created="Mon, 24 Aug 2009 09:46:16 +0100"  >&lt;p&gt;isn&apos;t it possible to make the call to &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; intern(&lt;span class=&quot;code-object&quot;&gt;char&lt;/span&gt;[] arr, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; len) {
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;not create a String? &lt;br/&gt;
currently , if I have a char[] it ends up creating a String (which makes a copy of the char[]) before it does the intern() operation.&lt;/p&gt;</comment>
                    <comment id="12746813" author="noble.paul" created="Mon, 24 Aug 2009 12:05:11 +0100"  >&lt;p&gt;I haven&apos;t quite tested it. But it is an idea as a patch. &lt;/p&gt;</comment>
                    <comment id="12746845" author="yseeley@gmail.com" created="Mon, 24 Aug 2009 13:41:19 +0100"  >&lt;blockquote&gt;
&lt;p&gt;isn&apos;t it possible to make the call to&lt;br/&gt;
public String intern(char[] arr, int offset, int len) {}&lt;br/&gt;
not create a String?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yep - that&apos;s why I added that method (just didn&apos;t get around to implementing it that way).&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12422715">LUCENE-1600</issuekey>
        </issuelink>
                    </outwardlinks>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12398451">LUCENE-1308</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12405877" name="intern.patch" size="30860" author="earwin" created="Sun, 19 Apr 2009 16:22:51 +0100" />
                    <attachment id="12415704" name="LUCENE-1607-contrib.patch" size="2693" author="thetaphi" created="Thu, 6 Aug 2009 07:46:55 +0100" />
                    <attachment id="12417468" name="LUCENE-1607.patch" size="1693" author="noble.paul" created="Mon, 24 Aug 2009 12:05:11 +0100" />
                    <attachment id="12410425" name="LUCENE-1607.patch" size="9859" author="yseeley@gmail.com" created="Thu, 11 Jun 2009 20:29:53 +0100" />
                    <attachment id="12410339" name="LUCENE-1607.patch" size="6213" author="yseeley@gmail.com" created="Wed, 10 Jun 2009 21:33:31 +0100" />
                    <attachment id="12408085" name="LUCENE-1607.patch" size="5403" author="yseeley@gmail.com" created="Thu, 14 May 2009 01:52:54 +0100" />
                    <attachment id="12406926" name="LUCENE-1607.patch" size="5403" author="yseeley@gmail.com" created="Thu, 30 Apr 2009 14:49:41 +0100" />
                    <attachment id="12406869" name="LUCENE-1607.patch" size="5412" author="yseeley@gmail.com" created="Thu, 30 Apr 2009 03:41:11 +0100" />
                    <attachment id="12406820" name="LUCENE-1607.patch" size="37147" author="earwin" created="Wed, 29 Apr 2009 20:30:55 +0100" />
                    <attachment id="12405957" name="LUCENE-1607.patch" size="31818" author="earwin" created="Mon, 20 Apr 2009 21:40:54 +0100" />
                    <attachment id="12405956" name="LUCENE-1607.patch" size="6553" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 21:36:29 +0100" />
                    <attachment id="12405955" name="LUCENE-1607.patch" size="6551" author="yseeley@gmail.com" created="Mon, 20 Apr 2009 21:30:41 +0100" />
                    <attachment id="12405879" name="LUCENE-1607.patch" size="4669" author="yseeley@gmail.com" created="Sun, 19 Apr 2009 19:17:52 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 19 Apr 2009 16:52:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12148</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26121</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>