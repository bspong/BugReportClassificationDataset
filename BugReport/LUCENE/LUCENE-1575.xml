<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:35:41 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1575/LUCENE-1575.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1575] Refactoring Lucene collectors (HitCollector and extensions)</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1575</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This issue is a result of a recent discussion we&apos;ve had on the mailing list. You can read the thread &lt;a href=&quot;http://www.nabble.com/Is-TopDocCollector%27s-collect()-implementation-correct--td22557419.html&quot; class=&quot;external-link&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have agreed to do the following refactoring:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Rename MultiReaderHitCollector to Collector, with the purpose that it will be the base class for all Collector implementations.&lt;/li&gt;
	&lt;li&gt;Deprecate HitCollector in favor of the new Collector.&lt;/li&gt;
	&lt;li&gt;Introduce new methods in IndexSearcher that accept Collector, and deprecate those that accept HitCollector.
	&lt;ul&gt;
		&lt;li&gt;Create a final class HitCollectorWrapper, and use it in the deprecated methods in IndexSearcher, wrapping the given HitCollector.&lt;/li&gt;
		&lt;li&gt;HitCollectorWrapper will be marked deprecated, so we can remove it in 3.0, when we remove HitCollector.&lt;/li&gt;
		&lt;li&gt;It will remove any instanceof checks that currently exist in IndexSearcher code.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Create a new (abstract) TopDocsCollector, which will:
	&lt;ul&gt;
		&lt;li&gt;Leave collect and setNextReader unimplemented.&lt;/li&gt;
		&lt;li&gt;Introduce protected members PriorityQueue and totalHits.&lt;/li&gt;
		&lt;li&gt;Introduce a single protected constructor which accepts a PriorityQueue.&lt;/li&gt;
		&lt;li&gt;Implement topDocs() and getTotalHits() using the PQ and totalHits members. These can be used as-are by extending classes, as well as be overridden.&lt;/li&gt;
		&lt;li&gt;Introduce a new topDocs(start, howMany) method which will be used a convenience method when implementing a search application which allows paging through search results. It will also attempt to improve the memory allocation, by allocating a ScoreDoc[] of the requested size only.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Change TopScoreDocCollector to extend TopDocsCollector, use the topDocs() and getTotalHits() implementations as they are from TopDocsCollector. The class will also be made final.&lt;/li&gt;
	&lt;li&gt;Change TopFieldCollector to extend TopDocsCollector, and make the class final. Also implement topDocs(start, howMany).&lt;/li&gt;
	&lt;li&gt;Change TopFieldDocCollector (deprecated) to extend TopDocsCollector, instead of TopScoreDocCollector. Implement topDocs(start, howMany)&lt;/li&gt;
	&lt;li&gt;Review other places where HitCollector is used, such as in Scorer, deprecate those places and use Collector instead.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Additionally, the following proposal was made w.r.t. decoupling score from collect():&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Change collect to accecpt only a doc Id (unbased).&lt;/li&gt;
	&lt;li&gt;Introduce a setScorer(Scorer) method.&lt;/li&gt;
	&lt;li&gt;If during collect the implementation needs the score, it can call scorer.score().&lt;br/&gt;
If we do this, then we need to review all places in the code where collect(doc, score) is called, and assert whether Scorer can be passed. Also this raises few questions:&lt;/li&gt;
	&lt;li&gt;What if during collect() Scorer is null? (i.e., not set) - is it even possible?&lt;/li&gt;
	&lt;li&gt;I noticed that many (if not all) of the collect() implementations discard the document if its score is not greater than 0. Doesn&apos;t it mean that score is needed in collect() always?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Open issues:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The name for Collector&lt;/li&gt;
	&lt;li&gt;TopDocsCollector was mentioned on the thread as TopResultsCollector, but that was when we thought to call Colletor ResultsColletor. Since we decided (so far) on Collector, I think TopDocsCollector makes sense, because of its TopDocs output.&lt;/li&gt;
	&lt;li&gt;Decoupling score from collect().&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I will post a patch a bit later, as this is expected to be a very large patch. I will split it into 2: (1) code patch (2) test cases (moving to use Collector instead of HitCollector, as well as testing the new topDocs(start, howMany) method.&lt;br/&gt;
There might be even a 3rd patch which handles the setScorer thing in Collector (maybe even a different issue?)&lt;/p&gt;</description>
                <environment></environment>
            <key id="12419661">LUCENE-1575</key>
            <summary>Refactoring Lucene collectors (HitCollector and extensions)</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Fri, 27 Mar 2009 16:44:24 +0000</created>
                <updated>Fri, 25 Sep 2009 17:23:20 +0100</updated>
                    <resolved>Fri, 24 Apr 2009 21:04:27 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12690094" author="mikemccand" created="Fri, 27 Mar 2009 20:43:51 +0000"  >&lt;p&gt;Looks good!  Thanks Shai.  Some responses:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Create a final class HitCollectorWrapper, and use it in the deprecated methods in IndexSearcher, wrapping the given HitCollector.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This turns deprecated HitCollector into a Collector?  Seems like it&lt;br/&gt;
should be package private?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Change TopFieldDocCollector (deprecated) to extend TopDocsCollector, instead of TopScoreDocCollector. Implement topDocs(start, howMany)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is deprecated, so we shouldn&apos;t add topDocs(start, howMany)?  I&lt;br/&gt;
think just switch it back to extending the deprecated TopDocCollector&lt;br/&gt;
(like it does in 2.4)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What if during collect() Scorer is null? (i.e., not set) - is it even possible?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think Lucene should guarantee not to do that?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I noticed that many (if not all) of the collect() implementations discard the document if its score is not greater than 0. Doesn&apos;t it mean that score is needed in collect() always?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmmm good point.  I would love to stop screening for 0 score in the&lt;br/&gt;
core collectors (like Solr).  Maybe we fix the core collectors to not&lt;br/&gt;
screen by zero score, but we add a new &quot;only keep positive scores&quot;&lt;br/&gt;
collector chain/wrapper class that does the filtering and the forwards&lt;br/&gt;
collection to another collector?  This way there&apos;s a migration path if&lt;br/&gt;
somehow users are relying on this.&lt;/p&gt;

&lt;p&gt;And we should note this difference clearly in the javadocs for the new&lt;br/&gt;
hierarchy.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;There might be even a 3rd patch which handles the setScorer thing in Collector (maybe even a different issue?) &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it&apos;s fine if it&apos;s the same issue, though doing it as 2 patches&lt;br/&gt;
is going to make life difficult.  I think a single patch covering&lt;br/&gt;
changes to src/java, and one to src/test is OK, though I&apos;d personally&lt;br/&gt;
prefer just one patch overall.&lt;/p&gt;</comment>
                    <comment id="12693443" author="shaie" created="Sat, 28 Mar 2009 14:17:12 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This turns deprecated HitCollector into a Collector? Seems like it&lt;br/&gt;
should be package private?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Initially I wrote it but then deleted. I decided to make the decision as I create the patch. If this will be used only in IndexSearcher, then it should be a private static final class in IndexSearcher, otherwise a package private one. However, if it turns out we&apos;d want to use it for now in other places too where we deprecate the HitCollector methods, then it will be public.&lt;br/&gt;
Anyway, it will be marked deprecated, and I have the intention to make it as &apos;invisible&apos; as possible.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is deprecated, so we shouldn&apos;t add topDocs(start, howMany)? I&lt;br/&gt;
think just switch it back to extending the deprecated TopDocCollector&lt;br/&gt;
(like it does in 2.4)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good idea.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hmmmm good point. I would love to stop screening for 0 score in the&lt;br/&gt;
core collectors (like Solr). Maybe we fix the core collectors to not&lt;br/&gt;
screen by zero score, but we add a new &quot;only keep positive scores&quot;&lt;br/&gt;
collector chain/wrapper class that does the filtering and the forwards&lt;br/&gt;
collection to another collector? This way there&apos;s a migration path if&lt;br/&gt;
somehow users are relying on this.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I can do that. Create a FilterZeroScoresCollector which wraps a Collector and passes forward only documents with score &amp;gt; 0. BTW, how can a document get a zero score?&lt;/p&gt;

&lt;p&gt;I thought to split patches to code and test since I believe the code patch can be ready sooner for review. The test patch will just fix test cases. If that matters so much, I can create a final patch in the end which contains all the changes for easier commit?&lt;/p&gt;</comment>
                    <comment id="12693448" author="creamyg" created="Sat, 28 Mar 2009 14:51:00 +0000"  >&lt;p&gt;&amp;gt; BTW, how can a document get a zero score?&lt;/p&gt;

&lt;p&gt;Any number of ways, since Query and Scorer are extensible.  How about a RandomScoreQuery that uses floor(rand(1.9))?  Or say that you have a bitset of docs which should match and you use that to feed a scorer.  What score should you assign?  Why not 0?  Why not -1?  Should it matter?&lt;/p&gt;</comment>
                    <comment id="12693462" author="mikemccand" created="Sat, 28 Mar 2009 15:59:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;I thought to split patches to code and test since I believe the code patch can be ready sooner for review. The test patch will just fix test cases. If that matters so much, I can create a final patch in the end which contains all the changes for easier commit?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK that sounds great.  The back-compat tests will also assert nothing broke.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anyway, it will be marked deprecated, and I have the intention to make it as &apos;invisible&apos; as possible.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, how can a document get a zero score?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ve wondered the same thing.  There was this thread recently:&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;http://www.nabble.com/TopDocCollector-td22244245.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/TopDocCollector-td22244245.html&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12693469" author="shaie" created="Sat, 28 Mar 2009 16:30:22 +0000"  >&lt;p&gt;After I posted the question on how can a document get a 0 score, I realized that it&apos;s possible due to extensions of Similarity for example. Thanks Marvin for clearing that up. I guess though that the Lucene core classes will not assign &amp;lt;= 0 score to a document?&lt;/p&gt;

&lt;p&gt;Anyway, whether it&apos;s true or not, I think I agree with Mike saying we should remove this screening from the core collectors. If my application extends Lucene in a way that it can assign &amp;lt;= 0 scores to documents, and it has the intention of screening those documents, it should use the new FilterZeroScoresCollector (maybe call it OnlyPositiveScoresCollector?)&lt;/p&gt;

&lt;p&gt;I don&apos;t think that assigning &amp;lt;= 0 score to a document necessarily means it should be removed from the result set. &lt;/p&gt;

&lt;p&gt;However, Mike (and others) - isn&apos;t there a back-compatibility issue with changing the core collectors to not screen on &amp;lt;=0 score documents? I mean, what if my application relies on that and extended Lucene in a way that it sometimes assigns 0 scores to documents? Now when I&apos;ll switch to 2.9, those documents won&apos;t be filtered. I will be able to use the new FilterZeroScoresCollector, but that&apos;ll require me to change my app&apos;s code.&lt;/p&gt;

&lt;p&gt;Maybe just do it for the new collectors (TopScoreDocCollector and TopFieldCollector)? I need to change my app&apos;s code anyway if I want to use them, so as long as we document this fact in their javadocs, we should be fine?&lt;/p&gt;</comment>
                    <comment id="12693470" author="mikemccand" created="Sat, 28 Mar 2009 17:07:10 +0000"  >
&lt;blockquote&gt;&lt;p&gt;However, Mike (and others) - isn&apos;t there a back-compatibility issue with changing the core collectors to not screen on &amp;lt;=0 score documents? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm right there is, because the search methods will use the new collectors.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I need to change my app&apos;s code anyway if I want to use them, so as long as we document this fact in their javadocs, we should be fine?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually there&apos;s no change to your code required (the search methods should use the new collectors).  So we do have a back-compat difference.&lt;/p&gt;

&lt;p&gt;We could make the change (turn off filtering), but put a setter on IndexSearcher to have it insert the &quot;PositiveScoresOnlyCollector&quot; wrapper?  I think the vast majority of users are not relying on &amp;lt;= 0 scoring docs to be filtered out.&lt;/p&gt;</comment>
                    <comment id="12693474" author="shaie" created="Sat, 28 Mar 2009 18:22:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;We could make the change (turn off filtering), but put a setter on IndexSearcher to have it insert the &quot;PositiveScoresOnlyCollector&quot; wrapper?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Then why do that at all? If I need to call searcher.setKeepOnlyPositiveScores, then it means a change to my code. I could then just pass in the PositiveScoresOnlyCollector to the search methods instead, right?&lt;/p&gt;

&lt;p&gt;I guess you are referring to the methods which don&apos;t take a collector as a parameter and instantiate a new TopScoreDocCollector internally? I tend to think that if someone uses those, it is just because they are simple, and I find it very hard to imagine that that someone relies on the filtering. So perhaps we can get away with just documenting the change in behavior?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think the vast majority of users are not relying on &amp;lt;= 0 scoring docs to be filtered out.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I tend to agree. This has been around for quite some time. I checked my custom collectors, and they do the same check. I only now realize I just followed the code practice I saw in Lucene&apos;s code, never giving it much thought of whether this can actually happen. I believe that if I&apos;d have extended Lucene in a way such that it returns &amp;lt;=0 scores, I&apos;d be aware of that and probably won&apos;t use the built-in collectors. I see no reason to filter &amp;lt;= 0 scored docs anyway, and if I wanted that, I&apos;d probably write my own filtering collector ...&lt;/p&gt;

&lt;p&gt;I think that if we don&apos;t believe people rely on the &amp;lt;= 0 filtering, let&apos;s just document it. I&apos;d hate to add a setter method to IndexSearcher, and a unit test, and check where else it should be added (i.e., in extending searcher classes) and introduce a new API which we might need to deprecate some day ...&lt;br/&gt;
People who&apos;ll need that functionality can move to use the methods that accept a Collector, and pass in the PositiveScoresOnlyCollector. That way we also keep the &apos;fast and easy&apos; search methods really simple, fast and easy.&lt;/p&gt;

&lt;p&gt;Is that acceptable?&lt;/p&gt;</comment>
                    <comment id="12693478" author="mikemccand" created="Sat, 28 Mar 2009 18:49:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;Then why do that at all? If I need to call searcher.setKeepOnlyPositiveScores, then it means a change to my code. I could then just pass in the PositiveScoresOnlyCollector to the search methods instead, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, I agree.  Let&apos;s add an entry to the top of CHANGES.txt that states this &lt;span class=&quot;error&quot;&gt;&amp;#91;minor&amp;#93;&lt;/span&gt; break in back compatibility, as well as the code fragment showing how to use that filter to get back to the pre-2.9 way?&lt;/p&gt;</comment>
                    <comment id="12693513" author="shaie" created="Sun, 29 Mar 2009 04:54:55 +0100"  >&lt;p&gt;Great !&lt;/p&gt;</comment>
                    <comment id="12693524" author="shaie" created="Sun, 29 Mar 2009 07:15:21 +0100"  >&lt;p&gt;BooleanScorer defines an internal package private static final Collector class. Two questions:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;May I change it to BooleanCollector? (the name conflicts with the Collector name we want to give to all base collectors)&lt;/li&gt;
	&lt;li&gt;May I change it to private static final? It is used only in BooleanScorer&apos;s newCollector() method.&lt;br/&gt;
I think the two are safe because it&apos;s already package-private and there&apos;s no other Lucene code which uses it.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;BTW, we might wanna review BooleanScorer&apos;s internal classes visibility. They are all package-private, with some public methods, however used by BooleanScorer only ... But that&apos;s something for a different issue.&lt;/p&gt;</comment>
                    <comment id="12693533" author="mikemccand" created="Sun, 29 Mar 2009 10:31:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;May I change it to BooleanCollector? (the name conflicts with the Collector name we want to give to all base collectors)&lt;/p&gt;&lt;/blockquote&gt;

&lt;blockquote&gt;&lt;p&gt;May I change it to private static final? It is used only in BooleanScorer&apos;s newCollector() method.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think these are fine.&lt;/p&gt;</comment>
                    <comment id="12693729" author="mikemccand" created="Mon, 30 Mar 2009 12:28:53 +0100"  >&lt;p&gt;I think as part of this we should allow TopFieldCollector to NOT get the score of each hit?  EG another boolean to the ctor?&lt;/p&gt;</comment>
                    <comment id="12693732" author="shaie" created="Mon, 30 Mar 2009 12:37:20 +0100"  >&lt;p&gt;I am not sure what you mean - score is used all over the place in collect() as well as other methods. updateBottom for example takes a score, updates bottom.score and then calls adjustTop(). Do you mean that if ignoreScore is true (in ctor), then setScorer should not save the Scorer and not call scorer.score()? If so, what should I do with all the methods that accept score? Create another code path in TopFieldCollector which ignore the score?&lt;/p&gt;

&lt;p&gt;Also, what should the default value be? true (for ignoring scores)?&lt;/p&gt;</comment>
                    <comment id="12693743" author="shaie" created="Mon, 30 Mar 2009 13:06:38 +0100"  >&lt;p&gt;Ok I now understand better where score is used in TopFieldCollector ... It is used in a number of places, two important are:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Maintain maxScore for returning in TopFieldDocs.&lt;/li&gt;
	&lt;li&gt;Passed to FieldComparator.compareBottom which takes a doc and score parameters. There is one comparator RelevanceComparator which makes use of the score passed, however that&apos;s part of the method signature.&lt;/li&gt;
	&lt;li&gt;Passed to FieldComparator.copy - again used by RelevanceComparator only.&lt;/li&gt;
	&lt;li&gt;Passed to updateBottom, which updates the score of the least element in the queue and then calls adjustTop().&lt;/li&gt;
&lt;/ol&gt;


&lt;ul&gt;
	&lt;li&gt;Number 2, 3 and 4 can be resolved by adding a setScorer to FieldComparator (as empty implementation) which TopFieldCollector will call in each collect() call, passing the Scorer that was given to it in its setScorer.&lt;/li&gt;
	&lt;li&gt;Then, we override that in RelevanceComparator, saving the Scorer and using it whenever the score is needed. Of course we&apos;ll need to save the current score, so that we don&apos;t call score() too many times for the same document.&lt;/li&gt;
	&lt;li&gt;This eliminates the need to define on TopFieldCollector whether scores should be saved. The reason is that the Sort parameter may include a SortField.SCORE field, which will invoke the RelevanceComparator.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The question is what to do with maxScore? It is needed for TopDocs / TopFieldDocs. It may also be important to know the maxScore of a query, even if you sort it by something which is not a score.&lt;/p&gt;

&lt;p&gt;Question is - if the steps above make sense, why should we do them at all? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Now the score is computed and passed on to every FieldComparator we received in Sort. Cleaning the method signature means additional code overhead in RelevanceComparator. If we want to compute maxScore as well, it means the score will be computed twice, once in collect() and once in RelevanceComparator.&lt;/p&gt;

&lt;p&gt;We can solve the double score() computation by using an internal ScoreCacheScorer which keeps the score of the current document and returns it whenever score() is called, unless it&apos;s a new document and then it delegates the call to the wrapped Scorer. TopFieldCollector can instantiate it in setScorer.&lt;/p&gt;

&lt;p&gt;But this looks quite a lot for cleaning a method signature, don&apos;t you think? Of course if you can suggest how we somehow remove the maxScore computation, then it might be a good change, since only if SortField.SCORE is used, will the score be computed.&lt;/p&gt;</comment>
                    <comment id="12693778" author="mikemccand" created="Mon, 30 Mar 2009 15:12:43 +0100"  >&lt;blockquote&gt;&lt;p&gt;The question is what to do with maxScore? It is needed for TopDocs / TopFieldDocs. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is why I was thinking you&apos;d have to tell TopFieldCollector whether or not it should track scores.  Furthermore, even if SortField.SCORE is not in your SortFields, an app may still want the scores to be enrolled in the TopFieldDocs, for presentation.&lt;/p&gt;

&lt;p&gt;Turning off scoring in TopFieldCollector&apos;s ctor just means 1) TopFieldCollector won&apos;t track max score, and 2) TopFieldCollector will leave score at 0 in the returned ScoreDoc array.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Number 2, 3 and 4 can be resolved by adding a setScorer to FieldComparator (as empty implementation) which TopFieldCollector will call in each collect() call, passing the Scorer that was given to it in its setScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;It makes sense to push the same improvement (not always passing a score; instead, you ask the scorer for score if you need it) down into the FieldCollector API.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We can solve the double score() computation by using an internal ScoreCacheScorer which keeps the score of the current document and returns it whenever score() is called, unless it&apos;s a new document and then it delegates the call to the wrapped Scorer. TopFieldCollector can instantiate it in setScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12693787" author="shaie" created="Mon, 30 Mar 2009 15:30:34 +0100"  >&lt;blockquote&gt;&lt;p&gt;Turning off scoring in TopFieldCollector&apos;s ctor just means 1) TopFieldCollector won&apos;t track max score, and 2) TopFieldCollector will leave score at 0 in the returned ScoreDoc array.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Just to be clear - TopDocs as well as TopFieldDocs require a maxScore parameter in their ctor. So are you suggesting to pass something like Float.NaN as maxScore if scoring is turned off? Or introducing a new ctor which does not require maxScore, and defaults to Float.NaN? (or both?)&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Furthermore, even if SortField.SCORE is not in your SortFields, an app may still want the scores to be enrolled in the TopFieldDocs, for presentation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right - we should separate between getting score out of the FieldComparator API and tracking scores in TFC. If I don&apos;t have SortField.SCORE in my list of sort fields, then scorer.score() will not be called at all from the FieldComparators layer.&lt;/p&gt;

&lt;p&gt;Tracking scores in TFC is what I&apos;m having troubles with. Turning it off does not necessarily improve anything .. Might be, and might not. In setScorer() I&apos;d still need to register Scorer for passing on to FieldComparator. In collect() I&apos;d still need to check whether score tracking is on, and if so, call scorer.score() and track maxScore. Note that if ScoreCacheScorer is used, then calling scorer.score() in collect does not have too much overhead.&lt;/p&gt;

&lt;p&gt;Also, what will be the default from a Lucene perspective? true - i.e., always keep track of scores?&lt;/p&gt;</comment>
                    <comment id="12693796" author="mikemccand" created="Mon, 30 Mar 2009 16:04:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;Or introducing a new ctor which does not require maxScore, and defaults to Float.NaN?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s a good approach, though for TopDocs the ctor should be package private I think (only called from TopFieldDocs&apos; ctor)?  And the javadocs should clearly spell out that this could happen (so people don&apos;t get scared on seeing Float.NaN coming back).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Turning it off does not necessarily improve anything .. Might be, and might not. In setScorer() I&apos;d still need to register Scorer for passing on to FieldComparator. In collect() I&apos;d still need to check whether score tracking is on, and if so, call scorer.score() and track maxScore. Note that if ScoreCacheScorer is used, then calling scorer.score() in collect does not have too much overhead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is an improvement?  (Scorer.score() will not have been called... that&apos;s the goal here).&lt;/p&gt;

&lt;p&gt;I guess we could also consider making a separate TopFieldCollector (NonScoringTopFieldCollector or some such), instead of sprinkling if statements all over the place.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, what will be the default from a Lucene perspective? true - i.e., always keep track of scores?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good question... we have the freedom to choose.  Perhaps default to off?  But say clearly in the migration javadocs that you have to set that to true to get same behavior as TSDC?&lt;/p&gt;</comment>
                    <comment id="12693812" author="shaie" created="Mon, 30 Mar 2009 16:52:38 +0100"  >&lt;p&gt;ok I&apos;ll add another package-private ctor to TopDocs which does not get maxScore and defaults to NaN, as well as update the javadocs. No back-compat here since the only code that will use it is TFC, which is new.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think this is an improvement? (Scorer.score() will not have been called... that&apos;s the goal here).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well, if we use ScoreCacheScorer, then this call is really fast, returning immediately and w/o computing the score.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I guess we could also consider making a separate TopFieldCollector (NonScoringTopFieldCollector or some such), instead of sprinkling if statements all over the place.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I always like such approaches. How&apos;s that sound:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Create a base NSTFC, which has a protected score member, initialized to 0, and is exactly like the current TFC, only w/o maxScore.&lt;/li&gt;
	&lt;li&gt;Have TFC extend NSTFC, override collect() and:
	&lt;ol&gt;
		&lt;li&gt;Set super.score = scorer.score(). That is required for updateBottom which updates the score on the ScoreDoc in pq.&lt;/li&gt;
		&lt;li&gt;Compute maxScore.&lt;/li&gt;
		&lt;li&gt;Call super.collect().&lt;/li&gt;
		&lt;li&gt;Override topDocs(start, howMany) to provide one with maxScore.&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;Good question... we have the freedom to choose. Perhaps default to off? But say clearly in the migration javadocs that you have to set that to true to get same behavior as TSDC?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So you suggest the methods on IndexSearcher today that take a Sort as parameter will default to NSTFC? As long as we document it it&apos;s ok? Are all of these new?&lt;/p&gt;</comment>
                    <comment id="12693822" author="mikemccand" created="Mon, 30 Mar 2009 17:19:08 +0100"  >&lt;blockquote&gt;&lt;p&gt;How&apos;s that sound:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds good!  So to be consistent maybe we create ScoringTopFieldCollector and NonScoringTopFieldCollector?&lt;/p&gt;

&lt;p&gt;This means we don&apos;t need ScoreCacheScorer?  (because ScoringTopFieldCollector will always grab the score).  Though how do we change FieldComparator API so as to not pass score around?  All comparators except RelevanceComparator don&apos;t use it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Well, if we use ScoreCacheScorer, then this call is really fast, returning immediately and w/o computing the score.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m actually torn on how fast this will be: I think that will be an if statement that&apos;s hard for the CPU to predict, which is costly.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So you suggest the methods on IndexSearcher today that take a Sort as parameter will default to NSTFC? As long as we document it it&apos;s ok? Are all of these new?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm... actually, no, I think those must continue to use NSTFC for the existing methods (to remain back compatible), but add a new search method that takes a boolean trackScore?&lt;/p&gt;</comment>
                    <comment id="12693843" author="shaie" created="Mon, 30 Mar 2009 17:59:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;So to be consistent maybe we create ScoringTopFieldCollector and NonScoringTopFieldCollector?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And have STFC extend NSTFC? I see no reason to create an abstract TopFieldCollector.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This means we don&apos;t need ScoreCacheScorer? (because ScoringTopFieldCollector will always grab the score). Though how do we change FieldComparator API so as to not pass score around? All comparators except RelevanceComparator don&apos;t use it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was actually thinking of that class for RelevanceComparator. So perhaps I can implement the logic inside RelevanceComparator? Although this sounds like a nice utility class, now that we have a setScorer on Collector - others may find it useful too.&lt;br/&gt;
Remember that score-tracking is done for maxScore and ScoreDoc purposes (inside STFC). The score in the FieldComparator API is used only in RelevanceComparator, whether it&apos;s STFC or NSTFC.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think those must continue to use NSTFC for the existing methods (to remain back compatible)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Did you mean continue to use STFC? The current behavior is that scoring is tracked, I think.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;add a new search method that takes a boolean trackScore?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I actually prefer not to expose any more methods. IndexSearcher already has plenty of them. Instead, one can use the very generic, simple and useful method search(Query, Collector) and pass in a NSTFC instance. Otherwise we&apos;ll end up adding many search() methods to IndexSearcher, if we continue with that approach going forward.&lt;/p&gt;</comment>
                    <comment id="12693847" author="mikemccand" created="Mon, 30 Mar 2009 18:16:42 +0100"  >&lt;blockquote&gt;&lt;p&gt;And have STFC extend NSTFC? I see no reason to create an abstract TopFieldCollector.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Although this sounds like a nice utility class, now that we have a setScorer on Collector - others may find it useful too.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK I agree, it would be useful to have for general usage (eg chaining collectors).&lt;/p&gt;

&lt;p&gt;But what is the plan now for the FieldComparator API?  We no longer pass score all around, but expose access to scorer, which only RelevanceComparator (in core) will use?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Did you mean continue to use STFC? The current behavior is that scoring is tracked, I think.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, yes, STFC.  Beginning to lose mind...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I actually prefer not to expose any more methods. IndexSearcher already has plenty of them. Instead, one can use the very generic, simple and useful method search(Query, Collector) and pass in a NSTFC instance. Otherwise we&apos;ll end up adding many search() methods to IndexSearcher, if we continue with that approach going forward.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;d be OK... the only thing that bothers me is I think the natural default when sorting by field is to not gather the score.  Ie I don&apos;t want someone evaluating Lucene in the future to say our field sort is too slow when they didn&apos;t realize they had to go use this advanced API that turns off scoring.&lt;/p&gt;

&lt;p&gt;What if we add a new method, and deprecate the old one?  This way come 3.0 we will not have added any methods, and then when sorting by field you see that you have to choose with or without scores.&lt;/p&gt;</comment>
                    <comment id="12693997" author="shaie" created="Tue, 31 Mar 2009 06:57:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;But what is the plan now for the FieldComparator API? We no longer pass score all around, but expose access to scorer, which only RelevanceComparator (in core) will use?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes. FieldComparator will have a default empty setScorer() method, which will be overridden by RelevanceComparator. In TopFieldCollector (forget the final name now) setScorer() method we set the Scorer on all FieldComparators. During collect(), only RelevanceComparator, if it exists, will compute the score.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What if we add a new method, and deprecate the old one?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The current methods are:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Searchable - search(Weight, Filter, int, Sort)&lt;/li&gt;
	&lt;li&gt;Searcher - search(Query, Filter, int, Sort)&lt;/li&gt;
	&lt;li&gt;IndexSearcher - search(Weight, Filter, int, Sort, boolean /* fillFields */)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Deprecate all three, and add the same but take another boolean as a parameter? I have two comments regarding that:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;The current methods need to call the new ones with trackScores = true since that&apos;s the current behavior.&lt;/li&gt;
	&lt;li&gt;When we are left with only the new versions, I&apos;m afraid those methods will not look &apos;simple fast&apos; to a user - I now have to decide whether I want to track scores or not, something I haven&apos;t given much thought to before. I kind of like the current signature, but I understand your concern regarding defaults.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;BTW, Searchable is an interface, so we cannot add it there. Searcher is an abstract class and we cannot add the method to it with default implementation (as I believe the other search methods will call the new one with default=true). So it only leaves IndexSearcher as an option. But then what if someone uses MultiSearcher? ParallelMultiSearcher? etc.&lt;/p&gt;

&lt;p&gt;Is it possible to deprecate a method, documenting that its runtime behavior will change in 3.0 and then in 3.0 change to not track scores?&lt;/p&gt;

&lt;p&gt;If we&apos;re touching TopFieldCollector in such a way, I&apos;d like to propose the following refactoring. It stems from the current complex implementation in collect() which checks in every collect call if we have just one Comparator or Multi, and we&apos;re talking about having two versions w/ and w/o score tracking:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Keep TopFieldCollector as abstract class with a static create() factory method, and an abstract updateBottom() method. It will still implement topDocs(start, howMany).&lt;/li&gt;
	&lt;li&gt;Have the factory method create one of 4 instances, all extend TFC, but are private internal classes, which do not concern the user:
	&lt;ol&gt;
		&lt;li&gt;OneComparatorNonScoringTopFieldCollector - assumes just one FieldComparator exists as well as scoring should not be tracked.&lt;/li&gt;
		&lt;li&gt;OneComparatorScoringTopFieldCollector - assumes just one FieldComparator exists as well as scoring should be tracked.&lt;/li&gt;
		&lt;li&gt;MultiComparatorNonScoringTopFieldCollector - assumes more than one FieldComparator exists, as well as scoring should not be tracked.&lt;/li&gt;
		&lt;li&gt;MultiComparatorScoringTopFieldCollector - assumes more than one FieldComparator exists, as well as scoring should be tracked.&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The advantages are:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;We simplify the API - the user is only aware of TopFieldCollector, and instead of calling a ctor it calls a static create method, which takes all the arguments as the ctor takes.&lt;/li&gt;
	&lt;li&gt;We are free to create whatever instance is the right and most optimized one given the input parameters. The user does not care how the instance is called. Hence the long names - they are internal anyway.&lt;/li&gt;
	&lt;li&gt;The code is much cleaner and easy to understand. It also does not need to check if we have just one comparator or more in every call to collect.&lt;/li&gt;
	&lt;li&gt;We don&apos;t need to add a protected score to a NonScoring collector (read above about code readability) just because a Scoring one extends it and will make use of it.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Since TopFieldCollector is new, we have the freedom to do it right w/o deprecating anything. I think it&apos;s a much cleaner design. It is orthogonal to the discussion we&apos;re having regarding the search methods and parameters. They will use the create() factory method instead of creating a collector, passing whatever arguments they have. So let&apos;s not confuse the two.&lt;/p&gt;

&lt;p&gt;The patch for this issue is ready. As soon as we agree on how to proceed with TFC, I&apos;ll add the changes and submit the patch.&lt;/p&gt;</comment>
                    <comment id="12694068" author="mikemccand" created="Tue, 31 Mar 2009 12:17:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we&apos;re touching TopFieldCollector in such a way, I&apos;d like to propose the following refactoring&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1.  That looks great.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When we are left with only the new versions, I&apos;m afraid those methods will not look &apos;simple fast&apos; to a user &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, which is why I&apos;d like in 3.0 for the default to be &quot;don&apos;t score when sorting by fields&quot;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is it possible to deprecate a method, documenting that its runtime behavior will change in 3.0 and then in 3.0 change to not track scores?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this may in fact be our best option: don&apos;t deprecate the method, but document that in 3.0 this method will no longer do scoring.  There is a precedent here: in 3.0, IndexReader.open is going to return readOnly readers by default (vs read/write today).  We have also done similar fixes within a minor release, eg fixes to StandardAnalyzer.  I think there are other things we should do (eg, StopFilter should enable position increment by default, which it doesn&apos;t today &amp;#8211; &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1258&quot; title=&quot;Increment position by default in StopFilter &amp;amp; QueryParser -&amp;gt; PhraseQuery&quot;&gt;&lt;del&gt;LUCENE-1258&lt;/del&gt;&lt;/a&gt;).  If we do this approach, on committing this issue you should open a new one w/ fix version 3.0 to switch up the default.&lt;/p&gt;

&lt;p&gt;I think, with 3.0, if we clearly document in CHANGES, as well as on the particular APIs, the changes to Lucene&apos;s defaults, that&apos;s sufficient?&lt;/p&gt;</comment>
                    <comment id="12694074" author="shaie" created="Tue, 31 Mar 2009 12:59:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we do this approach, on committing this issue you should open a new one w/ fix version 3.0 to switch up the default.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok then let&apos;s do that. I&apos;ll add a TODO to these methods that it should be changed in 3.0, and also open another issue. (The TODO is in case I forget to open the issue).&lt;/p&gt;

&lt;p&gt;I&apos;ll also add documentation to the CHANGES file as well as the API.&lt;/p&gt;

&lt;p&gt;Ok, I think the patch should be ready soon then. Just need to complete the refactoring to TopFieldCollector.&lt;/p&gt;</comment>
                    <comment id="12694151" author="shaie" created="Tue, 31 Mar 2009 16:26:20 +0100"  >&lt;p&gt;When I was about to make the changes to FieldComparator (add setScorer and calling scorer.score() when necessary) I noticed that scorer.score() declares it throws IOException, while the FieldComparatro methods don&apos;t. So two ways to handle it:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;catch the IOException and ignore it, assuming a 0 score. This is if we think no Scorer will actually throw an IOException.&lt;/li&gt;
	&lt;li&gt;Change FieldComparator APIs to declare throwing IOE, which will give us flexibility in the future. Since the Lucene code throws IOE in many places, I don&apos;t think it&apos;s a problem.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I&apos;m in favor of (2) (I had to add IOE to Collector.collect() for that reason).&lt;/p&gt;</comment>
                    <comment id="12694155" author="mikemccand" created="Tue, 31 Mar 2009 16:31:03 +0100"  >&lt;p&gt;I like 2 as well.  I find reserving that freedom to be very helpful, while preventing it to be a real hassle later on...&lt;/p&gt;</comment>
                    <comment id="12694426" author="shaie" created="Wed, 1 Apr 2009 09:49:56 +0100"  >&lt;p&gt;Eventually I decided to include just one patch file (instead of code and test) since it was simpler after all. Please be sure to review the following:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Collector class and documentation.&lt;/li&gt;
	&lt;li&gt;New TopDocsCollector class.&lt;/li&gt;
	&lt;li&gt;TopFieldCollector refactoring.&lt;/li&gt;
	&lt;li&gt;Methods deprecation.&lt;/li&gt;
	&lt;li&gt;New TestTopDocsCollector as well as test cases in TestSort.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                    <comment id="12694432" author="thetaphi" created="Wed, 1 Apr 2009 10:09:45 +0100"  >&lt;p&gt;I just wonder, why HitCollectorWrapper implements:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void collect(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc, &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; score) {
    collector.collect(doc + base, score);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is not needed by Collector abstract class and never called.&lt;/p&gt;</comment>
                    <comment id="12694438" author="shaie" created="Wed, 1 Apr 2009 10:15:22 +0100"  >&lt;p&gt;oops &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; leftovers from when it extended MultiReaderHitCollector (now called Collector)&lt;/p&gt;</comment>
                    <comment id="12694439" author="mikemccand" created="Wed, 1 Apr 2009 10:17:19 +0100"  >&lt;p&gt;Shai, it looks like you &quot;svn copy&quot;&apos;d MultiReaderHitCollector.java --&amp;gt; Collector.java?  It causes &quot;patch&quot; to be confused when applying the patch.  The simple workaround is to pre-copy that file yourself, manually, before appying the patch.&lt;/p&gt;</comment>
                    <comment id="12694442" author="thetaphi" created="Wed, 1 Apr 2009 10:25:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;oops  leftovers from when it extended MultiReaderHitCollector (now called Collector)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This is why we really should move to Java 1.5 soon and its @Override annotation...&lt;/p&gt;</comment>
                    <comment id="12694443" author="shaie" created="Wed, 1 Apr 2009 10:27:21 +0100"  >&lt;p&gt;I did not do any &quot;svn copy&quot;, just used Eclipse refactoring to change the name of the class to Collector. I did not understand though from your comment if I should do it differently and post another patch, or is that a hint to how someone can still apply the patch?&lt;/p&gt;</comment>
                    <comment id="12694445" author="thetaphi" created="Wed, 1 Apr 2009 10:34:19 +0100"  >&lt;p&gt;JavaDoc errors:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The Collector javadoc example still contains the score in its collect() method.&lt;/li&gt;
	&lt;li&gt;The javadocs of ParallelMultiSearcher&apos;s new Collector&apos;s 
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void search(Weight weight, Filter filter, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Collector collector)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; has still HitCollector in its JavaDocs.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is what I found out when reading the new generated Javadocs.&lt;/p&gt;</comment>
                    <comment id="12694448" author="shaie" created="Wed, 1 Apr 2009 10:47:02 +0100"  >&lt;p&gt;Thanks Mike. I ran the javadocs task and found other mentions of MultiReaderHitCollector as well as fixed some more javadocs. BTW, the javadoc Ant task outputs many errors on missing files/names, but that something for another issue.&lt;/p&gt;</comment>
                    <comment id="12694452" author="ab" created="Wed, 1 Apr 2009 10:56:08 +0100"  >&lt;p&gt;I&apos;m late to this discussion, so I may have missed something. Is there any provision in the new API for the early termination of hit collection? Currently the (time | count)-limited collectors that are used in Nutch and Solr have to throw RuntimeException to break the loop. It would be much more elegant if the new Collector.collect() had a way to signal the caller that it should stop looping without incurring the cost of throwing an Exception. E.g. by returning a boolean, or setting a flag in the caller.&lt;/p&gt;</comment>
                    <comment id="12694455" author="mikemccand" created="Wed, 1 Apr 2009 11:01:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Thanks Mike.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That was Uwe &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12694456" author="mikemccand" created="Wed, 1 Apr 2009 11:02:08 +0100"  >&lt;p&gt;Looks great!  Thanks Shai.&lt;/p&gt;

&lt;p&gt;My biggest question/issue is how TopDocsCollector now (still?)&lt;br/&gt;
requires that the PQ you give it is sorting primarily by score (eg&lt;br/&gt;
getMaxScore() assumes the max is in the PQ; topDocs() uses&lt;br/&gt;
results&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;&apos;s score when start == 0).  We&apos;ve sort of come full circle&lt;br/&gt;
(a &quot;hidden assumption&quot; that you are sorting by score was what started&lt;br/&gt;
the whole thread in the beginning) &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;We get away with that with TopFieldCollector because that overrides&lt;br/&gt;
all the score-related processing.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure how to cleanly fix this... maybe TopDocsCollector should&lt;br/&gt;
make maxScore() abstract?  Or... it&apos;s as if we need the&lt;br/&gt;
scoring/non-scoring bifurcation up higher (moved out of&lt;br/&gt;
TopFieldCollector to above TopDocsCollector)?&lt;/p&gt;

&lt;p&gt;EG say I provide my own PQ that&apos;s sorting by date (by loading date&lt;br/&gt;
from some external source, say); I may or may not care for score.&lt;/p&gt;

&lt;p&gt;Maybe we make a ScoringWrapperCollector that grabs score in its own&lt;br/&gt;
collect, then calls collect() on its child?&lt;/p&gt;

&lt;p&gt;A few other small things:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In the private final static classes inside TopFieldCollector, you&lt;br/&gt;
    can make the members final too (eg reverseMul, comparator), in&lt;br/&gt;
    case it helps compiler.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Can you add a paragraph @ top of CHANGES stating the pending&lt;br/&gt;
    default swap in 3.0 (ie the same note you added to&lt;br/&gt;
    IndexSearcher.search).  Add a new &quot;Changes in backwards&lt;br/&gt;
    compatibility policy&quot; section at the very top (look at how 2.4.0&lt;br/&gt;
    release did it).  And can you give explicit code fragment showing&lt;br/&gt;
    how to get back to the old way (ie show that you must pass in&lt;br/&gt;
    &quot;true&quot; for trackDocScores).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12694459" author="mikemccand" created="Wed, 1 Apr 2009 11:12:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;It would be much more elegant if the new Collector.collect() had a way to signal the caller that it should stop looping without incurring the cost of throwing an Exception. E.g. by returning a boolean, or setting a flag in the caller.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree: we should work into this new collection API a way to stop early.&lt;/p&gt;

&lt;p&gt;But I&apos;m nervous about the cost of checking a returned boolean on every collect call vs the cost of throwing/catching an exception.  Adding the boolean check slows down every single collect() call (by just a bit, but bits really count here), even those that never use stop early (the majority of apps today).   Throwing an exception adds a clear cost when you actually throw &amp;amp; catch it, but presumably that cost is proportionally tiny because you only throw it on searches that have been running for a long time, anyway.&lt;/p&gt;

&lt;p&gt;We could upgrade the exception to a checked exception; then we&apos;d need to add &quot;throws XXX&quot; to the search methods in 3.0 (perhaps wrapping as RuntimeException until 3.0).  But then I also wonder if the checked exception logic would add instructions in the collect() path.&lt;/p&gt;</comment>
                    <comment id="12694469" author="thetaphi" created="Wed, 1 Apr 2009 12:03:57 +0100"  >&lt;p&gt;I think, a checked Exception to stop collecting would be the best. The &quot;cost&quot; of the exception is very minimal (it is only thrown once in the collector and catched somewhere at top level). So where would be the costly part? Microseconds per search?&lt;/p&gt;</comment>
                    <comment id="12694474" author="shaie" created="Wed, 1 Apr 2009 12:23:15 +0100"  >&lt;p&gt;Sorry  &amp;#8211; thanks Uwe &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;On Wed, Apr 1, 2009 at 1:01 PM, Michael McCandless (JIRA)&lt;/p&gt;
</comment>
                    <comment id="12694483" author="shaie" created="Wed, 1 Apr 2009 12:36:27 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think, a checked Exception to stop collecting would be the best.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I actually think a RuntimeException is better for the following reasons:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The effects of a checked exception added to collect() will not touch IndexSearcher only, but also some Scorer implementations.&lt;/li&gt;
	&lt;li&gt;That only exists in the TimeLimitedCollector, which is not instantiated by Lucene code, but rather by my application code. Therefore, reading its javadocs, I know I should wrap the searcher.search with a try-catch. On the other hand, the rest of the Lucene users will not need to do that since they don&apos;t use it.&lt;/li&gt;
	&lt;li&gt;Going forward, someone may come up with another limiting Collector implementation, for example &quot;I want to stop collecting and searching as soon as I hit 10 documents&quot; - what would we do then - add another checked exception?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My point is - since such Collectors (at least now) are now instantiated by the search application and not by the Lucene code itself, RuntimeException is as good as checked exception, only they don&apos;t require any changes to the methods signature.&lt;/p&gt;</comment>
                    <comment id="12694494" author="shaie" created="Wed, 1 Apr 2009 13:03:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;Maybe we make a ScoringWrapperCollector that grabs score in its own collect, then calls collect() on its child?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How about this:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I remove maxScore() completely from TopDocsCollector.&lt;/li&gt;
	&lt;li&gt;I define newTopDocs to return a TopDocs() w/o a maxScore (like we said, defaulting to Float.NaN). Also change the method signature to receive the start as well as ScoreDoc[] that was collected so far.&lt;/li&gt;
	&lt;li&gt;TopScoreDocCollector will override it, fetching maxScore and returning a TopDocs.
	&lt;ul&gt;
		&lt;li&gt;TopFieldCollector will do the same, but returning TopFieldDocs.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;Can you add a paragraph @ top of CHANGES stating the pending default swap in 3.0&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Done.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In the private final static classes inside TopFieldCollector, you can make the members final too&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Done.&lt;/p&gt;</comment>
                    <comment id="12694496" author="shaie" created="Wed, 1 Apr 2009 13:06:32 +0100"  >&lt;p&gt;Includes the latest comments from Mike.&lt;/p&gt;</comment>
                    <comment id="12694502" author="mikemccand" created="Wed, 1 Apr 2009 13:37:23 +0100"  >&lt;blockquote&gt;&lt;p&gt;How about this:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK that looks good!&lt;/p&gt;

&lt;p&gt;Though we now don&apos;t have a single shared ancestor class that can give&lt;br/&gt;
you a maxScore() when sorting by score or when sorting by fields.  Not&lt;br/&gt;
sure how big a loss that is though...&lt;/p&gt;

&lt;p&gt;More comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Should we implement a default&lt;br/&gt;
    TopDocsCollector.collect/setScorer/setNextReader?  Ie,&lt;br/&gt;
    TopDocsCollector is supposed to be the &quot;you provide the PQ and we&lt;br/&gt;
    do the rest&quot; collector, most closely matching TopDocCollector.&lt;br/&gt;
    Or.... maybe we don&apos;t, because we don&apos;t know if we should compute&lt;br/&gt;
    the score for you, you may want to put something other than&lt;br/&gt;
    ScoreDoc into the queue, etc.  Who knows what your class&lt;br/&gt;
    considers &quot;top&quot;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What happened to OnlyPositiveScoresFilter?  (I don&apos;t see it).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;s a bit of a trap on calling either topDocs method in&lt;br/&gt;
    TopDocsCollector (or its subclasses) that it has popped everything&lt;br/&gt;
    from your PQ as a side-effect.  This is technically a pre-existing&lt;br/&gt;
    issue, but the new bracketed version makes the trap more &quot;trappy&quot;.&lt;br/&gt;
    For example, I can&apos;t call it N times once for each page &amp;#8211; I have&lt;br/&gt;
    to re-run the search to get another page&apos;s worth of results.  Can&lt;br/&gt;
    you update javadocs eg something like &quot;NOTE: you cannot call this&lt;br/&gt;
    method more than once&quot; .&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12694505" author="mikemccand" created="Wed, 1 Apr 2009 13:44:24 +0100"  >&lt;blockquote&gt;&lt;p&gt;I did not understand though from your comment if I should do it differently and post another patch, or is that a hint to how someone can still apply the patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The patch command gets confused because it sees set of diffs against what looks to be a pre-existing Collector.java, but of course I have no Collector.java locally.  &quot;svn diff&quot; did this because it knows you had renamed MRHC --&amp;gt; C.&lt;/p&gt;

&lt;p&gt;I think for now it&apos;s fine if those of us that need to apply the patch simply first copy MultiReaderHitCollector.java --&amp;gt; Collector.java.&lt;/p&gt;

&lt;p&gt;This is yet another example of how &quot;patch&quot; needs to be better integrated with svn: there needs to be a mirror &quot;svn patch&quot; to &quot;svn diff&quot; that&apos;s able to properly carry over all svn changes, perhaps do a 3way merge, etc.&lt;/p&gt;</comment>
                    <comment id="12694519" author="shaie" created="Wed, 1 Apr 2009 14:20:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Though we now don&apos;t have a single shared ancestor class that can give you a maxScore() when sorting by score or when sorting by fields&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think it&apos;s a big issue. We have just two extensions to TopDocsCollector, each tracking maxScore differently. Perhaps later on if more extensions are created, or a demand comes from users, we add a ScoringTopDocsCollector class?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should we implement a default TopDocsCollector.collect/setScorer/setNextReader?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I actually think that TopDocsCollector gives you exactly what I had in mind. When I started it, there was only collect(doc, score) method, and I wanted to have a base class that will implement getTotalHits and topDocs for you, while you only need to provide an implementation to collect(). Now collect has really become setNextReader, setScorer and collect. Meaning, you know what you want to do, TDC just takes care of creating the TopDocs for you, and you can even override topDocs(start, howMany) if you want to return a different TopDocs instance.&lt;/p&gt;

&lt;p&gt;I think now it&apos;s clean and simple.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What happened to OnlyPositiveScoresFilter? (I don&apos;t see it).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well ... you don&apos;t see it because I forgot to implement it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;br/&gt;
Funny thing - all the tests pass without it, meaning all that time, we were filtering &amp;lt;= 0 scored documents, but never really tested it ... I guess if it&apos;s because we never really believed it&apos;ll happen?&lt;/p&gt;

&lt;p&gt;Anyway, I&apos;ll add such a class and a suitable test class (make sure it fails w/o using that wrapper first).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can you update javadocs eg something like &quot;NOTE: you cannot call this method more than once&quot; .&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That has always been the case. Previously if you called topDocs() everything has been popped out of the queue for you. I understand what you say though, since we have the topDocs(start, howMany) API, nothing prevents a user from calling topDocs(0, 10) and topDocs(10, 10), only the second call will fail. However, I don&apos;t really think that&apos;s how people will use it ... and if they do, then perhaps they should just call topDocs() and do whatever they need on these ranges using the TopDocs object?&lt;br/&gt;
I&apos;ll add that to the documentation as well.&lt;/p&gt;</comment>
                    <comment id="12694531" author="shaie" created="Wed, 1 Apr 2009 14:51:35 +0100"  >&lt;p&gt;Adds:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;PositiveScoresOnlyCollector and TestPositiveScoresOnlyCollector.&lt;/li&gt;
	&lt;li&gt;Relevant comments in CHANGES&lt;/li&gt;
	&lt;li&gt;Comments to TopDocsCollector.topDocs(start, howMany) and topDocs(start)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12694595" author="mikemccand" created="Wed, 1 Apr 2009 16:59:03 +0100"  >
&lt;blockquote&gt;&lt;p&gt;Funny thing - all the tests pass without it, meaning all that time, we were filtering &amp;lt;= 0 scored documents, but never really tested it&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmmm!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I actually think that TopDocsCollector gives you exactly what I had in mind.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK let&apos;s keep the current approach.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Perhaps later on if more extensions are created, or a demand comes from users, we add a ScoringTopDocsCollector class?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;p&gt;I think patch looks good &amp;#8211; I don&apos;t have any more comments now.&lt;/p&gt;</comment>
                    <comment id="12694600" author="shaie" created="Wed, 1 Apr 2009 17:07:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think patch looks good - I don&apos;t have any more comments now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Great !&lt;/p&gt;

&lt;p&gt;Will you be committing it (perhaps after we give some more time for people to review it)?&lt;/p&gt;</comment>
                    <comment id="12694603" author="mikemccand" created="Wed, 1 Apr 2009 17:17:40 +0100"  >&lt;blockquote&gt;&lt;p&gt;Will you be committing it (perhaps after we give some more time for people to review it)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes... but let&apos;s let it age some so others can review.  Plus, I find coming back and looking at something again after just a couple of days results in a fresh perspective.&lt;/p&gt;</comment>
                    <comment id="12694608" author="mikemccand" created="Wed, 1 Apr 2009 17:28:47 +0100"  >&lt;p&gt;Shai, some contrib tests fail to compile (still using MultiReaderHitCollector), eg:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
[javac] /lucene/lucene.collector/contrib/miscellaneous/src/test/org/apache/lucene/index/TestFieldNormModifier.java:26: cannot find symbol
[javac] symbol  : class MultiReaderHitCollector
[javac] location: &lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; org.apache.lucene.search
[javac] &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.lucene.search.MultiReaderHitCollector;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12694719" author="shaie" created="Wed, 1 Apr 2009 21:27:14 +0100"  >&lt;p&gt;Perhaps you can help me here - I tried to run the test Ant task and all&lt;br/&gt;
tests passed. Then it got to building contrib&apos;s db and failed on sleepycat&lt;br/&gt;
with a major/minor version 49.0. Does this require Java 1.5? Should I run&lt;br/&gt;
the task with a 1.5 JDK?&lt;br/&gt;
The task stopped at this point with a BUILD FAILED message and did not&lt;br/&gt;
continue to other modules.&lt;/p&gt;

&lt;p&gt;I don&apos;t have the entire contrib in my build path, only a handful of them&lt;br/&gt;
which were not affected by these changes. Anyway, I&apos;ll take a look at it&lt;br/&gt;
tomorrow and submit another patch.&lt;/p&gt;

&lt;p&gt;On Wed, Apr 1, 2009 at 7:29 PM, Michael McCandless (JIRA)&lt;/p&gt;
</comment>
                    <comment id="12694849" author="mikemccand" created="Thu, 2 Apr 2009 01:52:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;Does this require Java 1.5? Should I run the task with a 1.5 JDK?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, likely contrib/db (and others) require 1.5.&lt;/p&gt;

&lt;p&gt;You should be able to just do &quot;ant test-contrib&quot; in the toplevel dir.&lt;/p&gt;</comment>
                    <comment id="12694895" author="shaie" created="Thu, 2 Apr 2009 07:49:05 +0100"  >&lt;p&gt;Fixed TestFieldNormModifier and TestLengthNormModifier.&lt;br/&gt;
All tests pass now (including contrib)&lt;/p&gt;</comment>
                    <comment id="12694919" author="mikemccand" created="Thu, 2 Apr 2009 09:58:39 +0100"  >&lt;p&gt;Could you also run &quot;ant test-tag&quot; (which tests JAR-drop-in back-compatibility)?  EG I&apos;m getting this compilation error:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
[javac] /lucene/src/lucene.collection/tags/lucene_2_4_back_compat_tests_20090320/src/test/org/apache/lucene/search/TestTimeLimitedCollector.java:136: incompatible types
[javac] found   : org.apache.lucene.search.TimeLimitedCollector
[javac] required: org.apache.lucene.search.HitCollector
[javac]     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; res;
[javac]            ^
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12694927" author="shaie" created="Thu, 2 Apr 2009 10:22:55 +0100"  >&lt;p&gt;I thought that ant test runs all tests. Thanks for the education.&lt;/p&gt;

&lt;p&gt;The reason is that TimeLimitedCollector now extends Collector, which does not extend HitCollector. Therefore the method attempts to return an invalid type. I&apos;m not sure how to fix it, because I cannot change the 2.4 test code, since Collector is not there.&lt;/p&gt;

&lt;p&gt;So the only reasonable solution I see here is to:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Change TimeLimitedCollector to extend HitCollector, document that in 3.0 it will change to extend Collector and that in the meantime use HitCollectorWrapper if you want.&lt;/li&gt;
	&lt;li&gt;Comment out all the Collector related methods, including the new ctor, with a TODO to reenstate in 3.0.&lt;/li&gt;
	&lt;li&gt;Fix the TestTimeLimitedCollector wrap it with a HCW as well as using only HitCollector as the wrapped collector.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Other solutions which I don&apos;t like are:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;deprecate TLC and create a new one NewTimeLimitedCollector - I hate the name &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;Have Collector extend HitCollector - I hate to even consider that.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12694938" author="mikemccand" created="Thu, 2 Apr 2009 10:43:36 +0100"  >&lt;blockquote&gt;&lt;p&gt;I thought that ant test runs all tests. Thanks for the education.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Probably, it should.  I&apos;ll raise this on java-dev.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Change TimeLimitedCollector to extend HitCollector, document that in 3.0 it will change to extend Collector and that in the meantime use HitCollectorWrapper if you want.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think I like this solution best (though this is very much a lesser of all evils situation).&lt;/p&gt;

&lt;p&gt;&amp;lt;lament&amp;gt;&lt;br/&gt;
Ahh the contortions we must go through because of Lucene&apos;s success.  Marvin over on Lucy can happily make major changes without batting an eye. The sad reality is that the ongoing growth rate of a thing is inversely proportional to its popularity.&lt;br/&gt;
&amp;lt;/lament&amp;gt;&lt;/p&gt;</comment>
                    <comment id="12694972" author="shaie" created="Thu, 2 Apr 2009 12:54:30 +0100"  >&lt;p&gt;Changes:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;TimeLimitedCollector, TestTimeLimitedCollector and CHANGES.&lt;/li&gt;
	&lt;li&gt;I also fixed a bug in TestTermScorer, which was discovered by the test-tag task, and existed since 1483 and propagated into HitCollectorWrapper as well: docBase was set to -1 by default, relying on setNextReader to be called. However if it&apos;s not called (as in TestTermScorer, or if someone called Scorer.score(Collector)), all document Ids are shifted backwards by 1. The test had a bug which asserted on the unshifted doc Id, and after I fixed the Ids to shift, it failed. Anyway, the test now works correctly, as well as HCW.&lt;/li&gt;
	&lt;li&gt;I checked all other Collector implementations and changed the default base to 0, unless in some test cases, where -1 had a meaning.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;All tests (contrib, core and tags) pass.&lt;/p&gt;</comment>
                    <comment id="12695098" author="mikemccand" created="Thu, 2 Apr 2009 20:15:34 +0100"  >&lt;p&gt;Super, all tests pass for me too...&lt;/p&gt;</comment>
                    <comment id="12695338" author="shaie" created="Fri, 3 Apr 2009 12:24:18 +0100"  >&lt;p&gt;I&apos;ve been thinking about TimeLimitedCollector and the revert to extend HitCollector I had to do in the last patch - the main reason was that I couldn&apos;t find a better name and did not want to deprecate it. But then, I thought that perhaps the current name is not so good, and we can change it? Syntactically, it is not a &apos;limited&apos; collector, but more of a &apos;limiting&apos; collector (I think, not being a native English speaker I may be wrong).&lt;br/&gt;
Alternative names I&apos;ve been thinking about are TimeKeeperCollector, TimeLimitingCollector, TimingOutCollector.&lt;br/&gt;
The advantage is that we deprecate the current one and have a clear back-compat support, instead of changing it in 3.0 to extend Collector. If you agree with any of these names I can create a new class, deprecate the current one, change the tests back to use the new version (and remove all those comments about the changes in 3.0). What do you think?&lt;/p&gt;</comment>
                    <comment id="12695358" author="mikemccand" created="Fri, 3 Apr 2009 13:12:00 +0100"  >&lt;blockquote&gt;&lt;p&gt;If you agree with any of these names I can create a new class, deprecate the current one, change the tests back to use the new version (and remove all those comments about the changes in 3.0). What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this approach.  I like &quot;TimeLimitingCollector&quot;, or maybe &quot;TimeoutCollector&quot;?&lt;/p&gt;</comment>
                    <comment id="12695359" author="mikemccand" created="Fri, 3 Apr 2009 13:13:30 +0100"  >
&lt;p&gt;OK, I attached a new patch with some minor changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Beefed up javadocs in Collector.java; fixed other javadocs&lt;br/&gt;
    warnings.  Tweaked CHANGES.txt.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Renamed PositiveOnlyScoresCollector --&amp;gt;&lt;br/&gt;
    PositiveScoresOnlyCollector&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And also came across these questions/issues:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;TopFieldCollector&apos;s updateBottom &amp;amp; add methods take score, and are&lt;br/&gt;
    passed score from the non-scoring collectors, but shouldn&apos;t?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;TermScorer need not override score(HitCollector hc) (super does&lt;br/&gt;
    the same thing).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The changes to TermScorer make me a bit nervous.  EG, the new&lt;br/&gt;
    InternalScorer: will it hurt performance?  Also this part:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+        &lt;span class=&quot;code-comment&quot;&gt;// Set the Scorer doc and score before calling collect in &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; it will be
&lt;/span&gt;+        &lt;span class=&quot;code-comment&quot;&gt;// used in collect()
&lt;/span&gt;+        s.d = doc;
+        s.score = score;
+        c.collect(doc);                      &lt;span class=&quot;code-comment&quot;&gt;// collect score&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;is spooky: I don&apos;t like how we worry that one may call scorer.doc() (I&lt;br/&gt;
don&apos;t like the ambiguity in the API &amp;#8211; we both pass doc and fear you&lt;br/&gt;
may call scorer.doc()).  Not sure how to resolve it.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Hmm &amp;#8211; we added a new abstract method to&lt;br/&gt;
    src/java/org/apache/lucene/search/Searcher.java (that accepts&lt;br/&gt;
    Collector).  Should that method be concrete (and throw UOE), for&lt;br/&gt;
    back compat?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We&apos;ve also added a method to the &quot;Searchable&quot; interface, which is&lt;br/&gt;
    a break in back-compat.  But my feeling is we should allow this&lt;br/&gt;
    break (but Shai can you add another Note at the top of&lt;br/&gt;
    CHANGES.txt, calling this out?).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12695478" author="shaie" created="Fri, 3 Apr 2009 17:32:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;I like &quot;TimeLimitingCollector&quot;, or maybe &quot;TimeoutCollector&quot;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like TimeLimitingCollector better, as I think the name makes the class more self explanatory.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;TopFieldCollector&apos;s updateBottom &amp;amp; add methods take score, and are passed score from the non-scoring collectors, but shouldn&apos;t?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;At the end of the day, even the non-scoring collectors store a score in ScoreDoc, which is Float.NaN. So they should pass a score. Unlike the scoring ones, they always pass Float.NaN without ever calling scorer.score(). That&apos;s the cleanest way I&apos;ve found I can make the changes to that class, w/o duplicating implementation all over the place. Notice that the scoring versions extend the non-scoring, and just add score computation, which resulted in a very clean implementation.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;TermScorer need not override score(HitCollector hc) (super does the same thing).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The changes to TermScorer make me a bit nervous.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since we pass Sorer to Collector, I thought we cannot really rely on anyone not calling scorer.doc() or getSimilarity ever - it is in the API. Since doc() is abstract, I had to implement it and just thought that retuning the current doc is better than -1 for example. There are some alternatives I see to resolve it:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Create an abstract ScoringOnlyScorer which extends Scorer and implements all methods to throw UOE (also as final), besides score() which it will define abstract. We then define a ScoringOnlyScorerWrapper which takes a Scorer and delegates the score() calls. We use SOSW in places where we can&apos;t extend SOS. Where we can, we just extend it directly and implement score(), like in the InternalScorer case.&lt;/li&gt;
	&lt;li&gt;Create a new class which implements just score() (I&apos;ve yet to come with a good name since Scorer is already taken) and create a wrapper which takes a Scorer and delegates the score() calls to it. Then Collector will use that new class, and we&apos;re sure that only score() can be called.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The last two comments are completely an overlook by my side. I&apos;m not so sure about your proposal though. If we add to Searcher a concrete impl which throws UOE, how would that work in 3.0? How would anyone who extends Searcher know that it has to extend this method? Maybe do it now, and document that in 3.0 it will become abstract again?&lt;br/&gt;
About Searchable, I wonder how many do implement Searchable, rather than extend IndexSearcher. Perhaps instead of making any changes in back-compat and add documentation to CHANGES I&apos;ll just comment out this method with a TODO to re-enstate in 3.0?&lt;/p&gt;</comment>
                    <comment id="12695513" author="mikemccand" created="Fri, 3 Apr 2009 18:38:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;I like TimeLimitingCollector better, as I think the name makes the class more self explanatory.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK let&apos;s go with that!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of the day, even the non-scoring collectors store a score in ScoreDoc, which is Float.NaN. So they should pass a score. Unlike the scoring ones, they always pass Float.NaN without ever calling scorer.score(). That&apos;s the cleanest way I&apos;ve found I can make the changes to that class, w/o duplicating implementation all over the place. Notice that the scoring versions extend the non-scoring, and just add score computation, which resulted in a very clean implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK... let&apos;s stick with this approach for now.  Since the impl is&lt;br/&gt;
locked down (ctor for TopFieldCollector is private) we can freely&lt;br/&gt;
switch up this API in the future without breaking back compat, if we&lt;br/&gt;
want to optimize not passing/copying around the unused score.&lt;/p&gt;

&lt;p&gt;Can&apos;t the scoring collector impls in TopFieldCollector be final?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Since we pass Sorer to Collector, I thought we cannot really rely on anyone not calling scorer.doc() or getSimilarity ever&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe instead make InternalScorer non-static, and then doc() can&lt;br/&gt;
return the doc from the TermScorer instance, instead of having to copy&lt;br/&gt;
&quot;s.d = doc&quot; each time?  score can do a similar thing.&lt;/p&gt;

&lt;p&gt;Actually, hang on: if I&apos;m using a Collector that doesn&apos;t need the&lt;br/&gt;
score, TermScoring is still computing it?  We don&apos;t want that right?&lt;br/&gt;
Can we simply pass &quot;this&quot; to setScorer(...)?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If we add to Searcher a concrete impl which throws UOE, how would that work in 3.0? How would anyone who extends Searcher know that it has to extend this method? Maybe do it now, and document that in 3.0 it will become abstract again?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK let&apos;s do that?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About Searchable, I wonder how many do implement Searchable, rather than extend IndexSearcher. Perhaps instead of making any changes in back-compat and add documentation to CHANGES I&apos;ll just comment out this method with a TODO to re-enstate in 3.0?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;p&gt;Make sure at the end of all of this, you open a new issue, marked as&lt;br/&gt;
fix version 3.0, that has all the &quot;and then on 3.0 we do XYZ&quot;s from&lt;br/&gt;
this.&lt;/p&gt;</comment>
                    <comment id="12695523" author="shaie" created="Fri, 3 Apr 2009 19:25:58 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can&apos;t the scoring collector impls in TopFieldCollector be final?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;They can, but they are private so they cannot be extended anyway. I can do that, but does it really matter?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We don&apos;t want that right? Can we simply pass &quot;this&quot; to setScorer(...)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s what I wanted to do, but then noticed that TermScorer.score() method is a bit different. However, now that I look at it again, I wonder if they are different. The difference is that in score(), it does at the end&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; raw * Similarity.decodeNorm(norms[doc]);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and in score(Collector, int) it does&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt;[] normDecoder = Similarity.getNormDecoder();
...
score *= normDecoder[norms[doc] &amp;amp; 0xFF];
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking in Similarity.decodeNorm, it does exactly what&apos;s done in score(Collector, int). So I guess this code has been duplicated for no good reason? Please validate what I wrote and if you also agree, I can change the entire method (score(Collector, int)) to not compute any score and call c.setScorer(this). That will solve it.&lt;/p&gt;

&lt;p&gt;So are you ok with passing Scorer to Collector, instead of just a class with a single score() method?&lt;/p&gt;

&lt;p&gt;I will open an issue w/ a fix version 3.0 and take care of all those TODOs. Should the issue also get rid of the deprecated methods? Or will we have a general issue in 3.0 that removes all deprecated methods?&lt;/p&gt;</comment>
                    <comment id="12695525" author="shaie" created="Fri, 3 Apr 2009 19:39:37 +0100"  >&lt;p&gt;BTW Mike - I think the accidental changes to Searchable and Searcher could have been easily detected by test-tags if we had classes in the back-compat tag which implemented interfaces / extended abstract classes with empty implementations. These are not really junit tests, but if someone would have changed an interface or abstract class, then attempting to compile the test package against the trunk would fail.&lt;/p&gt;

&lt;p&gt;It is not so relevant now, since the next release is 2.9 following by a 3.0 and back-compat will completely go away in 3.0, but perhaps post 3.0? Also, it will prevent us from making changes to back-compat like we wanted to in this issue, but perhaps it&apos;s good?&lt;/p&gt;</comment>
                    <comment id="12695537" author="mikemccand" created="Fri, 3 Apr 2009 20:01:12 +0100"  >
&lt;p&gt;I ran a &quot;first do no harm&quot; perf test, comparing trunk with this patch:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;query&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;hits&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qps&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qpsnew&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;pctg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3631.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3641.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2916.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2255.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-22.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3251.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2676.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-17.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 208.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 202.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  96.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  84.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-12.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 174.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 115.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-33.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  58.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  56.4&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  44.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  34.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-23.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  49.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  32.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-33.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  12.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -8.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -8.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  0.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -7.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -6.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Looks like:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Sort by relevance got maybe a tad slower (~3%)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Sort by field is now quite a bit slower (23-33% on term query &apos;1&apos;)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This was on a full wikipedia index, with 14 segments, Sun java&lt;br/&gt;
1.6.0_07 on OS X Mac Pro quad core, on Intel X25M 160 GB&lt;br/&gt;
SSD.&lt;/p&gt;

&lt;p&gt;I think we need to iterate some to try to get some performance back.&lt;/p&gt;</comment>
                    <comment id="12695541" author="mikemccand" created="Fri, 3 Apr 2009 20:21:03 +0100"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Can&apos;t the scoring collector impls in TopFieldCollector be final?&lt;/p&gt;

&lt;p&gt;They can, but they are private so they cannot be extended anyway. I can do that, but does it really matter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was thinking in case it eeks performance.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So I guess this code has been duplicated for no good reason?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Duplicated for performance I think.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I can change the entire method (score(Collector, int)) to not compute any score and call c.setScorer(this). That will solve it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should try this?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So are you ok with passing Scorer to Collector, instead of just a class with a single score() method?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good question... I&apos;m not sure.  It would be cleaner to expose only&lt;br/&gt;
score() (and I think we could add methods over time), but then we&apos;ll&lt;br/&gt;
be creating new instance per segment per search which&apos;ll only slow&lt;br/&gt;
things down.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I will open an issue w/ a fix version 3.0 and take care of all those TODOs. Should the issue also get rid of the deprecated methods? Or will we have a general issue in 3.0 that removes all deprecated methods?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You don&apos;t need to enumerate deprecated methods to get rid of &amp;#8211; we&lt;br/&gt;
won&apos;t forget those ones &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; It&apos;s these other &quot;special&quot; tasks that may&lt;br/&gt;
slip through the cracks.&lt;/p&gt;</comment>
                    <comment id="12695543" author="mikemccand" created="Fri, 3 Apr 2009 20:24:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;BTW Mike - I think the accidental changes to Searchable and Searcher could have been easily detected by test-tags if we had classes in the back-compat tag which implemented interfaces / extended abstract classes with empty implementations. These are not really junit tests, but if someone would have changed an interface or abstract class, then attempting to compile the test package against the trunk would fail.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s a great idea!  Every interface/abstract class should&lt;br/&gt;
have a &quot;just compile me&quot; subclass in the tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It is not so relevant now, since the next release is 2.9 following by a 3.0 and back-compat will completely go away in 3.0, but perhaps post 3.0?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is relevant because neither Searchable nor Searcher are deprecated&lt;br/&gt;
(yet)?  Ie during development of 2.9 and of 3.0 we have to ensure we&lt;br/&gt;
don&apos;t break back compat of non-deprecated APIs.&lt;/p&gt;

&lt;p&gt;So maybe fold this in on the next patch iteration?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, it will prevent us from making changes to back-compat like we wanted to in this issue, but perhaps it&apos;s good?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s good, because it&apos;d raise the issue right way vs us catching it or&lt;br/&gt;
not by staring at the code &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12695553" author="jasonrutherglen" created="Fri, 3 Apr 2009 21:02:31 +0100"  >&lt;p&gt;Something related to time limiting collectors we may want to&lt;br/&gt;
solve (maybe not in this patch) is passing the time limiting to&lt;br/&gt;
the sub-scorers. At the hit collector level the sub-scorers of a&lt;br/&gt;
multi clause query could be busy exceeding the time limit before&lt;br/&gt;
returning the first doc hit?&lt;/p&gt;</comment>
                    <comment id="12695575" author="shaie" created="Fri, 3 Apr 2009 21:59:14 +0100"  >

&lt;p&gt;How do I run such a test? Is there an algorithm for that in the benchmark&lt;br/&gt;
package?&lt;/p&gt;

&lt;p&gt;I compared the new TSDC to the trunk&apos;s version and the new code does (&apos;-&apos;&lt;br/&gt;
means a negative change, &apos;+&apos; means a positive change, &apos;|&apos; means&lt;br/&gt;
neither/undetermined):&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;adds one collector.setScorer() call to each query. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/forbidden.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;The scorer.score() call in collect() was just moved from whoever called&lt;br/&gt;
collect() to inside collect(), so I don&apos;t think there&apos;s a difference. (|)&lt;/li&gt;
	&lt;li&gt;Does not check if score &amp;gt; 0.0f in each collect &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;implements the new topDocs() method. Previously, it just implemented&lt;br/&gt;
topDocs() which returned everything. Now, topDocs() calls topDocs(0,&lt;br/&gt;
pq.size()), which verifies parameters and such - since that&apos;s executed once&lt;br/&gt;
at the end of the search, I doubt that it has any effect major effect on the&lt;br/&gt;
results.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;BTW, as I scanned through the code I noticed that previously TSDC returned&lt;br/&gt;
maxScore = Float.NEGATIVE_INFINITY in case there were 0 results to the&lt;br/&gt;
query, and now it returns Float.NaN. I&apos;m not sure however if this breaks&lt;br/&gt;
anything, since maxScore is probably used (if at all) for normalization of&lt;br/&gt;
scores, and in case there are 0 results you don&apos;t really have anything to&lt;br/&gt;
normalize? However I&apos;m not sure ...&lt;/p&gt;

&lt;p&gt;Regarding TopFieldDocs I am quite surprised. I assume the test uses the&lt;br/&gt;
OneComparatorScoringCollector, which means scores are computed:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;It has the same issue as in TSDC regarding topDocs(). So I think it should&lt;br/&gt;
be changed here as well, however I doubt that&apos;s the cause for the&lt;br/&gt;
performance hit.&lt;/li&gt;
	&lt;li&gt;It computes the score and then does super.collect(), which adds a method&lt;br/&gt;
call &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/forbidden.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;It doesn&apos;t check if the score is &amp;gt; 0 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
	&lt;li&gt;It calls comparator.setScorer, which is ignored in all comparators besides&lt;br/&gt;
RelevanceComparator. Not sure if it has any performance effects (|)&lt;br/&gt;
The rest of the code in collect() is exactly the same.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Can it be that super.collect() has such an effect? When I think on the&lt;br/&gt;
results of TSDC (-3%) vs. TFC (-28% on avg.), I think it might be since&lt;br/&gt;
setScorer() is called once before the series of collect() calls, however&lt;br/&gt;
super.collect() is called for every document. Your index is large (&amp;gt;2M&lt;br/&gt;
documents, right?) and I don&apos;t know how many results are for each query, if&lt;br/&gt;
they are in the range of 100Ks, then that could be the explanation.&lt;/p&gt;

&lt;p&gt;Mike - in case it&apos;s faster for you to run it, can you try to run the test&lt;br/&gt;
again with a change in the code which inlines super.collect() into&lt;br/&gt;
OneComparatorScoringCollector and compare the results again? I will run it&lt;br/&gt;
also after you tell me which algorithm you used, but only tomorrow morning,&lt;br/&gt;
so if you get to do it before then, that&apos;d be great.&lt;/p&gt;

&lt;p&gt;I doubt that the change in topDocs() affects the query time that much, since&lt;br/&gt;
it&apos;s called at the end of the search, and doing 4-5 &apos;if&apos; statements is&lt;br/&gt;
really not that expensive (I mean once per the entire search), comparing to&lt;br/&gt;
ScoreDoc[] array allocation, fetching Stored fields from the index etc. So&lt;br/&gt;
I&apos;d hate to implement all 3 topDocs() in each of the TopDocsCollector&lt;br/&gt;
extensions unless it proves to be a problem.&lt;/p&gt;

&lt;p&gt;Shai&lt;/p&gt;

&lt;p&gt;On Fri, Apr 3, 2009 at 10:02 PM, Michael McCandless (JIRA)&lt;br/&gt;
&amp;lt;jira@apache.org&amp;gt;wrote:&lt;/p&gt;
</comment>
                    <comment id="12695595" author="shaie" created="Fri, 3 Apr 2009 22:31:14 +0100"  >&lt;p&gt;BTW, I can change FieldValueHitQueue like I changed TopFieldCollector by&lt;br/&gt;
introducing a factory create() method which will return a&lt;br/&gt;
OneComparaterFieldValueHitQueue and MultiComparatorsFieldValueHitQueue.&lt;br/&gt;
Today, FVHQ.lessThan checks the numComparators in each call, which is&lt;br/&gt;
redundant.&lt;/p&gt;

&lt;p&gt;Also the class isn&apos;t final and I&apos;m not sure if we want to change it.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

</comment>
                    <comment id="12695674" author="shaie" created="Sat, 4 Apr 2009 07:07:27 +0100"  >&lt;p&gt;Mike - about your comments on the new Searcher and Searchable search(Weight, Filter, Collector). I think that best (if not only) option currently is to remove them from the interface (comment out I mean) with a TODO to add in 3.0.&lt;/p&gt;

&lt;p&gt;I tried to just comment out in Searchable, and empty impl in Searcher which throws UOE. However that caused a problem in in MultiSearcher, ParallelMultiSearcher and RemoteSearchable:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;RemoteSearchable impls Searchable - commenting out the new impl method with a TODO for 3.0 will be fine, but&lt;/li&gt;
	&lt;li&gt;MS and PMS accept Searchable in their ctor and use them in search(W, F, C) which they extend from Searcher (they MUST extend it because Searcher&apos;s throws UOE). However they call searchable.search, which accepts just a HC, and we can&apos;t wrap a Collector with a HC.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Previously, MS and PMS implemented the HC version by always wrapping with a MRHC. I think we should just pass in the given HC to the Searchable.search method, and rely on its wrapping by a HCW later on. In 3.0 we&apos;ll delete it entirely and use the Collector implementation.&lt;/p&gt;

&lt;p&gt;Do you see any other way?&lt;/p&gt;</comment>
                    <comment id="12695677" author="shaie" created="Sat, 4 Apr 2009 07:51:14 +0100"  >&lt;p&gt;Oh wait .. I should have tried to implement it before I sent the last email.&lt;/p&gt;

&lt;p&gt;After I tried to implement it, I noticed that commenting out the&lt;br/&gt;
Searcher.search(W, F, C) method creates a chain of compilation errors, since&lt;br/&gt;
all the HC methods now call the Collector one (actually all the search()&lt;br/&gt;
methods call that one eventually). So I&apos;m not sure it&apos;s a good idea to&lt;br/&gt;
comment it out. I thought to comment out all the Collector search methods in&lt;br/&gt;
Searcher, but then it resulted in compilation errors in other places.&lt;/p&gt;

&lt;p&gt;How problematic is this break in back-compat, given it will be documented in&lt;br/&gt;
CHANGES?&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Have search(W, F, C) on Searchable? I don&apos;t think it will have such a&lt;br/&gt;
great impact as I don&apos;t believe too many actually implement Searchable.&lt;/li&gt;
	&lt;li&gt;Have search(W, F, C) on Searcher as abstract? I know you offered, Mike, to&lt;br/&gt;
create an empty impl which throws UOE, but I&apos;m not sure what&apos;s worse: having&lt;br/&gt;
a compilation error or UOE at runtime (which can happen at the customer&apos;s).&lt;br/&gt;
After all, all the search methods call this one eventually, and if you did&lt;br/&gt;
extend Searcher (rather than IndexSearcher), you&apos;ll get UOE on every search.&lt;/li&gt;
&lt;/ul&gt;


</comment>
                    <comment id="12695697" author="mikemccand" created="Sat, 4 Apr 2009 10:40:58 +0100"  >&lt;p&gt;I&apos;m attaching the Python scripts I use to run the tests.  You also need this small mod:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(revision 761709)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(working copy)
@@ -63,6 +63,9 @@
     &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(runData);
   }
 
+  &lt;span class=&quot;code-comment&quot;&gt;// nocommit
&lt;/span&gt;+  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; first = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
+
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doLogic() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
     &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; res = 0;
     &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; closeReader = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
@@ -101,6 +104,11 @@
         } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
           hits = searcher.search(q, numHits);
         }
+        &lt;span class=&quot;code-comment&quot;&gt;// nocommit
&lt;/span&gt;+        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (first) {
+          &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;NUMHITS=&quot;&lt;/span&gt; + hits.totalHits);
+          first = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
+        }
         &lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;q=&quot;&lt;/span&gt; + q + &lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt; + hits.totalHits + &lt;span class=&quot;code-quote&quot;&gt;&quot; total hits&quot;&lt;/span&gt;); 
&lt;/span&gt; 
         &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (withTraverse()) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;All the python scripts do is write an alg, run it, gather the results, and collate in the end.  You run sortBench5.py once on trunk and once in a checkout with this patch, each time in the contrib/benchmark directory.  It saves a pickle file (results.pk) which sortCollate5.py then loads (you&apos;ll have to edit the hardwired paths in sortCollate5.py).&lt;/p&gt;</comment>
                    <comment id="12695699" author="mikemccand" created="Sat, 4 Apr 2009 10:49:15 +0100"  >&lt;blockquote&gt;&lt;p&gt;adds one collector.setScorer() call to each query. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, it&apos;s one setScorer() call per segment (my index had 14&lt;br/&gt;
segments).  But I can&apos;t imagine this slows things down.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The scorer.score() call in collect() was just moved from whoever called collect() to inside collect(), so I don&apos;t think there&apos;s a difference. (|)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would think so, though, maybe the compiler can no longer inline the&lt;br/&gt;
call.  We may need to peek at the asm.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Does not check if score &amp;gt; 0.0f in each collect implements the new topDocs() method.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, should be a speedup.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Previously, it just implemented topDocs() which returned everything. Now, topDocs() calls topDocs(0,&lt;br/&gt;
pq.size()), which verifies parameters and such - since that&apos;s executed once&lt;br/&gt;
at the end of the search, I doubt that it has any effect major effect on the&lt;br/&gt;
results.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;BTW, as I scanned through the code I noticed that previously TSDC returned&lt;br/&gt;
maxScore = Float.NEGATIVE_INFINITY in case there were 0 results to the&lt;br/&gt;
query, and now it returns Float.NaN. I&apos;m not sure however if this breaks&lt;br/&gt;
anything, since maxScore is probably used (if at all) for normalization of&lt;br/&gt;
scores, and in case there are 0 results you don&apos;t really have anything to&lt;br/&gt;
normalize? However I&apos;m not sure ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm good question.  Float.NAN seems more correct, so let&apos;s stick with&lt;br/&gt;
that?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regarding TopFieldDocs I am quite surprised. I assume the test uses the&lt;br/&gt;
OneComparatorScoringCollector, which means scores are computed:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, and we need to test multiple field sorting too. 	&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It has the same issue as in TSDC regarding topDocs(). So I think it should&lt;br/&gt;
be changed here as well, however I doubt that&apos;s the cause for the&lt;br/&gt;
performance hit.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What should be changed here?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It computes the score and then does super.collect(), which adds a method call &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It doesn&apos;t check if the score is &amp;gt; 0 &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Should be faster.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It calls comparator.setScorer, which is ignored in all comparators besides RelevanceComparator. Not sure if it has any performance effects (|)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Shouldn&apos;t have an effect.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The rest of the code in collect() is exactly the same.&lt;br/&gt;
Can it be that super.collect() has such an effect? When I think on the&lt;br/&gt;
results of TSDC (-3%) vs. TFC (-28% on avg.), I think it might be since&lt;br/&gt;
setScorer() is called once before the series of collect() calls, however&lt;br/&gt;
super.collect() is called for every document. Your index is large (&amp;gt;2M&lt;br/&gt;
documents, right?) and I don&apos;t know how many results are for each query, if&lt;br/&gt;
they are in the range of 100Ks, then that could be the explanation.&lt;/p&gt;&lt;/blockquote&gt; 

&lt;p&gt;The table shows number of hits per query &amp;#8211; query &quot;1&quot; is large.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mike - in case it&apos;s faster for you to run it, can you try to run the test&lt;br/&gt;
again with a change in the code which inlines super.collect() into&lt;br/&gt;
OneComparatorScoringCollector and compare the results again? I will run it&lt;br/&gt;
also after you tell me which algorithm you used, but only tomorrow morning,&lt;br/&gt;
so if you get to do it before then, that&apos;d be great.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll test this.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I doubt that the change in topDocs() affects the query time that much, since&lt;br/&gt;
it&apos;s called at the end of the search, and doing 4-5 &apos;if&apos; statements is&lt;br/&gt;
really not that expensive (I mean once per the entire search), comparing to&lt;br/&gt;
ScoreDoc[] array allocation, fetching Stored fields from the index etc. So&lt;br/&gt;
I&apos;d hate to implement all 3 topDocs() in each of the TopDocsCollector&lt;br/&gt;
extensions unless it proves to be a problem.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I also cannot imagine this is a problem.  It&apos;s the slowdown of big&lt;br/&gt;
searches that spooks me (it&apos;s fine if fast searches pick up some added&lt;br/&gt;
cost).&lt;/p&gt;</comment>
                    <comment id="12695700" author="mikemccand" created="Sat, 4 Apr 2009 10:51:50 +0100"  >&lt;blockquote&gt;
&lt;p&gt;BTW, I can change FieldValueHitQueue like I changed TopFieldCollector by&lt;br/&gt;
introducing a factory create() method which will return a&lt;br/&gt;
OneComparaterFieldValueHitQueue and MultiComparatorsFieldValueHitQueue.&lt;/p&gt;

&lt;p&gt;Today, FVHQ.lessThan checks the numComparators in each call, which is&lt;br/&gt;
redundant.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Seems good, unless the extra subclassing (and additions of super.XXX()) is somehow cause our performance loss.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also the class isn&apos;t final and I&apos;m not sure if we want to change it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes let&apos;s make it final.  We need to eek...&lt;/p&gt;</comment>
                    <comment id="12695701" author="mikemccand" created="Sat, 4 Apr 2009 10:54:26 +0100"  >&lt;blockquote&gt;
&lt;p&gt;How problematic is this break in back-compat, given it will be documented in&lt;br/&gt;
CHANGES?&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Have search(W, F, C) on Searchable? I don&apos;t think it will have such a&lt;br/&gt;
great impact as I don&apos;t believe too many actually implement Searchable.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Have search(W, F, C) on Searcher as abstract? I know you offered, Mike, to&lt;br/&gt;
create an empty impl which throws UOE, but I&apos;m not sure what&apos;s worse: having&lt;br/&gt;
a compilation error or UOE at runtime (which can happen at the customer&apos;s).&lt;br/&gt;
After all, all the search methods call this one eventually, and if you did&lt;br/&gt;
extend Searcher (rather than IndexSearcher), you&apos;ll get UOE on every search.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;OK let&apos;s add both and call it out in CHANGES.txt?&lt;/p&gt;</comment>
                    <comment id="12695711" author="shaie" created="Sat, 4 Apr 2009 12:39:17 +0100"  >&lt;p&gt;There are no super.XXX calls. The two FVHQ implementations just implement&lt;br/&gt;
lessThan according to whether it&apos;s a single comparator or muli case. This&lt;br/&gt;
removes the check of numComparators == 1.&lt;/p&gt;


&lt;p&gt;On Sat, Apr 4, 2009 at 12:53 PM, Michael McCandless (JIRA)&lt;/p&gt;
</comment>
                    <comment id="12695723" author="shaie" created="Sat, 4 Apr 2009 12:53:54 +0100"  >&lt;blockquote&gt;&lt;p&gt;OK let&apos;s add both and call it out in CHANGES.txt?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;great. so I leave them as they are in the latest patch and add a note to CHANGES.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Yes let&apos;s make it final. We need to eek...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This isn&apos;t necessary after all, since the class is now abstract, with a private ctor and two private final internal classes, which will be the concrete objects returned by create().&lt;/p&gt;

&lt;p&gt;Before submitting the next patch version, I&apos;d like to verify if super.collect() in TFC is the cause of the perf. degradation. We should also perf. test sorting w/o score tracking and note if there is any improvement over trunk. I&apos;m downloading the latest enwiki xml (20090306), so I hope that sometime tomorrow it will finish the download, extract, indexing and search tests.&lt;/p&gt;</comment>
                    <comment id="12695743" author="mikemccand" created="Sat, 4 Apr 2009 14:55:46 +0100"  >&lt;blockquote&gt;
&lt;p&gt;There are no super.XXX calls. The two FVHQ implementations just implement&lt;br/&gt;
lessThan according to whether it&apos;s a single comparator or muli case. This&lt;br/&gt;
removes the check of numComparators == 1.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Excellent!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Before submitting the next patch version, I&apos;d like to verify if super.collect() in TFC is the cause of the perf. degradation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll run this &amp;amp; post back.&lt;/p&gt;</comment>
                    <comment id="12695745" author="mikemccand" created="Sat, 4 Apr 2009 15:35:03 +0100"  >
&lt;p&gt;Odd &amp;#8211; inlining super.collect into OCSC, and making OCSC final, did not alter the numbers much (I re-ran trunk baseline to confirm its close to prior trunk baseline):&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;query&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;hits&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qps&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qpsnew&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;pctg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3635.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3650.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  0.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2915.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2297.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-21.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3265.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2665.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-18.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 208.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 202.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  97.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  85.4&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-12.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 174.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 125.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-28.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  58.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  56.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  44.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  34.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-22.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  49.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  35.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-28.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  12.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -8.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -8.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -0.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -7.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -6.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</comment>
                    <comment id="12695746" author="mikemccand" created="Sat, 4 Apr 2009 15:38:02 +0100"  >&lt;blockquote&gt;&lt;p&gt;We should also perf. test sorting w/o score tracking and note if there is any improvement over trunk.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Let&apos;s wait a bit until we sort things out (eg, w/ current patch, TermScorer will still compute its score even if I don&apos;t need it).&lt;/p&gt;</comment>
                    <comment id="12695750" author="mikemccand" created="Sat, 4 Apr 2009 15:57:10 +0100"  >&lt;p&gt;Shai can you post your latest patch, where TermScorer itself is passed down to the collector?&lt;/p&gt;</comment>
                    <comment id="12695767" author="shaie" created="Sat, 4 Apr 2009 18:29:36 +0100"  >&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Changed TermScorer.score() method to not call Similarity.decodeNorm. If we can change Scorer.similarity to be protected, we can give up getSimilarity() call in score(). Also changed TermScorer.score(Collector) to set &apos;this&apos; as the collector&apos;s scorer.&lt;/li&gt;
	&lt;li&gt;Deprecated TimeLimitedCollector, created new TimeLimitingCollector, renamed TestTimeLimitedCollector to TestTimeLimitingCollector and used the new TimeLimitingCollector.&lt;/li&gt;
	&lt;li&gt;Changed FVHQ to have a static create which returns One/MultiComparatorFieldValueHitQueue version.&lt;/li&gt;
	&lt;li&gt;Changed TopFieldCollector setNextReader versions to not call pq.size() but rather use numHits.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12695782" author="mikemccand" created="Sat, 4 Apr 2009 20:24:33 +0100"  >&lt;p&gt;OK thanks.  Numbers w/ new patch:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;query&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;hits&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qps&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qpsnew&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;pctg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3635.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3704.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  1.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2915.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2262.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-22.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3265.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2655.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-18.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 208.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 199.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -4.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  97.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  87.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-10.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 174.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 134.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-22.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  58.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  56.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  44.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  35.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-20.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  49.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  38.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-22.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -2.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  12.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -7.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  11.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -8.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;score&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.4&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -1.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -7.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; -6.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</comment>
                    <comment id="12695784" author="mikemccand" created="Sat, 4 Apr 2009 20:48:24 +0100"  >&lt;p&gt;Attached patch; only differences are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Under contrib/benchmark I made changes so you can specify non-scoring field sorting&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed the rename of TestTimeLimitedCollector --&amp;gt; Limiting to be patch-friendly&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;OK I ran performance with score tracking disabled during field sorted search:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;query&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;sort&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;hits&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qps&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;qpsnew&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;pctg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2915.7&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;4043.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 38.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;147&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;   6953&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3265.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;4840.1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 48.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  97.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 128.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 32.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;text&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 157101&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 174.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 273.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 56.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  44.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  60.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 35.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 565452&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  49.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  75.3&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 53.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  12.6&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 17.5%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 OR 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 784928&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  13.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 16.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;title&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  14.8&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  17.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 20.9%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1 AND 2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;doc&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 333153&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  15.2&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  18.9&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 24.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Very nice speedups!  We just have to figure out why the score-tracking variant got slower...&lt;/p&gt;</comment>
                    <comment id="12695853" author="shaie" created="Sun, 5 Apr 2009 13:44:10 +0100"  >&lt;p&gt;Mike - I&apos;ve been trying to see this performance hit, without indexing the full wikipedia content, but failed. What I did is:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create an index with 10M documents with one term (all with the same term). The index had 51 segments (I deliberately aimed at a high number).&lt;/li&gt;
	&lt;li&gt;Run a sort-by-doc (in reverse order so that collect() will actually do some work) search using TermQuery (so that TermScorer will be used).&lt;/li&gt;
	&lt;li&gt;Measure the avg. time of 20 query executions (I deliberately omit the first execution because I&apos;ve noticed that the first run sometimes take much longer, even after I kill the JVM. I guess it has to do with OS caches).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The time I measure between the trunk and the current version are very much comparable:&lt;br/&gt;
trunk-patched: (1) 1248.45 ms (2) 1255.45 ms&lt;br/&gt;
trunk-orig: (1) 1314.1 ms (2) 1265.65 ms&lt;br/&gt;
In both runs the patched trunk ran faster. Both did not have any large differences.&lt;/p&gt;

&lt;p&gt;Here&apos;s the code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

		File indexDir = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; File(args[0]);
		Directory dir = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FSDirectory(indexDir, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NativeFSLockFactory(indexDir));
		
		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!indexDir.exists() || indexDir.list().length == 0) {
			&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numDocs = 10000000;
			IndexWriter writer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(dir, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, MaxFieldLength.UNLIMITED);
			writer.setMergeFactor(50);
			writer.setMaxBufferedDocs(numDocs/100);
			&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;populating index&quot;&lt;/span&gt;);
			&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; time = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
			&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; numDocs; i++) {
				Document doc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Document();
				doc.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(&lt;span class=&quot;code-quote&quot;&gt;&quot;c&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;, Store.NO, Index.NOT_ANALYZED));
				writer.addDocument(doc);
			}
			writer.close(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
			&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;time=&quot;&lt;/span&gt; + (&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() - time));
		}
		
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;searching&quot;&lt;/span&gt;);
		IndexSearcher searcher = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(dir);
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;numSegments=&quot;&lt;/span&gt; + searcher.getIndexReader().getSequentialSubReaders().length);
		Sort sort = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Sort(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SortField(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, SortField.DOC, &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;));
		searcher.search(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TermQuery(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;code-quote&quot;&gt;&quot;c&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;)), &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, 10, sort);
		&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; time = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; numQueries = 20;
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; numQueries; i++) {
			searcher.search(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TermQuery(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;code-quote&quot;&gt;&quot;c&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;)), &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, 10, sort);
		}
		time = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() - time;
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;avg. time=&quot;&lt;/span&gt; + (time / numQueries) + &lt;span class=&quot;code-quote&quot;&gt;&quot; ms&quot;&lt;/span&gt;);
		searcher.close();
	}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Can you try running this code on your machine?&lt;/p&gt;</comment>
                    <comment id="12695868" author="mikemccand" created="Sun, 5 Apr 2009 17:04:59 +0100"  >&lt;p&gt;OK I ran it like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java -Xms1024M -Xmx1024M -Xbatch -server -cp build/classes/java:../lucene.collection PerfTest /lucene/fake
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Across these OS/JRE versions:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;OS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;JRE&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;%tg change&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Linux&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1075 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1120 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-4.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Linux&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_08&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1156 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1199 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-3.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;OS X&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_07 (64bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;774 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;823 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-6.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;OS X&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_16&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;987 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;936 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;5.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Win Svr 2003 (64bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_11 (64bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1209 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1308 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-8.2%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Win Svr 2003 (64bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_14 (64bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1559 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1564 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Shai which OS/JRE did you run on?&lt;/p&gt;

&lt;p&gt;Except for the JRE 1.5 cases on OS X and Win Svr 2003, things seem&lt;br/&gt;
generally slower with the patch, though I think the test is a little&lt;br/&gt;
too synthetic (sorting by doc reversed is far worse than a &quot;normal&quot;&lt;br/&gt;
fielded sort where I think the queue would typically fairly quickly&lt;br/&gt;
&quot;converge&quot;).  Also, I think it&apos;s better to take min rather than avg&lt;br/&gt;
across all the runs.&lt;/p&gt;</comment>
                    <comment id="12695876" author="shaie" created="Sun, 5 Apr 2009 18:21:56 +0100"  >&lt;blockquote&gt;&lt;p&gt;Shai which OS/JRE did you run on?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Windows XP, 1.5 (32 bit)&lt;/p&gt;

&lt;p&gt;I chose the sort by doc since I was very curious as to the major drop in performance your queries show. When you sort by doc, the queue converges exactly after 10 documents (assuming you ask for 10 results). After that, every document that&apos;s collected fails at the comparator level (first line in the &quot;if (queueFull)&quot; code) and the collector literally does nothing. So all that&apos;s left are the calls to scorer.score().&lt;br/&gt;
I chose to sort by docs reversed so that every call will actually do something.&lt;br/&gt;
I measured scorer.score() calls in OCSC and they were insignificant (~14 ms total on a single query run).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also, I think it&apos;s better to take min rather than avg across all the runs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t know. Some runs showed 112 ms and some 256 ms ... Taking the minimum just measures &quot;when the OS cache is fully optimized for your run&quot; case, that&apos;s why I prefer to take avg. Anyway, I don&apos;t think it matters since we&apos;re taking the same for both runs.&lt;/p&gt;

&lt;p&gt;I reviewed the code in TopFieldCollector and it&apos;s almost identical to before the patch, besides I differences I noted above, which don&apos;t seem like to have an effect. That&apos;s why I wanted to have a synthetic test, which we know exactly what it&apos;ll do.&lt;/p&gt;

&lt;p&gt;BTW, this test shows far smaller drop in performance comparing to your previous sort-by-doc runs, and it does collect ~x20 times more documents ...&lt;/p&gt;</comment>
                    <comment id="12695892" author="mikemccand" created="Sun, 5 Apr 2009 20:26:56 +0100"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Shai which OS/JRE did you run on?&lt;/p&gt;

&lt;p&gt;Windows XP, 1.5 (32 bit)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Did you run with -server, -Xbatch, -Xms/-Xmx set to same value, etc?&lt;br/&gt;
The goal is to minimize any source of noise in the measurement.&lt;/p&gt;

&lt;p&gt;I also got mixed results on 1.5...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I chose the sort by doc since I was very curious as to the major drop in performance your queries show. When you sort by doc, the queue converges exactly after 10 documents (assuming you ask for 10 results). After that, every document that&apos;s collected fails at the comparator level (first line in the &quot;if (queueFull)&quot; code) and the collector literally does nothing. So all that&apos;s left are the calls to scorer.score().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, I think sort by doc is overly easy, but sort by doc reversed&lt;br/&gt;
is overly hard.  I think sort by title &amp;amp; docdate (in wikipedia) are&lt;br/&gt;
reasonable.  Let&apos;s just leave doc entirely out of future wikipedia&lt;br/&gt;
tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I measured scorer.score() calls in OCSC and they were insignificant (~14 ms total on a single query run).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s very odd, because I see big speedups when we don&apos;t score.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Also, I think it&apos;s better to take min rather than avg across all the runs.&lt;/p&gt;

&lt;p&gt;I don&apos;t know. Some runs showed 112 ms and some 256 ms ... Taking the minimum just measures &quot;when the OS cache is fully optimized for your run&quot; case, that&apos;s why I prefer to take avg. Anyway, I don&apos;t think it matters since we&apos;re taking the same for both runs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you really had such wide variance on your runs (I didn&apos;t), it&apos;s&lt;br/&gt;
even more important to use min not avg.  It means there&apos;s alot of&lt;br/&gt;
noise in your measurement.&lt;/p&gt;

&lt;p&gt;For this test we do want full OS caching, no page misses, no daemon&lt;br/&gt;
that wakes up a steals a few cycles, etc.  This is why min, across&lt;br/&gt;
many iterations, is good: it makes the numbers less noisy and more&lt;br/&gt;
comparable.  A random unlucky outlier won&apos;t increase the time.&lt;/p&gt;

&lt;p&gt;True, min is not a good way to measure what you&apos;ll typically see when&lt;br/&gt;
running such searches in your app (the real world has lots of noise),&lt;br/&gt;
but that&apos;s not what we&apos;re after here.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I reviewed the code in TopFieldCollector and it&apos;s almost identical to before the patch, besides I differences I noted above, which don&apos;t seem like to have an effect. That&apos;s why I wanted to have a synthetic test, which we know exactly what it&apos;ll do.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think it may be the switch to an abstract Scorer &amp;#8211; the JIT can no&lt;br/&gt;
longer inline that code (maybe).&lt;/p&gt;

&lt;p&gt;Or maybe it&apos;s the switch to subclassing-not-if for the 4 impls of&lt;br/&gt;
TopFieldCollector?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, this test shows far smaller drop in performance comparing to your previous sort-by-doc runs, and it does collect ~x20 times more documents ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah but we changed alot of things.  I think sort by title, docdate&lt;br/&gt;
are more realistic tests.  It is nice that your test is ~20X&lt;br/&gt;
larger... I wish we had a real standard dataset that large, and real&lt;br/&gt;
queries instead of the few specific ones we are testing, would be&lt;br/&gt;
better.&lt;/p&gt;
</comment>
                    <comment id="12695895" author="mikemccand" created="Sun, 5 Apr 2009 20:30:38 +0100"  >&lt;p&gt;OK I modified your test (attached):&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Make a random int field and sort on that&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Switch to System.nanoTime to measure time&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Print min time in addition to avg&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Gather silly sum just to make sure JRE can&apos;t optimize away things&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Here are the results:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;OS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;JRE&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;%tg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;OS X&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_16&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;389&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;334&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;14.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;OS X&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_07 (64 bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;312&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;430&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-27.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Linux&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_08&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;403&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;337&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;16.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Linux&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_10&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;337&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;303&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;10.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Win Svr 2003 (64 bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.5.0_14 (64 bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;535&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;727&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-36.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Win Svr 2003 (64 bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.6.0_11 (64 bit)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;477&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;682&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-43.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;Now I&apos;m even more baffled.  The Win Svr 2003 times became especially&lt;br/&gt;
awful... in fact it&apos;s as if 64-bit JREs don&apos;t like this change.&lt;/p&gt;

&lt;p&gt;Or we may simply be chasing Java ghosts at this point... though these&lt;br/&gt;
are awfully big ghosts.&lt;/p&gt;</comment>
                    <comment id="12695954" author="markrmiller@gmail.com" created="Mon, 6 Apr 2009 03:10:16 +0100"  >&lt;p&gt;Gave the bench a try here on 64-bit linux with open-jdk 6 and sun-java 5.&lt;/p&gt;

&lt;p&gt;I did one throw away run with the new patch version, and then recorded the times for both - got 30% drop with the new patch.&lt;/p&gt;

&lt;p&gt;Reran both many times after and got approx the same times for both every attempt, using both JRE&apos;s mentioned above.&lt;/p&gt;

&lt;p&gt;Dunno know what that implies, but another data point.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12695957" author="shaie" created="Mon, 6 Apr 2009 03:42:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;Reran both many times after and got approx the same times for both every attempt, using both JRE&apos;s mentioned above.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Just for verification - by &quot;same time&quot; did you mean that your successive runs show ~X ms for both patched and non-patched trunk, or by &quot;same time&quot; you meant that the successive runs show -30% drop with the patch?&lt;/p&gt;</comment>
                    <comment id="12695958" author="markrmiller@gmail.com" created="Mon, 6 Apr 2009 03:48:04 +0100"  >&lt;p&gt;As in, the 30% drop appeared to be an aberration. Both patched and un-patched performed the same on subsequent runs. It appears there is not a loss on my setup - or its very small if there is.&lt;/p&gt;</comment>
                    <comment id="12695959" author="shaie" created="Mon, 6 Apr 2009 03:56:47 +0100"  >&lt;p&gt;Yes, that&apos;s what I saw too. I will run the test with both 1.5 and 1.6, 32/64 bit versions and post the results.&lt;/p&gt;

&lt;p&gt;BTW, if you look at Mike&apos;s table above, it&apos;s a black and white thing: the 1.5 JRE really like this patch and 1.6 really hate it. Maybe we should not move to 1.6 then? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; (kidding)&lt;/p&gt;</comment>
                    <comment id="12696010" author="shaie" created="Mon, 6 Apr 2009 10:09:36 +0100"  >&lt;p&gt;I wasn&apos;t able to run the test on 64-bit JRE. Here are the results on 32-bit JREs:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;OS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;JRE&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;%tg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;XP&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;IBM 1.5&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 573 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 571 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;font color=&quot;green&quot;&gt;0.34%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; XP &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 1.6.07 (32 bit) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 752 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 804 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;font color=&quot;red&quot;&gt;-6.4 %&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;SRV 2003&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; IBM 1.5 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 530/469 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 536/493 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;font color=&quot;green&quot;&gt;1%&lt;/font&gt;/&lt;font color=&quot;red&quot;&gt;-4.86%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;SRV 2003&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 1.6.07 (32 bit) &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 858 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 699 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &lt;font color=&quot;green&quot;&gt;22.7%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;I ran each twice, and just in the SRV-2003-1.5 case there were differences between the two runs. Also, it&apos;s important to notice that unlike Mike&apos;s results, the SRV2003-JRE1.6 run had 22.7% improvement with the patched version. I re-ran the 2003 runs a couple of times and the results were consistent.&lt;/p&gt;</comment>
                    <comment id="12696017" author="mikemccand" created="Mon, 6 Apr 2009 10:47:58 +0100"  >&lt;p&gt;Mark and Shai, are you guys using the last version of the bench (that sorts by random int field)?  Are you using the &quot;best&quot; time for your results?  How are you launching the JRE?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;BTW, if you look at Mike&apos;s table above, it&apos;s a black and white thing: the 1.5 JRE really like this patch and 1.6 really hate it. Maybe we should not move to 1.6 then?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, for my run on Linux, the patch was faster for both 1.5 &amp;amp; 1.6 JREs.&lt;/p&gt;</comment>
                    <comment id="12696019" author="shaie" created="Mon, 6 Apr 2009 10:53:03 +0100"  >&lt;p&gt;Added JustCompileSearch, JustCompileSearchFunction and JustCompileSearchSpans that extend/implement all abstract classes/interfaces in o.a.l.s, o.a.l.s.s and o.a.l.s.f. Those are not unit tests per-sei, however if anyone will change the interfaces/abstract classes in a way that it breaks back-compat, we&apos;ll know it right away. I think that in general this is something good to have for Lucene overall, however I only took care of the search.* packages in this patch.&lt;/p&gt;</comment>
                    <comment id="12696020" author="shaie" created="Mon, 6 Apr 2009 11:00:50 +0100"  >&lt;p&gt;I&apos;m using the latest version which sorts by that random field (the output includes the prints of best, avg. and sum, so I&apos;m sure of that). Also, the times I reported are the &apos;best&apos; time. I launch the JRE like you posted with those args: &quot;-Xms1024M -Xmx1024M -Xbatch -server&quot;.&lt;/p&gt;

&lt;p&gt;I reran now, and the results are consistent.&lt;/p&gt;</comment>
                    <comment id="12696084" author="markrmiller@gmail.com" created="Mon, 6 Apr 2009 14:47:04 +0100"  >&lt;p&gt;I just used the defaults for cmd line - I can give it another go ensuring server and more RAM. I used the latest perf code provided by Mike and the latest patch.&lt;/p&gt;

&lt;p&gt;I didn&apos;t look at the numbers too closely - my plan was to do a quick profile with each, but eyeballing runs with each over and over, they were approx the same (both best and avg), so I skipped the profiling.&lt;/p&gt;</comment>
                    <comment id="12696101" author="mikemccand" created="Mon, 6 Apr 2009 15:25:12 +0100"  >
&lt;p&gt;I ran 2 more JREs under linux:&lt;/p&gt;

&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;OS&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;JRE&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Trunk&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Patch&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;%tg&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Linux&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1.7.0 ea&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;333 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;320 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;green&quot;&gt;3.9%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Linux&lt;/th&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;IBM JRE 1.5.0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;401 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;352 ms&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&lt;font color=&quot;green&quot;&gt;12.2%&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
</comment>
                    <comment id="12696145" author="shaie" created="Mon, 6 Apr 2009 16:54:32 +0100"  >&lt;p&gt;So how do we proceed? It looks like we get inconsistent results, sometimes over the same OS and JRE, just different machine. Perhaps the test is too synthetic, although it does capture the essence of the changes. Mike, can you post your Wikipedia index somewhere so I can download and run your previous queries and compare the results?&lt;/p&gt;</comment>
                    <comment id="12696160" author="mikemccand" created="Mon, 6 Apr 2009 17:27:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;So how do we proceed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The results are definitely highly varying...&lt;/p&gt;

&lt;p&gt;It seems like I&apos;m the only one seeing sizable performance loss with the patch,&lt;br/&gt;
and then only with 64bit JREs (on OS X and Windows Server 2004 x64).&lt;/p&gt;

&lt;p&gt;Mark when you saw no performance loss on  64 bit linux, was the JRE&lt;br/&gt;
64 bit?&lt;/p&gt;

&lt;p&gt;If so, then maybe we should simply proceed with the patch as is.&lt;br/&gt;
These differences are clearly java ghosts and there&apos;s not much we can&lt;br/&gt;
do about that....&lt;/p&gt;

&lt;p&gt;The index is a little too large (2.6G) to schlepp around &amp;#8211; instead,&lt;br/&gt;
here&apos;s the alg I used to create it:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
analyzer=org.apache.lucene.analysis.standard.StandardAnalyzer

doc.maker=org.apache.lucene.benchmark.byTask.feeds.LineDocMaker

merge.policy=org.apache.lucene.index.LogDocMergePolicy

docs.file=/Volumes/External/lucene/wiki.txt
doc.stored = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
doc.term.vector = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
doc.add.log.step=1000
max.field.length=2147483647

directory=FSDirectory
autocommit=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
compound=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
ram.flush.mb = 128
doc.maker.forever = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;

work.dir=/lucene/work

{ &lt;span class=&quot;code-quote&quot;&gt;&quot;Rounds&quot;&lt;/span&gt;
  ResetSystemErase
  { &lt;span class=&quot;code-quote&quot;&gt;&quot;BuildIndex&quot;&lt;/span&gt;
    - CreateIndex
     { &lt;span class=&quot;code-quote&quot;&gt;&quot;AddDocs&quot;&lt;/span&gt; AddDoc &amp;gt; : *
    - CloseIndex
  }
  NewRound
} : 1

RepSumByPrefRound BuildIndex
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12696178" author="markrmiller@gmail.com" created="Mon, 6 Apr 2009 18:07:11 +0100"  >&lt;p&gt;Yes, both 64-bit versions - openjdk 6 and sun java 1.5. I appeared to be getting the same results with both jvm&apos;s and patched or not. I figured I&apos;d try a bit of profiling, since I have a 64-bit setup, but doesnt appear I&apos;d learn much. I&apos;m going to try a bit more testing tonight for the heck of it - I&apos;ve got sun 1.6 and a 32-bit 1.5 I could check with as well.&lt;/p&gt;</comment>
                    <comment id="12696460" author="mikemccand" created="Tue, 7 Apr 2009 11:08:10 +0100"  >&lt;p&gt;Attached new patch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Changed members &amp;amp; methods in TopFieldCollector from &quot;protected&quot; to&lt;br/&gt;
    package-private.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Tweaked javadocs, CHANGES.txt&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Removed some dead code, nocommits&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Re-added TestTimeLimitedCollector&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Besides the java ghosts, for which we will close our eyes and hope&lt;br/&gt;
they disappear, I think this is ready to go in!&lt;/p&gt;

&lt;p&gt;I&apos;ll way a few days and then commit.&lt;/p&gt;</comment>
                    <comment id="12696632" author="mikemccand" created="Tue, 7 Apr 2009 18:25:50 +0100"  >&lt;p&gt;New patch which just fixes contrib/spatial&apos;s cutover to the new API to further cutover to the new new API.&lt;/p&gt;</comment>
                    <comment id="12697052" author="mikemccand" created="Wed, 8 Apr 2009 16:13:46 +0100"  >&lt;p&gt;I wonder if we should break out tracking of max score, which is far more costly, from tracking scores of hits inserted into the queue?&lt;/p&gt;

&lt;p&gt;Typically the number of inserts is very low (ie, the queue &quot;converges&quot; quickly) and so only track scores of inserted hits would be much lower cost than also tracking max score.&lt;/p&gt;</comment>
                    <comment id="12697061" author="shaie" created="Wed, 8 Apr 2009 16:32:18 +0100"  >&lt;p&gt;That&apos;s actually what&apos;s done in TopScoreDocCollector. maxScore is not tracked at all, and only when topDocs() is called, maxScore is set to the largest element in the queue. It has some overhead in topDocs() (might require a pop of all elements, even if the range is &quot;give me the last 10&quot;), which I personally don&apos;t care about since it happens once per search.&lt;br/&gt;
maxScore is only tracked in TopFieldCollector, which indeed adds several instructions to each collect, including a call to Math.max.&lt;br/&gt;
Were you thinking along those lines? If so, I can remove maxScore tracking from TFC and compute it in topDocs only.&lt;/p&gt;

&lt;p&gt;Another idea, which will prevent popping out all the elements from the queue just to compare maxScore is to actually make it a method of TopDocsCollector (e.g., TDC.maxScore()). It will be the responsibility of the implementation (with TDC providing a base for all) to ensure that if the largest element is extracted, maxScore is set (so that we don&apos;t lose it). The reason I&apos;m thinking about it is that because maxScore is probably used only for normalization, and if a certain application never uses it, why should we compute it?&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12697083" author="mikemccand" created="Wed, 8 Apr 2009 17:22:09 +0100"  >
&lt;blockquote&gt;&lt;p&gt;maxScore is only tracked in TopFieldCollector, which indeed adds several instructions to each collect, including a call to Math.max.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, but most costly is the call to Scorer.score().  If you didn&apos;t&lt;br/&gt;
care to know the maxScore, but still wanted the raw score for each hit,&lt;br/&gt;
it&apos;d be much cheaper to only call Scorer.score() if the hit is&lt;br/&gt;
competitive (ie, is inserted into the pq).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Were you thinking along those lines? If so, I can remove maxScore tracking from TFC and compute it in topDocs only.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can&apos;t do that because that&apos;s a change in behavior (ie, maxScore&lt;br/&gt;
includes max across &lt;b&gt;all&lt;/b&gt; hits, not just the final topN).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The reason I&apos;m thinking about it is that because maxScore is probably used only for normalization, and if a certain application never uses it, why should we compute it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right that&apos;s my reasoning too.  So I think we should be able to separately turn off &quot;track max score&quot;.&lt;/p&gt;</comment>
                    <comment id="12697122" author="shaie" created="Wed, 8 Apr 2009 18:53:17 +0100"  >&lt;p&gt;Right ... so basically we&apos;re talking about changes in just TFC:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Add another parameter to TFC.create - trackMaxScore (default to true in IndexSearcher, but change to false in 3.0).&lt;/li&gt;
	&lt;li&gt;Keeping the non-scoring collectors as they are.&lt;/li&gt;
	&lt;li&gt;Create a ScoringNoMaxScoreCollector, which extends NonScoringCollector. It will compute score only if the doc has a chance to enter the queue. This means implementing collect() entirely, and not relying on super.collect.&lt;/li&gt;
	&lt;li&gt;Rename ScoringCollector to ScoringMaxScoreCollector and leave it as is: track both scores and maxScore and call super.collect().&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I figure there&apos;s no reason to create a NonScoringTrackMaxScore, since if we&apos;re calling score() to track maxScore, there&apos;s no reason not to set it on the docs that enter the pq.&lt;/p&gt;

&lt;p&gt;This does not affect TopScoreDocCollector.&lt;/p&gt;</comment>
                    <comment id="12697124" author="mikemccand" created="Wed, 8 Apr 2009 18:57:29 +0100"  >&lt;p&gt;Sounds right!  Wanna update the patch w/ that?&lt;/p&gt;</comment>
                    <comment id="12697130" author="shaie" created="Wed, 8 Apr 2009 19:11:00 +0100"  >&lt;p&gt;of course !&lt;/p&gt;</comment>
                    <comment id="12697152" author="mikemccand" created="Wed, 8 Apr 2009 20:05:02 +0100"  >&lt;p&gt;I came across another simple search optimization I think we should do:&lt;br/&gt;
if IndexSearcher can guarantee it visits docs in docID order (ie, turn&lt;br/&gt;
off the &quot;sort by numDocs()&quot; now done by default, that was added in&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt;), then in TopFieldCollector and TopScoreDocCollector we&lt;br/&gt;
can remove careful tie-breaking in the &quot;equals&quot; cases.&lt;/p&gt;

&lt;p&gt;This means in TopScoreDocCollector we could change this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (score &amp;gt;= reusableSD.score) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(inside collect) to:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (score &amp;gt; reusableSD.score) {
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;because if the new hit&apos;s score is == it can&apos;t possibly compete since&lt;br/&gt;
its docID is guaranteed to be greater than what&apos;s in the queue.&lt;/p&gt;

&lt;p&gt;Likewise, in TopFieldCollector.OneComparatorNonScoringCollector, we&lt;br/&gt;
can change:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; 0 || (cmp == 0 &amp;amp;&amp;amp; doc + docBase &amp;gt; bottom.docID)) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cmp &amp;lt;= 0) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and in MultiComparatorNonScoringCollector, we can change:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i == comparators.length - 1) {
  &lt;span class=&quot;code-comment&quot;&gt;// This is the equals &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;.
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doc + docBase &amp;gt; bottom.docID) {
    &lt;span class=&quot;code-comment&quot;&gt;// Definitely not competitive
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
  }
  &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i == comparators.length - 1) {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(or possibly refactor this one to return if c == 0 on exiting the&lt;br/&gt;
loop).&lt;/p&gt;

&lt;p&gt;We do still need the &quot;break tie&quot; logic in the lessThan methods of&lt;br/&gt;
HitQueue/FieldValueHitQueue, since PQ uses this to up/down heap itself&lt;br/&gt;
after we insert/delete.&lt;/p&gt;</comment>
                    <comment id="12697437" author="shaie" created="Thu, 9 Apr 2009 09:51:18 +0100"  >&lt;p&gt;Hey Mike. I actually planned to open another issue about optimizations to TSDC. Besides what you propose, I think that if we pre-fill pq with dummy objects (with score = Float.NEGATIVE_INF), we can skip the checks of &quot;if (reusableSD == null)&quot; and always assume the queue is full. We can even optimize it further by not calling pq.insertWithOverflow, but instead change top() and call adjustTop().&lt;/p&gt;

&lt;p&gt;I do think though that these belong in a different issue, since this one is about the refactoring. What do you say that I&apos;ll to this one the changes about maxScore we agreed, and then open a new one &quot;optimizations to TSDC and TFC&quot; and include those changes? I also want to do perf. measurements, ensure the unit tests cover everything etc. That issue already contains many changes.&lt;/p&gt;</comment>
                    <comment id="12697439" author="mikemccand" created="Thu, 9 Apr 2009 09:59:22 +0100"  >&lt;p&gt;OK that sounds like a good plan.&lt;/p&gt;

&lt;p&gt;I&apos;d be interested to see if pre-filling with sentinels gives better performance, too.&lt;/p&gt;

&lt;p&gt;Here&apos;s another one to add: some methods in Sort explicitly add SortField.FIELD_DOC as a &quot;tie breaker&quot; for the last SortField.  But, doing so should not be necessary (since we already break ties by docID), and is in fact less efficient (once the above optimization is in).&lt;/p&gt;</comment>
                    <comment id="12697442" author="shaie" created="Thu, 9 Apr 2009 10:09:53 +0100"  >&lt;p&gt;Does HitQueue favor documents with smaller ids? In case the score is equal I mean ... if not (I was under the impression larger doc Ids are favored), then if the scores are equal shouldn&apos;t the new doc replace the current doc? Isn&apos;t that&apos;s why the &amp;gt;= exists there now (othrewise it could be just &amp;gt;)? Or was it added as part of 1483, since it wasn&apos;t guaranteed documents are returned in increasing order?&lt;/p&gt;</comment>
                    <comment id="12697454" author="mikemccand" created="Thu, 9 Apr 2009 10:48:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;Does HitQueue favor documents with smaller ids?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.  In it&apos;s lessThan method, when the scores are equal, it does this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; hitA.doc &amp;gt; hitB.doc; 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Eg, hitB is &quot;favored&quot; (lessThan returns false) if it has a smaller doc than hitA.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Or was it added as part of 1483, since it wasn&apos;t guaranteed documents are returned in increasing order?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This was added as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1483&quot; title=&quot;Change IndexSearcher multisegment searches to search each individual segment using a single HitCollector&quot;&gt;&lt;del&gt;LUCENE-1483&lt;/del&gt;&lt;/a&gt;, but can be optimized away once we go back to in-order docID processing from IndexSearcher.&lt;/p&gt;</comment>
                    <comment id="12697462" author="mikemccand" created="Thu, 9 Apr 2009 11:05:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;Eg, hitB is &quot;favored&quot; (lessThan returns false) if it has a smaller doc than hitA.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Duh, I got that backwards.  This stuff is hard to think about!&lt;/p&gt;

&lt;p&gt;Corrected: if hitB has smaller doc than hitA, lessThan returns true, meaning hitB is preferred.&lt;/p&gt;</comment>
                    <comment id="12697733" author="shaie" created="Fri, 10 Apr 2009 05:53:54 +0100"  >&lt;ul&gt;
	&lt;li&gt;Adds the ScoringNoMaxScore collectors&lt;/li&gt;
	&lt;li&gt;Adds some tests to TestSort in order to test that functionality&lt;/li&gt;
	&lt;li&gt;Fixes a bug which existed since this issue - when maxScore is set to Float.NaN, Math.max always returns NaN. Therefore I set the ScoringMaxScore collectors to set it to NEG_INF (to accommodate scorers which assign negative scores to documents).&lt;/li&gt;
	&lt;li&gt;Added &quot;nomaxscore&quot; property to SearchWithSortTask.&lt;/li&gt;
	&lt;li&gt;Changed ReadTask.doLogic() to always use search(Query, Collector). The reason is that currently if scoring is set to true, it uses the default search method, however in 3.0 that method will be changed to not compute scores, and we might forget to change the logic in ReadTask.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;BTW, I wonder if we can replace the call to Math.max with just &apos;if (score &amp;gt; maxScore)&apos;? Looking at Math.max, it checks if the fist parameter is NaN (which I assume Scorer.score() will not return), and then if both equal 0.0f returns their sum, otherwise returns the biggest. Calling this method is quite expensive, and I think we will be safe with replacing it with &apos;if&apos;, however now that maxScore is decoupled as well, only the trackMaxScore collectors will suffer from it ....&lt;br/&gt;
Anyway, I added a TODO in case we don&apos;t want to change it now.&lt;/p&gt;</comment>
                    <comment id="12697747" author="shaie" created="Fri, 10 Apr 2009 06:45:15 +0100"  >&lt;p&gt;added another test case to TestSort&lt;/p&gt;</comment>
                    <comment id="12697791" author="mikemccand" created="Fri, 10 Apr 2009 12:18:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;BTW, I wonder if we can replace the call to Math.max with just &apos;if (score &amp;gt; maxScore)&apos;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I would just go ahead and do that.&lt;/p&gt;

&lt;p&gt;Looks great!  All tests pass.  Here&apos;s all I found... can you make a&lt;br/&gt;
new patch Shai?:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Patch is missing the fix to contrib/spatial&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Did you add a test case verifying maxScore is correct (so that the&lt;br/&gt;
    Float.NaN issue would trip the test)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Javadoc of searchWithSort needs to describe nomaxscore param&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;HitCollector isn&apos;t deprecated&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12697915" author="shaie" created="Fri, 10 Apr 2009 19:46:16 +0100"  >&lt;blockquote&gt;&lt;p&gt;Did you add a test case verifying maxScore is correct (so that the Float.NaN issue would trip the test)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I added to following tests:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;testSortWithoutScoreTracking - asserts that ScoreDoc.score is set to Float.NaN as well as maxScore.&lt;/li&gt;
	&lt;li&gt;testSortWithScoreNoMaxScoreTracking - asserts that ScoreDoc.score is not Float.NaN, but maxScore is.&lt;/li&gt;
	&lt;li&gt;testSortWithScoreAndMaxScoreTracking - asserts that both ScoreDoc.score and maxScore are not set to NaN.&lt;/li&gt;
	&lt;li&gt;testSortWithScoreAndMaxScoreTrackingNoResults - asserts that in case of a maxScore tracking collector with 0 results, maxScore is set to Float.NaN, rather than NEG_INF.&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;p&gt;HitCollector isn&apos;t deprecated&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Somehow when I applied your patch, this change wasn&apos;t taken in. Anyway, I noticed its javadocs also referenced MRHC, so I fixed it also.&lt;/p&gt;
</comment>
                    <comment id="12697919" author="mikemccand" created="Fri, 10 Apr 2009 19:53:20 +0100"  >&lt;blockquote&gt;&lt;p&gt;I added to following tests:&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Great, I&apos;ll have a look, thanks!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Somehow when I applied your patch, this change wasn&apos;t taken in. Anyway, I noticed its javadocs also referenced MRHC, so I fixed it also.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Most likely the hunk was rejected, due to the $Id$ keyword in that javadoc.  &quot;svn patch&quot; should fix this.&lt;/p&gt;</comment>
                    <comment id="12697942" author="mikemccand" created="Fri, 10 Apr 2009 20:33:50 +0100"  >&lt;p&gt;Patch looks good, and all tests patch.  I&apos;ll commit in a day or two, barring any more sudden improvements &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12698483" author="mikemccand" created="Mon, 13 Apr 2009 19:35:53 +0100"  >&lt;p&gt;Thanks Shai!&lt;/p&gt;</comment>
                    <comment id="12702471" author="thetaphi" created="Fri, 24 Apr 2009 19:07:26 +0100"  >&lt;p&gt;Hi,&lt;br/&gt;
Shalin found a backwards-incompatible change in the Searcher abstract class, I noticed this from his SVN comment for &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-940&quot; title=&quot;TrieRange support&quot;&gt;&lt;del&gt;SOLR-940&lt;/del&gt;&lt;/a&gt; (where he updated to Lucene trunk):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void search(Weight weight, Filter filter, Collector results) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This should not be abstract for backwards compatibility, but instead throw an UnsupportedOperationException or have a default implementation that somehow wraps the Collector using an old HitCollector (not very nice, I do not know how to fix this in any other way). Before 3.0, where this change would be ok,  the Javadocs should note, that the deprecated HitCollector API will be removed and the Collector part will be made abstract.&lt;br/&gt;
If this method stays abstract, you cannot compile old code or replace lucene jars (this is seldom, as almost nobody creates private implementations of Searcher, but Solr does...&lt;/p&gt;</comment>
                    <comment id="12702488" author="shaie" created="Fri, 24 Apr 2009 20:04:09 +0100"  >&lt;p&gt;If you read somewhere above, you&apos;ll see that we&apos;ve discussed this change. It seems that whatever we do, anyone who upgrades to 2.9 will need to touch his code. If you extend Searcher, you&apos;ll need to override that new method, regardless of what we choose to do. That&apos;s because if it&apos;s abstract, you need to implement it, and it it&apos;s concrete (throwing UOE), you&apos;ll need to override it since all the Searcher methods call this one at the end.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure wrapping a Collector with HitCollector will work, because all of the other classes now expect Collector, and their HitCollector variants call the Collector one with a HitCollectorWrapper (which is also deprecated).&lt;/p&gt;

&lt;p&gt;We agreed that making it abstract is the lesser of all evils, since you&apos;ll spot it at compile time, rather than at runtime, when you&apos;ll hit a UOE.&lt;/p&gt;</comment>
                    <comment id="12702509" author="mikemccand" created="Fri, 24 Apr 2009 20:52:56 +0100"  >&lt;blockquote&gt;&lt;p&gt;Shalin found a backwards-incompatible change in the Searcher abstract class&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We could go either way on this... the evils were strong with either choice, and we struggled and eventually went with adding abstract method today, for the reasons Shai enumerated.&lt;/p&gt;</comment>
                    <comment id="12702516" author="thetaphi" created="Fri, 24 Apr 2009 21:04:27 +0100"  >&lt;p&gt;OK, I resolve the issue again. I was just wondering and wanted to be sure. I also missed the first entry in CHANGES.txt, which explains it.&lt;br/&gt;
It is the same like with the Fieldable interface in the past, it is seldom implemented/overwritten and so the &quot;normal&quot; user will not be affected. And those who implement Fieldable or extend Searcher must implement it.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12404314" name="LUCENE-1575.1.patch" size="134745" author="shaie" created="Wed, 1 Apr 2009 10:15:22 +0100" />
                    <attachment id="12404317" name="LUCENE-1575.2.patch" size="135431" author="shaie" created="Wed, 1 Apr 2009 10:47:02 +0100" />
                    <attachment id="12404331" name="LUCENE-1575.3.patch" size="136676" author="shaie" created="Wed, 1 Apr 2009 13:06:32 +0100" />
                    <attachment id="12404334" name="LUCENE-1575.4.patch" size="143127" author="shaie" created="Wed, 1 Apr 2009 14:51:35 +0100" />
                    <attachment id="12404418" name="LUCENE-1575.5.patch" size="152619" author="shaie" created="Thu, 2 Apr 2009 07:49:05 +0100" />
                    <attachment id="12404438" name="LUCENE-1575.6.patch" size="164950" author="shaie" created="Thu, 2 Apr 2009 12:54:30 +0100" />
                    <attachment id="12404651" name="LUCENE-1575.7.patch" size="198203" author="shaie" created="Sat, 4 Apr 2009 18:29:36 +0100" />
                    <attachment id="12404704" name="LUCENE-1575.8.patch" size="229582" author="shaie" created="Mon, 6 Apr 2009 10:53:03 +0100" />
                    <attachment id="12405182" name="LUCENE-1575.9.patch" size="239901" author="shaie" created="Fri, 10 Apr 2009 19:46:16 +0100" />
                    <attachment id="12405144" name="LUCENE-1575.9.patch" size="231617" author="shaie" created="Fri, 10 Apr 2009 06:45:15 +0100" />
                    <attachment id="12404853" name="LUCENE-1575.patch" size="219917" author="mikemccand" created="Tue, 7 Apr 2009 18:25:50 +0100" />
                    <attachment id="12404816" name="LUCENE-1575.patch" size="218424" author="mikemccand" created="Tue, 7 Apr 2009 11:08:10 +0100" />
                    <attachment id="12404657" name="LUCENE-1575.patch" size="204314" author="mikemccand" created="Sat, 4 Apr 2009 20:48:24 +0100" />
                    <attachment id="12404538" name="LUCENE-1575.patch" size="166810" author="mikemccand" created="Fri, 3 Apr 2009 13:13:30 +0100" />
                    <attachment id="12404311" name="LUCENE-1575.patch" size="134846" author="shaie" created="Wed, 1 Apr 2009 09:49:55 +0100" />
                    <attachment id="12404676" name="PerfTest.java" size="2379" author="mikemccand" created="Sun, 5 Apr 2009 20:30:38 +0100" />
                    <attachment id="12404630" name="sortBench5.py" size="5803" author="mikemccand" created="Sat, 4 Apr 2009 10:40:58 +0100" />
                    <attachment id="12404631" name="sortCollate5.py" size="1121" author="mikemccand" created="Sat, 4 Apr 2009 10:40:58 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>18.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 27 Mar 2009 20:43:51 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12180</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26154</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>