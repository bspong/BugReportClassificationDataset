<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:01:12 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1425/LUCENE-1425.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1425] Add ConstantScore highlighting support to SpanScorer</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1425</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Its actually easy enough to support the family of constantscore queries with the new SpanScorer. This will also remove the requirement that you rewrite queries against the main index before highlighting (in fact, if you do, the constantscore queries will not highlight).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12406758">LUCENE-1425</key>
            <summary>Add ConstantScore highlighting support to SpanScorer</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="markrmiller@gmail.com">Mark Miller</assignee>
                                <reporter username="markrmiller@gmail.com">Mark Miller</reporter>
                        <labels>
                    </labels>
                <created>Sun, 19 Oct 2008 14:23:27 +0100</created>
                <updated>Thu, 2 May 2013 03:29:19 +0100</updated>
                    <resolved>Sat, 2 May 2009 23:48:33 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>modules/highlighter</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12640862" author="markrmiller@gmail.com" created="Sun, 19 Oct 2008 20:01:02 +0100"  >&lt;p&gt;First go at it, should be feature complete, but not thought complete.&lt;/p&gt;</comment>
                    <comment id="12642650" author="yseeley@gmail.com" created="Sat, 25 Oct 2008 20:27:02 +0100"  >&lt;p&gt;It seems like we should separate the concepts of extracting terms from highlighting.&lt;br/&gt;
There are scalability issues involved in enumerating all terms (both CPU and especially memory), and it seems like we should avoid that if possible.  What about some kind of interface that would allow leaving these queries in symbolic form?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;class Query {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; matches(Token t);
}

Or create an object optimized &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; matching &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; better speed:

class Query {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; TokenMatcher getTokenMatcher(IndexReader r);
}
class TokenMatcher {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; matches(Token t);  &lt;span class=&quot;code-comment&quot;&gt;// returns &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the token is part of &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; query
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; score(Token t);  &lt;span class=&quot;code-comment&quot;&gt;// returns &amp;lt;0 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; no match
&lt;/span&gt;}

Or perhaps even better is something that takes a complete TokenStream and spits back matches:

class TokenMatcher {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void setTokenStream(TokenStream ts);

  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; next();  &lt;span class=&quot;code-comment&quot;&gt;// returns &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there is another match
&lt;/span&gt;  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getStartOffset();
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getEndOffset();
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; getScore();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Basically, you want highlighting for a clause like a* to boil down to tokenText.startsWith(&quot;a&quot;)&lt;br/&gt;
Does that make sense?&lt;/p&gt;</comment>
                    <comment id="12642659" author="markrmiller@gmail.com" created="Sat, 25 Oct 2008 22:29:18 +0100"  >&lt;p&gt;Its a balancing act I suppose. Mark Harwood has suggested something similar in the past. Its ideally where we would like to end up I would think, but at the same time, it requires a lot more effort to implement the match logic in each query. I&apos;ll be happy to give it a shot as I can, but it would be nice to have some sort of support on a shorter time frame, even if inefficient. I think there are a lot of setups out there where you wont have enough matches in a document to consume &lt;em&gt;that&lt;/em&gt; much memory. To play nice, we ship with constantscore scoring off with the option to enable. Technically, its not really going to be any less efficient than the current support for non constantscore wildcard,prefix,range (other than the instantiated index).&lt;/p&gt;

&lt;p&gt;We can certainly hold off for a while to see where a match solution might go, but if it doesn&apos;t get much momentum, I&apos;d like to offer this option. Its a similar rationality to the Span Highlighter itself. It could have been done more efficiently if it broke the old API, and it could have been done right if we built in support to core Lucene, but the way it was done - its there and available and other ways are not.&lt;/p&gt;

&lt;p&gt;I&apos;ll let this stew and play around with the token matcher idea for a bit if/when/as time arises. SpanQueries, FilterQueries, ConstantScoreQueries, oh my.&lt;/p&gt;</comment>
                    <comment id="12642993" author="markh" created="Mon, 27 Oct 2008 18:12:40 +0000"  >&lt;p&gt;Delegating responsibility away from WeightedSpanTermExtractor seems desirable to avoid having special-case &quot;if clause instanceof xxx&quot;- type logic everywhere.&lt;br/&gt;
I suppose &quot;extractTerms&quot; was the core Query API&apos;s previous nod to supporting highlighting but is obviously falling short of what we need because:&lt;br/&gt;
1) It relies on generating potentially large lists of terms&lt;br/&gt;
2) It has no corresponding API that can be called on nested Filters&lt;br/&gt;
3) It does not reproduce positional logic e.g. Phrase/span queries&lt;/p&gt;

&lt;p&gt;The above TokenMatcher API certainly seems like a clean API from the highlighter&apos;s perspective but implementing it in queries/filters could prove trickier - especially for &quot;container&quot; classes such as BooleanQuery, SpanQuery, FilteredQuery, ConstantScoreQueries wrapping CachingWrapperFilters etc.&lt;/p&gt;

&lt;p&gt;There&apos;s a lot to consider here and Mark M&apos;s suggestion of adding more &quot;special-case&quot; logic into WeightedSpanTermExtractor may be a sensible holding position for now (guaranteed, as soon as Lucene-1424 is committed people will start squealing for some related highlighting support!) Another temporary alternative to consider is for Lucene-1424&apos;s &quot;ConstantScoreXxxxQuerys&quot; to implement extractTerms() in which case they retain the list of terms they generate - solely for highlighting purposes. This would require no specialised logic to be added to WeightedSpanTermExtractor and makes use of the existing-but-suboptimal &quot;highlighter-support&quot; API (Query.extractTerms)&lt;/p&gt;</comment>
                    <comment id="12671500" author="markrmiller@gmail.com" created="Sat, 7 Feb 2009 17:59:01 +0000"  >&lt;p&gt;I&apos;d like to go with this method as a stop gap solution for now. Its no worse than the previous approach of rewriting multi-term queries against the reader - in fact, its often much better as this approach rewrites against a memory index that only contains the doc to be highlighted.&lt;/p&gt;

&lt;p&gt;I think its important that we offer some way to highlight all of the query types. Performance and improvements can come later.&lt;/p&gt;

&lt;p&gt;This is an extension to the SpanScorer and won&apos;t affect the core Highlighter. So people can choose to use the SpanScorer if they want positional support (the non positional support is no slower), and then they can further choose if they want to expand multi term queries in the way provided (expanding multi-term defaults to false). Its generally going to work quite well, and the alternative at the moment is no highlighting.&lt;/p&gt;

&lt;p&gt;A general better solution that does not work with positions would probably be better applied to the standard Highlighter, and then the SpanScorer can take advantage of it at that time. Until then, I&apos;d like to offer full query type highlighting support with the SpanScorer since it is possible.&lt;/p&gt;

&lt;p&gt;So this solution adds the ability to turn on highlighting of all the Querys that extend MutliTermQuery, constantscore mode true or false. That gives the SpanScorer almost full query type highlighting coverage I think.&lt;/p&gt;</comment>
                    <comment id="12693917" author="markrmiller@gmail.com" created="Mon, 30 Mar 2009 22:56:01 +0100"  >&lt;p&gt;I&apos;d like to commit this soon.&lt;/p&gt;</comment>
                    <comment id="12705284" author="markrmiller@gmail.com" created="Sat, 2 May 2009 14:50:06 +0100"  >&lt;p&gt;needs a little fix to work with null field option and possibly default field&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12406757">LUCENE-1424</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12407086" name="LUCENE-1425.patch" size="3739" author="markrmiller@gmail.com" created="Sat, 2 May 2009 14:52:22 +0100" />
                    <attachment id="12399729" name="LUCENE-1425.patch" size="14782" author="markrmiller@gmail.com" created="Sat, 7 Feb 2009 17:59:01 +0000" />
                    <attachment id="12392442" name="LUCENE-1425.patch" size="14803" author="markrmiller@gmail.com" created="Sun, 19 Oct 2008 20:01:02 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sat, 25 Oct 2008 19:27:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12326</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26303</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>