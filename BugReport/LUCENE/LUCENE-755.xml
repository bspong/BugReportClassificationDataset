<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:07:02 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-755/LUCENE-755.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-755] Payloads</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-755</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This patch adds the possibility to store arbitrary metadata (payloads) together with each position of a term in its posting lists. A while ago this was discussed on the dev mailing list, where I proposed an initial design. This patch has a much improved design with modifications, that make this new feature easier to use and more efficient.&lt;/p&gt;

&lt;p&gt;A payload is an array of bytes that can be stored inline in the ProxFile (.prx). Therefore this patch provides low-level APIs to simply store and retrieve byte arrays in the posting lists in an efficient way. &lt;/p&gt;

&lt;p&gt;API and Usage&lt;br/&gt;
------------------------------   &lt;br/&gt;
The new class index.Payload is basically just a wrapper around a byte[] array together with int variables for offset and length. So a user does not have to create a byte array for every payload, but can rather allocate one array for all payloads of a document and provide offset and length information. This reduces object allocations on the application side.&lt;/p&gt;

&lt;p&gt;In order to store payloads in the posting lists one has to provide a TokenStream or TokenFilter that produces Tokens with payloads. I added the following two methods to the Token class:&lt;br/&gt;
  /** Sets this Token&apos;s payload. */&lt;br/&gt;
  public void setPayload(Payload payload);&lt;/p&gt;

&lt;p&gt;  /** Returns this Token&apos;s payload. */&lt;br/&gt;
  public Payload getPayload();&lt;/p&gt;

&lt;p&gt;In order to retrieve the data from the index the interface TermPositions now offers two new methods:&lt;br/&gt;
  /** Returns the payload length of the current term position.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This is invalid until 
{@link #nextPosition()} is called for&lt;br/&gt;
   *  the first time.&lt;br/&gt;
   * &lt;br/&gt;
   * @return length of the current payload in number of bytes&lt;br/&gt;
   */&lt;br/&gt;
  int getPayloadLength();&lt;br/&gt;
  &lt;br/&gt;
  /** Returns the payload data of the current term position.&lt;br/&gt;
   * This is invalid until {@link #nextPosition()}
&lt;p&gt; is called for&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;the first time.&lt;/li&gt;
	&lt;li&gt;This method must not be called more than once after each call&lt;/li&gt;
	&lt;li&gt;of 
{@link #nextPosition()}
&lt;p&gt;. However, payloads are loaded lazily,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;so if the payload data for the current position is not needed,&lt;/li&gt;
	&lt;li&gt;this method may not be called at all for performance reasons.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@param data the array into which the data of this payload is to be&lt;/li&gt;
	&lt;li&gt;stored, if it is big enough; otherwise, a new byte[] array&lt;/li&gt;
	&lt;li&gt;is allocated for this purpose.&lt;/li&gt;
	&lt;li&gt;@param offset the offset in the array into which the data of this payload&lt;/li&gt;
	&lt;li&gt;is to be stored.&lt;/li&gt;
	&lt;li&gt;@return a byte[] array containing the data of this payload&lt;/li&gt;
	&lt;li&gt;@throws IOException&lt;br/&gt;
   */&lt;br/&gt;
  byte[] getPayload(byte[] data, int offset) throws IOException;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Furthermore, this patch indroduces the new method IndexOutput.writeBytes(byte[] b, int offset, int length). So far there was only a writeBytes()-method without an offset argument. &lt;/p&gt;

&lt;p&gt;Implementation details&lt;br/&gt;
------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;One field bit in FieldInfos is used to indicate if payloads are enabled for a field. The user does not have to enable payloads for a field, this is done automatically:&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;The DocumentWriter enables payloads for a field, if one ore more Tokens carry payloads.&lt;/li&gt;
	&lt;li&gt;The SegmentMerger enables payloads for a field during a merge, if payloads are enabled for that field in one or more segments.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Backwards compatible: If payloads are not used, then the formats of the ProxFile and FreqFile don&apos;t change&lt;/li&gt;
	&lt;li&gt;Payloads are stored inline in the posting list of a term in the ProxFile. A payload of a term occurrence is stored right after its PositionDelta.&lt;/li&gt;
	&lt;li&gt;Same-length compression: If payloads are enabled for a field, then the PositionDelta is shifted one bit. The lowest bit is used to indicate whether the length of the following payload is stored explicitly. If not, i. e. the bit is false, then the payload has the same length as the payload of the previous term occurrence.&lt;/li&gt;
	&lt;li&gt;In order to support skipping on the ProxFile the length of the payload at every skip point has to be known. Therefore the payload length is also stored in the skip list located in the FreqFile. Here the same-length compression is also used: The lowest bit of DocSkip is used to indicate if the payload length is stored for a SkipDatum or if the length is the same as in the last SkipDatum.&lt;/li&gt;
	&lt;li&gt;Payloads are loaded lazily. When a user calls TermPositions.nextPosition() then only the position and the payload length is loaded from the ProxFile. If the user calls getPayload() then the payload is actually loaded. If getPayload() is not called before nextPosition() is called again, then the payload data is just skipped.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Changes of file formats&lt;br/&gt;
------------------------------&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;FieldInfos (.fnm)&lt;br/&gt;
The format of the .fnm file does not change. The only change is the use of the sixth lowest-order bit (0x20) of the FieldBits. If this bit is set, then payloads are enabled for the corresponding field. &lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ProxFile (.prx)&lt;br/&gt;
ProxFile (.prx) --&amp;gt;  &amp;lt;TermPositions&amp;gt;^TermCount&lt;br/&gt;
TermPositions   --&amp;gt; &amp;lt;Positions&amp;gt;^DocFreq&lt;br/&gt;
Positions       --&amp;gt; &amp;lt;PositionDelta, Payload?&amp;gt;^Freq&lt;br/&gt;
Payload         --&amp;gt; &amp;lt;PayloadLength?, PayloadData&amp;gt;&lt;br/&gt;
PositionDelta   --&amp;gt; VInt&lt;br/&gt;
PayloadLength   --&amp;gt; VInt &lt;br/&gt;
PayloadData     --&amp;gt; byte^PayloadLength&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For payloads disabled (unchanged):&lt;br/&gt;
PositionDelta is the difference between the position of the current occurrence in the document and the previous occurrence (or zero, if this is the first   occurrence in this document).&lt;/p&gt;

&lt;p&gt;For Payloads enabled:&lt;br/&gt;
PositionDelta/2 is the difference between the position of the current occurrence in the document and the previous occurrence. If PositionDelta is odd, then PayloadLength is stored. If PositionDelta is even, then the length of the current payload equals the length of the previous payload and thus PayloadLength is omitted.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;FreqFile (.frq)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;SkipDatum     --&amp;gt; DocSkip, PayloadLength?, FreqSkip, ProxSkip&lt;br/&gt;
PayloadLength --&amp;gt; VInt&lt;/p&gt;

&lt;p&gt;For payloads disabled (unchanged):&lt;br/&gt;
DocSkip records the document number before every SkipInterval th document in TermFreqs. Document numbers are represented as differences from the previous value in the sequence.&lt;/p&gt;

&lt;p&gt;For payloads enabled:&lt;br/&gt;
DocSkip/2 records the document number before every SkipInterval th  document in TermFreqs. If DocSkip is odd, then PayloadLength follows. If DocSkip is even, then the length of the payload at the current skip point equals the length of the payload at the last skip point and thus PayloadLength is omitted.&lt;/p&gt;


&lt;p&gt;This encoding is space efficient for different use cases:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;If only some fields of an index have payloads, then there&apos;s no space overhead for the fields with payloads disabled.&lt;/li&gt;
	&lt;li&gt;If the payloads of consecutive term positions have the same length, then the length only has to be stored once for every term. This should be a common case, because users probably use the same format for all payloads.&lt;/li&gt;
	&lt;li&gt;If only a few terms of a field have payloads, then we don&apos;t waste much space because we benefit again from the same-length-compression since we only have to store the length zero for the empty payloads once per term.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All unit tests pass.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12359147">LUCENE-755</key>
            <summary>Payloads</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="michaelbusch">Michael Busch</assignee>
                                <reporter username="michaelbusch">Michael Busch</reporter>
                        <labels>
                    </labels>
                <created>Wed, 20 Dec 2006 19:08:30 +0000</created>
                <updated>Tue, 19 Jun 2007 09:14:50 +0100</updated>
                    <resolved>Thu, 15 Mar 2007 05:18:41 +0000</resolved>
                                            <fixVersion>2.2</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>3</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12460496" author="gsingers" created="Fri, 22 Dec 2006 14:29:33 +0000"  >&lt;p&gt;Great patch, Michael, and something that will come in handy for a lot of people.  I can vouch it applies cleanly and all the tests pass.  &lt;/p&gt;

&lt;p&gt;Now I am not sure I am totally understanding everything just yet so the following is thinking aloud, but bear with me.&lt;/p&gt;

&lt;p&gt;One of the big unanswered questions (besides how this fits into the whole flexible indexing scheme as discussed on the Payloads and Flexible indexing threads on java-dev) at this point for me is: how do we expose/integrate this into the scoring side of the equation?  It seems we would need some interfaces that hook into the scoring mechanism so that people can define what all these payloads are actually used for, or am I missing something?  Yet the TermScorer takes in the TermDocs, so it doesn&apos;t yet have access to the payloads (although this is easily remedied since we have access to the TermPositions when we construct TermScorer.)  Span Queries could easily be extended to include payload information since they use the TermPositions, which would be useful for post-processing algorithms.&lt;/p&gt;

&lt;p&gt;I can imagine an interface that you would have to be set on the Query/Scorer (and inherited unless otherwise set???).  The default implementation would be to ignore any payload, I suppose.  We could also add a callback in the Similarity mechanism, something like:&lt;/p&gt;

&lt;p&gt;float calculatePayloadFactor(byte[] payload);&lt;br/&gt;
or &lt;br/&gt;
float calculatePayloadFactor(Term term, byte[] payload);&lt;/p&gt;

&lt;p&gt;Then this factor could be added/multiplied into the term score or whatever other scorers use it?????? &lt;/p&gt;

&lt;p&gt;Is this making any sense?&lt;/p&gt;</comment>
                    <comment id="12460647" author="michaelbusch" created="Sat, 23 Dec 2006 15:06:39 +0000"  >&lt;p&gt;&amp;gt; Great patch, Michael, and something that will come in handy for a lot of people. I can vouch it applies cleanly and all the tests pass.&lt;/p&gt;

&lt;p&gt;Cool, thanks for trying it out, Grant! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; Now I am not sure I am totally understanding everything just yet so the following is thinking aloud, but bear with me.&lt;/p&gt;

&lt;p&gt;&amp;gt; One of the big unanswered questions (besides how this fits into the whole flexible indexing scheme as discussed on the Payloads and &lt;br/&gt;
&amp;gt; Flexible indexing threads on java-dev) at this point for me is: how do we expose/integrate this into the scoring side of the equation? It seems &lt;br/&gt;
&amp;gt; we would need some interfaces that hook into the scoring mechanism so that people can define what all these payloads are actually used &lt;br/&gt;
&amp;gt; for, or am I missing something? Yet the TermScorer takes in the TermDocs, so it doesn&apos;t yet have access to the payloads (although this is &lt;br/&gt;
&amp;gt; easily remedied since we have access to the TermPositions when we construct TermScorer.) Span Queries could easily be extended to &lt;br/&gt;
&amp;gt; include payload information since they use the TermPositions, which would be useful for post-processing algorithms.&lt;/p&gt;

&lt;p&gt;I would say it really depends on the use case of the payloads. For example XML search: here payloads can be used to store depths information of terms. An extended Span class could then take the depth information into account for query evaluation. As you pointed out the span classes already have easy access to the payloads since they use TermPositions, so to implement such a subclass should be fairly simple.&lt;/p&gt;

&lt;p&gt;&amp;gt; I can imagine an interface that you would have to be set on the Query/Scorer (and inherited unless otherwise set???). The default &lt;br/&gt;
&amp;gt; implementation would be to ignore any payload, I suppose. We could also add a callback in the Similarity mechanism, something like:&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; float calculatePayloadFactor(byte[] payload);&lt;br/&gt;
&amp;gt; or&lt;br/&gt;
&amp;gt; float calculatePayloadFactor(Term term, byte[] payload);&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; Then this factor could be added/multiplied into the term score or whatever other scorers use it??????&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Is this making any sense?&lt;/p&gt;

&lt;p&gt;I believe the case you&apos;re describing here is per-term norms/boosts? Yah I think this would work and you are right, the Scorers have to have access to TermPositions, TermDocs is not sufficient. So yes, it would be nice if TermScorer would use TermPositions instead of TermDocs. I just opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-761&quot; title=&quot;Clone proxStream lazily in SegmentTermPositions&quot;&gt;&lt;del&gt;LUCENE-761&lt;/del&gt;&lt;/a&gt;, which changes SegmentTermPositions to clone the proxStream lazily at the first time nextPosition() is called. Then the costs for creating TermDocs and TermPositions are the same and together with lazy prox skipping (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-687&quot; title=&quot;Performance improvement: Lazy skipping on proximity file&quot;&gt;&lt;del&gt;LUCENE-687&lt;/del&gt;&lt;/a&gt;) there&apos;s no reason anymore to not use TermPositions.&lt;/p&gt;

&lt;p&gt;However, as currently discussed on java-dev, per-term boosts could also be part of a new posting format in the flexible index scheme and thus not stored in the payloads.&lt;/p&gt;

&lt;p&gt;So in general this patch doesn&apos;t add yet a new search feature to Lucene, it rather opens the door for new features in the future. The way to add such a new feature is then:&lt;br/&gt;
1) Write an analyzer that provides data neccessary for the new feature and produces Tokens with payloads containing these data.&lt;br/&gt;
2) Write/extend a Scorer that has access to TermPositions and makes use of the data in the payloads for matching or scoring or both.&lt;/p&gt;</comment>
                    <comment id="12463414" author="hibou" created="Tue, 9 Jan 2007 21:56:04 +0000"  >&lt;p&gt;The patch I have just upload (payload.patch) is Michael&apos;s one (payloads.patch) with the customization of how payload are written and read, exactly like I did for Lucene-662. An IndexFormat is in fact a factory of PayloadWriter and PayloadReader, this index format being stored in the Directory instance.&lt;/p&gt;

&lt;p&gt;Note that I haven&apos;t changed the javadoc neither the comments included in Michael&apos;s patch, it needs some cleanup if somebody is interested in commiting it.&lt;br/&gt;
And sorry for the name of the patch I have uploaded, it is a little bit confusing now, and I can&apos;t change it&apos;s name. I will be more carefull next time when naming my patch files.&lt;/p&gt;</comment>
                    <comment id="12479781" author="gsingers" created="Sat, 10 Mar 2007 00:38:20 +0000"  >&lt;p&gt;Nicolas,&lt;/p&gt;

&lt;p&gt;Are you implying your patch fits in with 662 (and needs to be applied after) or it is just in the style of 662 but isn&apos;t dependent on?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Grant&lt;/p&gt;</comment>
                    <comment id="12479841" author="hibou" created="Sat, 10 Mar 2007 14:28:42 +0000"  >&lt;p&gt;Grant&amp;gt;&lt;br/&gt;
The patch I have propsed here has no dependency on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-662&quot; title=&quot;Extendable writer and reader of field data&quot;&gt;&lt;del&gt;LUCENE-662&lt;/del&gt;&lt;/a&gt;, I just &quot;imported&quot; some ideas from it and put them there. Since the &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-662&quot; title=&quot;Extendable writer and reader of field data&quot;&gt;&lt;del&gt;LUCENE-662&lt;/del&gt;&lt;/a&gt; have involved, the patches will probably make conflicts. The best to use here is Michael&apos;s one. I think it won&apos;t conflit with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-662&quot; title=&quot;Extendable writer and reader of field data&quot;&gt;&lt;del&gt;LUCENE-662&lt;/del&gt;&lt;/a&gt;. And if both are intended to be commited, then the best is to commit the both seperately and redo the work I have done with the provided patch (I remember that it was quite easy).&lt;/p&gt;</comment>
                    <comment id="12479961" author="michaelbusch" created="Mon, 12 Mar 2007 00:34:50 +0000"  >&lt;p&gt;I&apos;m attaching the new patch with the following changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;applies cleanly on the current trunk&lt;/li&gt;
	&lt;li&gt;fixed a bug in FSDirectory which affected payloads with length greater than 1024 bytes and extended testcase TestPayloads to test this fix&lt;/li&gt;
	&lt;li&gt;added the following warning comments to the new APIs:&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Warning: The status of the Payloads feature is experimental. The APIs&lt;/li&gt;
	&lt;li&gt;introduced here might change in the future and will not be supported anymore&lt;/li&gt;
	&lt;li&gt;in such a case. If you want to use this feature in a production environment&lt;/li&gt;
	&lt;li&gt;you should wait for an official release.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Another comment about an API change: In BufferedIndexOutput I changed the method &lt;br/&gt;
  protected abstract void flushBuffer(byte[] b, int len) throws IOException;&lt;br/&gt;
to&lt;br/&gt;
  protected abstract void flushBuffer(byte[] b, int offset, int len) throws IOException;&lt;/p&gt;

&lt;p&gt;which means that subclasses of BufferedIndexOutput won&apos;t compile anymore. I made this change for performance reasons: If a payload is longer than 1024 bytes (standard buffer size of BufferedIndexOutput) then it can be flushed efficiently to disk without having to perform array copies. &lt;/p&gt;

&lt;p&gt;Is this API change acceptable? Users who have custom subclasses of BufferedIndexOutput would have to change their classes in order to work.&lt;/p&gt;</comment>
                    <comment id="12480552" author="michaelbusch" created="Tue, 13 Mar 2007 21:32:11 +0000"  >&lt;p&gt;Attaching a new patch. The previous one didn&apos;t apply cleanly anymore after &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-710&quot; title=&quot;Implement &amp;quot;point in time&amp;quot; searching without relying on filesystem semantics&quot;&gt;&lt;del&gt;LUCENE-710&lt;/del&gt;&lt;/a&gt; was committed.&lt;/p&gt;</comment>
                    <comment id="12480910" author="michaelbusch" created="Wed, 14 Mar 2007 20:28:38 +0000"  >&lt;p&gt;Another one! (previous version didn&apos;t apply cleanly anymore after committing &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-818&quot; title=&quot;IndexWriter should detect when it&amp;#39;s used after being closed&quot;&gt;&lt;del&gt;LUCENE-818&lt;/del&gt;&lt;/a&gt;, Mike is keeping me busy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;

&lt;p&gt;Grant, did you get a chance to review the patch? I would like to go ahead and commit it soon with the API warnings if nobody objects...&lt;/p&gt;</comment>
                    <comment id="12481003" author="gsingers" created="Thu, 15 Mar 2007 02:50:10 +0000"  >&lt;p&gt;OK, I&apos;ve applied the patch.  All tests pass for me.  I think it looks  &lt;br/&gt;
good.  Have you run any benchmarks on it?  I ran the standard one on  &lt;br/&gt;
the patched version and on trunk, in a totally unscientific test.  In  &lt;br/&gt;
theory, the case with no payloads should perform very closely to the  &lt;br/&gt;
existing code, and this seems to be born out by me running the micro- &lt;br/&gt;
standard (ant run-task in contrib/benchmark).   Once we have this  &lt;br/&gt;
committed someone can take a crack at adding support to the  &lt;br/&gt;
benchmarker for payloads.&lt;/p&gt;

&lt;p&gt;Payload should probably be serializable.&lt;/p&gt;

&lt;p&gt;All in all, I think we could commit this, then adding the search/ &lt;br/&gt;
scoring capabilities like we&apos;ve talked about.  I like the  &lt;br/&gt;
documentation/comments you have added, very useful.  (One of these  &lt;br/&gt;
days I will take on documenting the index package like I intend to,  &lt;br/&gt;
so what you&apos;ve added will be quite helpful!)   We will/may want to  &lt;br/&gt;
add in, for example, a PayloadQuery and derivatives and a QueryParser  &lt;br/&gt;
operator that supported searching in the payload, or possibly  &lt;br/&gt;
boosting if a certain term has a certain type of payload (not that I  &lt;br/&gt;
want anything to do with the QueryParser).  Even beyond that,  &lt;br/&gt;
SpanPayloadQuery, etc.  I will possibly have some cycles to actually  &lt;br/&gt;
write some code for these next week.&lt;/p&gt;

&lt;p&gt;Just throwing this out there, I&apos;m not sure I really mean it or  &lt;br/&gt;
not &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, but:&lt;br/&gt;
do you think it would be useful to consider restricting the size of  &lt;br/&gt;
the payload?  I know, I know, as soon as we put a limit on it,  &lt;br/&gt;
someone will want to expand it, but I was thinking if we knew the  &lt;br/&gt;
size had a limit we could better control the performance and caching,  &lt;br/&gt;
etc. on the scoring/search side.    I guess it is buyer beware, maybe  &lt;br/&gt;
we put some javadocs on this.&lt;/p&gt;

&lt;p&gt;Also, I started &lt;a href=&quot;http://wiki.apache.org/lucene-java/Payloads&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/Payloads&lt;/a&gt; as I  &lt;br/&gt;
think we will want to have some docs explaining why Payloads are  &lt;br/&gt;
useful in non-javadoc format.&lt;/p&gt;

&lt;p&gt;On a side note, have a look at &lt;a href=&quot;http://wiki.apache.org/lucene-java/&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/&lt;/a&gt; &lt;br/&gt;
PatchCheckList to see if there is anything you feel you can add.&lt;/p&gt;



&lt;p&gt;--------------------------&lt;br/&gt;
Grant Ingersoll&lt;br/&gt;
Center for Natural Language Processing&lt;br/&gt;
&lt;a href=&quot;http://www.cnlp.org&quot; class=&quot;external-link&quot;&gt;http://www.cnlp.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Read the Lucene Java FAQ at &lt;a href=&quot;http://wiki.apache.org/jakarta-lucene/&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/jakarta-lucene/&lt;/a&gt; &lt;br/&gt;
LuceneFAQ&lt;/p&gt;

</comment>
                    <comment id="12481014" author="michaelbusch" created="Thu, 15 Mar 2007 04:16:12 +0000"  >&lt;p&gt;Grant Ingersoll commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-755&quot; title=&quot;Payloads&quot;&gt;&lt;del&gt;LUCENE-755&lt;/del&gt;&lt;/a&gt;:&lt;br/&gt;
----------------------------------------&lt;/p&gt;

&lt;p&gt;&amp;gt; OK, I&apos;ve applied the patch.  All tests pass for me.  I think it looks  &lt;br/&gt;
&amp;gt; good.  Have you run any benchmarks on it?  I ran the standard one on  &lt;br/&gt;
&amp;gt; the patched version and on trunk, in a totally unscientific test.  In  &lt;br/&gt;
&amp;gt; theory, the case with no payloads should perform very closely to the  &lt;br/&gt;
&amp;gt; existing code, and this seems to be born out by me running the micro- &lt;br/&gt;
&amp;gt; standard (ant run-task in contrib/benchmark).   Once we have this  &lt;/p&gt;

&lt;p&gt;Grant, thank you for running the benchmarks!&lt;br/&gt;
In case no payloads are used there is indeed no performance decrease to &lt;br/&gt;
expect, because the file format does not change at all in that case.&lt;/p&gt;

&lt;p&gt;&amp;gt; committed someone can take a crack at adding support to the  &lt;br/&gt;
&amp;gt; benchmarker for payloads.&lt;/p&gt;

&lt;p&gt;Good point! This will help us finding possible optimizations.&lt;/p&gt;

&lt;p&gt;&amp;gt; Payload should probably be serializable.&lt;/p&gt;

&lt;p&gt;Agreed. Will do ...&lt;/p&gt;

&lt;p&gt;&amp;gt; All in all, I think we could commit this, then adding the search/ &lt;br/&gt;
&amp;gt; scoring capabilities like we&apos;ve talked about.  I like the  &lt;br/&gt;
&amp;gt; documentation/comments you have added, very useful.  (One of these  &lt;br/&gt;
&amp;gt; days I will take on documenting the index package like I intend to,  &lt;br/&gt;
&amp;gt; so what you&apos;ve added will be quite helpful!)   We will/may want to  &lt;/p&gt;

&lt;p&gt;That&apos;s what I was planning to do as well... haven&apos;t had time yet. But &lt;br/&gt;
good that there&apos;s another volunteer, so we can split the work &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; add in, for example, a PayloadQuery and derivatives and a QueryParser  &lt;br/&gt;
&amp;gt; operator that supported searching in the payload, or possibly  &lt;br/&gt;
&amp;gt; boosting if a certain term has a certain type of payload (not that I  &lt;br/&gt;
&amp;gt; want anything to do with the QueryParser).  Even beyond that,  &lt;br/&gt;
&amp;gt; SpanPayloadQuery, etc.  I will possibly have some cycles to actually  &lt;br/&gt;
&amp;gt; write some code for these next week.&lt;/p&gt;

&lt;p&gt;Yes there are lots of things we could do. I was also thinking about&lt;br/&gt;
providing a demo that uses payloads. Let&apos;s commit this first, then&lt;br/&gt;
we can start working on these items...&lt;/p&gt;

&lt;p&gt;&amp;gt; Just throwing this out there, I&apos;m not sure I really mean it or  &lt;br/&gt;
&amp;gt; not  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; , but:&lt;br/&gt;
&amp;gt; do you think it would be useful to consider restricting the size of  &lt;br/&gt;
&amp;gt; the payload?  I know, I know, as soon as we put a limit on it,  &lt;br/&gt;
&amp;gt; someone will want to expand it, but I was thinking if we knew the  &lt;br/&gt;
&amp;gt; size had a limit we could better control the performance and caching,  &lt;br/&gt;
&amp;gt; etc. on the scoring/search side.    I guess it is buyer beware, maybe  &lt;br/&gt;
&amp;gt; we put some javadocs on this.&lt;/p&gt;

&lt;p&gt;Hmm, I&apos;m not sure if we should limit the size... since there are&lt;br/&gt;
so many different use cases I wouldn&apos;t even know how to pick such &lt;br/&gt;
a limit. However, if we discover later that a limit would be helpful&lt;br/&gt;
to optimize things on the search side we could think about a limit&lt;br/&gt;
parameter on field level, which would be easy to add if we introduce&lt;br/&gt;
a schema and global field semantics with FI.&lt;/p&gt;

&lt;p&gt;&amp;gt; Also, I started &lt;a href=&quot;http://wiki.apache.org/lucene-java/Payloads&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/Payloads&lt;/a&gt; as I  &lt;br/&gt;
&amp;gt; think we will want to have some docs explaining why Payloads are  &lt;br/&gt;
&amp;gt; useful in non-javadoc format.&lt;/p&gt;

&lt;p&gt;Cool, that will be helpful!&lt;/p&gt;

&lt;p&gt;&amp;gt; On a side note, have a look at &lt;a href=&quot;http://wiki.apache.org/lucene-java/&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/&lt;/a&gt; &lt;br/&gt;
&amp;gt; PatchCheckList to see if there is anything you feel you can add.&lt;/p&gt;

&lt;p&gt;Thanks for reviewing this so thoroughly, Grant! I will commit it soon!&lt;/p&gt;</comment>
                    <comment id="12481034" author="michaelbusch" created="Thu, 15 Mar 2007 05:18:41 +0000"  >&lt;p&gt;I just committed this. Payload is serializable now.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12365166">LUCENE-834</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12348592" name="payload.patch" size="94932" author="hibou" created="Tue, 9 Jan 2007 21:45:06 +0000" />
                    <attachment id="12353316" name="payloads.patch" size="79747" author="michaelbusch" created="Wed, 14 Mar 2007 20:28:38 +0000" />
                    <attachment id="12353231" name="payloads.patch" size="79727" author="michaelbusch" created="Tue, 13 Mar 2007 21:32:11 +0000" />
                    <attachment id="12353080" name="payloads.patch" size="79777" author="michaelbusch" created="Mon, 12 Mar 2007 00:34:50 +0000" />
                    <attachment id="12347603" name="payloads.patch" size="78251" author="michaelbusch" created="Wed, 20 Dec 2006 19:28:05 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 22 Dec 2006 14:29:33 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12997</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26975</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>