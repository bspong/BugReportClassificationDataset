<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:07:54 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1781/LUCENE-1781.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1781] Large distances in Spatial go beyond Prime MEridian</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1781</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;&lt;a href=&quot;http://amidev.kaango.com/solr/core0/select?fl=*&amp;amp;json.nl=map&amp;amp;wt=json&amp;amp;radius=5000&amp;amp;rows=20&amp;amp;lat=39.5500507&amp;amp;q=honda&amp;amp;qt=geo&amp;amp;long=-105.7820674&quot; class=&quot;external-link&quot;&gt;http://amidev.kaango.com/solr/core0/select?fl=*&amp;amp;json.nl=map&amp;amp;wt=json&amp;amp;radius=5000&amp;amp;rows=20&amp;amp;lat=39.5500507&amp;amp;q=honda&amp;amp;qt=geo&amp;amp;long=-105.7820674&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Get an error when using Solr when distance is calculated for the boundary box past 90 degrees.&lt;/p&gt;


&lt;p&gt;Aug 4, 2009 1:54:00 PM org.apache.solr.common.SolrException log&lt;br/&gt;
SEVERE: java.lang.IllegalArgumentException: Illegal lattitude value 93.1558669413734&lt;br/&gt;
        at org.apache.lucene.spatial.geometry.FloatLatLng.&amp;lt;init&amp;gt;(FloatLatLng.java:26)&lt;br/&gt;
        at org.apache.lucene.spatial.geometry.shape.LLRect.createBox(LLRect.java:93)&lt;br/&gt;
        at org.apache.lucene.spatial.tier.DistanceUtils.getBoundary(DistanceUtils.java:50)&lt;br/&gt;
        at org.apache.lucene.spatial.tier.CartesianPolyFilterBuilder.getBoxShape(CartesianPolyFilterBuilder.java:47)&lt;br/&gt;
        at org.apache.lucene.spatial.tier.CartesianPolyFilterBuilder.getBoundingArea(CartesianPolyFilterBuilder.java:109)&lt;br/&gt;
        at org.apache.lucene.spatial.tier.DistanceQueryBuilder.&amp;lt;init&amp;gt;(DistanceQueryBuilder.java:61)&lt;br/&gt;
        at com.pjaol.search.solr.component.LocalSolrQueryComponent.prepare(LocalSolrQueryComponent.java:151)&lt;br/&gt;
        at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:174)&lt;br/&gt;
        at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:131)&lt;br/&gt;
        at org.apache.solr.core.SolrCore.execute(SolrCore.java:1328)&lt;br/&gt;
        at org.apache.solr.servlet.SolrDispatchFilter.execute(SolrDispatchFilter.java:341)&lt;br/&gt;
        at org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:244)&lt;br/&gt;
        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)&lt;br/&gt;
        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)&lt;br/&gt;
        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)&lt;br/&gt;
        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)&lt;br/&gt;
        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)&lt;br/&gt;
        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)&lt;br/&gt;
        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)&lt;br/&gt;
        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:286)&lt;br/&gt;
        at org.apache.coyote.http11.Http11AprProcessor.process(Http11AprProcessor.java:857)&lt;br/&gt;
        at org.apache.coyote.http11.Http11AprProtocol$Http11ConnectionHandler.process(Http11AprProtocol.java:565)&lt;br/&gt;
        at org.apache.tomcat.util.net.AprEndpoint$Worker.run(AprEndpoint.java:1509)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;/p&gt;

</description>
                <environment>&lt;p&gt;All&lt;/p&gt;</environment>
            <key id="12432219">LUCENE-1781</key>
            <summary>Large distances in Spatial go beyond Prime MEridian</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="billnbell">Bill Bell</reporter>
                        <labels>
                    </labels>
                <created>Wed, 5 Aug 2009 00:38:11 +0100</created>
                <updated>Mon, 23 Nov 2009 22:18:04 +0000</updated>
                    <resolved>Tue, 22 Sep 2009 01:08:41 +0100</resolved>
                            <version>2.9</version>
                                <fixVersion>3.0</fixVersion>
                                <component>modules/spatial</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12739248" author="billnbell" created="Wed, 5 Aug 2009 00:40:03 +0100"  >&lt;p&gt;Fixed code - needs to be put in a release (trunk)&lt;/p&gt;</comment>
                    <comment id="12739286" author="mikemccand" created="Wed, 5 Aug 2009 01:54:17 +0100"  >&lt;p&gt;I was able to get TestCartesian to hit the issue, but adding 6000.0 radius into its tests, and confirmed that the patch fixed it.&lt;/p&gt;

&lt;p&gt;I also changed the two if&apos;s in each of the new norm methods to be if / else if instead (they are exclusive, I think).&lt;/p&gt;

&lt;p&gt;But unfortunately my lat/lng arithmetic is rather rusty &amp;#8211; I don&apos;t fully understand the normalization that&apos;s being added, here.  Can someone (Patrick?) check this?&lt;/p&gt;

&lt;p&gt;Also, what happens if radius is absurdly large and the resulting lat/lngs are ridiculous (say 1000.0)?&lt;/p&gt;</comment>
                    <comment id="12739974" author="mikemccand" created="Thu, 6 Aug 2009 11:06:58 +0100"  >&lt;p&gt;So, here&apos;s one thing that worries me about this change... note that my grasp of geographic math is very tenuous at best, so what follows could be pure folly:&lt;/p&gt;

&lt;p&gt;Say the latitude must wrap around, because it&apos;s 110.  This means (I think) that the this point has crossed over the north pole.&lt;/p&gt;

&lt;p&gt;With this patch, we&apos;ll simply map that 110 to 90 - (110 - 90) = 70.&lt;/p&gt;

&lt;p&gt;But shouldn&apos;t we also be flipping the longitude 180 degrees whenever the latitude crosses the north pole?  Ie, in crossing the north pole, the point has moved to the other side of the earth.  We aren&apos;t, with the current patch, which I think means the normalization simply bounces the point back where it came from, which doesn&apos;t seem right?&lt;/p&gt;

&lt;p&gt;Also, the code has this spooky TODO which looks relevant to this discussion:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// TODO: Prob only works in northern hemisphere?&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;m a little too nervous to commit this patch as is... I&apos;m going to clear it from 2.9 for now.  I&apos;m hoping someone with a strong grasp of lat/long math can step in and bring some clarity here, in time for 2.9...&lt;/p&gt;</comment>
                    <comment id="12740320" author="billnbell" created="Fri, 7 Aug 2009 00:48:39 +0100"  >&lt;p&gt;I did some additional testing, and here is the new fix that works. The issue is the number of miles per Long is dependent on Latitude. The code checks it but only uses this value from the center point. I converted to the standard way to calculate distances for the Earth, assume 45 and 225 degree right angles. This is working using very large distances.&lt;/p&gt;

&lt;p&gt;See new code.&lt;/p&gt;

&lt;p&gt;Not sure if you want the prints.&lt;/p&gt;</comment>
                    <comment id="12740322" author="billnbell" created="Fri, 7 Aug 2009 00:50:36 +0100"  >&lt;p&gt;Large distance fixer&lt;/p&gt;</comment>
                    <comment id="12740439" author="billnbell" created="Fri, 7 Aug 2009 08:45:44 +0100"  >&lt;p&gt;Michael - Please rerun your tests.&lt;/p&gt;

&lt;p&gt;The 2 normalization functions probably are now not needed, but they are there &quot;as an added check&quot;...&lt;/p&gt;

&lt;p&gt;This algorithm is standard, several web sites use it from Haversine. One example is at  &quot;Destination point given distance and bearing from start point&quot; at &lt;a href=&quot;http://www.movable-type.co.uk/scripts/latlong.html&quot; class=&quot;external-link&quot;&gt;http://www.movable-type.co.uk/scripts/latlong.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                    <comment id="12740478" author="mikemccand" created="Fri, 7 Aug 2009 10:26:33 +0100"  >&lt;p&gt;Thanks for the updated patch Bill!&lt;/p&gt;

&lt;p&gt;That&apos;s a good improvement (taking into account the varying miles per lng, depending on lat), but isn&apos;t that fix orthogonal to the normalization issue?  Ie, one could still easily overflow lat or lng with a large enough miles.  EG, I added 6000 miles as a testcase in TestCartesian, and if I turn off the normalization, it hits the same exception (Illegal lattitude value 94.77745787739758).&lt;/p&gt;

&lt;p&gt;And I&apos;m still concerned that the normalization fails to properly &quot;cross&quot; the north (or south) pole, by flipping the lng whenever the lat is too high; instead it seems to incorrectly &quot;bounce&quot; the point back?  Am I missing something?&lt;/p&gt;</comment>
                    <comment id="12740798" author="billnbell" created="Sat, 8 Aug 2009 01:44:40 +0100"  >&lt;p&gt;Everything is working except when you use a large area like 10000 miles. I get no results at this distance when crossing the anti-meridian (180 degrees).&lt;/p&gt;

&lt;p&gt;Most of the time this is fine, but specifically when -181 becomes 178 there appears to be an issue somewhere else in the code and nothing is returned. I believe this code is good, the issue is somewhere else. Maybe lower left is no longer lower left, and upper right is no longer upper right? The box is probably too big for the other algorithms. Not sure what else to check. How it is being used? Regardless this section appears right.&lt;/p&gt;

&lt;p&gt;Start here: ctr 39.3209801,-111.0937311&lt;br/&gt;
Distance: 7200&lt;/p&gt;

&lt;p&gt;boxCorners: before norm 22.100623434197477,21.15746490712925&lt;br/&gt;
boxCorners: normLng 22.100623434197477,21.15746490712925&lt;br/&gt;
boxCorners: distance: d 7200.0&lt;br/&gt;
boxCorners: ctr 39.3209801,-111.0937311&lt;br/&gt;
boxCorners: normLat 22.100623434197477,21.15746490712925&lt;br/&gt;
boxCorners: before norm -43.22565169384456,-181.34791600031286   note -181&lt;br/&gt;
boxCorners: normLng -43.22565169384456,178.65208399968714 Note 178&lt;br/&gt;
boxCorners: distance: d 7200.0&lt;br/&gt;
boxCorners: ctr 39.3209801,-111.0937311&lt;br/&gt;
boxCorners: normLat -43.22565169384456,178.65208399968714&lt;br/&gt;
corner 1054.4155877284288&lt;/p&gt;

&lt;p&gt;I do get results from Hawaii crossing this at 10,000 miles. This works:&lt;/p&gt;

&lt;p&gt;boxCorners: before norm 6.201324582593365,-0.012709669713800501&lt;br/&gt;
boxCorners: normLng 6.201324582593365,-0.012709669713800501&lt;br/&gt;
boxCorners: distance: d 10000.0&lt;br/&gt;
boxCorners: ctr 19.8986819,-155.6658568&lt;br/&gt;
boxCorners: normLat 6.201324582593365,-0.012709669713800501&lt;br/&gt;
boxCorners: before norm -41.508634930577436,-302.4840293070323 note -302&lt;br/&gt;
boxCorners: normLng -41.508634930577436,57.5159706929677 note 57&lt;br/&gt;
boxCorners: distance: d 10000.0&lt;br/&gt;
boxCorners: ctr 19.8986819,-155.6658568&lt;br/&gt;
boxCorners: normLat -41.508634930577436,57.5159706929677&lt;br/&gt;
corner 1464.4660940672625&lt;/p&gt;

&lt;p&gt;Note: This does not get any results. Note the 4.815339955430126 difference. Very weird.&lt;/p&gt;

&lt;p&gt;boxCorners: distance: d 10500.0&lt;br/&gt;
boxCorners: ctr 19.8986819,-155.6658568&lt;br/&gt;
boxCorners: normLat 0.8114618951495843,4.815339955430126&lt;br/&gt;
boxCorners: before norm -37.88735182208723,-310.6222696081052&lt;br/&gt;
boxCorners: normLng -37.88735182208723,49.37773039189477&lt;br/&gt;
boxCorners: distance: d 10500.0&lt;br/&gt;
boxCorners: ctr 19.8986819,-155.6658568&lt;br/&gt;
boxCorners: normLat -37.88735182208723,49.37773039189477&lt;br/&gt;
corner 1537.6893987706253&lt;/p&gt;



</comment>
                    <comment id="12740800" author="billnbell" created="Sat, 8 Aug 2009 01:47:31 +0100"  >&lt;p&gt;Added flipping for &amp;gt; 90 degrees if needed. See comment.&lt;/p&gt;</comment>
                    <comment id="12740831" author="billnbell" created="Sat, 8 Aug 2009 04:41:38 +0100"  >&lt;p&gt;I did some additional research. The current Spatial ONLY works for one hemisphere at a time. It does a simple min/max for lat/long measurements. This makes the whole solution not useful between one hemisphere and another. Specifically Rectangle.java, getBoundary, etc needs to work on a circle. The first step is to build a rectangle when lat goes from -90 to +89, and long goes from -180 to +179, etc.&lt;/p&gt;

&lt;p&gt; new Rectangle(ll.getLng(), ll.getLat(), ur.getLng(), ur.getLat())&lt;/p&gt;

&lt;p&gt;At least LLRect appears correct now... Next step is to fix the CartesianPolyFilterBuilder.&lt;/p&gt;

</comment>
                    <comment id="12740859" author="mikemccand" created="Sat, 8 Aug 2009 10:19:15 +0100"  >&lt;p&gt;OK the new normLat looks like it handles crossing the pole now, by flipping the lng; thanks.&lt;/p&gt;

&lt;p&gt;Can you add a unit test that confirms this was a problem before, and that the new lng-flipping resolves it?  Probably if you just modify TestCartesian, to add a new point, and then add a new test cast that starts from a lat/lng that&apos;s near the pole, you could get the issue to happen &amp;amp; be resolved.&lt;/p&gt;

&lt;p&gt;Also, can use &quot;svn diff&quot; and post the resulting output (instead of the whole copy of each source file)?  Thanks.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The current Spatial ONLY works for one hemisphere at a time.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, shouldn&apos;t LLRect work fine if a rect crosses the equator?   Or, a pole?  What I think it cannot handle is crossing the anti-meridian?  (Because, when that projects out, you&apos;ll need 2 rectangles, on opposite sides, to handle it?).  I&apos;m not sure what LLRect should even do if it finds it &quot;needs&quot; to cross the anti-meridian.  If it had the ability to return 2 rectangles I think it could be fixed.&lt;/p&gt;

&lt;p&gt;Or are you saying there are further limitations in contrib/spatial (ie, not caused by LLRect) that cause it to only work within one hemisphere?&lt;/p&gt;

&lt;p&gt;As for the &quot;we get no results when radius is very large&quot; bug, I like the theory that the corners need to be flipped.  Or, it could be the rect tried to cross the anti-meridian, and once we fix that, this case will also be fixed.  Finally, it could also be we simply have to floor the the lat after normalizing.  Ie before normalizing we get a ridiculous lat, say 1000.0, which normLat cannot handle since it can only &quot;undo&quot; at most &quot;off by 90&quot;.  I think normLat may need to be changed so that if it still sees lat/lng out of bounds after doing it&apos;s normalization, it simply floors the resulting lat?  Can you add a test case for this case as well?  We may as well get test cases for all the problems we&apos;re uncovering... then as we iterate on the patches we can see if they are fixed.&lt;/p&gt;</comment>
                    <comment id="12751945" author="billnbell" created="Sun, 6 Sep 2009 19:53:22 +0100"  >&lt;p&gt;SVN diff patch&lt;/p&gt;</comment>
                    <comment id="12753107" author="billnbell" created="Wed, 9 Sep 2009 15:31:47 +0100"  >&lt;p&gt;New test cases to test Prime and Anti Meridien. Both fail&lt;/p&gt;</comment>
                    <comment id="12753108" author="billnbell" created="Wed, 9 Sep 2009 15:33:24 +0100"  >&lt;p&gt;In case you cannot figure out the SVN diff.&lt;/p&gt;</comment>
                    <comment id="12753109" author="billnbell" created="Wed, 9 Sep 2009 15:33:55 +0100"  >&lt;p&gt;I added the test cases that both fail.&lt;/p&gt;</comment>
                    <comment id="12753881" author="mikemccand" created="Fri, 11 Sep 2009 00:05:04 +0100"  >&lt;p&gt;So the anti-meridian test is expected to fail, right?  Ie, LLRect is only able to represent a single rect, which is insufficient (I think?).  Not sure what LLRect should do when it detects that the anti-meridian is crossed.  Would be best if we could return 2 rects somehow...&lt;/p&gt;

&lt;p&gt;The prime-meridan test is testing the &quot;distance too large&quot; issue, right?  It fails now, but we should be able to fix this, I think, by capping the corners somehow?&lt;/p&gt;

&lt;p&gt;The last issue is the pole-flipping issue, which we think we fixed but we don&apos;t yet have a test case for, right?&lt;/p&gt;</comment>
                    <comment id="12753956" author="billnbell" created="Fri, 11 Sep 2009 03:48:54 +0100"  >&lt;p&gt;Not exactly.&lt;/p&gt;

&lt;p&gt;testPrimeM() should be fixed by the new LLRect.java. It goes over 90 degrees, and LLRect.java pole flips. If this is not working with the new LLRect, there is something wrong with that.&lt;/p&gt;

&lt;p&gt;testAntiM() creates a case that should fail. This condition needs to be fixed. The case is: You are located in Hawaii and you should see:&lt;/p&gt;

&lt;p&gt;Marshall Island Airfield&quot;,7.06, 171.2&lt;br/&gt;
Midway Island&quot;,25.7, -171.7&lt;/p&gt;

&lt;p&gt;It only shows the Midway Island, since it is still in the same hemisphere (it did not go from -171 to 171 (the Anti-Meridien), This case also errors since the upper right is also going over the pole. So it also is testing testPrimeM(). If we reduce the miles to 3500 it tests only these 2 points. Since it does not show Marshall Island, the Local Lucene is not working right. Once this case works people we can release it.&lt;/p&gt;

&lt;p&gt;Here are my thoughts on a fix:&lt;/p&gt;

&lt;p&gt;LLRect does calculate the right box across anti-meridien. The issue is elsewhere. Either we have multiple boxes, or check the Point2D since the whole thing is not right crossing boundaries... box.getMaxPoint().getY() is not the max  when going &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/forbidden.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; to &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/add.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; and vice versa.&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; boxCorners: ur 43.242262719615994,-123.073340742054&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; boxCorners: cnt 21.6032207,-158.0&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; boxCorners: ll -5.189678558944157,177.24228397256368&lt;/p&gt;

</comment>
                    <comment id="12753992" author="billnbell" created="Fri, 11 Sep 2009 05:32:41 +0100"  >&lt;p&gt;Posted new Test Junit tests. The AntiM will still fail, until we get a fix. &lt;/p&gt;</comment>
                    <comment id="12754062" author="mikemccand" created="Fri, 11 Sep 2009 10:21:26 +0100"  >&lt;p&gt;Bill, could you please post a single patch that includes all of your changes (fixing LLRect &amp;amp; TestCartesian)?  Also, please first &quot;svn up&quot; to the latest svn trunk so that the patch applies cleanly.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;testPrimeM() should be fixed by the new LLRect.java. It goes over 90 degrees, and LLRect.java pole flips. If this is not working with the new LLRect, there is something wrong with that.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm I&apos;m seeing testPrimeM fail &amp;#8211; maybe once I sync to your new patch I&apos;ll see it pass.  Maybe name that test &quot;testPoleFlipping&quot; or something instead?&lt;/p&gt;

&lt;p&gt;So testPrimeM isn&apos;t testing the &quot;miles is too large&quot; issue?  If not, can you add a new test that explicitly tests this?  We can use something ridiculous like 100000 miles.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;LLRect does calculate the right box across anti-meridien.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree that it calculates the correct &quot;upper right&quot; and &quot;lower left&quot;, but when those cross the anti-meridian, it&apos;s not possible to represent that with a single rect (you need two).  This is where I&apos;m waaaay out of my depth w/ GIS search... in general, how is this &quot;normally&quot; handled?  It seems like something higher up must accept two rects and OR them together during the searching?&lt;/p&gt;</comment>
                    <comment id="12754837" author="billnbell" created="Mon, 14 Sep 2009 07:15:00 +0100"  >&lt;p&gt;Combined patch. This does not fix Anti Meridien yet. It does test for it.&lt;/p&gt;</comment>
                    <comment id="12754909" author="billnbell" created="Mon, 14 Sep 2009 11:13:24 +0100"  >&lt;p&gt;Patch that fixed prime meridian and antimeridian issues. Also pole flipping.&lt;/p&gt;</comment>
                    <comment id="12754939" author="mikemccand" created="Mon, 14 Sep 2009 12:47:33 +0100"  >&lt;p&gt;Looks like great progress!  I now see all tests pass with your patch.&lt;/p&gt;

&lt;p&gt;So you now explicitly handle 2 different rects in CartesianPolyFilterBuilder.&lt;/p&gt;

&lt;p&gt;However, I added a &quot;miles too big&quot; test, by inserting a 10000.0 miles test case in testRange &amp;amp; testGeoHashRange, which ought to return all points (20) but instead only hits 1.  I think to fix this we just have to detect when the rect wraps around back onto itself, and somehow return &quot;whole world&quot; as the degenerate filter?&lt;/p&gt;</comment>
                    <comment id="12755344" author="billnbell" created="Tue, 15 Sep 2009 06:04:29 +0100"  >&lt;p&gt;Probably, do we have someone else to tackle that one? I would go further than 10,000 miles as well.&lt;/p&gt;

&lt;p&gt;There should be a switch to return all points, and just keep sorting and distance from lat/long, but I am not sure where to put that one...&lt;/p&gt;

&lt;p&gt;Bill&lt;/p&gt;

</comment>
                    <comment id="12757821" author="billnbell" created="Mon, 21 Sep 2009 05:58:51 +0100"  >&lt;p&gt;Can we go with my patch, and address this new large mile issue as a new LUCENE issue? I can probably assist, I just want this committed if possible.&lt;/p&gt;</comment>
                    <comment id="12757961" author="mikemccand" created="Mon, 21 Sep 2009 18:25:19 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can we go with my patch, and address this new large mile issue as a new LUCENE issue? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree, let&apos;s break this out as its own issue.  I&apos;ll open it and then commit this one.  Thanks Bill!&lt;/p&gt;</comment>
                    <comment id="12757963" author="mikemccand" created="Mon, 21 Sep 2009 18:31:47 +0100"  >&lt;p&gt;I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1921&quot; title=&quot;Absurdly large radius (miles) search fails to include entire earth&quot;&gt;&lt;del&gt;LUCENE-1921&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                    <comment id="12757972" author="mikemccand" created="Mon, 21 Sep 2009 19:06:18 +0100"  >&lt;p&gt;Mark is it OK to commit this now?  I realize it won&apos;t make 2.9 if the current RC is it...&lt;/p&gt;</comment>
                    <comment id="12758069" author="mikemccand" created="Tue, 22 Sep 2009 01:08:41 +0100"  >&lt;p&gt;Thanks Bill!&lt;/p&gt;</comment>
                    <comment id="12772098" author="mikemccand" created="Fri, 30 Oct 2009 21:26:09 +0000"  >&lt;p&gt;Correcting fix version.&lt;/p&gt;</comment>
                    <comment id="12781655" author="billnbell" created="Mon, 23 Nov 2009 22:15:26 +0000"  >&lt;p&gt;Has this been applied to 2.9.1 ?  Or do I need to apply it manually? I tested it on 2.9.1 and it does not appear to be in there.&lt;/p&gt;</comment>
                    <comment id="12781659" author="mikemccand" created="Mon, 23 Nov 2009 22:18:04 +0000"  >&lt;p&gt;No, this is fixed in 3.0 (to be released shortly).&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12419503" name="LUCENE-1781.patch" size="18096" author="billnbell" created="Mon, 14 Sep 2009 11:13:24 +0100" />
                    <attachment id="12415558" name="LUCENE-1781.patch" size="3530" author="mikemccand" created="Wed, 5 Aug 2009 01:54:17 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 5 Aug 2009 00:54:17 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11981</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25945</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>