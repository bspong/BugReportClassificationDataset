<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:23:06 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3486/LUCENE-3486.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3486] Add SearcherLifetimeManager, so you can retrieve the same searcher you previously used</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3486</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The idea is similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-2809&quot; title=&quot;searcher leases&quot;&gt;SOLR-2809&lt;/a&gt; (adding searcher leases to Solr).&lt;/p&gt;

&lt;p&gt;This utility class sits above whatever your source is for &quot;the&lt;br/&gt;
current&quot; searcher (eg NRTManager, SearcherManager, etc.), and records&lt;br/&gt;
(holds a reference to) each searcher in recent history.&lt;/p&gt;

&lt;p&gt;The idea is to ensure that when a user does a follow-on action (clicks&lt;br/&gt;
next page, drills down/up), or when two or more searcher invocations&lt;br/&gt;
within a single user search need to happen against the same searcher&lt;br/&gt;
(eg in distributed search), you can retrieve the same searcher you&lt;br/&gt;
used &quot;last time&quot;.&lt;/p&gt;

&lt;p&gt;I think with the new searchAfter API (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2215&quot; title=&quot;paging collector&quot;&gt;&lt;del&gt;LUCENE-2215&lt;/del&gt;&lt;/a&gt;), doing follow-on&lt;br/&gt;
searches on the same searcher is more important, since the &quot;bottom&quot;&lt;br/&gt;
(score/docID) held for that API can easily shift when a new searcher&lt;br/&gt;
is opened.&lt;/p&gt;

&lt;p&gt;When you do a &quot;new&quot; search, you record the searcher you used with the&lt;br/&gt;
manager, and it returns to you a long token (currently just the&lt;br/&gt;
IR.getVersion()), which you can later use to retrieve the same&lt;br/&gt;
searcher.&lt;/p&gt;

&lt;p&gt;Separately you must periodically call prune(), to prune the old&lt;br/&gt;
searchers, ideally from the same thread / at the same time that&lt;br/&gt;
you open a new searcher.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12525711">LUCENE-3486</key>
            <summary>Add SearcherLifetimeManager, so you can retrieve the same searcher you previously used</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Tue, 4 Oct 2011 19:21:59 +0100</created>
                <updated>Sun, 27 Nov 2011 12:29:32 +0000</updated>
                    <resolved>Mon, 10 Oct 2011 23:17:15 +0100</resolved>
                                            <fixVersion>3.5</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13120357" author="mikemccand" created="Tue, 4 Oct 2011 19:22:41 +0100"  >&lt;p&gt;Patch.&lt;/p&gt;</comment>
                    <comment id="13120405" author="shaie" created="Tue, 4 Oct 2011 20:33:07 +0100"  >&lt;p&gt;What a cool object, Mike ! And the javadocs are very good too.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Perhaps instead of &quot;recordTimeSec = System.nanoTime()/1000000000.0;&quot; you can use TimeUnit.NANOS.toSeconds? Just for clarity, and get rid of this monstrous number &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Typo: &quot;such that if the use performs&quot;: &apos;use&apos; --&amp;gt; &apos;user&apos;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;About this code:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
+    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (tracker == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
+      tracker = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SearcherTracker(searcher);
+      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (searchers.putIfAbsent(version, tracker) != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
+        &lt;span class=&quot;code-comment&quot;&gt;// Another thread beat us -- must decRef to undo
&lt;/span&gt;+        &lt;span class=&quot;code-comment&quot;&gt;// incRef done by SearcherTracker ctor:
&lt;/span&gt;+        searcher.getIndexReader().decRef();
+      }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Would it be better if SearcherTracker has a close() method and we call it instead of decRef()-ing on our own? Seems cleaner to me, and I always like to see the code that incRef/new closer to decRef/close. And if tomorrow SearcherTracker needs to clear other things too, we&apos;re already covered.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;About this &quot;// nocommit &amp;#8211; maybe make it &apos;public&apos; that you just decRef?&quot; --&amp;gt; do you mean whether we should jdoc that that&apos;s all we&apos;re doing? If so, why commit to just that? I don&apos;t think it contributes to the user ...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I have a problem with the Pruner interface. It has a single method prune which takes an IndexSearcher and ageSec (BTW, why is it double and not long?). And there&apos;s PruneByAge impl. But, what other impls could there be for this interface, if not by age?
	&lt;ul&gt;
		&lt;li&gt;On the other hand, I can certainly see someone, perhaps w/ NRT, not wanting to keep too many searchers around, and instead of committing to an age, he&apos;ll want to use a hard number (like, the newest 5 searchers) - that interface makes it impossible to impl.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If you think however that pruning by age, is the only scenario that makes sense, then I suggest removing the interface and having just the impl. Otherwise, perhaps a different interface should be created, one that receives a list of searchers, with their age, and returns a list of searchers that should be released? Just an idea.&lt;/p&gt;

&lt;p&gt;Hmm, now that I read prune(Pruner) jdoc, I can see how someone could impl &quot;newest 5 searchers&quot; by just counting up to 5 in its doPrune() calls, because prune(Pruner) guarantees that the searchers are passed newest to oldest. But still I wonder if the interface is not too limited.&lt;/p&gt;

&lt;p&gt;Looks very good !&lt;/p&gt;</comment>
                    <comment id="13120481" author="mikemccand" created="Tue, 4 Oct 2011 22:14:33 +0100"  >&lt;blockquote&gt;&lt;p&gt;Perhaps instead of &quot;recordTimeSec = System.nanoTime()/1000000000.0;&quot; you can use TimeUnit.NANOS.toSeconds? Just for clarity, and get rid of this monstrous number .&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I was wanting to have the seconds be a double, but, I agree that&apos;s&lt;br/&gt;
overkill; I think a &quot;typical&quot; pruning time should be maybe 10 minutes&lt;br/&gt;
and so having &quot;int seconds&quot; is OK.  I&apos;ll change it and use&lt;br/&gt;
TimeUnit.NANOSECONDS.toSeconds.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Typo: &quot;such that if the use performs&quot;: &apos;use&apos; --&amp;gt; &apos;user&apos;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks I&apos;ll fix.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Would it be better if SearcherTracker has a close() method and we call it instead of decRef()-ing on our own?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree &amp;#8211; I&apos;ll fix.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About this &quot;// nocommit &#8211; maybe make it &apos;public&apos; that you just decRef?&quot; --&amp;gt; do you mean whether we should jdoc that that&apos;s all we&apos;re doing? If so, why commit to just that? I don&apos;t think it contributes to the user ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well... the release is sort of &quot;spooky&quot; in that you can freely call it after close, which is why I thought about making its impl public; but I agree, let&apos;s leave it private and just keep the NOTE that it&apos;s fine to call after close.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have a problem with the Pruner interface. It has a single method prune which takes an IndexSearcher and ageSec (BTW, why is it double and not long?). And there&apos;s PruneByAge impl. But, what other impls could there be for this interface, if not by age?&lt;br/&gt;
On the other hand, I can certainly see someone, perhaps w/ NRT, not wanting to keep too many searchers around, and instead of committing to an age, he&apos;ll want to use a hard number (like, the newest 5 searchers) - that interface makes it impossible to impl.&lt;br/&gt;
If you think however that pruning by age, is the only scenario that makes sense, then I suggest removing the interface and having just the impl. Otherwise, perhaps a different interface should be created, one that receives a list of searchers, with their age, and returns a list of searchers that should be released? Just an idea.&lt;/p&gt;

&lt;p&gt;Hmm, now that I read prune(Pruner) jdoc, I can see how someone could impl &quot;newest 5 searchers&quot; by just counting up to 5 in its doPrune() calls, because prune(Pruner) guarantees that the searchers are passed newest to oldest. But still I wonder if the interface is not too limited.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, my idea was to make it really easy to prune-by-age, since&lt;br/&gt;
that&apos;s the common case, but also make it possible to do more&lt;br/&gt;
expert policies.&lt;/p&gt;

&lt;p&gt;I think prune-by-count is possible, but maybe more interesting would&lt;br/&gt;
be prune-by-total-segments-size, ie, if a large merge commits, this&lt;br/&gt;
metric would cut back on the number of searchers so that the net RAM&lt;br/&gt;
tied up is lower.  Not sure this is really needed in practice as large&lt;br/&gt;
merges don&apos;t complete often and it&apos;s unlikely you&apos;d hit more than one in&lt;br/&gt;
your time window...&lt;/p&gt;

&lt;p&gt;Thanks Shai!&lt;/p&gt;</comment>
                    <comment id="13120489" author="mikemccand" created="Tue, 4 Oct 2011 22:29:44 +0100"  >&lt;p&gt;Patch w/ Shai&apos;s suggestions, and tweaked some jdocs.&lt;/p&gt;</comment>
                    <comment id="13120662" author="shaie" created="Wed, 5 Oct 2011 05:17:48 +0100"  >&lt;p&gt;Looks good. I noticed you marked close() with @Override. Are we on Java 6 in 3.x?&lt;/p&gt;</comment>
                    <comment id="13120817" author="mikemccand" created="Wed, 5 Oct 2011 11:38:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;I noticed you marked close() with @Override. Are we on Java 6 in 3.x?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sigh, no we are not; in 3.x I&apos;ll have to comment that out.&lt;/p&gt;</comment>
                    <comment id="13120960" author="jasonrutherglen" created="Wed, 5 Oct 2011 14:34:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Looks good. I noticed you marked close() with @Override. Are we on Java 6 in 3.x?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;@Override is all over the place in Solr!?&lt;/p&gt;</comment>
                    <comment id="13120969" author="thetaphi" created="Wed, 5 Oct 2011 14:40:32 +0100"  >&lt;p&gt;Jason: Java 5 does not allow @Override on interfaces!&lt;/p&gt;</comment>
                    <comment id="13120974" author="thetaphi" created="Wed, 5 Oct 2011 14:44:09 +0100"  >&lt;p&gt;Mike: Why do we need the duplicate of IOUtils in SearcherLifetimeManager.close()? You can also use IOUtils.closeSafely(Collection)?&lt;/p&gt;</comment>
                    <comment id="13121144" author="mikemccand" created="Wed, 5 Oct 2011 18:02:07 +0100"  >&lt;p&gt;Thanks Uwe, you&apos;re right &amp;#8211; new patch, to just use IOUtils.  I also make an effort to catch mis-use (record called while close is running).&lt;/p&gt;</comment>
                    <comment id="13157794" author="thetaphi" created="Sun, 27 Nov 2011 12:29:32 +0000"  >&lt;p&gt;Bulk close after release of 3.5&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12497815" name="LUCENE-3486.patch" size="14624" author="mikemccand" created="Wed, 5 Oct 2011 18:02:07 +0100" />
                    <attachment id="12497710" name="LUCENE-3486.patch" size="16024" author="mikemccand" created="Tue, 4 Oct 2011 22:29:44 +0100" />
                    <attachment id="12497676" name="LUCENE-3486.patch" size="15156" author="mikemccand" created="Tue, 4 Oct 2011 19:22:41 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 4 Oct 2011 19:33:07 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>44588</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24210</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>