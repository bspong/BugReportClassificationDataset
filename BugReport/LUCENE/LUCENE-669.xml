<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:11:34 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-669/LUCENE-669.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-669] finalize()-methods of FSDirectory.FSIndexInput and FSDirectory.FSIndexOutput try to close already closed file</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-669</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Hi all,&lt;/p&gt;

&lt;p&gt;I found a small problem in FSDirectory: The finalize()-methods of FSDirectory.FSIndexInput and FSDirectory.FSIndexOutput try to close the underlying file. This is not a problem unless the file has been closed before by calling the close() method. If it has been closed before, the finalize method throws an IOException saying that the file is already closed. Usually this IOException would go unnoticed, because the GarbageCollector, which calls finalize(), just eats it. However, if I use the Eclipse debugger the execution of my code will always be suspended when this exception is thrown.&lt;/p&gt;

&lt;p&gt;Even though this exception probably won&apos;t cause problems during normal execution of Lucene, the code becomes cleaner if we apply this small patch. Might this IOException also have a performance impact, if it is thrown very frequently?&lt;/p&gt;

&lt;p&gt;I attached the patch which applies cleanly on the current svn HEAD. All testcases pass and I verfied with the Eclipse debugger that the IOException is not longer thrown.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12349375">LUCENE-669</key>
            <summary>finalize()-methods of FSDirectory.FSIndexInput and FSDirectory.FSIndexOutput try to close already closed file</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.png">Trivial</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="michaelbusch">Michael Busch</assignee>
                                <reporter username="buschmic">Michael Busch</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 Sep 2006 08:46:17 +0100</created>
                <updated>Tue, 27 Feb 2007 18:10:34 +0000</updated>
                    <resolved>Thu, 30 Nov 2006 00:08:28 +0000</resolved>
                                            <fixVersion>2.1</fixVersion>
                                <component>core/store</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12448786" author="mikemccand" created="Fri, 10 Nov 2006 16:07:07 +0000"  >&lt;p&gt;This patch looks good to me.  It still applies cleanly to the current &lt;span class=&quot;error&quot;&gt;&amp;#91;Nov 10 2006&amp;#93;&lt;/span&gt; svn head, and I think there&apos;s very little risk.  I think it makes sense to guard against double-closing.&lt;/p&gt;</comment>
                    <comment id="12448894" author="otis" created="Fri, 10 Nov 2006 23:31:29 +0000"  >&lt;p&gt;Looks fine to me.&lt;/p&gt;

&lt;p&gt;Maybe change this a bit:&lt;br/&gt;
   public void close() throws IOException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (!isClone)&lt;/li&gt;
	&lt;li&gt;file.close();&lt;br/&gt;
+    if (!isClone) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+      if (file != null) {
+        file.close();
+        file = null;
+      }+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That if (file != null) block could be replaced with closeFile() call, I think.&lt;/p&gt;

&lt;p&gt;Also, what was closing the file when you run this in Eclipse?&lt;/p&gt;</comment>
                    <comment id="12448908" author="michaelbusch" created="Sat, 11 Nov 2006 00:35:16 +0000"  >&lt;p&gt;The method closeFile() belongs to FSDirectory.FSIndexOutput, so I can&apos;t call it in FSDirectory.FSIndexInput.close(). (This is hard to see if you just look at the patch file). &lt;/p&gt;

&lt;p&gt;I added the method closeFile() to FSDirectory.FSIndexOutput, because the behaviour of finalize() and close() is slightly different: finalize() simply closes the file, whereas close() calls super.close() first and closes the file then. I didn&apos;t want to change this behavior, thus I can&apos;t just call close() from finalize().&lt;/p&gt;

&lt;p&gt;But now I am actually wondering if this behavior is correct. super.close() triggers a flush of the buffer. So in the current Lucene code, FSDirectory.FSIndexOutput.close() triggers a flush, but FSDirectory.FSIndexOutput.finalize() doesn&apos;t. Shouldn&apos;t we call flush also inside finalize() surrounded by try/catch?&lt;/p&gt;</comment>
                    <comment id="12452630" author="michaelbusch" created="Sun, 26 Nov 2006 06:56:59 +0000"  >&lt;p&gt;Since the new testcase TestStressIndexing has been added as part of the lockless commits I see this test failing regularly. In ten runs it failed four times with the following exception:&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testsuite: org.apache.lucene.index.TestStressIndexing&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 33.338 sec&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- Standard Output ---------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; java.io.IOException: The handle is invalid.&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- ---------------- ---------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- Standard Error -----------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; java.io.IOException: The handle is invalid.&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at java.io.RandomAccessFile.close0(Native Method)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at java.io.RandomAccessFile.close(RandomAccessFile.java:573)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.store.FSIndexInput.close(FSDirectory.java:537)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.CompoundFileReader.close(CompoundFileReader.java:111)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.SegmentReader.doClose(SegmentReader.java:252)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.IndexReader.close(IndexReader.java:637)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.MultiReader.doClose(MultiReader.java:235)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.IndexReader.close(IndexReader.java:637)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.search.IndexSearcher.close(IndexSearcher.java:74)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.TestStressIndexing$SearcherThread.run(TestStressIndexing.java:101)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- ---------------- ---------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase: testStressIndexAndSearching(org.apache.lucene.index.TestStressIndexing):	FAILED&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; hit unexpected exception in search2&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: hit unexpected exception in search2&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.TestStressIndexing.runStressTest(TestStressIndexing.java:140)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; at org.apache.lucene.index.TestStressIndexing.testStressIndexAndSearching(TestStressIndexing.java:161)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Test org.apache.lucene.index.TestStressIndexing FAILED&lt;/p&gt;

&lt;p&gt;It appears to be the same problem for which I opened this issue. After applying the patch I did not see the test failing anymore (I ran it about 20 times...)&lt;/p&gt;

&lt;p&gt;I attach a new version of this patch. Now FSDirectory.FSIndexOutput.finalize() simply calls close() which triggers a flush of the buffer. I don&apos;t see a reason not do that. Anybody does?&lt;/p&gt;

&lt;p&gt;All unit tests pass with the new patch.&lt;/p&gt;</comment>
                    <comment id="12453434" author="mikemccand" created="Sun, 26 Nov 2006 11:40:13 +0000"  >&lt;p&gt;Hmmm.  Michael, how does the exception in this unit test tie into this issue?  Ie, I thought this issue was that only finalize would be doing a double-close?  I&apos;m confused how the two are connected (it&apos;s awesome that your patch fixes this, but I&apos;d like to understand why!).&lt;/p&gt;</comment>
                    <comment id="12453819" author="michaelbusch" created="Tue, 28 Nov 2006 08:25:46 +0000"  >&lt;p&gt;Mike,&lt;/p&gt;

&lt;p&gt;you are right, it is very weird that 1) this problem happens and 2) my patch fixes it. It took me quite a while to figure out what the real problem is but I think I have at least a guess now. &lt;/p&gt;

&lt;p&gt;The problem again only happens on an IBM JVM. It happens rarely with your unmodified TestStressIndexing. If I change this testcase so that is does not perform the stress test on a RAMDirectory but only on a FSDirectory it happens almost always. This is VERY weird, because I did not change the stress test at all... I just commented the lines&lt;/p&gt;

&lt;p&gt;//    // First in a RAM directory:&lt;br/&gt;
//    Directory directory = new RAMDirectory();&lt;br/&gt;
//    runStressTest(directory);&lt;br/&gt;
//    directory.close();&lt;/p&gt;

&lt;p&gt;and suddenly every test fails with the IOException &quot;The handle is invalid&quot;. So that makes me think it has something to do with garbage collection and the finalize() methods.&lt;/p&gt;

&lt;p&gt;Now if I just comment out the finalize() method of FSDirectory.FSIndexOutput the test passes. This is even stranger, because the IOException occurred in FSDirectory.FSIndexInput.close(), not in FSIndexOutput, so in a different class which uses hence a different file descriptor.&lt;/p&gt;

&lt;p&gt;So I checked how java.io.FileDescriptor is implemented: It simply wraps an int value. I can&apos;t see how these int values are computed, because the open() method of RandomAccessFile is native. &lt;/p&gt;

&lt;p&gt;So I believe the following happens:&lt;br/&gt;
(1) FSIndexOutput uses a FileDescriptor with value x&lt;br/&gt;
(2) FSIndexOutput.close() is called, so the underlying file is being closed&lt;br/&gt;
(3) A new FSIndexInput instance is created by a searcher thread. This opens a RandomAccessFile. Because FileDescriptor x is not in use anymore, x is used as the value for the new FileDescriptor.&lt;br/&gt;
(4) Now garbage collection kicks in. It removes the old instance of FSIndexOutput for which close() has been called already. So the garbage collector calls finalize() which calls RandomAccessFile.close() again which still uses the descriptor with value x. So this call of close() actually closes the file used by the IndexInput instance created in (3).&lt;br/&gt;
(5) FSIndexInput.close() is called and tries to close the file which has been closed already in (4) and thus the IOException occurs.&lt;/p&gt;

&lt;p&gt;So it seems to me that the IBM JVM makes file descriptor values available after a file has been closed, whereas Sun waits until the FileDescriptor instance is destroyed. This might be a bug in the JVM, but since this patch is very simple we could just use it to be on the safe side.&lt;/p&gt;

&lt;p&gt;Do you think this makes sense? Or does anybody have a better idea why commenting out the finalize() method in FSIndexOutput prevents FSIndexInput.close() from throwing the IOException? &lt;/p&gt;</comment>
                    <comment id="12454037" author="mikemccand" created="Tue, 28 Nov 2006 17:38:26 +0000"  >&lt;p&gt;Michael, which OS are you seeing the exception on?  I&apos;m trying to repro on Linux w/ IBM&apos;s JVM 1.5.0 with no success.&lt;/p&gt;</comment>
                    <comment id="12454076" author="michaelbusch" created="Tue, 28 Nov 2006 19:00:24 +0000"  >&lt;p&gt;I&apos;m seeing the problem on Windows XP SP2, IBM JVM 1.5 SR3. I&apos;m running the tests in eclipse.&lt;/p&gt;</comment>
                    <comment id="12454098" author="mikemccand" created="Tue, 28 Nov 2006 20:11:03 +0000"  >&lt;p&gt;OK I will try to repro.&lt;/p&gt;

&lt;p&gt;In the meantime, I like your theory above!  It seems very plausible that the 2nd close (during finalize) could &lt;span class=&quot;error&quot;&gt;&amp;#91;incorrectly&amp;#93;&lt;/span&gt; close what was in fact a newly opened descriptor (in use elsewhere).  This also means this bug is more serious that I had thought (I thought it would just throw exceptions up to the GC).&lt;/p&gt;

&lt;p&gt;One way to be sure this theory is true is to instrument the finalize() to see that indeed it called close for the second time, and, the close succeeded (instead of throwing the original exception you saw).  Ie, if this event occurs and then corresponds to the above exception in the TestStressIndexing unit test, then we&apos;ve got this explained, and, it&apos;s quite serious since in production this could in theory result in errant IOExceptions like the one above.&lt;/p&gt;</comment>
                    <comment id="12454236" author="michaelbusch" created="Wed, 29 Nov 2006 06:09:09 +0000"  >&lt;p&gt;Mike,&lt;/p&gt;

&lt;p&gt;I tried to add some debug to FSIndexOutput and made another observation which makes this issue even odder! I added a boolean variable to FSIndexOutput with the name isOpen. I don&apos;t do anything with this variable, I just change the close() method from:&lt;/p&gt;

&lt;p&gt;  public void close() throws IOException &lt;/p&gt;
{
    super.close();
    file.close();
  }

&lt;p&gt;to &lt;/p&gt;

&lt;p&gt;  public void close() throws IOException &lt;/p&gt;
{
    super.close();
    file.close();
    isOpen = false;
  }

&lt;p&gt;and suddenly the problem disappears! Now I change close() to&lt;/p&gt;

&lt;p&gt;  public void close() throws IOException &lt;/p&gt;
{
    super.close();
    isOpen = false;
    file.close();
  }

&lt;p&gt;and the IOException occurs again. Notice that I don&apos;t use isOpen anywhere else in the code. So it seems that the problem only occurs if file.close() is the last instruction in close(). I bet this is a JVM bug, maybe the compiler makes some kind of optimization (maybe early freeing up the resources of the method&apos;s context that are on the stack while the last instruction of the method is being executed). So I&apos;m not completely sure what the real problem is, but I&apos;m pretty sure it is a JVM bug.&lt;/p&gt;</comment>
                    <comment id="12454488" author="mikemccand" created="Wed, 29 Nov 2006 23:28:42 +0000"  >&lt;p&gt;Ugh!  This bug is clearly a heisenbug.&lt;/p&gt;

&lt;p&gt;OK, I can also reproduce this on Windows when I use the IBM 1.5.0 JRE.&lt;br/&gt;
I can&apos;t repro with the Sun 1.5.0_07 JRE.&lt;/p&gt;

&lt;p&gt;When I apply your patch, the IOException goes away.&lt;/p&gt;

&lt;p&gt;Furthermore, my best efforts to get a standalone test to show the&lt;br/&gt;
error have failed.  I don&apos;t understand what precise tickling is&lt;br/&gt;
required to get the IOException to happen.&lt;/p&gt;

&lt;p&gt;Finally, I found this spooky very recent thread on java-user that&lt;br/&gt;
looks very much like this error (and was never resolved):&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.gossamer-threads.com/lists/lucene/java-user/40357&quot; class=&quot;external-link&quot;&gt;http://www.gossamer-threads.com/lists/lucene/java-user/40357&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I think in this case it was on Sun&apos;s JRE.  So I tried the test using&lt;br/&gt;
&quot;java -server&quot; but it didn&apos;t fail.  Sigh.&lt;/p&gt;

&lt;p&gt;My conclusion is: double-closing a RandomAccessFile is dangerous!  And&lt;br/&gt;
quite possibly can cause problems for &quot;real&quot; use cases (ie, not just&lt;br/&gt;
when testing under Eclipse).&lt;/p&gt;

&lt;p&gt;I will commit this patch.&lt;/p&gt;

&lt;p&gt;I made a couple of tiny changes: changed the name to &quot;isOpen&quot; and&lt;br/&gt;
moved up the &quot;isOpen = true&quot; to be right after the file is actually&lt;br/&gt;
opened.&lt;/p&gt;

&lt;p&gt;I also like the change to flush the buffer on finalize (if the file is&lt;br/&gt;
still open).&lt;/p&gt;

&lt;p&gt;Thanks Michael!&lt;/p&gt;</comment>
                    <comment id="12454505" author="michaelbusch" created="Thu, 30 Nov 2006 00:46:18 +0000"  >&lt;p&gt;Wow that was a tough one!&lt;/p&gt;

&lt;p&gt;Thanks for trying so hard to reproduce it, Mike. And thanks for committing, the small changes you made to my patch sound good to me!&lt;/p&gt;</comment>
                    <comment id="12470628" author="rnewson" created="Tue, 6 Feb 2007 16:23:13 +0000"  >
&lt;p&gt;The close() method in RandomAccessFile is defined not to throw IOException if it&apos;s merely closed twice. The bug here is with the IBM JDK and not Lucene. &lt;/p&gt;

&lt;p&gt;This stanza;&lt;/p&gt;

&lt;p&gt;final RandomAccessFile raf = new RandomAccessFile(&quot;/tmp/raf&quot;, &quot;rw&quot;);&lt;br/&gt;
		for (int i = 0; i &amp;lt; 1000; i++) &lt;/p&gt;
{
			raf.close();
		}

&lt;p&gt;should run fine everywhere, according to Javadocs;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;file:///home/rnewson/Documents/jdk-1.5/api/java/io/Closeable.html#close(&quot; class=&quot;external-link&quot;&gt;file:///home/rnewson/Documents/jdk-1.5/api/java/io/Closeable.html#close(&lt;/a&gt;)&lt;br/&gt;
&quot;Closes this stream and releases any system resources associated with it. If the stream is already closed then invoking this method has no effect.&quot;&lt;/p&gt;

&lt;p&gt;This behavior was clarified with the introduction of the Closeable interface in 1.5, so perhaps IBM are not to blame for this. &lt;/p&gt;</comment>
                    <comment id="12476266" author="mikemccand" created="Tue, 27 Feb 2007 18:10:34 +0000"  >&lt;p&gt;Closing all issues that were resolved for 2.1.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12345670" name="FSDirectory_close_file2.patch" size="1910" author="michaelbusch" created="Sun, 26 Nov 2006 06:56:59 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 10 Nov 2006 16:07:07 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13083</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27061</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>