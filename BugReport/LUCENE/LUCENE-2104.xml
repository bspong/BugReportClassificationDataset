<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:32:55 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2104/LUCENE-2104.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2104] IndexWriter.unlock does does nothing if NativeFSLockFactory is used</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2104</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;If NativeFSLockFactory is used, IndexWriter.unlock will return, silently doing nothing. The reason is that NativeFSLockFactory&apos;s makeLock always creates a new NativeFSLock. NativeFSLock&apos;s release first checks if its lock is not null. However, only if obtain() is called, that lock is not null. So release actually does nothing, and so IndexWriter.unlock does not delete the lock, or fail w/ exception.&lt;br/&gt;
This is only a problem in NativeFSLock, and not in other Lock implementations, at least as I was able to see.&lt;/p&gt;

&lt;p&gt;Need to think first how to reproduce in a test, and then fix it. I&apos;ll work on it.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12442226">LUCENE-2104</key>
            <summary>IndexWriter.unlock does does nothing if NativeFSLockFactory is used</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Wed, 2 Dec 2009 15:35:18 +0000</created>
                <updated>Fri, 18 Jun 2010 09:03:51 +0100</updated>
                    <resolved>Tue, 1 Jun 2010 19:36:40 +0100</resolved>
                            <version>2.9</version>
                <version>2.9.1</version>
                <version>3.0</version>
                                <fixVersion>2.9.3</fixVersion>
                <fixVersion>3.0.2</fixVersion>
                <fixVersion>3.1</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12788077" author="shaie" created="Wed, 9 Dec 2009 13:02:20 +0000"  >&lt;p&gt;I think that if I move those lines (in NativeFSLock.release()):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!path.delete())
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LockReleaseFailedException(&lt;span class=&quot;code-quote&quot;&gt;&quot;failed to delete &quot;&lt;/span&gt; + path);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;to outside the if(lockExists()) section, this should work? Because then the new NativeFSLock will attempt to release an lock that&apos;s held by someone else, and fail. If the lock exists for some reason, but nobody is holding it, that line should succeed.&lt;/p&gt;

&lt;p&gt;In order to test it, I think I&apos;ll need to spawn two processes, which is trickier. Let me know what you think about the fix in the meantime.&lt;/p&gt;</comment>
                    <comment id="12788581" author="shaie" created="Thu, 10 Dec 2009 08:06:11 +0000"  >&lt;p&gt;Patch includes a test in TestLockFactory and fix in NativeFSLock.&lt;/p&gt;</comment>
                    <comment id="12788599" author="thetaphi" created="Thu, 10 Dec 2009 08:53:02 +0000"  >&lt;p&gt;In general, there is no problem with NativeFSLock at all, because the removal of the lock file is just a &quot;cleanup&quot;, which is not needed (not deleting the lock file would produce no problem - we only delete it to be interoperable with SimpleFSLockFactory). The existence of a lock file is no indice for a locked directory, only if a lock is &quot;on the file&quot;. The JVM normally automatically removes lock files on exit.&lt;/p&gt;

&lt;p&gt;Removing the lock file to &quot;unlock&quot; is also a no-op, because even if the lock file is removed, the lock still exists (unix delete on last close semantics). The unlock method in IndexWriter is just for SimpleFSLockFactory and is of no use for any other lock factory.&lt;/p&gt;</comment>
                    <comment id="12788611" author="shaie" created="Thu, 10 Dec 2009 09:16:09 +0000"  >&lt;p&gt;Uwe, the problem is that unlock does nothing when NativeFSLock is used. So I open an IndexWriter and receive a LockObtainFailedException, and then call unlock because I&apos;m sure no one else holds the lock, I expect to be able to open the writer after unlock returns. With NativeFSLock, I cannot fail to obtain the lock if it&apos;s there but nobody uses it, so if I hit the exception, I shouldn&apos;t be allowed to call unlock.&lt;/p&gt;

&lt;p&gt;If you use SimpleFSLockFactory and call IndexWriter.unlock(), but SimpleFSLock.release() fails, you hit an exception. With NativeFSLock it&apos;s not the same, simply because NativeFSLockFactory.makeLock creates a new instance with a &apos;lock = null&apos;, and therefore calling release() is always a no-op.&lt;/p&gt;

&lt;p&gt;I think the symmetry is broken and that&apos;s what the issue and patch attempt to fix.&lt;/p&gt;</comment>
                    <comment id="12788616" author="thetaphi" created="Thu, 10 Dec 2009 09:26:47 +0000"  >&lt;p&gt;The problem with NativeFSLock is that you cannot release the lock if you are not owning the lock. It is the same like with synchronized() blocks, you can only unlock, if you own the lock.&lt;/p&gt;

&lt;p&gt;If you use NativeFSLock you should never-ever try to forcefully unlock! If there is a lock, then the dir is used and it would be the badest thing you could do, to forcefully unlock. The O/S will take care of lock removal on JVM exit.&lt;/p&gt;

&lt;p&gt;I just repeat: IndexWriter.unlock() is only a last resort to forcefully remove a lock file from SimpleFSLockFactory because the cleanup does not work. And I want to repeat: Removing the lock file does not remove the lock. You test e.g. fails on windows even with you patch, because Windows forcefully keeps the lock and does not allow to remove the lock file until it is explicitely unlocked.&lt;/p&gt;

&lt;p&gt;What you patch does on UNIX is, that it removes the lock file and therefore all references in filesystem to the lock. If another index writer then tries to lock again, it works, because the new file has another inode number and is a different lock file. What you are tryng to do is completely broken.&lt;/p&gt;</comment>
                    <comment id="12788620" author="thetaphi" created="Thu, 10 Dec 2009 09:30:59 +0000"  >&lt;p&gt;The fix would be to add a javadocs comment to IW.unlock, that this method only works and is a hack just for SimpleFSLockFactory. The existence of a lock file in native fs lock is not the presence of a lock. The file is just a helper, to have a lock &quot;namespace&quot;. Even if the file exists, the lock may not be obtained.&lt;/p&gt;</comment>
                    <comment id="12788697" author="shaie" created="Thu, 10 Dec 2009 12:12:26 +0000"  >&lt;p&gt;Thanks for the info Uwe. I know the unlock is to be used as a last resort, and if you know no one else has a reference to the lock. The fact that on Windows this fails is perfect, that&apos;s exactly what I want - for unlock() to fail if someone keeps a reference to the lock. On Unix - I didn&apos;t realize that&apos;s what happens, so that&apos;s indeed broken.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure that the fix is just javadocs ... perhaps the fix should be to add an unlock() method to Lock and impl it in SimpleFSLock by calling release(), but on NativeFSLock to first obtain the lock and if that succeeds, release it. That way, the obtain would fail and we can throw an exception. Also, we can keep release() and impl in NativeFSLock to first obtain if it does not hold the lock.&lt;/p&gt;

&lt;p&gt;Also, what you say about IndexWriter.unlock() should be used if SimpleFSLockFactory is used, and only then, is not: (1) documented anywhere and (2) reasonable. What if I implement a Lock over a DB (I think someone even posted something about that a while ago). I should still be able to call unlock().&lt;/p&gt;

&lt;p&gt;The thing is, IMO unlock() should throw an exception if it failed, and currently it does so in SimpleFSLock but not for NativeFSLock. The symmetry is broken, and I see no reason why it shouldn&apos;t fail for NativeFSLock, so the application knows about it. Notice that NativeFSLock fails to thrown an exception only because makeLock creates a new instance with the &apos;lock&apos; member being null. It gives a false impression that the unlock succeeded, and for the wrong reason.&lt;/p&gt;</comment>
                    <comment id="12789873" author="mikemccand" created="Sun, 13 Dec 2009 11:26:11 +0000"  >&lt;p&gt;Seems like two things are being discussed here:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Should IW.unlock be able to forcefully release a still-in-use&lt;br/&gt;
    lock?  For SimpleFSLockFactory we have no choice but to allow&lt;br/&gt;
    this, since it&apos;s unable to tell if the lock is &quot;really&quot; still&lt;br/&gt;
    held.  But since NativeFSLockFactory can tell, I don&apos;t think we&lt;br/&gt;
    should remove a still-in-use lock?  Seems like we leave the choice&lt;br/&gt;
    to the LF, eg for someone&apos;s external LF, it should decide if&lt;br/&gt;
    forceful removal is allowed.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If forceful removal is not allowed, should we throw an exception&lt;br/&gt;
    noting that you failed to forcefully remove the lock?  Seems like&lt;br/&gt;
    we should?  Ie, somehow, NativeFSLockFactory should try to acquire&lt;br/&gt;
    the lock, and if it was already locked, should throw an exception&lt;br/&gt;
    saying you cannot release it?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12789876" author="thetaphi" created="Sun, 13 Dec 2009 11:34:48 +0000"  >&lt;p&gt;+1 on exception.&lt;/p&gt;

&lt;p&gt;The problem: NativeFSLockFactory is never possible to get the lock and release it. This is only allowed for the code, that holds the lock (its the same like with a sysnchonized mutex using j.l.concurrent.ReentrantLock, only code that holds the lock can free it). So it is impossible to remove a lock, held by another process but it may be possible to release if it is created in the same JVM instance (for this to work, the factory needs a map of all generated locks).&lt;/p&gt;</comment>
                    <comment id="12789894" author="shaie" created="Sun, 13 Dec 2009 13:51:30 +0000"  >&lt;p&gt;Thanks for the comments. I proposed this above:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;perhaps the fix should be to add an unlock() method to Lock and impl it in SimpleFSLock by calling release(), but on NativeFSLock to first obtain the lock and if that succeeds, release it. That way, the obtain would fail and we can throw an exception. Also, we can keep release() and impl in NativeFSLock to first obtain if it does not hold the lock.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I vote for the second option (i.e. not adding another API, but use what&apos;s there and include a &quot;first obtain then release&quot; logic in an &apos;else&apos; part in NativeFSLock).&lt;/p&gt;</comment>
                    <comment id="12790135" author="shaie" created="Mon, 14 Dec 2009 13:12:46 +0000"  >&lt;p&gt;Changed NativeFSLock.release() to first obtain and then release the lock, if it&apos;s not held. That way, if obtain fails, LockReleaseFailedException is thrown, to indicate that.&lt;/p&gt;</comment>
                    <comment id="12791242" author="shaie" created="Wed, 16 Dec 2009 07:21:43 +0000"  >&lt;p&gt;How do we proceed with this? Can someone (Uwe/Mike?) plz review the latest patch I added?&lt;/p&gt;</comment>
                    <comment id="12791244" author="thetaphi" created="Wed, 16 Dec 2009 07:30:06 +0000"  >&lt;p&gt;For me the latest patch looks good as it no longer enforces to unlock (which is not possible with NativeFSLock) and throws Exception. The message should not include other processs, as the test verifies that it also fails in the same process, if the file is locked. Something like &quot;Cannot forcefully unlock a NativeFSLock which is held by another indexer component.&quot;.&lt;/p&gt;</comment>
                    <comment id="12791267" author="shaie" created="Wed, 16 Dec 2009 08:34:31 +0000"  >&lt;p&gt;Changed the sentence and updated CHANGES.&lt;/p&gt;</comment>
                    <comment id="12791303" author="mikemccand" created="Wed, 16 Dec 2009 10:26:50 +0000"  >&lt;p&gt;Patch looks good!  Thanks Shai.&lt;/p&gt;</comment>
                    <comment id="12791340" author="thetaphi" created="Wed, 16 Dec 2009 12:03:31 +0000"  >&lt;p&gt;Committed revision 891205 with the &quot;== false&quot; check changed to &quot;!&quot;&lt;/p&gt;

&lt;p&gt;Thanks Shai!&lt;/p&gt;</comment>
                    <comment id="12871223" author="thetaphi" created="Tue, 25 May 2010 17:12:30 +0100"  >&lt;p&gt;Should I backport?&lt;/p&gt;</comment>
                    <comment id="12871235" author="mikemccand" created="Tue, 25 May 2010 17:36:38 +0100"  >&lt;blockquote&gt;&lt;p&gt;Should I backport?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No &amp;#8211; it was already fixed on 3x (I just marked it as such in the issue), probably because we branched 3x off after this was committed.&lt;/p&gt;</comment>
                    <comment id="12873438" author="mikemccand" created="Sun, 30 May 2010 15:39:09 +0100"  >&lt;p&gt;backport&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12428146" name="LUCENE-2104.patch" size="2939" author="shaie" created="Wed, 16 Dec 2009 08:34:31 +0000" />
                    <attachment id="12427920" name="LUCENE-2104.patch" size="2861" author="shaie" created="Mon, 14 Dec 2009 13:12:46 +0000" />
                    <attachment id="12427589" name="LUCENE-2104.patch" size="2696" author="shaie" created="Thu, 10 Dec 2009 08:06:11 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 10 Dec 2009 08:53:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11675</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25621</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>