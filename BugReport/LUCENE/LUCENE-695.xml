<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:25:13 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-695/LUCENE-695.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-695] Improve BufferedIndexInput.readBytes() performance</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-695</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;During a profiling session, I discovered that BufferedIndexInput.readBytes(),&lt;br/&gt;
the function which reads a bunch of bytes from an index, is very inefficient&lt;br/&gt;
in many cases. It is efficient for one or two bytes, and also efficient&lt;br/&gt;
for a very large number of bytes (e.g., when the norms are read all at once);&lt;br/&gt;
But for anything in between (e.g., 100 bytes), it is a performance disaster.&lt;br/&gt;
It can easily be improved, though, and below I include a patch to do that.&lt;/p&gt;

&lt;p&gt;The basic problem in the existing code was that if you ask it to read 100&lt;br/&gt;
bytes, readBytes() simply calls readByte() 100 times in a loop, which means&lt;br/&gt;
we check byte after byte if the buffer has another character, instead of just&lt;br/&gt;
checking once how many bytes we have left, and copy them all at once.&lt;/p&gt;

&lt;p&gt;My version, attached below, copies these 100 bytes if they are available at&lt;br/&gt;
bulk (using System.arraycopy), and if less than 100 are available, whatever&lt;br/&gt;
is available gets copied, and then the rest. (as before, when a very large&lt;br/&gt;
number of bytes is requested, it is read directly into the final buffer).&lt;/p&gt;

&lt;p&gt;In my profiling, this fix caused amazing performance&lt;br/&gt;
improvement: previously, BufferedIndexInput.readBytes() took as much as 25%&lt;br/&gt;
of the run time, and after the fix, this was down to 1% of the run time! However, my scenario is &lt;b&gt;not&lt;/b&gt; the typical Lucene code, but rather a version of Lucene with added payloads, and these payloads average at 100 bytes, where the original readBytes() did worst. I expect that my fix will have less of an impact on &quot;vanilla&quot; Lucene, but it still can have an impact because it is used for things like reading fields. (I am not aware of a standard Lucene benchmark, so I can&apos;t provide benchmarks on a more typical case).&lt;/p&gt;

&lt;p&gt;In addition to the change to readBytes(), my attached patch also adds a new&lt;br/&gt;
unit test to BufferedIndexInput (which previously did not have a unit test).&lt;br/&gt;
This test simulates a &quot;file&quot; which contains a predictable series of bytes, and&lt;br/&gt;
then tries to read from it with readByte() and readButes() with various&lt;br/&gt;
sizes (many thousands of combinations are tried) and see that exactly the&lt;br/&gt;
expected bytes are read. This test is independent of my new readBytes()&lt;br/&gt;
inplementation, and can be used to check the old implementation as well.&lt;/p&gt;

&lt;p&gt;By the way, it&apos;s interesting that BufferedIndexOutput.writeBytes was already efficient, and wasn&apos;t simply a loop of writeByte(). Only the reading code was inefficient. I wonder why this happened.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12353836">LUCENE-695</key>
            <summary>Improve BufferedIndexInput.readBytes() performance</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png">Resolved</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="nyh">Nadav Har&apos;El</reporter>
                        <labels>
                    </labels>
                <created>Tue, 24 Oct 2006 10:51:45 +0100</created>
                <updated>Thu, 23 Jun 2011 13:20:35 +0100</updated>
                    <resolved>Thu, 26 Oct 2006 23:25:56 +0100</resolved>
                            <version>2.0.0</version>
                                                <component>core/store</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12444271" author="nyh" created="Tue, 24 Oct 2006 10:52:57 +0100"  >&lt;p&gt;The patch, which includes the change to BufferedIndexInput.readBytes(), and a new unit test for that class.&lt;/p&gt;</comment>
                    <comment id="12444316" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 14:58:54 +0100"  >&lt;p&gt;&amp;gt; I wonder why this happened.&lt;/p&gt;

&lt;p&gt;readBytes on less than a buffer size probably only happens with binary (or compressed) fields, relatively new additions to Lucene, so it probably didn&apos;t have much of a real-world impact.   I think it is important to fix though, as more things may be byte-oriented in the future.&lt;/p&gt;

&lt;p&gt;After applying the patch, at least one unit test fails:&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase: testReadPastEOF(org.apache.lucene.index.TestCompoundFile):&lt;br/&gt;
        FAILED&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Block read past end of file&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: Block read past end of file&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt;     at org.apache.lucene.index.TestCompoundFile.testReadPastEOF(Test&lt;br/&gt;
CompoundFile.java:616)&lt;/p&gt;</comment>
                    <comment id="12444322" author="nyh" created="Tue, 24 Oct 2006 15:34:41 +0100"  >&lt;p&gt;Sorry, I didn&apos;t notice that my fix broke this unit test. Thanks for catching that.&lt;/p&gt;

&lt;p&gt;What is happening is interesting: this test (TestCompoundFile.testReadPastEof()) is testing what happens when you read 40 bytes beyond the end of file, and expects the appropriate exception to be thrown. The old code actually did this for 40 bytes, so it passed this test, but the interesting thing is that when you asked for more than a buffer-full of bytes, say, 10K, the length() checking code was not there! So the old code was broken in this respect, just not for 40 bytes which were tested.&lt;/p&gt;

&lt;p&gt;I&apos;ll fix my patch to add this beyond-end-of-file check, and will post the new patch ASAP.&lt;/p&gt;</comment>
                    <comment id="12444342" author="nyh" created="Tue, 24 Oct 2006 16:35:29 +0100"  >&lt;p&gt;A fixed patch, which now checks that we don&apos;t read past of of file. This is now checked correctly in all three cases (1. data already in the buffer, 2. small number of bytes in addition to buffer 3. large number of bytes in addition to the buffer).&lt;/p&gt;

&lt;p&gt;Note that the original code (before my patch) did not check length()  for large number of bytes, only in refill() (which was only called for a small number of bytes). This code now checks in this case as well, so it is more correct than it was.&lt;/p&gt;

&lt;p&gt;The TestCompoundFile test now passes, and I also added to my new BufferedIndexInput unit test a third test case, testEOF, which tests that we can read up to EOF, but not past it. This test tests that small overflows (a few bytes) and very large overflows both throw an exception.&lt;/p&gt;

&lt;p&gt;I also made another change in this patch which I wish I didn&apos;t have to make, to account for other unit tests: One unit test assumed that readBytes() can work if given a null array, if the length requested is 0. Unfortunately, System.arraycopy doesn&apos;t share this permiscousity, so I had to add another silly if(len&amp;gt;0) test in the readBytes() code.&lt;/p&gt;</comment>
                    <comment id="12444350" author="yseeley@gmail.com" created="Tue, 24 Oct 2006 16:55:18 +0100"  >&lt;p&gt;&amp;gt; One unit test assumed that readBytes() can work if given a null array, if the length requested is 0. Unfortunately,&lt;br/&gt;
&amp;gt; System.arraycopy doesn&apos;t share this permiscousity, so I had to add another silly if(len&amp;gt;0) test in the readBytes() &lt;br/&gt;
&amp;gt; code.&lt;/p&gt;

&lt;p&gt;If &quot;given&quot; a null array?  Is this ever done in Lucene?  Which should be fixed, the testcase or the code?&lt;/p&gt;</comment>
                    <comment id="12444903" author="nyh" created="Thu, 26 Oct 2006 15:22:10 +0100"  >&lt;p&gt;&amp;gt; If &quot;given&quot; a null array? Is this ever done in Lucene? Which should be fixed, the testcase or the code? &lt;/p&gt;

&lt;p&gt;I don&apos;t know - readBytes() documentation doesn&apos;t explictly say what should happen if it is asked to read zero bytes: is it simply supposed to do nothing (and in this case it doesn&apos;t matter which array you give it - could even be null), or should it still expect the array to be non-null? I don&apos;t know if any code in Lucene itself assumes that it can work when given a null array and a 0 count - I doubt it. But one test does assume this, so I simply added an extra &quot;if&quot; to check for the 0 count, and when that happens, avoid calling System.arraycopy() (which even when the count is 0, expects the array to be non-null, for some reason).&lt;/p&gt;</comment>
                    <comment id="12445026" author="yseeley@gmail.com" created="Thu, 26 Oct 2006 23:25:56 +0100"  >&lt;p&gt;Committed.  Thanks Nadav!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12343553" name="readbytes.patch" size="7434" author="nyh" created="Tue, 24 Oct 2006 16:35:29 +0100" />
                    <attachment id="12343524" name="readbytes.patch" size="5740" author="nyh" created="Tue, 24 Oct 2006 10:52:57 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 24 Oct 2006 13:58:54 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13057</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27035</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>