<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:09:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-276/LUCENE-276.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-276] Memory leak when sorting</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-276</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is the same post I sended two days before to the Lucene user&apos;s list. This &lt;br/&gt;
bug seems to have something in common with bug no. 30628 but that bug is closed &lt;br/&gt;
as invalid.&lt;/p&gt;

&lt;p&gt;I&apos;m sending test code that everyone can try. The code is singular, don&apos;t say &lt;br/&gt;
there is no sense in reopening the same index. I can only show, that reopening &lt;br/&gt;
leaks memory. The index is filled by pseudo-real data, they aren&apos;t significant &lt;br/&gt;
and the process of index creation as well. &lt;/p&gt;

&lt;p&gt;The problem must be in field caching code used by sort.&lt;/p&gt;

&lt;p&gt;Affected versions of Lucene:&lt;br/&gt;
1.4.1&lt;br/&gt;
CVS 1.5-rc1-dev&lt;/p&gt;

&lt;p&gt;This code survives only few first iterations if you run java with -Xmx5m. With &lt;br/&gt;
Lucene 1.4-final ends regulary.&lt;/p&gt;

&lt;p&gt;import org.apache.lucene.analysis.standard.StandardAnalyzer;&lt;br/&gt;
import org.apache.lucene.document.Document;&lt;br/&gt;
import org.apache.lucene.document.Field;&lt;br/&gt;
import org.apache.lucene.index.IndexReader;&lt;br/&gt;
import org.apache.lucene.index.IndexWriter;&lt;br/&gt;
import org.apache.lucene.index.Term;&lt;br/&gt;
import org.apache.lucene.search.Hits;&lt;br/&gt;
import org.apache.lucene.search.IndexSearcher;&lt;br/&gt;
import org.apache.lucene.search.Searcher;&lt;br/&gt;
import org.apache.lucene.search.Sort;&lt;br/&gt;
import org.apache.lucene.search.SortField;&lt;br/&gt;
import org.apache.lucene.search.TermQuery;&lt;br/&gt;
import org.apache.lucene.store.Directory;&lt;br/&gt;
import org.apache.lucene.store.RAMDirectory;&lt;/p&gt;

&lt;p&gt;import java.io.IOException;&lt;br/&gt;
import java.text.SimpleDateFormat;&lt;br/&gt;
import java.util.Calendar;&lt;br/&gt;
import java.util.Date;&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Run this test with Lucene 1.4.1 and -Xmx5m&lt;br/&gt;
 */&lt;br/&gt;
public class ReopenTest&lt;br/&gt;
{&lt;br/&gt;
    private static long mem_last = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    public static void main(String[] args) throws IOException&lt;br/&gt;
    {&lt;br/&gt;
        Directory directory = create_index();&lt;/p&gt;

&lt;p&gt;        for (int i = 1; i &amp;lt; 100; i++) &lt;/p&gt;
{
            System.err.println(&quot;loop &quot; + i + &quot;, index version: &quot; + IndexReader.
getCurrentVersion(directory));
            search_index(directory);
            add_to_index(directory, i);
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    private static void add_to_index(Directory directory, int i) throws &lt;br/&gt;
IOException&lt;/p&gt;
    {
        IndexWriter writer = new IndexWriter(directory, new StandardAnalyzer(), 
false);

        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Document doc = new Document();

        doc.add(Field.Keyword(&quot;date&quot;, 
          df.format(new Date(System.currentTimeMillis()))));
        doc.add(Field.Keyword(&quot;id&quot;, &quot;CD&quot; + String.valueOf(i)));
        doc.add(Field.Text(&quot;text&quot;, &quot;Tohle neni text &quot; + i));
        writer.addDocument(doc);

        System.err.println(&quot;index size: &quot; + writer.docCount());
        writer.close();
    }

&lt;p&gt;    private static void search_index(Directory directory) throws IOException&lt;br/&gt;
    {&lt;br/&gt;
        IndexReader reader = IndexReader.open(directory);&lt;br/&gt;
        Searcher searcher = new IndexSearcher(reader);&lt;/p&gt;

&lt;p&gt;        print_mem(&quot;search 1&quot;);&lt;br/&gt;
        SortField[] fields = new SortField&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;;&lt;br/&gt;
        fields&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = new SortField(&quot;date&quot;, SortField.STRING, true);&lt;br/&gt;
        fields&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; = new SortField(&quot;id&quot;, SortField.STRING, false);&lt;br/&gt;
        Sort sort = new Sort(fields);&lt;br/&gt;
        TermQuery query = new TermQuery(new Term(&quot;text&quot;, &quot;\&quot;text 5\&quot;&quot;));&lt;/p&gt;

&lt;p&gt;        print_mem(&quot;search 2&quot;);&lt;br/&gt;
        Hits hits = searcher.search(query, sort);&lt;br/&gt;
        print_mem(&quot;search 3&quot;);&lt;/p&gt;

&lt;p&gt;        for (int i = 0; i &amp;lt; hits.length(); i++) &lt;/p&gt;
{
            Document doc = hits.doc(i);
            System.out.println(&quot;doc &quot; + i + &quot;: &quot; + doc.toString());
        }
&lt;p&gt;        print_mem(&quot;search 4&quot;);&lt;br/&gt;
        searcher.close();&lt;br/&gt;
        reader.close();&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;    private static void print_mem(String log)&lt;/p&gt;
    {
        long mem_free = Runtime.getRuntime().freeMemory();
        long mem_total = Runtime.getRuntime().totalMemory();
        long mem_max = Runtime.getRuntime().maxMemory();

        long delta = (mem_last - mem_free) * -1;

        System.out.println(log + &quot;= delta: &quot; + delta + &quot;, free: &quot; + mem_free + 
&quot;, used: &quot; + (mem_total-mem_free) + &quot;, total: &quot; + mem_total + &quot;, max: &quot; + 
mem_max);

        mem_last = mem_free;
    }

&lt;p&gt;    private static Directory create_index() throws IOException&lt;br/&gt;
    {&lt;br/&gt;
        print_mem(&quot;create 1&quot;);&lt;br/&gt;
        Directory directory = new RAMDirectory();&lt;/p&gt;

&lt;p&gt;        Calendar c = Calendar.getInstance();&lt;br/&gt;
        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);&lt;br/&gt;
        IndexWriter writer = new IndexWriter(directory, new StandardAnalyzer(), &lt;br/&gt;
true);&lt;br/&gt;
        for (int i = 0; i &amp;lt; 365 * 15; i++) &lt;/p&gt;
{
            Document doc = new Document();

            doc.add(Field.Keyword(&quot;date&quot;, 
               df.format(new Date(c.getTimeInMillis()))));
            doc.add(Field.Keyword(&quot;id&quot;, &quot;AB&quot; + String.valueOf(i)));
            doc.add(Field.Text(&quot;text&quot;, &quot;Tohle je text &quot; + i));
            writer.addDocument(doc);

            doc = new Document();

            doc.add(Field.Keyword(&quot;date&quot;, 
               df.format(new Date(c.getTimeInMillis()))));
            doc.add(Field.Keyword(&quot;id&quot;, &quot;ef&quot; + String.valueOf(i)));
            doc.add(Field.Text(&quot;text&quot;, &quot;Je tohle text &quot; + i));
            writer.addDocument(doc);

            c.add(Calendar.DAY_OF_YEAR, 1);
        }
&lt;p&gt;        writer.optimize();&lt;br/&gt;
        System.err.println(&quot;index size: &quot; + writer.docCount());&lt;br/&gt;
        writer.close();&lt;/p&gt;

&lt;p&gt;        print_mem(&quot;create 2&quot;);&lt;br/&gt;
        return directory;&lt;br/&gt;
    }&lt;br/&gt;
}&lt;/p&gt;</description>
                <environment>&lt;p&gt;Operating System: All&lt;br/&gt;
Platform: All&lt;/p&gt;</environment>
            <key id="12314426">LUCENE-276</key>
            <summary>Memory leak when sorting</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="java-dev@lucene.apache.org">Lucene Developers</assignee>
                                <reporter username="kuhn@fg.cz">Jiri Kuhn</reporter>
                        <labels>
                    </labels>
                <created>Wed, 15 Sep 2004 19:40:37 +0100</created>
                <updated>Sat, 27 May 2006 02:38:11 +0100</updated>
                    <resolved>Sat, 27 May 2006 02:38:11 +0100</resolved>
                            <version>1.4</version>
                                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12321900" author="daniel.naber@t-online.de" created="Thu, 16 Sep 2004 06:16:42 +0100"  >&lt;p&gt;See here for some analysis: &lt;br/&gt;
&lt;a href=&quot;http://www.mail-archive.com/lucene-user%40jakarta.apache.org/msg09462.html&quot; class=&quot;external-link&quot;&gt;http://www.mail-archive.com/lucene-user%40jakarta.apache.org/msg09462.html&lt;/a&gt; &lt;/p&gt;</comment>
                    <comment id="12321901" author="spencer@jstor.org" created="Mon, 27 Sep 2004 21:26:51 +0100"  >&lt;p&gt;We also see this bug in Lucene 1.4.1, but NOT in 1.4.1 RC3.&lt;/p&gt;</comment>
                    <comment id="12321902" author="spencer@jstor.org" created="Mon, 27 Sep 2004 21:58:41 +0100"  >&lt;p&gt;Never mind.  We had internal confusion about version numbering.  I was looking&lt;br/&gt;
at 1.4RC3.&lt;/p&gt;</comment>
                    <comment id="12321903" author="rafal@caltha.pl" created="Wed, 29 Sep 2004 19:33:37 +0100"  >&lt;p&gt;Created an attachment (id=12890)&lt;br/&gt;
patch that fixes the problem made against CVS HEAD as of September 29th&lt;/p&gt;</comment>
                    <comment id="12321904" author="rafal@caltha.pl" created="Wed, 29 Sep 2004 19:34:39 +0100"  >&lt;p&gt;Created an attachment (id=12891)&lt;br/&gt;
patch that fixes the problem made against 1.4.1 release&lt;/p&gt;</comment>
                    <comment id="12321905" author="rafal@caltha.pl" created="Wed, 29 Sep 2004 19:41:07 +0100"  >&lt;p&gt;Comparator cache entries couldn&apos;t ever go away because IndexReader objects used&lt;br/&gt;
as weak referenced keys were strong-references by the very same&lt;br/&gt;
WeakHashMap$Entry object. This was because IndexReader was referenced from an&lt;br/&gt;
instance variable of the Comparator objects - an implicit one because final&lt;br/&gt;
IndexReader reader argument of comparator* method is used inside Comparator&lt;br/&gt;
object initialization. Moving initialization of the fieldOrder/index variables&lt;br/&gt;
outside object initialization eliminates the implicit reader field, thus&lt;br/&gt;
allowing IndexReader object&apos;s to be GCd correctly.&lt;/p&gt;</comment>
                    <comment id="12321906" author="goller@detego-software.de" created="Wed, 29 Sep 2004 23:18:21 +0100"  >&lt;p&gt;Thanks for the patch. I did not verify whether it solves the memory leak problem.&lt;br/&gt;
However, I committed the changes (and did an analog chance in&lt;br/&gt;
SortComparator.java) since they definitely cannot do any harm. Daniel agreed to&lt;br/&gt;
make some tests soon.&lt;br/&gt;
If positive, he will close the bug.&lt;/p&gt;

&lt;p&gt;Christoph&lt;/p&gt;</comment>
                    <comment id="12321907" author="daniel.naber@t-online.de" created="Thu, 30 Sep 2004 03:47:57 +0100"  >&lt;p&gt;Thanks, the patch works, i.e. the test case doesn&apos;t throw out of memory &lt;br/&gt;
anymore. The patch has been applied to CVS (HEAD branch). &lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12312390" name="ASF.LICENSE.NOT.GRANTED--lucene-31240-1.4.1.diff" size="2592" author="rafal@caltha.pl" created="Wed, 29 Sep 2004 19:34:39 +0100" />
                    <attachment id="12312389" name="ASF.LICENSE.NOT.GRANTED--lucene-31240-29092004.diff" size="2592" author="rafal@caltha.pl" created="Wed, 29 Sep 2004 19:33:37 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_10010" key="com.atlassian.jira.plugin.system.customfieldtypes:importid">
                <customfieldname>Bugzilla Id</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>31240</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 16 Sep 2004 05:16:42 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>13473</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>27455</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>