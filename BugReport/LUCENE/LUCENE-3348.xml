<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:17:18 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3348/LUCENE-3348.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3348] IndexWriter applies wrong deletes during concurrent flush-all</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3348</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Yonik uncovered this with the TestRealTimeGet test: if a flush-all is&lt;br/&gt;
underway, it is possible for an incoming update to pick a DWPT that is&lt;br/&gt;
stale, ie, not yet pulled/marked for flushing, yet the DW has cutover&lt;br/&gt;
to a new deletes queue.  If this happens, and the deleted term was&lt;br/&gt;
also updated in one of the non-stale DWPTs, then the wrong document is&lt;br/&gt;
deleted and the test fails by detecting the wrong value.&lt;/p&gt;

&lt;p&gt;There&apos;s a 2nd failure mode that I haven&apos;t figured out yet, whereby 2&lt;br/&gt;
docs are returned when searching by id (there should only ever be 1&lt;br/&gt;
doc since the test uses updateDocument which is atomic wrt&lt;br/&gt;
commit/reopen).&lt;/p&gt;

&lt;p&gt;Yonik verified the test passes pre-DWPT, so my guess is (but I&lt;br/&gt;
have yet to verify) this test also passes on 3.x.  I&apos;ll backport&lt;br/&gt;
the test to 3.x to be sure.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12515680">LUCENE-3348</key>
            <summary>IndexWriter applies wrong deletes during concurrent flush-all</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="simonw">Simon Willnauer</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Thu, 28 Jul 2011 18:16:43 +0100</created>
                <updated>Fri, 10 May 2013 11:42:56 +0100</updated>
                    <resolved>Wed, 10 Aug 2011 08:37:11 +0100</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="13072436" author="mikemccand" created="Thu, 28 Jul 2011 18:39:24 +0100"  >&lt;p&gt;Initial patch, tons of nocommits still but tests pass.&lt;/p&gt;

&lt;p&gt;I moved the Lucene-only test over to oal.index, and added VERBOSE&lt;br/&gt;
prints.&lt;/p&gt;

&lt;p&gt;I made an initial possible fix for the first failure, which seems to&lt;br/&gt;
work (I don&apos;t seem to hit that failure anymore).  I&apos;m not sure I like&lt;br/&gt;
the fix... basically, after pulling the DWPT for indexing, I check if&lt;br/&gt;
it&apos;s stale, and if so call a new method in DWFlushControl to move that&lt;br/&gt;
DWPT into the toFlush list.  I think it&apos;d be better to somehow, up&lt;br/&gt;
front in flush-all, mark all current DWPTs as stale, pull them out of&lt;br/&gt;
rotation, so that the thread pool would never return such a stale&lt;br/&gt;
DWPT.&lt;/p&gt;

&lt;p&gt;Still trying to understand the 2nd failure...&lt;/p&gt;</comment>
                    <comment id="13072509" author="simonw" created="Thu, 28 Jul 2011 21:06:18 +0100"  >&lt;p&gt;mike, patch looks good. one little think, you should check if the DWPT is already pending before calling #setFlushPending(DWPT).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I think it&apos;d be better to somehow, up&lt;br/&gt;
front in flush-all, mark all current DWPTs as stale, pull them out of&lt;br/&gt;
rotation, so that the thread pool would never return such a stale&lt;br/&gt;
DWPT.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;the problem here is that you need to lock all the states that are selected for flushing. at the same time an indexing thread could lock such a DWPT and index a document which causes the problem this issues tries to solve. If you sync the thread pools getAndLock method this could work but in the non-blocking approach I think this is the only way to prevent this.&lt;/p&gt;</comment>
                    <comment id="13072523" author="mikemccand" created="Thu, 28 Jul 2011 21:44:55 +0100"  >&lt;p&gt;OK I&apos;ll make sure it&apos;s not already pending.&lt;/p&gt;
</comment>
                    <comment id="13072599" author="mikemccand" created="Fri, 29 Jul 2011 00:28:42 +0100"  >&lt;p&gt;The 2nd bug seems to be because a commit() is running concurrently with a getReader(), and the flush-all being done for the getReader() is making a newly flushed segment visible to the SegmentInfos just before commit clones the SegmentInfos, and the buffered deletes have not been fully processed yet at the point for that new segment (and for segments before it).&lt;/p&gt;

&lt;p&gt;You can see it in IW.prepareCommit &amp;#8211; we call flush(true, true) and then startCommit w/o any sync, so in there a concurrent getReader can sneak in a change to the segmentInfos so that an updateDocument appears non-atomic.&lt;/p&gt;</comment>
                    <comment id="13072962" author="jasonrutherglen" created="Fri, 29 Jul 2011 19:34:23 +0100"  >&lt;p&gt;Sorry to add my opinion to this, however I think that while non-blocking deletes are quite fancy, it seems they are  open to various bugs such as this.  Is there a compelling reason non-locking is used, eg, performance?&lt;/p&gt;</comment>
                    <comment id="13072968" author="simonw" created="Fri, 29 Jul 2011 19:49:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;Sorry to add my opinion to this, however I think that while non-blocking deletes are quite fancy, it seems they are open to various bugs such as this. Is there a compelling reason non-locking is used, eg, performance?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Jason, this issue is unrelated to non-blocking deletes. The bug here is in concurrent flush which is indeed the main performance factor in DWPT. &lt;/p&gt;</comment>
                    <comment id="13073071" author="mikemccand" created="Sat, 30 Jul 2011 00:33:27 +0100"  >&lt;p&gt;Another patch, I think fixing the 2nd issue by doing a custom flush&lt;br/&gt;
inside prepareCommit, that clones &amp;amp; incRefs the flushed SegmentInfos&lt;br/&gt;
inside a sync block so that we get a consistent point-in-time commit.&lt;/p&gt;

&lt;p&gt;I also fixed a test deadlock caused by the fix for the first issue &amp;#8211;&lt;br/&gt;
have to handle the case where the DWPT is null because close is in&lt;br/&gt;
process.&lt;/p&gt;

&lt;p&gt;I also evil&apos;d up the TestStressNRT by randomizing everything, and&lt;br/&gt;
fixed RIW to sometimes pull an NRT reader after doing a commit just to&lt;br/&gt;
mix that up.&lt;/p&gt;

&lt;p&gt;The test seems to pass now; I think it&apos;s ready to commit... but I&apos;ll let it beast a while more...&lt;/p&gt;</comment>
                    <comment id="13073332" author="simonw" created="Sun, 31 Jul 2011 09:08:48 +0100"  >&lt;p&gt;mike, patch looks good. some thoughts:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;can we factor out the while(true)
{.. getAndLock(thread, DW) .. }
&lt;p&gt; to prevent this code duplication?&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;you throw a NPE if the DWPT is null, yet this is handled by ThreadState#isActive() and calls ensureOpen() to throw consistent exception when IW is closed like further down you see:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!perThread.isActive()) {
  ensureOpen();
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;: &lt;span class=&quot;code-quote&quot;&gt;&quot;perThread is not active but we are still open&quot;&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think this will also solve the deadlock issue you describing above, no?&lt;/p&gt;

&lt;p&gt;thanks for taking care of this, another proof that concurrency is not easy &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                    <comment id="13073535" author="mikemccand" created="Mon, 1 Aug 2011 14:44:54 +0100"  >&lt;p&gt;Thanks Simon; I&apos;ll make both of those fixes.&lt;/p&gt;

&lt;p&gt;Unfortunately there is still at least one more thread safety issue that I&apos;m trying to track down... beasting uncovered a good seed.&lt;/p&gt;</comment>
                    <comment id="13073556" author="simonw" created="Mon, 1 Aug 2011 15:30:09 +0100"  >&lt;blockquote&gt;&lt;p&gt;Unfortunately there is still at least one more thread safety issue that I&apos;m trying to track down... beasting uncovered a good seed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;argh! can you post it here?&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="13073586" author="mikemccand" created="Mon, 1 Aug 2011 17:02:07 +0100"  >&lt;p&gt;Current patch, but still at least another concurrency issue.&lt;/p&gt;</comment>
                    <comment id="13073588" author="mikemccand" created="Mon, 1 Aug 2011 17:05:09 +0100"  >&lt;p&gt;Here&apos;s what I run with the while1 tester in luceneutil: &lt;tt&gt;TestStressNRT -iters 3 -verbose -seed -6208047570437556381:-3138230871915238634&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;I think what&apos;s special about the seed is maxBufferedDocs is 3, so we are doing tons of segment flushing.  I dumbed back the test somewhat (turned off merging entirely, only 1 reader thread, up to 5 writer threads, and it still fails.&lt;/p&gt;</comment>
                    <comment id="13073678" author="simonw" created="Mon, 1 Aug 2011 20:31:04 +0100"  >&lt;p&gt;mike I can not reproduce this failure.. what exactly is failing there? maybe you can put the output in a text file and attache it?&lt;/p&gt;

&lt;p&gt;Regarding the latest patch, I think we can call DWFlushControl#addFlushableState() from DWFlushControl#markForFullFlush() and use a global list to collect the DWPT for the full flush. &lt;/p&gt;

&lt;p&gt;I think we should move the getAndLock call into DWFlushControl something like DWFlushControl#obtainAndLock(), this would allow us to make the check and the DWFlushControl#addFlushableState() method private to DWFC. Further we can also simplify the deleteQueue check a little since we already obtained a ThreadState we don&apos;t need to unlock the state again after calling addFlushableState(), something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ThreadState obtainAndLock() {
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ThreadState perThread = perThreadPool.getAndLock(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;
        .currentThread(), documentsWriter);
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (perThread.isActive()
        &amp;amp;&amp;amp; perThread.perThread.deleteQueue != documentsWriter.deleteQueue) {
      &lt;span class=&quot;code-comment&quot;&gt;// There is a flush-all in process and &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; DWPT is
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// now stale -- enroll it &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; flush and &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;
&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// another DWPT:
&lt;/span&gt;      addFlushableState(perThread);
    }
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; perThread;
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Eventually we are spending too much time in full flush since we lock all ThreadStates at least once while some indexing threads might have already helped out with swapping out DWPT instances. I think we can collect already swapped out ThreadStates during a full flush and only check the ones that have not been processed? &lt;/p&gt;</comment>
                    <comment id="13073802" author="mikemccand" created="Mon, 1 Aug 2011 22:42:09 +0100"  >&lt;p&gt;Full output from a failure.&lt;/p&gt;</comment>
                    <comment id="13073804" author="mikemccand" created="Mon, 1 Aug 2011 22:43:33 +0100"  >&lt;p&gt;OK I attached output of a failure &amp;#8211; it&apos;s 400K lines.  Search for the AssertionError, where id:26 couldn&apos;t find a doc nor tombstone.&lt;/p&gt;</comment>
                    <comment id="13079434" author="mikemccand" created="Thu, 4 Aug 2011 17:08:40 +0100"  >&lt;p&gt;Simon found one case that could result in a delete becoming visible before a previous updateDocument.  I made that fix (to DW.applyAllDeletes) but unfortunately there&apos;s still a failure (see fail2.txt.bz2).&lt;/p&gt;</comment>
                    <comment id="13079814" author="simonw" created="Fri, 5 Aug 2011 08:39:26 +0100"  >&lt;p&gt;I think I now know what is causing the failure here. In IW#prepareCommit(Map) we release the full flush (docWriter.finishFullFlush(success)&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; before we apply the deletes. This means that another thread can start flushing and freeze &amp;amp; push its global deletes into the BufferedDeleteStream before we call IW#maybeApplyDeletes(). if a flush is fast enough (small segment) and something else causes the committing thread to wait on the IW in order to apply the deletes a del-packet could sneak in not belonging to the commit. I IW#getReader this is already handled correctly. &lt;/p&gt;
</comment>
                    <comment id="13080045" author="mikemccand" created="Fri, 5 Aug 2011 17:09:32 +0100"  >&lt;p&gt;I think you are right!  I will fix prepareCommit to match getReader and re-beast.&lt;/p&gt;</comment>
                    <comment id="13080177" author="mikemccand" created="Fri, 5 Aug 2011 20:48:58 +0100"  >&lt;p&gt;Patch, incorporating Simon&apos;s last suggestion.  I think this fixes the concurrency bugs &amp;#8211; beasting for 2703 iterations so far and no failure!&lt;/p&gt;

&lt;p&gt;Not quite committable &amp;#8211; lots of added SOPs.  I&apos;ll be out next week so won&apos;t get to this until I&apos;m back so feel free to clean it up and commit!&lt;/p&gt;</comment>
                    <comment id="13080210" author="simonw" created="Fri, 5 Aug 2011 21:44:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;Patch, incorporating Simon&apos;s last suggestion. I think this fixes the concurrency bugs &#8211; beasting for 2703 iterations so far and no failure!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;awesome! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Not quite committable &#8211; lots of added SOPs. I&apos;ll be out next week so won&apos;t get to this until I&apos;m back so feel free to clean it up and commit!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Mike, I will assign this to me and get it committable next week. &lt;/p&gt;

&lt;p&gt;Thanks, have a good time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13080226" author="mikemccand" created="Fri, 5 Aug 2011 22:04:41 +0100"  >&lt;p&gt;Thanks Simon!  Also I didn&apos;t implement your suggestion above (putting the new code into DWTC.obtainAndLock), but I think we should!&lt;/p&gt;</comment>
                    <comment id="13080939" author="simonw" created="Mon, 8 Aug 2011 14:30:35 +0100"  >&lt;p&gt;here is a cleaned up patch with all the fixes. I beasted the seed for 3k times no failure and run 5k random iteration without a failure. I think we are good to go here.&lt;/p&gt;</comment>
                    <comment id="13081038" author="yseeley@gmail.com" created="Mon, 8 Aug 2011 17:39:23 +0100"  >&lt;p&gt;Tricky stuff... great job of tracking all these concurrency issues down!&lt;br/&gt;
I tweaked the test (more variability in number of threads, etc) and it&apos;s been running for 2 hours w/ no failures.&lt;/p&gt;</comment>
                    <comment id="13081166" author="simonw" created="Mon, 8 Aug 2011 21:20:34 +0100"  >&lt;p&gt;I am planning to commit this tomorrow if nobody objects&lt;/p&gt;</comment>
                    <comment id="13081187" author="markrmiller@gmail.com" created="Mon, 8 Aug 2011 21:54:47 +0100"  >&lt;p&gt;+1 - thanks for ferreting these concurrency issues out!&lt;/p&gt;</comment>
                    <comment id="13081553" author="simonw" created="Tue, 9 Aug 2011 11:22:54 +0100"  >&lt;p&gt;Committed to trunk in revision 1155278.&lt;br/&gt;
I backported the test to 3.x and it failed. Maybe something is wrong with the test though, I will dig! Here is the failure: &lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    [junit] ------------- Standard Output ---------------
    [junit] FAIL: hits id:34 val=-38
    [junit]   docID=43 id:-34 foundVal=38
    [junit] READER3: FAILED: unexpected exception
    [junit] java.lang.AssertionError: id=34 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.junit.Assert.fail(Assert.java:91)
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:345)
    [junit] FAIL: hits id:25 val=39
    [junit]   docID=24 id:25 foundVal=39
    [junit]   docID=85 id:25 foundVal=43
    [junit] READER1: FAILED: unexpected exception
    [junit] java.lang.AssertionError: id=25 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.junit.Assert.fail(Assert.java:91)
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:345)
    [junit] ------------- ---------------- ---------------
    [junit] ------------- Standard Error -----------------
    [junit] NOTE: reproduce with: ant test -Dtestcase=TestStressNRT -Dtestmethod=test -Dtests.seed=-78c35b20c01ed2f8:-292d76adf99900e2:3f7c8696906a10c7
    [junit] NOTE: reproduce with: ant test -Dtestcase=TestStressNRT -Dtestmethod=test -Dtests.seed=-78c35b20c01ed2f8:-292d76adf99900e2:3f7c8696906a10c7
    [junit] The following exceptions were thrown by threads:
    [junit] *** Thread: READER3 ***
    [junit] java.lang.RuntimeException: java.lang.AssertionError: id=34 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:360)
    [junit] Caused by: java.lang.AssertionError: id=34 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.junit.Assert.fail(Assert.java:91)
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:345)
    [junit] *** Thread: READER1 ***
    [junit] java.lang.RuntimeException: java.lang.AssertionError: id=25 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:360)
    [junit] Caused by: java.lang.AssertionError: id=25 reader=ReadOnlyDirectoryReader(segments_q _2l(3.4):cv62/13 _2p(3.4):Cv6 _2o(3.4):cv47) totalHits=2
    [junit] 	at org.junit.Assert.fail(Assert.java:91)
    [junit] 	at org.apache.lucene.index.TestStressNRT$2.run(TestStressNRT.java:345)
    [junit] NOTE: test params are: locale=fr_BE, timezone=EET
    [junit] NOTE: all tests run in this JVM:
    [junit] [TestCharFilter, TestClassicAnalyzer, TestKeywordAnalyzer, TestStandardAnalyzer, TestBinaryDocument, TestAtomicUpdate, TestConcurrentMergeScheduler, TestDeletionPolicy, TestDirectoryReader, TestDoc, TestLazyProxSkipping, TestMultiLevelSkipList, TestPerSegmentDeletes, TestSameTokenSamePosition, TestStressNRT]
    [junit] NOTE: Linux 2.6.35-30-generic amd64/Sun Microsystems Inc. 1.6.0_26 (64-bit)/cpus=12,threads=1,free=286656336,total=352714752
    [junit] ------------- ---------------- ---------------

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13082213" author="simonw" created="Wed, 10 Aug 2011 08:43:53 +0100"  >&lt;p&gt;FYI - I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3368&quot; title=&quot;IndexWriter commits update documents without corresponding delete&quot;&gt;&lt;del&gt;LUCENE-3368&lt;/del&gt;&lt;/a&gt; to track the failures in 3.x and backported the test together with the fix.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12489357" name="fail2.txt.bz2" size="131954" author="mikemccand" created="Thu, 4 Aug 2011 17:08:40 +0100" />
                    <attachment id="12488469" name="fail.txt.bz2" size="853055" author="mikemccand" created="Mon, 1 Aug 2011 22:42:09 +0100" />
                    <attachment id="12489685" name="LUCENE-3348.patch" size="57206" author="simonw" created="Mon, 8 Aug 2011 14:30:35 +0100" />
                    <attachment id="12489526" name="LUCENE-3348.patch" size="59643" author="mikemccand" created="Fri, 5 Aug 2011 20:48:58 +0100" />
                    <attachment id="12489356" name="LUCENE-3348.patch" size="56932" author="mikemccand" created="Thu, 4 Aug 2011 17:08:40 +0100" />
                    <attachment id="12488413" name="LUCENE-3348.patch" size="55626" author="mikemccand" created="Mon, 1 Aug 2011 17:02:07 +0100" />
                    <attachment id="12488266" name="LUCENE-3348.patch" size="48711" author="mikemccand" created="Sat, 30 Jul 2011 00:33:27 +0100" />
                    <attachment id="12488117" name="LUCENE-3348.patch" size="31306" author="mikemccand" created="Thu, 28 Jul 2011 18:39:24 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 28 Jul 2011 20:06:18 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2738</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24348</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>