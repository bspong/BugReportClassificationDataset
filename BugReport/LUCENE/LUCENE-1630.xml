<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:13:58 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1630/LUCENE-1630.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1630] Mating Collector and Scorer on doc Id orderness</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1630</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This is a spin off of &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1593&quot; title=&quot;Optimizations to TopScoreDocCollector and TopFieldCollector&quot;&gt;&lt;del&gt;LUCENE-1593&lt;/del&gt;&lt;/a&gt;. This issue proposes to expose appropriate API on Scorer and Collector such that one can create an optimized Collector based on a given Scorer&apos;s doc-id orderness and vice versa. Copied from &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1593&quot; title=&quot;Optimizations to TopScoreDocCollector and TopFieldCollector&quot;&gt;&lt;del&gt;LUCENE-1593&lt;/del&gt;&lt;/a&gt;, here is the list of changes:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Deprecate Weight and create QueryWeight (abstract class) with a new scorer(reader, scoreDocsInOrder), replacing the current scorer(reader) method. QueryWeight implements Weight, while score(reader) calls score(reader, false /* out-of-order */) and scorer(reader, scoreDocsInOrder) is defined abstract.
	&lt;ul&gt;
		&lt;li&gt;Also add QueryWeightWrapper to wrap a given Weight implementation. This one will also be deprecated, as well as package-private.&lt;/li&gt;
		&lt;li&gt;Add to Query variants of createWeight and weight which return QueryWeight. For now, I prefer to add a default impl which wraps the Weight variant instead of overriding in all Query extensions, and in 3.0 when we remove the Weight variants - override in all extending classes.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Add to Scorer isOutOfOrder with a default to false, and override in BS to true.&lt;/li&gt;
	&lt;li&gt;Modify BooleanWeight to extend QueryWeight and implement the new scorer method to return BS2 or BS based on the number of required scorers and setAllowOutOfOrder.&lt;/li&gt;
	&lt;li&gt;Add to Collector an abstract &lt;em&gt;acceptsDocsOutOfOrder&lt;/em&gt; which returns true/false.
	&lt;ul&gt;
		&lt;li&gt;Use it in IndexSearcher.search methods, that accept a Collector, in order to create the appropriate Scorer, using the new QueryWeight.&lt;/li&gt;
		&lt;li&gt;Provide a static create method to TFC and TSDC which accept this as an argument and creates the proper instance.&lt;/li&gt;
		&lt;li&gt;Wherever we create a Collector (TSDC or TFC), always ask for out-of-order Scorer and check on the resulting Scorer isOutOfOrder(), so that we can create the optimized Collector instance.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Modify IndexSearcher to use all of the above logic.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The only class I&apos;m worried about, and would like to verify with you, is Searchable. If we want to deprecate all the search methods on IndexSearcher, Searcher and Searchable which accept Weight and add new ones which accept QueryWeight, we must do the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Deprecate Searchable in favor of Searcher.&lt;/li&gt;
	&lt;li&gt;Add to Searcher the new QueryWeight variants. Here we have two choices: (1) break back-compat and add them as abstract (like we&apos;ve done with the new Collector method) or (2) add them with a default impl to call the Weight versions, documenting these will become abstract in 3.0.&lt;/li&gt;
	&lt;li&gt;Have Searcher extend UnicastRemoteObject and have RemoteSearchable extend Searcher. That&apos;s the part I&apos;m a little bit worried about - Searchable implements java.rmi.Remote, which means there could be an implementation out there which implements Searchable and extends something different than UnicastRemoteObject, like Activeable. I think there is very small chance this has actually happened, but would like to confirm with you guys first.&lt;/li&gt;
	&lt;li&gt;Add a deprecated, package-private, SearchableWrapper which extends Searcher and delegates all calls to the Searchable member.&lt;/li&gt;
	&lt;li&gt;Deprecate all uses of Searchable and add Searcher instead, defaulting the old ones to use SearchableWrapper.&lt;/li&gt;
	&lt;li&gt;Make all the necessary changes to IndexSearcher, MultiSearcher etc. regarding overriding these new methods.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One other optimization that was discussed in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1593&quot; title=&quot;Optimizations to TopScoreDocCollector and TopFieldCollector&quot;&gt;&lt;del&gt;LUCENE-1593&lt;/del&gt;&lt;/a&gt; is to expose a topScorer() API (on Weight) which returns a Scorer that its score(Collector) will be called, and additionally add a start() method to DISI. That will allow Scorers to initialize either on start() or score(Collector). This was proposed mainly because of BS and BS2 which check if they are initialized in every call to next(), skipTo() and score(). Personally I prefer to see that in a separate issue, following that one (as it might add methods to QueryWeight).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12424750">LUCENE-1630</key>
            <summary>Mating Collector and Scorer on doc Id orderness</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Wed, 6 May 2009 21:12:03 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:24 +0100</updated>
                    <resolved>Sat, 27 Jun 2009 12:15:01 +0100</resolved>
                                            <fixVersion>2.9</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12715484" author="shaie" created="Tue, 2 Jun 2009 12:29:22 +0100"  >&lt;p&gt;I want to start working on that once &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1614&quot; title=&quot;Add next() and skipTo() variants to DocIdSetIterator that return the current doc, instead of boolean&quot;&gt;&lt;del&gt;LUCENE-1614&lt;/del&gt;&lt;/a&gt; is resolved. In the meantime, I&apos;d like to discuss whether we should define a topScorer() method on Weight, or have Weight introduce a score(Collector) method.&lt;br/&gt;
I think I prefer the latter since even if I call topScorer and get back a Scorer, nothing prevents me from iterating on the Scorer, rather than calling its score(Collector) method. Also, we can deprecate Scorer.score(Collector), and come up w/ another one which is package-private.&lt;/p&gt;

&lt;p&gt;Another thing that was brought up by Mavin:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you make QueryWeight a subclass of Query, do you need any new methods?&lt;/p&gt;

&lt;p&gt;Before Weight existed, only Query and Scorer existed. Compiling a Scorer&lt;br/&gt;
involved &quot;weighting the query&quot;, by factoring IDF etc, then calling&lt;br/&gt;
query.Scorer().  To make Query objects reusable, Weight was introduced as an&lt;br/&gt;
intermediate stage.  Making QueryWeight a subclass of Query would be entirely&lt;br/&gt;
within the spirit of the original design, since the role played by Weight was&lt;br/&gt;
originally performed by a Query.&lt;/p&gt;

&lt;p&gt;Marvin Humphrey&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Today Weight exposes only few methods, and I don&apos;t want to have to implement some of Query methods, just because QueryWeight (the replacement of Weight) will subclass Query. But I don&apos;t know enough about what led to that decision.&lt;/p&gt;

&lt;p&gt;To me, it&apos;d be ok to get rid of Weight entirely and just have Query and Scorer, while Query.scorer() do whatever Weight does today. But Marvin mentions reusing Query objects (which I don&apos;t fully understand what that means - is it reusing the instance or the code), so I&apos;d like to hear your thoughts.&lt;/p&gt;

&lt;p&gt;If we do get rid of Weight, or make QueryWeight a subclass of Query, it will simplify the Searcher API.&lt;/p&gt;</comment>
                    <comment id="12715497" author="earwin" created="Tue, 2 Jun 2009 12:53:49 +0100"  >&lt;blockquote&gt;&lt;p&gt;To me, it&apos;d be ok to get rid of Weight entirely and just have Query and Scorer, while Query.scorer() do whatever Weight does today. But Marvin mentions reusing Query objects (which I don&apos;t fully understand what that means - is it reusing the instance or the code), so I&apos;d like to hear your thoughts.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As far as my understanding goes:&lt;br/&gt;
Query is reusable instance-wise. Weight is a Query primed with index-dependent stuff, like freqs that are used to calculate the score. Scorer is something that actually iterates on the docs and does the scoring.&lt;br/&gt;
With per-segment collection you usually get a Query, produce a Weight from it using toplevel IR (most likely MSR), so you have freqs for the whole index, and then get a Scorer for each of the segments and iterate on them.&lt;br/&gt;
I don&apos;t see how you can get freqs from toplevel reader and iterate on lower-level reader if you merge Weight and Score.&lt;br/&gt;
Merging Weight and Query back is something I don&apos;t like too - I use a huge bunch of pre-parsed Queries that are run against ever-different indexes.&lt;/p&gt;</comment>
                    <comment id="12715503" author="shaie" created="Tue, 2 Jun 2009 13:12:22 +0100"  >&lt;p&gt;Thanks for the explanation.&lt;/p&gt;

&lt;p&gt;Couldn&apos;t we can merge Weight with Query in a way that you could still reuse the Query instance? Weight has 6 methods:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;getQuery will not be required anymore.&lt;/li&gt;
	&lt;li&gt;getValue/sumOfSquareWeigths/normalize - I think these can be part of Query.&lt;/li&gt;
	&lt;li&gt;scorer/explain - can be part of Query and we keep on passing an IndexReader.&lt;br/&gt;
Though I admit I haven&apos;t checked all Weight implementations, I think this can work?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If not, then I believe Marvin&apos;s idea to have QueryWeight subclass Query, was to simplify the Searcher API. We can still do that w/o having QW subclass Q, by for example expose only a Weight API on Searcher? Eventually, all the Query search() variants call a Weight variant.&lt;/p&gt;

&lt;p&gt;I just think that sub-classing Q by QW is not the right way, just for them to have the same super type ... So if we can&apos;t get rid of Weight and stuff all in Query, I think we should stay with the Query, QueryWeight, Scorer separation.&lt;/p&gt;</comment>
                    <comment id="12715509" author="earwin" created="Tue, 2 Jun 2009 13:41:23 +0100"  >&lt;p&gt;You can&apos;t, because Weights produced from same Query are different for different indexes.&lt;br/&gt;
You can probably modify Query inplace for a given index, produce some scorers, do scoring, then modify Query for another index, produce scorers, etc..&lt;br/&gt;
But now your Query is no longer thread-safe, and I can&apos;t reuse it from different threads.&lt;/p&gt;

&lt;p&gt;So with all its strange looks the trio of Q, W, S is still the best approach if you ask me.&lt;/p&gt;</comment>
                    <comment id="12715516" author="shaie" created="Tue, 2 Jun 2009 14:03:39 +0100"  >&lt;blockquote&gt;&lt;p&gt;So with all its strange looks the trio of Q, W, S is still the best approach if you ask me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok, I think I&apos;m convinced. Weight looks like it makes reusing a Query instance easier.&lt;/p&gt;

&lt;p&gt;So how about my other proposal, to get rid of Query-based search methods in Searcher, and stick w/ QueryWeight only? Maybe even add on Searcher a method createWeight(Query) if that&apos;s needed.&lt;/p&gt;</comment>
                    <comment id="12715973" author="earwin" created="Wed, 3 Jun 2009 17:24:50 +0100"  >&lt;p&gt;Searcher is supposed to be a little cherry of userfriendliness atop a glass of Lucene murky internals, ain&apos;t it?&lt;br/&gt;
I mean, even you had to be explained the ways of Query, Weight and Scorer, what would a Lucene neophyte do if we remove his beloved convenience methods?&lt;/p&gt;</comment>
                    <comment id="12718436" author="shaie" created="Thu, 11 Jun 2009 13:54:12 +0100"  >&lt;p&gt;Over in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1407&quot; title=&quot;Refactor Searchable to not have RMI Remote dependency&quot;&gt;&lt;del&gt;LUCENE-1407&lt;/del&gt;&lt;/a&gt; I made some comments about deprecating Searchable and moving RMI out from core. It looks like we have a problem - Today RemoteSearchable implements Searchalbe (and by inheritance java.rmi.Remote) as well as extend UnicastRemoteObject. That&apos;s because a class has to extend a concrete Remote class, or implement a concrete Remote sub-interface.&lt;/p&gt;

&lt;p&gt;After refactoring, it will need to extend both Searcher and UnicastRemoteObject. Unless we make Searcher extend UnicastRemoteObject, but that will bring the RMI stuff back into core.&lt;/p&gt;

&lt;p&gt;So either I leave Searchable around, and add a new QueryWeight variant method to it, or we make Searcher extend UnicastRemoteObject and at a later point have RemoteSearchable include some concrete implementation of RemoteServer (i.e., implement on our own, when it&apos;s in contrib) and then remove the extension of UnicastRemoteObject by Searcher.&lt;/p&gt;

&lt;p&gt;Regarding back-compat, due to the Collector work we already made changes to the interface as well as Searcher, so I don&apos;t think that should worry us.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="12718632" author="shaie" created="Thu, 11 Jun 2009 21:44:29 +0100"  >&lt;p&gt;Given the changes in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1407&quot; title=&quot;Refactor Searchable to not have RMI Remote dependency&quot;&gt;&lt;del&gt;LUCENE-1407&lt;/del&gt;&lt;/a&gt;, I don&apos;t think we can deprecate Searchable, but instead change it to include the new QueryWeight methods. Either that or breaking Weight to include the new needed methods.&lt;/p&gt;

&lt;p&gt;I lean towards breaking Searchable, since I think there&apos;s a much larger chance that there are Weight implementations out there, but only few Searchable/Searcher. And the migration is really simple - just add another method which accepts QueryWeight, and have the Weight variant call the other method with QueryWeightWrapper.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;MultiSearcher also expects Searchable ... Maybe we should just make Searchable package-private (in 3.0)? That way it will only be extended by RemoteSearchable. MultiSearcher can then move to work w/ Searcher, and have a package-private ctor which accepts Searchable, just in case someone wants to use RemoteSearchable.&lt;/p&gt;

&lt;p&gt;I&apos;d like to post a patch soon, so any comments are welcome.&lt;/p&gt;</comment>
                    <comment id="12718959" author="mikemccand" created="Fri, 12 Jun 2009 21:02:43 +0100"  >&lt;p&gt;We could simply declare, going forward, that we may add methods to Searchable?&lt;/p&gt;

&lt;p&gt;Or... instead of moving RemoteSearchable out to contrib/remote, we could simply remove it, and state that apps should move to their own means of remoting searching (or, use Solr)?&lt;/p&gt;</comment>
                    <comment id="12718963" author="simonw" created="Fri, 12 Jun 2009 21:13:38 +0100"  >&lt;p&gt;Keep in mind that it is easier to include a contrib jar than moving an existing infrastructure to Solr. &lt;br/&gt;
We can still add methods to Searchable and define another interface in contrib/remote. still easier than moving to solr for some people. I&apos;m not an RMI friend but based on all the back conpat discussions we should try to misplease everybody equally.&lt;/p&gt;

&lt;p&gt;simon&lt;/p&gt;</comment>
                    <comment id="12718968" author="shaie" created="Fri, 12 Jun 2009 21:37:11 +0100"  >&lt;p&gt;My plan was to deprecate Searchable and make it package-private in 3.0. That way, we can enjoy both worlds - change Searchable as we want, and use it internally for RemoteSearchable as well as MultiSearcher. We can even not add the new QueryWeight variants to it at this point, since the class will be marked deprecated. We only need them in Searcher.&lt;/p&gt;</comment>
                    <comment id="12719188" author="yseeley@gmail.com" created="Sat, 13 Jun 2009 23:21:05 +0100"  >&lt;blockquote&gt;&lt;p&gt;We could simply declare, going forward, that we may add methods to Searchable? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like this approach - there are super-expert classes like this that most don&apos;t override or implement, but some do.  It seems better for all involved if it&apos;s allowed to stay public with suitable disclaimers and less stringent back compat.&lt;/p&gt;</comment>
                    <comment id="12719243" author="shaie" created="Sun, 14 Jun 2009 11:23:23 +0100"  >&lt;p&gt;If that&apos;s agreed, then I&apos;ll do it and put a NOTE in its javadocs. I&apos;ll also remove some deprecated methods (Collector vs. HitCollector). I don&apos;t know if I should keep the Weight methods around and change them to QueryWeight in 3.0, or do the change now. Just want to minimize the noise.&lt;/p&gt;</comment>
                    <comment id="12719535" author="shaie" created="Mon, 15 Jun 2009 13:14:22 +0100"  >&lt;p&gt;Ok I was just about to post the patch, when the Spatial tests failed. After some investigation, I found out the following, and would appreciate your suggestions. IndexSearcher.search(QueryWeight weight, Filter filter, final int nDocs, Sort sort, boolean fillFields) I wrote the following code:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to create a Scorer in out-of-order mode, just to know which TFC
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// version to instantiate.
&lt;/span&gt;    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; docsScoredInOrder = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subReaders.length &amp;gt; 0) {
      docsScoredInOrder = !weight.scorer(subReaders[0], &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;).scoresOutOfOrder();
    }
    TopFieldCollector collector = TopFieldCollector.create(sort, nDocs,
        fillFields, fieldSortDoTrackScores, fieldSortDoMaxScore, docsScoredInOrder);
    search(weight, filter, collector);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For clarification - I need to know which TFC instance to create (in-order / out-of-order). For that, I need to first create a Scorer, asking for out-of-order one, and then check whether the Scorer is indeed an out-of-order or not. That&apos;s a dummy Scorer, as I never use it afterwards, but since we didn&apos;t want to add scoresOutOfOrder to Weight, but Scorer, I don&apos;t have any other choice.&lt;/p&gt;

&lt;p&gt;For Spatial, this creates a problem. One of the tests uses ConstantScoreQuery and passes in a Filter. CSQ.scorer() creates a new Scorer and uses the given Filter as reference. In Spatial, every time Filter.getDocIdSet() is called, the internal filter populates a WeakHashMap of distances (with the doc id as key), and doesn&apos;t clear it between invocations. It also updates the &quot;base&quot; of the key to handle multiple readers. Therefore the docs of the first reader are added twice - once for the dummy invocation and the second time since the &quot;base&quot; is updated (LatLongDistanceFilter.java, line 222) to reader.maxDoc().&lt;/p&gt;

&lt;p&gt;I tried to create a new &quot;distances&quot; map on every invocation, but then another test fails. I don&apos;t know this code very well, and I don&apos;t know which is the best solution:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Complicate the code in IndexSearcher to create a Scorer, then collect it and then proceed w/ iterating on the readers, from the 2nd forward. This is a real ugly change, I tried it and quickly reverted. It also breaks the current beauty of having all the search methods call search(Weight, Filter, Collector).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fix LatLongDistanceFilter code to check if reader.maxDoc() == nextOffset, then do nextOffset -= reader.maxDoc(). This is not pretty either, since it assumes a certain implementation and use of it, which I don&apos;t like either.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Add scoresOutOfOrder to Weight, but I don&apos;t know if we want to add this &quot;knowledge&quot; to Weight, and it fits nicely in Scorer.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Any suggestions? perhaps a different fix to Spatial?&lt;/p&gt;</comment>
                    <comment id="12719539" author="earwin" created="Mon, 15 Jun 2009 13:34:10 +0100"  >&lt;p&gt;I like the last option (move scoresOutOfOrder to Weight) most. Creating dummy scorer looks ugly to me, and looks like it will cause more problems of the same kind in the future.&lt;/p&gt;</comment>
                    <comment id="12719640" author="shaie" created="Mon, 15 Jun 2009 17:53:35 +0100"  >&lt;p&gt;ok - let&apos;s start iterating on the patch. Anyone volunteer to accept it (and then I&apos;ll update CHANGES &quot;via ?&quot;)?&lt;/p&gt;

&lt;p&gt;Patch include:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;QueryWeight with the new scorer(IndexReader, soreDocsInOrder, topScorer) and scoresOutOfOrder().&lt;/li&gt;
	&lt;li&gt;Added methods to Searcher (this breaks back-compat, but it&apos;s already broken here because of 1575).&lt;/li&gt;
	&lt;li&gt;BooleanWeight now creates BS or BS2 up front, and therefore BS2&apos;s code is simplified.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All tests pass.&lt;/p&gt;</comment>
                    <comment id="12719992" author="shaie" created="Tue, 16 Jun 2009 10:00:33 +0100"  >&lt;p&gt;Changed Query.createQueryWeight to public, as was suggested by Yonik. All tests pass.&lt;/p&gt;

&lt;p&gt;Still no volunteers? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12720280" author="mikemccand" created="Tue, 16 Jun 2009 19:35:44 +0100"  >&lt;p&gt;Patch looks good!&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;There are some new javadoc warnings (wrong links)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Maybe, in changes, add that BooleanQuery will now score docs out&lt;br/&gt;
    of order when used with a Collector that can accept docs out of&lt;br/&gt;
    order?  Ie this is a good ootb perf gain for or queries, sorting&lt;br/&gt;
    by field or score.&lt;br/&gt;
.&lt;br/&gt;
    Oh, ugh, it seems we don&apos;t actually do that today (because we&lt;br/&gt;
    respect the static setting).  Hmm.  Can&apos;t we change that static&lt;br/&gt;
    default (BooleanQuery.allowDocsOutOfOrder) to true?  Because, our&lt;br/&gt;
    core collectors can handle it, and any custom collector will by&lt;br/&gt;
    default say it cannot handle it so there wouldn&apos;t be a break in&lt;br/&gt;
    back compat?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;That&apos;s a nice cleanup, seeing BooleanQuery decide which scorer&lt;br/&gt;
    impl to return &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We don&apos;t need the &quot; = null&quot; initializer on&lt;br/&gt;
    BooleanScorer2.countingSumScorer&apos;s decl&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can we make Collector.supportsDocsOutOfOrder abstract?  Defaulting&lt;br/&gt;
    to false isn&apos;t great (I&apos;d rather subclass think about the&lt;br/&gt;
    question).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can we rename Collector.supportsDocsOutOfOrder -&amp;gt;&lt;br/&gt;
    acceptsDocsOutOfOrder?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can we also make QueryWeight.scoresOutOfOrder abstract?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;CustomScoreQuery.scoresOutOfOrder should only look at its&lt;br/&gt;
    subQueryWeight?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;If a given Scorer.scoresOutOfOrder returns true, does that mean&lt;br/&gt;
    nextDoc is allowed to return docs out of order?  How is advance&lt;br/&gt;
    defined for such scorers?  (BooleanScore does this, and its&lt;br/&gt;
    advance throws UOE).  Maybe we allow this but advance may not&lt;br/&gt;
    work for such scorers?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Should scoresOutOfOrder() move from QueryWeight --&amp;gt; Scorer?  I may&lt;br/&gt;
    call QueryWeight.scorer with scoreDocsInOrder=false, but many will&lt;br/&gt;
    in fact return a scorer that does score docs in order (eg BQ does&lt;br/&gt;
    this depending on what kind fo clauses, and how many, it has), and&lt;br/&gt;
    we could then pick a faster collector in such cases?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Shouldn&apos;t DisjunctionMaxQuery pass true for scoreDocsInOrder when&lt;br/&gt;
    asking its sub-queries for their scorers?  Ie even if its callee&lt;br/&gt;
    allow out-of-order scoring, it requires in-order of its children?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think DisjunctionMaxQuery.scoresOutOfOrder should simply return&lt;br/&gt;
    false? &lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Actually I think the way to factor the static setting in is&lt;br/&gt;
    backwards?  Shouldn&apos;t it be &lt;tt&gt;scoreDocsInOrder |= !allowDocsOutOfOrder&lt;/tt&gt;?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you sharpen the javadocs for boolean topScorer param?  Ie, &quot;if&lt;br/&gt;
    true, score(Collector) will be called; if false, nextDoc/advance&lt;br/&gt;
    will be called&quot;.  (I found myself momentarily wondering if&lt;br/&gt;
    DocumentWriter&apos;s usage of Scorer API was a topScorer).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Shouldn&apos;t Searchable cutover to QueryWeight too?  (We are keeping&lt;br/&gt;
    Searchable, but allowing changes to it)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Nice catch, removing Searchable&apos;s now-wrong NOTE about scoring&lt;br/&gt;
    when sorting by field!&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12720477" author="shaie" created="Wed, 17 Jun 2009 03:50:10 +0100"  >&lt;p&gt;Thanks for the review Mike. Answers below. The comments which I did not answer will be fixed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can we make Collector.supportsDocsOutOfOrder abstract? Defaulting to false isn&apos;t great (I&apos;d rather subclass think about the question).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In general, I tried to avoid it since that would require changing all core Collectors. There aren&apos;t many, but still ...&lt;/p&gt;

&lt;p&gt;This goes for QueryWeight.scoresOutOfOrder - wanted to avoid changing all core Weights to impl the method w/ &quot;return false&quot;. I actually think that many Weights/Scorers do score documents in-order, hence the default impl.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If a given Scorer.scoresOutOfOrder returns true, does that mean nextDoc is allowed to return docs out of order?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When you deal with a Scorer which returns out-of-order, you can only call scorer.score(Collector). If you&apos;re going to iterate, you&apos;re going to have to create a Scorer in-order, and that&apos;s what IndexSearcher does. I&apos;ll spell it out clearly in the javadocs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Should scoresOutOfOrder() move from QueryWeight --&amp;gt; Scorer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;ve discussed it few posts up. When this information in in Scorer, I should first ask for a Scorer, and only then I can create a Collector. If I&apos;ll use the Scorer immediately, then that&apos;ll be ok. However, that&apos;s not the case in IndexSearcher, and results in a bug in Spatial, and unless we want to uglify IndexSearcher code, it seemed that this can sit in QueryWeight.&lt;/p&gt;

&lt;p&gt;But I do think it&apos;s a problematic method in QW too, since if it returns false by default, I&apos;ll create a Collector which expects docs in-order, but then I&apos;d lose the optimization in BooleanWeight which may return an out-of-order superior Scorer. If I return true, I&apos;ll create a Collector which expects out-of-order, and the Scorer (again, an example from BW) may be actually in-order, and I&apos;ve wasted unnecessary &apos;if doc &amp;gt; topDoc&apos; cycles.&lt;/p&gt;

&lt;p&gt;So I don&apos;t know what&apos;s better: make IndexSearcher code more complicated or sacrifice a potential loss of this optimization?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Actually I think the way to factor the static setting in is backwards? Shouldn&apos;t it be scoreDocsInOrder |= !allowDocsOutOfOrder?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, nice catch &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Shouldn&apos;t Searchable cutover to QueryWeight too? (We are keeping Searchable, but allowing changes to it)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wrote that above too - I don&apos;t think we can declare and execute right in 2.9 that Searchable can be changed unexpectedly. So I added a NOTE to its javadocs and thought to do the change post 2.9, when we remove Weight. We&apos;d be forced to change these methods to QueryWeight, and fix RemoteSearchable too. And it will be consistent w/ our back-compat policy (at least the part where we declare on an upcoming change before it happens).&lt;/p&gt;

&lt;p&gt;But if you think otherwise, I don&apos;t mind deprecating and adding new methods (I&apos;ve got used to it already, I almost do it blindly &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;

&lt;p&gt;I&apos;ll fix the other comments, and post a patch back after we resolve the remaining open issues.&lt;/p&gt;</comment>
                    <comment id="12720548" author="shaie" created="Wed, 17 Jun 2009 09:11:28 +0100"  >&lt;p&gt;Fixed most of your comments Mike. I also noticed I did not document Collector.acceptsDocsOutOfOrder, so fixed that too.&lt;/p&gt;

&lt;p&gt;The remaining things we should agree on are:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;deprecated Weight and add QueryWeight variants to Searchable. I prefer to do it post 2.9.&lt;/li&gt;
	&lt;li&gt;move scoresDocsOutOfOrder to Scorer instead of Weight. I fixed BooleanWeight to return true if there is a chance it will return BS (i.e. there are no required clauses and &amp;lt;32 prohibited clauses). I guess we&apos;ll need to discuss that one more.&lt;/li&gt;
	&lt;li&gt;Make Collector.acceptsDocsOutOfOrder and QueryWeight.scoresDocsOutOfOrder abstract - I think the default impl makes sense for most of the imps out there and the ones in core, but I don&apos;t have a strong feeling against making it abstract.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All tests pass, and javadocs are good as well.&lt;/p&gt;</comment>
                    <comment id="12720607" author="mikemccand" created="Wed, 17 Jun 2009 11:28:07 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Can we make Collector.supportsDocsOutOfOrder abstract? Defaulting to false isn&apos;t great (I&apos;d rather subclass think about the question).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In general, I tried to avoid it since that would require changing all core Collectors. There aren&apos;t many, but still ...&lt;/p&gt;

&lt;p&gt;This goes for QueryWeight.scoresOutOfOrder - wanted to avoid changing all core Weights to impl the method w/ &quot;return false&quot;. I actually think that many Weights/Scorers do score documents in-order, hence the default impl.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK... thinking more about it, I think having&lt;br/&gt;
QueryWeight.scoresDocsOutOfOrder default to &quot;false&quot; is reasonable (I&lt;br/&gt;
think most do in-order scoring).  Also, I think the perf gains are&lt;br/&gt;
relatively small if a QueryWeight returns &quot;true&quot;, so, by defaulting to&lt;br/&gt;
false we&apos;re not leaving much performance on the table.&lt;/p&gt;

&lt;p&gt;But for Collector it&apos;s a different story: the gains by allowing&lt;br/&gt;
BooleanQuery to use its out-of-order scorer are sizable.  And, I&apos;d&lt;br/&gt;
expect many custom Collectors would be fine with out-of-order&lt;br/&gt;
collection.&lt;/p&gt;

&lt;p&gt;Since these are brand new classes, we have the chance to do it well.&lt;br/&gt;
It&apos;s very much an expert thing already to make your own Collector...&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;If a given Scorer.scoresOutOfOrder returns true, does that mean nextDoc is allowed to return docs out of order?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;When you deal with a Scorer which returns out-of-order, you can only call scorer.score(Collector). If you&apos;re going to iterate, you&apos;re going to have to create a Scorer in-order, and that&apos;s what IndexSearcher does. I&apos;ll spell it out clearly in the javadocs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That may be a bit too strong &amp;#8211; eg BooleanScorer lets you nextDoc()&lt;br/&gt;
your way through its out-of-order docs (just not advance()).  Maybe&lt;br/&gt;
state just that you can&apos;t use advance in the javadocs?&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Should scoresOutOfOrder() move from QueryWeight --&amp;gt; Scorer?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;ve discussed it few posts up. When this information in in Scorer, I should first ask for a Scorer, and only then I can create a Collector. If I&apos;ll use the Scorer immediately, then that&apos;ll be ok. However, that&apos;s not the case in IndexSearcher, and results in a bug in Spatial, and unless we want to uglify IndexSearcher code, it seemed that this can sit in QueryWeight.&lt;/p&gt;

&lt;p&gt;But I do think it&apos;s a problematic method in QW too, since if it returns false by default, I&apos;ll create a Collector which expects docs in-order, but then I&apos;d lose the optimization in BooleanWeight which may return an out-of-order superior Scorer. If I return true, I&apos;ll create a Collector which expects out-of-order, and the Scorer (again, an example from BW) may be actually in-order, and I&apos;ve wasted unnecessary &apos;if doc &amp;gt; topDoc&apos; cycles.&lt;/p&gt;

&lt;p&gt;So I don&apos;t know what&apos;s better: make IndexSearcher code more complicated or sacrifice a potential loss of this optimization?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Could we &quot;invert&quot; the logic in IndexSearcher that makes a collector,&lt;br/&gt;
eg by creating a utility class that will on-demand provide a collector&lt;br/&gt;
once told whether the docs will be in order?  Basically, &quot;curry&quot; all&lt;br/&gt;
the other details about the collector (sorting by score vs field, if&lt;br/&gt;
by field whether to track scores &amp;amp; max score).  Then inside doSearch&lt;br/&gt;
when we finally know if the Scorer will be in-order, we ask that&lt;br/&gt;
helper class for the collector?  The first time the helper class is&lt;br/&gt;
called, it makes the collector; subsequent times it returns the same&lt;br/&gt;
one.&lt;/p&gt;

&lt;p&gt;There is a risk, though, if the Scorer returned for a given segment&lt;br/&gt;
&quot;changes its mind&quot;... eg the first segment&apos;s scorer says the docs will&lt;br/&gt;
be in order, and then some later segment&apos;s scorer says they will not&lt;br/&gt;
be in order.  So... that&apos;s risky.&lt;/p&gt;

&lt;p&gt;Maybe we leave it on QueryWeight, but fix BooleanWeight to return&lt;br/&gt;
exactly the right thing?  (It can be exact, right?  Because we know&lt;br/&gt;
the conditions under which BooleanWeight, if allowed to do so, would&lt;br/&gt;
choose to return an out-of-order scorer).&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Shouldn&apos;t Searchable cutover to QueryWeight too? (We are keeping Searchable, but allowing changes to it)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I wrote that above too - I don&apos;t think we can declare and execute right in 2.9 that Searchable can be changed unexpectedly. So I added a NOTE to its javadocs and thought to do the change post 2.9, when we remove Weight. We&apos;d be forced to change these methods to QueryWeight, and fix RemoteSearchable too. And it will be consistent w/ our back-compat policy (at least the part where we declare on an upcoming change before it happens).&lt;/p&gt;

&lt;p&gt;But if you think otherwise, I don&apos;t mind deprecating and adding new methods (I&apos;ve got used to it already, I almost do it blindly  ).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Sorry, I&amp;#39;m losing track of all the comments&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;OK let&apos;s defer the changes to Searchable until 3.1.  Make sure you&lt;br/&gt;
open a follow-on issue so we remember &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12720612" author="shaie" created="Wed, 17 Jun 2009 11:49:01 +0100"  >&lt;p&gt;Ok I will change acceptsDocsOutOfOrder on Collector to abstract, and implement it in all core collectors.&lt;/p&gt;

&lt;p&gt;I&apos;ve already changed BooleanWeight&apos;s impl, as I wrote above &quot;I fixed BooleanWeight to return true if there is a chance it will return BS (i.e. there are no required clauses and &amp;lt;32 prohibited clauses)&quot;.&lt;/p&gt;

&lt;p&gt;I still don&apos;t think scoresOutOfOrder can live on Scorer. IndexSearcher&apos;s search methods all call eventually to search(QueryWeight, Filter, Collector), which means that by that time you should already have a Collector ready (note that the user may pass its own Collector). Therefore such a utility will not work for user provided collectors, and specifically this method creates a Scorer for a given reader, but never a Collector (and a Collector is created just once).&lt;/p&gt;

&lt;p&gt;So if we were to take your approach, it&apos;d deviate the &quot;fast search methods&quot; from the other search methods. The others would call search(Weight, Filter, Collector) and the &quot;fast ones&quot; would not (since they don&apos;t have a Collector yet). This will complicate IndexSearcher&apos;s code, IMO unnecessarily. If we want to differentiate the two, I can do that w/o a helper class.&lt;/p&gt;</comment>
                    <comment id="12720619" author="earwin" created="Wed, 17 Jun 2009 12:01:20 +0100"  >&lt;p&gt;I wasn&apos;t following the issue closely, so this question might by silly - how does out-of-order scoring/collection marry with filters?&lt;br/&gt;
If I remember right, filter/scorer intersection relies on proper orderness.&lt;/p&gt;</comment>
                    <comment id="12720622" author="shaie" created="Wed, 17 Jun 2009 12:04:47 +0100"  >&lt;p&gt;It isn&apos;t and that&apos;s what I expressed in the javadocs. If you plan to iterate on a Scorer, you should always ask for in-order one, and that&apos;s what IndexSearcher does. Mike suggested above to refine that documentation to say that if you plan to call nextDoc() only, you can still ask for an out-of-order scorer.&lt;/p&gt;</comment>
                    <comment id="12720623" author="mikemccand" created="Wed, 17 Jun 2009 12:05:45 +0100"  >&lt;p&gt;Still working through the patch... here&apos;s what I found so far:&lt;/p&gt;


&lt;ul&gt;
	&lt;li&gt;You forgot to fill in the &quot;?&quot; in CHANGES &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you change the default for BooleanQuery.allowDocsOutOfOrder to&lt;br/&gt;
    true?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;How come {{Document doc(int n, FieldSelector fieldSelector) throws&lt;br/&gt;
    CorruptIndexException, IOException}} is added to Searcher.java in&lt;br/&gt;
    your patch?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Rethinking fixing Searchable now vs later: first off, we&apos;ve&lt;br/&gt;
    already changed the interface in 2.9 (added Collector); second&lt;br/&gt;
    off, in our changes with Fieldable we both changed our policy and&lt;br/&gt;
    the interface, in one release.  Maybe we should in fact switch to&lt;br/&gt;
    QueryWeight?  (I&apos;m not sure).  This patch already breaks back&lt;br/&gt;
    compat of Searcher (there are new abstract methods), anyway.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Instead of saying &quot;there is a chance&quot; in the javadoc in BQ, can&lt;br/&gt;
    you change it to say &quot;BQ will return an out-of-order scorer if&lt;br/&gt;
    requested&quot;?  (There&apos;s no chance in the matter...).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In fact, DocumentsWriter very much needs for the docs to be scored&lt;br/&gt;
    in order (it breaks out of the loop on the first out-of-bounds&lt;br/&gt;
    doc).  Can you put that back?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;As much as I love all the little code cleanups, can you resist the&lt;br/&gt;
    temptation, especially in such large patches as this?  I think a&lt;br/&gt;
    separate issue that does pure code cleanups would be a great way&lt;br/&gt;
    to fix these, going forward...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;&quot;not need anymore&quot; --&amp;gt; &quot;not needed anymore&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We can now make things final in BS2, like countingSumScorer,&lt;br/&gt;
    *Scorers, etc?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12720629" author="shaie" created="Wed, 17 Jun 2009 12:32:36 +0100"  >&lt;blockquote&gt;&lt;p&gt;You forgot to fill in the &quot;?&quot; in CHANGES&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I guess you&apos;re looking at the previous patch. It already has your name in the latest &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;How come &lt;tt&gt;Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException&lt;/tt&gt; is added to Searcher.java in your patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s leftover from when I first deprecated Searchable - I wanted to move all the methods from Searchable to Searcher so that we don&apos;t forget that later. Will remove it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Rethinking fixing Searchable now vs later&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ok I will do that. Deprecate the current ones and add new ones. We need to keep the Weight-variant methods in, since someone might call it. If he doesn&apos;t extend Searcher or implement Searchable, there&apos;s no real break in back-compat for him.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As much as I love all the little code cleanups&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Apologies ... I&apos;ll try to restrain myself. That&apos;s why I didn&apos;t want to make Collector.accepts..() abstract - it would force me to touch more files, which means more code cleanups &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I&apos;ll do my best to stop.&lt;/p&gt;</comment>
                    <comment id="12720632" author="shaie" created="Wed, 17 Jun 2009 12:44:28 +0100"  >&lt;blockquote&gt;
&lt;p&gt;    You forgot to fill in the &quot;?&quot; in CHANGES&lt;/p&gt;

&lt;p&gt;I guess you&apos;re looking at the previous patch. It already has your name in the latest &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, you&apos;re right - there are two sections in CHANGES which I&apos;ve added text to, and I put your name in the second one only.&lt;/p&gt;</comment>
                    <comment id="12720666" author="shaie" created="Wed, 17 Jun 2009 14:36:15 +0100"  >&lt;ul&gt;
	&lt;li&gt;Collector&apos;s acceptDocsOutOfOrder is abstract - this was a really good change since I completely forgot to override it in all home brewed Collectors to return true where applicable. I also surprised to see that &amp;lt;5 collectors actually should return false (most of them in tests).&lt;/li&gt;
	&lt;li&gt;I added QueryWeight variants to Searchable and implemented in RemoteSearchable.&lt;/li&gt;
	&lt;li&gt;Mike - I&apos;m afraid I did some more code cleanup (not much though) - that was before I saw your last comment. sorry&lt;/li&gt;
	&lt;li&gt;Handled the rest of the latest comments.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All tests pass&lt;/p&gt;</comment>
                    <comment id="12721196" author="mikemccand" created="Thu, 18 Jun 2009 12:13:12 +0100"  >
&lt;ul&gt;
	&lt;li&gt;I wonder if we should have a separate TopScorer class, that&lt;br/&gt;
    doesn&apos;t expose nextDoc/advance methods?  And then a separate&lt;br/&gt;
    QueryWeight.topScorer method instead of a boolean arg to&lt;br/&gt;
    QueryWeight.scorer.  (I&apos;m torn...).  EG, if you get a topScorer,&lt;br/&gt;
    you are not supposed to call nextDoc/advance on it, so it really&lt;br/&gt;
    feels like it wants to be a different class than Scorer...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Update CHANGES entry based on iterations on the patch&lt;br/&gt;
    (eg supportsDocsOutOfOrder --&amp;gt; acceptsDocsOutOfOrder)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can we rename QW.scoresOutOfOrder -&amp;gt; QW.scoresDocsOutOfOrder?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In IndexSearcher ~line 221 shouldn&apos;t was pass &quot;true&quot; for&lt;br/&gt;
    scoresDocsInOrder in &lt;tt&gt;Scorer scorer = weight.scorer(reader, false, true)&lt;/tt&gt;?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;QyertWeight -&amp;gt; QueryWeight&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think CustomScoreQuery.scorer should actually always score docs&lt;br/&gt;
    in order?  So CustomWeight.scoresOutOfOrder should return false?&lt;br/&gt;
    And CustomWeight.scorer should pass &quot;true&quot; for scoreDocsInOrder to&lt;br/&gt;
    all sub-weights?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12721204" author="shaie" created="Thu, 18 Jun 2009 12:34:07 +0100"  >&lt;blockquote&gt;&lt;p&gt;QyertWeight -&amp;gt; QueryWeight&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;ll fix. Can you please next time give me a hint on where did you find it? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I wonder if we should have a separate TopScorer class&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I remember that at some point I suggested to have a score(Searcher, Collector) on QueryWeight, and make Scorer.score(Collector) package-private (of course we&apos;d need to deprecate first and invent a new name). But then I realized that custom weights would still need access to Scorer.score(Collector) if they want to use an existing Scorer or something.&lt;/p&gt;

&lt;p&gt;Taking Scorer.score(Collector) out of Scorer and into TopScorer is a large re-factoring. Are you sure about this? I just think of all the Scorers we have, and out there, that need to impl a new class, and possible duplicate a lot of code that is today shared between the top-level-scorer and iterator-type-scorer.&lt;/p&gt;

&lt;p&gt;I understand what you say &quot;so it really feels like it wants to be a different class than Scorer&quot; - I feel that too. But I don&apos;t see a great ROI here.&lt;/p&gt;</comment>
                    <comment id="12721208" author="shaie" created="Thu, 18 Jun 2009 12:43:22 +0100"  >&lt;blockquote&gt;&lt;p&gt;I think CustomScoreQuery.scorer should actually always score docs in order? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why? I don&apos;t see that it relies on doc id orderness anywhere. What if its subWeight is a BooleanWeight and I use a Collector which accepts docs out-of-order? Will I have a problem if I ask for an out-of-order Scorer?&lt;/p&gt;</comment>
                    <comment id="12721276" author="mikemccand" created="Thu, 18 Jun 2009 15:26:16 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can you please next time give me a hint on where did you find it? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  It&apos;s a quick search through the patch file though &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Taking Scorer.score(Collector) out of Scorer and into TopScorer is a large re-factoring. Are you sure about this? I just think of all the Scorers we have, and out there, that need to impl a new class, and possible duplicate a lot of code that is today shared between the top-level-scorer and iterator-type-scorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m definitely not sure about it...&lt;/p&gt;

&lt;p&gt;For Scorers that don&apos;t have anything special to do when they are &quot;top&quot;, we&apos;d have a default impl (get a non-top Scorer and iterate over it, like Scorer.score now does.  So I think the only weight that&apos;d do something interesting is BooleanQuery&apos;s.&lt;/p&gt;

&lt;p&gt;But I agree this is a big change, so let&apos;s hold off for now?  With search specialization (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1594&quot; title=&quot;Use source code specialization to maximize search performance&quot;&gt;&lt;del&gt;LUCENE-1594&lt;/del&gt;&lt;/a&gt;) the difference between &quot;being top&quot; and &quot;being sub&quot; seems to be more important....&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I think CustomScoreQuery.scorer should actually always score docs in order?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why? I don&apos;t see that it relies on doc id orderness anywhere&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;CustomScorer&apos;s nextDoc uses advance on its subScorers.&lt;/p&gt;</comment>
                    <comment id="12721285" author="shaie" created="Thu, 18 Jun 2009 15:49:17 +0100"  >&lt;blockquote&gt;&lt;p&gt;CustomScorer&apos;s nextDoc uses advance on its subScorers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I noticed that, but thought that out-of-order means a top-scorer usually, and then score(Collector) is called. But now I see CustomScorer does not implement score(Collector) which means it uses Scorer&apos;s, which calls nextDoc() and advance().&lt;/p&gt;

&lt;p&gt;Regarding TopScorer, it&apos;d need to get a Scorer as input, otherwise what would be its default impl for score(Collector)? I thought it should be the current one of Scorer&apos;s.&lt;/p&gt;

&lt;p&gt;Will post a patch soon.&lt;/p&gt;</comment>
                    <comment id="12721291" author="shaie" created="Thu, 18 Jun 2009 16:00:38 +0100"  >&lt;p&gt;Implemented the latest comments, except for TopScorer&lt;/p&gt;</comment>
                    <comment id="12722159" author="mikemccand" created="Sat, 20 Jun 2009 11:01:13 +0100"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;CustomScorer&apos;s nextDoc uses advance on its subScorers.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I noticed that, but thought that out-of-order means a top-scorer usually, and then score(Collector) is called. But now I see CustomScorer does not implement score(Collector) which means it uses Scorer&apos;s, which calls nextDoc() and advance().&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, Scorer&apos;s default impl of &quot;score(Collector)&quot; doesn&apos;t use&lt;br/&gt;
advance() right? &lt;/p&gt;

&lt;p&gt;And so it&apos;s OK to use nextDoc() on a Scorer that returns out-of-order&lt;br/&gt;
docs.  But if you pass topScorer=true, you should not attempt to&lt;br/&gt;
iterate through its docs (I think?).&lt;/p&gt;

&lt;p&gt;Ie, I think &quot;scores docs in order&quot; is somewhat orthogonal to &quot;is top&lt;br/&gt;
scorer&quot;.  I can iterate through nextDocs() that come back out of&lt;br/&gt;
order...&lt;/p&gt;

&lt;p&gt;But, right, CustomScorer&apos;s nextDoc() won&apos;t do the right thing if it&apos;s&lt;br/&gt;
subQueryScorer return docs out of order.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Regarding TopScorer, it&apos;d need to get a Scorer as input, otherwise what would be its default impl for score(Collector)? I thought it should be the current one of Scorer&apos;s.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right I think it&apos;d look roughly something like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
class Scorer() {
  ...
  TopScorer topScorer(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; scoreDocsInOrder) {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TopScorer(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.scorer(scoreDocInOrder));
  }
}

class TopScorer &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Scorer {
  TopScorer() {}
  TopScorer(Scorer sub) {
    collector.setScorer(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; doc;
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; ((doc = nextDoc()) != NO_MORE_DOCS) {
      collector.collect(doc);
    }
  }
  void score(Collector) {
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But, I don&apos;t like having TopScorer extend Scorer; I think we&apos;d have to&lt;br/&gt;
factor out a base class that has the &quot;float score()&quot; method.  Anyway,&lt;br/&gt;
let&apos;s do this later.&lt;/p&gt;</comment>
                    <comment id="12722160" author="mikemccand" created="Sat, 20 Jun 2009 11:02:38 +0100"  >&lt;p&gt;Patch looks good!  I attached a new version w/ some small changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Tweaked javadocs, fixed javadocs warnings, CHANGES&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;It&apos;s nice that this change requires no changes to back-compat branch!&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Pass &quot;false&quot; for topScorer arg in CustomScorer.scorer (instead of&lt;br/&gt;
    threading down the incoming topScorer).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think it&apos;s ready to commit.  I&apos;ll wait a day or two...&lt;/p&gt;</comment>
                    <comment id="12723212" author="shaie" created="Tue, 23 Jun 2009 18:51:21 +0100"  >&lt;p&gt;Mike, after you commit this we should take a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt; - I&apos;m not sure if there was anything left to improve from what we had initially thought to do.&lt;/p&gt;</comment>
                    <comment id="12723229" author="mikemccand" created="Tue, 23 Jun 2009 19:13:13 +0100"  >&lt;p&gt;Thanks Shai!&lt;/p&gt;

&lt;p&gt;Yes, let&apos;s go look @ &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1652&quot; title=&quot;Enhancements to Scorers following the changes to DocIdSetIterator&quot;&gt;&lt;del&gt;LUCENE-1652&lt;/del&gt;&lt;/a&gt; now!&lt;/p&gt;</comment>
                    <comment id="12723976" author="mikemccand" created="Thu, 25 Jun 2009 10:43:41 +0100"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-940&quot; title=&quot;TrieRange support&quot;&gt;&lt;del&gt;SOLR-940&lt;/del&gt;&lt;/a&gt; is hitting an exception due to the addition of QueryWeight:&lt;br/&gt;
because we&apos;ve added default impl for Query.createQueryWeight, that&lt;br/&gt;
throws UOE, users who pass their own Query impls, that haven&apos;t yet&lt;br/&gt;
cutover to createQueryWeight, to BooleanQuery (within BooleanClause)&lt;br/&gt;
will hit this exception:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
SEVERE: java.lang.UnsupportedOperationException
	at org.apache.lucene.search.Query.createQueryWeight(Query.java:102)
	at org.apache.lucene.search.BooleanQuery$BooleanWeight.&amp;lt;init&amp;gt;(BooleanQuery.java:185)
	at org.apache.lucene.search.BooleanQuery.createQueryWeight(BooleanQuery.java:401)
	at org.apache.lucene.search.Query.queryWeight(Query.java:120)
	at org.apache.lucene.search.Searcher.createQueryWeight(Searcher.java:237)
	at org.apache.lucene.search.Searcher.search(Searcher.java:173)
	at org.apache.solr.search.SolrIndexSearcher.getDocListAndSetNC(SolrIndexSearcher.java:1103)
	at org.apache.solr.search.SolrIndexSearcher.getDocListC(SolrIndexSearcher.java:880)
	at org.apache.solr.search.SolrIndexSearcher.search(SolrIndexSearcher.java:341)
	at org.apache.solr.handler.component.QueryComponent.process(QueryComponent.java:176)
	at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:195)
	at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:131)
	at org.apache.solr.core.SolrCore.execute(SolrCore.java:1290)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because BooleanQuery is always calling createQueryWeight of its&lt;br/&gt;
sub-queries.  (Other queries, eg CustomScoreQuery, do so as well).&lt;/p&gt;

&lt;p&gt;I think this is a back-compat break.  Shai, any ideas how to fix this&lt;br/&gt;
so we somehow auto-wrap with QueryWeightWrapper?&lt;/p&gt;

&lt;p&gt;EG, we could have the default impl for createQueryWeight to call&lt;br/&gt;
weight() and wrap it.  The danger is if you subclass Query and fail to&lt;br/&gt;
override either of these methods, we&apos;ve created an infinite recursion.&lt;br/&gt;
(Though, we have precedent here: TokenStream does the same thing).&lt;br/&gt;
Too bad Java doesn&apos;t let you declare that of these 2 methods at least&lt;br/&gt;
one must be overridden.&lt;/p&gt;</comment>
                    <comment id="12723989" author="thetaphi" created="Thu, 25 Jun 2009 10:57:17 +0100"  >&lt;blockquote&gt;
&lt;p&gt;EG, we could have the default impl for createQueryWeight to call&lt;br/&gt;
weight() and wrap it.  The danger is if you subclass Query and fail to&lt;br/&gt;
override either of these methods, we&apos;ve created an infinite recursion.&lt;br/&gt;
(Though, we have precedent here: TokenStream does the same thing).&lt;br/&gt;
Too bad Java doesn&apos;t let you declare that of these 2 methods at least&lt;br/&gt;
one must be overridden.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;(Though, we have precedent here: TokenStream does the same thing).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;With my newest TokenStream improvements (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1693&quot; title=&quot;AttributeSource/TokenStream API improvements&quot;&gt;&lt;del&gt;LUCENE-1693&lt;/del&gt;&lt;/a&gt;) this is no loger the case, it checks in the ctor, that one of the methods was overridden and throws UOE early (this reflection-based feature was added, because a &quot;what method was overriden&quot; was needed for correct delegation in now 3 different methods doing the same)    &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;But on the other hand the infinite loop is very fast failing (StackOverflow occurs mostly after &amp;lt;300 iterations).&lt;/p&gt;</comment>
                    <comment id="12723995" author="mikemccand" created="Thu, 25 Jun 2009 11:04:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;With my newest TokenStream improvements (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1693&quot; title=&quot;AttributeSource/TokenStream API improvements&quot;&gt;&lt;del&gt;LUCENE-1693&lt;/del&gt;&lt;/a&gt;) this is no loger the case, it checks in the ctor, that one of the methods was overridden and throws UOE early (this reflection-based feature was added, because a &quot;what method was overriden&quot; was needed for correct delegation in now 3 different methods doing the same)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Whoa, powerful!  But this sounds like a possible perf hit for analyzers that don&apos;t reuse their Tokenizers?&lt;/p&gt;</comment>
                    <comment id="12723996" author="shaie" created="Thu, 25 Jun 2009 11:04:21 +0100"  >&lt;p&gt;Previously creaetWeight() threw UOE, and I&apos;ve changed it to call createQueryWeight and the latter to throw UOE. This was obviously the wrong way &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;I think we should:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Revert createWeight to throw UOE&lt;/li&gt;
	&lt;li&gt;Change createQueryWeight to call createWeight() and wrap w/ QueryWeightWrapper&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This should not cause infinite recursion, I think, since:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The Lucene code calls createQueryWeight.&lt;/li&gt;
	&lt;li&gt;All of the Lucene Query impls implement createQueryWeight.&lt;/li&gt;
	&lt;li&gt;Any external Query which did not impl createQueryWeight yet, will be fine too, since Query.createQueryWeight will call the given query&apos;s createWeight, which ought to be implemented. Otheriwse UOE was encountered long before.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Makes sense? I can post a patch soon.&lt;/p&gt;</comment>
                    <comment id="12723998" author="mikemccand" created="Thu, 25 Jun 2009 11:08:39 +0100"  >&lt;p&gt;That sounds like the right approach Shai!  And such legacy Query classes will receive deprecation warnings (that they are overriding a deprecated method), so I think that fixes the back-compat breakage.&lt;/p&gt;</comment>
                    <comment id="12724003" author="thetaphi" created="Thu, 25 Jun 2009 11:14:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;Whoa, powerful! But this sounds like a possible perf hit for analyzers that don&apos;t reuse their Tokenizers?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For these Tokenizers the cost to create the new TokenStreams is very high without this patch, too (because the new TokenStream API). The TokenStreams and Filters have to add all their attributes  to a LinkedHashMap in their ctors. This is why I wanted to make NumericTokenStream reuseable when I invented it &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;And the reflection check is not too slow, as no classes are loaded with forName, its just a check to (getMethod().getDeclaringClass() != TokenStream.class)&lt;/p&gt;

&lt;p&gt;If there is more to discuss or some performance tests, see &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1693&quot; title=&quot;AttributeSource/TokenStream API improvements&quot;&gt;&lt;del&gt;LUCENE-1693&lt;/del&gt;&lt;/a&gt;; at the moment it&apos;s a two-man-show between Michael and me with always showing up possible backwards-compatibility problems and so on!&lt;/p&gt;</comment>
                    <comment id="12724006" author="mikemccand" created="Thu, 25 Jun 2009 11:18:36 +0100"  >&lt;blockquote&gt;&lt;p&gt;For these Tokenizers the cost to create the new TokenStreams is very high without this patch, too (because the new TokenStream API). The TokenStreams and Filters have to add all their attributes to a LinkedHashMap in their ctors. This is why I wanted to make NumericTokenStream reuseable when I invented it &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;at the moment it&apos;s a two-man-show between Michael and me with always showing up possible backwards-compatibility problems and so on!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yah nobody can keep up with you guys!!&lt;/p&gt;</comment>
                    <comment id="12724038" author="shaie" created="Thu, 25 Jun 2009 12:15:27 +0100"  >&lt;p&gt;Very small patch, just one class ... I can&apos;t believe it&apos;s me &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12724042" author="thetaphi" created="Thu, 25 Jun 2009 12:27:46 +0100"  >&lt;p&gt;Looks good, this is the correct way to do this.&lt;/p&gt;</comment>
                    <comment id="12724079" author="mikemccand" created="Thu, 25 Jun 2009 14:12:32 +0100"  >&lt;p&gt;I&apos;ll commit shortly!  Thanks Shai.&lt;/p&gt;</comment>
                    <comment id="12724257" author="mikemccand" created="Thu, 25 Jun 2009 21:28:53 +0100"  >&lt;p&gt;Something is still amiss... from &lt;a href=&quot;https://issues.apache.org/jira/browse/SOLR-940&quot; title=&quot;TrieRange support&quot;&gt;&lt;del&gt;SOLR-940&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.lang.StackOverflowError
at org.apache.solr.search.function.FunctionQuery.rewrite(FunctionQuery.java:50)
at org.apache.lucene.search.IndexSearcher.rewrite(IndexSearcher.java:291)
at org.apache.lucene.search.Query.queryWeight(Query.java:125)
at org.apache.lucene.search.Query.weight(Query.java:117)
at org.apache.lucene.search.Query.createQueryWeight(Query.java:108)
at org.apache.lucene.search.Query.queryWeight(Query.java:126)
at org.apache.lucene.search.Query.weight(Query.java:117)
at org.apache.lucene.search.Query.createQueryWeight(Query.java:108)
at org.apache.lucene.search.Query.queryWeight(Query.java:126)
at org.apache.lucene.search.Query.weight(Query.java:117)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12724268" author="thetaphi" created="Thu, 25 Jun 2009 21:40:19 +0100"  >&lt;p&gt;I think the patch is wrong, it must be&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; QueryWeight createQueryWeight(Searcher searcher) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; QueryWeightWrapper(createWeight(searcher)); &lt;span class=&quot;code-comment&quot;&gt;// and not weigth(searcher)
&lt;/span&gt;   }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12724284" author="mikemccand" created="Thu, 25 Jun 2009 21:52:10 +0100"  >&lt;p&gt;Agreed &amp;#8211; I&apos;ll commit shortly.&lt;/p&gt;</comment>
                    <comment id="12724289" author="shaie" created="Thu, 25 Jun 2009 22:03:01 +0100"  >&lt;p&gt;oops .. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. I&apos;ve said it before - these two just confuse me. I ran into similar issues when I prepared the patch. Maybe we need a QueryTestImpl which impls &lt;b&gt;just&lt;/b&gt; the deprecated methods, and we should run some searches with it. That way, our tests would catch those problems.&lt;/p&gt;</comment>
                    <comment id="12724460" author="shalinmangar" created="Fri, 26 Jun 2009 11:23:17 +0100"  >&lt;p&gt;Something is still wrong, I&apos;m seeing:&lt;/p&gt;

&lt;p&gt;SEVERE: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:242)&lt;br/&gt;
	at org.apache.lucene.search.Searcher.search(Searcher.java:173)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.getDocListAndSetNC(SolrIndexSearcher.java:1103)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.getDocListC(SolrIndexSearcher.java:880)&lt;br/&gt;
	at org.apache.solr.search.SolrIndexSearcher.search(SolrIndexSearcher.java:341)&lt;br/&gt;
	at org.apache.solr.handler.component.QueryComponent.process(QueryComponent.java:176)&lt;/p&gt;

&lt;p&gt;I did some digging around. It seems that before r787772 (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1630&quot; title=&quot;Mating Collector and Scorer on doc Id orderness&quot;&gt;&lt;del&gt;LUCENE-1630&lt;/del&gt;&lt;/a&gt;), the BooleanQuery#scorer used to return a null scorer only if the subScorer was null &lt;b&gt;and&lt;/b&gt; the clause was required. With trunk, the new BooleanQuery#scorer method returns null if the sub scorer is null without checking if the clause was required. But I&apos;m not sure if that is the only problem. When I changed BooleanQuery to the old behavior, I still see the same NPE but this time it is coming from DisjunctionMaxQuery#scorer due to subScorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS always being false. The subScorer in this case was ExactPhraseScorer.&lt;/p&gt;</comment>
                    <comment id="12724556" author="shaie" created="Fri, 26 Jun 2009 15:18:26 +0100"  >&lt;p&gt;I&apos;ll check it, and add some unit tests, which are obviously missing &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Shalin - do you have a simple test case that reproduces the problem? (just for easier start)&lt;/p&gt;</comment>
                    <comment id="12724564" author="mikemccand" created="Fri, 26 Jun 2009 15:59:38 +0100"  >&lt;p&gt;Sorry Shalin, and thanks for digging into this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;With trunk, the new BooleanQuery#scorer method returns null if the sub scorer is null without checking if the clause was required.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is clearly wrong.  I&apos;ve added a test case &amp;amp; fixed it.&lt;/p&gt;

&lt;p&gt;DisjunctionMaxWeight&apos;s scorer also returns null if any of its&lt;br/&gt;
sub-scorers are null (on trunk &amp;amp; 2.4.1), which I think is not right?&lt;br/&gt;
I think it should simply skip that sub scorer; I&apos;ve included that in&lt;br/&gt;
the patch too.&lt;/p&gt;

&lt;p&gt;Finally, I think I fixed your 2nd NPE, where IndexSearcher was failing&lt;br/&gt;
to handle a null scorer returned by the top QueryWeight, though I&apos;m&lt;br/&gt;
not certain it was the same issue you hit.&lt;/p&gt;

&lt;p&gt;Can you try out the attached patch?  Sorry!&lt;/p&gt;</comment>
                    <comment id="12724587" author="shaie" created="Fri, 26 Jun 2009 16:53:10 +0100"  >&lt;p&gt;Mike, thanks for taking care of that. I&apos;m completely embarassed by these failures. Obviously when I moved scorer.score() in IndexSearcher out of doSearch() (now searchWithFilter), I forgot to check for the null Scorer. With that added test case, I won&apos;t be able to &quot;forget&quot; again.&lt;/p&gt;

&lt;p&gt;About the test case, I&apos;m not sure it catches the queryWeight.scorer() returning null. It does check that optional null scorers are just ignored by BQ. Maybe if you add to BQ the same PhraseQuery as MUST, BQ will return null, which will test IndexSearcher handling of a null Scorer?&lt;/p&gt;</comment>
                    <comment id="12724591" author="mikemccand" created="Fri, 26 Jun 2009 17:04:37 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m completely embarassed by these failures.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Well this is tricky stuff!&lt;/p&gt;

&lt;p&gt;And one of the failures (DisjunctionMaxQuery) is pre-existing.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;About the test case, I&apos;m not sure it catches the queryWeight.scorer() returning null&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The 2nd part of the test case (the DisjunctionMaxQuery) does give a null top-level scorer back to IndexSearcher, and results in this exception (before fixing IndexSearcher &amp;amp; DisjunctionMaxQuery):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    [junit] java.lang.NullPointerException
    [junit] 	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:244)
    [junit] 	at org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:171)
    [junit] 	at org.apache.lucene.search.Searcher.search(Searcher.java:183)
    [junit] 	at org.apache.lucene.search.Searcher.search(Searcher.java:193)
    [junit] 	at org.apache.lucene.search.TestBooleanQuery.testNullOrSubScorer(TestBooleanQuery.java:80)
    [junit] 	at org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12724619" author="shaie" created="Fri, 26 Jun 2009 18:22:27 +0100"  >&lt;p&gt;Is there a test for BQ returning null scorer when one if its required clauses is required and returns a null scorer itself? If not, I suggest we cover that angle also, can&apos;t hurt. What do you think?&lt;/p&gt;</comment>
                    <comment id="12724625" author="mikemccand" created="Fri, 26 Jun 2009 18:28:45 +0100"  >&lt;blockquote&gt;&lt;p&gt;Is there a test for BQ returning null scorer when one if its required clauses is required and returns a null scorer itself? If not, I suggest we cover that angle also, can&apos;t hurt. What do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good idea - not sure if there is an existing test - can you add that (to the last patch)?&lt;/p&gt;</comment>
                    <comment id="12724628" author="shaie" created="Fri, 26 Jun 2009 18:38:04 +0100"  >&lt;blockquote&gt;&lt;p&gt;can you add that (to the last patch)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure. I&apos;ll try to do it today or tomorrow.&lt;/p&gt;</comment>
                    <comment id="12724636" author="shalinmangar" created="Fri, 26 Jun 2009 18:47:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;Can you try out the attached patch? Sorry!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That fixes the NPEs I was seeing. Thanks!&lt;/p&gt;</comment>
                    <comment id="12724643" author="mikemccand" created="Fri, 26 Jun 2009 19:13:55 +0100"  >&lt;p&gt;Super, I&apos;ll commit the current patch.  Shai I&apos;ll commit the additional test case once you post that...&lt;/p&gt;</comment>
                    <comment id="12724831" author="shaie" created="Sat, 27 Jun 2009 11:13:46 +0100"  >&lt;p&gt;Added testcase to TestBooleanQuery&lt;/p&gt;</comment>
                    <comment id="12724842" author="mikemccand" created="Sat, 27 Jun 2009 12:15:01 +0100"  >&lt;p&gt;Super &amp;#8211; I just committed this; thanks Shai.&lt;/p&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12431840">LUCENE-1771</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12411805" name="LUCENE-1630-2.patch" size="1315" author="shaie" created="Thu, 25 Jun 2009 12:15:27 +0100" />
                    <attachment id="12411984" name="LUCENE-1630.patch" size="870" author="shaie" created="Sat, 27 Jun 2009 11:13:46 +0100" />
                    <attachment id="12411928" name="LUCENE-1630.patch" size="4398" author="mikemccand" created="Fri, 26 Jun 2009 16:00:19 +0100" />
                    <attachment id="12411306" name="LUCENE-1630.patch" size="148215" author="mikemccand" created="Sat, 20 Jun 2009 11:02:38 +0100" />
                    <attachment id="12411080" name="LUCENE-1630.patch" size="147806" author="shaie" created="Thu, 18 Jun 2009 16:00:38 +0100" />
                    <attachment id="12410932" name="LUCENE-1630.patch" size="147788" author="shaie" created="Wed, 17 Jun 2009 14:36:14 +0100" />
                    <attachment id="12410907" name="LUCENE-1630.patch" size="122251" author="shaie" created="Wed, 17 Jun 2009 09:11:28 +0100" />
                    <attachment id="12410769" name="LUCENE-1630.patch" size="120829" author="shaie" created="Tue, 16 Jun 2009 10:00:33 +0100" />
                    <attachment id="12410681" name="LUCENE-1630.patch" size="120688" author="shaie" created="Mon, 15 Jun 2009 17:53:35 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>9.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 2 Jun 2009 11:53:49 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12127</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26098</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>