<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:58:42 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-879/LUCENE-879.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-879] Document number integrity merge policy</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-879</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;This patch allows for document numbers stays the same even after merge of segments with deletions.&lt;/p&gt;

&lt;p&gt;Consumer needs to do this:&lt;br/&gt;
indexWriter.setSkipMergingDeletedDocuments(false);&lt;/p&gt;

&lt;p&gt;The effect will be that deleted documents are replaced by a new Document() in the merged segment, but not marked as deleted. This should probably be some policy thingy that allows for different solutions such as keeping the old document, et c.&lt;/p&gt;

&lt;p&gt;Also see &lt;a href=&quot;http://www.nabble.com/optimization-behaviour-tf3723327.html#a10418880&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/optimization-behaviour-tf3723327.html#a10418880&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
            <key id="12369124">LUCENE-879</key>
            <summary>Document number integrity merge policy</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="karl.wettin">Karl Wettin</reporter>
                        <labels>
                    </labels>
                <created>Fri, 11 May 2007 18:19:01 +0100</created>
                <updated>Wed, 26 Jan 2011 05:08:24 +0000</updated>
                    <resolved>Wed, 26 Jan 2011 04:59:56 +0000</resolved>
                            <version>2.1</version>
                                                <component>core/store</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12495103" author="karl.wettin" created="Fri, 11 May 2007 18:36:18 +0100"  >&lt;p&gt;Forgot to tell about all the effects:&lt;/p&gt;

&lt;p&gt;1. Replaces deleted documents with a new Document()&lt;br/&gt;
2. Stores a null term frequency vector&lt;br/&gt;
3. Sets norm to Similarity.encodeNorm(0f)&lt;/p&gt;
</comment>
                    <comment id="12495127" author="doronc" created="Fri, 11 May 2007 19:41:43 +0100"  >&lt;p&gt;I skimmed through the patch and I understand that all terms and postings &lt;br/&gt;
of deleted docs are discarded, and, instead, an empty doc is added.&lt;/p&gt;

&lt;p&gt;I would like to comment on the idea behind this.&lt;/p&gt;

&lt;p&gt;I think that this satisfies part of (some) applications needs, &lt;br/&gt;
assuming it is mainly documents updating that causes deletions.&lt;/p&gt;

&lt;p&gt;For example, assume initial 5 documents &lt;/p&gt;
{A,B,C,D,E}
&lt;p&gt;, their internal ids &lt;br/&gt;
are &lt;/p&gt;
{0,1,2,3,4}
&lt;p&gt;, and used as keys to consumer&apos;s secondary storage.&lt;/p&gt;

&lt;p&gt;Now, docs B and D are updated - so the internal ids would change.&lt;br/&gt;
As of now, they become:  &lt;/p&gt;
{A:0, C:1, E:2, B`:3, D`:4}
&lt;p&gt;.&lt;br/&gt;
With this patch, I believe they would become:  &lt;/p&gt;
{A:0, _:1, C:2, _:3, E:4, B`:5, D`:6}
&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;So, accessing the secondary storage is now working nicely for the unchanged &lt;br/&gt;
docs A, C, E, but the keys in the secondary storage have to be modified for the &lt;br/&gt;
updated documents B and D.&lt;/p&gt;

&lt;p&gt;This is probably not too bad, because the application updated the secondary &lt;br/&gt;
storage anyhow, so why not updating the access key at the same&lt;br/&gt;
time - especially if the application keeps track of number of added documents.&lt;/p&gt;

&lt;p&gt;I like this idea, but can see a few issues:&lt;/p&gt;

&lt;p&gt;1) statistics are somewhat distorted - docCount used at search time &lt;br/&gt;
    computations (idf) now (always) includes docs that were deleted. &lt;/p&gt;

&lt;p&gt;2) In the long run, norms size grow, so more memory is used.&lt;br/&gt;
     Eventually a merge-and-clean/squeeze might be required, but I guess the &lt;br/&gt;
     application can do that in a controlled and efficient manner, updating the &lt;br/&gt;
     secondary storage ids at the same time.&lt;/p&gt;

&lt;p&gt;How about a different - more external - approach, not changing the internal-ids &lt;br/&gt;
behavior, but rather using payloads for storing external IDs, and, when opening a &lt;br/&gt;
new reader, reading (once) these IDs to an int array, that maps from&lt;br/&gt;
internal IDs to application IDs. This information is now readily available &lt;br/&gt;
at search time for referencing the secondary repository. Having these IDs as &lt;br/&gt;
payloads should allow to load them relatively fast, so hopefully warming a new &lt;br/&gt;
reader would not be too slow as result of this. That was part 1 of the price of this &lt;br/&gt;
approach. Part 2 is the memory taken for the IDs - 4 bytes per doc per reader.&lt;br/&gt;
Part 3 is the complexity of using this, but I didn&apos;t think of API yet.&lt;/p&gt;

&lt;p&gt;Doron&lt;/p&gt;</comment>
                    <comment id="12495145" author="karl.wettin" created="Fri, 11 May 2007 21:02:30 +0100"  >&lt;p&gt;Doron, thanks for the input. &lt;/p&gt;

&lt;p&gt;I have not had time to read and think everything though that you wrote yet, but I will tell you of what I&apos;m doing and what I&apos;m aiming at.&lt;/p&gt;

&lt;p&gt;I use this patch in conjunction with an Oracle (Sleepycat) BDB object storage. The Lucene document number (LDN) is used as secondary key. I do no unmarshalling to object from data stored in Lucene fields, I only use it as an index. I never have to read the document from Lucene. I have no clue how much CPU ticks or bits of RAM this might save me, I&apos;ll have to bench that later on. This is just me fooling around with technology solutions for fun, a proof of concept. There is no real project.&lt;/p&gt;

&lt;p&gt;When I update an instance of the object storage, I&apos;ll create a new document in Lucene and then update the LDN in the instace to be updated in the object storage, then delete the old document in Lucene.&lt;/p&gt;

&lt;p&gt;Even though it works, I do not like this solution. I want to fully retain the document number integrity for updated document. I belive this can be solved if i limit the warranty to an index in an optimized state. &lt;/p&gt;

&lt;p&gt;An instance of DocumentIdentityFactory, capable of identifying and create queried to uniquely identify documents, will be passed to the SegmentMerger. It might look at field &quot;_type&quot; and &quot;_pk&quot;, or so. &lt;/p&gt;

&lt;p&gt;As SegmentMerger.mergeFields reach a deleted document it will use the factory to find replacements for the deleted document in the index. The one with the top document number is latest one and thus the winner. This document will be added at the current position and added to a list of document number to treat as deleted. &lt;/p&gt;

&lt;p&gt;Ta-da, and there we have safe(tm) document numbers.&lt;/p&gt;</comment>
                    <comment id="12495201" author="karl.wettin" created="Sat, 12 May 2007 00:15:41 +0100"  >&lt;p&gt;This new patch allows consumer to, based on a primary key, delete a document and add a new document with the same document number as the deleted. The events will occur on merging.&lt;/p&gt;</comment>
                    <comment id="12495239" author="hibou" created="Sat, 12 May 2007 09:16:15 +0100"  >&lt;p&gt;Karl, in your application, you store nothing in Lucene isn&apos;t it ?&lt;br/&gt;
Does it cost so much to just store an field id in Lucene ?&lt;/p&gt;</comment>
                    <comment id="12495257" author="karl.wettin" created="Sat, 12 May 2007 13:07:51 +0100"  >&lt;p&gt;Nicolas Lalev&#233;e &lt;span class=&quot;error&quot;&gt;&amp;#91;12/May/07 01:16 AM&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt; Karl, in your application, you store nothing in Lucene isn&apos;t it ?&lt;br/&gt;
&amp;gt; Does it cost so much to just store an field id in Lucene ? &lt;/p&gt;

&lt;p&gt;I have no clue how much CPU ticks or bits of RAM this might save me, I&apos;ll have to bench that later on. This is just me fooling around with technology solutions for fun, a proof of concept. There is no real project.&lt;/p&gt;

&lt;p&gt;But it is not the cost that conserns me. It is having the data spread around diffrent layers. I want to use BDB as object storage, not Lucene.&lt;/p&gt;</comment>
                    <comment id="12495310" author="hibou" created="Sat, 12 May 2007 18:18:56 +0100"  >&lt;p&gt;That was I was talking about, storing in Lucene just an ID referencing the data in another storage. So this Lucene-stored ID became the document-id you try to fix.&lt;/p&gt;

&lt;p&gt;I have also done some experimentation about making the storage external, but I realized that what I was coding was exactly the same as storing an ID in Lucene. But I didn&apos;t tried to &quot;fix&quot; the document id.&lt;/p&gt;</comment>
                    <comment id="12986846" author="shaie" created="Wed, 26 Jan 2011 04:59:56 +0000"  >&lt;p&gt;Closing for long inactivity. Also, there seems to be a reasonable workaround proposed that would not require Lucene to handle mock empty documents to preserve the other doc IDs. In addition, we&apos;re working towards out of order merges etc., so I don&apos;t see how this would fit in the future at all.&lt;/p&gt;</comment>
                    <comment id="12986848" author="trejkaz" created="Wed, 26 Jan 2011 05:08:24 +0000"  >&lt;p&gt;The workaround of using an ID turns out to be very slow.  The worst part is if you need to build a filter - if your database query spits out some other ID scheme then you need to map them to lucene IDs to build the filter, which effectively comes down to one search per document matching the filter.&lt;/p&gt;

&lt;p&gt;Was there another workaround proposed which &lt;b&gt;was&lt;/b&gt; actually reasonable?  Maybe I&apos;m just not seeing it?&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12357153" name="LUNCENE-879.diff" size="29299" author="karl.wettin" created="Sat, 12 May 2007 00:15:41 +0100" />
                    <attachment id="12357124" name="LUNCENE-879.diff" size="15495" author="karl.wettin" created="Fri, 11 May 2007 18:20:11 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 11 May 2007 18:41:43 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12863</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26850</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>