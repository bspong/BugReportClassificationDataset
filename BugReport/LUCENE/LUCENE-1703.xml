<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:15:39 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1703/LUCENE-1703.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1703] Add a waitForMerges() method to IndexWriter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1703</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;It would be very useful to have a waitForMerges() method on the IndexWriter.&lt;/p&gt;

&lt;p&gt;Right now, the only way i can see to achieve this is to call IndexWriter.close()&lt;/p&gt;

&lt;p&gt;ideally, there would be a method on the IndexWriter to wait for merges without actually closing the index.&lt;br/&gt;
This would make it so that background merges (or optimize) can be waited for without closing the IndexWriter, and then reopening a new IndexWriter&lt;/p&gt;

&lt;p&gt;the close() reopen IndexWriter method can be problematic if the close() fails as the write lock won&apos;t be released&lt;br/&gt;
this could then result in the following sequence:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;close() - fails&lt;/li&gt;
	&lt;li&gt;force unlock the write lock (per close() documentation)&lt;/li&gt;
	&lt;li&gt;new IndexWriter() (acquires write lock)&lt;/li&gt;
	&lt;li&gt;finalize() on old IndexWriter releases the write lock&lt;/li&gt;
	&lt;li&gt;Index is now not locked, and another IndexWriter pointing to the same directory could be opened&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If you don&apos;t force unlock the write lock, opening a new IndexWriter will fail until garbage collection calls finalize() the old IndexWriter&lt;/p&gt;

&lt;p&gt;If the waitForMerges() method is available, i would likely never need to close() the IndexWriter until right before the process being shutdown, so this issue would not occur (worst case scenario, the waitForMerges() fails)&lt;/p&gt;

</description>
                <environment></environment>
            <key id="12428388">LUCENE-1703</key>
            <summary>Add a waitForMerges() method to IndexWriter</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="tsmith">Tim Smith</reporter>
                        <labels>
                    </labels>
                <created>Fri, 19 Jun 2009 18:45:44 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:27 +0100</updated>
                    <resolved>Tue, 23 Jun 2009 22:08:27 +0100</resolved>
                            <version>2.4</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12721903" author="mikemccand" created="Fri, 19 Jun 2009 18:54:43 +0100"  >&lt;p&gt;You can use ConcurrentMergeScheduler.sync()?&lt;/p&gt;</comment>
                    <comment id="12721908" author="tsmith" created="Fri, 19 Jun 2009 18:58:04 +0100"  >&lt;p&gt;thought maybe that method would do it, however that method is undocumented (no javadoc) &lt;/p&gt;

&lt;p&gt;ideally, the IndexWriter would have these semantics in order to handle any configured MergeScheduler that may perform background syncs&lt;/p&gt;</comment>
                    <comment id="12721911" author="mikemccand" created="Fri, 19 Jun 2009 19:03:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;ideally, the IndexWriter would have these semantics in order to handle any configured MergeScheduler that may perform background syncs&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.  Wanna cons up a patch?&lt;/p&gt;</comment>
                    <comment id="12721913" author="tsmith" created="Fri, 19 Jun 2009 19:05:22 +0100"  >&lt;p&gt;I&apos;m not super familiar with internals of IndexWriter, but i&apos;ll give it a shot&lt;/p&gt;</comment>
                    <comment id="12721921" author="tsmith" created="Fri, 19 Jun 2009 19:28:47 +0100"  >&lt;p&gt;Here&apos;s a diff for IndexWriter.java&lt;/p&gt;

&lt;p&gt;moved code from else block in finishMerges() into public waitForMerges() method&lt;/p&gt;

&lt;p&gt;this should wait for any outstanding merges to be complete prior to exiting&lt;/p&gt;

&lt;p&gt;will see if i can also work up a test case&lt;/p&gt;</comment>
                    <comment id="12721938" author="tsmith" created="Fri, 19 Jun 2009 20:09:51 +0100"  >&lt;p&gt;I&apos;m finding it a bit tricky to create a proper unit test for this&lt;/p&gt;

&lt;p&gt;This is indirectly tested as IndexWriter.close() will call this method&lt;/p&gt;

&lt;p&gt;but explicit calling of this method is harder to test as it requires outstanding merges to be running (very difficult to trigger)&lt;/p&gt;

&lt;p&gt;I started with TestIndexWriter.testNoWaitClose() as a base&lt;br/&gt;
however, modifying this to test waitForMerges() takes 11 seconds to run (surely because it always waits, and doesn&apos;t abort the merges)&lt;/p&gt;

&lt;p&gt;also, in order to properly test, another method should be added to IndexWriter&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; getOutstandingMerges() {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; mergingSegments.size();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I suppose the most proper test would create a subclass of ConcurrentMergeScheduler that would block all merges until after i released a lock.  Then the test would add docs, fork off thread to unlock for merging in X seconds, then call waitForMerges.&lt;/p&gt;</comment>
                    <comment id="12721949" author="mikemccand" created="Fri, 19 Jun 2009 20:23:46 +0100"  >&lt;p&gt;Patch looks good!  I don&apos;t think you actually need a separate unit test, since (as you pointed out), this method is well tested internally?&lt;/p&gt;</comment>
                    <comment id="12721951" author="shaie" created="Fri, 19 Jun 2009 20:26:28 +0100"  >&lt;p&gt;May I ask what&apos;s the use case for this? I looked at IndexWriter and the following have doWait versions: close(), optimize() and expungeDeletes(). The only one that doesn&apos;t is commit(), which documents it will not wait for merges. So this seems to be a method just for&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; { 
  writer.commit(); 
} &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; { 
  writer.waitForMerges(); 
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is there any other use case that you would want to wait for merges to finish?&lt;/p&gt;

&lt;p&gt;It&apos;s just that adding methods means we need to support them going forward, and if there&apos;s no real use case (or at least none that is covered by current API), we should not do it?&lt;/p&gt;</comment>
                    <comment id="12721954" author="tsmith" created="Fri, 19 Jun 2009 20:33:22 +0100"  >&lt;p&gt;My primary use case for this is to stabilize an index prior to performing a backup operation&lt;/p&gt;

&lt;p&gt;If background merges are ongoing, then partial segment files will be written to disk (potentially while an rsync or other operation is running)&lt;/p&gt;

&lt;p&gt;this will result in partial segments being backed up&lt;/p&gt;

&lt;p&gt;while this should still be a viable index, as the partial segments have not been &quot;committed&quot;, it results in an unclean backup (this can result in rsync throwing warnings/errors (which operations people greatly dislike)&lt;/p&gt;


</comment>
                    <comment id="12721963" author="tsmith" created="Fri, 19 Jun 2009 20:53:30 +0100"  >&lt;p&gt;Very minor change&lt;br/&gt;
moved assert on mergingSegments.size() into waitForMerges()&lt;/p&gt;</comment>
                    <comment id="12721987" author="shaie" created="Fri, 19 Jun 2009 21:33:45 +0100"  >&lt;p&gt;I&apos;m just playing the devil&apos;s advocate here. &lt;/p&gt;

&lt;p&gt;I&apos;m still not sure that this method is needed. A MergeScheduler is given to IndexWriter, and therefore your code should be able to sync() on it, whether it&apos;s ConcurrentMergeScheduler or a different one which does background merges, since you control its creation. If it&apos;s something that needs to improve on CMS, let&apos;s improve it (like documenting sync()).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;My primary use case for this is to stabilize an index prior to performing a backup operation&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Still .. if you call any of the methods I&apos;ve mentioned, you can change your code to call the doWait variants, except for commit(). If commit() is what you&apos;re after, wouldn&apos;t it be better to add a commit(doWait) so that you can call it w/ doWait=true?&lt;/p&gt;

&lt;p&gt;BTW, Mike McCandless has written a great article on Hot Backups w/ Lucene, which you can find here: &lt;a href=&quot;http://www.manning.com/free/green_HotBackupsLucene.html&quot; class=&quot;external-link&quot;&gt;http://www.manning.com/free/green_HotBackupsLucene.html&lt;/a&gt; (need to register to Manning first). If you&apos;re not familiar w/ it, I suggest you read it since it shows a nice and elegant ways to perform backups, w/o the need to sync your writer.&lt;/p&gt;

&lt;p&gt;I&apos;m planning to try it out. One thing you can do, after calling snapshot() is to compare the files returned from snapshot() to the ones in the backup and: (1) delete the ones in backup that do not appear in the returned list of files, and copy over the files that do not exist in the backup (except for .lock). The article is really good and self explanatory.&lt;/p&gt;</comment>
                    <comment id="12722003" author="tsmith" created="Fri, 19 Jun 2009 21:53:59 +0100"  >&lt;p&gt;MergeScheduler does not provide a sync() method in its abstract class. Therefore, an implementation could be used that would not derive from or provide a sync() method&lt;/p&gt;

&lt;p&gt;If it did, this would be a more than acceptable solution instead of putting the method on the IndexWriter. (i potentially want to allow configuration to specify what MergeScheduler to use, and if sync() isn&apos;t specified on the base class, i can&apos;t reliably use it (will have to do instanceof checks, and a new concurrent based scheduler not derived from ConcurrentMergeScheduler breaks this)&lt;/p&gt;

&lt;p&gt;Also, the SerialMergeScheduler may be in use and be running due to another thread calling addDocument triggering a merge, but i want my second thread to wait for that merge to complete (this would require implementing sync() on SerialMergeScheduler to allow other threads to sync on the merge as well)&lt;/p&gt;

&lt;p&gt;optimize() is not a viable option to use to wait for merges as this could take a long time (hours)&lt;br/&gt;
close() requires reopening the IndexWriter (which i am trying to avoid in the first place)&lt;br/&gt;
expungeDeletes(true) is doing more work that is actually required (this could be a viable solution, however its a bit odd to &quot;waitForMerges()&quot; by calling a method called expungeDeletes())&lt;/p&gt;

&lt;p&gt;I will try getting access to the article you suggest, however i still expect i will want this method at the end of the day (and will end up using expungeDeletes(true) if it never gets added (with copious comments indicating that expungeDeletes() is actually being used to wait for background merges)&lt;/p&gt;

&lt;p&gt;Another use for waitForMerges() is as a more lightweight version of optimize().&lt;br/&gt;
this will allow blocking adding more documents until background merges are complete periodically, preventing from throttling the IO on the indexer from being hit too hard. Could call IndexWriter.maybeMerge() followed by IndexWriter.waitForMerges()&lt;/p&gt;


</comment>
                    <comment id="12722019" author="shaie" created="Fri, 19 Jun 2009 22:20:13 +0100"  >&lt;blockquote&gt;
&lt;p&gt;MergeScheduler does not provide a sync() method in its abstract class. Therefore, an implementation could be used that would not derive from or provide a sync() method&lt;/p&gt;

&lt;p&gt;If it did, this would be a more than acceptable solution instead of putting the method on the IndexWriter. (i potentially want to allow configuration to specify what MergeScheduler to use, and if sync() isn&apos;t specified on the base class, i can&apos;t reliably use it (will have to do instanceof checks, and a new concurrent based scheduler not derived from ConcurrentMergeScheduler breaks this)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can add a sync() method to MergeScheduler or you do it on your side. There are only two MS today: CMS and SMS. If you&apos;re going to write your own CMS variant, then you can have it extend CMS, or define your own interface with a sync() method, which will delegate that call to whatever MS it wraps. Again, the way I see it, you know which MS you instantiate, and therefore you should be able to declare its type and use whatever methods it has. If you want something configurable, I suggest we move sync() to MS (w/ a default impl of doing nothing, for back-compat).&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;... another thread calling addDocument triggering a merge&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This will only happen if you use autoCommit=true, right? You can use autoCommit=true, and when you call commit(), use the one that waits for merges (the one that does not exist yet &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ), and sync all your addDoc threads with that current commit thread (make sure you use a ReadWriteLock, or otherwise all your addDocs are going to sync on each other).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;this will allow blocking adding more documents until background merges are complete periodically&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What&apos;s &quot;periodically&quot;? If you&apos;re using autoCommit=false, those merges cannot happen suddenly. There are only 4 methods that can trigger them (I think?) and you can sync on calling them w/ the rest of the addDoc threads.&lt;/p&gt;

&lt;p&gt;Don&apos;t get me wrong - I just play the devil&apos;s advocate here. Recently, we&apos;ve had this thread &lt;a href=&quot;http://www.nabble.com/ReadOnly-IndexReaders-td23787255.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/ReadOnly-IndexReaders-td23787255.html&lt;/a&gt; - a naive question on adding an ever more naive method to IndexReader - isReadOnly. If you read it, you&apos;ll see that it wasn&apos;t accepted at the end, because we&apos;ve understood it will just try to cover a design flaw of your system.&lt;/p&gt;

&lt;p&gt;Therefore I&apos;m just trying to verify whether this method is absolutely necessary, and there aren&apos;t any &quot;design decisions&quot; we should make in our apps to better handle that case.&lt;/p&gt;

&lt;p&gt;Having said that, I&apos;m not a committer and if one decides it&apos;s important enough, one would take this issue and commit it. I just enjoy the discussion  for now (hope you too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ).&lt;/p&gt;</comment>
                    <comment id="12722037" author="tsmith" created="Fri, 19 Jun 2009 22:45:22 +0100"  >&lt;p&gt;NOTE: I&apos;m always using autoCommit=false (autoCommit=true is deprecated anyway)&lt;/p&gt;

&lt;p&gt;however, i could potentially have 2 threads feeding the index (in my custom code)&lt;br/&gt;
one thread may call addDocument() (or maybeMerge() to be more to the point)&lt;br/&gt;
this thread could result in the SerialMergeScheduler to start merging (addDocument() won&apos;t return until this merge completes)&lt;br/&gt;
I then want thread 2 to call waitForMerges(), at which point it will wait till the first thread will have finished its merges (at which point addDocument will have returned)&lt;/p&gt;

&lt;p&gt;Obviously this is a contrived example as i personally will be locking the updates such that no addDocument() call could be in process when i want to call waitForMerges(), however this situation points out that even the SerialMergeScheduler should have an actual implementation for a sync() method, which would block until the thread actually doing the merge has completed. (as i may be calling sync() from a different thread other than the one the IndexWriter called merge() on) SerialMergeScheduler should therefore have a lock that will be held while merging, and a sync() method should be added that will just acquire and release the lock. Making both the sync() and merge() methods on the SerialMergeScheduler would achieve this (and the sync would just be a synchronized noop)&lt;/p&gt;

&lt;p&gt;It seems more natural to me to put this &quot;sync&quot; on the IndexWriter itself, especially as this will be completely agnostic to the merge scheduler used.&lt;/p&gt;


&lt;p&gt;for the &quot;periodic&quot; waiting for merge thread completion, this would be driven by messages from client code to request a &quot;soft optimize&quot; perhaps, which would just wait for background merges to complete. This could then result in turning over a new IndexReader for more efficient searches than using the old IndexReader (which may be more segmented). This message asking for a &quot;soft optimize&quot; may be sent on some scheduled basis in order to achieve better search performance (without the cost of an explicit optimize)&lt;/p&gt;


&lt;p&gt;Discussion is all well and good, and i definitely appreciate all comments.&lt;br/&gt;
Even if this doesn&apos;t end up going in, you&apos;ve pointed out another solution (using expungeDeletes()) which will achieve the same solution for me at least.&lt;/p&gt;
</comment>
                    <comment id="12722040" author="mikemccand" created="Fri, 19 Jun 2009 22:56:19 +0100"  >&lt;p&gt;There are also &quot;merges&quot; that take place outside of the merge scheduler, eg addIndexesNoOptimize copies over the tail segments by running its own merges.  Also, with &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1313&quot; title=&quot;Near Realtime Search (using a built in RAMDirectory)&quot;&gt;&lt;del&gt;LUCENE-1313&lt;/del&gt;&lt;/a&gt;, there may be merges that run entirely in RAM, not under MergeScheduler.&lt;/p&gt;

&lt;p&gt;I think it makes sense to expose waitForMerges in IW (instead of duplicating the code in every merge scheduler).  We may be able to then deprecate CMS.sync?&lt;/p&gt;</comment>
                    <comment id="12722057" author="shaie" created="Fri, 19 Jun 2009 23:12:47 +0100"  >&lt;blockquote&gt;
&lt;p&gt;one thread may call addDocument() (or maybeMerge() to be more to the point)&lt;br/&gt;
this thread could result in the SerialMergeScheduler to start merging (addDocument() won&apos;t return until this merge completes)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Again, if autoCommit=false, how can this happen? I thought that if autoCommit=false, no commit happens and therefore no segment merging?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think it makes sense to expose waitForMerges in IW (instead of duplicating the code in every merge scheduler). We may be able to then deprecate CMS.sync?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I guess I&apos;m still not convinced what simplicity would that bring. For Tim&apos;s use case, just two threads, using SMS, that might work. But for the general use case, or one which uses multiple indexing threads, one of which may call commit() at some point, another daemon may run optimize(), I dunno, this would still require syncing all threads around that waitForMerges call, if the intent is to prevent document additions while merges occur. Therefore this method is not expected to make my life any easier, except that if I need to report &quot;no merges are running&quot; or make a decision based on &quot;no merges are running&quot; I should have one thread call this waitForMerges()&lt;/p&gt;

&lt;p&gt;Of course, still playing the devil&apos;s advocate, you could call waitForMerges() which will return immediately b/c there are no merges to do or that are running, and soon as that happens, a context switch also happens, and an innocent addDocument will trigger a 50-segments merge, at which point whatever you thought to do b/c there are no merges, will hit the exact scenario you were trying to avoid all that time &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;I&apos;ll admit though that it&apos;s late here (1 AM), and perhaps I&apos;m not seeing this clearly. And .. I still don&apos;t understand how if autocommit=false, and addDocument/deleteDocument can trigger a merge.&lt;/p&gt;</comment>
                    <comment id="12722065" author="thetaphi" created="Fri, 19 Jun 2009 23:27:28 +0100"  >&lt;blockquote&gt;&lt;p&gt;I still don&apos;t understand how if autocommit=false, and addDocument/deleteDocument can trigger a merge.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why not? I always use autocommit=false. After I added a number of documents to the index some of the existing not-yet committed segments get merged. It will never merge the current existing and committed segments, but the segments created during indexing can be merged. After commit() or close() the already existing and the new segments are maybe additionally merged and a new segments file written.&lt;/p&gt;</comment>
                    <comment id="12722069" author="jasonrutherglen" created="Fri, 19 Jun 2009 23:35:28 +0100"  >&lt;p&gt;Seems like a useful feature.&lt;/p&gt;</comment>
                    <comment id="12722145" author="shaie" created="Sat, 20 Jun 2009 06:53:31 +0100"  >&lt;p&gt;Right ... forgot the merges to the uncommitted segments. If we do this, can we also add a commit() version which waits for merges, to complete the set of operations that allow you to wait for merges (just for convenience, so that you don&apos;t call commit() followed by a waitForMerges()), or .. deprecate all the variants of the other methods that wait for merges, and say that the default behavior will not wait, and if you want this, call waitForMergest() afterwards?&lt;/p&gt;</comment>
                    <comment id="12722168" author="mikemccand" created="Sat, 20 Jun 2009 11:41:57 +0100"  >&lt;blockquote&gt;&lt;p&gt;After I added a number of documents to the index some of the existing not-yet committed segments get merged. It will never merge the current existing and committed segments, but the segments created during indexing can be merged. After commit() or close() the already existing and the new segments are maybe additionally merged and a new segments file written.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, existing segments do get merged (assuming the merge policy selects them).  It&apos;s just that they cannot be deleted because logically there are two snapshots while an IndexWriter is running with autoCommit false: the index as of when it was opened, and the current in-memory SegmentInfos.  (And if you are using a deletion policy different from the default KeepOnlyLastCommit, even more snapshots will be kept).&lt;/p&gt;</comment>
                    <comment id="12722169" author="mikemccand" created="Sat, 20 Jun 2009 11:42:47 +0100"  >&lt;blockquote&gt;&lt;p&gt;or .. deprecate all the variants of the other methods that wait for merges, and say that the default behavior will not wait, and if you want this, call waitForMergest() afterwards?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Though we have a migration challenge (if we want to swap the default).  Or we add a matchVersion.&lt;/p&gt;</comment>
                    <comment id="12722231" author="shaie" created="Sat, 20 Jun 2009 18:57:13 +0100"  >&lt;blockquote&gt;&lt;p&gt;Though we have a migration challenge (if we want to swap the default). Or we add a matchVersion.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If we change the default to not wait, then I don&apos;t think matchVersion will matter. Since I&apos;ll need to update my code anyway, I don&apos;t think I&apos;d care whether I call waitForMerges(), or matchVersion, even though the latter is called only once and the change is required in just one place. matchVersion, IMO, is required in more complicated cases, like that ACRONYM issue, which my code really has no control over.&lt;/p&gt;</comment>
                    <comment id="12722274" author="mikemccand" created="Sun, 21 Jun 2009 00:21:25 +0100"  >&lt;blockquote&gt;&lt;p&gt;If we change the default to not wait, then I don&apos;t think matchVersion will matter. Since I&apos;ll need to update my code anyway, I don&apos;t think I&apos;d care whether I call waitForMerges(), or matchVersion, even though the latter is called only once and the change is required in just one place. matchVersion, IMO, is required in more complicated cases, like that ACRONYM issue, which my code really has no control over.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But we can&apos;t suddenly not wait, if you call optimize(), right?  (That&apos;s too severe a change in runtime behavior) Ie, we&apos;d have to rename it to something else, and deprecate the old one.&lt;/p&gt;

&lt;p&gt;Actually... I&apos;m no longer so sure we should make this change to the default.  I think the current default (optimize(), addIndexes*(), expungeDeletes(), etc., all wait until they&apos;re &quot;done&quot;) is actually a good default?&lt;/p&gt;</comment>
                    <comment id="12722292" author="shaie" created="Sun, 21 Jun 2009 03:30:45 +0100"  >&lt;p&gt;I&apos;m not against the default, just thought that waitForMerges() will be even more useful if all of these didn&apos;t have the doWait variant, and it will reduce the number of methods on IW. We can leave them around though, I guess it doesn&apos;t hurt.&lt;/p&gt;</comment>
                    <comment id="12722819" author="tsmith" created="Mon, 22 Jun 2009 21:58:09 +0100"  >&lt;p&gt;I also noticed that at least on expungeDeletes() these methods may only wait for merges that the method itself initiated&lt;/p&gt;

&lt;p&gt;the waitForMerges() method would wait for all merges regardless of who initiated the merge.&lt;/p&gt;

&lt;p&gt;so:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
  expungeDeletes(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
} &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
  waitForMerges();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;would not be the same as&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
expungeDeletes(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;as the later would only wait for the merges actually caused by the expungeDeletes() method&lt;/p&gt;

&lt;p&gt;This would indicate that the waitForMerges=true/false variants of different methods should remain&lt;/p&gt;</comment>
                    <comment id="12722834" author="mikemccand" created="Mon, 22 Jun 2009 22:15:28 +0100"  >&lt;blockquote&gt;&lt;p&gt;This would indicate that the waitForMerges=true/false variants of different methods should remain&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh good point; and I think the default should be to wait.  OK I plan to commit the current patch in a day or two.  Thanks Tim!&lt;/p&gt;</comment>
                    <comment id="12723307" author="mikemccand" created="Tue, 23 Jun 2009 22:08:27 +0100"  >&lt;p&gt;Thanks Tim!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12411255" name="IndexWriter.java.diff" size="1617" author="tsmith" created="Fri, 19 Jun 2009 20:53:30 +0100" />
                    <attachment id="12411248" name="IndexWriter.java.diff" size="1578" author="tsmith" created="Fri, 19 Jun 2009 19:28:47 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 19 Jun 2009 17:54:43 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12055</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26023</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>