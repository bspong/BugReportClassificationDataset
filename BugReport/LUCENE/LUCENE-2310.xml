<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:09:19 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2310/LUCENE-2310.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2310] Reduce Fieldable, AbstractField and Field complexity</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2310</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;In order to move field type like functionality into its own class, we really need to try to tackle the hierarchy of Fieldable, AbstractField and Field.  Currently AbstractField depends on Field, and does not provide much more functionality that storing fields, most of which are being moved over to FieldType.  Therefore it seems ideal to try to deprecate AbstractField (and possible Fieldable), moving much of the functionality into Field and FieldType.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12458840">LUCENE-2310</key>
            <summary>Reduce Fieldable, AbstractField and Field complexity</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                    <parent id="12458721">LUCENE-2308</parent>
                        <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="cmale">Chris Male</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Mar 2010 19:09:05 +0000</created>
                <updated>Fri, 10 May 2013 11:44:22 +0100</updated>
                    <resolved>Tue, 20 Mar 2012 15:40:57 +0000</resolved>
                                            <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12844178" author="mikemccand" created="Thu, 11 Mar 2010 19:21:07 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                    <comment id="12844469" author="cmale" created="Fri, 12 Mar 2010 12:01:57 +0000"  >&lt;p&gt;The challenge presented in this work is the pervasiveness of the Fieldable class.  Its used in several hundred places through the source, but the majority are in tests, and in Document itself.  Therefore part of this work will be also to move as many of the tests over to using Field, and working on the Document API as well.&lt;/p&gt;</comment>
                    <comment id="12844922" author="cmale" created="Sat, 13 Mar 2010 17:25:55 +0000"  >&lt;p&gt;Attaching first version of the patch which deprecates AbstractField.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Moves the properties and getters/setters down into Field.&lt;/li&gt;
	&lt;li&gt;Field now only implements Fieldable&lt;/li&gt;
	&lt;li&gt;Field now allows its value to be set to null through its construction.  This allows subclasses to set the fieldData to their own&lt;/li&gt;
	&lt;li&gt;NumericField now extends Field, overridding the setValue methods as they are not supported&lt;/li&gt;
	&lt;li&gt;LazyField also now extends Field&lt;/li&gt;
	&lt;li&gt;AbstractField is now no longer used anywhere.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12844923" author="thetaphi" created="Sat, 13 Mar 2010 17:31:58 +0000"  >&lt;p&gt;You should also not be able to set the TokenStream in NF.&lt;/p&gt;

&lt;p&gt;IMO, i would keep AbstractField and only remove Fieldable, as interfaces are not wanted in Lucene.&lt;/p&gt;

&lt;p&gt;-1 for this patch in its current form.&lt;/p&gt;</comment>
                    <comment id="12844929" author="cmale" created="Sat, 13 Mar 2010 17:54:29 +0000"  >&lt;blockquote&gt;
&lt;p&gt;You should also not be able to set the TokenStream in NF.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes good point.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;IMO, i would keep AbstractField and only remove Fieldable, as interfaces are not wanted in Lucene&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually I would like to remove both actually.  There doesn&apos;t seem much reason to keep AbstractField, especially since its already dependent on Field.XYZ and seems only to only store all the various properties, most of which will be moved away to FieldType anyway.&lt;/p&gt;

&lt;p&gt;Would a compromise be to also add an UOE to setting the TokenStream in NumericField? It does still have the concept of a TokenStream, so it is a Field, but a specialisation which handles the TokenStream itself.&lt;/p&gt;</comment>
                    <comment id="12844930" author="tsmith" created="Sat, 13 Mar 2010 17:58:51 +0000"  >&lt;p&gt;Personally, i like keeping Fieldable, (or having AbstractField just with abstract methods and no actual implementation)&lt;/p&gt;

&lt;p&gt;for feeding documents, i use custom Fieldable implementations to reduce amount of setters called, as Fields of different types have different constant settings&lt;/p&gt;</comment>
                    <comment id="12844931" author="earwin" created="Sat, 13 Mar 2010 18:03:20 +0000"  >&lt;p&gt;These settings will go to FieldType?&lt;/p&gt;</comment>
                    <comment id="12844932" author="cmale" created="Sat, 13 Mar 2010 18:10:55 +0000"  >&lt;p&gt;Hi Tim,&lt;/p&gt;

&lt;p&gt;Yeah I see what you are saying, but as Earwin says, the &apos;settings&apos; will be pushed into the FieldType, so they&apos;ll be removed from Fieldable as well.&lt;/p&gt;</comment>
                    <comment id="12844933" author="cmale" created="Sat, 13 Mar 2010 18:11:36 +0000"  >&lt;p&gt;I should note, to prevent confusion, that my patch is just the beginning of this work, designed to illustrate the direction I&apos;m heading.&lt;/p&gt;</comment>
                    <comment id="12844941" author="cmale" created="Sat, 13 Mar 2010 19:12:13 +0000"  >&lt;p&gt;Addressed the issues raised by Uwe about the TokenStream in NumericField.  NumericField now throws a UOE on setTokenStream.  Since it  also extends Field which has its own TokenStream field, NumericField now uses the field from TokenStream rather than its own.&lt;/p&gt;

&lt;p&gt;The more and more this is discussed the clearer it is that Field should be the base class of the Field hierarchy, and not AbstractField or Fieldable.  The issue of having all the setters and configurations will be addressed in LUENE-2308 when we move them all to FieldType.  Field will become a simple tuple consisting of at least a value and type, and possibly a TokenStream.&lt;/p&gt;

&lt;p&gt;NumericField and LazyField are customisations of Field controlling certain aspects of the tuple.  For NumericField that is the TokenStream and setting the value.  For LazyField that is the value.&lt;/p&gt;</comment>
                    <comment id="12844945" author="thetaphi" created="Sat, 13 Mar 2010 19:25:19 +0000"  >&lt;p&gt;There is one problem in backwards:&lt;br/&gt;
If somebody has the following code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
AbstractField field = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Field(...)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This will no longer work.&lt;/p&gt;</comment>
                    <comment id="12844949" author="cmale" created="Sat, 13 Mar 2010 19:42:36 +0000"  >&lt;p&gt;Addressed Uwe&apos;s issue again.&lt;/p&gt;

&lt;p&gt;Only solution is to change Field to extend AbstractField again, even though AbstractField is dead code.&lt;/p&gt;

&lt;p&gt;Also fixed:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added final to setter methods that are also final in AbstractField for consistency sake&lt;/li&gt;
	&lt;li&gt;Fixed import for javadocs in CheckIndex and FieldsReader&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12845118" author="cmale" created="Sun, 14 Mar 2010 18:37:20 +0000"  >&lt;p&gt;Spent more time pondering how to deprecate Fieldable and the major issue is Document#getFields(), which returns a modifiable List&amp;lt;Fieldable&amp;gt;.  Because it is modifiable, consumers can add to it directly rather than through Document.&lt;/p&gt;

&lt;p&gt;If it were unmodifiable, then it would be possible to control adding Fieldables in Document, which would then allow us to wrap Fieldable instances in a Field subclass, meaning Document would only have a List&amp;lt;Field&amp;gt;.&lt;/p&gt;

&lt;p&gt;Given this limitation, I&apos;m currently thinking about not trying to deprecate Fieldable in 3.x, but instead adding the unmodifiable list method and deprecating #getFields().  I would also add some functionality for removing Fieldables, which seems to be all thats lack in Document.  Then in 4.x I would deprecate Fieldable.&lt;/p&gt;

&lt;p&gt;Slow process, but I think by deprecating AbstractField now we have already made a step forward to improving this hierarchy in preparation for the FieldType classes.&lt;/p&gt;

&lt;p&gt;Remaining in this work is a code cleanup of all 3 classes, so that code is understandable when we add in FieldType.&lt;/p&gt;</comment>
                    <comment id="12845122" author="shaie" created="Sun, 14 Mar 2010 19:51:14 +0000"  >&lt;p&gt;How about if getFields() will return an Iterable&amp;lt;Field&amp;gt;? It&apos;ll need to be deprecated and a new method created, but it can be simple enough solution to avoid one adding fields directly to Document w/o passing through doc.add first.&lt;/p&gt;

&lt;p&gt;If you do end up removing getFields(), then I&apos;d like to have a clear() on Document. I once proposed it and was told to call getFields().clear() instead, which allows me to reuse my Document instance. If I lose that option, I&apos;d appreciate if a direct clear() on Document will exist instead.&lt;/p&gt;</comment>
                    <comment id="12845129" author="cmale" created="Sun, 14 Mar 2010 20:34:51 +0000"  >&lt;p&gt;Hi Shai,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How about if getFields() will return an Iterable&amp;lt;Field&amp;gt;? It&apos;ll need to be deprecated and a new method created, but it can be simple enough solution to avoid one adding fields directly to Document w/o passing through doc.add first.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not really in favour of Iterable in this case as it inhibits people calling .size().  Knowing how many fields a Document has might be useful.  But I agree it would certainly prevent people from adding new Fields and is a simple solution.  Do you think getting the number of fields has a use case at all?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you do end up removing getFields(), then I&apos;d like to have a clear() on Document. I once proposed it and was told to call getFields().clear() instead, which allows me to reuse my Document instance. If I lose that option, I&apos;d appreciate if a direct clear() on Document will exist instead.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes.  I will certainly add clear().  Do you think its useful to support removing specific fields as well i.e. remove(String fieldName)?&lt;/p&gt;</comment>
                    <comment id="12845130" author="shaie" created="Sun, 14 Mar 2010 20:40:22 +0000"  >&lt;p&gt;I can&apos;t think of why one would want to know how many fields a Document has. But even then, we can add a numFields() method to Document. The Iterable thingy will just prevent a lot of unnecessayy work I think.&lt;/p&gt;

&lt;p&gt;About remove(String fieldName), I don&apos;t see a case for that as well. A Document is a point in time object - you parse a document, extract metadata, converts the entire flow to a Lucene object (in this case Document) and passes it along to IW. You then move on to the next document.&lt;/p&gt;

&lt;p&gt;So I wouldn&apos;t know why would someone want to remove a field from a Document ... but perhaps I just haven&apos;t run into the use case yet. Iterable btw will at least alert the user if he did that, because a ConcurrentModificationException will be thrown (if we&apos;re using a List-based iterator) ...&lt;/p&gt;</comment>
                    <comment id="12845135" author="cmale" created="Sun, 14 Mar 2010 20:59:03 +0000"  >&lt;p&gt;Haha, i whole heartedly agree with all your points.&lt;/p&gt;

&lt;p&gt;One option instead of adding another method to return Iterable&amp;lt;Fieldable&amp;gt;, is for Document to implement Iterable&amp;lt;Fieldable&amp;gt; and to return a unmodifiable Iterator.&lt;/p&gt;

&lt;p&gt;This would then fit nicely with future ideas I had about providing iterators based on FieldType criteria, allowing the IW to then retrieve an iterator of only those fields which are to be indexed for example.&lt;/p&gt;</comment>
                    <comment id="12845702" author="shaie" created="Tue, 16 Mar 2010 04:30:32 +0000"  >&lt;p&gt;i like the idea of Document to implement Iterable, but how does that solve the case where someone wants to query how many fields a document has? Will you still have getFields(), only now it will return an unmodifiable collection?&lt;/p&gt;

&lt;p&gt;I guess the unmod collection can be returned even today, right?&lt;/p&gt;

&lt;p&gt;BTW, what happens if getFields() return an unmod collection, but someone calls doc.add(Field)? I think the unmod collection prevents you from adding to that collection wrapper, but not for that collection to be changed from under the hood? If that&apos;s true, then that could cause some trouble ... so getFields() will really return a snapshot of Document, which means we need to clone Fields ...&lt;/p&gt;

&lt;p&gt;Gets too complicated no? Maybe just do: (1) Doc implements Iterable and (2) Doc exposes numFIelds(), add(Field)?&lt;/p&gt;

&lt;p&gt;About remove(field), I thought of a possible scenario though I still don&apos;t think it&apos;s interesting enough - suppose that you pass your Document through a processing pipeline/chain, each handler adds fields as metadata to the Document. For example, annotators. It might be that a field A exists, only for a handler down the chain to understand A&apos;s meaning and then replace it w/ A1 and A2. For that you&apos;ll want to be able to move a field ... I guess we could add a remove method to Document, and if it&apos;ll be called while the fields are iterated on, a CME will be thrown, which is perfectly fine with me.&lt;/p&gt;</comment>
                    <comment id="12845771" author="cmale" created="Tue, 16 Mar 2010 09:18:36 +0000"  >&lt;p&gt;Hi Shai,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;i like the idea of Document to implement Iterable, but how does that solve the case where someone wants to query how many fields a document has?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It doesn&apos;t, but then I&apos;d add a numFields() method maybe.  It seems like something with a small use case and so having it has a method on the side seems ideal.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Will you still have getFields(), only now it will return an unmodifiable collection?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes and no.  getFields will remain but with a modifiable list.  I will then deprecate the method and recommend people use the Iterable.  This gives everybody a chance to migrate during the 3.x versions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Maybe just do: (1) Doc implements Iterable and (2) Doc exposes numFIelds(), add(Field)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yup lets do that.  Unfortunately getFields will remain until 4.0.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;About remove(field), I thought of a possible scenario though I still don&apos;t think it&apos;s interesting enough - suppose that you pass your Document through a processing pipeline/chain, each handler adds fields as metadata to the Document. For example, annotators. It might be that a field A exists, only for a handler down the chain to understand A&apos;s meaning and then replace it w/ A1 and A2. For that you&apos;ll want to be able to move a field ... I guess we could add a remove method to Document, and if it&apos;ll be called while the fields are iterated on, a CME will be thrown, which is perfectly fine with me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;With the idea of having remove(...) I am trying to foresee what people might be doing via getFields() and thus are not going to be able to do when its gone.  We will have the ability to add and iterate, so having the functionality to remove seems to complete it.  I completely agree that if something happens and a CME is thrown, then that problem should be left to the user.&lt;/p&gt;

&lt;p&gt;I think this clarifies this direction.  Document will be changed as follows:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Document will become Iterable&amp;lt;Fieldable&amp;gt;&lt;/li&gt;
	&lt;li&gt;getFields() will be deprecated in favour of the Iterable&lt;/li&gt;
	&lt;li&gt;numFields() will be added returning the number of fields&lt;/li&gt;
	&lt;li&gt;remove(String) will be added allowing someone to remove Fields with the given name.  If a CME occurs, thats up to the user to handle.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Cheers Shai!&lt;/p&gt;
</comment>
                    <comment id="12845936" author="shaie" created="Tue, 16 Mar 2010 15:27:57 +0000"  >&lt;p&gt;I&apos;m sorry for the confusion - I got used to all the deprecation discussions so much that it&apos;s embedded in my replies &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; - when I wrote &quot;instead getFields&quot; I meant that it will be deprecated, and we&apos;ll carry it w/ us until 4.0 is out.&lt;/p&gt;

&lt;p&gt;So overall we agree on the changes that need to be made. BTW, when you deprecate a method, you usually change it to call the new API or change it to use the new data structures or whatever. So we need to think how to impl getFields such that if one calls remove, numFields or use the iterator on an interleving manner, his code doesn&apos;t break ... I don&apos;t think it should be hard but it might be a good idea to even write such (deprecated) unit test&lt;/p&gt;</comment>
                    <comment id="12845939" author="cmale" created="Tue, 16 Mar 2010 15:38:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;So overall we agree on the changes that need to be made. BTW, when you deprecate a method, you usually change it to call the new API or change it to use the new data structures or whatever. So we need to think how to impl getFields such that if one calls remove, numFields or use the iterator on an interleving manner, his code doesn&apos;t break ... I don&apos;t think it should be hard but it might be a good idea to even write such (deprecated) unit test&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure we have to change getFields.  We can just deprecate it, and point people to the new methods.  I think it&apos;d be more effort than its worth to create a List impl that calls the new methods.  Was that what you were implying?  I do agree its worth writing a test to ensure all old functionality can be done via the new methods somehow.&lt;/p&gt;</comment>
                    <comment id="12845968" author="shaie" created="Tue, 16 Mar 2010 16:11:03 +0000"  >&lt;p&gt;That was usually the approach. You provide new methods, deprecate old ones, however both work and not in a XOR mode. Both should work and we need to ensure that if people call both they still function properly. Unless this has changed, in which case it should be clearly documented.&lt;/p&gt;

&lt;p&gt;But I don&apos;t think it is a big problem to support both? If Document still keeps its fields in a List then all should remain the same. We could have a 4.0 note to switch to a Map based DS to better support remove, but that&apos;s questionable because we&apos;ll need to maintain ordering on the fields (the order in which they inserted) though personally I don&apos;t think it should matter much to the user, however that&apos;s the current implementation. &lt;/p&gt;</comment>
                    <comment id="12845972" author="cmale" created="Tue, 16 Mar 2010 16:17:26 +0000"  >&lt;p&gt;I recommend we keep it as a List since that facilitates having different iterators by FieldType criteria more.  A Map would support get and remove better, but I think we want to move people to using Iterators and the remove method is there for a case we don&apos;t know of yet.&lt;/p&gt;

&lt;p&gt;I&apos;ll create a patch with these ideas shortly.&lt;/p&gt;

&lt;p&gt;Cheers!&lt;/p&gt;</comment>
                    <comment id="12846002" author="shaie" created="Tue, 16 Mar 2010 17:09:39 +0000"  >&lt;p&gt;I agree. Then keeping both deprecated and new API should be supported easily.&lt;/p&gt;</comment>
                    <comment id="12847844" author="cmale" created="Sat, 20 Mar 2010 23:08:53 +0000"  >&lt;p&gt;New version of the AbstractField deprecation patch which cleans up Field so its more readable, deferring documentation to Fieldable where possible in preparation for deprecating most the methods in Fieldable. &lt;/p&gt;</comment>
                    <comment id="12847849" author="cmale" created="Sat, 20 Mar 2010 23:54:49 +0000"  >&lt;p&gt;Attaching patch for changes to Document implementing above ideas discussed above&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Document#getFields() is deprecated&lt;/li&gt;
	&lt;li&gt;Document now implements Iterable&amp;lt;Fieldable&amp;gt; and provides an iterator() method&lt;/li&gt;
	&lt;li&gt;Added a getNumFields() method for returning the number of fields in a Document&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Having not paid attention earlier, there is already a removeFields method in Document, so it didn&apos;t need to be added.&lt;/p&gt;

&lt;p&gt;There are some greater problems with Document related to this issue.  It provides methods for both Fieldables and Fields, getField(String) for example, could throw a ClassCastException if used in combination with AbstractField.  Because the overall goal of this work is to reduce these 3 classes to just Field in 4.x, I think we can leave the methods as most will be deprecated.  However some documentation improvements might prevent any CCEs.&lt;/p&gt;

&lt;p&gt;I&apos;ll spin off another issue later to do that once this stuff has been committed.&lt;/p&gt;</comment>
                    <comment id="12847857" author="cmale" created="Sun, 21 Mar 2010 00:45:49 +0000"  >&lt;p&gt;Attaching patch that migrates core (including tests) away from Document#getFields().&lt;/p&gt;</comment>
                    <comment id="12847898" author="thetaphi" created="Sun, 21 Mar 2010 08:13:06 +0000"  >&lt;p&gt;I would make the iterator() unmodifiable (without remove()), so map the list before with Collections.umodifiableList(). Any comments?&lt;/p&gt;</comment>
                    <comment id="12847911" author="cmale" created="Sun, 21 Mar 2010 10:36:16 +0000"  >&lt;p&gt;Hi Uwe,&lt;/p&gt;

&lt;p&gt;Yes you are right.  That was one of the original motivations for this work!  I will make the appropriate change now.&lt;/p&gt;</comment>
                    <comment id="12847912" author="cmale" created="Sun, 21 Mar 2010 10:48:13 +0000"  >&lt;p&gt;Attached new version of Document change which makes the Iterator unmodifiable.   Noted this fact in the javadoc for the iterator() method.&lt;/p&gt;</comment>
                    <comment id="12847914" author="cmale" created="Sun, 21 Mar 2010 11:13:16 +0000"  >&lt;p&gt;The patch I just attached makes a test in InstantiatedIndex fail because it tries to remove a field through the iterator.  This illustrates a concern I have with making the iterator unmodifiable, there is no efficient way to remove a field while iterating, without also running into a CCE.  I will think over this issue a little bit before deciding whether to continue with the unmodifiable iterator or not.&lt;/p&gt;</comment>
                    <comment id="12851794" author="mikemccand" created="Wed, 31 Mar 2010 10:47:35 +0100"  >&lt;p&gt;I wonder if, like we&apos;re thinking for analysis, we can substantially&lt;br/&gt;
reduce the Document/Field API that&apos;s consumed by the indexer....&lt;/p&gt;

&lt;p&gt;Really all indexer needs to do is:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Iterate the indexed fields, for each getting a name, a TokenStream&lt;br/&gt;
    (or possibly something more pared-back &amp;#8211; don&apos;t need close nor&lt;br/&gt;
    reset), and a FieldType containing indexing settings (omits&lt;br/&gt;
    positions, omits term freq, etc.)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Iterate the stored fields, for each getting name and value (or,&lt;br/&gt;
    possibly, only a serialize() method, instead?)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The iterators would be unmodifiable.&lt;/p&gt;

&lt;p&gt;Indexer could care less how these are implemented.&lt;/p&gt;

&lt;p&gt;Lucene would still provide a fully featured concrete Document/Field&lt;br/&gt;
classes that&apos;re app-friendly, ie malleable, with clear, add/remove&lt;br/&gt;
fields, etc.  I think Document &amp;amp; Field can be fully concrete?  Ie no&lt;br/&gt;
more AbstractField/Fieldable.  It&apos;s simply a convenience class offered&lt;br/&gt;
to apps.&lt;/p&gt;

&lt;p&gt;Indexer would not see that class.  It would only see the above minimal&lt;br/&gt;
interface.  So for expert apps that don&apos;t want to use Lucene&apos;s&lt;br/&gt;
convenient Document/Field, they can easily make their own impls of&lt;br/&gt;
that interface.&lt;/p&gt;</comment>
                    <comment id="12851812" author="cmale" created="Wed, 31 Mar 2010 11:46:41 +0100"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;I think this is a great idea.&lt;/p&gt;

&lt;p&gt;Having a clear separation from the &apos;core space&apos; where the indexer sits, and the &apos;user space&apos; gives us the freedom to address the Document/Fieldable class stack problems.&lt;/p&gt;

&lt;p&gt;We could introduce an IndexableDocument abstraction (which Document would implement) which provides the stripped down API that the indexer needs for Documents, which is just a way to get the fields to index and store. &lt;/p&gt;

&lt;p&gt;Given that the indexer need only know the name, type and value/tokenstream for a Field, we can visualize this as just a tuple.  Therefore the IndexableDocument, rather than returning Fields, could return instances of a new Tuple class, which would be immutable.  Field would then implement Tuple.&lt;/p&gt;

&lt;p&gt;Document and Field would then be exactly as suggested, &apos;user space&apos; app friendly mutable classes.  &lt;/p&gt;

&lt;p&gt;On the search side, the &apos;core space&apos; wouldn&apos;t know of the idea of a Document, but rather a set of tuples.  We would then allow different consumers of those tuples to be provided.  One such consumer would use the tuples to build Documents and Fields again. &lt;/p&gt;</comment>
                    <comment id="12851819" author="earwin" created="Wed, 31 Mar 2010 12:10:49 +0100"  >&lt;p&gt;Yahoo! +1 for introducing barebones interface for the indexer.&lt;/p&gt;</comment>
                    <comment id="12851829" author="shaie" created="Wed, 31 Mar 2010 12:56:29 +0100"  >&lt;p&gt;+1 for this simplification. Can we just name it Indexable, and omit Document from it? That way, it&apos;s both shorter and less chances for users to directly link it w/ Document.&lt;/p&gt;

&lt;p&gt;One thing I didn&apos;t understand though, is what will happen to ir/is.doc() method? Will those be deprecated in favor of some other class which receives an IR as parameter and knows how to re-construct Indexable(Document)?&lt;/p&gt;</comment>
                    <comment id="12851832" author="cmale" created="Wed, 31 Mar 2010 13:09:02 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Can we just name it Indexable, and omit Document from it? That way, it&apos;s both shorter and less chances for users to directly link it w/ Document.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;One thing I didn&apos;t understand though, is what will happen to ir/is.doc() method? Will those be deprecated in favor of some other class which receives an IR as parameter and knows how to re-construct Indexable(Document)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I imagine some sort of callback which the IR/IS call with the information they take from the index.  One default implementation we could provide would re-construct Indexables, and one could re-construct Documents for the userspace.&lt;/p&gt;</comment>
                    <comment id="12851839" author="earwin" created="Wed, 31 Mar 2010 13:27:21 +0100"  >&lt;p&gt;Can&apos;t we keep interfaces for indexing and retrieval separate?&lt;br/&gt;
Isn&apos;t that the whole freaking point - having a minimal-area interface to index stuff, with possibly widely varying implementations. You can&apos;t reconstruct Indexable by definition, as it is user-defined and provided.&lt;br/&gt;
Your average back-compat Document may be one implementation, but I can have an implementation that just reads stuff from the socket and shoves it into the index, streaming-style - how&apos;re you going to reconstruct that?&lt;/p&gt;</comment>
                    <comment id="12851842" author="shaie" created="Wed, 31 Mar 2010 13:35:52 +0100"  >&lt;p&gt;Right Earwin - agreed.&lt;/p&gt;

&lt;p&gt;I&apos;d like to summarize a brief discussion we had on IRC around that:&lt;br/&gt;
The idea is not to provide another interface/class for search purposes, but rather expose the right API from IndexReader, even if it might be a bit low-level. API like getIndexedFields(docId) and getStorefFields(docId), both optionally take a FieldSelector, should allow the application to re-construct its Indexable however it wants. And IR/IS don&apos;t need to know anything about that.&lt;br/&gt;
To complete the picture for current users, we can have a static reconstruct() on Document which takes IR, docId and FieldSelector ...&lt;/p&gt;

&lt;p&gt;BTW, I&apos;m not even sure getIndedxedFields can be efficiently supported today. Just listing it here for completeness.&lt;/p&gt;</comment>
                    <comment id="12851844" author="cmale" created="Wed, 31 Mar 2010 13:43:08 +0100"  >&lt;p&gt;Earwin,&lt;/p&gt;

&lt;p&gt;Yeah definitely we want to keep things separate.  I am infavour of Indexable being an indexing only construct, staying in the index part of the core space.  However Document will be a user space construct that spans both indexing and searching since its API is designed to be flexible and easy to use and manipulate.&lt;/p&gt;

&lt;p&gt;Writing implements of Indexable will be an expert thing I imagine, so if you index bytes taken from a socket, then I imagine you&apos;ll choose an implementation on the search side that can handle it.  If your stream from a socket has some custom stuff, then you could write a custom consumer on the search side that builds whatever search construct you want.&lt;/p&gt;</comment>
                    <comment id="12851849" author="thetaphi" created="Wed, 31 Mar 2010 13:57:54 +0100"  >&lt;p&gt;I am also +1 on the indexer interface.&lt;/p&gt;

&lt;p&gt;I just repeat myself: We still need TokenStream, an AttributeSource alone is too less. But that is away from that issue: Indexable provides an iterator of fields that consist of name and TokenStream and some options (possibly like omitNorms). If you just dont want to have close() in TokenStream, let&apos;s remove it. end() is needed for offsets, the indexer need to take care. incrementToken() is the iterator approach. What else is there? Reset may be invisible to indexer (I would refactor that and would make a subclass of TokenStream that supports reset, ResetableTokenStream - like Tokenizer supports reset(Reader), which is also a subclass). The abstract TokenStream then is only consisting of incrementToken() and end() + the AttributeSource access methods. Attributes needed by indexer are only TermToBytesRefAttribute, PositionIncrementAtt, OffsetAttribute and PayloadAttribute.&lt;/p&gt;</comment>
                    <comment id="12851850" author="cmale" created="Wed, 31 Mar 2010 14:02:16 +0100"  >&lt;p&gt;Hi Uwe,&lt;/p&gt;

&lt;p&gt;I envisaged the Indexable providing Tuples of  field name, field type, and TokenStream as it is today.  So I think we shouldn&apos;t run into any problems?&lt;/p&gt;</comment>
                    <comment id="12851856" author="thetaphi" created="Wed, 31 Mar 2010 14:21:34 +0100"  >&lt;p&gt;Yeah!&lt;/p&gt;</comment>
                    <comment id="13009989" author="cmale" created="Wed, 23 Mar 2011 04:09:14 +0000"  >&lt;p&gt;Reactivating this issue.  &lt;/p&gt;

&lt;p&gt;New patch against 3x (since its all about deprecations).  AbstractField and Fieldable are deprecated.  Document is changed a little in preparation for using Field.  Code cleanup in Field.&lt;/p&gt;

&lt;p&gt;I&apos;m going to leave the suggested larger changes to Document and Field for a later issue.  I really want to get these classes out of trunk so I can then visualize the code better.&lt;/p&gt;</comment>
                    <comment id="13010022" author="simonw" created="Wed, 23 Mar 2011 08:07:54 +0000"  >&lt;p&gt;Hey Chris,&lt;/p&gt;

&lt;p&gt;good that you reactivate this issue! I was looking into similar stuff while working on docvalues since it really needs to add stuff to Field / Fieldable. With a cleanup and eventually FieldType this would be way less painless I guess. I have a couple of questions and comments to the current patch. &lt;br/&gt;
Btw. I like the fact that the previous patch was uploaded March 21 2010 and the latest took 1 year to come up on march 23 2011 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Why do you reformat all the stuff in Field, is that necessary here at all? I mean its needed eventually but for the deprecation of things it only bloats the patch really doesn&apos;t it?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;When you deprecate AbstractField and Fieldable, Field should ideally be a standalone class. So I see that this still needs to subclass Fieldable / AbstractField but could it stand alone now so that we can simply remove the extends / implements on Field once we drop things in 4.0? I think it looks good from looking at the patch though&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I don&apos;t like the name getAllFields on Document since it implies that we have a getPartialFields or something. I see that you can not use getFields since it only differs in return type which doesn&apos;t belong to the signature though. Maybe we should implement Iterable&amp;lt;Field&amp;gt; here and offer an additional method getFieldsAsList or maybe getFields(List&amp;lt;Field&amp;gt; fields)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;once we have this in what are the next steps towards FieldType? Will we have only one class Field that is backed by a FieldType but still offers the methods it has now? Or doe we have two totally new classes FieldTyps and FieldValue, something like this:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; 
class FieldValue {
  FieldType type;
  &lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; boost;
  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; name;
  &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; value;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I wonder if this patch raises tons of deprecation warnings all over lucene where Fieldable was used? In IW we use it all over the place though. We must fix that in this issue too otherwise uwe will go mad I guess &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;thanks for bringing this up again!&lt;/p&gt;</comment>
                    <comment id="13010027" author="cmale" created="Wed, 23 Mar 2011 08:27:14 +0000"  >&lt;p&gt;Thanks for taking a look at this Simon.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Why do you reformat all the stuff in Field, is that necessary here at all? I mean its needed eventually but for the deprecation of things it only bloats the patch really doesn&apos;t it?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because for me this issue is about reducing the complexity of these classes and Field is a mess.  Making it more readable reduces the complexity.  If needs be I will do this in two patches, but I don&apos;t feel this issue is resolved till the code in Field is readable.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;When you deprecate AbstractField and Fieldable, Field should ideally be a standalone class. So I see that this still needs to subclass Fieldable / AbstractField but could it stand alone now so that we can simply remove the extends / implements on Field once we drop things in 4.0? I think it looks good from looking at the patch though&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t really understand what you&apos;re suggesting here.  In 3x where the deprecations will be occurring Field has to continue to extend AbstractField.  Yes in 4.0 we can drop that extension but addressing the deprecations is not in the scope of 3x.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t like the name getAllFields on Document since it implies that we have a getPartialFields or something. I see that you can not use getFields since it only differs in return type which doesn&apos;t belong to the signature though. Maybe we should implement Iterable&amp;lt;Field&amp;gt; here and offer an additional method getFieldsAsList or maybe getFields(List&amp;lt;Field&amp;gt; fields)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah good call.  I think implementing Iterable&amp;lt;Field&amp;gt; is best, but it will also require adding a count() method to Document since often people retrieve the List to get the number of fields.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;once we have this in what are the next steps towards FieldType? Will we have only one class Field that is backed by a FieldType but still offers the methods it has now? Or doe we have two totally new classes FieldTyps and FieldValue&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Once FieldType is in, all the various metadata properties (isIndexed, isStored etc) will be moved to FieldType, leaving Field as what you suggest as FieldValue.  Field will contain its type, boost, name, value.  If we have Analyzers on FieldTypes, then we will be able to remove the TokenStream from Field.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I wonder if this patch raises tons of deprecation warnings all over lucene where Fieldable was used? In IW we use it all over the place though. We must fix that in this issue too otherwise uwe will go mad I guess&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah but not in 3x unfortunately.  As it stands people can retrieve the List of Fieldables via getFields() and add whatever implementation of Fieldable they like.  Consequently we need to continue to support Fieldable in IW for example.  Once this code has been committed I will create a new patch for trunk which moves all of Solr and Lucene over to the Field.  I could do this in many places already of course, but that core classes like IW would have to remain as they are.&lt;/p&gt;

&lt;p&gt;I will wait for your thoughts on the reformating and then make a new patch.&lt;/p&gt;
</comment>
                    <comment id="13010030" author="simonw" created="Wed, 23 Mar 2011 08:57:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t really understand what you&apos;re suggesting here. In 3x where the deprecations will be occurring Field has to continue to extend AbstractField. Yes in 4.0 we can drop that extension but addressing the deprecations is not in the scope of 3x.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What I mean here is that if I would simply remove the extends AbstractField from Field would it still compile or are there any dependencies from AbstractField? IMO AbstractField should just be empty now right?&lt;/p&gt;</comment>
                    <comment id="13010032" author="cmale" created="Wed, 23 Mar 2011 09:07:56 +0000"  >&lt;p&gt;Yes Field would still compile if you removed the extends.  However if we empty AbstractField then any client code that also extends AbstractField would break.  Thats why I deprecate the whole class but leave its code in.  We could empty it and change it to extend Field, I think that would still work.&lt;/p&gt;</comment>
                    <comment id="13010035" author="simonw" created="Wed, 23 Mar 2011 09:19:05 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Yeah but not in 3x unfortunately. As it stands people can retrieve the List of Fieldables via getFields() and add whatever implementation of Fieldable they like. Consequently we need to continue to support Fieldable in IW for example. Once this code has been committed I will create a new patch for trunk which moves all of Solr and Lucene over to the Field. I could do this in many places already of course, but that core classes like IW would have to remain as they are.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So, what is the reason for doing this in 3.x at all, can&apos;t we simply drop stuff in 4.0 and let 3.x alone?&lt;/p&gt;

&lt;p&gt;Simon&lt;/p&gt;</comment>
                    <comment id="13010036" author="cmale" created="Wed, 23 Mar 2011 09:31:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, what is the reason for doing this in 3.x at all, can&apos;t we simply drop stuff in 4.0 and let 3.x alone?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Very good question.  Certainly we are simplifying the codebase and I feel that Field is what most users use (not AbstractField).  But I know some expert users do use AbstractField.  But maybe they can handle the hard change?&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12439380" name="LUCENE-2310-Deprecate-AbstractField-CleanField.patch" size="42089" author="cmale" created="Sat, 20 Mar 2010 23:08:53 +0000" />
                    <attachment id="12438700" name="LUCENE-2310-Deprecate-AbstractField.patch" size="20644" author="cmale" created="Sat, 13 Mar 2010 19:42:36 +0000" />
                    <attachment id="12438698" name="LUCENE-2310-Deprecate-AbstractField.patch" size="17601" author="cmale" created="Sat, 13 Mar 2010 19:12:13 +0000" />
                    <attachment id="12438694" name="LUCENE-2310-Deprecate-AbstractField.patch" size="15505" author="cmale" created="Sat, 13 Mar 2010 17:25:55 +0000" />
                    <attachment id="12439384" name="LUCENE-2310-Deprecate-DocumentGetFields-core.patch" size="16037" author="cmale" created="Sun, 21 Mar 2010 00:45:49 +0000" />
                    <attachment id="12439404" name="LUCENE-2310-Deprecate-DocumentGetFields.patch" size="2038" author="cmale" created="Sun, 21 Mar 2010 10:48:13 +0000" />
                    <attachment id="12439383" name="LUCENE-2310-Deprecate-DocumentGetFields.patch" size="1990" author="cmale" created="Sat, 20 Mar 2010 23:54:49 +0000" />
                    <attachment id="12474367" name="LUCENE-2310.patch" size="47662" author="cmale" created="Wed, 23 Mar 2011 04:09:14 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 11 Mar 2010 19:21:07 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11484</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25415</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>