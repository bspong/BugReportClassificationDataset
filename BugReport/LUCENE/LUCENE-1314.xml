<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 12:58:45 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1314/LUCENE-1314.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1314] IndexReader.clone</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1314</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Based on discussion &lt;a href=&quot;http://www.nabble.com/IndexReader.reopen-issue-td18070256.html&quot; class=&quot;external-link&quot;&gt;http://www.nabble.com/IndexReader.reopen-issue-td18070256.html&lt;/a&gt;.  The problem is reopen returns the same reader if there are no changes, so if docs are deleted from the new reader, they are also reflected in the previous reader which is not always desired behavior.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12398848">LUCENE-1314</key>
            <summary>IndexReader.clone</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="jasonrutherglen">Jason Rutherglen</reporter>
                        <labels>
                    </labels>
                <created>Mon, 23 Jun 2008 17:27:55 +0100</created>
                <updated>Fri, 25 Sep 2009 17:23:06 +0100</updated>
                    <resolved>Sun, 1 Mar 2009 12:12:52 +0000</resolved>
                            <version>2.3.1</version>
                                <fixVersion>2.9</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12607296" author="jasonrutherglen" created="Mon, 23 Jun 2008 18:13:51 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;First cut at this, seems to work as desired.  Need to come up with a test case for it.  &lt;/p&gt;

&lt;p&gt;Does anyone know how to turn off Eclipse automatically changing the import statements?  I am not making it reformat but if I edit some code in a file it sees fit to reformat the imports.  &lt;/p&gt;</comment>
                    <comment id="12607609" author="jasonrutherglen" created="Tue, 24 Jun 2008 14:23:44 +0100"  >&lt;p&gt;A package protected field &quot;boolean openNewFieldsReader = true;&quot; (defaults to true to mimic previous behavior) should be added to SegmentReader to allow subclasses to determine if they want a new fieldsReader opened everytime a reopen occurs.  The SegmentReader.doClose would need to not close fieldsReader if the openNewFieldsReader was set to false.&lt;/p&gt;

&lt;p&gt;The SegmentReader.reopenSegment method directly instantiates a SegmentReader rather than using IMPL like SegmentReader.get(Directory dir, SegmentInfo si, SegmentInfos sis, boolean closeDir, boolean ownDir, int readBufferSize, boolean  doOpenStores) does.&lt;/p&gt;

&lt;p&gt;In my SegmentReader subclass I am passing a lock and passing a reference to fieldsReader for global locking and a single fieldsReader across all instances.  Otherwise there are too many instances of fieldsReader and file descriptors will be used up.  &lt;/p&gt;</comment>
                    <comment id="12607654" author="jasonrutherglen" created="Tue, 24 Jun 2008 16:38:11 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Included the changes mentioned to allow a subclass of SegmentReader to not load fieldsReader on every reopen.  Added the IMPL based instantiation in reopenSegment.  SegmentReader.doClose does not close fieldsReader if openNewFieldsReader is false.&lt;/p&gt;</comment>
                    <comment id="12607681" author="jasonrutherglen" created="Tue, 24 Jun 2008 17:55:48 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Added SegmentReader protected BitVector cloneDeletedDocs() that allows subclasses to do the cloning.  This will allow for pooling reuse if many reopens occur and many BitVectors are created.  &lt;/p&gt;</comment>
                    <comment id="12607857" author="nyh" created="Wed, 25 Jun 2008 06:01:57 +0100"  >&lt;p&gt;At first glance, my opinion was that adding this flag to reopen() is confusing. reopen()&apos;s current behavior is explained well in the documentation, and has a particular use case in mind (checking if the index has changed, and if it has, reopen it). Frankly, I didn&apos;t understand why reopen() should (even with the addition of a new parameter) clone or &quot;copy on write&quot; the IndexReader when the index hasn&apos;t changed.&lt;br/&gt;
If this capability is needed, wouldn&apos;t it have been clearer if IndexReader had some new clone() or copyOnWrite() (in IndexReader&apos;s case, a write would actually be a delete...) method that can be called to get a new object that behaves independently from the previous one when it comes to writing (again, a delete)?&lt;br/&gt;
In your code, you could then do something like&lt;/p&gt;

&lt;p&gt;newIndexReader = indexReader.reopen();&lt;br/&gt;
if(newIndexReader==indexReader)&lt;br/&gt;
  newIndexReader = indexReader.clone(); // copy on write&lt;br/&gt;
else {&lt;br/&gt;
   oldIndexReader.close(); // most applications won&apos;t do this here, but never mind now.&lt;br/&gt;
}&lt;br/&gt;
indexReader = newIndexReader;&lt;/p&gt;

&lt;p&gt;I thought that this was a cleaner API, because reopen() isn&apos;t complicated with an extra flag that has nothing to do with its intended function, and the new clone() or copyOnWrite() method can also be used in other situations when you want different objects of the same index to handle deletes separately.&lt;/p&gt;

&lt;p&gt;But on second glance, it dawned on me: You can&apos;t actually delete on both objects at once, because when you start deleting in one object, it holds a lock and then you can&apos;t do deletions in the second object! So I have to admit, the usefulness of of a general clone/copyOnWrite feature for IndexReader is quite limited. My suggestion above can still be the API, but I admit it will hardly be useful in any situation except (the rare situation nowadays of?) a reopen() and later deletes.&lt;/p&gt;</comment>
                    <comment id="12607954" author="mikemccand" created="Wed, 25 Jun 2008 11:52:50 +0100"  >&lt;blockquote&gt;&lt;p&gt;In my SegmentReader subclass I am passing a lock and passing a reference to fieldsReader for global locking and a single fieldsReader across all instances. Otherwise there are too many instances of fieldsReader and file descriptors will be used up.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe instead we should just fix access to FieldsReader to be thread safe, either by making FieldsReader itself thread safe, or by doing something similar to what&apos;s done for TermVectorsReader (where each thread makes a &quot;shallow&quot; clone of the original TermVectorsReader, held in a ThreadLocal instance).  If we do that, then in SegmentReader.doReopen()  we never have to clone FieldsReader.&lt;/p&gt;</comment>
                    <comment id="12608039" author="jasonrutherglen" created="Wed, 25 Jun 2008 14:39:20 +0100"  >&lt;p&gt;Here is the code of the SegmentReader subclass.  Using the clone terminology would work as well, inside of SegmentReader the clone would most likely reuse SegmentReader.reopenSegment.  The subclass turns off locking by overriding acquireWriteLock and having it do nothing.  I do not know a general fix for the locking issue mentioned &quot;it holds a lock and then you can&apos;t do deletions in the second object&quot;.  Perhaps there is a way using lock less commits.  It is possible to have SegmentReader implement if deletes occur to an earlier IndexReader and a flush is tried it fails, rather than fail in a newer IndexReader like it would now.  This would require keeping track of later IndexReaders which is something Ocean does outside of IndexReader.  &lt;/p&gt;

&lt;p&gt;As far as the FieldsReader, given how many SegmentReaders Ocean creates (up to one per update), a shallow clone threadlocal would still potentially create many file descriptors.  I would rather see a synchronized FieldsReader, or simply use the approach in the code below.  The external lock used seems ok because there is little competition for reading Documents, no more than normal a Lucene application using a single IndexReader loading documents for N results.  &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class OceanSegmentReader &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; SegmentReader {
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; ReentrantLock fieldsReaderLock;
  
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; OceanSegmentReader() {
    openNewFieldsReader = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
  }
  
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void doInitialize() {
    fieldsReaderLock = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();
  }
  
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void acquireWriteLock() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
  }
  
  &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; DirectoryIndexReader doReopen(SegmentInfos infos, &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; force) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
    OceanSegmentReader segmentReader = (OceanSegmentReader)&lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.doReopen(infos, force);
    segmentReader.fieldsReaderLock = fieldsReaderLock;
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; segmentReader;
  }
  
  /**
   * @&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException
   *           &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the index is corrupt
   * @&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException
   *           &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there is a low-level IO error
   */
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; Document document(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n, FieldSelector fieldSelector) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
    ensureOpen();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isDeleted(n))
      &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-quote&quot;&gt;&quot;attempt to access a deleted document&quot;&lt;/span&gt;);
    fieldsReaderLock.lock();
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getFieldsReader().doc(n, fieldSelector);
    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
      fieldsReaderLock.unlock();
    }
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12608635" author="jasonrutherglen" created="Fri, 27 Jun 2008 02:34:22 +0100"  >&lt;p&gt;Using the patch and the above subclass of SegmentReader received the following bug.  I am assuming it has something to do with SegmentInfos committing.  Ideally the new clone method of IndexReader will avoid things like reloading SegmentInfos from disk each time.  That will probably slow down the rapid updates too much.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1) testSearch(org.apache.lucene.ocean.TestSearch)java.lang.AssertionError: delete count mismatch: info=1 vs BitVector=5
at org.apache.lucene.index.SegmentReader.loadDeletedDocs(SegmentReader.java:365)
at org.apache.lucene.index.SegmentReader.initialize(SegmentReader.java:328)
at org.apache.lucene.index.SegmentReader.get(SegmentReader.java:267)
at org.apache.lucene.index.SegmentReader.get(SegmentReader.java:235)
at org.apache.lucene.index.DirectoryIndexReader$1.doBody(DirectoryIndexReader.java:90)
at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:649)
at org.apache.lucene.index.DirectoryIndexReader.open(DirectoryIndexReader.java:97)
at org.apache.lucene.index.IndexReader.open(IndexReader.java:213)
at org.apache.lucene.index.IndexReader.open(IndexReader.java:209)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12609071" author="mikemccand" created="Sun, 29 Jun 2008 10:44:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;Using the patch and the above subclass of SegmentReader received the following bug. I am assuming it has something to do with SegmentInfos committing. Ideally the new clone method of IndexReader will avoid things like reloading SegmentInfos from disk each time. That will probably slow down the rapid updates too much.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right, that exception happens because you are carrying your own deletedDocs in memory to the new SegmentReader without first saving them to the _X_N.del file for that segment.  The new clone() approach definitely should not reload the segments_N file, and thus not call SegmentReader.initialize.&lt;/p&gt;</comment>
                    <comment id="12609072" author="mikemccand" created="Sun, 29 Jun 2008 10:51:10 +0100"  >&lt;blockquote&gt;&lt;p&gt;It is possible to have SegmentReader implement if deletes occur to an earlier IndexReader and a flush is tried it fails, rather than fail in a newer IndexReader like it would now. This would require keeping track of later IndexReaders which is something Ocean does outside of IndexReader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think this is tricky, since SegmentReader doesn&apos;t explicitly track whether there is a &quot;cloned&quot; reader out there.  As things stand now, there is no such thing as a cloned reader, and so the only way that another SegmentReader is out there is if there have been commits to the index, in which case isCurrent() returns false and the old reader will not allow deletes to be performed.  I suppose we could look at the refCount of the IndexReader: any reader that has been cloned and not yet closed will have a refCount &amp;gt; 1, whereas the last reader returned from a clone() call will have refCount 1.&lt;/p&gt;

&lt;p&gt;So unless we try to track this, when there are N clones out there, any one of them will be allowed to grab the write lock when a change (deletion or setNorm) is attempted, thus preventing all the other clones (and all readers open on previous commits) from making changes.&lt;/p&gt;</comment>
                    <comment id="12609116" author="jasonrutherglen" created="Sun, 29 Jun 2008 16:17:39 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Added fieldsReaderLocal to SegmentReader.  reopenSegment passed the fieldsReaderLocal and termVectorsLocal to the new SegmentReader.  In the current version, a new termVectorsLocal is created for each SegmentReader which made reuse of the previously created TermVectorsReaders for a thread unavailable.  The same is implemented for fieldsReaderLocal.  &lt;/p&gt;

&lt;p&gt;The locking needs a default mechanism.  For my own purposes I will likely turn it off, the bug I posted was really the fault of the Ocean code since fixed.  &lt;/p&gt;

&lt;p&gt;Would like to be able to optionally have this line run in DirectoryIndexReader in reopen.  Does it need to be run on a clone?&lt;/p&gt;

&lt;p&gt;SegmentInfos infos = new SegmentInfos();&lt;br/&gt;
infos.read(directory, segmentFileName);&lt;/p&gt;</comment>
                    <comment id="12609456" author="hossman" created="Tue, 1 Jul 2008 06:10:18 +0100"  >&lt;p&gt;I haven&apos;t really been following this issue, but this comment caught my eye...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;So unless we try to track this, when there are N clones out there, any one of them will be allowed to grab the write lock when a change (deletion or setNorm) is attempted, thus preventing all the other clones (and all readers open on previous commits) from making changes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;...and gave me an erie sense of deja vu.  looking back at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-743&quot; title=&quot;IndexReader.reopen()&quot;&gt;&lt;del&gt;LUCENE-743&lt;/del&gt;&lt;/a&gt;, the original approach for reopen was based on cloning and prompted this comment from me...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-743?focusedCommentId=12534123#action_12534123&quot; class=&quot;external-link&quot;&gt;https://issues.apache.org/jira/browse/LUCENE-743?focusedCommentId=12534123#action_12534123&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;...which led to some interesting discussion about what the semantics of cloning an IndexReader should be (even though ultimately cloning wasn&apos;t used).&lt;/p&gt;
</comment>
                    <comment id="12609999" author="mikemccand" created="Wed, 2 Jul 2008 19:26:04 +0100"  >&lt;blockquote&gt;&lt;p&gt;...which led to some interesting discussion about what the semantics of cloning an IndexReader should be (even though ultimately cloning wasn&apos;t used).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In fact that 2nd point you raised (&quot;what happens when you clone an IndexReader that has pending changes&quot;) makes me nervous here.  I think I&apos;d prefer that we disallow that (throw an exception when this is attempted).  Ie you can only clone a reader that has no pending changes.&lt;/p&gt;

&lt;p&gt;Also Jason you added set/getWriteLock: how come you couldn&apos;t just customize LockFactory for that, instead?  Eg if you want to turn off locking you can just use NoLockFactory.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Would like to be able to optionally have this line run in DirectoryIndexReader in reopen. Does it need to be run on a clone?&lt;/p&gt;

&lt;p&gt;SegmentInfos infos = new SegmentInfos();&lt;br/&gt;
infos.read(directory, segmentFileName);&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree that line should not run on clone().&lt;/p&gt;</comment>
                    <comment id="12610065" author="jasonrutherglen" created="Wed, 2 Jul 2008 23:05:54 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;SegmentReader.doReopen throws an IOException when deletedDocsDirty or normsDirty is true.  DirectoryIndexReader getLock and setLock removed.  Added isCurrent check in DirectoryIndexReader.doCommit, as per a few comments ago regarding making sure the commit only happens to the latest index.&lt;/p&gt;</comment>
                    <comment id="12610203" author="mikemccand" created="Thu, 3 Jul 2008 12:48:06 +0100"  >&lt;p&gt;I don&apos;t think we need to check isCurrent() in doCommit() because since&lt;br/&gt;
the reader holds the write lock it is necessarily current?&lt;/p&gt;

&lt;p&gt;I can&apos;t compile with your patch.  It seems like you have changes to&lt;br/&gt;
BitVector.java which did&apos;t make it into the patch?  Eg the getBits()&lt;br/&gt;
method.&lt;/p&gt;

&lt;p&gt;I attached a new version with these changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Throw IllegalStateException if you try to clone a reader that has&lt;br/&gt;
    pending changes.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Clone the SegmentInfos, instead of just taking a reference, in&lt;br/&gt;
    DirectoryIndexReader&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Changed &quot;public abstract Object clone()&quot; in IndexReader to be a&lt;br/&gt;
    method that throws UnsupportedOperationException instead&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Renamed a few things; removed some whitespace only diffs.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Factored up doReopenOrClone into IndexReader&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;One difference between clone() and reopen() is you force the&lt;br/&gt;
deletedDocs BitVector to be cloned in SegmentReader during clone(),&lt;br/&gt;
but not during reopen().  With reopen() we &quot;declared&quot; that if you make&lt;br/&gt;
changes to your reopened reader, it&apos;s undefined what happens to your&lt;br/&gt;
old readers.  Ie, it&apos;s a &quot;don&apos;t do that&quot; situation.&lt;/p&gt;

&lt;p&gt;But with clone() the situation is reversed: the whole reason why you&lt;br/&gt;
make a clone() is to isolate any changes in the new reader from being&lt;br/&gt;
visible to the old reader.  Given that, I think you also must clone()&lt;br/&gt;
the norms right?&lt;/p&gt;

&lt;p&gt;Jason could you add cloning of norms, and add some unit tests, to the&lt;br/&gt;
patch?  Thanks.&lt;/p&gt;
</comment>
                    <comment id="12610244" author="jasonrutherglen" created="Thu, 3 Jul 2008 15:53:32 +0100"  >&lt;p&gt;&amp;gt; check isCurrent()&lt;/p&gt;

&lt;p&gt;I thought we wanted to check a commit on a clone that the index is current?  Does it need to be in a clone only portion of the code?  Which class is best?&lt;/p&gt;

&lt;p&gt;&amp;gt; clone() the norms &lt;/p&gt;

&lt;p&gt;We need to clone norms.  I want to make cloning deletedDocs and norms optional mainly because it is a waste in Ocean to clone norms.  Is the best way to give the option parameters to the clone method (breaking Cloneable)?  An additional option could be readOnly.  Perhaps norms or deletedDocs becomes readOnly if they are ref copied and not cloned.  IndexReader.open and reopen would need a readOnly parameter.  Or should a subclass of SegmentReader handle cloning or refing norms and deletedDocs.&lt;/p&gt;

&lt;p&gt;I think it may be easiest to have readOnly be a part of this patch.  I wanted to separate out the FieldsReader synchronization code into a separate patch but then this patch would have been messed up without it (the new FieldsReader per SegmentReader issue).  Readonly may end up being similar.  &lt;/p&gt;

&lt;p&gt;The newlines is another Eclipse thing I haven&apos;t figured out yet.  &lt;/p&gt;</comment>
                    <comment id="12610260" author="mikemccand" created="Thu, 3 Jul 2008 16:38:41 +0100"  >&lt;blockquote&gt;&lt;p&gt;I thought we wanted to check a commit on a clone that the index is current? Does it need to be in a clone only portion of the code? Which class is best?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think checking when a change is first made (and grabbing the write.lock to prevent others) is safer?  Else you could lose changes you had made.  Ie if there are clones out there, the first one that starts making changes prevents any others from doing so.  But I feel like I&apos;m missing something about Ocean: was there some driver for checking on commit instead?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We need to clone norms. I want to make cloning deletedDocs and norms optional mainly because it is a waste in Ocean to clone norms. Is the best way to give the option parameters to the clone method (breaking Cloneable)? An additional option could be readOnly. Perhaps norms or deletedDocs becomes readOnly if they are ref copied and not cloned. IndexReader.open and reopen would need a readOnly parameter. Or should a subclass of SegmentReader handle cloning or refing norms and deletedDocs.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;d be nice if we could do a copy-on-write approach.  This way no copy is made when you first clone, but if you go to make a change, it makes a private copy only at that point.  And you don&apos;t have to separately specify a readOnly up front only to find later you didn&apos;t pass in the right value.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think it may be easiest to have readOnly be a part of this patch. I wanted to separate out the FieldsReader synchronization code into a separate patch but then this patch would have been messed up without it (the new FieldsReader per SegmentReader issue). Readonly may end up being similar.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Maybe instead we wait on the readOnly patch until we resolve this one (ie stage them)?&lt;/p&gt;</comment>
                    <comment id="12610303" author="jasonrutherglen" created="Thu, 3 Jul 2008 19:03:52 +0100"  >&lt;p&gt;There are really only two options here and perhaps this API will work.  &lt;/p&gt;

&lt;p&gt;// true makes a copy of the data structure always, while false passes the reference if the data structure is read only or makes a copy if it is writeable. &lt;br/&gt;
IndexReader.getCopy(boolean normsWriteable, boolean deletesWriteable)&lt;br/&gt;
IndexReader.getCopyReadOnly() // defaults to getCopy(false, false)&lt;/p&gt;

&lt;p&gt;Clone can be removed or default to getCopy(true, true).  The current APIs default to getCopy(true, true).  It is good to make this explicit here so that the deletedDocs or norms cannot be changed later when it is the clear intention of the code.  It is no different than RandomAccessFile(file, &quot;r&quot;) and RandomAccessFile(file, &quot;rw&quot;)  &lt;/p&gt;

&lt;p&gt;Lucene is supposed to be designed for fast reads at the expense of writes, no?  This code in SegmentReader with the deletedDocs and norms synchronization goes against that.  I think it is important to figure out a solution to give users the option of removing synchronization in SegmentReader, users who are willing to give up a little bit in memory (norms or deletedDocs don&apos;t use very much anyways).  &lt;/p&gt;

&lt;p&gt;&amp;gt; copy-on-write approach&lt;/p&gt;

&lt;p&gt;Is the problem with isDeleted now.  The java.util.concurrent.CopyOnWriteArrayList for example uses a volatile list and synchronized update methods.  Which will not work because of JDK1.4.&lt;/p&gt;

&lt;p&gt;&amp;gt; driver for checking on commit &lt;/p&gt;

&lt;p&gt;Yes, it is more of an assertion, it can be performed in Ocean as well.  &lt;/p&gt;</comment>
                    <comment id="12610318" author="rengels@ix.netcom.com" created="Thu, 3 Jul 2008 19:55:35 +0100"  >&lt;p&gt;volatile should work on just about all 1.4.1+ JVMs, which I think is the required JVM level for Lucene anyway...&lt;/p&gt;</comment>
                    <comment id="12610330" author="jasonrutherglen" created="Thu, 3 Jul 2008 20:49:02 +0100"  >&lt;p&gt;Following up on the API comment, there can be a version of the norms or deletedDocs wrapper class for pre JDK1.5 that uses a synchronized accessor as demonstrated &lt;a href=&quot;http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/CopyOnWriteArrayList.java&quot; class=&quot;external-link&quot;&gt;http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/CopyOnWriteArrayList.java&lt;/a&gt; (works on JDK1.2 and above) and a version for JDK1.5 that uses volatile.  This is only for the writeable norms or deletedDocs anyways, but will yield results for users who continue to use the default API with a writeable IndexReader.  The null check can be synchronized and there can be a global setting that tells the IndexReader to instantiate a new deletedDocs or norms on init.  &lt;/p&gt;</comment>
                    <comment id="12610510" author="mikemccand" created="Fri, 4 Jul 2008 11:04:50 +0100"  >&lt;p&gt;Why would you ever need to make a read-only clone of a writable IndexReader?  In fact, once we have readOnly IndexReaders, why would you ever clone one?  The &lt;span class=&quot;error&quot;&gt;&amp;#91;precarious&amp;#93;&lt;/span&gt; use case that set us down this path (adding clone()) in the first place was to make a clone so that you could make changes to the clone without affecting the original reader.&lt;/p&gt;

&lt;p&gt;I think clone() should just clone() and not &quot;alter&quot; the readOnly-ness of the original IndexReader?  We could still then under the hood do copy-on-write.  We can just do this ourselves &amp;#8211; keep a boolean isShared in SegmentReader that&apos;s true when more than one SegmentReader is referencing the norms/deletedDocs.&lt;/p&gt;

&lt;p&gt;I do think we should make IndexReader.open take a readOnly boolean (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1030&quot; title=&quot;&amp;quot;Read-only&amp;quot; IndexReaders&quot;&gt;&lt;del&gt;LUCENE-1030&lt;/del&gt;&lt;/a&gt;).  In fact, maybe we should go off do that one, first, since it may change our approach to clone?  (Ie swap the order of these two)?&lt;/p&gt;</comment>
                    <comment id="12611148" author="jasonrutherglen" created="Mon, 7 Jul 2008 14:10:11 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Implemented copy on write for norms and deletedDocs when a cloned SegmentReader is created.  A copy on write ref count is used to insure the correct number of copies are created.  &lt;/p&gt;

&lt;p&gt;Includes a test case.&lt;/p&gt;</comment>
                    <comment id="12611556" author="mikemccand" created="Tue, 8 Jul 2008 13:36:18 +0100"  >&lt;p&gt;Jason, I had some problems with the latest patch.  First, it wouldn&apos;t compile, because createIndex was private in TestIndexReaderReopen.&lt;/p&gt;

&lt;p&gt;Once I changed that to protected, I&apos;m seeing this failure in TestStressIndexing2:&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testsuite: org.apache.lucene.index.TestStressIndexing2&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Tests run: 2, Failures: 2, Errors: 0, Time elapsed: 9.596 sec&lt;/p&gt;

&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- Standard Output ---------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;stored/uncompressed,indexed,termVector,termVectorOffsets,termVectorPosition&amp;lt;f71:??? &amp;gt;, stored/uncompressed,indexed,tokenized,termVector,termVectorOffsets,termVectorPosition&amp;lt;f99:E J H J H F E C I C &amp;gt;, stored/uncompressed,indexed,omitNorms&amp;lt;id:1000085&amp;gt;&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;stored/uncompressed,indexed,termVector,termVectorOffsets,termVectorPosition&amp;lt;f27:???@?p+???l? &amp;gt;, stored/uncompressed,indexed,omitNorms&amp;lt;id:1000000&amp;gt;&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;stored/uncompressed,indexed,omitNorms&amp;lt;id:12&amp;gt;&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;stored/uncompressed,indexed,termVector,termVectorOffsets,termVectorPosition,omitNorms&amp;lt;f64:C &amp;gt;, stored/uncompressed,indexed,termVector,termVectorOffsets,termVectorPosition,omitNorms&amp;lt;f90:1???t?? &amp;gt;, stored/uncompressed,indexed,omitNorms&amp;lt;id:0&amp;gt;&amp;#93;&lt;/span&gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; ------------- ---------------- ---------------&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase: testRandom(org.apache.lucene.index.TestStressIndexing2):	FAILED&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; expected:&amp;lt;3&amp;gt; but was:&amp;lt;2&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: expected:&amp;lt;3&amp;gt; but was:&amp;lt;2&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:336)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:234)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:193)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.testRandom(TestStressIndexing2.java:68)&lt;/p&gt;


&lt;p&gt;    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase: testMultiConfig(org.apache.lucene.index.TestStressIndexing2):	FAILED&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; expected:&amp;lt;1&amp;gt; but was:&amp;lt;3&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: expected:&amp;lt;1&amp;gt; but was:&amp;lt;3&amp;gt;&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:336)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:234)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:193)&lt;br/&gt;
    &lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; 	at org.apache.lucene.index.TestStressIndexing2.testMultiConfig(TestStressIndexing2.java:97)&lt;/p&gt;


&lt;p&gt;Are you seeing this too?&lt;/p&gt;</comment>
                    <comment id="12611585" author="jasonrutherglen" created="Tue, 8 Jul 2008 14:54:33 +0100"  >&lt;p&gt;I am seeing the error.  It is not norms because the test does not test norms.  It is either a problem with fieldsreader or deleted docs.  &lt;/p&gt;</comment>
                    <comment id="12611715" author="jasonrutherglen" created="Tue, 8 Jul 2008 18:49:38 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;docStoreOffset is now cloned in FieldsReader.clone() fixing the bug encountered by TestStressIndexing2.&lt;/p&gt;</comment>
                    <comment id="12611719" author="jasonrutherglen" created="Tue, 8 Jul 2008 18:52:14 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Same as previous, with TestIndexReaderClone&lt;/p&gt;</comment>
                    <comment id="12612504" author="jasonrutherglen" created="Thu, 10 Jul 2008 15:11:08 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Added protected DirectoryIndexReader.allowCloneWithChanges which allows clones with changes to be made.  Added protected IndexReader.decRef(boolean flush) and protected IndexReader.close(boolean flush) which allows subclasses to optionally flush changes.&lt;/p&gt;</comment>
                    <comment id="12612511" author="mikemccand" created="Thu, 10 Jul 2008 15:28:53 +0100"  >&lt;blockquote&gt;&lt;p&gt;Added protected DirectoryIndexReader.allowCloneWithChanges which allows clones with changes to be made.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This makes me a bit nervous.  What does it &quot;mean&quot; to clone an IndexReader that has changes?  Normally Lucene only allows one writer at a time on the index.&lt;/p&gt;</comment>
                    <comment id="12612525" author="jasonrutherglen" created="Thu, 10 Jul 2008 16:06:36 +0100"  >&lt;p&gt;Because Ocean does not flush to disk with every transaction (deleteDocument then clone the reader) there is a need to allow cloning of readers that have not flushed changes.  Rather than create a workaround, which I did that involves overriding clone and setting hasChanges=false, cloning and then setting hasChanges=true again, this seemed to be cleaner.  &lt;/p&gt;</comment>
                    <comment id="12613025" author="mikemccand" created="Sat, 12 Jul 2008 01:32:11 +0100"  >&lt;blockquote&gt;&lt;p&gt;Because Ocean does not flush to disk with every transaction (deleteDocument then clone the reader) there is a need to allow cloning of readers that have not flushed changes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But when you clone a reader with pending changes, is the old reader&apos;s write lock revoked?  Meaning it is not allowed to commit (yet, continues to hold the changes it has)?  And the newly cloned reader gets the write lock?  Are further changes allowed against the old reader, or maybe it should become &quot;frozen&quot;?&lt;/p&gt;</comment>
                    <comment id="12613973" author="jasonrutherglen" created="Wed, 16 Jul 2008 15:44:29 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;Fixed bug in SegmentReader.reopenSegment that caused the ref count of deleted docs and norms to reset after the second clone.  Added test in TestIndexReaderClone to test for this.&lt;/p&gt;

&lt;p&gt;Answering the question from a few comments ago, I don&apos;t think this patch needs to wait on IndexReader becoming read only.  &lt;/p&gt;</comment>
                    <comment id="12631041" author="mikemccand" created="Mon, 15 Sep 2008 15:49:44 +0100"  >
&lt;p&gt;Jason I&apos;d like to bring closure on this one; I think it&apos;s a good&lt;br/&gt;
addition.&lt;/p&gt;

&lt;p&gt;But the fact that this patch implies it&apos;s possible to clone an&lt;br/&gt;
IndexReader that has pending changes makes me nervous.&lt;/p&gt;

&lt;p&gt;So, could you change the patch to not include the&lt;br/&gt;
&quot;allowCloneWithChanges&quot; addition to IndexReader?  And, instead factor&lt;br/&gt;
out the current logic in DirectoryIndexReader.reopen that skips&lt;br/&gt;
checking when there are pending changes or isCurrent() returns true&lt;br/&gt;
into a new method &quot;allowReopen()&quot;?  This way you can subclass and put&lt;br/&gt;
Ocean&apos;s logic (allowing a reader with pending changes to be cloned)&lt;br/&gt;
into allowReopen().&lt;/p&gt;

&lt;p&gt;This way Lucene itself does not allow cloning a reader that has&lt;br/&gt;
changes.  But subclasses (Ocean) can still do so.&lt;/p&gt;</comment>
                    <comment id="12631430" author="jasonrutherglen" created="Tue, 16 Sep 2008 16:07:51 +0100"  >&lt;p&gt;Looks like something changed such that the test case no longer works for the norms cloning.  Having some problems figuring out what changed as it used to work.&lt;/p&gt;</comment>
                    <comment id="12631770" author="jasonrutherglen" created="Wed, 17 Sep 2008 14:30:55 +0100"  >&lt;p&gt;lucene-1314.patch&lt;/p&gt;

&lt;p&gt;The TestIndexReaderClone sometimes fails on the norms byte comparison.  The TestIndexReaderReopen fails on the ref counting.  I am not sure why yet but will look into it.&lt;/p&gt;</comment>
                    <comment id="12631840" author="mikemccand" created="Wed, 17 Sep 2008 17:44:09 +0100"  >&lt;p&gt;Jason I&apos;m seeing many other tests failing (besides TestIndexReaderReopen).  Are you seeing these too?  EG:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    [junit] Testcase: testHangOnClose(org.apache.lucene.index.TestAddIndexesNoOptimize):	Caused an ERROR
    [junit] MockRAMDirectory: cannot close: there are still open files: {_0.fdx=13}
    [junit] java.lang.RuntimeException: MockRAMDirectory: cannot close: there are still open files: {_0.fdx=13}
    [junit] 	at org.apache.lucene.store.MockRAMDirectory.close(MockRAMDirectory.java:292)
    [junit] 	at org.apache.lucene.index.TestAddIndexesNoOptimize.testHangOnClose(TestAddIndexesNoOptimize.java:537)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The failures all seem to be because *.fdx files are not being closed properly.&lt;/p&gt;</comment>
                    <comment id="12631850" author="jasonrutherglen" created="Wed, 17 Sep 2008 18:07:55 +0100"  >&lt;p&gt;Hi Michael,&lt;/p&gt;

&lt;p&gt;It used to work this patch.  It was not easy to implement the first time.  I did a merge of the new code and these are the resulting problems.  Do you know what has changed since 2.3.1?  Or around July?  I am surprised at some of the errors as they should be unrelated to how the patch works.  I may need to go ahead and break up the patch into the FieldsReader synchronization optimization (or is this already in trunk?) in order to isolate the issues.  What do you think?&lt;/p&gt;

&lt;p&gt;Jason&lt;/p&gt;</comment>
                    <comment id="12631855" author="jasonrutherglen" created="Wed, 17 Sep 2008 18:21:47 +0100"  >&lt;p&gt;Yes I am seeing the same error.  &lt;/p&gt;</comment>
                    <comment id="12631873" author="mikemccand" created="Wed, 17 Sep 2008 19:44:52 +0100"  >&lt;p&gt;OK I think you are missing a &quot;cloneableIndexStream.close()&quot; in FieldsReader.close.  For me that fixes all the tests failing with *.fdx &quot;still open&quot;.&lt;/p&gt;

&lt;p&gt;But I still see 5 failures in TestIndexReaderReopen.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I may need to go ahead and break up the patch into the FieldsReader synchronization optimization (or is this already in trunk?) in order to isolate the issues.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think that&apos;s a good idea.&lt;/p&gt;</comment>
                    <comment id="12655315" author="jasonrutherglen" created="Wed, 10 Dec 2008 18:57:28 +0000"  >&lt;p&gt;The remaining design issue with this patch is the writeLock.  It would seems best to share the writeLock and ref it across instances of clones SegmentReaders.  It is hurting my brain because it would be best to simply have a shared context object that represents all shared data between SegmentReaders but this probably will not work as it would move variables such as deletedDocs, norms, and the writeLock.  &lt;/p&gt;</comment>
                    <comment id="12655332" author="jasonrutherglen" created="Wed, 10 Dec 2008 19:43:23 +0000"  >&lt;p&gt;Seems like 2 solutions to clone and pending updates in SegmentReader:&lt;/p&gt;

&lt;p&gt;1) Flush any pending changes on clone&lt;br/&gt;
2) Throw an exception when the original SegmentReader receives new updates (i.e. deleteDocument is called) and on close does not flush the changes.  Flush throws an exception reading &quot;This segmentreader has pending changes and has been cloned and so cannot accept or flush updates&quot;  The problem with this one is it could lead to unpredictable behavior in that the user may assume the pending changes are being flushed (on close) and are not.  &lt;/p&gt;

&lt;p&gt;Perhaps both can be supported with IndexReader.clone(boolean autoFlush) where the autoFlush=true tells the clone method to flush pending updates (if there are any), and false means keep the pending changes but throw an exception on flush.&lt;/p&gt;</comment>
                    <comment id="12655386" author="jasonrutherglen" created="Wed, 10 Dec 2008 22:19:19 +0000"  >&lt;p&gt;Decided to simply release the lock in SegmentReader when a clone occurs.  If the original segmentreader receives updates (such as deleteDocument) after being cloned then it throws a LockObtainFailedException.  &lt;/p&gt;</comment>
                    <comment id="12655403" author="jasonrutherglen" created="Wed, 10 Dec 2008 23:02:37 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SegmentReader.reopenSegment accepts doClone variable&lt;/li&gt;
	&lt;li&gt;Ref class created for SegmentReader&lt;/li&gt;
	&lt;li&gt;TestIndexReaderClone focuses on testing SegmentReader&lt;/li&gt;
	&lt;li&gt;TestIndexReaderClone creates an index, clones and tests the deletedDocs reference counting&lt;/li&gt;
	&lt;li&gt;During a clone of a SegmentReader, the writeLock is released&lt;/li&gt;
	&lt;li&gt;Norms are not copy on write yet&lt;/li&gt;
	&lt;li&gt;TestIndexReaderReopen passes&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If the general method looks ok, norms cloning will be implemented&lt;/p&gt;</comment>
                    <comment id="12655429" author="jasonrutherglen" created="Wed, 10 Dec 2008 23:36:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;bytes now cloning properly compared to previous patch&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12656109" author="jasonrutherglen" created="Fri, 12 Dec 2008 18:44:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added TestIndexReaderCloneNorms because cloning the norms is really hard to do implemented as copy on write.  There seem to be many caveats such as whether or not the norms stream is still open?  testNormsRefCounting fails with a corruptedIndexException which I&apos;m investigating.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I now remember implementing a copy of just the bytes, and only editting them in the Norm object to get around these issues.  Basically on clone, new Norm objects and a Map is created but the byte array of the cloned norm is shared.  On a write, the bytes are cloned.  This gets around needing to deal with the reader norm reference counting used by reopen, though is this a good idea?&lt;/p&gt;

&lt;p&gt;I&apos;ll try that and see if it works.  Otherwise, suggestions besides hard cloning the norms for each clone?&lt;/p&gt;</comment>
                    <comment id="12657976" author="jasonrutherglen" created="Fri, 19 Dec 2008 02:21:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Implemented copying the writeLock reference in DirectorySegmentReader.doReopen to the cloned reader, readonly is set to true, acquireWriteLock throws LockObtainFailedException when readOnly is true&lt;/li&gt;
	&lt;li&gt;Tests try to generate LockObtainFailedException on a cloned reader by trying to update&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;TODO:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Probably needs more tests from TestIndexReaderReopen such as a multithreading one&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12658617" author="jasonrutherglen" created="Mon, 22 Dec 2008 18:33:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added TestIndexReaderClone.testParallelReader and testMixedReaders&lt;/li&gt;
	&lt;li&gt;Test-core Lucene tests pass&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I request assistance in what type of code properly tests multi threading for cloning readers&lt;/p&gt;</comment>
                    <comment id="12658863" author="mikemccand" created="Tue, 23 Dec 2008 16:09:08 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I request assistance in what type of code properly tests multi threading for cloning readers&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Shouldn&apos;t cloning be synchronized, at least the step that transfers the write lock to the cloned reader?&lt;/p&gt;

&lt;p&gt;It should also be synchronized to avoid acquisition of the write lock while the clone is underway.  Ie, only one of those can &quot;win&quot;.&lt;/p&gt;

&lt;p&gt;The first time a reader with pending changes is cloned, it transfers the write lock to the clone.  If that same reader gets cloned again, that&apos;s fine (but no write lock needs transferring again).&lt;/p&gt;

&lt;p&gt;BTW can you sync up your patch to the latest trunk?  Or, let me know which revision your patch is based on?  (I&apos;m having trouble applying the patch).&lt;/p&gt;</comment>
                    <comment id="12658876" author="jasonrutherglen" created="Tue, 23 Dec 2008 16:33:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Updated to work with trunk&lt;/li&gt;
	&lt;li&gt;Cleaned up commented code, removed unused variables&lt;/li&gt;
	&lt;li&gt;All tests pass&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Michael M.:&lt;br/&gt;
&quot;Shouldn&apos;t cloning be synchronized, at least the step that transfers the write lock to the cloned reader?&quot;&lt;/p&gt;

&lt;p&gt;The clone method is synchronized, is there something else that should be synchronized on?  I&apos;m trying to figure out (if it&apos;s necessary) the right unit test for the synchronization.  &lt;/p&gt;</comment>
                    <comment id="12658917" author="mikemccand" created="Tue, 23 Dec 2008 18:25:23 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; The clone method is synchronized, is there something else that should be synchronized on?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think that&apos;s sufficient.&lt;/p&gt;</comment>
                    <comment id="12658921" author="jasonrutherglen" created="Tue, 23 Dec 2008 18:39:55 +0000"  >&lt;p&gt;In the case of a reader that is already cloned, and clone is called again, do we want to throw an exception (if so what kind)?  Or perhaps clone should call acquireWriteLock to ensure only the reader with the lock may clone?  &lt;/p&gt;</comment>
                    <comment id="12658929" author="jasonrutherglen" created="Tue, 23 Dec 2008 19:11:08 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DirectoryIndexReader.doReopen acquires the write lock on a clone to ensure&lt;br/&gt;
  only the cloned reader may pass the write lock to the clone reader.&lt;br/&gt;
  This protects against the case where another reader may be trying&lt;br/&gt;
  to clone at the same time.&lt;/li&gt;
	&lt;li&gt;All tests pass&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12659235" author="mikemccand" created="Fri, 26 Dec 2008 12:39:43 +0000"  >
&lt;p&gt;OK I reviewed the patch; some comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;We have clone &amp;amp; reopen methods on *Reader (ParallelReader,&lt;br/&gt;
    MultiReader) that are not synchronized; shouldn&apos;t they be&lt;br/&gt;
    synchronized as well?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;You are still re-loading segments_N when cloning, which is&lt;br/&gt;
    incorrect (in fact I had fixed this in my patch above but it got&lt;br/&gt;
    lost); you should just clone segmentInfos instead.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.java we have &quot;if (doClone) acquireWriteLock();&quot;,&lt;br/&gt;
    which isn&apos;t right?  Ie, if this reader does not currently have the&lt;br/&gt;
    write lock (it has no &quot;local mods&quot;) it should not acquire it?  One&lt;br/&gt;
    should be allowed to clone a stale reader?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Have you done any tests to see the cost of the copy-on-write&lt;br/&gt;
    cloning of deleted docs BitVector &amp;amp; norms?  The first new mod to&lt;br/&gt;
    the cloned reader pays that penalty.  Marvin&apos;s &quot;tombstone&quot;&lt;br/&gt;
    deletions would bring this penalty to near zero, but it&apos;s a big&lt;br/&gt;
    change (and should certainly be decoupled from this!).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In IndexReader.clone()&apos;s javadocs can you state that on cloning a&lt;br/&gt;
    reader with pending modifications, the original reader then&lt;br/&gt;
    becomes readOnly (in addition to passing the write lock to the&lt;br/&gt;
    cloned reader)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you rename IndexReader.cloneBitVector --&amp;gt; cloneDeletedDocs?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;When you clone the deleted docs (because refCount is &amp;gt; 1) you are&lt;br/&gt;
    first decRef&apos;ing the old one and then making the clone... can you&lt;br/&gt;
    change that so the decRef is done last?  I don&apos;t think any actual&lt;br/&gt;
    bug would result from the way it is now, but let&apos;s be defensive&lt;br/&gt;
    (don&apos;t decRef something until you really are done using it).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Class Ref does not need to delcare its private int refCount as&lt;br/&gt;
    volatile; you always access that member from a synchronized&lt;br/&gt;
    context.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.clone, you incRef the deleteDocsCopyOnWriteRef,&lt;br/&gt;
    but it might be null, right?  Oh I see, it&apos;s always init&apos;d to a&lt;br/&gt;
    new Ref() but then you make a new Ref() again on the first&lt;br/&gt;
    delete.  Can you make it null by default?  (Seems like it should&lt;br/&gt;
    be null if deletedDocs is).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you change Ref() so that it init&apos;s its refCount to 1?  This&lt;br/&gt;
    way new Ref() need not immediately call incRef, and a Ref() with&lt;br/&gt;
    refCount 0 is never allowed out into the wild, and you should then&lt;br/&gt;
    add an &quot;assert refCount &amp;gt; 0&quot; in incRef as well.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.doClose() you are failing to call&lt;br/&gt;
    deletedDocsCopyOnWriteRef.decRef(), so you have a refCount leak.&lt;br/&gt;
    Can you create a unit test that 1) opens reader 1, 2) does deletes&lt;br/&gt;
    on reader 1, 3) clones reader 1 --&amp;gt; reader 2, 4) closes reader 1,&lt;br/&gt;
    5) deletes more docs with reader 1, and 6) asserts that the&lt;br/&gt;
    deletedDocs BitVector did not get cloned?  First verify the test&lt;br/&gt;
    fails, then fix the bug...&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;How should unDeleteAll() work?  EG it seems like you must decRef&lt;br/&gt;
    the Ref, then set it to null?  Can you add some tests for the&lt;br/&gt;
    various permutations of this?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SegmentReader.Norm now has two refCounts, and I think both are&lt;br/&gt;
    necessary. One tracks refs to the Norm instance itself and the&lt;br/&gt;
    other tracks refs to the byte[].  Can you add some comments&lt;br/&gt;
    explaining the difference (because it&apos;s confusing at first blush)?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think the answer to your question &quot;// is it necessary to clone&lt;br/&gt;
    everything?&quot; in SegmentReader.Norm.clone() is &quot;yes&quot;; can you&lt;br/&gt;
    make sure you are cloning everything and then remove that comment?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.doClose() we are also failing to decRef Norm&lt;br/&gt;
    instances (I think this is a pre-existing bug) and the newly added&lt;br/&gt;
    Refs to the byte[]&apos;s as well.  Can you fix both of these?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.Norm.cloneBytes() don&apos;t you need to create a new&lt;br/&gt;
    bytesRef as well, because you are making a private copy at that&lt;br/&gt;
    point?  Oh I see, you do this up in SegmentReader.doSetNorm; can&lt;br/&gt;
    you move it (= making a new bytesRef) down into cloneBytes()?&lt;br/&gt;
    Also, do the decRef of the old Ref last, not first, just like the&lt;br/&gt;
    deletedDocs case.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think you might have an off-by-one error in Norm cloning.  A&lt;br/&gt;
    newly cloned norm seems to share its byte[] with the original put&lt;br/&gt;
    gets a bytesRef with refCount 1?  (Should be refCount 2?).&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you rename deletedDocsCopyOnWriteRef -&amp;gt; deletedDocsRef?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Can you add &quot;new and experimental&quot; caveats to the package-private&lt;br/&gt;
    APIs you&apos;ve added (cloneNormBytes, cloneDeletedDocs)?&lt;/li&gt;
&lt;/ul&gt;

</comment>
                    <comment id="12660979" author="jasonrutherglen" created="Mon, 5 Jan 2009 23:05:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;p&gt;Michael, thanks for reviewing the patch in such detail.  All of your comments have been included in the latest version of the patch.&lt;/p&gt;

&lt;p&gt;M.M: In SegmentReader.java we have &quot;if (doClone) acquireWriteLock();&quot;, which isn&apos;t right? Ie, if this reader does not currently have the write lock (it has no &quot;local mods&quot;) it should not acquire it? One should be allowed to clone a stale reader?&lt;/p&gt;

&lt;p&gt;Cloning a stale reader is fixed in the patch.  The problem is the user may get into trouble by updating the stale reader which was debated before.  I got the impression insuring the reader being updated was the latest was important.  &lt;/p&gt;

&lt;p&gt;M.M.: Have you done any tests to see the cost of the copy-on-write cloning of deleted docs BitVector &amp;amp; norms? The first new mod to the cloned reader pays that penalty. Marvin&apos;s &quot;tombstone&quot; deletions would bring this penalty to near zero, but it&apos;s a big change (and should certainly be decoupled from this!).&lt;/p&gt;

&lt;p&gt;The cost of cloning them meaning the creating a new byte array or some other cost like memory consumption?  I need to reread Marvin&apos;s tombstones which at first glance seemed to be an iterative approach to saving deletions that seems like a transaction log.  Correct?&lt;/p&gt;

&lt;p&gt;M.M.: SegmentReader.Norm now has two refCounts, and I think both are necessary. One tracks refs to the Norm instance itself and the other tracks refs to the byte[]. Can you add some comments explaining the difference (because it&apos;s confusing at first blush)?&lt;/p&gt;

&lt;p&gt;Byte[] referencing is used because a new norm object needs to be created for each clone, and the byte array is all that is needed for sharing between cloned readers.  The current norm referencing is for sharing between readers whereas the byte[] referencing is for copy on write which is independent of reader references.&lt;/p&gt;

&lt;p&gt;M.M.: In SegmentReader.doClose() you are failing to call deletedDocsCopyOnWriteRef.decRef(), so you have a refCount leak.  Can you create a unit test that 1) opens reader 1, 2) does deletes on reader 1, 3) clones reader 1 --&amp;gt; reader 2, 4) closes reader 1, 5) deletes more docs with reader 1, and 6) asserts that the&lt;br/&gt;
deletedDocs BitVector did not get cloned? First verify the test fails, then fix the bug...&lt;/p&gt;

&lt;p&gt;In regards to #5, the test cannot delete from reader 1 once it&apos;s closed.  A method called TestIndexReaderClone.testSegmentReaderCloseReferencing was added to test this closing use case.&lt;/p&gt;</comment>
                    <comment id="12661214" author="mikemccand" created="Tue, 6 Jan 2009 17:27:08 +0000"  >
&lt;blockquote&gt;
&lt;p&gt;&amp;gt; The problem is the user may get into trouble by updating the stale reader which was debated before. I got the impression insuring the reader being updated was the latest was important.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But: when one attempts to change a stale reader, that&apos;s caught when&lt;br/&gt;
trying to acquire the write lock?  (Ie during clone I think you don&apos;t&lt;br/&gt;
need to also check for this).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; The cost of cloning them meaning the creating a new byte array&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah I was thinking CPU cost of creating &amp;amp; copying deleted docs &amp;amp;&lt;br/&gt;
norms; I was just curious (I don&apos;t think we have to measure this&lt;br/&gt;
before committing).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I need to reread Marvin&apos;s tombstones which at first glance seemed to be an iterative approach to saving deletions that seems like a transaction log. Correct?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Similar to a transaction log in that the size of what&apos;s written is in&lt;br/&gt;
proportion to how many changes (deletions) you made.  But different in&lt;br/&gt;
that there is no other data structure (ie the tombstones &lt;b&gt;are&lt;/b&gt; the&lt;br/&gt;
representation of the deletes) and so the tombstones are used &quot;live&quot;&lt;br/&gt;
(whereas transaction log is typically &quot;played back&quot; on next startup&lt;br/&gt;
after a failure).&lt;/p&gt;

&lt;p&gt;If we had tombstones to represent deletes in Lucene then any new&lt;br/&gt;
deletions would not require any cloning of prior deletions.  Ie there&lt;br/&gt;
would be no copy-on-write.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; M.M.: SegmentReader.Norm now has two refCounts, and I think both are necessary. One tracks refs to the Norm instance itself and the other tracks refs to the byte[]. Can you add some comments explaining the difference (because it&apos;s confusing at first blush)?&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; Byte[] referencing is used because a new norm object needs to be created for each clone, and the byte array is all that is needed for sharing between cloned readers. The current norm referencing is for sharing between readers whereas the byte[] referencing is for copy on write which is independent of reader references.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Got it.  Can you put this into the javadocs in the Norm class?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; M.M.: In SegmentReader.doClose() you are failing to call deletedDocsCopyOnWriteRef.decRef(), so you have a refCount leak. Can you create a unit test that 1) opens reader 1, 2) does deletes on reader 1, 3) clones reader 1 --&amp;gt; reader 2, 4) closes reader 1, 5) deletes more docs with reader 1, and 6) asserts that the&lt;br/&gt;
deletedDocs BitVector did not get cloned? First verify the test fails, then fix the bug...&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; In regards to #5, the test cannot delete from reader 1 once it&apos;s closed. A method called TestIndexReaderClone.testSegmentReaderCloseReferencing was added to test this closing use case.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Woops &amp;#8211; I meant &quot;5) deletes more docs with reader 2&quot;.  Test case&lt;br/&gt;
looks good!  Thanks.&lt;/p&gt;

&lt;p&gt;A few more comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Can you update javadocs of IndexReader.reopen to remove the&lt;br/&gt;
    warning about not doing modification operations?  With&lt;br/&gt;
    copy-on-write you are now free to do deletes against the reopened&lt;br/&gt;
    reader with no impact to the reader you had reopened/cloned.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;What is SegmentReader.doDecRef for?  It seems dead?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SegmentReader.doUndeleteAll has 4 space indent (should be 2)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;We have this in SegmentReader.reopenSegment:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (deletedDocsRef == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) deletedDocsRef = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Ref();
&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; deletedDocsRef.incRef();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;   But I think if I clone a reader with no deletes, the clone then&lt;br/&gt;
   &lt;span class=&quot;error&quot;&gt;&amp;#91;incorrectly&amp;#93;&lt;/span&gt; has a deletedDocsRef set?  Can you fix that code to&lt;br/&gt;
   keep the invariant that if deleteDocs is null, so is&lt;br/&gt;
   deletedDocsRef, and v/v?  Can you sprinkle asserts to make sure&lt;br/&gt;
   that invariant always holds?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.decRef we have &quot;if (deletedDocsRef != null &amp;amp;&amp;amp;&lt;br/&gt;
    deletedDocsRef.refCount() &amp;gt; 1) deletedDocsRef.decRef();&quot; &amp;#8211; but,&lt;br/&gt;
    you should not have to check if deletedDocsRef.refCount() &amp;gt; 1?&lt;br/&gt;
    Does something break when you remove that?  (In which case I think&lt;br/&gt;
    we have a refCount bug lurking...)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;The norm cloning logic in SegmentReader.reopenSegment needs to be&lt;br/&gt;
    cleaned up... eg we first sweep through each Norm, incRef&apos;ing it,&lt;br/&gt;
    and then make 2nd pass to do full clone.  Really we should have if&lt;br/&gt;
    (doClone) up front and do a single pass?  Also: I think we need&lt;br/&gt;
    that same logic to re-open the singleNormStream for the clone case&lt;br/&gt;
    as well.&lt;br/&gt;
.&lt;br/&gt;
    Hmm, in the non-single-norm stream case I think we also must&lt;br/&gt;
    re-open the norm file, rather than clone it, in Norm.clone().  I&lt;br/&gt;
    think if you 1) open reader 1(do no searching w/ it), 2) clone it&lt;br/&gt;
    --&amp;gt; reader 2, 3) close reader 1, 4) try to do a search against a&lt;br/&gt;
    field that then needs to load norms, you&apos;ll hit an&lt;br/&gt;
    AlreadyClosedException, because you had a cloned IndexInput vs a&lt;br/&gt;
    newly reopened one?  Can you add that test case?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Why was this needed:
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (doClone &amp;amp;&amp;amp; normsDirty) {
  normsUpToDate = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;    It seems like leaving normsUpToDate as true should have worked&lt;br/&gt;
    (all the Norm instances are cloned anyway?).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;In SegmentReader.doUndeleteAll, can you conditionalize on whether&lt;br/&gt;
    deletedDocs != null?  In general rather than having separate&lt;br/&gt;
    checks for deleteDocs != null and deletedDocsRef != null, I&apos;d&lt;br/&gt;
    prefer to check only deletedDocs != null and add an assert that&lt;br/&gt;
    deleteDocsRef != null, with else clause having assert&lt;br/&gt;
    deletedDocsRef == null.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12661443" author="jasonrutherglen" created="Wed, 7 Jan 2009 04:41:43 +0000"  >&lt;p&gt;Everything in the previous post should be working and completed.  TestIndexReaderReopen.testThreadSafety is creating a bug in the deletedDocs referencing which is related to &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!success) {
&lt;span class=&quot;code-comment&quot;&gt;// An exception occured during reopen, we have to decRef the norms
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// that we incRef&apos;ed already and close singleNormsStream and FieldsReader
&lt;/span&gt;clone.decRef();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;at the bottom of SegmentReader.reopenSegment.  I am finished for the day and posted what is completed otherwise.&lt;/p&gt;

&lt;p&gt;&amp;gt; &quot;Similar to a transaction log in that the size of what&apos;s written is in&lt;br/&gt;
proportion to how many changes (deletions) you made. But different in&lt;br/&gt;
that there is no other data structure (ie the tombstones are the&lt;br/&gt;
representation of the deletes) and so the tombstones are used &quot;live&quot;&lt;br/&gt;
(whereas transaction log is typically &quot;played back&quot; on next startup&lt;br/&gt;
after a failure).&lt;/p&gt;

&lt;p&gt;If we had tombstones to represent deletes in Lucene then any new&lt;br/&gt;
deletions would not require any cloning of prior deletions. Ie there&lt;br/&gt;
would be no copy-on-write.&quot;&lt;/p&gt;

&lt;p&gt;Definitely interesting, how do tombstones work with BitVector?&lt;/p&gt;

&lt;p&gt;I changed Norm.clone to Norm.cloneNorm because it needs to throw an IOException, the clone interface does not allow exceptions and it&apos;s hidden inside of SegmentReader so the naming conventions should not matter.  &lt;/p&gt;</comment>
                    <comment id="12661531" author="mikemccand" created="Wed, 7 Jan 2009 12:04:53 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Definitely interesting, how do tombstones work with BitVector?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;They would replace BitVector with an iterator API (eg DocIDSet).  SegmentTermDocs would then AND together the term&apos;s postings with the deleted docs postings.  I mocked up a rough test of iteration vs random-access and tentatively found that iteration was a bit faster if %tg deletes was less than 10% or so, but then more costly if it was higher.  I didn&apos;t dig much into it though.&lt;/p&gt;

&lt;p&gt;Once Lucene access deletes via iterator, then multiple tombstone streams could be merged during searching.&lt;/p&gt;

&lt;p&gt;I&apos;ll look at the patch.  Thanks Jason!&lt;/p&gt;</comment>
                    <comment id="12662043" author="jasonrutherglen" created="Thu, 8 Jan 2009 17:16:01 +0000"  >&lt;p&gt;I executed on Eclipse Mac OS X on a 4 core box (core&apos;s significant due to the threads).  I ran TestIndexReaderReopen.testThreadSafety 2 times in debug mode it worked, thought that debug mode wasn&apos;t making the bug reproduce so tried just running the test and it passed again.  The 5th time it gave an error in debug mode.  The test case fails consistently when SegmentReader.reopenSegment success == false and decRef is called afterwards in the finally clause.  It seems that calling this decRef on the newly cloned object is causing the assertion error which is possibly related to threading.  Probably because the decRef on the failed clone is decrementing one too many times on a deletedDocsRef used by another reader and causing the following assertion error.  I&apos;m not sure if this is a real bug or an issue that the test case should ignore.  &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.AssertionError
	at org.apache.lucene.index.SegmentReader$Ref.decRef(SegmentReader.java:104)
	at org.apache.lucene.index.SegmentReader.decRef(SegmentReader.java:249)
	at org.apache.lucene.index.MultiSegmentReader.doClose(MultiSegmentReader.java:413)
	at org.apache.lucene.index.IndexReader.decRef(IndexReader.java:157)
	at org.apache.lucene.index.IndexReader.close(IndexReader.java:990)
	at org.apache.lucene.index.TestIndexReaderReopen$9.run(TestIndexReaderReopen.java:703)
	at org.apache.lucene.index.TestIndexReaderReopen$ReaderThread.run(TestIndexReaderReopen.java:818)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12662127" author="jasonrutherglen" created="Thu, 8 Jan 2009 21:22:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt;.patch&lt;/p&gt;

&lt;p&gt;All tests pass.  &lt;/p&gt;

&lt;p&gt;IndexReader.close was made non-final to override in SegmentReader.  This is due to the propagation of the method calls to SegmentReader.doClose previously passed through decRef which could be called by IndexReader.decRef or IndexReader.close.  In order to decref the copy on write refs, the close method needs to decrement the references, rather than simply the decRef method.  This caused the bug found in the previous comment where if decRef was called the deletedDocsRef did not need to also be decrefed which was the cause of the ref count assertion failing.  &lt;/p&gt;

&lt;p&gt;Occasionally TestIndexReaderReopen.testThreadSafety fails due to an already closed exception.  Trunk however also fails periodically.  Given multi threading of reopen/close is usually unlikely I am not sure it is worth investigating further.&lt;/p&gt;

&lt;p&gt;Fixed norm byte refs not decrefing on close.&lt;/p&gt;

&lt;p&gt;Fixed cloneNorm() byteRef being created when there is no byte array, added assertion check.&lt;/p&gt;

</comment>
                    <comment id="12662465" author="mikemccand" created="Fri, 9 Jan 2009 18:41:34 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Occasionally TestIndexReaderReopen.testThreadSafety fails due to an already closed exception. Trunk however also fails periodically.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Jason, I don&apos;t see this.  I&apos;m running TestIndexReaderReopen via the command line (not through eclipse).  Are you able to see a failure (on trunk) via the command line?&lt;/p&gt;</comment>
                    <comment id="12662472" author="jasonrutherglen" created="Fri, 9 Jan 2009 18:57:43 +0000"  >&lt;p&gt;I haven&apos;t seen this error via the command line, only sporadically in eclipse.  Is there a way with ant to only test one test case?  &lt;br/&gt;
Tried:&lt;br/&gt;
&quot;ant -Dtestcase=org.apache.lucene.index.TestIndexReaderReopen test-core&quot; which according to the Wiki &lt;a href=&quot;http://wiki.apache.org/lucene-java/HowToContribute&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/HowToContribute&lt;/a&gt; should work.&lt;/p&gt;</comment>
                    <comment id="12662475" author="ehatcher" created="Fri, 9 Jan 2009 19:03:56 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Is there a way with ant to only test one test case?&lt;br/&gt;
Tried:&lt;br/&gt;
&quot;ant -Dtestcase=org.apache.lucene.index.TestIndexReaderReopen test-core&quot; which according to the Wiki &lt;a href=&quot;http://wiki.apache.org/lucene-java/HowToContribute&quot; class=&quot;external-link&quot;&gt;http://wiki.apache.org/lucene-java/HowToContribute&lt;/a&gt; should work. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The value of the testcase parameter fits in this way **/$&lt;/p&gt;
{testcase}
&lt;p&gt;.java in common-build.xml, so in your case it&apos;d be -Dtestcase=TestIndexReaderReopen&lt;/p&gt;</comment>
                    <comment id="12662485" author="jasonrutherglen" created="Fri, 9 Jan 2009 19:20:51 +0000"  >&lt;p&gt;That worked Erik.&lt;/p&gt;

&lt;p&gt;I executed TestIndexReaderReopen using the &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1314&quot; title=&quot;IndexReader.clone&quot;&gt;&lt;del&gt;LUCENE-1314&lt;/del&gt;&lt;/a&gt; patch 8 times via command line and did not see the error.  &lt;/p&gt;

&lt;p&gt;Then tried TestIndexReaderReopen in trunk and saw this the first time:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;common.test:
    [mkdir] Created dir: /Users/jrutherg/dev/lucenetrunk/trunk/build/test
    [junit] Testsuite: org.apache.lucene.index.TestIndexReaderReopen
    [junit] &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed)
    [junit] Tests run: 15, Failures: 1, Errors: 0, Time elapsed: 19.125 sec
    [junit] 
    [junit] ------------- Standard Output ---------------
    [junit] java.io.FileNotFoundException: _0_6.del
    [junit] 	at org.apache.lucene.store.RAMDirectory.openInput(RAMDirectory.java:237)
    [junit] 	at org.apache.lucene.util.BitVector.&amp;lt;init&amp;gt;(BitVector.java:235)
    [junit] 	at org.apache.lucene.index.SegmentReader.loadDeletedDocs(SegmentReader.java:412)
    [junit] 	at org.apache.lucene.index.SegmentReader.reopenSegment(SegmentReader.java:499)
    [junit] 	at org.apache.lucene.index.MultiSegmentReader.&amp;lt;init&amp;gt;(MultiSegmentReader.java:112)
    [junit] 	at org.apache.lucene.index.SegmentReader.doReopen(SegmentReader.java:442)
    [junit] 	at org.apache.lucene.index.DirectoryIndexReader$2.doBody(DirectoryIndexReader.java:153)
    [junit] 	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:688)
    [junit] 	at org.apache.lucene.index.DirectoryIndexReader.reopen(DirectoryIndexReader.java:175)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$9.run(TestIndexReaderReopen.java:685)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$ReaderThread.run(TestIndexReaderReopen.java:818)
    [junit] org.apache.lucene.store.AlreadyClosedException: &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed
    [junit] 	at org.apache.lucene.index.IndexReader.ensureOpen(IndexReader.java:196)
    [junit] 	at org.apache.lucene.index.SegmentReader.docFreq(SegmentReader.java:741)
    [junit] 	at org.apache.lucene.index.MultiSegmentReader.docFreq(MultiSegmentReader.java:378)
    [junit] 	at org.apache.lucene.search.IndexSearcher.docFreq(IndexSearcher.java:86)
    [junit] 	at org.apache.lucene.search.Similarity.idf(Similarity.java:481)
    [junit] 	at org.apache.lucene.search.TermQuery$TermWeight.&amp;lt;init&amp;gt;(TermQuery.java:44)
    [junit] 	at org.apache.lucene.search.TermQuery.createWeight(TermQuery.java:146)
    [junit] 	at org.apache.lucene.search.Query.weight(Query.java:95)
    [junit] 	at org.apache.lucene.search.Searcher.createWeight(Searcher.java:185)
    [junit] 	at org.apache.lucene.search.Searcher.search(Searcher.java:136)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$9.run(TestIndexReaderReopen.java:689)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$ReaderThread.run(TestIndexReaderReopen.java:818)
    [junit] ------------- ---------------- ---------------
    [junit] ------------- Standard Error -----------------
    [junit] java.io.FileNotFoundException: _0_6.del
    [junit] 	at org.apache.lucene.store.RAMDirectory.openInput(RAMDirectory.java:237)
    [junit] 	at org.apache.lucene.util.BitVector.&amp;lt;init&amp;gt;(BitVector.java:235)
    [junit] 	at org.apache.lucene.index.SegmentReader.loadDeletedDocs(SegmentReader.java:412)
    [junit] 	at org.apache.lucene.index.SegmentReader.reopenSegment(SegmentReader.java:499)
    [junit] 	at org.apache.lucene.index.MultiSegmentReader.&amp;lt;init&amp;gt;(MultiSegmentReader.java:112)
    [junit] 	at org.apache.lucene.index.SegmentReader.doReopen(SegmentReader.java:442)
    [junit] 	at org.apache.lucene.index.DirectoryIndexReader$2.doBody(DirectoryIndexReader.java:153)
    [junit] 	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:688)
    [junit] 	at org.apache.lucene.index.DirectoryIndexReader.reopen(DirectoryIndexReader.java:175)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$9.run(TestIndexReaderReopen.java:685)
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen$ReaderThread.run(TestIndexReaderReopen.java:818)
    [junit] ------------- ---------------- ---------------
    [junit] Testcase: testThreadSafety(org.apache.lucene.index.TestIndexReaderReopen):	FAILED
    [junit] Error occurred in thread &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-51:
    [junit] &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed
    [junit] junit.framework.AssertionFailedError: Error occurred in thread &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-51:
    [junit] &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; IndexReader is closed
    [junit] 	at org.apache.lucene.index.TestIndexReaderReopen.testThreadSafety(TestIndexReaderReopen.java:760)
    [junit] 
    [junit] 
    [junit] Test org.apache.lucene.index.TestIndexReaderReopen FAILED

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12662519" author="mikemccand" created="Fri, 9 Jan 2009 21:11:28 +0000"  >&lt;p&gt;Odd, I still can&apos;t see it.  Are you sure you have no local mods?  Eg the line number in BitVector.java looks off (but others look OK).&lt;/p&gt;

&lt;p&gt;What&apos;s your full env?  I&apos;m also running on quad core Mac Pro, 10.5.5, with this java:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Java(TM) SE &lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt; Environment (build 1.6.0_07-b06-153)
Java HotSpot(TM) 64-Bit Server VM (build 1.6.0_07-b06-57, mixed mode)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12662545" author="jasonrutherglen" created="Fri, 9 Jan 2009 22:27:52 +0000"  >&lt;p&gt;&lt;b&gt;Software&lt;/b&gt;&lt;br/&gt;
  System Version:	Mac OS X 10.5.6 (9G55)&lt;br/&gt;
  Kernel Version:	Darwin 9.6.0&lt;br/&gt;
  Boot Volume:	Macintosh HD&lt;br/&gt;
&lt;b&gt;Hardware&lt;/b&gt;&lt;br/&gt;
Model Name:	Mac Pro&lt;br/&gt;
  Model Identifier:	MacPro3,1&lt;br/&gt;
  Processor Name:	Quad-Core Intel Xeon&lt;br/&gt;
  Processor Speed:	2.8 GHz&lt;br/&gt;
  Number Of Processors:	2&lt;br/&gt;
  Total Number Of Cores:	8&lt;br/&gt;
  L2 Cache (per processor):	12 MB&lt;br/&gt;
  Memory:	12 GB&lt;br/&gt;
  Bus Speed:	1.6 GHz&lt;br/&gt;
  Boot ROM Version:	MP31.006C.B05&lt;br/&gt;
  SMC Version:	1.25f4&lt;br/&gt;
  Serial Number:	G88151P4XYL&lt;/p&gt;

&lt;p&gt;java -version&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java version &lt;span class=&quot;code-quote&quot;&gt;&quot;1.5.0_16&quot;&lt;/span&gt;
Java(TM) 2 &lt;span class=&quot;code-object&quot;&gt;Runtime&lt;/span&gt; Environment, Standard Edition (build 1.5.0_16-b06-284)
Java HotSpot(TM) Client VM (build 1.5.0_16-133, mixed mode, sharing)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does ant execute with -server turned on?  My VM isn&apos;t 64bit?  &lt;/p&gt;</comment>
                    <comment id="12662832" author="mikemccand" created="Sun, 11 Jan 2009 22:45:13 +0000"  >
&lt;p&gt;I started from the last patch and made some fixes to how norms are&lt;br/&gt;
shared (new patch attached).&lt;/p&gt;

&lt;p&gt;I also fixed the reopen/clone unit tests to use MockRAMDirectory, to&lt;br/&gt;
verify all open files are closed... which resulted in some interesting&lt;br/&gt;
failures that are now fixed.&lt;/p&gt;

&lt;p&gt;With this change, we use fewer file descriptions during reopen &amp;amp;&lt;br/&gt;
clone.  Previously, the norms in the new reader opened a new&lt;br/&gt;
IndexInput on reopen or clone; now we share the original one (similar&lt;br/&gt;
to how &quot;referencedSegmentReader&quot; works).  This is true for the &quot;single&lt;br/&gt;
norm stream&quot; case too.&lt;/p&gt;

&lt;p&gt;It&apos;s now safe to make changes (norms, deletions) on a reopened reader&lt;br/&gt;
(as well as cloned reader); it won&apos;t affect the previous reader (a&lt;br/&gt;
private copy-on-write is made on the first change).&lt;/p&gt;

&lt;p&gt;All tests pass, except I still can&apos;t repro the failure Jason sees on&lt;br/&gt;
trunk.  I think we&apos;re getting close!&lt;/p&gt;</comment>
                    <comment id="12663023" author="jasonrutherglen" created="Mon, 12 Jan 2009 17:35:41 +0000"  >&lt;p&gt;Fixing the norms bytes loading is good, it seemed incorrect but I&lt;br/&gt;
didn&apos;t want to mess with it as I didn&apos;t fully understand it. &lt;/p&gt;

&lt;p&gt;I executed TestIndexReaderReopen 7 times and did not see the error.&lt;/p&gt;</comment>
                    <comment id="12663375" author="jasonrutherglen" created="Tue, 13 Jan 2009 16:59:14 +0000"  >&lt;p&gt;I think we should add reopen(boolean readonly) and clone(boolean&lt;br/&gt;
readonly) as otherwise the only way to obtain a readonly reader is to&lt;br/&gt;
call IR.open.&lt;/p&gt;</comment>
                    <comment id="12663485" author="jasonrutherglen" created="Tue, 13 Jan 2009 21:43:23 +0000"  >&lt;p&gt;This patch includes the previous patch. All tests pass.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;IndexReader.clone(boolean openReadOnly) method added that returns a&lt;br/&gt;
read only reader.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Previously on a clone, the DirectoryIndexReader.doReopen was&lt;br/&gt;
looking up the latest segmentinfos file from the directory&lt;br/&gt;
implementation. This was unnecessary because the current segmentinfos&lt;br/&gt;
is being cloned. In this patch DirectoryIndexReader.clone uses the&lt;br/&gt;
new doReopenSegmentInfos (which can also be used by &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt;).&lt;br/&gt;
When clone returns a read only reader, the write lock etc is not&lt;br/&gt;
shared. &lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;SegmentReader. reopenSegment has a openReadOnly argument.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added a test case in TestIndexReaderClone checking for read only&lt;br/&gt;
readers being returned from the method clone openReadOnly=true. &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I decided against having reopen have a read only method because it&lt;br/&gt;
does not always return a reader like clone does. If the existing&lt;br/&gt;
reader is not read only and the returned reader is supposed to be&lt;br/&gt;
read only, the current contract of the reopen method would break&lt;br/&gt;
because if there are no changes it is supposed to return the existing&lt;br/&gt;
reader. Also returning a read only reader is desired, clone may be&lt;br/&gt;
used.&lt;/p&gt;</comment>
                    <comment id="12664265" author="mikemccand" created="Thu, 15 Jan 2009 21:10:31 +0000"  >&lt;p&gt;Jason I think TestIndexReaderClone.java is missing from your patch?&lt;/p&gt;</comment>
                    <comment id="12664271" author="mikemccand" created="Thu, 15 Jan 2009 21:27:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&amp;gt; Previously on a clone, the DirectoryIndexReader.doReopen was&lt;br/&gt;
&amp;gt; looking up the latest segmentinfos file from the directory&lt;br/&gt;
&amp;gt; implementation. This was unnecessary because the current segmentinfos&lt;br/&gt;
&amp;gt; is being cloned.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good!  So now we don&apos;t even run the FindSegmentsFile at all during&lt;br/&gt;
clone.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I think we should add reopen(boolean readonly) and clone(boolean&lt;br/&gt;
&amp;gt; readonly) as otherwise the only way to obtain a readonly reader is to&lt;br/&gt;
&amp;gt; call IR.open. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree.  It then seems like for realtime search you may want to clone&lt;br/&gt;
a readOnly IR to do your searching (for better concurrency), and keep&lt;br/&gt;
the writable IR for doing further changes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; IndexReader.clone(boolean openReadOnly) method added that returns a&lt;br/&gt;
&amp;gt; read only reader.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If I have a readOnly reader and I clone with readOnly=false, should&lt;br/&gt;
that give me a non-readOnly clone?  I think it should?  But I think&lt;br/&gt;
current patch doesn&apos;t handle that right?  If so, could you add a test&lt;br/&gt;
case &amp;amp; fix it?&lt;/p&gt;

&lt;p&gt;Then, if I have a non-readOnly reader and I clone it with&lt;br/&gt;
readOnly=true, it seems like the semantics is to have the original&lt;br/&gt;
reader keep the write lock, ie it&apos;s allowed to continue making changes&lt;br/&gt;
if it wants, and the first change after that clone should&lt;br/&gt;
copy-on-write?  Can you add a test case verifying that?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;gt; I decided against having reopen have a read only method because it&lt;br/&gt;
&amp;gt; does not always return a reader like clone does.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK.&lt;/p&gt;</comment>
                    <comment id="12664395" author="jasonrutherglen" created="Fri, 16 Jan 2009 03:32:33 +0000"  >&lt;p&gt;All tests pass&lt;/p&gt;

&lt;p&gt;Changed DirectoryIndexReader. acquireWriteLock to throw an&lt;br/&gt;
UnsupportedOperationException (rather than a&lt;br/&gt;
LockObtainFailedException) when the reader is readonly because&lt;br/&gt;
TestIndexReader.testReadOnly was failing&lt;/p&gt;

&lt;p&gt;Added test for cloning a writeable reader to read only&lt;/p&gt;

&lt;p&gt;Cloning a read only reader into a writeable reader throws an&lt;br/&gt;
exception. Added a test case&lt;/p&gt;

&lt;p&gt;Why does DirectoryIndexReader and SegmentReader have a readonly&lt;br/&gt;
variable? &lt;/p&gt;</comment>
                    <comment id="12664511" author="mikemccand" created="Fri, 16 Jan 2009 13:14:31 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Changed DirectoryIndexReader. acquireWriteLock to throw an&lt;br/&gt;
UnsupportedOperationException (rather than a&lt;br/&gt;
LockObtainFailedException) when the reader is readonly because&lt;br/&gt;
TestIndexReader.testReadOnly was failing&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can&apos;t really make that change &amp;#8211; it&apos;s technically a change to back compat.  Can we just fix the test that was failing (why was it failing?).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cloning a read only reader into a writeable reader throws an&lt;br/&gt;
exception.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why not allow this?  (It shouldn&apos;t be hard to allow it?)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why does DirectoryIndexReader and SegmentReader have a readonly&lt;br/&gt;
variable? &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Hmm &amp;#8211; that&apos;s no good.  Can you remove SegmentReader&apos;s?&lt;/p&gt;</comment>
                    <comment id="12664557" author="jasonrutherglen" created="Fri, 16 Jan 2009 16:41:36 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&quot;Changed DirectoryIndexReader. acquireWriteLock to throw an&lt;br/&gt;
UnsupportedOperationException (rather than a&lt;br/&gt;
LockObtainFailedException) when the reader is readonly because&lt;br/&gt;
TestIndexReader.testReadOnly was failing&quot;&lt;/p&gt;

&lt;p&gt;We can&apos;t really make that change - it&apos;s technically a change to back&lt;br/&gt;
compat. Can we just fix the test that was failing (why was it&lt;br/&gt;
failing?). &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s been added in this patch so there isn&apos;t a back compat issue. I&apos;m&lt;br/&gt;
not sure why it wasn&apos;t being thrown in previous testing.&lt;br/&gt;
acquireWriteLock in ReadOnly*Reader throws&lt;br/&gt;
UnsupportedOperationException making the patch compatible with&lt;br/&gt;
existing behavior.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;Cloning a read only reader into a writeable reader throws an&lt;br/&gt;
exception.&quot;&lt;/p&gt;

&lt;p&gt;Why not allow this? (It shouldn&apos;t be hard to allow it?) &lt;/p&gt;&lt;/blockquote&gt; 

&lt;p&gt;While it seem logical, it&apos;s not allowed because the read only reader&lt;br/&gt;
doesn&apos;t hold the write lock which it needs to pass on to the&lt;br/&gt;
writeable reader. &lt;/p&gt;

&lt;p&gt;SegmentReader.readOnly variable removed&lt;/p&gt;

&lt;p&gt;All tests pass&lt;/p&gt;</comment>
                    <comment id="12664568" author="mikemccand" created="Fri, 16 Jan 2009 17:09:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s been added in this patch so there isn&apos;t a back compat issue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, I was confused.  This new exception is thrown if you 1) have a&lt;br/&gt;
non-readOnly reader1, 2) reopen it with readOnly=false (thus marking&lt;br/&gt;
reader1 as readOnly=true), and 3) try to make a change with the&lt;br/&gt;
now-readOnly reader.&lt;/p&gt;

&lt;p&gt;OK I like throwing UOE.  It&apos;s the same as what you get if you open&lt;br/&gt;
a readOnly reader and try to make a change.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;While it seem logical, it&apos;s not allowed because the read only reader&lt;br/&gt;
doesn&apos;t hold the write lock which it needs to pass on to the&lt;br/&gt;
writeable reader. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that&apos;s OK?  Ie, cloning to a non-readOnly reader when it doesn&apos;t&lt;br/&gt;
already have the write lock simply means the new reader is allowed to&lt;br/&gt;
attempt acquiring the write lock (even though it doesn&apos;t already have&lt;br/&gt;
the write lock).&lt;/p&gt;

&lt;p&gt;Ie &quot;being non-readOnly&quot; and &quot;holding the write lock&quot; are two separate&lt;br/&gt;
things.&lt;/p&gt;

&lt;p&gt;I can see this being useful if you are an app that doens&apos;t often need&lt;br/&gt;
to make changes w/ the reader... so you hold a readOnly reader most of&lt;br/&gt;
the time, but then when you need to make a change you clone it to&lt;br/&gt;
non-readOnly clone to make changes.&lt;/p&gt;

&lt;p&gt;I also wonder what should happen if you 1) have a non-readOnly&lt;br/&gt;
reader1, but 2) it has no changes pending (does not hold the write&lt;br/&gt;
lock) and 3) you clone it to a non-readOnly clone reader2.  I think&lt;br/&gt;
reader1 should not be marked readOnly this case, because it has no&lt;br/&gt;
pending changes.  Ie I think at this point reader1 &amp;amp; reader2 should be&lt;br/&gt;
interchangeable?&lt;/p&gt;</comment>
                    <comment id="12664652" author="jasonrutherglen" created="Fri, 16 Jan 2009 19:59:07 +0000"  >&lt;p&gt;Added TestIndexReaderClone.testCloneNoChangesStilReadOnly, changed&lt;br/&gt;
behavior such that if there are no changes, the original reader is&lt;br/&gt;
not set to readonly (the previous behavior was to set readonly to&lt;br/&gt;
true even if the reader did not have changes).&lt;/p&gt;</comment>
                    <comment id="12664668" author="mikemccand" created="Fri, 16 Jan 2009 20:35:33 +0000"  >&lt;p&gt;Jason I think your last patch is stale?  I don&apos;t see the new test case nor the changed logic about setting reader to readOnly on clone.&lt;/p&gt;</comment>
                    <comment id="12664697" author="jasonrutherglen" created="Fri, 16 Jan 2009 21:56:37 +0000"  >&lt;p&gt;Sorry, here it is.&lt;/p&gt;</comment>
                    <comment id="12664727" author="mikemccand" created="Fri, 16 Jan 2009 22:50:49 +0000"  >&lt;p&gt;I&apos;m seeing this failure:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[junit] Testcase: testCloneWriteToOrig(org.apache.lucene.index.TestIndexReaderClone):	FAILED
[junit] deleting from the original should not have worked
[junit] junit.framework.AssertionFailedError: deleting from the original should not have worked
[junit] 	at org.apache.lucene.index.TestIndexReaderClone.testCloneWriteToOrig(TestIndexReaderClone.java:53)
[junit] 
[junit] 
[junit] Test org.apache.lucene.index.TestIndexReaderClone FAILED
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think that test just needs to be updated based on the new semantics?  Could you also test the reverse (that r2 is also able to do a delete, as long as r1 hasn&apos;t).&lt;/p&gt;

&lt;p&gt;And also this one:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[junit] Testcase: testNormsRefCounting(org.apache.lucene.index.TestIndexReaderCloneNorms):	FAILED
[junit] did not hit expected exception
[junit] junit.framework.AssertionFailedError: did not hit expected exception
[junit] 	at org.apache.lucene.index.TestIndexReaderCloneNorms.testNormsRefCounting(TestIndexReaderCloneNorms.java:179)
[junit] 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which I think is failing for the same reason (changed semantics).&lt;/p&gt;

&lt;p&gt;It seems like you also now allow non-readOnly reader to clone to a writable one?  Is there a test case for that?&lt;/p&gt;

&lt;p&gt;Also can you make sure you always close MockRAMDir&apos;s that you opened (at least one test does not)?  On close it fails if there are still any open files, which is a good test that we are not over-incref&apos;ing somewhere.&lt;/p&gt;</comment>
                    <comment id="12664733" author="jasonrutherglen" created="Fri, 16 Jan 2009 23:24:36 +0000"  >&lt;p&gt;I was running &quot;ant test-tag&quot; which doesn&apos;t run all the tests (such as&lt;br/&gt;
the ones from the patch) so the failures weren&apos;t showing up.  Executed ant test-core.&lt;br/&gt;
And I always see:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; Testcase:&lt;br/&gt;
warning(junit.framework.TestSuite$1):	FAILED &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; No tests found&lt;br/&gt;
in org.apache.lucene.index.TestDebug &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: No tests found in&lt;br/&gt;
org.apache.lucene.index.TestDebug&lt;/p&gt;

&lt;p&gt;TestIndexReaderCloneNorms.testNormsRefCounting changed where the&lt;br/&gt;
expected exception test is made, trying to write to a reader that&apos;s&lt;br/&gt;
been cloned, and the clone has been updated&lt;/p&gt;

&lt;p&gt;Changed TestIndexReaderClone.testCloneWriteToOrig to test if deleting&lt;br/&gt;
from the original reader works (it should because neither one has&lt;br/&gt;
made updates and acquired the write lock at that stage)&lt;/p&gt;
</comment>
                    <comment id="12664866" author="mikemccand" created="Sat, 17 Jan 2009 20:30:20 +0000"  >&lt;p&gt;It&apos;s best to run &quot;ant test test-tag&quot;, which tests core, contrib and back compat.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;junit&amp;#93;&lt;/span&gt; junit.framework.AssertionFailedError: No tests found in&lt;br/&gt;
org.apache.lucene.index.TestDebug &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m not sure what&apos;s up with that... I don&apos;t see a TestDebug.java checked in.  Maybe you have a local mod?&lt;/p&gt;</comment>
                    <comment id="12664976" author="mikemccand" created="Sun, 18 Jan 2009 16:26:42 +0000"  >
&lt;p&gt;New patch attached.  All tests pass.  Changes:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Simplified semantics: if you clone non-readOnly reader1 to&lt;br/&gt;
    non-readOnly reader2, I now simply clear hasChanges &amp;amp; writeLock on&lt;br/&gt;
    reader1 and transfer them to reader2, but do not set readOnly in&lt;br/&gt;
    reader1.  This means reader1 is free to attempt to acquire the&lt;br/&gt;
    write lock if it wants, and it simply fails if it&apos;s stale (ie, we&lt;br/&gt;
    just re-use the existing code path to catch this, rather than add&lt;br/&gt;
    a new check), and this way we never have a case where an existing&lt;br/&gt;
    reader &quot;becomes&quot; readOnly &amp;#8211; it can only be born readOnly.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added reopen(readOnly) (what Jason referred to above).  I think&lt;br/&gt;
    the semantics are well defined: it returns a new reader if either&lt;br/&gt;
    the index has changed or readOnly is different.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Added test for &quot;clone readOnly to non-readOnly&quot; case, which&lt;br/&gt;
    failed, and fixed various places where we were not respecting&lt;br/&gt;
    &quot;openReadOnly&quot; correctly.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Share common source (ReadOnlySegmentReader.noWrite) for throwing&lt;br/&gt;
    exception on attempting change to a readOnly reader&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Fixed a sneaky pre-existing bug with reopen (added test case): if&lt;br/&gt;
    you have a non-readOnly reader on a single segment index, then add&lt;br/&gt;
    a segment, then reopen it and try to do a delete w/ new reader, it&lt;br/&gt;
    fails.  This is because we were incorrectly sharing the original&lt;br/&gt;
    SegmentReader instance which still had its own SegmentInfos, so it&lt;br/&gt;
    attempts to double-acquire write lock during a single deleteDocument&lt;br/&gt;
    call.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;More tests&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12666256" author="shalinmangar" created="Thu, 22 Jan 2009 19:23:40 +0000"  >&lt;blockquote&gt;&lt;p&gt;Fixed a sneaky pre-existing bug with reopen&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Michael, does this affect IndexReader.deleteDocument only? Is using IndexWriter.deleteDocuments fine?&lt;/p&gt;</comment>
                    <comment id="12666334" author="mikemccand" created="Thu, 22 Jan 2009 22:48:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;Michael, does this affect IndexReader.deleteDocument only? Is using IndexWriter.deleteDocuments fine?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Correct, it&apos;s only attempted changes through the reopened IndexReader that are affected (IndexWriter is fine).&lt;/p&gt;</comment>
                    <comment id="12667440" author="mikemccand" created="Mon, 26 Jan 2009 21:29:58 +0000"  >&lt;p&gt;OK, new patch.  I think it&apos;s ready to commit!  I&apos;ll wait a day or&lt;br/&gt;
two... changes:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Allow reopen(readOnly=true) on a reader that has pending changes&lt;br/&gt;
    (added test)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added CHANGES.txt entry&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added some missing copyrights, fixed javadocs.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Small cleanups, asserts, refactoring&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="12668816" author="mikemccand" created="Fri, 30 Jan 2009 11:13:09 +0000"  >&lt;p&gt;Committed revision 739238.  Thanks Jason!&lt;/p&gt;</comment>
                    <comment id="12668930" author="jasonrutherglen" created="Fri, 30 Jan 2009 17:09:38 +0000"  >&lt;p&gt;Cool, cheers Mike!&lt;/p&gt;</comment>
                    <comment id="12668941" author="jasonrutherglen" created="Fri, 30 Jan 2009 17:28:53 +0000"  >&lt;p&gt;I&apos;m thinking of implementing a follow on patch that performs pooling&lt;br/&gt;
of the byte arrays used by the norms and deleted docs. Because the&lt;br/&gt;
byte array length for a segment is always the same, they can be&lt;br/&gt;
pooled. &lt;/p&gt;

&lt;p&gt;It is useful because if IR.clone is called repeatedly and written to,&lt;br/&gt;
with the old readers thrown away, the byte arrays will accumulate as&lt;br/&gt;
garbage and this could affect the garbage collector. The patch will&lt;br/&gt;
most likely end up in contrib as it would use ConcurrentHashMap to&lt;br/&gt;
avoid synchronization. &lt;/p&gt;

</comment>
                    <comment id="12669030" author="mikemccand" created="Fri, 30 Jan 2009 21:22:30 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I&apos;m thinking of implementing a follow on patch that performs pooling&lt;br/&gt;
of the byte arrays used by the norms and deleted docs.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think this may be premature, or maybe just out of order... I&apos;d much rather see the incremental copy on write solution (which would not be allocating the whole array) explored first, I think?&lt;/p&gt;</comment>
                    <comment id="12671362" author="jasonrutherglen" created="Fri, 6 Feb 2009 22:42:46 +0000"  >&lt;p&gt;Now that we&apos;ve got IndexReader.getSequentialSubReaders(), users may&lt;br/&gt;
try to clone the sub-readers which throws the exception below. I&apos;d&lt;br/&gt;
like to support cloning individual segment readers because some cases&lt;br/&gt;
require cloning on the existing segments, without reloading the new&lt;br/&gt;
segments. &lt;/p&gt;

&lt;p&gt;The use case is realtime search where the ram index is being flushed&lt;br/&gt;
to disk in the background and we don&apos;t need IR.clone to also open the&lt;br/&gt;
new segments. The old segments could be acquiring deletes as the&lt;br/&gt;
background flush to disk is occurring. I suppose I could write a hack&lt;br/&gt;
such that a clone is performed on the multireader, then only the old&lt;br/&gt;
segments are pulled out and deleted from.&lt;/p&gt;

&lt;p&gt;Attached is a method TestIndexReaderClone.testCloneSubreaders that&lt;br/&gt;
tests individual segment reader clone.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.NullPointerException
	at org.apache.lucene.index.DirectoryIndexReader.clone(DirectoryIndexReader.java:171)
	at org.apache.lucene.index.DirectoryIndexReader.clone(DirectoryIndexReader.java:162)
	at org.apache.lucene.index.TestIndexReaderClone.testCloneSubreaders(TestIndexReaderClone.java:46)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12671511" author="mikemccand" created="Sat, 7 Feb 2009 19:29:45 +0000"  >&lt;p&gt;Attached patch.  If the segmentInfos is null (because the SegmentReader is not &quot;standalone&quot;) we now just clone the segment.  If you call reopen on a non-standalone SegmentReader I throw UnsupportedOperationException.&lt;/p&gt;

&lt;p&gt;Jason can you test this?  Thanks.&lt;/p&gt;</comment>
                    <comment id="12671951" author="jasonrutherglen" created="Mon, 9 Feb 2009 18:34:42 +0000"  >&lt;p&gt;Mike, your patch solved the null pointer exception. An item of&lt;br/&gt;
concern is when deleteDocument is called on the sub-readers, the&lt;br/&gt;
write lock is not acquired, and it&apos;s not passed from the parent&lt;br/&gt;
MultiSegmentReader. In the new patch I close the subreaders&lt;br/&gt;
individually, then close the MultiSegmentReader. When opening the&lt;br/&gt;
index again the SegmentReader can&apos;t find the .del file. Perhaps we&lt;br/&gt;
javadoc the parameters of these types of cases or there&apos;s a fix.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.io.FileNotFoundException: _b_1.del
	at org.apache.lucene.store.MockRAMDirectory.openInput(MockRAMDirectory.java:246)
	at org.apache.lucene.util.BitVector.&amp;lt;init&amp;gt;(BitVector.java:209)
	at org.apache.lucene.index.SegmentReader.loadDeletedDocs(SegmentReader.java:591)
	at org.apache.lucene.index.SegmentReader.initialize(SegmentReader.java:557)
	at org.apache.lucene.index.SegmentReader.get(SegmentReader.java:495)
	at org.apache.lucene.index.SegmentReader.get(SegmentReader.java:417)
	at org.apache.lucene.index.MultiSegmentReader.&amp;lt;init&amp;gt;(MultiSegmentReader.java:55)
	at org.apache.lucene.index.DirectoryIndexReader$1.doBody(DirectoryIndexReader.java:112)
	at org.apache.lucene.index.SegmentInfos$FindSegmentsFile.run(SegmentInfos.java:688)
	at org.apache.lucene.index.DirectoryIndexReader.open(DirectoryIndexReader.java:123)
	at org.apache.lucene.index.IndexReader.open(IndexReader.java:316)
	at org.apache.lucene.index.IndexReader.open(IndexReader.java:227)
	at org.apache.lucene.index.TestIndexReaderClone.testCloneSubreaders(TestIndexReaderClone.java:427)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="12671991" author="mikemccand" created="Mon, 9 Feb 2009 20:07:44 +0000"  >&lt;p&gt;If the SegmentReader is not standalone (does not &quot;own&quot; a SegmentInfos,&lt;br/&gt;
and is therefore a sub-reader in a MultiSegmentReader), I think you&lt;br/&gt;
should not make changes (setNorm, deleteDocument) with it?&lt;/p&gt;

&lt;p&gt;Ie, you should always use the &quot;parent&quot; MultiSegmentReader to make&lt;br/&gt;
changes.&lt;/p&gt;

&lt;p&gt;I&apos;ll update the javadocs for getSequentialSubReaders to state this.&lt;/p&gt;
</comment>
                    <comment id="12673359" author="jasonrutherglen" created="Fri, 13 Feb 2009 19:30:24 +0000"  >&lt;blockquote&gt;
&lt;p&gt;If the SegmentReader is not standalone (does not &quot;own&quot; a SegmentInfos,&lt;br/&gt;
and is therefore a sub-reader in a MultiSegmentReader), I think you&lt;br/&gt;
should not make changes (setNorm, deleteDocument) with it? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For realtime there is a use case where a Multi*Reader needs to be&lt;br/&gt;
cloned without (re)opening the new segments. This is due to running&lt;br/&gt;
IW.addIndexes in a backbround thread where upon completion a&lt;br/&gt;
concurrent IR.clone could unintentionally open the new segments.&lt;br/&gt;
Opening the new segments may be undesirable because the transaction&lt;br/&gt;
may have locked segments and so does not want to delete from the new&lt;br/&gt;
segments. &lt;/p&gt;

&lt;p&gt;One approach is an IndexReader.cloneNoNew method. Or perhaps&lt;br/&gt;
IR.clone(boolean openReadOnly, boolean openNewSegments) where&lt;br/&gt;
openNewSegments defaults to true. &lt;/p&gt;</comment>
                    <comment id="12673415" author="mikemccand" created="Fri, 13 Feb 2009 23:14:11 +0000"  >&lt;blockquote&gt;
&lt;p&gt;For realtime there is a use case where a Multi*Reader needs to be&lt;br/&gt;
cloned without (re)opening the new segments.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I thought that&apos;s exactly what clone does (does not open the segments_N)?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is due to running&lt;br/&gt;
IW.addIndexes in a backbround thread where upon completion a&lt;br/&gt;
concurrent IR.clone could unintentionally open the new segments.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If IW is opened with autoCommit false, then even on completely of addIndexes,&lt;br/&gt;
a newly &lt;span class=&quot;error&quot;&gt;&amp;#91;re-&amp;#93;&lt;/span&gt;opened reader won&apos;t see the change, until IW commits?&lt;/p&gt;</comment>
                    <comment id="12673442" author="jasonrutherglen" created="Sat, 14 Feb 2009 01:09:12 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I thought that&apos;s exactly what clone does (does not open the&lt;br/&gt;
segments_N)? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; IW+IR is crowding into my thoughts on realtime and clone&lt;br/&gt;
where the segmentinfos is obtained from the IW which gets updated. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If IW is opened with autoCommit false, then even on&lt;br/&gt;
completely of addIndexes, a newly &lt;span class=&quot;error&quot;&gt;&amp;#91;re-&amp;#93;&lt;/span&gt;opened reader won&apos;t see the&lt;br/&gt;
change, until IW commits? &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Perhaps we need to update the IW.addIndexes javadoc which reads:&lt;br/&gt;
&quot;This method is transactional in how Exceptions are handled: it does&lt;br/&gt;
not commit a new segments_N file until all indexes are added. This&lt;br/&gt;
means if an Exception occurs (for example disk full), then either no&lt;br/&gt;
indexes will have been added or they all will have been.&quot;&lt;/p&gt;

&lt;p&gt;I wasn&apos;t sure if commit is required to see the new indexes. Maybe we&lt;br/&gt;
can add something like &quot;When autoCommit=false commit must be called&lt;br/&gt;
to make the new indexes visible to a reader&quot;. &lt;/p&gt;</comment>
                    <comment id="12673590" author="mikemccand" created="Sun, 15 Feb 2009 10:26:48 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I wasn&apos;t sure if commit is required to see the new indexes. Maybe we&lt;br/&gt;
can add something like &quot;When autoCommit=false commit must be called&lt;br/&gt;
to make the new indexes visible to a reader&quot;. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Actually, this is already described in the &quot;autoCommit=false&quot; javadocs at the top of IW.  Any &amp;amp; all changes done with IW are not visible to a newly opened IR until commit() is called.&lt;/p&gt;</comment>
                    <comment id="12673597" author="mikemccand" created="Sun, 15 Feb 2009 10:57:31 +0000"  >&lt;p&gt;Committed revision 744653, to allow cloning of sub-readers.&lt;/p&gt;</comment>
                    <comment id="12675886" author="mikemccand" created="Mon, 23 Feb 2009 13:14:49 +0000"  >&lt;p&gt;Reopening to remember to add the missing deprecations for 2.9...&lt;/p&gt;</comment>
                    <comment id="12675899" author="mikemccand" created="Mon, 23 Feb 2009 13:59:18 +0000"  >&lt;p&gt;Duh, wrong issue.&lt;/p&gt;</comment>
                    <comment id="12677120" author="jasonrutherglen" created="Thu, 26 Feb 2009 19:41:18 +0000"  >&lt;p&gt;Related to &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1516&quot; title=&quot;Integrate IndexReader with IndexWriter &quot;&gt;&lt;del&gt;LUCENE-1516&lt;/del&gt;&lt;/a&gt; I&apos;m seeing a bug.&lt;/p&gt;

&lt;p&gt;The test case in TestIndexReaderClone.testLucene1516Bug recreates the&lt;br/&gt;
bug. Basically a reader is created, incRefed, a clone is made, the&lt;br/&gt;
reader is decRefed, then incRefed again where the&lt;br/&gt;
reader.deletedDocsRef assert &amp;gt; 0 fails.&lt;/p&gt;</comment>
                    <comment id="12677181" author="mikemccand" created="Fri, 27 Feb 2009 00:32:36 +0000"  >&lt;p&gt;Hmm &amp;#8211; good catch!  In fact I think we should not be incRef/decRefing the deletedDocsRef with every incRef/decRef on the SegmentReader... I&apos;ll fix.&lt;/p&gt;</comment>
                    <comment id="12677526" author="mikemccand" created="Fri, 27 Feb 2009 21:04:14 +0000"  >
&lt;p&gt;Attached patch.  I plan to commit in a day or two.&lt;/p&gt;

&lt;p&gt;OK I changed deletedDocRefs to only be inc/decRef&apos;d once for the&lt;br/&gt;
reader, not every time the reader is inc/decRef&apos;d (which was causing&lt;br/&gt;
the bug you saw).&lt;/p&gt;

&lt;p&gt;But then because of how a reopened SegmentReader references the&lt;br/&gt;
original, the deleted docs were being unecessarily copy-on-write&apos;d (on&lt;br/&gt;
closing the first reader we would fail to decref the deletedDocsRef so&lt;br/&gt;
when the 2nd reader did a delete, it would copy).&lt;/p&gt;

&lt;p&gt;So then I added a new coreRef to SegmentReader, instead of the&lt;br/&gt;
referencedSegmengReader.  I like this approach better because it&lt;br/&gt;
allows the original reader to be closed, without closing the core&lt;br/&gt;
objects when other readers share them.&lt;/p&gt;

&lt;p&gt;It also simplifies SegmentReader&apos;s inc/decRef so that they no longer&lt;br/&gt;
need to be overridden.&lt;/p&gt;

&lt;p&gt;Also, when cloning the BitVector, I changed it to not copy count over&lt;br/&gt;
&amp;#8211; if a separate thread is changing the deleted docs at the same time,&lt;br/&gt;
the count could be off.&lt;/p&gt;

&lt;p&gt;Back-compat tests don&apos;t pass, because TestIndexReaderReopen is&lt;br/&gt;
checking internal reference counts; I&apos;ll commit fixes to tests when I&lt;br/&gt;
commit.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12390270" name="lucene-1314.patch" size="44934" author="jasonrutherglen" created="Wed, 17 Sep 2008 14:30:55 +0100" />
                    <attachment id="12386189" name="lucene-1314.patch" size="41705" author="jasonrutherglen" created="Wed, 16 Jul 2008 15:44:29 +0100" />
                    <attachment id="12385762" name="lucene-1314.patch" size="40146" author="jasonrutherglen" created="Thu, 10 Jul 2008 15:11:08 +0100" />
                    <attachment id="12385523" name="lucene-1314.patch" size="39941" author="jasonrutherglen" created="Tue, 8 Jul 2008 18:52:14 +0100" />
                    <attachment id="12385522" name="lucene-1314.patch" size="30078" author="jasonrutherglen" created="Tue, 8 Jul 2008 18:49:38 +0100" />
                    <attachment id="12385394" name="lucene-1314.patch" size="35926" author="jasonrutherglen" created="Mon, 7 Jul 2008 14:10:11 +0100" />
                    <attachment id="12385197" name="lucene-1314.patch" size="20078" author="mikemccand" created="Thu, 3 Jul 2008 12:48:06 +0100" />
                    <attachment id="12385152" name="lucene-1314.patch" size="21034" author="jasonrutherglen" created="Wed, 2 Jul 2008 23:05:54 +0100" />
                    <attachment id="12384921" name="lucene-1314.patch" size="21274" author="jasonrutherglen" created="Sun, 29 Jun 2008 16:17:39 +0100" />
                    <attachment id="12384598" name="lucene-1314.patch" size="16870" author="jasonrutherglen" created="Tue, 24 Jun 2008 17:55:48 +0100" />
                    <attachment id="12384591" name="lucene-1314.patch" size="16412" author="jasonrutherglen" created="Tue, 24 Jun 2008 16:38:11 +0100" />
                    <attachment id="12384513" name="lucene-1314.patch" size="13680" author="jasonrutherglen" created="Mon, 23 Jun 2008 18:13:51 +0100" />
                    <attachment id="12401131" name="LUCENE-1314.patch" size="14128" author="mikemccand" created="Fri, 27 Feb 2009 21:04:14 +0000" />
                    <attachment id="12401062" name="LUCENE-1314.patch" size="943" author="jasonrutherglen" created="Thu, 26 Feb 2009 19:41:18 +0000" />
                    <attachment id="12399842" name="LUCENE-1314.patch" size="4027" author="jasonrutherglen" created="Mon, 9 Feb 2009 18:34:42 +0000" />
                    <attachment id="12399733" name="LUCENE-1314.patch" size="3236" author="mikemccand" created="Sat, 7 Feb 2009 19:29:45 +0000" />
                    <attachment id="12399694" name="LUCENE-1314.patch" size="1072" author="jasonrutherglen" created="Fri, 6 Feb 2009 22:42:46 +0000" />
                    <attachment id="12398771" name="LUCENE-1314.patch" size="92882" author="mikemccand" created="Mon, 26 Jan 2009 21:29:58 +0000" />
                    <attachment id="12398183" name="LUCENE-1314.patch" size="92149" author="mikemccand" created="Sun, 18 Jan 2009 16:26:42 +0000" />
                    <attachment id="12398119" name="LUCENE-1314.patch" size="84204" author="jasonrutherglen" created="Fri, 16 Jan 2009 23:24:36 +0000" />
                    <attachment id="12398112" name="LUCENE-1314.patch" size="83968" author="jasonrutherglen" created="Fri, 16 Jan 2009 21:56:37 +0000" />
                    <attachment id="12398102" name="LUCENE-1314.patch" size="83544" author="jasonrutherglen" created="Fri, 16 Jan 2009 19:59:07 +0000" />
                    <attachment id="12398085" name="LUCENE-1314.patch" size="84388" author="jasonrutherglen" created="Fri, 16 Jan 2009 16:41:36 +0000" />
                    <attachment id="12398041" name="LUCENE-1314.patch" size="84340" author="jasonrutherglen" created="Fri, 16 Jan 2009 03:32:33 +0000" />
                    <attachment id="12397820" name="LUCENE-1314.patch" size="62037" author="jasonrutherglen" created="Tue, 13 Jan 2009 21:43:23 +0000" />
                    <attachment id="12397663" name="LUCENE-1314.patch" size="77876" author="mikemccand" created="Sun, 11 Jan 2009 22:45:13 +0000" />
                    <attachment id="12397447" name="LUCENE-1314.patch" size="50662" author="jasonrutherglen" created="Thu, 8 Jan 2009 21:22:04 +0000" />
                    <attachment id="12397266" name="LUCENE-1314.patch" size="49012" author="jasonrutherglen" created="Wed, 7 Jan 2009 04:41:43 +0000" />
                    <attachment id="12397161" name="LUCENE-1314.patch" size="45584" author="jasonrutherglen" created="Mon, 5 Jan 2009 23:05:39 +0000" />
                    <attachment id="12396690" name="LUCENE-1314.patch" size="41983" author="jasonrutherglen" created="Tue, 23 Dec 2008 19:11:08 +0000" />
                    <attachment id="12396679" name="LUCENE-1314.patch" size="41250" author="jasonrutherglen" created="Tue, 23 Dec 2008 16:33:00 +0000" />
                    <attachment id="12396616" name="LUCENE-1314.patch" size="40748" author="jasonrutherglen" created="Mon, 22 Dec 2008 18:33:06 +0000" />
                    <attachment id="12396451" name="LUCENE-1314.patch" size="36353" author="jasonrutherglen" created="Fri, 19 Dec 2008 02:21:43 +0000" />
                    <attachment id="12395961" name="LUCENE-1314.patch" size="34826" author="jasonrutherglen" created="Fri, 12 Dec 2008 18:44:00 +0000" />
                    <attachment id="12395774" name="LUCENE-1314.patch" size="18457" author="jasonrutherglen" created="Wed, 10 Dec 2008 23:36:54 +0000" />
                    <attachment id="12395766" name="LUCENE-1314.patch" size="17453" author="jasonrutherglen" created="Wed, 10 Dec 2008 23:02:37 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>36.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 25 Jun 2008 05:01:57 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12434</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26414</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>