<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:22:54 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-2482/LUCENE-2482.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-2482] Index sorter</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-2482</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;A tool to sort index according to a float document weight. Documents with high weight are given low document numbers, which means that they will be first evaluated. When using a strategy of &quot;early termination&quot; of queries (see TimeLimitedCollector) such sorting significantly improves the quality of partial results.&lt;/p&gt;

&lt;p&gt;(Originally this tool was created by Doug Cutting in Nutch, and used norms as document weights - thus the ordering was limited by the limited resolution of norms. This is a pure Lucene version of the tool, and it uses arbitrary floats from a specified stored field).&lt;/p&gt;</description>
                <environment></environment>
            <key id="12465591">LUCENE-2482</key>
            <summary>Index sorter</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="ab">Andrzej Bialecki </assignee>
                                <reporter username="ab">Andrzej Bialecki </reporter>
                        <labels>
                    </labels>
                <created>Thu, 27 May 2010 20:16:01 +0100</created>
                <updated>Fri, 10 May 2013 11:42:53 +0100</updated>
                    <resolved>Sun, 25 Mar 2012 18:04:11 +0100</resolved>
                            <version>3.1</version>
                <version>4.0-ALPHA</version>
                                <fixVersion>3.6</fixVersion>
                                <component>modules/other</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>5</watches>
                                                    <comments>
                    <comment id="12872329" author="ab" created="Thu, 27 May 2010 20:16:43 +0100"  >&lt;p&gt;Patch with the tool and a unit test.&lt;/p&gt;</comment>
                    <comment id="12872357" author="eksdev" created="Thu, 27 May 2010 21:44:22 +0100"  >&lt;p&gt;nice! &lt;br/&gt;
There is also another interesting use case for sorting index, performance and index size!&lt;/p&gt;

&lt;p&gt;We use a couple of fields with low cardinality (zip code, user group... and likes). Having index sorted on these makes rle compression of  postings really effective, making it possible to load all values into couple of M-bytes of ram.&lt;br/&gt;
At a moment we just sort collection before indexing.&lt;/p&gt;

&lt;p&gt;Would  it be possible somehow to use a combination of stored fields and to specify comparator? Even comparing them as byte[] would do the trick for this business case as it is only important to keep the same values together, order is irrelevant. Of course, having decoder to decode byte[] before comparing would be useful (e.g. for composite fields) , but would work in many cases without it.   &lt;/p&gt;

&lt;p&gt;This works fine even with moderate update rate, as you can re-sort periodically. It does not have to be totally sorted, everything works, just slightly more memory is needed for filters&lt;/p&gt;

&lt;p&gt;With flex, having postings that use rle compression is quite possible ... this tool could become &quot;optimizeHard()&quot; tool for some indexes &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="12872366" author="ab" created="Thu, 27 May 2010 22:10:59 +0100"  >&lt;p&gt;Re: combination of fields + a comparator: sure, why not, take a look at the implementation of the DocScore inner class - you can stuff whatever you want there.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure if I follow your use case though ... please remember that this re-sorting is applied exactly the same to all postings, so savings on one list may cause bloat on another list.&lt;/p&gt;</comment>
                    <comment id="12872386" author="eksdev" created="Thu, 27 May 2010 22:41:56 +0100"  >&lt;p&gt;Re: I&apos;m not sure if I follow your use case though&lt;/p&gt;

&lt;p&gt;Simple case, you have a 100Mio docs with 2 fields, CITY and  TEXT&lt;/p&gt;

&lt;p&gt;sorting on CITY makes postings look like: &lt;br/&gt;
    Orlando:                  ---------------------------------&lt;br/&gt;
 New York:                                                               -------------------------------------&lt;br/&gt;
perfectly compressible. &lt;/p&gt;

&lt;p&gt;without really affecting distribution (compressibility) of terms from the TEXT field.&lt;/p&gt;

&lt;p&gt;If CITY would remain in unsorted order (e.g. uniform distribution), you deal with very large postings for all terms coming from this field  &lt;/p&gt;

&lt;p&gt;Sorting on many fields helps often, e.g. if you have hierarchical compositions like 1 CITY with many  ZIP_CODES...  philosophically, sorting always increases compressibility and improves locality of reference... but sure, you need to know what you want&lt;/p&gt;</comment>
                    <comment id="12897172" author="ab" created="Wed, 11 Aug 2010 09:03:43 +0100"  >&lt;p&gt;If there are no objections I&apos;d like to commit this soon.&lt;/p&gt;</comment>
                    <comment id="12912481" author="ab" created="Mon, 20 Sep 2010 15:46:42 +0100"  >&lt;p&gt;Committed in rev. 998948.&lt;/p&gt;</comment>
                    <comment id="12912921" author="ab" created="Tue, 21 Sep 2010 11:25:38 +0100"  >&lt;p&gt;..to remember we need a port of this tool to 4.0&lt;/p&gt;</comment>
                    <comment id="12915993" author="koji" created="Wed, 29 Sep 2010 02:11:39 +0100"  >&lt;p&gt;I think this is an interesting tool. I&apos;m wondering if Solr can call it, as Solr does merge indexes. &lt;/p&gt;

&lt;p&gt;Is there any restrictions on this? I&apos;ve never looked into deeper it, but for example, I see isPayloadAvailable() returns always false. Does it mean that it doesn&apos;t support payload?&lt;br/&gt;
Can it support multiple Sorts on indexed fields other than stored float field?&lt;/p&gt;</comment>
                    <comment id="12933896" author="mikemccand" created="Fri, 19 Nov 2010 18:10:04 +0000"  >&lt;p&gt;We need to fix this on 4.0 too.&lt;/p&gt;</comment>
                    <comment id="12982411" author="rcmuir" created="Sun, 16 Jan 2011 22:54:22 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not sure if I follow your use case though ... please remember that this re-sorting is applied exactly the same to all postings, so savings on one list may cause bloat on another list.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hi Andrzej, I came across this the other day, and thought it would be really interesting in the context of some of our newer codecs&lt;br/&gt;
under development in trunk and the bulkpostings branch.&lt;/p&gt;

&lt;p&gt;I found the results presented there based on index sorting for codecs like simple9 to be really compelling, significant reduction&lt;br/&gt;
in bits/posting for docids especially, because it can pack a lot of small deltas efficiently.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;The &#64257;rst method reorders the documents in a text collection based on the number of
distinct terms contained in each document. The idea is that two documents that each
contain a large number of distinct terms are more likely to share terms than are a
document with many distinct terms and a document with few distinct terms. Therefore,
by assigning docids so that documents with many terms are close together, we may
expect a greater clustering e&#64256;ect than by assigning docids at random.

The second method assumes that the documents have been crawled from the Web (or
maybe a corporate Intranet). It reassigns docids in lexicographical order of URL. The
idea here is that two documents from the same Web server (or maybe even from the
same directory on that server) are more likely to share common terms than two random
documents from unrelated locations on the Internet.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ir.uwaterloo.ca/book/06-index-compression.pdf&quot; class=&quot;external-link&quot;&gt;http://www.ir.uwaterloo.ca/book/06-index-compression.pdf&lt;/a&gt; (see page 214: doc id reordering)&lt;/p&gt;</comment>
                    <comment id="12984393" author="juangrande" created="Thu, 20 Jan 2011 20:53:16 +0000"  >&lt;p&gt;Hi! I&apos;m attaching a patch with an implementation of this feature for Lucene 4.0. I&apos;m not sure if the style is right because I can&apos;t download the codestyle.xml file for Eclipse.&lt;/p&gt;</comment>
                    <comment id="12985331" author="shaie" created="Sun, 23 Jan 2011 14:18:10 +0000"  >&lt;p&gt;Looks like it needs some more work - moving to 3.2&lt;/p&gt;</comment>
                    <comment id="13043546" author="rcmuir" created="Fri, 3 Jun 2011 17:40:41 +0100"  >&lt;p&gt;bulk move 3.2 -&amp;gt; 3.3&lt;/p&gt;</comment>
                    <comment id="13199201" author="pablo.castellanos" created="Thu, 2 Feb 2012 20:45:27 +0000"  >&lt;p&gt;Hi, I wanted to implement some early termination strategies over my Lucene index so I started playing with the 4.0 patch as I need to reorder it.&lt;/p&gt;

&lt;p&gt;So I have found that a lot of functions have changed in the past year and I had to go for some modifications, mainly:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/*@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; TermFreqVector[] getTermFreqVectors(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docNumber)
        &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getTermFreqVectors(newToOld[docNumber]);
}*/

@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Fields getTermVectors(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docID) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException {
&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getTermVectors(newToOld[docID]);
}

/*@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Document document(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n, FieldSelector fieldSelector)
        &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.document(newToOld[n], fieldSelector);
}*/

@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void document(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; docID, StoredFieldVisitor visitor)
&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CorruptIndexException, IOException {
&lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.document(newToOld[docID], visitor);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There exists also a getDeletedDocs function and I haven&apos;t found any good replacement for it&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /*@Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Bits getDeletedDocs() {
      &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bits deletedDocs = &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.getDeletedDocs();

      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (deletedDocs == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;

      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Bits() {
        @Override
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; get(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; index) {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; deletedDocs.get(newToOld[index]);
        }

        @Override
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; length() {
          &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; deletedDocs.length();
        }
      };
    }*/
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After applying these changes and using the code against my lucene index I get some weird results. It seems that the new sorting has worked but the posting list that access to the documents is still pointing to the old data.&lt;/p&gt;

&lt;p&gt;Imagine that I have 2 documents in my index and that I want to sort them by price (So the most expensive item should have a lower docId)&lt;/p&gt;

&lt;p&gt;Document 1&lt;/p&gt;
&lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;docId:1, name: iPod, price: 100$&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Document 2&lt;/p&gt;
&lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;docId:2, name: iPhone, price: 300$&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I run my modified version of IndexSorter over it and after that I try to query the new index, so if I query for &lt;em&gt;name:iPhone&lt;/em&gt; I get:&lt;/p&gt;
&lt;div class=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;panelContent&quot;&gt;
&lt;p&gt;docId:2, name: iPod, price: 100$&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That leads me to believe that the documents have been sorted but the new index is using the old posting list. &lt;/p&gt;

&lt;p&gt;So I have two questions, are you planning on updating this code for newer versions of Lucene 4.0 or am I on my own to get it to work? And if this is the case, where should I look for getting a solution for my problem?&lt;/p&gt;

&lt;p&gt;Thanks in advance for your help.&lt;/p&gt;</comment>
                    <comment id="13237931" author="rcmuir" created="Sun, 25 Mar 2012 18:02:25 +0100"  >&lt;p&gt;This issue is actually fixed in 3.x, but is still open for a 4.0 port.&lt;/p&gt;

&lt;p&gt;I&apos;ll open an issue (with fix version of 4.0) for the trunk port.&lt;/p&gt;</comment>
                    <comment id="13237932" author="rcmuir" created="Sun, 25 Mar 2012 18:04:11 +0100"  >&lt;p&gt;I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3918&quot; title=&quot;Port index sorter to trunk APIs&quot;&gt;&lt;del&gt;LUCENE-3918&lt;/del&gt;&lt;/a&gt; for the trunk port to eliminate confusing in JIRA: the 3.x work has been done for a while.&lt;/p&gt;</comment>
                    <comment id="13494187" author="matthjw" created="Fri, 9 Nov 2012 18:31:24 +0000"  >&lt;p&gt;Hi all &amp;#8211; few quick questions if anyone is still watching this.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Could this be used to achieve an impact ordered index, as in e.g. &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, where documents in a given term&apos;s postings list are ordered by score contribution or term frequency?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Any caveats or things one should be aware of when it comes to index sorting in combination with different index merge strategies, and some of the more advanced stuff in Solr for managing distributed indexes?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Anyone aware of any other work along the lines of early stopping / dynamic pruning optimisations in Lucene? e.g. MaxScore from &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; (I think Xapian &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; calls it &apos;operator decay&apos;) or accumulator pruning based algorithms from &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; (perhaps in combination with impact ordering)? in particular is there anything in Lucene 4&apos;s approach to scoring and indexing which would make these hard in principle?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Any pointers gratefully received.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Buettcher Clarke &amp;amp; Cormack &quot;Implementing and Evaluating search engines&quot; ch. 5 pp. 143-153&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://xapian.org/docs/matcherdesign.html&quot; class=&quot;external-link&quot;&gt;http://xapian.org/docs/matcherdesign.html&lt;/a&gt;&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12445691" name="indexSorter.patch" size="15464" author="ab" created="Thu, 27 May 2010 20:16:43 +0100" />
                    <attachment id="12468887" name="LUCENE-2482-4.0.patch" size="13461" author="juangrande" created="Thu, 20 Jan 2011 20:53:16 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 27 May 2010 20:44:22 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>11338</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>25210</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>