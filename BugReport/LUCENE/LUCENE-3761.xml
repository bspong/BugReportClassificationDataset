<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:29:56 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3761/LUCENE-3761.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3761] Generalize SearcherManager</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3761</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;I&apos;d like to generalize SearcherManager to a class which can manage instances of a certain type of interfaces. The reason is that today SearcherManager knows how to handle IndexSearcher instances. I have a SearcherManager which manages a pair of IndexSearcher and TaxonomyReader pair.&lt;/p&gt;

&lt;p&gt;Recently, few concurrency bugs were fixed in SearcherManager, and I realized that I need to apply them to my version as well. Which led me to think why can&apos;t we have an SM version which is generic enough so that both my version and Lucene&apos;s can benefit from?&lt;/p&gt;

&lt;p&gt;The way I see SearcherManager, it can be divided into two parts: (1) the part that manages the logic of acquire/release/maybeReopen (i.e., ensureOpen, protect from concurrency stuff etc.), and (2) the part which handles IndexSearcher, or my SearcherTaxoPair. I&apos;m thinking that if we&apos;ll have an interface with incRef/decRef/tryIncRef/maybeRefresh, we can make SearcherManager a generic class which handles this interface.&lt;/p&gt;

&lt;p&gt;I will post a patch with the initial idea, and we can continue from there.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12541831">LUCENE-3761</key>
            <summary>Generalize SearcherManager</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="shaie">Shai Erera</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Wed, 8 Feb 2012 16:49:02 +0000</created>
                <updated>Fri, 10 May 2013 11:44:08 +0100</updated>
                    <resolved>Tue, 14 Feb 2012 15:37:13 +0000</resolved>
                                            <fixVersion>3.6</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13203739" author="shaie" created="Wed, 8 Feb 2012 16:55:07 +0000"  >&lt;p&gt;Initial patch. Introduces a new package &apos;thingy&apos; (a temporary one, this will eventually move to o.a.l.search) with the class ThingyManager, a Thingy interface and a SearcherThingy implementation.&lt;/p&gt;

&lt;p&gt;As far as I can tell (if there are no bugs), this can replace SearcherManager as-is, aside from a &apos;nocommit&apos; which I know how to handle, but didn&apos;t get to it yet.&lt;/p&gt;

&lt;p&gt;The approach is that ThingyManager receives a Thingy&amp;lt;G&amp;gt; instance and delegates calls to it.&lt;/p&gt;

&lt;p&gt;Robert and I discussed another approach - have ThingyManager abstract with a concrete (final) SearcherManager impl which overrides methods like incRef/decRef etc. I still didn&apos;t try to impl that approach, I think that I&apos;ll give it a try, later.&lt;/p&gt;

&lt;p&gt;Oh, and BTW, ThingyManager (even though a cool name !) will not be its final name ! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. It&apos;s just easier to progress like that, without thinking too much about the name.&lt;/p&gt;</comment>
                    <comment id="13203753" author="mikemccand" created="Wed, 8 Feb 2012 17:14:44 +0000"  >&lt;p&gt;This looks nice!&lt;/p&gt;

&lt;p&gt;I like &quot;Thingy&quot;.  Very Dr. Seuss...&lt;/p&gt;

&lt;p&gt;I think maybeRefresh should match IR.openIfChanged?  (So we learn from&lt;br/&gt;
our prior mistakes w/ IR.reopen).  Ie, name it openIfChanged&lt;br/&gt;
(maybeRefresh sounds like it could be an in-place operation),&lt;br/&gt;
return null (not this) if there is no change, and document that if it&lt;br/&gt;
returns non-null it transfers a reference to you.&lt;/p&gt;</comment>
                    <comment id="13204343" author="shaie" created="Thu, 9 Feb 2012 08:06:53 +0000"  >&lt;p&gt;Option #2:&lt;/p&gt;

&lt;p&gt;ThingyManager&amp;lt;G&amp;gt; is an abstract class which implements all the concurrency administration and exposes the abstract methods tryIncRef(), decRef() and refreshIfNeeded().&lt;/p&gt;

&lt;p&gt;SearcherManager now extends ThingyManager&amp;lt;IndexSearcher&amp;gt; and implements just these 3 methods (in addition to isSearcherCurrent()).&lt;/p&gt;

&lt;p&gt;What I like about this approach is that SearcherManager remains a concrete class, so that code can reference it and not ThingyManager. Also, IMO it&apos;s a simplified impl vs. the composite ThingyManager/Thingy. AND besides the rename of maybeReopen to maybeRefresh, NONE of the code was affected by this refactoring.&lt;/p&gt;

&lt;p&gt;I&apos;ve left the unneeded code as commented out in SearcherManager for easy comparison, but it should go away. TestSM passes (as well as all core tests), so I think that ThingyManager handles all concurrency cases as SearcherManager. However, it could use another inspecting eye &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;As for the name &amp;#8211; now the name is less important b/c I don&apos;t think we&apos;ll reference ThingyManagers. I lean towards something like ReferenceManager / RefCountManager or remove Manager. Something simple. Suggestions are welcome.&lt;/p&gt;</comment>
                    <comment id="13204614" author="mikemccand" created="Thu, 9 Feb 2012 16:12:52 +0000"  >&lt;p&gt;Looks awesome &amp;#8211; I like this 2nd approach better!&lt;/p&gt;

&lt;p&gt;And, actually... I think maybeRefresh is in fact a good name, because we are refreshing internal state to the ThingyManager (ie, this is different from IR.openIfChanged, which returns a new object to you and does not alter the state of the object you had passed in).&lt;/p&gt;

&lt;p&gt;I think ReferenceManager is good?  RefCountManager seems too low level (ie, ref counting is an impl detail, just one way to manage references, and you are not in fact managing the ref counts...).  Can&apos;t think of any other candidates.... naming is the hardest part &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13204668" author="shaie" created="Thu, 9 Feb 2012 17:30:09 +0000"  >&lt;p&gt;I like ReferenceManager too. I&apos;ll produce a cleaner patch with correct naming and also a SearcherTaxoManager (For an IndexSearcher and TaxoReader pair).&lt;/p&gt;

&lt;p&gt;I&apos;m not in front of the code now &amp;#8211; do you think that NRTManager should be refactored too?&lt;/p&gt;</comment>
                    <comment id="13204681" author="mikemccand" created="Thu, 9 Feb 2012 17:43:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;do you think that NRTManager should be refactored too?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That would be wonderful!  It&apos;s rather... hairy.&lt;/p&gt;

&lt;p&gt;But I think it&apos;s tricky, because the maybeReopen takes a boolean (applyDeletes)... which is confusing.  Maybe, we can change this, so that you must specify the applyDeletes up front to the ctor (I think there&apos;s no harm in making two NRTMgrs if you sometimes require deletes and other times don&apos;t... I mean resource wise it&apos;d be no different that what NRTManager now does internally).  If we did that, then I think NRTManager could subclass ReferenceManager?  (And would no longer &quot;contain&quot; a SearcherManager inside it).&lt;/p&gt;

&lt;p&gt;Probably we should explore that on a new issue...&lt;/p&gt;</comment>
                    <comment id="13205244" author="shaie" created="Fri, 10 Feb 2012 05:19:16 +0000"  >&lt;blockquote&gt;&lt;p&gt;Probably we should explore that on a new issue...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. Given what you wrote, I think it deserves its own inspection. Maybe I&apos;ll do the SearcherTaxoManager in its own issue too, I&apos;ll think about it.&lt;/p&gt;</comment>
                    <comment id="13205565" author="mikemccand" created="Fri, 10 Feb 2012 17:31:23 +0000"  >&lt;p&gt;OK I opened &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3769&quot; title=&quot;Simplify NRTManager&quot;&gt;&lt;del&gt;LUCENE-3769&lt;/del&gt;&lt;/a&gt; to simplify NRTManager... I think it should be easy to cutover to ThingyManager after that!&lt;/p&gt;</comment>
                    <comment id="13205578" author="simonw" created="Fri, 10 Feb 2012 17:48:52 +0000"  >&lt;p&gt;I like this improvement while there is a serious problem with the current patch. &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; G current;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt; 

&lt;p&gt;should either be volatile otherwise threads could spin unnecessarily long since tryInc will fail until the reference is re-read from main memory. I wonder if we should maybe make this a AtomicReference and remove the sync entirely. I don&apos;t like that this is actually syncing on &quot;this&quot; just for the swap purpose. Either we go for an AtomicRef or introduce a protected lock object. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Can&apos;t think of any other candidates.... naming is the hardest part &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;what about RefCountedResourceManager? Kind of long but hits the purpose...&lt;/p&gt;

</comment>
                    <comment id="13205603" author="mikemccand" created="Fri, 10 Feb 2012 18:25:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;I don&apos;t like that this is actually syncing on &quot;this&quot; just for the swap purpose. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, I would prefer sticking with simple synchronized methods here... swapSearcher is called once during reopen, and by definition called from a single thread, so it will be uncontended.  The added cost is surely minor, while keeping the code simple.&lt;/p&gt;</comment>
                    <comment id="13205632" author="simonw" created="Fri, 10 Feb 2012 18:53:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;Hmm, I would prefer sticking with simple synchronized methods here... swapSearcher is called once during reopen, and by definition called from a single thread, so it will be uncontended. The added cost is surely minor, while keeping the code simple.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I didn&apos;t raise this due to perf reasons. I think using AtomicRef make is simpler since it encapsulates everything rather than using synchronized + volatile &lt;br/&gt;
we&apos;d replace this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; G oldThingy = current;
current = newThingy;
release(oldThingy);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
release(atomicRef.getAndSet(newThingy));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;seems simpler to me though... for read access you simply call atomicRef.get() &lt;/p&gt;</comment>
                    <comment id="13205753" author="mikemccand" created="Fri, 10 Feb 2012 21:03:20 +0000"  >&lt;p&gt;Hmm, but how to protect swapThingy in one thread while close() is called in another?&lt;/p&gt;</comment>
                    <comment id="13206022" author="shaie" created="Sat, 11 Feb 2012 05:15:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;should either be volatile otherwise threads could spin unnecessarily long since tryInc will fail until the reference is re-read from main memory.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think that we need to make &apos;current&apos; volatile. It&apos;s only changed from swapSearcher which is synchronized, and therefore as soon as it changes, all shared copies of that instance (in all threads) gets updated.&lt;/p&gt;

&lt;p&gt;There are many web pages that discuss volatile vs. synchronized (just Google those 3 words) and this page (&lt;a href=&quot;http://www.javamex.com/tutorials/synchronization_volatile.shtml&quot; class=&quot;external-link&quot;&gt;http://www.javamex.com/tutorials/synchronization_volatile.shtml&lt;/a&gt;) even suggests that volatile is more expensive, because synchronization happens on each access to the variable, while in synchronized it&apos;s only inside the synced block.&lt;/p&gt;

&lt;p&gt;We check &apos;current&apos; in ensureOpen() which happens on every API call, and I think that volatile would therefore be more expensive. Also, I&apos;m not sure that using AtomicRef would be simpler code. And following Mike&apos;s comments, I prefer to have an explicit synced swapSearcher.&lt;/p&gt;</comment>
                    <comment id="13206061" author="simonw" created="Sat, 11 Feb 2012 09:11:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;Hmm, but how to protect swapThingy in one thread while close() is called in another?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;well essentially its the same just a while() with a CAS... I will take a stab at this soon. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t think that we need to make &apos;current&apos; volatile. It&apos;s only changed from swapSearcher which is synchronized, and therefore as soon as it changes, all shared copies of that instance (in all threads) gets updated.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Shai, this is a common misconception lemme give you an example:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class Deadlocker {
 &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; ready;

 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void startThread() {
     &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;() {
         &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
             &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;T2: Waiting two seconds.&quot;&lt;/span&gt;);
             &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; { sleep(2000); } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) { /* ignore */ }
             &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;T2: Setting ready = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt;);
             setReady();
         }
     }.start();
 }

 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; void setReady() {
   ready = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
 }

 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; [] args) {
     startThread();
     &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;T1: spinning.&quot;&lt;/span&gt;);
     &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!ready) {
         &lt;span class=&quot;code-comment&quot;&gt;// Do nothing.
&lt;/span&gt;     }
     &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;T1: Ready!&quot;&lt;/span&gt;);
 }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;if you run this on a 64 bit server vm this program will deadlock while on a 32bit client vm it won&apos;t. Now make &quot;ready&quot; volatile and you are good to go, you can even remove the sync entirely. I leave the rest to you to figure out why this happens... In general you&lt;br/&gt;
need to use special mechanisms to guarantee that communication happens between these threads, as you would on a message passing system. Memory writes that happen in one thread can &quot;leak through&quot; and be seen by another thread, but this is by no means guaranteed. Without explicit communication, you can&apos;t guarantee which writes get seen by other threads, or even the order in which they get seen and this communication must be on both sides, reader and writer!&lt;/p&gt;</comment>
                    <comment id="13206141" author="mikemccand" created="Sat, 11 Feb 2012 14:55:05 +0000"  >&lt;blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;Hmm, but how to protect swapThingy in one thread while close() is called in another?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;well essentially its the same just a while() with a CAS... I will take a stab at this soon.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s exactly the kind of added code complexity I don&apos;t like.  I can&lt;br/&gt;
understand it if this were some hotspot... but that&apos;s not the case&lt;br/&gt;
here.&lt;/p&gt;

&lt;p&gt;I think we should stick w/ simple synchronized methods.&lt;/p&gt;

&lt;p&gt;I agree we need the volatile...&lt;/p&gt;</comment>
                    <comment id="13206159" author="dweiss" created="Sat, 11 Feb 2012 16:11:21 +0000"  >&lt;p&gt;Bq. if you run this on a 64 bit server vm this program will deadlock while on a 32bit client vm it won&apos;t.&lt;/p&gt;

&lt;p&gt;Simon didn&apos;t mention that is the behavior under HotSpot, the result of running that code under other VMs and hardware architectures is in general unpredictable.&lt;/p&gt;

&lt;p&gt;The above behavior on HotSpot is in fact not a result of memory visibility problems (but it could be!) but of how the code is seen by HotSpot jit optimizers. If the code is compiled by c1 compiler (default on 32-bit jvms in -client mode) everything works (or tends to &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; because the loop: while (!ready) {} always accesses physical memory. Once the code is on-stack-replaced with the c2 compiler (default second-tier optimizer for optimizer -server, it also explains why you need a delay in T2), c2&apos;s optimizer sees while (!ready) {} as a constant (because ready is not volatile and there are no happens-before with anything else) and promotes it outside the loop. The machine code becomes something like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!ready) {
  &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {/* spin */}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can dump the assembly with debug versions of HotSpot and verify if I&apos;m right. Another cool way of seing such opotimizations in reality is to use gcj -O3 and compile to assembly instead of an object file. &lt;/p&gt;

&lt;p&gt;(Sorry for being so verbose, this used to be part of a Java course I taught while in academia; I&apos;d seen wide eyes on folks that had been writing Java code for a good few years).&lt;/p&gt;</comment>
                    <comment id="13206264" author="simonw" created="Sat, 11 Feb 2012 20:58:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think we should stick w/ simple synchronized methods.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I am good with this, not a big deal&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I agree we need the volatile...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;yeah absolutely&lt;/p&gt;</comment>
                    <comment id="13206909" author="shaie" created="Mon, 13 Feb 2012 14:48:26 +0000"  >&lt;p&gt;Thanks for the education guys. Simon&apos;s example clarified my confusion &amp;#8211; if all access to a variable are synchronized, it doesn&apos;t need to be volatile. However in ThingyManager, only setting the variable is synced, but reading it isn&apos;t. That&apos;s why it needs to be volatile. And swapThingy needs to be synced for concurrency issues (close in parallel to maybeRefresh).&lt;/p&gt;

&lt;p&gt;I will declare it volatile. Will upload a patch soon.&lt;/p&gt;

&lt;p&gt;BTW, I&apos;d like to rename maybeRefresh to refresh() because this method doesn&apos;t return an instance or anything, and to me it&apos;s just like calling refresh on say a web page - nothing guarantees that it will change. The method returns true/false depending on whether refresh was done. Are there any objections?&lt;/p&gt;</comment>
                    <comment id="13206960" author="shaie" created="Mon, 13 Feb 2012 16:17:12 +0000"  >&lt;p&gt;Updated patch:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;ThingyManager renamed to ReferenceManager&lt;/li&gt;
	&lt;li&gt;Declared &apos;current&apos; volatile (thanks Simon!)&lt;/li&gt;
	&lt;li&gt;Added two tests to TestSM. While they could be under a TestReferenceManager new class, I didn&apos;t think that creating another class + a ReferenceManager extension is worth it.&lt;/li&gt;
	&lt;li&gt;Added a CHANGES entry under back-compat (following maybeReopen to maybeRefresh).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If nobody objects, I&apos;d like to rename maybeRefresh to just refresh, and commit it. Otherwise, I&apos;ll commit what I have.&lt;/p&gt;

&lt;p&gt;I&apos;ve decided to deal with the SearcherTaxoManager in a different issue.&lt;/p&gt;</comment>
                    <comment id="13206965" author="rcmuir" created="Mon, 13 Feb 2012 16:21:48 +0000"  >&lt;p&gt;For 3.x, is it possible to have maybeReopen still (final+deprecated, calls maybeRefresh) ?&lt;/p&gt;

&lt;p&gt;This would prevent a back compat break&lt;/p&gt;</comment>
                    <comment id="13207020" author="simonw" created="Mon, 13 Feb 2012 18:04:26 +0000"  >&lt;blockquote&gt;&lt;p&gt;For 3.x, is it possible to have maybeReopen still (final+deprecated, calls maybeRefresh) ?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If nobody objects, I&apos;d like to rename maybeRefresh to just refresh, and commit it. Otherwise, I&apos;ll commit what I have.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should reflect the &quot;try&quot; / &quot;maybe&quot; in the name since this operation is non-blocking. I designed this to work nicely with an async system where multiple refresh ops can come in concurrently. this method shouldn&apos;t block if we are already refreshing. That said I think we should either use maybe or try as a prefix for the method name.&lt;/p&gt;
</comment>
                    <comment id="13207041" author="mikemccand" created="Mon, 13 Feb 2012 18:28:50 +0000"  >&lt;p&gt;Patch looks great Shai!&lt;/p&gt;</comment>
                    <comment id="13207780" author="shaie" created="Tue, 14 Feb 2012 15:37:13 +0000"  >&lt;p&gt;Thanks all for your comments. Robert, I added back maybeReopen to SearcherManager as deprecated.&lt;/p&gt;

&lt;p&gt;Committed rev 1243906 (3x).&lt;br/&gt;
Ported to trunk 1244000 (trunk).&lt;/p&gt;

&lt;p&gt;I will open a separate issue for SearcherTaxoManager&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12514369" name="LUCENE-3761.patch" size="18615" author="shaie" created="Mon, 13 Feb 2012 16:17:12 +0000" />
                    <attachment id="12513924" name="LUCENE-3761.patch" size="19151" author="shaie" created="Thu, 9 Feb 2012 08:06:53 +0000" />
                    <attachment id="12513837" name="LUCENE-3761.patch" size="8827" author="shaie" created="Wed, 8 Feb 2012 16:55:07 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 8 Feb 2012 17:14:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>227119</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>23938</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>