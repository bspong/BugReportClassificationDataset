<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:16:51 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3054/LUCENE-3054.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3054] SorterTemplate.quickSort stack overflows on broken comparators that produce only few disticnt values in large arrays</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3054</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Looking at Otis&apos;s sort problem on the mailing list, he said:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;* looked for other places where this call is made - found it in
MultiPhraseQuery$MultiPhraseWeight and changed that call from
ArrayUtil.quickSort to ArrayUtil.mergeSort
* now we no longer see SorterTemplate.quickSort in deep recursion when we do a
thread dump
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I thought this was interesting because PostingsAndFreq&apos;s comparator&lt;br/&gt;
looks like it needs a tiebreaker.&lt;/p&gt;

&lt;p&gt;I think in our sorts we should add some asserts to try to catch some of these broken comparators.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12505810">LUCENE-3054</key>
            <summary>SorterTemplate.quickSort stack overflows on broken comparators that produce only few disticnt values in large arrays</summary>
                <type id="3" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/task.png">Task</type>
                                <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="thetaphi">Uwe Schindler</assignee>
                                <reporter username="rcmuir">Robert Muir</reporter>
                        <labels>
                    </labels>
                <created>Fri, 29 Apr 2011 18:45:20 +0100</created>
                <updated>Fri, 3 Jun 2011 17:37:14 +0100</updated>
                    <resolved>Tue, 3 May 2011 14:19:20 +0100</resolved>
                            <version>3.1</version>
                                <fixVersion>3.1.1</fixVersion>
                <fixVersion>3.2</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="13027099" author="rcmuir" created="Fri, 29 Apr 2011 18:46:41 +0100"  >&lt;p&gt;really ugly prototype... i expect the generics/sort policeman will want to jump in here anyway &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;but it does catch that problem:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    [junit] Testsuite: org.apache.lucene.index.TestCodecs
    [junit] Testcase: testSepPositionAfterMerge(org.apache.lucene.index.TestCodecs):    FAILED
    [junit] insane comparator for: org.apache.lucene.search.PhraseQuery$PostingsAndFreq
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                    <comment id="13027119" author="otis" created="Fri, 29 Apr 2011 19:29:37 +0100"  >&lt;p&gt;Btw. this is with Lucene 3.1&lt;br/&gt;
For full thread: &lt;a href=&quot;http://search-lucene.com/m/ytANA59Q9G1&quot; class=&quot;external-link&quot;&gt;http://search-lucene.com/m/ytANA59Q9G1&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13027123" author="rcmuir" created="Fri, 29 Apr 2011 19:32:05 +0100"  >&lt;p&gt;i expanded the patch to all the sorts, just to find all the wierd sorting/comparators going on.&lt;/p&gt;

&lt;p&gt;it also finds some false positives, ones that are documented as inconsistent with equals, ones in tests, etc.&lt;/p&gt;

&lt;p&gt;but we can at least look into the ones it finds.&lt;/p&gt;</comment>
                    <comment id="13027639" author="thetaphi" created="Mon, 2 May 2011 14:02:26 +0100"  >&lt;p&gt;I investigated what happens here:&lt;/p&gt;

&lt;p&gt;The problem is indeed quickSort, but not undernormal circumstances. The problem with quickSort (just google for stack overflow and quicksort) is that it only works fine for arrays with many values. Once you only have few distinct values and a large array, depending on the oreder it may happen that it splits into two subarrays for next iteration, where one is very large and the other only contains few items.&lt;/p&gt;

&lt;p&gt;Attached is a patch, that shows the problem. It almost every time stack overflows. Also quicksort is very &lt;b&gt;slow&lt;/b&gt; for this case.&lt;/p&gt;

&lt;p&gt;This is exactly what happens on PhraseQuery: we only have very few distinct items and possibly a very huge array. To fix this, we should change PhraseQuery to use mergeSort instead. Mergesort is also much faster in this case, as it always splits the array in the center. So the number of iterations is limited.&lt;/p&gt;

&lt;p&gt;For TermsHash/BytesRefHash its mostly also not a problem, as the values (the terms are 100% distict, as only the hash is sorted).&lt;/p&gt;

&lt;p&gt;But there may still be the slight chance this messes up. I propose to change SorterTemplate to fall back to mergeSort once it checks that number of iterations grows e.g. &amp;gt; 20 (have to test a little bit).&lt;/p&gt;

&lt;p&gt;I will change that issue to higher priority and we also need to backport to 3.1.&lt;/p&gt;</comment>
                    <comment id="13027640" author="rcmuir" created="Mon, 2 May 2011 14:07:54 +0100"  >&lt;blockquote&gt;
&lt;p&gt;I propose to change SorterTemplate to fall back to mergeSort once it checks that number of iterations grows e.g. &amp;gt; 20 (have to test a little bit).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I like the idea of some &quot;guard&quot; here to prevent the stack overflow, and hopefully keep the quickSort performance for the places where we know its better than mergesort.&lt;/p&gt;</comment>
                    <comment id="13027641" author="thetaphi" created="Mon, 2 May 2011 14:09:16 +0100"  >&lt;p&gt;Patch that shows the issue.&lt;/p&gt;</comment>
                    <comment id="13027643" author="thetaphi" created="Mon, 2 May 2011 14:18:22 +0100"  >&lt;p&gt;As quicksort gets insanely slow when these type of data gets sorted, this also explains Otis&apos; slowdown.&lt;/p&gt;</comment>
                    <comment id="13027662" author="thetaphi" created="Mon, 2 May 2011 14:58:06 +0100"  >&lt;p&gt;Due to the realtime merge (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3023&quot; title=&quot;Land DWPT on trunk&quot;&gt;&lt;del&gt;LUCENE-3023&lt;/del&gt;&lt;/a&gt;), suddenly DocFieldProcessor got a reincarnation of quicksort again... will remove, too&lt;/p&gt;</comment>
                    <comment id="13027677" author="thetaphi" created="Mon, 2 May 2011 15:44:32 +0100"  >&lt;p&gt;Here the patch that combines Robert&apos;s optimization for PhraseQuery (term with lower docFreq will also have less positions) and the safety for quickSort at all.&lt;/p&gt;</comment>
                    <comment id="13027678" author="thetaphi" created="Mon, 2 May 2011 15:46:05 +0100"  >&lt;p&gt;Set fix versions (also backport to 3.1.1, as its serious for some large PhraseQueries and a serious slowdown then).&lt;/p&gt;</comment>
                    <comment id="13027679" author="thetaphi" created="Mon, 2 May 2011 15:51:57 +0100"  >&lt;p&gt;Sorry, the safety net is only needed at 40 (from my tests), before it may affect BytesRefHash performance.&lt;/p&gt;

&lt;p&gt;I will commit later!&lt;/p&gt;</comment>
                    <comment id="13027684" author="thetaphi" created="Mon, 2 May 2011 16:04:55 +0100"  >&lt;p&gt;Better test that fails faster in case of quickSort bug&lt;/p&gt;</comment>
                    <comment id="13027699" author="thetaphi" created="Mon, 2 May 2011 16:46:10 +0100"  >&lt;p&gt;Final patch.&lt;/p&gt;

&lt;p&gt;After some discussion with robert: The use of QuickSort is fine after the comparator was fixed to not only sort by docFreq.&lt;/p&gt;</comment>
                    <comment id="13027702" author="thetaphi" created="Mon, 2 May 2011 16:50:06 +0100"  >&lt;p&gt;Committed trunk revision: 1098633&lt;/p&gt;

&lt;p&gt;Now merging...&lt;/p&gt;</comment>
                    <comment id="13027707" author="thetaphi" created="Mon, 2 May 2011 17:11:42 +0100"  >&lt;p&gt;Merged 3.x revision: 1098639&lt;br/&gt;
Merged 3.1 revision: 1098641&lt;/p&gt;</comment>
                    <comment id="13027722" author="mikemccand" created="Mon, 2 May 2011 17:51:49 +0100"  >&lt;p&gt;Reopening so we can discuss things further...:&lt;/p&gt;

&lt;p&gt;QuickSort is dangerous!  Yet, it&apos;s definitely faster than MergeSort&lt;br/&gt;
for some cases (~20% faster when sorting terms for writing segment, in&lt;br/&gt;
quick test I ran on Wikipedia content).&lt;/p&gt;

&lt;p&gt;So the core issue is we should not use QS when there&apos;s a risk of any&lt;br/&gt;
ties, because in that case it can run really slowly or hit infinite&lt;br/&gt;
recursion.&lt;/p&gt;

&lt;p&gt;And we (well, Otis; thank you!) found one such place today (where&lt;br/&gt;
MultiPhraseQuery sorts its terms) where we could have many ties and&lt;br/&gt;
thus run very slowly / hit stack overflow.&lt;/p&gt;

&lt;p&gt;I appreciate the motivation for the &quot;safety net&quot;, but, it makes me&lt;br/&gt;
nervous... because, say we had done this a few months back... then&lt;br/&gt;
Otis likely would not have reported the issue?  Ie, the&lt;br/&gt;
MultiPhraseQuery would run slowly... which could evade detection&lt;br/&gt;
(people may just think it&apos;s slow).&lt;/p&gt;

&lt;p&gt;I prefer brittle fails over silent slowdowns because the brittle fail&lt;br/&gt;
gets your attention and you get a real fix in.  Silent slowdowns evade&lt;br/&gt;
detection.  Sort of like the difference between a virus and&lt;br/&gt;
spyware...&lt;/p&gt;

&lt;p&gt;Also, what&apos;s preventing us from accidentally using QS somewhere in the&lt;br/&gt;
future, where we shouldn&apos;t?  What&apos;s going to catch us?&lt;/p&gt;

&lt;p&gt;Robert&apos;s first patch would catch this and protect us going forward?&lt;/p&gt;

&lt;p&gt;Or, maybe we could strengthen that approach and &quot;assert cmp != 0&quot;&lt;br/&gt;
inside QS (ie, no ties are allowed to be passed to QS)?&lt;/p&gt;

&lt;p&gt;Though, using asserts only is risky, because it could be the&lt;br/&gt;
comparator may return 0, but it&apos;s just that none of our test cases&lt;br/&gt;
tickled it.&lt;/p&gt;

&lt;p&gt;Maybe instead we could do this in a type-safe way: make a new&lt;br/&gt;
NoTiesComparator whose compare method can only return LESS_THAN or&lt;br/&gt;
GREATER_THAN?  And then QS would require NoTiesComparator.  Could that&lt;br/&gt;
work?&lt;/p&gt;</comment>
                    <comment id="13027730" author="mikemccand" created="Mon, 2 May 2011 18:21:12 +0100"  >&lt;p&gt;Also, I think PQ.PostingsAndFreq.compare is still able to return ties, if the app puts the same term at the same position (which is a silly thing to do... but, still possible).&lt;/p&gt;

&lt;p&gt;I think instead of disambiguating by Term, we should disambiguate by ord (ie, position of this term in the array of the query itself), since that can never be the same for entries in the array?&lt;/p&gt;</comment>
                    <comment id="13027772" author="dweiss" created="Mon, 2 May 2011 19:58:43 +0100"  >&lt;p&gt;I&apos;m sure many of you know this, but there is a new implementation of mergesort in java.util.Collections &amp;#8211; it is based on a few clever heuristics (so it is a merge sort, only a finely tuned one) and has been ported/ partially inspired by the sort in Python as far as I recall.&lt;/p&gt;

&lt;p&gt;Maybe it&apos;d be sensible to compare against this and see what happens. I know Lucene/Solr would rather have its own implementation so that it doesn&apos;t rely on the standard library, but in my benchmarks the implementation in Collections.sort() was hard to beat...&lt;/p&gt;</comment>
                    <comment id="13027774" author="thetaphi" created="Mon, 2 May 2011 20:06:39 +0100"  >&lt;p&gt;Dawid:&lt;br/&gt;
There are two problems we have seen with native sort:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it copies the array/collection always first, this caused slowdown for lots of places especiall in automaton - so it never sorts in plcace&lt;/li&gt;
	&lt;li&gt;we sometimes need to sort multiple arrays in parallel, one as sort &quot;key&quot; -&amp;gt; especially in TermsHash/BytesRefHash. This is where SorterTemplate comes into the game: it supports separate swap(i,j) and compare(i,j) operations.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Uwe&lt;/p&gt;</comment>
                    <comment id="13027780" author="dweiss" created="Mon, 2 May 2011 20:12:45 +0100"  >&lt;p&gt;Thanks Uwe, I didn&apos;t know about it. Still, the algorithm folks developing OpenJDK have implemented is public, so an improvement can be filed &amp;#8211; maybe somebody will find the time to implement it in a version suitable for Lucene.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Timsort&quot; class=&quot;external-link&quot;&gt;http://en.wikipedia.org/wiki/Timsort&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13027808" author="mikemccand" created="Mon, 2 May 2011 21:00:22 +0100"  >&lt;p&gt;So, there are two known improvements to our QS, to try to avoid the O(N^2)&lt;br/&gt;
worst-case, both from Robert Sedgewick.&lt;/p&gt;

&lt;p&gt;First, it&apos;s better to select median of low/mid/high as the pivot&lt;br/&gt;
(&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort#Choice_of_pivot&quot; class=&quot;external-link&quot;&gt;http://en.wikipedia.org/wiki/Quicksort#Choice_of_pivot&lt;/a&gt;).  Second, we&lt;br/&gt;
should handle &quot;equal&quot; values better&lt;br/&gt;
(&lt;a href=&quot;http://www.angelfire.com/pq/jamesbarbetti/articles/sorting/001_QuicksortIsBroken.htm#Duplicates&quot; class=&quot;external-link&quot;&gt;http://www.angelfire.com/pq/jamesbarbetti/articles/sorting/001_QuicksortIsBroken.htm#Duplicates&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;See also Lucy&apos;s nice QS impl:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://svn.apache.org/viewvc/incubator/lucy/trunk/core/Lucy/Util/SortUtils.c?revision=1098445&amp;amp;view=markup#l331&quot; class=&quot;external-link&quot;&gt;http://svn.apache.org/viewvc/incubator/lucy/trunk/core/Lucy/Util/SortUtils.c?revision=1098445&amp;amp;view=markup#l331&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;which I think addresses the above two issues, and goes even further&lt;br/&gt;
(eq-to-pivot values are explicitly &quot;moved to the middle&quot; and then not&lt;br/&gt;
recursed on).&lt;/p&gt;

&lt;p&gt;The thing is, fixing these will make our QS more &quot;general&quot;, at the&lt;br/&gt;
expense of some added cost for the cases we know work fine today (eg&lt;br/&gt;
sorting terms before flushing a segment).&lt;/p&gt;

&lt;p&gt;Maybe we leave our QS as is (except, changing the 40 to be dynamic&lt;br/&gt;
depending on input length), noting that you should not use it if your&lt;br/&gt;
comparator does not break ties, and even if it does there are still&lt;br/&gt;
risks because of potentially bad pivot selection?&lt;/p&gt;

&lt;p&gt;Or, maybe we remove QS always use MS?  Yes, there&apos;s a hit to the sort&lt;br/&gt;
when flushing the segment, but this is a tiny cost compared to the&lt;br/&gt;
rest of segment flushing...&lt;/p&gt;

&lt;p&gt;Separately we can look into whether the tool timsort is faster for&lt;br/&gt;
sorting terms for flush....&lt;/p&gt;</comment>
                    <comment id="13027892" author="thetaphi" created="Mon, 2 May 2011 23:44:38 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Maybe we leave our QS as is (except, changing the 40 to be dynamic&lt;br/&gt;
depending on input length), noting that you should not use it if your&lt;br/&gt;
comparator does not break ties, and even if it does there are still&lt;br/&gt;
risks because of potentially bad pivot selection?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That looks like this: &lt;a href=&quot;http://en.wikipedia.org/wiki/Introsort&quot; class=&quot;external-link&quot;&gt;http://en.wikipedia.org/wiki/Introsort&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We only need a good recursion depth where to switch!&lt;/p&gt;</comment>
                    <comment id="13027918" author="thetaphi" created="Tue, 3 May 2011 00:25:32 +0100"  >&lt;p&gt;Here a patch which implements what introsort does: if the depth of recursion is &amp;gt;75% of log2&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;, switch to mergeSort.&lt;/p&gt;

&lt;p&gt;Also this patch moves all remaining quickSort calls to mergeSort on search side, where the comparators are not good. A few remaining ones in indexer keep alive, but those are all unique sets of terms or field names (needs some more review tomorrow).&lt;/p&gt;

&lt;p&gt;Mike: What do you think, maybe you can do some benchmarking?&lt;/p&gt;</comment>
                    <comment id="13027948" author="thetaphi" created="Tue, 3 May 2011 01:18:16 +0100"  >&lt;p&gt;Studying the C++ STL code showed that they use 2 * log2&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_down.gif&quot; height=&quot;19&quot; width=&quot;19&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; as depth limit. I implemented that. It showed that for the most cases in Lucene (BytesRefHash), it uses quicksort (so no change to performance). The other cases use already mergeSort and the &quot;bad&quot; test in TestArrayUtil switches sucessfully to mergeSort.&lt;/p&gt;</comment>
                    <comment id="13028125" author="mikemccand" created="Tue, 3 May 2011 10:34:31 +0100"  >&lt;p&gt;Patch looks good!  I like the 2*log_2(N) dynamic cutover; this means we can tolerate somewhat lopsided QS recursion and remain using QS.&lt;/p&gt;</comment>
                    <comment id="13028212" author="thetaphi" created="Tue, 3 May 2011 14:19:20 +0100"  >&lt;p&gt;Committed trunk revision: 1099041&lt;br/&gt;
Merged 3.x revision: 1099045&lt;br/&gt;
Merged 3.1 revision: 1099046&lt;/p&gt;</comment>
                    <comment id="13043485" author="rcmuir" created="Fri, 3 Jun 2011 17:37:14 +0100"  >&lt;p&gt;Bulk closing for 3.2&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12478006" name="LUCENE-3054-dynamic.patch" size="6372" author="thetaphi" created="Tue, 3 May 2011 01:14:56 +0100" />
                    <attachment id="12477967" name="LUCENE-3054.patch" size="6385" author="thetaphi" created="Mon, 2 May 2011 16:46:10 +0100" />
                    <attachment id="12477966" name="LUCENE-3054.patch" size="6023" author="thetaphi" created="Mon, 2 May 2011 16:04:55 +0100" />
                    <attachment id="12477960" name="LUCENE-3054.patch" size="6023" author="thetaphi" created="Mon, 2 May 2011 15:51:57 +0100" />
                    <attachment id="12477959" name="LUCENE-3054.patch" size="6023" author="thetaphi" created="Mon, 2 May 2011 15:44:32 +0100" />
                    <attachment id="12477833" name="LUCENE-3054.patch" size="6586" author="rcmuir" created="Fri, 29 Apr 2011 19:32:05 +0100" />
                    <attachment id="12477819" name="LUCENE-3054.patch" size="2039" author="rcmuir" created="Fri, 29 Apr 2011 18:46:41 +0100" />
                    <attachment id="12477947" name="LUCENE-3054-stackoverflow.patch" size="913" author="thetaphi" created="Mon, 2 May 2011 14:09:16 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>8.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 29 Apr 2011 18:29:37 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2155</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24639</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>