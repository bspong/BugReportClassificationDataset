<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:02:32 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-1126/LUCENE-1126.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-1126] Simplify StandardTokenizer JFlex grammar</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-1126</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Summary of thread entitled &quot;Fullwidth alphanumeric characters, plus a question on Korean ranges&quot; begun by Daniel Noll on java-user, and carried over to java-dev:&lt;/p&gt;

&lt;p&gt;On 01/07/2008 at 5:06 PM, Daniel Noll wrote:&lt;br/&gt;
&amp;gt; I wish the tokeniser could just use Character.isLetter and&lt;br/&gt;
&amp;gt; Character.isDigit instead of having to know all the ranges itself, since&lt;br/&gt;
&amp;gt; the JRE already has all this information.  Character.isLetter does&lt;br/&gt;
&amp;gt; return true for CJK characters though, so the ranges would still come in&lt;br/&gt;
&amp;gt; handy for determining what kind of letter they are.  I don&apos;t support&lt;br/&gt;
&amp;gt; JFlex has a way to do this...&lt;/p&gt;

&lt;p&gt;The DIGIT macro could be replaced by JFlex&apos;s predefined character class &lt;span class=&quot;error&quot;&gt;&amp;#91;:digit:&amp;#93;&lt;/span&gt;, which has the same semantics as java.lang.Character.isDigit().&lt;/p&gt;

&lt;p&gt;Although JFlex&apos;s predefined character class &lt;span class=&quot;error&quot;&gt;&amp;#91;:letter:&amp;#93;&lt;/span&gt; (same semantics as java.lang.Character.isLetter()) includes CJK characters, there is a way to handle this using JFlex&apos;s regex negation syntax &lt;tt&gt;!&lt;/tt&gt;.  From &lt;a href=&quot;http://jflex.de/manual.html&quot; class=&quot;external-link&quot;&gt;the JFlex documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;he expression that matches everything of &lt;tt&gt;a&lt;/tt&gt; not matched by &lt;tt&gt;b&lt;/tt&gt; is !(!&lt;tt&gt;a&lt;/tt&gt;|&lt;tt&gt;b&lt;/tt&gt;) &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So to exclude CJ characters from the LETTER macro:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    LETTER = ! ( ! [:letter:] | {CJ} )
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since &lt;span class=&quot;error&quot;&gt;&amp;#91;:letter:&amp;#93;&lt;/span&gt; includes all of the Korean ranges, there&apos;s no reason (AFAICT) to treat them separately; unlike Chinese and Japanese characters, which are individually tokenized, the Korean characters should participate in the same token boundary rules as all of the other letters.&lt;/p&gt;

&lt;p&gt;I looked at some of the differences between Unicode 3.0.0, which Java 1.4.2 supports, and Unicode 5.0, the latest version, and there are lots of new and modified letter and digit ranges.  This stuff gets tweaked all the time, and I don&apos;t think Lucene should be in the business of trying to track it, or take a position on which Unicode version users&apos; data should conform to.  &lt;/p&gt;

&lt;p&gt;Switching to using JFlex&apos;s &lt;span class=&quot;error&quot;&gt;&amp;#91;:letter:&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;:digit:&amp;#93;&lt;/span&gt; predefined character classes ties (most of) these decisions to the user&apos;s choice of JVM version, and this seems much more reasonable to me than the current status quo.&lt;/p&gt;

&lt;p&gt;I will attach a patch shortly.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12386001">LUCENE-1126</key>
            <summary>Simplify StandardTokenizer JFlex grammar</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="steve_rowe">Steve Rowe</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Jan 2008 20:49:56 +0000</created>
                <updated>Sat, 11 Oct 2008 13:49:34 +0100</updated>
                    <resolved>Thu, 4 Sep 2008 20:49:56 +0100</resolved>
                            <version>2.2</version>
                                <fixVersion>2.4</fixVersion>
                                <component>modules/analysis</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12557854" author="hossman" created="Fri, 11 Jan 2008 00:29:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;Switching to using JFlex&apos;s &lt;span class=&quot;error&quot;&gt;&amp;#91;:letter:&amp;#93;&lt;/span&gt; and &lt;span class=&quot;error&quot;&gt;&amp;#91;:digit:&amp;#93;&lt;/span&gt; predefined character classes ties (most of) these decisions to the user&apos;s choice of JVM version, and this seems much more reasonable to me than the current status quo.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Clarification: I don&apos;t think this would actually tie anything to the &quot;user&apos;s&quot; choice of JVM, wouldn&apos;t it make the behavior of the resulting code depend on the JVM choice of whoever generated StandardTokenizerImpl.java from StandardTokenizerImpl.jflex (not to mention possible discrepancies based on the version of JFLex in use at the time) ?&lt;/p&gt;

&lt;p&gt;I&apos;m not positive, but couldn&apos;t this result in situations where a committer using a 1.5 JVM could generate and commit a StandardTokenizerImpl.java that had would have a different behavior then if he was using 1.4 &amp;#8211; all of which would be completely independent of whether or not the release engineer of the next release compiled the resulting grammer using 1.4?&lt;/p&gt;</comment>
                    <comment id="12557864" author="steve_rowe" created="Fri, 11 Jan 2008 01:01:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;I&apos;m not positive, but couldn&apos;t this result in situations where a committer using a 1.5 JVM could generate and commit a StandardTokenizerImpl.java that had would have a different behavior then if he was using 1.4 - all of which would be completely independent of whether or not the release engineer of the next release compiled the resulting grammer using 1.4?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, you&apos;re right - I was conceiving of the resulting lexer building the tables at runtime, but looking at the code in StandardTokenizerImpl.java, that&apos;s patently false - this, as you point out, is a compile-time operation.&lt;/p&gt;

&lt;p&gt;And when I compile with 1.4.2, the resulting StandardTokenizerImpl.java file is significantly different from the result with 1.5.0.&lt;/p&gt;

&lt;p&gt;I&apos;m quite sure, despite this, that switching to the (compile-time) JVM&apos;s Unicode version&apos;s definitions of letters and digits is a better policy than depending on a non-existent update mechanism for the grammar.&lt;/p&gt;</comment>
                    <comment id="12557868" author="steve_rowe" created="Fri, 11 Jan 2008 01:07:13 +0000"  >&lt;p&gt;Compiled using JFlex 1.4.1, JDK 1.4.2&lt;/p&gt;</comment>
                    <comment id="12557921" author="hossman" created="Fri, 11 Jan 2008 07:22:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;this, as you point out, is a compile-time operation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;again, minor clarification ... if it were &quot;compile-time&quot; it would be *.java -&amp;gt; *.class conversion ... what we&apos;re talking about is ... i dunno ... &quot;jflex-time&quot; or &quot;source-generation-time&quot; ... where the JVM in use during the  *.flex -&amp;gt; *.java conversion affects the behavior of the final code.&lt;/p&gt;

&lt;p&gt;(i&apos;m not saying it&apos;s a bad thing ... i just want to be clear about what happens where)&lt;/p&gt;</comment>
                    <comment id="12557988" author="steve_rowe" created="Fri, 11 Jan 2008 13:47:42 +0000"  >&lt;p&gt;In part my imprecise characterization of the process comes from what is likely a misunderstanding of the Lucene-Java release process - when you said:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m not positive, but couldn&apos;t this result in situations where a committer using a 1.5 JVM could generate and commit a StandardTokenizerImpl.java that had would have a different behavior then if he was using 1.4 - all of which would be completely independent of whether or not the release engineer of the next release compiled the resulting grammer using 1.4?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I assumed you meant that during the release process, the lexical scanner source (.java file) would be regenerated from the grammar (.jflex file).  And in this scenario, I meant to refer to &quot;compile-time&quot; as the entire build process - raw source to jar assembly, &lt;b&gt;including&lt;/b&gt; lexical scanner generation - undertaken when producing a binary release.&lt;/p&gt;

&lt;p&gt;But of course you&apos;re right &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; .  The JVM version being used during source-generation-time (occurring prior to, and potentially not contiguously with, bytecode-generation-time) determines the version of Unicode used to define the meaning of &quot;letter&quot; and &quot;digit&quot;.&lt;/p&gt;</comment>
                    <comment id="12557996" author="gsingers" created="Fri, 11 Jan 2008 14:33:10 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&apos;m not positive, but couldn&apos;t this result in situations where a committer using a 1.5 JVM could generate and commit a StandardTokenizerImpl.java that had would have a different behavior then if he was using 1.4 - all of which would be completely independent of whether or not the release engineer of the next release compiled the resulting grammer using 1.4?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;True, but no committer should ever be doing this, right?  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  At least not until 3.0.  The ANT settings specify 1.4 right?  If it does happen, it is a bug, no?&lt;/p&gt;</comment>
                    <comment id="12558030" author="steve_rowe" created="Fri, 11 Jan 2008 17:14:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;The ANT settings specify 1.4 right? If it does happen, it is a bug, no?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The ANT settings specify that the bytecode compiler should produce 1.4-JVM-compatible byte code (javac.target property), and that the Java source code should be interpreted as complying with a particular version of the Java language specification (javac.source property).&lt;/p&gt;

&lt;p&gt;But the JVM is a different tool from the bytecode compiler, and as Hoss pointed out, it is the JVM under which JFlex runs that makes the difference.&lt;/p&gt;

&lt;p&gt;As I noted above:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And when I compile with 1.4.2, the resulting StandardTokenizerImpl.java file is significantly different from the result with 1.5.0.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;(&lt;tt&gt;s/compile/generate the scanner source/g&lt;/tt&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;</comment>
                    <comment id="12626052" author="mikemccand" created="Wed, 27 Aug 2008 11:19:19 +0100"  >&lt;p&gt;This patch looks reasonable?  We are replacing our own hardwired regexp for DIGIT with JFlex&apos;s :digit: which then falls back to the Character.isDigit() &lt;span class=&quot;error&quot;&gt;&amp;#91;equivalent&amp;#93;&lt;/span&gt; on the JVM that ran jflex.&lt;/p&gt;</comment>
                    <comment id="12626531" author="mikemccand" created="Thu, 28 Aug 2008 12:51:53 +0100"  >&lt;p&gt;I will commit this in a day or two.&lt;/p&gt;</comment>
                    <comment id="12627943" author="mikemccand" created="Wed, 3 Sep 2008 10:27:03 +0100"  >&lt;p&gt;Hmm &amp;#8211; I&apos;m now seeing an failure with this patch, in TestThaiAnalyzer (in contrib/analyzers):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    [junit] Testcase: testAnalyzer(org.apache.lucene.analysis.th.TestThaiAnalyzer):	FAILED
    [junit] expected:&amp;lt;?[]&amp;gt; but was:&amp;lt;?[??]&amp;gt;
    [junit] junit.framework.ComparisonFailure: expected:&amp;lt;?[]&amp;gt; but was:&amp;lt;?[??]&amp;gt;
    [junit] 	at org.apache.lucene.analysis.th.TestThaiAnalyzer.assertAnalyzesTo(TestThaiAnalyzer.java:43)
    [junit] 	at org.apache.lucene.analysis.th.TestThaiAnalyzer.testAnalyzer(TestThaiAnalyzer.java:54)
    [junit] 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does anyone else see this?&lt;/p&gt;</comment>
                    <comment id="12628106" author="steve_rowe" created="Wed, 3 Sep 2008 20:33:11 +0100"  >&lt;p&gt;Yeah, I see this too.&lt;/p&gt;

&lt;p&gt;The issue is that the entire Thai range &lt;tt&gt;\u0e00-\u0e5b&lt;/tt&gt; is included in the unpatched grammar&apos;s &lt;/p&gt;
{LETTER}
&lt;p&gt; definition, which contains the huge range &lt;tt&gt;\u0100-\u1fff&lt;/tt&gt;, much of which is not actually letters.  The patched grammar instead substitutes the Unicode 3.0 &lt;tt&gt;Letter&lt;/tt&gt; general category (via JFlex&apos;s &lt;span class=&quot;error&quot;&gt;&amp;#91;:letter:&amp;#93;&lt;/span&gt;), which excludes some characters in the Thai range: non-spacing marks, a currency symbol, numerals, etc.&lt;/p&gt;

&lt;p&gt;ThaiAnalyzer uses ThaiWordFilter, which uses Java&apos;s BreakIterator to tokenize the contiguous text (i.e. without whitespace) provided by StandardTokenizer.&lt;/p&gt;

&lt;p&gt;The failing test expects to see &lt;tt&gt;&quot;\u0e17\u0e35\u0e48&quot;&lt;/tt&gt;, but instead gets &lt;tt&gt;&quot;\u0e17&quot;&lt;/tt&gt;, because &lt;tt&gt;\u0e35&lt;/tt&gt; is a non-spacing mark, which the patched StandardTokenizer doesn&apos;t pass to ThaiWordFilter.&lt;/p&gt;

&lt;p&gt;Because of this problem, I guess I&apos;m -1 on applying the patch I provided.&lt;/p&gt;

&lt;p&gt;One solution would be to switch from using the &lt;tt&gt;Letter&lt;/tt&gt; general category to the derived property &lt;tt&gt;Alphabetic&lt;/tt&gt;, which includes both general categories &lt;tt&gt;Letter&lt;/tt&gt; and &lt;tt&gt;Mark&lt;/tt&gt;. (see Annex C of &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr18/#Compatibility_Properties&quot; class=&quot;external-link&quot;&gt;the Unicode Regular Expressions Technical Standard&lt;/a&gt; under &quot;alpha&quot; for discussion of this).  The current version of JFlex does not support Unicode property references in its syntax, though, so simplifying &amp;#8211; and correcting &amp;#8211; the grammar may have to wait for the next version of JFlex, which will support syntax like {{\p&lt;/p&gt;
{Alphabetic}
&lt;p&gt;}}.&lt;/p&gt;</comment>
                    <comment id="12628308" author="mikemccand" created="Thu, 4 Sep 2008 12:12:26 +0100"  >&lt;blockquote&gt;
&lt;p&gt;One solution would be to switch from using the Letter general category to the derived property Alphabetic, which includes both general categories Letter and Mark. (see Annex C of the Unicode Regular Expressions Technical Standard under &quot;alpha&quot; for discussion of this). The current version of JFlex does not support Unicode property references in its syntax, though, so simplifying - and correcting - the grammar may have to wait for the next version of JFlex, which will support syntax like \p&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {Alphabetic}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Could we, alternatively, modify the patch to explicitly add back in the full Thai range into ALPHANUM, and then upgrade to \p&lt;/p&gt;
{Alphabetic}
&lt;p&gt; once the next version of JFlex is released?&lt;/p&gt;

&lt;p&gt;Or are there other languages, besides Thai, that we might break with this patch?&lt;/p&gt;</comment>
                    <comment id="12628368" author="steve_rowe" created="Thu, 4 Sep 2008 17:12:58 +0100"  >&lt;blockquote&gt;
&lt;p&gt;Could we, alternatively, modify the patch to explicitly add back in the full Thai range into ALPHANUM, and then upgrade to \p&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {Alphabetic}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; once the next version of JFlex is released?&lt;/p&gt;

&lt;p&gt;Or are there other languages, besides Thai, that we might break with this patch?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I noticed in looking at the Unicode database that Lao, which is contiguous with Thai and contained in the unpatched {{&lt;/p&gt;
{LETTER}
&lt;p&gt;}} range, has exactly the same issue as Thai.  However, the Lucene code base doesn&apos;t contain a Lao Analyzer.  And I think ThaiAnalyzer is depending on faulty behavior from StandardTokenizer, so &quot;fixing&quot; the issue for other languages would be to make the assumption that they too would depend on bad behavior.&lt;/p&gt;

&lt;p&gt;I&apos;ll shortly provide a redone patch that allows the ThaiAnalyzer to work again, but unless we have evidence of actual use by other language analyzers, I don&apos;t think we should be addressing them right now.&lt;/p&gt;</comment>
                    <comment id="12628387" author="mikemccand" created="Thu, 4 Sep 2008 18:06:29 +0100"  >&lt;blockquote&gt;&lt;p&gt;I&apos;ll shortly provide a redone patch that allows the ThaiAnalyzer to work again, but unless we have evidence of actual use by other language analyzers, I don&apos;t think we should be addressing them right now.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK this sounds like the right approach.&lt;/p&gt;</comment>
                    <comment id="12628392" author="steve_rowe" created="Thu, 4 Sep 2008 18:31:57 +0100"  >&lt;p&gt;Refreshed original patch to include the Thai range &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;\u0e00-\u0e59&amp;#93;&lt;/span&gt;&lt;/tt&gt; in the {{&lt;/p&gt;
{ALPHANUM}
&lt;p&gt;}} definition.&lt;/p&gt;

&lt;p&gt;All tests, including TestThaiAnalyzer, now pass.&lt;/p&gt;</comment>
                    <comment id="12628406" author="mikemccand" created="Thu, 4 Sep 2008 18:54:01 +0100"  >&lt;p&gt;Steven, it looks like you ran JFlex with a 1.5 or 1.6 JRE?  Should we stick with that, or, go with a 1.4 JRE (which is indeed significantly different)?&lt;/p&gt;</comment>
                    <comment id="12628424" author="steve_rowe" created="Thu, 4 Sep 2008 19:31:59 +0100"  >&lt;blockquote&gt;&lt;p&gt;Steven, it looks like you ran JFlex with a 1.5 or 1.6 JRE? Should we stick with that, or, go with a 1.4 JRE (which is indeed significantly different)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;re right, Mike - I was inadvertently using a 1.5 JRE.  I&apos;ll put up another patch produced with 1.4 JRE shortly - we should definitely not go with 1.5..&lt;/p&gt;</comment>
                    <comment id="12628428" author="mikemccand" created="Thu, 4 Sep 2008 19:41:09 +0100"  >&lt;p&gt;Steven, it&apos;s OK I can regen; I just wanted to confirm which JRE (1.4) we should use.&lt;/p&gt;

&lt;p&gt;I&apos;m also going to add a comment at the top of StandardTokenizerImpl.jflex stating this.&lt;/p&gt;</comment>
                    <comment id="12628442" author="mikemccand" created="Thu, 4 Sep 2008 20:49:56 +0100"  >&lt;p&gt;Committed revision 692211.&lt;/p&gt;

&lt;p&gt;Thanks Steven!&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12389517" name="LUCENE-1126.patch" size="15247" author="steve_rowe" created="Thu, 4 Sep 2008 18:31:57 +0100" />
                    <attachment id="12372951" name="LUCENE-1126.patch" size="14739" author="steve_rowe" created="Fri, 11 Jan 2008 01:07:13 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 11 Jan 2008 00:29:48 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12619</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26603</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>