<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:22:56 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-854/LUCENE-854.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-854] Create merge policy that doesn&apos;t periodically inadvertently optimize</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-854</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;The current merge policy, at every maxBufferedDocs *&lt;br/&gt;
power-of-mergeFactor docs added, will do a fully cascaded merge, which&lt;br/&gt;
is the same as an optimize.&lt;/p&gt;

&lt;p&gt;I think this is not good because at that &quot;optimization poin&quot;, the&lt;br/&gt;
particular addDocument call is &lt;span class=&quot;error&quot;&gt;&amp;#91;surprisingly&amp;#93;&lt;/span&gt; very expensive.  While,&lt;br/&gt;
amortized over all addDocument calls, the cost is low, the cost is&lt;br/&gt;
paid &quot;up front&quot; and in a very &quot;bunched up&quot; manner.&lt;/p&gt;

&lt;p&gt;I think of this as &quot;pay it forward&quot;: you are paying the full cost of&lt;br/&gt;
an optimize right now on the expectation / hope that you will be&lt;br/&gt;
adding a great many more docs.  But, if you don&apos;t add that many more&lt;br/&gt;
docs, then, the amortized cost for your index is in fact far higher&lt;br/&gt;
than it should have been.  Better to &quot;pay as you go&quot; instead.&lt;/p&gt;

&lt;p&gt;So we could make a small change to the policy by only merging the&lt;br/&gt;
first mergeFactor segments once we hit 2X the merge factor.  With&lt;br/&gt;
mergeFactor=10, when we have created the 20th level 0 (just flushed)&lt;br/&gt;
segment, we merge the first 10 into a level 1 segment.  Then on&lt;br/&gt;
creating another 10 level 0 segments, we merge the second set of 10&lt;br/&gt;
level 0 segments into a level 1 segment, etc.&lt;/p&gt;

&lt;p&gt;With this new merge policy, an index that&apos;s a bit bigger than a&lt;br/&gt;
current &quot;optimization point&quot; would then have a lower amortized cost&lt;br/&gt;
per document.  Plus the merge cost is less &quot;bunched up&quot; and less &quot;pay&lt;br/&gt;
it forward&quot;: instead you pay for what you are actually using.&lt;/p&gt;

&lt;p&gt;We can start by creating this merge policy (probably, combined with&lt;br/&gt;
with the &quot;by size not by doc count&quot; segment level computation from&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-845&quot; title=&quot;If you &amp;quot;flush by RAM usage&amp;quot; then IndexWriter may over-merge&quot;&gt;&lt;del&gt;LUCENE-845&lt;/del&gt;&lt;/a&gt;) and then later decide whether we should make it the&lt;br/&gt;
default merge policy.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12366277">LUCENE-854</key>
            <summary>Create merge policy that doesn&apos;t periodically inadvertently optimize</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mikemccand">Michael McCandless</assignee>
                                <reporter username="mikemccand">Michael McCandless</reporter>
                        <labels>
                    </labels>
                <created>Sat, 31 Mar 2007 13:14:17 +0100</created>
                <updated>Fri, 3 Jun 2011 17:37:20 +0100</updated>
                    <resolved>Fri, 6 May 2011 00:30:40 +0100</resolved>
                            <version>2.2</version>
                                <fixVersion>3.2</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/index</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>4</watches>
                                                    <comments>
                    <comment id="12993538" author="mikemccand" created="Fri, 11 Feb 2011 15:35:41 +0000"  >&lt;p&gt;I created a new merge policy, to take advantage of non-contiguous merging (&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1076&quot; title=&quot;Allow MergePolicy to select non-contiguous merges&quot;&gt;&lt;del&gt;LUCENE-1076&lt;/del&gt;&lt;/a&gt;) and fix certain limitations of LogMergePolicy.&lt;/p&gt;

&lt;p&gt;The new policy does not support contiguous merging, and always merges according to byte size, always pro rated by pct deletes.&lt;/p&gt;

&lt;p&gt;The policy&apos;s core logic is similar to LogMP, in that it tries to merge roughly equal sized segments at once, maxMergeAtOnce (renamed from mergeFactor) at a time, resulting in the usual exponential staircase pattern when you feed it roughly equal sized segments.&lt;/p&gt;

&lt;p&gt;You configure the approx max merged segment size (unlike LogMP where you configure the max to-be-merged size, which was always a source of confusion!).  Unlike LogMP, when segments are getting close to being too large, the new policy will merge fewer segs, eg down to merging pairwise, to reach approx the max allowed size.  This is important since it makes that setting more &quot;accurate&quot;; I now default it to 5 GB (vs LogMP&apos;s 2 GB).&lt;/p&gt;

&lt;p&gt;There is a separate maxMergeAtOnceExplicit that controls &quot;explicit&quot; merging (ie, app calls optimize or expungeDeletes, and maybe in the future also addIndexes); I defaulted it to 30.  There is no max segment size for optimize.&lt;/p&gt;

&lt;p&gt;The big difference vs LogMP is that the new policy does not &quot;over-merge&quot;, meaning it does not &quot;pay it forward&quot;/forcefully cascade the way LogMP does today.  This fixes the &quot;inadvertent optimize&quot; that LogMP does.&lt;/p&gt;

&lt;p&gt;For any given sized index, the new policy computes a budget of how many segments that index is allowed to have (ie, it enumerates the steps in the stair case, based on mergeAtOnce, &lt;span class=&quot;error&quot;&gt;&amp;#91;floored&amp;#93;&lt;/span&gt; min segment size, and total bytes in the index); then, if the index is over-budget it picks the least-cost merge.  This results in a smoother progression over time of number of segments.&lt;/p&gt;

&lt;p&gt;There is a new configuration, segmentsPerTier, that lets you control how many segments per level you can &quot;tolerate&quot;.  This is a nice knob to turn to tradeoff merge cost vs search cost.  It defaults to 10, which means it matches the staircase pattern that LogMP produces, but you can now separately control the &quot;width&quot; of the stairs in the staircase, from how many segments are merged at once for non-explicit merges.&lt;/p&gt;

&lt;p&gt;It has useCompoundFile and noCFSRatio just like LogMP.&lt;/p&gt;

&lt;p&gt;It has a new setting &quot;expungeDeletesPctAllowed&quot;, default 10%, which allows expungeDeletes to skip merging a segment if it has &amp;lt; 10% deletions.&lt;/p&gt;

&lt;p&gt;I think we should keep LogMergePolicy available for apps that want contiguous merging, merge by doc count, to not pro-rate by deletions, or to enforce a max segment size during optimize.  But, with this, I&apos;d remove the non-contiguous support for LogMergePolicy that was added under &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1076&quot; title=&quot;Allow MergePolicy to select non-contiguous merges&quot;&gt;&lt;del&gt;LUCENE-1076&lt;/del&gt;&lt;/a&gt;, and make this new MP the default one.&lt;/p&gt;</comment>
                    <comment id="12994106" author="mikemccand" created="Sun, 13 Feb 2011 14:38:27 +0000"  >&lt;p&gt;I put up a blog post showing a movie of how TieredMP differs from LogByteSizeMP: &lt;a href=&quot;http://chbits.blogspot.com/2011/02/visualizing-lucenes-segment-merges.html&quot; class=&quot;external-link&quot;&gt;http://chbits.blogspot.com/2011/02/visualizing-lucenes-segment-merges.html&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="12994114" author="thetaphi" created="Sun, 13 Feb 2011 15:59:06 +0000"  >&lt;p&gt;Nice videos, have already seen them on twitter yesterday &lt;b&gt;g&lt;/b&gt;&lt;/p&gt;</comment>
                    <comment id="13043525" author="rcmuir" created="Fri, 3 Jun 2011 17:37:20 +0100"  >&lt;p&gt;Bulk closing for 3.2&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12470862" name="LUCENE-854.patch" size="112452" author="mikemccand" created="Fri, 11 Feb 2011 15:35:41 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 13 Feb 2011 15:59:06 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>12887</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>26875</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>