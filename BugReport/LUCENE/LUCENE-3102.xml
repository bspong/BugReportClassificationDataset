<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:23:17 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3102/LUCENE-3102.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3102] Few issues with CachingCollector</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3102</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;CachingCollector (introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-1421&quot; title=&quot;Ability to group search results by field&quot;&gt;&lt;del&gt;LUCENE-1421&lt;/del&gt;&lt;/a&gt;) has few issues:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Since the wrapped Collector may support out-of-order collection, the document IDs cached may be out-of-order (depends on the Query) and thus replay(Collector) will forward document IDs out-of-order to a Collector that may not support it.&lt;/li&gt;
	&lt;li&gt;It does not clear cachedScores + cachedSegs upon exceeding RAM limits&lt;/li&gt;
	&lt;li&gt;I think that instead of comparing curScores to null, in order to determine if scores are requested, we should have a specific boolean - for clarity&lt;/li&gt;
	&lt;li&gt;This check &quot;if (base + nextLength &amp;gt; maxDocsToCache)&quot; (line 168) can be relaxed? E.g., what if nextLength is, say, 512K, and I cannot satisfy the maxDocsToCache constraint, but if it was 10K I would? Wouldn&apos;t we still want to try and cache them?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Also:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The TODO in line 64 (having Collector specify needsScores()) &amp;#8211; why do we need that if CachingCollector ctor already takes a boolean &quot;cacheScores&quot;? I think it&apos;s better defined explicitly than implicitly?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Let&apos;s introduce a factory method for creating a specialized version if scoring is requested / not (i.e., impl the TODO in line 189)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think it&apos;s a useful collector, which stands on its own and not specific to grouping. Can we move it to core?&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;How about using OpenBitSet instead of int[] for doc IDs?
	&lt;ul&gt;
		&lt;li&gt;If the number of hits is big, we&apos;d gain some RAM back, and be able to cache more entries&lt;/li&gt;
		&lt;li&gt;NOTE: OpenBitSet can only be used for in-order collection only. So we can use that if the wrapped Collector does not support out-of-order&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Do you think we can modify this Collector to not necessarily wrap another Collector? We have such Collector which stores (in-memory) all matching doc IDs + scores (if required). Those are later fed into several processes that operate on them (e.g. fetch more info from the index etc.). I am thinking, we can make CachingCollector &lt;b&gt;optionally&lt;/b&gt; wrap another Collector and then someone can reuse it by setting RAM limit to unlimited (we should have a constant for that) in order to simply collect all matching docs + scores.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;I think a set of dedicated unit tests for this class alone would be good.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That&apos;s it so far. Perhaps, if we do all of the above, more things will pop up.&lt;/p&gt;</description>
                <environment></environment>
            <key id="12507277">LUCENE-3102</key>
            <summary>Few issues with CachingCollector</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="shaie">Shai Erera</assignee>
                                <reporter username="shaie">Shai Erera</reporter>
                        <labels>
                    </labels>
                <created>Sun, 15 May 2011 16:33:57 +0100</created>
                <updated>Fri, 3 Jun 2011 17:37:20 +0100</updated>
                    <resolved>Wed, 18 May 2011 19:52:10 +0100</resolved>
                                            <fixVersion>3.2</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                <component>core/search</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13033784" author="mikemccand" created="Sun, 15 May 2011 17:43:59 +0100"  >&lt;p&gt;Great catches Shai &amp;#8211; thanks for the thorough review!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Since the wrapped Collector may support out-of-order collection, the document IDs cached may be out-of-order (depends on the Query) and thus replay(Collector) will forward document IDs out-of-order to a Collector that may not support it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh... maybe we throw IllegalArgExc if the replay&apos;d collector requires&lt;br/&gt;
in-order but the first pass collector didn&apos;t?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;It does not clear cachedScores + cachedSegs upon exceeding RAM limits&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm, I think it does clear cachedScores?  (But not cachedSegs).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think that instead of comparing curScores to null, in order to determine if scores are requested, we should have a specific boolean - for clarity&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That sounds great!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This check &quot;if (base + nextLength &amp;gt; maxDocsToCache)&quot; (line 168) can be relaxed? E.g., what if nextLength is, say, 512K, and I cannot satisfy the maxDocsToCache constraint, but if it was 10K I would? Wouldn&apos;t we still want to try and cache them?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh you mean for the last &quot;chunk&quot; we could alloc right up to the limit?&lt;br/&gt;
Good!&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The TODO in line 64 (having Collector specify needsScores()) &#8211; why do we need that if CachingCollector ctor already takes a boolean &quot;cacheScores&quot;? I think it&apos;s better defined explicitly than implicitly?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I think we should keep the explicit boolean (cacheScores), but eg&lt;br/&gt;
you could mess up (pass cacheScores = false but then pass a collector&lt;br/&gt;
that calls .score()) &amp;#8211; that&apos;s why I added to TODO.  Ie, it&apos;d be nice&lt;br/&gt;
if we could &quot;verify&quot; that the collector agrees we don&apos;t need scores.&lt;/p&gt;

&lt;p&gt;I think there were other places in Lucene where knowing this up front&lt;br/&gt;
could help us... can&apos;t remember the details.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Let&apos;s introduce a factory method for creating a specialized version if scoring is requested / not (i.e., impl the TODO in line 189)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think it&apos;s a useful collector, which stands on its own and not specific to grouping. Can we move it to core?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How about using OpenBitSet instead of int[] for doc IDs?&lt;br/&gt;
If the number of hits is big, we&apos;d gain some RAM back, and be able to cache more entries&lt;br/&gt;
NOTE: OpenBitSet can only be used for in-order collection only. So we can use that if the wrapped Collector does not support out-of-order&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Hmm but if the number of hits is small we spend un-needed RAM/CPU,&lt;br/&gt;
but, then that tradeoff is maybe OK?  I&apos;m just worried about indices&lt;br/&gt;
w/ lots of docs... we could also &quot;upgrade&quot; to a bit set part way&lt;br/&gt;
through, since it&apos;s so clear where the cutoff is.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Do you think we can modify this Collector to not necessarily wrap another Collector? We have such Collector which stores (in-memory) all matching doc IDs + scores (if required). Those are later fed into several processes that operate on them (e.g. fetch more info from the index etc.). I am thinking, we can make CachingCollector optionally wrap another Collector and then someone can reuse it by setting RAM limit to unlimited (we should have a constant for that) in order to simply collect all matching docs + scores.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d actually rather not have the constant &amp;#8211; ie, I don&apos;t want to make&lt;br/&gt;
it easy to be unlimited?  It seems too dangerous... I&apos;d rather your&lt;br/&gt;
code has to spell out 10*1024 so you realize you&apos;re saying 10 GB (for&lt;br/&gt;
example).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think a set of dedicated unit tests for this class alone would be good.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Awesome feedback!!  Are you planning to work up a patch for these...?&lt;/p&gt;</comment>
                    <comment id="13033787" author="shaie" created="Sun, 15 May 2011 18:06:06 +0100"  >&lt;blockquote&gt;&lt;p&gt;Hmm, I think it does clear cachedScores? (But not cachedSegs).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, I meant curScores.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;+1 (on move to core)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I will start w/ &quot;svn mv&quot; this to core, so that later patches on this issue will be applied easily. Moving to core has nothing to do w/ resolving the other issues.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;we could also &quot;upgrade&quot; to a bit set part way through, since it&apos;s so clear where the cutoff is&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;you&apos;re right, but cutting off to OBS is dangerous, b/c by doing that we:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Suddenly halt search when we create and populate OBS&lt;/li&gt;
	&lt;li&gt;Lose the ability to support out-of-order docs (in fact, depending on the mode and how the query was executed so far, we might not even be able to do the cut-off at all).&lt;br/&gt;
So I prefer that we make that decision up front, perhaps through another parameter to the factory method.&lt;/li&gt;
&lt;/ol&gt;


&lt;blockquote&gt;&lt;p&gt;but eg you could mess up (pass cacheScores = false but then pass a collector that calls .score())&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Oh I see, so this TODO is about the use of cachedScorer (vs. just delegating setScorer to other). I agree.&lt;/p&gt;

&lt;p&gt;BTW, this version of cachedScorer is very optimized and clean, but we do have ScoreCachingWrappingScorer which achieves the same goal, only w/ 1-2 more &apos;if&apos;. Perhaps we should reuse it? But then again, for the purpose of this Collector, cachedScorer is the most optimized it can be.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ie, I don&apos;t want to make it easy to be unlimited? It seems too dangerous... I&apos;d rather your code has to spell out 10*1024 so you realize you&apos;re saying 10 GB (for example).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;What if you run w/ 16GB Heap? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;But ok, I don&apos;t mind, we can spell it out clearly in the jdocs.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Are you planning to work up a patch for these...?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think so. I&apos;ll try to squeeze it in my schedule in the next couple of days. If I see I don&apos;t get to it, I&apos;ll update the issue.&lt;/p&gt;</comment>
                    <comment id="13033788" author="shaie" created="Sun, 15 May 2011 18:08:03 +0100"  >&lt;blockquote&gt;&lt;p&gt;I will start w/ &quot;svn mv&quot; this to core&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Or, we can iterate on all the changes here, then do the svn move as part of the commit. Both work for me.&lt;/p&gt;</comment>
                    <comment id="13033983" author="shaie" created="Mon, 16 May 2011 12:59:45 +0100"  >&lt;p&gt;Patch includes the bug fixes + test. Still none of the items I listed after &apos;Also ...&apos;. I plan to tackle that next, in subsequent patches.&lt;/p&gt;

&lt;p&gt;Question &amp;#8211; perhaps we can commit these changes incrementally? I.e., after we iterate on the changes in this patch, if they are ok, commit them, then do the rest of the stuff? Or a single commit w/ everything is preferable?&lt;/p&gt;

&lt;p&gt;Mike, there is another reason to separate Collector.needsScores() from cacheScores &amp;#8211; it is possible someone will pass a Collector which needs scores, however won&apos;t want to have CachingCollector &apos;cache&apos; them. In which case, the wrapped Collector should be delegated setScorer instead of cachedScorer.&lt;/p&gt;

&lt;p&gt;I will leave Collector.needsScores() for a different issue though?&lt;/p&gt;</comment>
                    <comment id="13033992" author="mikemccand" created="Mon, 16 May 2011 13:30:39 +0100"  >&lt;p&gt;Patch looks awesome Shai!&lt;/p&gt;

&lt;p&gt;Only thing is: I would be careful about directly setting those private fields of the cachedScorer; I think (not sure) this incurs an &quot;access&quot; check on each assignment.  Maybe make them package protected?  Or use a setter?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Question &#8211; perhaps we can commit these changes incrementally?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 - progress not perfection!  These changes are great.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mike, there is another reason to separate Collector.needsScores() from cacheScores &#8211; it is possible someone will pass a Collector which needs scores, however won&apos;t want to have CachingCollector &apos;cache&apos; them. In which case, the wrapped Collector should be delegated setScorer instead of cachedScorer.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ahh good point, because the 2nd pass collector may not need the scores.  So on the first pass we&apos;d have to forward the .score() request to the wrapped collector but not cache it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I will leave Collector.needsScores() for a different issue though?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Thanks for iterating on this Shai!&lt;/p&gt;</comment>
                    <comment id="13034060" author="shaie" created="Mon, 16 May 2011 16:30:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;Only thing is: I would be careful about directly setting those private fields of the cachedScorer; I think (not sure) this incurs an &quot;access&quot; check on each assignment. Maybe make them package protected? Or use a setter?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good catch Mike. I read about it some and found this nice webpage which explains the implications (&lt;a href=&quot;http://www.glenmccl.com/jperf/&quot; class=&quot;external-link&quot;&gt;http://www.glenmccl.com/jperf/&lt;/a&gt;). Indeed, if the member is private (whether it&apos;s in the inner or outer class), there is an access check. So the right think to do is to declare is protected / package-private, which I did. Thanks for the opportunity to get some education !&lt;/p&gt;

&lt;p&gt;Patch fixes this. I intend to commit this shortly + move the class to core + apply to trunk. Then, I&apos;ll continue w/ the rest of the improvements.&lt;/p&gt;</comment>
                    <comment id="13034091" author="mikemccand" created="Mon, 16 May 2011 17:37:51 +0100"  >&lt;p&gt;Patch looks great Shai &amp;#8211; +1 to commit!!&lt;/p&gt;

&lt;p&gt;Yes that is very sneaky about the private fields in inner/outer classes &amp;#8211; it&apos;s good you added a comment explaining it!&lt;/p&gt;</comment>
                    <comment id="13034283" author="shaie" created="Mon, 16 May 2011 21:30:43 +0100"  >&lt;p&gt;Committed revision 1103870 (3x).&lt;br/&gt;
Committed revision 1103872 (trunk).&lt;/p&gt;

&lt;p&gt;What&apos;s committed:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Move CachingCollector to core&lt;/li&gt;
	&lt;li&gt;Fix bugs&lt;/li&gt;
	&lt;li&gt;Add TestCachingCollector&lt;/li&gt;
	&lt;li&gt;Some refactoring&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Moving on to next proposed changes.&lt;/p&gt;</comment>
                    <comment id="13034728" author="shaie" created="Tue, 17 May 2011 12:38:10 +0100"  >&lt;p&gt;Patch against 3x which:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Adds factory method to CachingCollector, specializing on cacheScores&lt;/li&gt;
	&lt;li&gt;Clarify Collector.needScores() TODO&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There are two remaining issues, let&apos;s address them after we iterate on this patch.&lt;/p&gt;</comment>
                    <comment id="13034841" author="mikemccand" created="Tue, 17 May 2011 17:09:05 +0100"  >&lt;p&gt;Patch looks great!  But, can we rename curupto -&amp;gt; curUpto (and same for curbase)?  Ie, so it matches the other camelCaseVariables we have here...&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;</comment>
                    <comment id="13035188" author="shaie" created="Wed, 18 May 2011 05:00:48 +0100"  >&lt;p&gt;Committed revision 1104680 (3x).&lt;br/&gt;
Committed revision 1104683 (trunk).&lt;/p&gt;</comment>
                    <comment id="13035223" author="shaie" created="Wed, 18 May 2011 07:51:44 +0100"  >&lt;p&gt;There are two things left to do:&lt;/p&gt;

&lt;p&gt;(1) Use bit set instead of int[] for docIDs. If we do this, then it means the Collector cannot support out-of-order collections (which is not a big deal IMO). It also means for large indexes, we might consume more RAM than int[].&lt;/p&gt;

&lt;p&gt;(2) Allow this Collector to stand on its own, w/o necessarily wrapping another Collector. There are several ways we can achieve that:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Take a &apos;null&apos; Collector and check other != null. Adds an &apos;if&apos; but not a big deal IMO. Also, acceptDocsOutOfOrder will have to either return false (or true), or we take that as a parameter.&lt;/li&gt;
	&lt;li&gt;Take a &apos;null&apos; Collector and set this.other to a private static instance of a NoOpCollector. We&apos;ll still be delegating calls to it, but hopefully it won&apos;t be expensive. Same issue w/ out-of-order&lt;/li&gt;
	&lt;li&gt;Create two specialized variants of CachingCollector.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Personally I&apos;m not too much in favor of the last option - too much code dup for not much gain.&lt;/p&gt;

&lt;p&gt;The option I like the most is the 2nd (introducing a NoOpCollector). We can even introduce it as a public static member of CachingCollector and let users decide if they want to use it or not. For ease of use, we can still allow &apos;null&apos; to be passed to create().&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                    <comment id="13035280" author="shaie" created="Wed, 18 May 2011 11:42:40 +0100"  >&lt;p&gt;Patch against 3x:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Adds a create() to CachingCollector which does not take a Collector to wrap. Internally, it creates a no-op collector, which ignores everything.&lt;/li&gt;
	&lt;li&gt;Javadocs for create()&lt;/li&gt;
	&lt;li&gt;matching test.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    <comment id="13035283" author="mikemccand" created="Wed, 18 May 2011 11:50:29 +0100"  >&lt;p&gt;The committed CHANGES has typo (reply should be replay).&lt;/p&gt;</comment>
                    <comment id="13035285" author="mikemccand" created="Wed, 18 May 2011 11:55:36 +0100"  >&lt;p&gt;Patch to allow no wrapped collector looks good!  I wonder/hope hotspot can realize those method calls are no-ops...&lt;/p&gt;

&lt;p&gt;Maybe change TestGrouping to randomly use this ctor?  Ie, randomly, you can use caching collector (not wrapped), then call its replay method twice (once against 1st pass, then against 2nd pass, collectors), and then assert results like normal.  This is also a good verification that replay works twice...&lt;/p&gt;

&lt;p&gt;On the OBS, it makes me nervous to just always do this; I&apos;d rather have it cutover at some point?  Or perhaps it&apos;s an expert optional arg to create, whether it should back w/ OBS vs int[]?&lt;/p&gt;

&lt;p&gt;Or, ideally... we make a bit set impl that does this all under the hood (uses int[] when there are few docs, and &quot;ugprades&quot; to OBS once there are &quot;enough&quot; to justify it...), then we can just use that bit set here.&lt;/p&gt;</comment>
                    <comment id="13035344" author="shaie" created="Wed, 18 May 2011 13:39:26 +0100"  >&lt;blockquote&gt;&lt;p&gt;The committed CHANGES has typo (reply should be replay).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks, will include it in the next commit.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;d rather have it cutover at some point&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This can only be done if out-of-order collection wasn&apos;t done so far, because otherwise, cutting to OBS will take cached doc IDs and scores out of sync.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;we make a bit set impl that does this all under the hood (uses int[] when there are few docs, and &quot;ugprades&quot; to OBS once there are &quot;enough&quot; to justify it...)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s a good idea. I think we should leave the OBS stuff for another issue. See first how this performs and optimize only if needed.&lt;/p&gt;

&lt;p&gt;I&apos;ll take a look at TestGrouping.&lt;/p&gt;</comment>
                    <comment id="13035432" author="shaie" created="Wed, 18 May 2011 16:21:02 +0100"  >&lt;p&gt;Patch adds random to TestGrouping and fixes the CHANGES typo.&lt;/p&gt;

&lt;p&gt;Mike, TestGrouping fails w/ this seed: -Dtests.seed=7295196064099074191:-1632255311098421589 (it picks a no wrapping collector).&lt;/p&gt;

&lt;p&gt;I guess I didn&apos;t insert the random thing properly. It&apos;s the only place where the test creates a CachingCollector though. I noticed that it fails on the &apos;doCache&apos; but &apos;!doAllGroups&apos; case.&lt;/p&gt;

&lt;p&gt;Can you please take a look? I&apos;m not familiar with this test, and cannot debug it anymore today.&lt;/p&gt;</comment>
                    <comment id="13035457" author="mikemccand" created="Wed, 18 May 2011 16:49:01 +0100"  >&lt;p&gt;Patch.&lt;/p&gt;

&lt;p&gt;I think I fixed TestGrouping to exercise the &quot;no wrapped collector&quot; and &quot;replay twice&quot; case for CachingCollector.&lt;/p&gt;</comment>
                    <comment id="13035579" author="shaie" created="Wed, 18 May 2011 19:52:10 +0100"  >&lt;p&gt;Thanks Mike. Seems that TestGrouping is indeed fixed.&lt;/p&gt;

&lt;p&gt;Committed revision 1124378 (3x).&lt;br/&gt;
Committed revision 1124379 (trunk).&lt;/p&gt;

&lt;p&gt;Resolving this. We can tackle OBS and other optimizations in subsequent issues if the need arises.&lt;/p&gt;

&lt;p&gt;Thanks Mike !&lt;/p&gt;</comment>
                    <comment id="13035637" author="mikemccand" created="Wed, 18 May 2011 21:15:59 +0100"  >&lt;p&gt;Thanks Shai &amp;#8211; this is awesome progress!&lt;/p&gt;</comment>
                    <comment id="13043524" author="rcmuir" created="Fri, 3 Jun 2011 17:37:20 +0100"  >&lt;p&gt;Bulk closing for 3.2&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12479452" name="LUCENE-3102-factory.patch" size="20249" author="shaie" created="Tue, 17 May 2011 12:38:10 +0100" />
                    <attachment id="12479608" name="LUCENE-3102-nowrap.patch" size="4952" author="shaie" created="Wed, 18 May 2011 16:21:02 +0100" />
                    <attachment id="12479565" name="LUCENE-3102-nowrap.patch" size="3011" author="shaie" created="Wed, 18 May 2011 11:42:40 +0100" />
                    <attachment id="12479613" name="LUCENE-3102.patch" size="7425" author="mikemccand" created="Wed, 18 May 2011 16:49:01 +0100" />
                    <attachment id="12479337" name="LUCENE-3102.patch" size="16739" author="shaie" created="Mon, 16 May 2011 16:30:26 +0100" />
                    <attachment id="12479318" name="LUCENE-3102.patch" size="16332" author="shaie" created="Mon, 16 May 2011 12:59:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 15 May 2011 16:43:59 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2137</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    <customfieldvalue key="10120"><![CDATA[Patch Available]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24592</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>