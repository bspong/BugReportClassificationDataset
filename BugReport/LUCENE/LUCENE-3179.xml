<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Tue Jul 16 13:09:43 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LUCENE-3179/LUCENE-3179.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[LUCENE-3179] OpenBitSet.prevSetBit()</title>
                <link>https://issues.apache.org/jira/browse/LUCENE-3179</link>
                <project id="12310110" key="LUCENE">Lucene - Core</project>
                        <description>&lt;p&gt;Find a previous set bit in an OpenBitSet.&lt;br/&gt;
Useful for parent testing in nested document query execution &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2454&quot; title=&quot;Nested Document query support&quot;&gt;&lt;del&gt;LUCENE-2454&lt;/del&gt;&lt;/a&gt; .&lt;/p&gt;</description>
                <environment></environment>
            <key id="12509493">LUCENE-3179</key>
            <summary>OpenBitSet.prevSetBit()</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="paul.elschot@xs4all.nl">Paul Elschot</assignee>
                                <reporter username="paul.elschot@xs4all.nl">Paul Elschot</reporter>
                        <labels>
                    </labels>
                <created>Tue, 7 Jun 2011 19:11:51 +0100</created>
                <updated>Wed, 6 Jul 2011 21:49:08 +0100</updated>
                    <resolved>Fri, 24 Jun 2011 21:45:29 +0100</resolved>
                                            <fixVersion>3.3</fixVersion>
                <fixVersion>4.0-ALPHA</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13045567" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 19:16:08 +0100"  >&lt;p&gt;Add prevSetBit() and tests. Also moves some test code from TestOpenBitSet to TestBitUtil.&lt;/p&gt;</comment>
                    <comment id="13045576" author="yseeley@gmail.com" created="Tue, 7 Jun 2011 19:30:38 +0100"  >&lt;p&gt;Hey Paul, did you try this implementation against Long.numberOfLeadingZeros?&lt;br/&gt;
The later Oracle Java6 implementations have instrinsified this method, so it might be faster: &lt;br/&gt;
&lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=6823354&quot; class=&quot;external-link&quot;&gt;http://bugs.sun.com/view_bug.do?bug_id=6823354&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13045583" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 19:37:18 +0100"  >&lt;p&gt;Correct the issue number in the patch, and remove a superfluous javadoc comment.&lt;/p&gt;</comment>
                    <comment id="13045584" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 19:38:37 +0100"  >&lt;p&gt;Correct the issue number in the patch, remove a superfluous javadoc comment, and grant licence ...&lt;/p&gt;</comment>
                    <comment id="13045587" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 19:45:45 +0100"  >&lt;p&gt;I did not try this against Long.numberOfLeadingZeros, but in case that is faster we should use that of course.&lt;/p&gt;</comment>
                    <comment id="13045655" author="thetaphi" created="Tue, 7 Jun 2011 23:04:51 +0100"  >&lt;p&gt;If it&apos;s faster, should we not replace it completely in Lucene? The impl in Java 5 (Sun JDK) is identical to ours from BitUtils, so why replicate? If it gets intrinsic, it can only get faster. I assume its a relict from pre-Java-1.5 times like Lucene 2.9.&lt;/p&gt;</comment>
                    <comment id="13045656" author="thetaphi" created="Tue, 7 Jun 2011 23:05:13 +0100"  >&lt;p&gt;With the previous comment I also refer to nextSetBit().&lt;/p&gt;</comment>
                    <comment id="13045659" author="dweiss" created="Tue, 7 Jun 2011 23:07:12 +0100"  >&lt;p&gt;I posted the benchmarks of intrinsic vs. manual (OpenBitSet) performance of nlz and pop (bitcount) methods a while ago &amp;#8211; they should still be around JIRA somewhere. If I recall right, the difference was significant, although not like an order of magnitude or  something... and on CPUs without intrinsic instructions the implementation handcrafted by Yonik was actually faster than the one in the standard library. Of course these days most CPUs will have popcnt/ nlz instructions, so it makes sense to switch.&lt;/p&gt;</comment>
                    <comment id="13045662" author="dweiss" created="Tue, 7 Jun 2011 23:11:17 +0100"  >&lt;p&gt;I think it&apos;s the 1.6 that adds these intrinsics &amp;#8211; I don&apos;t know if they&apos;ve been backported to updates to 1.5, but this should be relatively easy to verify empirically.&lt;/p&gt;</comment>
                    <comment id="13045663" author="thetaphi" created="Tue, 7 Jun 2011 23:12:49 +0100"  >&lt;p&gt;That&apos;s strange, the last time I looked into the code from the src.jar standard library it was 1:1 identical (there was even the same reference to the same Hacker&apos;s delight article). So I am just confused...&lt;/p&gt;</comment>
                    <comment id="13045667" author="dweiss" created="Tue, 7 Jun 2011 23:16:02 +0100"  >&lt;p&gt;Intrinsics are implemented/added at the hotspot (jit) level, you won&apos;t see them in src.jar &amp;#8211; all calls to specific methods in Long.* or Integer.* are replaced by handcrafted assembly (usually process-specific instructions that do what a given method should do).&lt;/p&gt;

&lt;p&gt;If you&apos;re interested, check out openjdk code of hotspot and scan for intrinsics (or popcnt).&lt;/p&gt;</comment>
                    <comment id="13045669" author="thetaphi" created="Tue, 7 Jun 2011 23:20:35 +0100"  >&lt;p&gt;You misunderstood me, i know what intrinsics are. My confusion was related to that:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;and on CPUs without intrinsic instructions the implementation handcrafted by Yonik was actually faster than the one in the standard library&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;And the so called hand crafted method is identical in src.jar and Yonik&apos;s code. So without intrinsics, the standard library and Yoniks code should be identical in performance, as it was same code, the last time I looked into it.&lt;/p&gt;</comment>
                    <comment id="13045674" author="yseeley@gmail.com" created="Tue, 7 Jun 2011 23:26:46 +0100"  >&lt;blockquote&gt;&lt;p&gt;And the so called hand crafted method is identical in src.jar and Yonik&apos;s code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For pop, yes. But not for ntz or pop_array and friends.&lt;/p&gt;

&lt;p&gt;BitUtil.pop exists because this was originally written to work with java1.4 which didn&apos;t have Long.bitCount()&lt;br/&gt;
&lt;a href=&quot;http://markmail.org/message/5ay4m2thsvsahk3c&quot; class=&quot;external-link&quot;&gt;http://markmail.org/message/5ay4m2thsvsahk3c&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13045676" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 23:27:13 +0100"  >&lt;p&gt;The micro benchmarks for ntz() and pop() are at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2221&quot; title=&quot;Micro-benchmarks for ntz and pop (BitUtils) operations.&quot;&gt;&lt;del&gt;LUCENE-2221&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                    <comment id="13045679" author="dweiss" created="Tue, 7 Jun 2011 23:29:21 +0100"  >&lt;p&gt;Oh, ok &amp;#8211; clear. So, my comment was related to the various methods of doing bitcounts and other bit-fiddling on arrays of long values (for example pop_array) &amp;#8211; these are HD derived implementations; I compared them to naive loops using intrinsics and naive loops on cpus (and jvms) without intrinsics &amp;#8211; in that case simple loops with intrinsics was faster than Lucene&apos;s code, but Lucene&apos;s code was faster than simple loops without intrinsics (effectively using whatever was in the std. library).&lt;/p&gt;</comment>
                    <comment id="13045682" author="thetaphi" created="Tue, 7 Jun 2011 23:34:59 +0100"  >&lt;p&gt;OK, so we can sefely remove BitUtil.pop and replace by the Java 5 method (maybe review again the code in src.jar also for ntz). And if this one is an intrinsic in Java 6 its even faster.&lt;/p&gt;

&lt;p&gt;Now we talk the same language &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;20&quot; width=&quot;20&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    <comment id="13045685" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 23:36:29 +0100"  >&lt;p&gt;As to the performance, the current patch at &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2454&quot; title=&quot;Nested Document query support&quot;&gt;&lt;del&gt;LUCENE-2454&lt;/del&gt;&lt;/a&gt; has a bitwise linear search to do this.&lt;/p&gt;</comment>
                    <comment id="13046140" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 20:12:26 +0100"  >&lt;p&gt;I did a bit of performance testing (sun java 1.6.0_xx, not the very latest one).&lt;/p&gt;

&lt;p&gt;This is a typical output on my machine (the dummy can be ignored, it is only there to make sure that nothing is optimized away):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;BitUtil nlz time: 5664 picosec/call, dummy: 11572915728
Long    nlz time: 8464 picosec/call, dummy: 7715277152
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That means that the nlz code in the patch is definitely faster than Long.numberOfLeadingZeros for the test arguments used.&lt;br/&gt;
The test arguments are divided roughly evenly for the possible numbers of leading zero bits.&lt;/p&gt;</comment>
                    <comment id="13046141" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 20:14:57 +0100"  >&lt;p&gt;TestBitUtil.java as in the patch and extended with a testPerfNlz method that gave the output above.&lt;/p&gt;</comment>
                    <comment id="13046169" author="dweiss" created="Wed, 8 Jun 2011 20:51:18 +0100"  >&lt;p&gt;You&apos;re not providing the required contex &amp;#8211; what exact JVM and what exact processor did you test on? I&apos;ve just ran your test on my machine with the following result:&lt;/p&gt;

&lt;p&gt;BitUtil nlz time: 3109 picosec/call, dummy: 20252602524&lt;br/&gt;
Long    nlz time: 1279 picosec/call, dummy: 48220482200&lt;/p&gt;

&lt;p&gt;I&apos;m guessing yours didn&apos;t use the intrinsic inline at all (for whatever reason). My machine is a fairly old Intel I7 860 running 64-Bit server hotspot 1.6.0_24-b07.&lt;/p&gt;
</comment>
                    <comment id="13046227" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 22:15:32 +0100"  >&lt;p&gt;The java.vm.version value 1.6.0_03-b05, java.vm.info value is mixed mode.&lt;br/&gt;
The processor is an Athlon II X3 450 at 800 MHz.&lt;/p&gt;

&lt;p&gt;Since the Long time is about 2.5 times faster than the BitUtil with a 64 bit processor, I&apos;ll change the patch to use Long. When the hardware allows better performance, it should be used.&lt;/p&gt;</comment>
                    <comment id="13046239" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 22:30:45 +0100"  >&lt;p&gt;BitUtil.nlz() and the performance test method (renamed to tstPerfNlz()) are still in the patch, even though they are not used.&lt;/p&gt;

&lt;p&gt;I think committing this could wait until &lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-2454&quot; title=&quot;Nested Document query support&quot;&gt;&lt;del&gt;LUCENE-2454&lt;/del&gt;&lt;/a&gt; is committed, and then that code can be changed to use prevSetBit() together with this.&lt;/p&gt;</comment>
                    <comment id="13046243" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 22:34:13 +0100"  >&lt;p&gt;Corrected mixing up the digits of the issue number.&lt;/p&gt;</comment>
                    <comment id="13046641" author="mikemccand" created="Thu, 9 Jun 2011 17:00:39 +0100"  >&lt;p&gt;I think we should just commit this?  It&apos;s a useful API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/LUCENE-3171&quot; title=&quot;BlockJoinQuery/Collector&quot;&gt;&lt;del&gt;LUCENE-3171&lt;/del&gt;&lt;/a&gt; (alternative nested docs impl w/ single pass collector) also could use this.&lt;/p&gt;</comment>
                    <comment id="13051141" author="mikemccand" created="Fri, 17 Jun 2011 16:34:36 +0100"  >&lt;p&gt;Patch, just fixes some whitespace issues and adds CHANGES entry. I think it&apos;s ready to commit!&lt;/p&gt;</comment>
                    <comment id="13051366" author="mikemccand" created="Fri, 17 Jun 2011 23:30:27 +0100"  >&lt;p&gt;Thanks Paul!&lt;/p&gt;</comment>
                    <comment id="13054521" author="thetaphi" created="Fri, 24 Jun 2011 17:17:09 +0100"  >&lt;p&gt;The testcase for prevSetBit has a bug, that was found by testing with java 5. It assumes that the allocation strategy for BitSet and OpenBitSet is identical, which it is not. E.g. Java 5&apos;s new BitSet(0) allocates still one word, while OpenBitSet does not.&lt;/p&gt;

&lt;p&gt;The attached patch fixes the issue.&lt;/p&gt;</comment>
                    <comment id="13054573" author="thetaphi" created="Fri, 24 Jun 2011 18:40:57 +0100"  >&lt;p&gt;Yonik mentioned on mailing list that prevSetBit is broken for size==0 and also indexes &amp;gt;= size. In that case you always get AIOOBE or even wrong results. In the case of an index &amp;gt;= the length of the bitset, the scanning must start at the last possible bit, so subIndex must be 0x3f and not simply the anded bits.&lt;/p&gt;

&lt;p&gt;This is my naive fix. Tests pass (I added a extra check to the test that start beyond end of bitset to check prevSetBit).&lt;/p&gt;</comment>
                    <comment id="13054578" author="thetaphi" created="Fri, 24 Jun 2011 18:53:09 +0100"  >&lt;p&gt;The check for negative indexes must be done to make the following loop work (which is standard to iterate backwards from &quot;startBit&quot; on all bits):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = bs.prevSetBit(startBit); i &amp;gt;= 0; i = bs.prevSetBit(i-1)) {
     &lt;span class=&quot;code-comment&quot;&gt;// operate on index i here
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This would fail with AIOOBE when i=0 on the last iteration (happens if 0th bit is set), because bs.prevSetBit(i-1) has negative parameter. The exit condition is checked later, so -1 must be allowed.&lt;/p&gt;</comment>
                    <comment id="13054589" author="thetaphi" created="Fri, 24 Jun 2011 19:06:13 +0100"  >&lt;p&gt;Modified patch. I moved the assignment to the &quot;word&quot; variable to also inside the if/else branch, as for the beyond-last-bit case we can optimize to not shift at all.&lt;/p&gt;</comment>
                    <comment id="13054606" author="paul.elschot@xs4all.nl" created="Fri, 24 Jun 2011 19:21:38 +0100"  >&lt;p&gt;The 3179-fix patch looks good to me.&lt;br/&gt;
I remember I had some doubts about which bit was actually the last one, and stopped worrying about it when the tests passed.&lt;br/&gt;
This patch makes it very clear what the last bit is.&lt;/p&gt;</comment>
                    <comment id="13054607" author="yseeley@gmail.com" created="Fri, 24 Jun 2011 19:23:15 +0100"  >&lt;p&gt;+1, patch looks good Uwe.&lt;/p&gt;</comment>
                    <comment id="13054669" author="thetaphi" created="Fri, 24 Jun 2011 21:45:29 +0100"  >&lt;p&gt;Committed 3.x branch revision: 1139430&lt;br/&gt;
Committed trunk revision: 1139431&lt;br/&gt;
Committed 3.3 branch revision: 1139433&lt;/p&gt;

&lt;p&gt;Thanks Yonik!&lt;/p&gt;</comment>
                    <comment id="13054681" author="thetaphi" created="Fri, 24 Jun 2011 22:20:46 +0100"  >&lt;p&gt;One more comment: When working on the code, the symmetry all other methods have between long and int is broken here. For consistency we should add the long method, too. I just don&apos;t like the missing consistency.&lt;/p&gt;

&lt;p&gt;Also: OpenBitSet.nextSetBit() does not use Long.numberOfTrailingZeroes() but the new prevSetBit() does. As both methods have intrinsics, why only use one of them? Yonik?&lt;/p&gt;

&lt;p&gt;Any comments?&lt;/p&gt;</comment>
                    <comment id="13055063" author="mikemccand" created="Sun, 26 Jun 2011 13:41:03 +0100"  >&lt;p&gt;Thanks for fixing these Uwe!&lt;/p&gt;

&lt;p&gt;I actually don&apos;t like how &quot;generic&quot; OBS has become... ie, that all methods have an int and long version, that the OBS doesn&apos;t &quot;know&quot; how many bits it holds (I added this field recently, but only for assertions), that some methods &quot;grow&quot; the number of bits and others don&apos;t, some methods accept out-of-bounds indices (negative and &amp;gt; numBits), etc.  I think it&apos;s grown to accommodate too many users.... but I&apos;m not sure what we should do to fix this.  Maybe factor out (yet another) bit set impl that doesn&apos;t grow, knows its number of bits, has these fast getNext/getPrev set bit methods, operates only on int indices, etc.&lt;/p&gt;</comment>
                    <comment id="13055064" author="mikemccand" created="Sun, 26 Jun 2011 13:43:01 +0100"  >&lt;blockquote&gt;&lt;p&gt;One more comment: When working on the code, the symmetry all other methods have between long and int is broken here. For consistency we should add the long method, too. I just don&apos;t like the missing consistency.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think we should add the long version, for consistency.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Also: OpenBitSet.nextSetBit() does not use Long.numberOfTrailingZeroes() but the new prevSetBit() does. As both methods have intrinsics, why only use one of them? Yonik?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good question!  In testing on this issue, above, Dawid and Paul found the intrinsics were faster on modern JREs... seems like nextSetBit should cutover too?&lt;/p&gt;</comment>
                    <comment id="13055118" author="thetaphi" created="Sun, 26 Jun 2011 17:55:51 +0100"  >&lt;p&gt;Here the patch with the long version and Long.numberOfTrailingZeroes() instead of BitUtils.ntz().&lt;/p&gt;

&lt;p&gt;Path was already available on my checkout. We should only also test the long versions (according to Clover all of them are not really tested).&lt;/p&gt;</comment>
                    <comment id="13055134" author="thetaphi" created="Sun, 26 Jun 2011 19:05:25 +0100"  >&lt;p&gt;New patch that also improves tests to check all uncovered long methods (of course the indexes are still &amp;lt; Integer.MAX_VALUE(.&lt;/p&gt;</comment>
                    <comment id="13055506" author="mikemccand" created="Mon, 27 Jun 2011 13:41:47 +0100"  >&lt;p&gt;Patch looks good Uwe &amp;#8211; thanks!&lt;/p&gt;</comment>
                    <comment id="13057980" author="thetaphi" created="Thu, 30 Jun 2011 19:46:17 +0100"  >&lt;p&gt;Any other comments/microbenchmarks from other committers? Dawid and Paul?&lt;/p&gt;

&lt;p&gt;I would like to commit this if nobody objects! What should we do with the then obsolete BitUtils methods?&lt;/p&gt;</comment>
                    <comment id="13058924" author="rcmuir" created="Sat, 2 Jul 2011 03:40:14 +0100"  >&lt;p&gt;bulk close for 3.3&lt;/p&gt;</comment>
                    <comment id="13060829" author="thetaphi" created="Wed, 6 Jul 2011 21:49:08 +0100"  >&lt;p&gt;Committed long versions and additional tests: rev 1143558 (trunk), rev 1143560 (3.x).&lt;/p&gt;

&lt;p&gt;I did not commit the cutover to Long.numberOfLeadingZeroes, because it was not performance tested. Also from the use-case, on machines without intrinsics, the JDK-given methods are slower (see comments in BitUtils.ntz, as in most cases the bits are shifted away (in nextSetBit), so the faster algorithm is to inverse the algorithm when calculating ntz.&lt;/p&gt;</comment>
                </comments>
                    <attachments>
                    <attachment id="12483752" name="LUCENE-3179-fix.patch" size="1681" author="thetaphi" created="Fri, 24 Jun 2011 19:06:13 +0100" />
                    <attachment id="12483750" name="LUCENE-3179-fix.patch" size="1471" author="thetaphi" created="Fri, 24 Jun 2011 18:40:57 +0100" />
                    <attachment id="12483863" name="LUCENE-3179-long-ntz.patch" size="6251" author="thetaphi" created="Sun, 26 Jun 2011 19:05:25 +0100" />
                    <attachment id="12483857" name="LUCENE-3179-long-ntz.patch" size="2246" author="thetaphi" created="Sun, 26 Jun 2011 17:55:51 +0100" />
                    <attachment id="12482943" name="LUCENE-3179.patch" size="11375" author="mikemccand" created="Fri, 17 Jun 2011 16:34:36 +0100" />
                    <attachment id="12481872" name="LUCENE-3179.patch" size="10510" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 22:34:13 +0100" />
                    <attachment id="12481733" name="LUCENE-3179.patch" size="7882" author="paul.elschot@xs4all.nl" created="Tue, 7 Jun 2011 19:38:37 +0100" />
                    <attachment id="12481849" name="TestBitUtil.java" size="3979" author="paul.elschot@xs4all.nl" created="Wed, 8 Jun 2011 20:14:57 +0100" />
                    <attachment id="12483728" name="TestOpenBitSet.patch" size="537" author="thetaphi" created="Fri, 24 Jun 2011 17:17:28 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>9.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 7 Jun 2011 18:30:38 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2103</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310120" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                <customfieldname>Lucene Fields</customfieldname>
                <customfieldvalues>
                        <customfieldvalue key="10121"><![CDATA[New]]></customfieldvalue>
    
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>24518</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>