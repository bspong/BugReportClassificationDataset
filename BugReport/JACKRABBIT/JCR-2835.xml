<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:36:12 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2835/JCR-2835.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2835] Poor performance of ISDESCENDANTNODE on SQL 2 queries</title>
                <link>https://issues.apache.org/jira/browse/JCR-2835</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Using the latest source code, I have noticed very bad performance on SQL-2 queries that use the ISDESCENDANTNODE constraint on a large sub-tree. For example, the query : &lt;br/&gt;
&lt;br/&gt;
select * from [jnt:news] as news where ISDESCENDANTNODE(news,&amp;#39;/root/site&amp;#39;) order by news.[date] desc &lt;br/&gt;
&lt;br/&gt;
executes in 600ms &lt;br/&gt;
&lt;br/&gt;
select * from [jnt:news] as news order by news.[date] desc&lt;br/&gt;
&lt;br/&gt;
executes in 4ms&lt;br/&gt;
&lt;br/&gt;
From looking at the problem in the Yourkit profiler, it seems that the culprit is the constraint building, that uses recursive Lucene searches to build the list of descendant node IDs : &lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private Query getDescendantNodeQuery(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DescendantNode dn, JackrabbitIndexSearcher searcher)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throws RepositoryException, IOException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BooleanQuery query = new BooleanQuery();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LinkedList&amp;lt;NodeId&amp;gt; ids = new LinkedList&amp;lt;NodeId&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeImpl ancestor = (NodeImpl) session.getNode(dn.getAncestorPath());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ids.add(ancestor.getNodeId());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (!ids.isEmpty()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String id = ids.removeFirst().toString();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Query q = new JackrabbitTermQuery(new Term(FieldNames.PARENT, id));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;QueryHits hits = searcher.evaluate(q);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ScoreNode sn = hits.nextScoreNode();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (sn != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;query.add(q, SHOULD);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;do {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ids.add(sn.getNodeId());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sn = hits.nextScoreNode();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} while (sn != null);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (PathNotFoundException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;query.add(new JackrabbitTermQuery(new Term(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;FieldNames.UUID, &amp;quot;invalid-node-id&amp;quot;)), // never matches&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SHOULD);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return query;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
In the above example this generates over 2800 Lucene queries, which is the culprit. I wonder if it wouldn&amp;#39;t be faster to retrieve the IDs by using the JCR to retrieve the list of child IDs ?&lt;br/&gt;
&lt;br/&gt;
This was probably also missed because I didn&amp;#39;t seem to find any performance tests on this constraint.</description>
                <environment></environment>
            <key id="12492705">JCR-2835</key>
            <summary>Poor performance of ISDESCENDANTNODE on SQL 2 queries</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="bhillou">Serge Huber</reporter>
                        <labels>
                    </labels>
                <created>Wed, 8 Dec 2010 07:37:21 +0000</created>
                <updated>Tue, 8 Nov 2011 15:56:08 +0000</updated>
                    <resolved>Mon, 3 Jan 2011 19:29:41 +0000</resolved>
                            <version>2.2</version>
                <version>2.2.1</version>
                <version>2.3</version>
                                <fixVersion>2.2.1</fixVersion>
                <fixVersion>2.3</fixVersion>
                                <component>jackrabbit-core</component>
                <component>query</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12969329" author="bhillou" created="Wed, 8 Dec 2010 14:36:35 +0000"  >Added fix version, please correct if needed.</comment>
                    <comment id="12969331" author="bhillou" created="Wed, 8 Dec 2010 14:40:51 +0000"  >&lt;br/&gt;
I am attaching a patch to the LuceneQueryFactory that replaces the recursive Lucene queries with JCR sub-tree traversing. This seems to yield a little bit better performance (x3) in my tests, but this is still slow if the sub-tree has a lot of nodes.&lt;br/&gt;
&lt;br/&gt;
I welcome any feedback you may have. I am also ready to commit this if you&amp;#39;d like.&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12969432" author="jukkaz" created="Wed, 8 Dec 2010 19:16:08 +0000"  >This probably won&amp;#39;t make it in the 2.2 timeframe, so targetting just 2.3 for now.&lt;br/&gt;
&lt;br/&gt;
When fixing this, we should start by adding a test case to the peformance test suite (possibly with an option to compare SQL2 against XPath). That way we&amp;#39;ll have solid numbers to back any improvement ideas.&lt;br/&gt;
&lt;br/&gt;
In general subtree queries are troublesome even for XPath, but there&amp;#39;s still a lot we can do to bring SQL2 at least close to that level. One idea I had (but didn&amp;#39;t yet have time to implement) was to collect the parent UUIDs of the entire subtree not by traversing each node separately, but by per-level queries like 1) parent-id=&amp;lt;uuid-of-ancestor&amp;gt;, 2) parent-id=&amp;lt;uuid-of-child1&amp;gt; parent-id=&amp;lt;uuid-of-child2&amp;gt; ..., 3) same for grandchildren, etc. That way we&amp;#39;d only need to execute a handful of Lucene queries per one subtree constraint.</comment>
                    <comment id="12969649" author="bhillou" created="Thu, 9 Dec 2010 07:42:15 +0000"  >Hello Jukka, &lt;br/&gt;
&lt;br/&gt;
Thanks again for your quick answer.&lt;br/&gt;
&lt;br/&gt;
Yes agreed we should provide a test case. Where should this be included ? I might have the opportunity to help develop this but I don&amp;#39;t really know the best place to add such a case ?&lt;br/&gt;
&lt;br/&gt;
Interesting approach for the levels, this would indeed reduce the number of queries, although the clauses could get quite large, not sure if that&amp;#39;s an issue for Lucene.&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12969700" author="jukkaz" created="Thu, 9 Dec 2010 11:33:40 +0000"  >See the ./test/performance directory within Jackrabbit trunk. I just added some instructions in the README.txt file for adding new tests. The simplest way to get started is to copy and adapt the SimpleSearchTest and SQL2SearchTest classes to something like DescendantSearchTest and SQL2DescendantSearchTest classes.&lt;br/&gt;
&lt;br/&gt;
Re: large clauses; Yes, we&amp;#39;d probably need some extra code that automatically splits the queries into smaller subqueries, like is currently being done by the QueryEngine.execute() method for large joins.</comment>
                    <comment id="12969792" author="bhillou" created="Thu, 9 Dec 2010 16:31:18 +0000"  >I am attaching a first pass at the descendant search tests. &lt;br/&gt;
These tests were performed on the trunk WITHOUT the proposed patch. I will work on implementing Jukka&amp;#39;s proposal now that I have the tests.&lt;br/&gt;
&lt;br/&gt;
Please review the XPath one as I am not that fluent in those queries. &lt;br/&gt;
&lt;br/&gt;
The current difference is huge (provided my tests are correct) : &lt;br/&gt;
&lt;br/&gt;
XPath : &lt;br/&gt;
# DescendantSearchTest                   min     10%     50%     90%     max&lt;br/&gt;
2.2                                       25      34      43      59     265&lt;br/&gt;
&lt;br/&gt;
SQL-2 : &lt;br/&gt;
&lt;br/&gt;
# SQL2DescendantSearchTest               min     10%     50%     90%     max&lt;br/&gt;
2.2                                   395318  395318  395318  395318  395318&lt;br/&gt;
&lt;br/&gt;
If the test implementations look ok, I can commit them once reviewed. &lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12969838" author="bhillou" created="Thu, 9 Dec 2010 18:15:42 +0000"  >I just tested with the patch I proposed here, the results are slightly better, but still very far from the XPath implementation : &lt;br/&gt;
&lt;br/&gt;
# SQL2DescendantSearchTest               min     10%     50%     90%     max&lt;br/&gt;
2.2                                   224662  224662  224662  224662  224662&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12970024" author="jukkaz" created="Fri, 10 Dec 2010 00:10:00 +0000"  >Thanks for adding the test! Feel free to commit it.</comment>
                    <comment id="12970100" author="bhillou" created="Fri, 10 Dec 2010 08:09:20 +0000"  >Ok I have committed the perf tests in revision 1044239. &lt;br/&gt;
&lt;br/&gt;
I will be working on trying out your suggestion today.&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12970436" author="jukkaz" created="Sat, 11 Dec 2010 09:44:06 +0000"  >BTW, when adding new files, remember to always include the Apache license header. I added the header to the new test classes in revision 1044613 to fix the Hudson failure caused by this.</comment>
                    <comment id="12970715" author="bhillou" created="Mon, 13 Dec 2010 07:00:48 +0000"  >Sorry about that Jukka, my bad. Didn&amp;#39;t know this could cause Hudson to fail.&lt;br/&gt;
&lt;br/&gt;
Btw unfortunately I didn&amp;#39;t have the time to test your proposal. I was working on comparing the Lucene queries between the XPath and SQL-2 tests, and saw that the DescendantChildNodeQuery is being used in the case of XPath but not in the case of SQL-2. I&amp;#39;m not (yet) an expert at Lucene, but maybe that&amp;#39;s a place to start ? &lt;br/&gt;
&lt;br/&gt;
I also notice that the SimpleQueryResult does not support result fetch size as the other SingleColumnQueryResult and MultipleColumnQueryResult do. I realize this is because of the join merging, but maybe we should look at being able to do &amp;quot;progressive&amp;quot; merging alongside with merges in order to reduce the number of results being loaded systematically. Again I haven&amp;#39;t thought this through completely and maybe there is some limitation on doing so.&lt;br/&gt;
&lt;br/&gt;
These query problems are difficult because we are basically rewriting a full-fledged SQL optimizer, and maybe we should look at how databases perform these ?&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12971692" author="draier" created="Wed, 15 Dec 2010 14:46:12 +0000"  >Hi,&lt;br/&gt;
&lt;br/&gt;
I just made some improvements in the DescendantNode constraint, using the same kind of subquery we do in XPATH (DescendantSelfAxisQuery)&lt;br/&gt;
&lt;br/&gt;
First I had to slightly change the XPath test in order to make it more comparable with the one SQL-2, as the current query in DescendantSearchTest does not return any result :-)&lt;br/&gt;
&lt;br/&gt;
So instead of : /testroot//*[@testcount=&amp;quot; + i + &amp;quot;]&amp;quot;  &lt;br/&gt;
I used :  /jcr:root/testroot//element(*,nt:base)[@testcount=&amp;quot; + i + &amp;quot;]&amp;quot;&lt;br/&gt;
(added a the jcr:root , and an nt:base constraint to have the same constraint as in sql-2 - btw this could also be improved, as a constraint on nt:base does not make much sense and does not need to be expanded to all sub types)&lt;br/&gt;
&lt;br/&gt;
Before patching, i had theses figures - similar to what serge got before&lt;br/&gt;
&lt;br/&gt;
# DescendantSearchTest &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; min &amp;#xA0; &amp;#xA0; 10% &amp;#xA0; &amp;#xA0; 50% &amp;#xA0; &amp;#xA0; 90% &amp;#xA0; &amp;#xA0; max&lt;br/&gt;
2.2 &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0;411 &amp;#xA0; &amp;#xA0; 416 &amp;#xA0; &amp;#xA0; 430 &amp;#xA0; &amp;#xA0; 450 &amp;#xA0; &amp;#xA0; 690&lt;br/&gt;
# SQL2DescendantSearchTest &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; min &amp;#xA0; &amp;#xA0; 10% &amp;#xA0; &amp;#xA0; 50% &amp;#xA0; &amp;#xA0; 90% &amp;#xA0; &amp;#xA0; max&lt;br/&gt;
2.2 &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; 203530 &amp;#xA0;203530 &amp;#xA0;203530 &amp;#xA0;203530 &amp;#xA0;203530&lt;br/&gt;
&lt;br/&gt;
After  patching :&lt;br/&gt;
&lt;br/&gt;
# DescendantSearchTest &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; min &amp;#xA0; &amp;#xA0; 10% &amp;#xA0; &amp;#xA0; 50% &amp;#xA0; &amp;#xA0; 90% &amp;#xA0; &amp;#xA0; max&lt;br/&gt;
2.3 &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0;420 &amp;#xA0; &amp;#xA0; 429 &amp;#xA0; &amp;#xA0; 448 &amp;#xA0; &amp;#xA0; 479 &amp;#xA0; &amp;#xA0;1208&lt;br/&gt;
# SQL2DescendantSearchTest &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; min &amp;#xA0; &amp;#xA0; 10% &amp;#xA0; &amp;#xA0; 50% &amp;#xA0; &amp;#xA0; 90% &amp;#xA0; &amp;#xA0; max&lt;br/&gt;
2.3 &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0; &amp;#xA0;319 &amp;#xA0; &amp;#xA0; 327 &amp;#xA0; &amp;#xA0; 339 &amp;#xA0; &amp;#xA0; 351 &amp;#xA0; &amp;#xA0; 375&lt;br/&gt;
&lt;br/&gt;
Which make the SQL2 queries even faster than the XPATH one. Basically, I use a DescendantSelfAxisQuery with subqueries when possible. Compared to Xpath, the context query is simpler ( the one that gets the ancestor node ), as it is based on nodeid instead of nested ChildAxisQuery queries - which can explain that sql-2 is slightly faster.&lt;br/&gt;
&lt;br/&gt;
For example, an xpath query like : &amp;quot; /jcr:root/folder1/folder2//element(*,nt:type) &amp;quot;&lt;br/&gt;
Is translated to :&lt;br/&gt;
&lt;br/&gt;
+DescendantSelfAxisQuery(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ChildAxisQuery(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+ChildAxisQuery(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_:PARENT:, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{}folder1), &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{}folder2), &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+_:PROPERTIES:1570322:primaryType[14877513:type, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)&lt;br/&gt;
&lt;br/&gt;
Where an equivalent &amp;quot; select * from [nt:type] as obj where ISDESCENDANTNODE(obj, &amp;#39;/folder1/folder2&amp;#39;) &amp;quot; gives :&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
DescendantSelfAxisQuery(_:UUID:a4137e73-6a16-4148-9d61-2353230a15d0, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+_:PROPERTIES:1570322:primaryType[14877513:type, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1)&lt;br/&gt;
&lt;br/&gt;
Note that it currently only works in the first level of constraint - an isDescendantNode constraint inside an OR / NOT boolean query won&amp;#39;t use the subquery. I don&amp;#39;t think it&amp;#39;s a big issue for the OR - but it can be for the NOT .. &lt;br/&gt;
&lt;br/&gt;
The patch is attached ..&lt;br/&gt;
&lt;br/&gt;
Regards&lt;br/&gt;
</comment>
                    <comment id="12972379" author="bhillou" created="Fri, 17 Dec 2010 07:34:02 +0000"  >I have generated the performance graphs and indeed this patch looks really good !&lt;br/&gt;
&lt;br/&gt;
Btw I had a lot of trouble generating the graphs under Mac OS X. It took me a while to understand that I needed to install the following packages from fink : &lt;br/&gt;
&lt;br/&gt;
imagemagick2-svg&lt;br/&gt;
gnuplot&lt;br/&gt;
&lt;br/&gt;
I have added to the README.txt instructions on how to use the script under Mac OS X to generate the graphs.&lt;br/&gt;
&lt;br/&gt;
If nobody has any objections, I&amp;#39;d like to commit this patch since the results are really much better ?&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12972384" author="bhillou" created="Fri, 17 Dec 2010 08:01:37 +0000"  >Also, maybe we should port this to 2.2.1 ? &lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12972436" author="jukkaz" created="Fri, 17 Dec 2010 10:47:02 +0000"  >+1 Looks great!&lt;br/&gt;
&lt;br/&gt;
Re: 2.2.1; Yes, I think it would be a good idea to backport this even though strictly speaking it&amp;#39;s not just a bug fix. We don&amp;#39;t introduce any externally visible API or behaviour changes, and this change should also fix the &amp;quot;too many clauses&amp;quot; problem already reported on users@.</comment>
                    <comment id="12972440" author="bhillou" created="Fri, 17 Dec 2010 10:57:21 +0000"  >Thanks Jukka, will you take care of the backport or should I do it ?&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge... </comment>
                    <comment id="12972444" author="bhillou" created="Fri, 17 Dec 2010 11:10:26 +0000"  >Ok I have committed this in the trunk, as revision 1050346&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12976897" author="jukkaz" created="Mon, 3 Jan 2011 19:29:41 +0000"  >Merged to the 2.2 branch in revision 1054716.</comment>
                </comments>
                    <attachments>
                    <attachment id="12466449" name="DescendantSearchTest.png" size="26216" author="bhillou" created="Fri, 17 Dec 2010 07:34:02 +0000" />
                    <attachment id="12465919" name="JCR-2835_PerformanceTests.patch" size="4417" author="bhillou" created="Thu, 9 Dec 2010 16:32:10 +0000" />
                    <attachment id="12465805" name="JCR-2835_Poor_performance_on_ISDESCENDANTNODE_constraint_v1.patch" size="1988" author="bhillou" created="Wed, 8 Dec 2010 14:40:51 +0000" />
                    <attachment id="12466323" name="JCR-2835-use-DescendantSelfAxisQuery.patch" size="8761" author="draier" created="Wed, 15 Dec 2010 14:47:46 +0000" />
                    <attachment id="12466450" name="SQL2DescendantSearchTest.png" size="31771" author="bhillou" created="Fri, 17 Dec 2010 07:34:02 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 8 Dec 2010 19:16:08 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>97810</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>250315</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>