<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 06:03:18 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2272/JCR-2272.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2272] Errors during concurrent session import of nodes with same UUIDs</title>
                <link>https://issues.apache.org/jira/browse/JCR-2272</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>21.08.2009 16:22:14 *ERROR* [Executor 0] ConnectionRecoveryManager: could not execute statement, reason: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by &amp;#39;SQL090821042140130&amp;#39; defined on &amp;#39;DEFAULT_BUNDLE&amp;#39;., state/code: 23505/20000 (ConnectionRecoveryManager.java, line 453)&lt;br/&gt;
21.08.2009 16:22:14 *ERROR* [Executor 0] BundleDbPersistenceManager: failed to write bundle: 6c292772-349e-42b3-8255-7729615c67de (BundleDbPersistenceManager.java, line 1212)&lt;br/&gt;
ERROR 23505: The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by &amp;#39;SQL090821042140130&amp;#39; defined on &amp;#39;DEFAULT_BUNDLE&amp;#39;.&lt;br/&gt;
	at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.IndexChanger.insertAndCheckDups(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.IndexChanger.doInsert(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.IndexChanger.insert(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.IndexSetChanger.insert(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.RowChangerImpl.insertRow(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.execute.InsertResultSet.open(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)&lt;br/&gt;
	at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(Unknown Source)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:371)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal(ConnectionRecoveryManager.java:298)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:261)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt(ConnectionRecoveryManager.java:239)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.storeBundle(BundleDbPersistenceManager.java:1209)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.putBundle(AbstractBundlePersistenceManager.java:709)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.storeInternal(AbstractBundlePersistenceManager.java:651)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.store(AbstractBundlePersistenceManager.java:527)&lt;br/&gt;
	at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.store(BundleDbPersistenceManager.java:563)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:724)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1101)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:351)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:354)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:326)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1098)&lt;br/&gt;
	at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:925)&lt;br/&gt;
	at org.apache.jackrabbit.core.ConcurrentImportTest$1.execute(ConcurrentImportTest.java:73)&lt;br/&gt;
	at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:209)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:637)&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12433728">JCR-2272</key>
            <summary>Errors during concurrent session import of nodes with same UUIDs</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="tripod">Tobias Bocanegra</reporter>
                        <labels>
                    </labels>
                <created>Fri, 21 Aug 2009 21:49:20 +0100</created>
                <updated>Tue, 8 Nov 2011 15:47:02 +0000</updated>
                    <resolved>Tue, 27 Sep 2011 20:58:47 +0100</resolved>
                            <version>2.0-alpha8</version>
                                <fixVersion>2.2.9</fixVersion>
                                <component>jackrabbit-core</component>
                <component>xml</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12746220" author="tripod" created="Fri, 21 Aug 2009 21:50:55 +0100"  >Added org/apache/jackrabbit/core/ConcurrentImportTest.java that reproduces this issue.&lt;br/&gt;
</comment>
                    <comment id="12748371" author="stefan@jira" created="Thu, 27 Aug 2009 14:47:52 +0100"  >attached a patch which causes an InvaliditemStateException to be thrown on coliding node creations&lt;br/&gt;
&lt;br/&gt;
ConcurrentImportTest.testConcurrentImport fails now with an InvalidItemStateException (as expected); the test should IMO be fixed.&lt;br/&gt;
&lt;br/&gt;
ConcurrentImportTest.testConcurrentImportVersionable fails now with a VersionException (History already exists ...);&lt;br/&gt;
i am not sure whether that&amp;#39;s a VersionManager issue.</comment>
                    <comment id="12749482" author="stefan@jira" created="Mon, 31 Aug 2009 14:05:19 +0100"  >revised patch</comment>
                    <comment id="12753663" author="dpfister" created="Thu, 10 Sep 2009 16:32:30 +0100"  >Applying the revised patch exposes another problem with an ItemState&amp;#39;s internal data object, which results in a NullPointerException when a session tries to modify an item that has been destroyed concurrently by another session.&lt;br/&gt;
&lt;br/&gt;
Submitting a cumulative patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2272&quot; title=&quot;Errors during concurrent session import of nodes with same UUIDs&quot;&gt;&lt;strike&gt;JCR-2272&lt;/strike&gt;&lt;/a&gt;_NPE.patch) that fixes this issue and lets ConcurrentImportTest throw an unexpected exception - such as NPE - again as RepositoryException.</comment>
                    <comment id="12766552" author="stefan@jira" created="Fri, 16 Oct 2009 15:52:06 +0100"  >adapted patch to current trunk (r825918)&lt;br/&gt;
&lt;br/&gt;
however, applying the patch causes a test failure:&lt;br/&gt;
&lt;br/&gt;
-------------------------------------------------------------------------------&lt;br/&gt;
Test set: org.apache.jackrabbit.core.integration.JCRAPITest&lt;br/&gt;
-------------------------------------------------------------------------------&lt;br/&gt;
Tests run: 1895, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 47.385 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!&lt;br/&gt;
testUpdate(org.apache.jackrabbit.test.api.NodeTest)  Time elapsed: 0.015 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!&lt;br/&gt;
javax.jcr.RepositoryException: org.apache.jackrabbit.core.state.StaleItemStateException: d1edb4c2-a258-4fe4-864b-1bb73252b55f has been created externally&lt;br/&gt;
	at org.apache.jackrabbit.core.VersionManagerImpl.mergeOrUpdate(VersionManagerImpl.java:350)&lt;br/&gt;
	at org.apache.jackrabbit.core.VersionManagerImpl.update(VersionManagerImpl.java:287)&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeImpl.update(NodeImpl.java:3126)&lt;br/&gt;
	at org.apache.jackrabbit.test.api.NodeTest.testUpdate(NodeTest.java:305)&lt;br/&gt;
Caused by: org.apache.jackrabbit.core.state.StaleItemStateException: d1edb4c2-a258-4fe4-864b-1bb73252b55f has been created externally&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:677)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1087)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1117)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:351)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:354)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:326)&lt;br/&gt;
	at org.apache.jackrabbit.core.version.VersionManagerImplBase$WriteOperation.save(VersionManagerImplBase.java:463)&lt;br/&gt;
	at org.apache.jackrabbit.core.version.VersionManagerImplMerge.merge(VersionManagerImplMerge.java:109)&lt;br/&gt;
	at org.apache.jackrabbit.core.VersionManagerImpl.mergeOrUpdate(VersionManagerImpl.java:348)&lt;br/&gt;
	... 23 more&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12773158" author="jukkaz" created="Tue, 3 Nov 2009 20:08:57 +0000"  >See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2295&quot; title=&quot;Occasional query test failures&quot;&gt;&lt;strike&gt;JCR-2295&lt;/strike&gt;&lt;/a&gt; for an occasional query test failure that was caused by the ConcurrentImportTest class introduced here. Marcel disabled the test in revision 812032.</comment>
                    <comment id="13095286" author="reschke" created="Thu, 1 Sep 2011 14:24:35 +0100"  >The last patch applies against trunk if &lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;public static final int STATUS_STALE_MODIFIED = 5;&lt;br/&gt;
&lt;br/&gt;
gets re-added (not sure about the rational for removing it).&lt;br/&gt;
&lt;br/&gt;
Confirming that testUpdate fails.&lt;br/&gt;
&lt;br/&gt;
I also get four failures in the ShareableNodesTests.</comment>
                    <comment id="13095291" author="stefan@jira" created="Thu, 1 Sep 2011 14:34:10 +0100"  >as of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2650&quot; title=&quot;don&amp;#39;t silently merge session-local transient changes with external changes before save().&quot;&gt;&lt;strike&gt;JCR-2650&lt;/strike&gt;&lt;/a&gt; STATUS_STALE_MODIFIED is not applicable anymore </comment>
                    <comment id="13095965" author="reschke" created="Fri, 2 Sep 2011 14:13:37 +0100"  >&amp;gt; I also get four failures in the ShareableNodesTests. &lt;br/&gt;
&lt;br/&gt;
Apparently known issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2756&quot; title=&quot;Shareable node test failures&quot;&gt;JCR-2756&lt;/a&gt;) - was running from Eclipse.&lt;br/&gt;
&lt;br/&gt;
Stefan:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; as of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2650&quot; title=&quot;don&amp;#39;t silently merge session-local transient changes with external changes before save().&quot;&gt;&lt;strike&gt;JCR-2650&lt;/strike&gt;&lt;/a&gt; STATUS_STALE_MODIFIED is not applicable anymore &lt;br/&gt;
&lt;br/&gt;
So is there another state that could be used? I tried STATUS_UNDEFINED which seems to yield exactly the same result.</comment>
                    <comment id="13095973" author="reschke" created="Fri, 2 Sep 2011 14:26:02 +0100"  >Patch updated for trunk, with STATUS_STALE_MODIFIED replaced by STATUS_UNDEFINED.&lt;br/&gt;
&lt;br/&gt;
The problem in NodeTest.testUpdate remains, though.</comment>
                    <comment id="13097169" author="reschke" created="Mon, 5 Sep 2011 16:04:32 +0100"  >NodeTest.testUpdate fails. because the update operation happens on a node which has an additional child node in the workspace the update() imports from. This node handled as addedState and detected as status != STATUS_NEW, thus the operation fails.&lt;br/&gt;
&lt;br/&gt;
Wild guess: maybe the update/merge code needs to create a NodeState with a different status here?</comment>
                    <comment id="13097951" author="reschke" created="Tue, 6 Sep 2011 13:18:45 +0100"  >Stefan wrote:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; ConcurrentImportTest.testConcurrentImportVersionable fails now with a VersionException (History already exists ...);&lt;br/&gt;
i am not sure whether that&amp;#39;s a VersionManager issue. &lt;br/&gt;
&lt;br/&gt;
I think it&amp;#39;s correct that an exception occurs here; the question seems to be mainly whether it&amp;#39;s the correct exception to throw, and whether the save() operation is properly aborted...&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13098031" author="reschke" created="Tue, 6 Sep 2011 15:29:43 +0100"  >Proposed patch.</comment>
                    <comment id="13098037" author="reschke" created="Tue, 6 Sep 2011 15:36:06 +0100"  >Summary so far:&lt;br/&gt;
&lt;br/&gt;
- the problem on update() was caused by the node state of the new node being flipped from NEW to EXISTING_MODIFIED while removing the jcr:mixins property (which apparently isn&amp;#39;t seen on the source node, not sure why); the pattern to change the state only for != NEW was already common in NodeStateEx, so it was probably an oversight that it wasn&amp;#39;t followed in this case as well.&lt;br/&gt;
&lt;br/&gt;
- the change for ItemStateManager used STATUS_STALE_MODIFIED previously which has been removed in the meantime; somebody needs to have a look whether STATUS_UNDEFINED is correct here&lt;br/&gt;
&lt;br/&gt;
...ConcurrentImportTests:&lt;br/&gt;
&lt;br/&gt;
- these had be excluded (both in pom.xml and not being added in TestAll) before.&lt;br/&gt;
&lt;br/&gt;
-- testConcurrentImport works for me *in Eclipse* when I move addNode(test, uuid, JcrConstants.NT_UNSTRUCTURED, uuid, mixins); inside the try block (so the exception happens early; before save). It doesn&amp;#39;t work for me when run from Maven (me confused)&lt;br/&gt;
&lt;br/&gt;
- testConcurrentImportVersionable aborts as it should, but with a VersioningException instead of the expected StaleItemException; not sure how we should address this (tune the test expectation?)</comment>
                    <comment id="13098808" author="mreutegg" created="Wed, 7 Sep 2011 10:33:47 +0100"  >What is the reason for the change in the ItemManager?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; STATUS_UNDEFINED&lt;br/&gt;
&lt;br/&gt;
This doesn&amp;#39;t sound correct, but all other alternative seem inappropriate as well.&lt;br/&gt;
&lt;br/&gt;
Maybe we should introduce a STATUS_STALE_NEW? After all, the node is still new because it had been added. We just want to make sure it isn&amp;#39;t persisted.</comment>
                    <comment id="13098811" author="mreutegg" created="Wed, 7 Sep 2011 10:37:34 +0100"  >&amp;gt; STATUS_UNDEFINED&lt;br/&gt;
&lt;br/&gt;
On the other hand, we also use it in ItemState.discard(). So, the status isn&amp;#39;t just used as default value for uninitialized ItemState.</comment>
                    <comment id="13098847" author="reschke" created="Wed, 7 Sep 2011 12:08:39 +0100"  >&amp;gt; What is the reason for the change in the ItemManager? &lt;br/&gt;
&lt;br/&gt;
Dunno; it seems it was added by Dominique in the 2009-09-10 patch.</comment>
                    <comment id="13099099" author="reschke" created="Wed, 7 Sep 2011 18:04:38 +0100"  >Running ConcurrentImportTest.testConcurrentImport some more I still see various different, non-reproducible exceptions (not entirely surprisingly given the nature of the test).&lt;br/&gt;
&lt;br/&gt;
We probably need to go through each of them and decide whether they are just cases where the wrong exception is thrown, or whether there&amp;#39;s an issue left.&lt;br/&gt;
&lt;br/&gt;
I think it would make sense to add code that tests for the repository corruption we&amp;#39;re after. Is there something more elegant than doing a query for all nodes, and checking getPath() on each of them?</comment>
                    <comment id="13102648" author="reschke" created="Mon, 12 Sep 2011 14:34:21 +0100"  >...attached a new patch that (a) attempts to explain why we set the state &amp;quot;UNDEFINED&amp;quot;, and (b) adds a sanity check to the test case for a subsequent save() after a failed save().&lt;br/&gt;
&lt;br/&gt;
The remaining issues still are:&lt;br/&gt;
&lt;br/&gt;
- how do we in general test for RM corruption&lt;br/&gt;
- fix the remaining test failures (are these acceptable or do they need more tests and fixes?)&lt;br/&gt;
</comment>
                    <comment id="13103432" author="mreutegg" created="Tue, 13 Sep 2011 08:44:45 +0100"  >&amp;gt; (b) adds a sanity check to the test case for a subsequent save() &lt;br/&gt;
&lt;br/&gt;
the session.save() must happen before the session.refresh(), otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in the Task thread must be reported back to the main test thread, which then calls fail.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; how do we in general test for RM corruption&lt;br/&gt;
&lt;br/&gt;
This is a more general problem with the checkConsistency() method on the PersistenceManager. It does not have a return value, nor does it throw an exception when it detects inconsistencies. I think we should open a new issue about this.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; fix the remaining test failures&lt;br/&gt;
&lt;br/&gt;
Are there other test failures other than &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3068&quot; title=&quot;IMPORT_UUID_COLLISION_REPLACE_EXISTING import should not fail for duplicate UUIDs&quot;&gt;JCR-3068&lt;/a&gt;?</comment>
                    <comment id="13103454" author="reschke" created="Tue, 13 Sep 2011 09:24:34 +0100"  >&amp;gt;the session.save() must happen before the session.refresh(), otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in&lt;br/&gt;
&amp;gt; the Task thread must be reported back to the main test thread, which then calls fail.&lt;br/&gt;
&lt;br/&gt;
Indeed. Will fix.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;This is a more general problem with the checkConsistency() method on the PersistenceManager. It does not have a return value, nor does it throw an exception when it detects inconsistencies. I think we should&lt;br/&gt;
&amp;gt; open a new issue about this.&lt;br/&gt;
&lt;br/&gt;
Will open a separate ticket for this TODO.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Are there other test failures other than &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3068&quot; title=&quot;IMPORT_UUID_COLLISION_REPLACE_EXISTING import should not fail for duplicate UUIDs&quot;&gt;JCR-3068&lt;/a&gt;? &lt;br/&gt;
&lt;br/&gt;
(1) ConcurrentImportTest occasionally falls with other exceptions.&lt;br/&gt;
(2) ConcurrentImportTest.testConcurrentImportVersionable fails with VersionException /History already exists) and we need to decide whether this is ok, Given the fact that in theory the save operation should not fail at all (see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3068&quot; title=&quot;IMPORT_UUID_COLLISION_REPLACE_EXISTING import should not fail for duplicate UUIDs&quot;&gt;JCR-3068&lt;/a&gt;) we probably can treat it like the other exception for now.</comment>
                    <comment id="13103542" author="mreutegg" created="Tue, 13 Sep 2011 12:30:21 +0100"  >I agree, the version history issue probably has the same root cause.&lt;br/&gt;
&lt;br/&gt;
It would be nice when the test did not throw an exception at all, but I don&amp;#39;t consider this a critical issue right now. The use case is IMO rather theoretical and an application could still handle the exception caused by a concurrent import.&lt;br/&gt;
&lt;br/&gt;
I think the important part of this issue is to make sure the repository keeps consistent.</comment>
                    <comment id="13103568" author="reschke" created="Tue, 13 Sep 2011 13:06:21 +0100"  >&amp;gt; the session.save() must happen before the session.refresh(), otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in the Task thread must be reported back to the main test thread, which then calls fail.&lt;br/&gt;
&lt;br/&gt;
Updated the test so it doesn&amp;#39;t use fail(), and does the 2nd save() without a refresh, Surprise (or not): the subsequent save() actually *succeeds*. This is not that surprising, as we have a race condition, and the save() should have succeeded anyway.</comment>
                    <comment id="13103687" author="reschke" created="Tue, 13 Sep 2011 16:20:23 +0100"  >More observations:&lt;br/&gt;
&lt;br/&gt;
- concurrent import fails with different kinds of RepositoryExceptions, not only InvalidItemStateExceptions -- as, for this case, there shouldn&amp;#39;t be any exceptions, it seems to be ok to allow all kinds of RepositoryExceptions for now, and address this problem later on&lt;br/&gt;
&lt;br/&gt;
- exceptions sometimes happen before save() and thus are not accepted; I think that behavior is ok, so we should move addNode() into the try block&lt;br/&gt;
&lt;br/&gt;
The most important issue continues to fix those exceptions which are caused by the attempt to add a node to the persistence although it is already there (on the PersistenceManager level); we should (a) change BundleDBPersistenceManager to produce a more useful exception in this case, and (b) in the test case follow the exception chain checking for an SQLIntegrityViolationException, treating that as a test failure.&lt;br/&gt;
&lt;br/&gt;
Patch follow -- with that patch, we still see occasional failures, and we probably need to dig deeper.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13105466" author="reschke" created="Thu, 15 Sep 2011 17:23:20 +0100"  >Updated patch; now aborts suspicious call into BundleDBPersistenceManager; running ConcurrentImportTest frequently enough still causes this (constraint violations on the DB level) to happen.</comment>
                    <comment id="13107781" author="reschke" created="Mon, 19 Sep 2011 13:32:52 +0100"  >Traces, obtained by adding debug output to various places.&lt;br/&gt;
&lt;br/&gt;
It shows that the new code in LocalItemStateManager does not catch the change done in thread 1 as thread 1&amp;#39;s beginUpdate happens too late.</comment>
                    <comment id="13107852" author="reschke" created="Mon, 19 Sep 2011 15:21:03 +0100"  >Another trace, now logging the downgrade of the write log as well.&lt;br/&gt;
&lt;br/&gt;
Note that threads 1 and 2 finish before 0 and 3 start; so it&amp;#39;s only two threads (0 and 3) involved here.</comment>
                    <comment id="13108699" author="jukkaz" created="Tue, 20 Sep 2011 14:22:58 +0100"  >The latest patch looks like a reasonable step forward. I&amp;#39;ll try to review the attached traces to better understand also the deeper interactions here. Meanwhile, some comments:&lt;br/&gt;
&lt;br/&gt;
* The SQLIntegrityConstraintViolationException class is only available since Java 6. As an alternative we could try to interpret the value returned by the SQLException.getSQLState() method.&lt;br/&gt;
&lt;br/&gt;
* I couldn&amp;#39;t get the ConcurrentImportTest to fail with the latest patch despite numerous attempts, but that might be just due to my pretty fast server and the relatively low level of concurrency in the test case. Or then everything is just fine. :-)&lt;br/&gt;
&lt;br/&gt;
* What I do see instead is plenty of warnings like the following. I didn&amp;#39;t check yet if this is because of the changes in the patch or something we&amp;#39;d in any case need to fix.&lt;br/&gt;
&lt;br/&gt;
15:01:43.975 WARN  [Executor 0] ItemSaveOperation.java:885  /testroot/9afd33fd-b66d-4c8f-9d02-0fe16245d0bc/jcr:mixinTypes: failed to restore transient state&lt;br/&gt;
javax.jcr.RepositoryException: org.apache.jackrabbit.core.state.ItemStateException: there&amp;#39;s already a property state instance with id 9afd33fd-b66d-4c8f-9d02-0fe16245d0bc/{&lt;a href=&quot;http://www.jcp.org/jcr/1.0&quot;&gt;http://www.jcp.org/jcr/1.0&lt;/a&gt;}mixinTypes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.PropertyImpl.restoreTransient(PropertyImpl.java:197) ~[classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemSaveOperation.restoreTransientItems(ItemSaveOperation.java:879) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemSaveOperation.perform(ItemSaveOperation.java:277) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemImpl.perform(ItemImpl.java:91) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:329) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionSaveOperation.perform(SessionSaveOperation.java:64) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.perform(SessionImpl.java:360) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:809) [classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ConcurrentImportTest$1.execute(ConcurrentImportTest.java:95) [test-classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:209) [test-classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.Thread.run(Thread.java:662) [na:1.6.0_23]&lt;br/&gt;
Caused by: org.apache.jackrabbit.core.state.ItemStateException: there&amp;#39;s already a property state instance with id 9afd33fd-b66d-4c8f-9d02-0fe16245d0bc/{&lt;a href=&quot;http://www.jcp.org/jcr/1.0&quot;&gt;http://www.jcp.org/jcr/1.0&lt;/a&gt;}mixinTypes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.state.SessionItemStateManager.createTransientPropertyState(SessionItemStateManager.java:631) ~[classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.PropertyImpl.restoreTransient(PropertyImpl.java:191) ~[classes/:na]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;... 12 common frames omitted&lt;br/&gt;
</comment>
                    <comment id="13108706" author="reschke" created="Tue, 20 Sep 2011 14:33:09 +0100"  >&amp;gt; The SQLIntegrityConstraintViolationException class is only available since Java 6. As an alternative we could try to interpret the value returned by the SQLException.getSQLState() method.&lt;br/&gt;
&lt;br/&gt;
Will fix.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I couldn&amp;#39;t get the ConcurrentImportTest to fail with the latest patch despite numerous attempts, but that might be just due to my pretty fast server and the relatively low level of concurrency in the test case. Or then everything is just fine. :-) &lt;br/&gt;
&lt;br/&gt;
On my test machine, it usually requires &amp;gt; 10 iterations.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; What I do see instead is plenty of warnings like the following. I didn&amp;#39;t check yet if this is because of the changes in the patch or something we&amp;#39;d in any case need to fix. &lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t believe I have seen those; will pay attention.</comment>
                    <comment id="13108748" author="jukkaz" created="Tue, 20 Sep 2011 15:40:41 +0100"  >I created the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2272&quot; title=&quot;Errors during concurrent session import of nodes with same UUIDs&quot;&gt;&lt;strike&gt;JCR-2272&lt;/strike&gt;&lt;/a&gt; branch for this so we can better exchange code until the tests no longer fail and we can merge the work back to trunk. In revision 117316 I committed your latest patch to the branch and in revision 1173169 I broke the Java 6 dependency.</comment>
                    <comment id="13109393" author="jukkaz" created="Wed, 21 Sep 2011 11:26:54 +0100"  >There&amp;#39;s a pretty nasty case of an IllegalStateException (a RuntimeException) being thrown by ItemState.connect() when it detects an inconsistency caused by this problem. To make such issues more visible and easier to catch I changed the exception to an ItemStateException in revision 1173558 of the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2272&quot; title=&quot;Errors during concurrent session import of nodes with same UUIDs&quot;&gt;&lt;strike&gt;JCR-2272&lt;/strike&gt;&lt;/a&gt; branch.&lt;br/&gt;
&lt;br/&gt;
One very troublesome effect of that exception is that it can cause a repository deadlock since the cluster lock never gets released in SISM.Update.end() when the exception gets thrown from within the ChangeLog.persisted() call. I&amp;#39;ll look into making the cluster lock handling more robust (move the unlocking to a finally block) before digging deeper into this consistency problem.</comment>
                    <comment id="13109635" author="jukkaz" created="Wed, 21 Sep 2011 17:35:16 +0100"  >See revisions 1173578 and 1173579 for the changes required to prevent an unexpected exception from locking the entire cluster.&lt;br/&gt;
&lt;br/&gt;
I digged deeper into this problem and I think I now have a pretty good idea of what goes wrong. When a session creates a node with an explicitly given UUID, it can be that the new transient NodeState gets created right after some other thread has persisted another node with the exact same UUID. In such a case the new NodeState doesn&amp;#39;t necessarily receive notifications about the other node having been created and thus its status is still STATUS_NEW. &lt;br/&gt;
&lt;br/&gt;
The attached patch contains an initial patch that attempts to prevent such cases by explicitly checking the underlying persistence manager for duplicate ids once a new NodeState has already been connected to the state notification mechanism. This check is only done when a predefined UUID is used, so it shouldn&amp;#39;t affect performance too badly, though I&amp;#39;ll still need to check how the creation of the localState instance in NodeImpl.makePersistent() affects this assumption (since there the id of a transient node gets copied).&lt;br/&gt;
&lt;br/&gt;
The patch passes all tests and as far as I can tell fixes also the ConcurrentImportTest. However, it&amp;#39;s a pretty complex change, so code reviews would be welcome.</comment>
                    <comment id="13112442" author="jukkaz" created="Thu, 22 Sep 2011 10:32:21 +0100"  >I committed the proposed patch to the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2272&quot; title=&quot;Errors during concurrent session import of nodes with same UUIDs&quot;&gt;&lt;strike&gt;JCR-2272&lt;/strike&gt;&lt;/a&gt; branch in revision 1174016. In the followup revision 1174017 I fixed a problem for handling of transient spaces that both remove and add a node with the same UUID. The followup revision also avoids the duplicate id checks in NodeImp.makePersistent(), which should prevent the extra performance hit.</comment>
                    <comment id="13112578" author="reschke" created="Thu, 22 Sep 2011 14:47:09 +0100"  >It seems to me that the changes really help, but I still see occasional failures; from running ConcurrentImportTest in a loop I&amp;#39;d say it happen roughly 2% of the time.</comment>
                    <comment id="13112623" author="reschke" created="Thu, 22 Sep 2011 15:35:59 +0100"  >With the current code, I see occasional NPEs such as:&lt;br/&gt;
&lt;br/&gt;
Exception in thread &amp;quot;Executor 0&amp;quot; java.lang.NullPointerException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemSaveOperation.validateTransientItems(I&lt;br/&gt;
temSaveOperation.java:493)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemSaveOperation.perform(ItemSaveOperatio&lt;br/&gt;
n.java:216)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionState.perform(SessionState.&lt;br/&gt;
java:200)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemImpl.perform(ItemImpl.java:91)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:329)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionSaveOperation.perform(Sessi&lt;br/&gt;
onSaveOperation.java:64)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionState.perform(SessionState.&lt;br/&gt;
java:200)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.perform(SessionImpl.java:360)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:809)&lt;br/&gt;
&lt;br/&gt;
or&lt;br/&gt;
&lt;br/&gt;
Exception in thread &amp;quot;Executor 1&amp;quot; java.lang.NullPointerException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemManager.getDefinition(ItemManager.java&lt;br/&gt;
:206)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ItemData.getDefinition(ItemData.java:99)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.AbstractNodeData.getNodeDefinition(Abstrac&lt;br/&gt;
tNodeData.java:73)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.NodeImpl.getDefinition(NodeImpl.java:2423)&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.xml.SessionImporter.startNode(SessionImpor&lt;br/&gt;
ter.java:349)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.xml.SysViewImportHandler.processNode(SysVi&lt;br/&gt;
ewImportHandler.java:94)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.xml.SysViewImportHandler.endElement(SysVie&lt;br/&gt;
wImportHandler.java:249)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.xml.ImportHandler.endElement(ImportHandler&lt;br/&gt;
.java:195)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ConcurrentImportTest.addNode(ConcurrentImp&lt;br/&gt;
ortTest.java:200)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.ConcurrentImportTest$1.execute(ConcurrentI&lt;br/&gt;
mportTest.java:95)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(Abstr&lt;br/&gt;
actConcurrencyTest.java:209)</comment>
                    <comment id="13113495" author="jukkaz" created="Fri, 23 Sep 2011 16:08:36 +0100"  >To solve &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3063&quot; title=&quot;NullPointerException in ItemManager&quot;&gt;&lt;strike&gt;JCR-3063&lt;/strike&gt;&lt;/a&gt; it looks like we may need to revert the changes of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2171&quot; title=&quot;Deadlock in SharedItemStateManager on session.move and node.save&quot;&gt;&lt;strike&gt;JCR-2171&lt;/strike&gt;&lt;/a&gt;. That shouldn&amp;#39;t be a problem since Stefan has meanwhile modified how transient items are handled and the original deadlock scenario of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2171&quot; title=&quot;Deadlock in SharedItemStateManager on session.move and node.save&quot;&gt;&lt;strike&gt;JCR-2171&lt;/strike&gt;&lt;/a&gt; should no longer be possible.&lt;br/&gt;
&lt;br/&gt;
Reverting &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2171&quot; title=&quot;Deadlock in SharedItemStateManager on session.move and node.save&quot;&gt;&lt;strike&gt;JCR-2171&lt;/strike&gt;&lt;/a&gt; should help also here, as doing so would move the troublesome item state notifications back inside the SISM write lock.</comment>
                    <comment id="13115861" author="jukkaz" created="Tue, 27 Sep 2011 20:58:47 +0100"  >Together with &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3063&quot; title=&quot;NullPointerException in ItemManager&quot;&gt;&lt;strike&gt;JCR-3063&lt;/strike&gt;&lt;/a&gt; (that explains the above NPEs) and some last touches I added in revision 1176545 I think we&amp;#39;re pretty much done here. I merged the branch work back to trunk in revision 1176546.&lt;br/&gt;
&lt;br/&gt;
I also merged the changes back to the 2.2 branch in revision 1176577 for inclusion in the 2.2.9 release.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12434818">JCR-2295</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12519973">JCR-3063</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12495398" name="0001-JCR-2272-Errors-during-concurrent-session-import-of-.patch" size="18521" author="jukkaz" created="Wed, 21 Sep 2011 17:35:16 +0100" />
                    <attachment id="12492740" name="2272.patch" size="4327" author="reschke" created="Fri, 2 Sep 2011 14:26:02 +0100" />
                    <attachment id="12422356" name="JCR-2272__Errors_during_concurrent_session_import_of_nodes_with_same_UUIDs.patch" size="5059" author="stefan@jira" created="Fri, 16 Oct 2009 15:52:06 +0100" />
                    <attachment id="12419184" name="JCR-2272_NPE.patch" size="5148" author="dpfister" created="Thu, 10 Sep 2009 16:32:30 +0100" />
                    <attachment id="12417879" name="JCR-2272.patch" size="7819" author="stefan@jira" created="Thu, 27 Aug 2009 14:47:52 +0100" />
                    <attachment id="12418141" name="JCR-2272_revised.patch" size="3924" author="stefan@jira" created="Mon, 31 Aug 2009 14:05:19 +0100" />
                    <attachment id="12494026" name="JCR2272.Sep12.patch" size="5699" author="reschke" created="Mon, 12 Sep 2011 14:31:30 +0100" />
                    <attachment id="12494248" name="JCR2272.Sep13b.patch" size="10485" author="reschke" created="Tue, 13 Sep 2011 16:21:33 +0100" />
                    <attachment id="12494220" name="JCR2272.Sep13.patch" size="5857" author="reschke" created="Tue, 13 Sep 2011 13:04:06 +0100" />
                    <attachment id="12494644" name="JCR2272.Sep15.patch" size="10536" author="reschke" created="Thu, 15 Sep 2011 17:23:20 +0100" />
                    <attachment id="12493153" name="JCR2272.Sep6.patch" size="4361" author="reschke" created="Tue, 6 Sep 2011 15:29:43 +0100" />
                    <attachment id="12495055" name="t4.html" size="5098" author="reschke" created="Mon, 19 Sep 2011 13:32:52 +0100" />
                    <attachment id="12495056" name="t4.txt" size="2456" author="reschke" created="Mon, 19 Sep 2011 13:32:52 +0100" />
                    <attachment id="12495074" name="t5.txt" size="2783" author="reschke" created="Mon, 19 Sep 2011 15:21:03 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>14.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 27 Aug 2009 13:47:52 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>33622</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231742</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>