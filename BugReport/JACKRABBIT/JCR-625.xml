<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:32:02 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-625/JCR-625.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-625] Memory is not freed up when jackrabbit-server war is redeployed in tomcat</title>
                <link>https://issues.apache.org/jira/browse/JCR-625</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>This bug was introduced with the new CacheManager feature. See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-619&quot; title=&quot;CacheManager (Memory Management in Jackrabbit)&quot;&gt;&lt;strike&gt;JCR-619&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
The CacheManager starts a new background thread which optimizes memory distribution every second accross the various caches. When a jackrabbit repository is shutdown, this background thread is still running and prevents the GC from collecting the classloader when jackrabbit is deployed in a web application.&lt;br/&gt;
&lt;br/&gt;
Steps to reproduce:&lt;br/&gt;
1) build jackrabbit and jcr-server from trunk and deploy into a tomcat&lt;br/&gt;
2) touch the web.xml file of the jcr-server web app (this will force a redeployment)&lt;br/&gt;
&lt;br/&gt;
After step 2 two things may happen. Either:&lt;br/&gt;
- The memory consumption increases because the CacheManager thread is not shutdown&lt;br/&gt;
or&lt;br/&gt;
- The CacheManager thread dies unexpectedly with a NullPointerException:&lt;br/&gt;
&lt;br/&gt;
Exception in thread &amp;quot;org.apache.jackrabbit.core.state.CacheManager&amp;quot; java.lang.NullPointerException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.state.CacheManager.run(CacheManager.java:90)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.Thread.run(Unknown Source)</description>
                <environment>No released version is affected, only trunk: svn revision 471800.</environment>
            <key id="12354913">JCR-625</key>
            <summary>Memory is not freed up when jackrabbit-server war is redeployed in tomcat</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="tmueller">Thomas Mueller</assignee>
                                <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Tue, 7 Nov 2006 10:07:18 +0000</created>
                <updated>Wed, 5 Mar 2008 14:35:48 +0000</updated>
                    <resolved>Tue, 18 Sep 2007 08:57:42 +0100</resolved>
                                                            <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12447756" author="tmueller" created="Tue, 7 Nov 2006 11:38:09 +0000"  >Obviously, this is really bad. It didn&amp;#39;t help to make it a daemon thread, and to use a WeakHashMap. I will change the CacheManager: instead of being a singleton, the CacheManager will be associated with a PersistentManager (or Repository). And the thread must be stopped when the PersistentManager / Repository is closed. This should solve the problem. Unfortunately, it will be harder to avoid OutOfMemory if many repositories are open at the same time, but this is probably not that big a problem.&lt;br/&gt;
&lt;br/&gt;
Thomas</comment>
                    <comment id="12447783" author="mreutegg" created="Tue, 7 Nov 2006 13:18:03 +0000"  >How about starting the background thread only when there are caches to manage? Or stop the background thread when there are no more caches to manage respectively?</comment>
                    <comment id="12447841" author="tmueller" created="Tue, 7 Nov 2006 16:09:36 +0000"  >Starting / stopping the CacheManager thread on demand would probably be a solution, I didn&amp;#39;t think about this. The singleton pattern would still not work when using different class loaders. Also, configuring the cache size per repository is not possible. I made a patch to keep the cache managers in the RepositoryImpl. Unfortunately, this means adding it to many constructors. The test case with the jcr-server works now (the unit tests work as well).</comment>
                    <comment id="12447843" author="tmueller" created="Tue, 7 Nov 2006 16:11:09 +0000"  >CacheManager in the RepositoryImpl</comment>
                    <comment id="12447853" author="jukkaz" created="Tue, 7 Nov 2006 16:41:11 +0000"  >I don&amp;#39;t really like the idea of having to use a separate thread to do this. Can&amp;#39;t the various caches just call the CacheManager whenever an object is placed in the cache. You can amortize the performance hit by requesting reallocation only every N caching operations. This structure would avoid the need to manage a separate thread.&lt;br/&gt;
&lt;br/&gt;
Also, it would be cleaner if you passed around a factory object instead of the CacheManager. That would make it much easier to plug in alternative caching behaviours. Something like this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public interface ItemStateCacheFactory {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ItemStateCache newItemStateCache();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
and:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public class ManagedMLRUItemStateCacheFactory {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private final CacheManager manager;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public ManagedCacheFactory(CacheManager manager) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.manager = manager;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public ItemStateCache newItemStateCache() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ItemStateCache cache = new MLRUItemStateCache();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;manager.add(cache);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return cache;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                    <comment id="12448082" author="jukkaz" created="Wed, 8 Nov 2006 09:23:56 +0000"  >A simpler alternative to using the factory pattern would be to pull the instantiation of the cache as high up the call chain as possible. It would still be cleaner to pass the cache instance to an ItemStateManager than the CacheManager, since the manager is really a detail of the cache implementation and should not be exposed to other components like the ItemStatemanagers.</comment>
                    <comment id="12448434" author="tmueller" created="Thu, 9 Nov 2006 11:21:26 +0000"  >Hi,&lt;br/&gt;
&lt;br/&gt;
As requested by Jukka Zitting, I made a few changes to the cache manager. There is no new functionality, and the current behaviour changed only very slightly:&lt;br/&gt;
&lt;br/&gt;
Instead of passing the CacheManager to various constructors, now an ItemStateCacheFactory is passed (this is a new interface, and there is a single new class implementing this interface, ManagedMLRUItemStateCacheFactory).&lt;br/&gt;
&lt;br/&gt;
Now the caches calls the CacheManager from time to time (each time a cache was accessed 128 more times). This is not done directly, but using a new interface CacheAccessListener. The CacheManager is the only class implementing this interface. The CacheManager then checks if it&amp;#39;s time to resize the caches (this is done at most every second). There is no more cache manager thread. The disadvantages are: The caches will not shrink if none of them is accessed, or accessed infrequently. And there is a (very small) overhead on each cache access.&lt;br/&gt;
&lt;br/&gt;
Again, for me the CacheManager is a workaround. I hope we can soon replace this with a (more) unified cache. &lt;br/&gt;
&lt;br/&gt;
Thomas</comment>
                    <comment id="12449305" author="tmueller" created="Mon, 13 Nov 2006 10:37:36 +0000"  >The CacheManager slows a few things down at the moment, for example the unit tests. I found the problem: The caches are never disposed, and therefore the CacheManager sometimes has a lot of caches to manage (at one point in the unit test over 3000). Garbage collection will eventually reclaim the unused objects (the CacheManager uses a WeakHashMap), so this is not a memory problem. I will submit a patch later today.</comment>
                    <comment id="12528290" author="tmueller" created="Tue, 18 Sep 2007 08:57:42 +0100"  >As far as I know, this problem has been fixed since a long time. Please reopen if not.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310010">
                <name>Incorporates</name>
                                                <inwardlinks description="is part of">
                            <issuelink>
            <issuekey id="12354673">JCR-619</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12344491" name="cacheManager3.txt" size="17049" author="tmueller" created="Tue, 7 Nov 2006 16:11:09 +0000" />
                    <attachment id="12344661" name="cacheManager4.txt" size="35343" author="tmueller" created="Thu, 9 Nov 2006 11:21:26 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 7 Nov 2006 11:38:09 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142282</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>252849</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>