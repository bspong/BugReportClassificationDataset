<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:59:07 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1753/JCR-1753.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1753] Allow means force a Repository to synchronize with the cluster</title>
                <link>https://issues.apache.org/jira/browse/JCR-1753</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Based on the thread on the user mailing list I&amp;#39;m logging this to propose adding a sync() method to force cluster synchronization using the JackrabbitRepository extension API.&lt;br/&gt;
&lt;br/&gt;
The purpose of the method is such that in a distributed clustered environment sometime cluster synchronization does or has not occurred such that certain repositories are in a stale state.  This method would provide a means to force a repository to update pull in possible changes made by other Jackrabbit repositories.&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12404904">JCR-1753</key>
            <summary>Allow means force a Repository to synchronize with the cluster</summary>
                <type id="2" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png">New Feature</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="mkwhitacre">Micah Whitacre</reporter>
                        <labels>
                    </labels>
                <created>Mon, 22 Sep 2008 20:51:20 +0100</created>
                <updated>Thu, 13 Aug 2009 16:03:39 +0100</updated>
                    <resolved>Wed, 8 Jul 2009 17:25:39 +0100</resolved>
                                            <fixVersion>1.6</fixVersion>
                                <component>clustering</component>
                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12633458" author="mkwhitacre" created="Mon, 22 Sep 2008 20:58:52 +0100"  >I forgot to include the link to the mailing list thread in the original bug description[1].&lt;br/&gt;
&lt;br/&gt;
The attachment contains patches for the 1.4 branch of the jackrabbit-core and jackrabbit-api projects.  It adds the method forceClusterSync() to the JackrabbitRepository interface and implements the method in the three implementations of the interface.&lt;br/&gt;
&lt;br/&gt;
The patches stray from Jukka&amp;#39;s suggestion of naming the method sync() as the use case I was needing solved involved a clustered environment.  sync() seems general enough that it might indicate the repository implementation would pick up any changes made to the data store.  I know on the mailing list altering the database directly instead of through JCR/Jackrabbit API is discouraged so perhaps that isn&amp;#39;t a valid use case.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also not completely familiar with all use cases and therefore the implementations of the method only work in a clustered environment.  I assume that multiple repositories hitting the same database in an unclustered environment could be considered invalid.  However if this assumption is incorrect then the code will need to be changed to handle that.&lt;br/&gt;
&lt;br/&gt;
[1] - &lt;a href=&quot;http://www.nabble.com/Forcing-a-cluster-synch-td19578255.html&quot;&gt;http://www.nabble.com/Forcing-a-cluster-synch-td19578255.html&lt;/a&gt;</comment>
                    <comment id="12633802" author="jukkaz" created="Tue, 23 Sep 2008 18:00:00 +0100"  >Hmm, there&amp;#39;s a somewhat releated long discussion ([1] and [2]) about JackrabbitRepository.shutdown() that we had earlier this year. This method is not nearly as intrusive as the shutdown() method, but there might be valid reasons why it shouldn&amp;#39;t be exposed to just any client.&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;http://markmail.org/message/fqyypq5x6bma4ike&quot;&gt;http://markmail.org/message/fqyypq5x6bma4ike&lt;/a&gt;&lt;br/&gt;
[2] &lt;a href=&quot;http://markmail.org/message/dsqyv3rafo4j5xea&quot;&gt;http://markmail.org/message/dsqyv3rafo4j5xea&lt;/a&gt;</comment>
                    <comment id="12634044" author="mreutegg" created="Wed, 24 Sep 2008 08:50:03 +0100"  >I have the same concerns regarding the visibility of the method.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also wondering if this is really needed. IIUC the cluster works like an eventually consistent system (see [1] for an introduction). If the application can guarantee &amp;#39;session consistency&amp;#39; (i.e. an application session always uses a given cluster node and only switches to another cluster node when it goes down) the consequences of the inconsistency window should be very limited.&lt;br/&gt;
&lt;br/&gt;
Micah, can you please elaborate why you need a cluster node to be in sync? Even if you can sync a cluster node, it might get out of sync again right away by a modification of another cluster node.&lt;br/&gt;
&lt;br/&gt;
[1] &lt;a href=&quot;http://www.allthingsdistributed.com/2007/12/eventually_consistent.html&quot;&gt;http://www.allthingsdistributed.com/2007/12/eventually_consistent.html&lt;/a&gt;</comment>
                    <comment id="12634140" author="mkwhitacre" created="Wed, 24 Sep 2008 14:41:44 +0100"  >My use case is described in the mailing list link included in the first comment.  I read the article you linked to and it was very interesting.  In my situation we are shooting for session consistency however there is not means to guarantee the stickiness of the session on the server side.  The setup I have is operations are routed between 3 different JVMs and each JVM is read/writing to the JCR repository.  So the use case I&amp;#39;m shooting for is client 1 performs writes which get routed to JVM1.  The same client then performs a read on that write however the operation is routed to JVM2.  In this situation I know that the write operation has occurred but when retrieving from the repository get a PathNotFoundException.  So in that case I&amp;#39;d like to sync to update JVM2.  After I sync I attempt to read and either get the value I&amp;#39;m looking for or I don&amp;#39;t.  If i don&amp;#39;t then I know that a concurrent modification has occurred and report the appropriate response back to the client.  </comment>
                    <comment id="12637895" author="jukkaz" created="Wed, 8 Oct 2008 13:12:17 +0100"  >How about if we made Repository.login() and Session.refresh() automatically trigger a cluster sync? I think that would be well in line with both the semantic and performance expectations a typical client would have.</comment>
                    <comment id="12637926" author="dpfister" created="Wed, 8 Oct 2008 14:44:00 +0100"  >I&amp;#39;m a bit concerned about the number of sync() calls that might pile up in the end: at the moment, the sync() operation is guarded by a Mutex, roughly like this:&lt;br/&gt;
&lt;br/&gt;
mutex.acquire();&lt;br/&gt;
try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;doSync();&lt;br/&gt;
} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;mutex.release();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
a lot of threads might potentially end up handling Repository.login() and Session.refresh() and would therefore all in turn wait for each other, only to start the sync() operation again. I&amp;#39;d therefore change the semantics of the method described above to:&lt;br/&gt;
&lt;br/&gt;
(1) either return immediately if a thread is already inside doSync() is already in progress&lt;br/&gt;
(2) or wait for the processing thread in doSync() to finish and then return&lt;br/&gt;
&lt;br/&gt;
Optionally, the wait in (2) might again be limited by a timeout in order to avoid locking the complete system.&lt;br/&gt;
&lt;br/&gt;
WDYT?</comment>
                    <comment id="12638234" author="jukkaz" created="Thu, 9 Oct 2008 10:23:11 +0100"  >I&amp;#39;m not sure that there will be that many syncs, especially if we don&amp;#39;t trigger the sync from Repository.login() calls. Additionally, if the node already is in sync with the cluster (which would be the usual case), then the sync amounts to just retrieving the journal revision number and comparing it with the local state.&lt;br/&gt;
&lt;br/&gt;
If the retrieval of the journal revision number is expensive, we could add an additional local guard that just ensures that at least one cluster sync has been done between a client calling Session.refresh() (or Repository.login()) and the call returning. Whether it&amp;#39;s that thread or some other thread doing the sync doesn&amp;#39;t matter. Something like this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private volatile int syncCount = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int count = syncCount;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mutex.acquire();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (count == syncCount) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;doSync();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;syncCount++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mutex.release();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                    <comment id="12638245" author="jukkaz" created="Thu, 9 Oct 2008 11:09:58 +0100"  >Attached a patch (0001-&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1753&quot; title=&quot;Allow means force a Repository to synchronize with the cluster&quot;&gt;&lt;strike&gt;JCR-1753&lt;/strike&gt;&lt;/a&gt;-Allow-means-force-a-Repository-to-synchron.patch) that triggers cluster synchronization in Repository.login() and Session.refresh().</comment>
                    <comment id="12638246" author="jukkaz" created="Thu, 9 Oct 2008 11:10:33 +0100"  >Attached a patch (0002-&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1753&quot; title=&quot;Allow means force a Repository to synchronize with the cluster&quot;&gt;&lt;strike&gt;JCR-1753&lt;/strike&gt;&lt;/a&gt;-Allow-means-force-a-Repository-to-synchron.patch) that implements the syncCount guard variable.</comment>
                    <comment id="12638252" author="dpfister" created="Thu, 9 Oct 2008 11:53:03 +0100"  >Patch looks good to me, apart from the missing &amp;quot;h&amp;quot; in method name &amp;quot;syncWitCluster&amp;quot; ;) &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m still uneasy with the idea of having journal.sync() being potentially called with every Repository.login() and Session.refresh(), thinking of applications that e.g. test the repository availability by intermittently calling Repository.login(). What about specifying a lower bound on the delay (e.g. 1 second) that should pass before another journal sync actually takes place?</comment>
                    <comment id="12638269" author="jukkaz" created="Thu, 9 Oct 2008 13:12:57 +0100"  >&amp;gt; missing &amp;quot;h&amp;quot; in method name &amp;quot;syncWitCluster&amp;quot; ;)&lt;br/&gt;
&lt;br/&gt;
Good catch, thanks!&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I&amp;#39;m still uneasy with the idea of having journal.sync() being potentially called with every&lt;br/&gt;
&amp;gt; Repository.login() and Session.refresh(), thinking of applications that e.g. test the repository&lt;br/&gt;
&amp;gt; availability by intermittently calling Repository.login().&lt;br/&gt;
&lt;br/&gt;
The performance hit is a single SELECT statement (for DatabaseJournal) or a directory listing (for FileJournal). I don&amp;#39;t think that&amp;#39;s too much, but you&amp;#39;re right in that there are cases (one example is a web site without a session pool) where avoiding any extra perfromance hit on login() would be beneficial.&lt;br/&gt;
&lt;br/&gt;
I think it would be OK if we didn&amp;#39;t trigger the cluster sync on login(). A client could still use refresh() to ensure causal consistency (Micah&amp;#39;s use case).&lt;br/&gt;
&lt;br/&gt;
&amp;gt; What about specifying a lower bound on the delay (e.g. 1 second) that should pass before&lt;br/&gt;
&amp;gt; another journal sync actually takes place?&lt;br/&gt;
&lt;br/&gt;
That would kind of defeat the purpose as the client would then have no way (apart from explicitly waiting for that one second and retrying the sync) to ensure consistent access to the repository.</comment>
                    <comment id="12638273" author="tmueller" created="Thu, 9 Oct 2008 13:30:59 +0100"  >We need a configurable lower bound on the delay. Some applications may call refresh() a lot. If there was a change, the cluster mechanism will call PersistenceManager.onExternalUpdate(), which is potentially expensive. Without a lower bound on the delay, the system may get unusably slow. For example, if there is a background thread that calls Session.refresh() once a second, and if PersistenceManager.onExternalUpdate() takes one second. </comment>
                    <comment id="12638287" author="jukkaz" created="Thu, 9 Oct 2008 14:18:47 +0100"  >&amp;gt; For example, if there is a background thread that calls Session.refresh() once a second,&lt;br/&gt;
&amp;gt; and if PersistenceManager.onExternalUpdate() takes one second.&lt;br/&gt;
&lt;br/&gt;
Why is that a problem? With the syncCount patch any later refresh() methods will just wait for the first invocation to finish before just returning without invoking another sync. Also, the usual case is that there are no changes to report, so the amortized cost of the refresh() method is still pretty small.&lt;br/&gt;
&lt;br/&gt;
The sync mutex already implements a lower bound delay that prevents any two syncs from executing concurrently. Adding more delay is IMHO stepping to the client territory. The client may have a good reason to want to sync more frequently (Micah&amp;#39;s round robin case is an excellent example) and I see no reason why the repository should explicitly try to degrade the performance below what the hardware is capable of.</comment>
                    <comment id="12638303" author="jukkaz" created="Thu, 9 Oct 2008 16:26:58 +0100"  >I will create an alternative patch that only triggers the cluster sync in refresh() and includes a configuration option for disabling this feature.</comment>
                    <comment id="12650207" author="jukkaz" created="Mon, 24 Nov 2008 14:18:34 +0000"  >Attached the alternative patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1753&quot; title=&quot;Allow means force a Repository to synchronize with the cluster&quot;&gt;&lt;strike&gt;JCR-1753&lt;/strike&gt;&lt;/a&gt;-sync-in-refresh.patch).&lt;br/&gt;
&lt;br/&gt;
With this method the client needs to call session.refresh(...) to force a cluster sync.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve also included a static (and public) flag variable, SessionImpl.clusterSyncOnRefresh, that an application can set to false if it wants to disable this feature (some applications may have come to expect refresh to be a nearly instantaneous operation, which no longer is true with this feature).</comment>
                    <comment id="12651530" author="jukkaz" created="Fri, 28 Nov 2008 11:33:41 +0000"  >Dropping the jackrabbit-api component as the latest proposals are based on only the standard JCR API.&lt;br/&gt;
&lt;br/&gt;
Note that this improvement will not make it in Jackrabbit 1.5. Let&amp;#39;s target the 1.6 version for this.</comment>
                    <comment id="12728764" author="jukkaz" created="Wed, 8 Jul 2009 17:25:39 +0100"  >Committed a slightly modified version of the patch in revision 792211. Merged to the 1.x branch in revision 792212.&lt;br/&gt;
&lt;br/&gt;
Cluster synchronization is now enabled by default for Session.refresh(boolean). The synch can be selectively disabled per session by setting the &amp;quot;org.apache.jackrabbit.disableClusterSyncOnRefresh&amp;quot; attribute to any non-null value. Alternatively a SessionImpl subclass can disable (or enable) this feature for all refresh() calls by overriding the protected clusterSyncOnRefresh() method.&lt;br/&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12391803" name="0001-JCR-1753-Allow-means-force-a-Repository-to-synchron.patch" size="3319" author="jukkaz" created="Thu, 9 Oct 2008 11:09:58 +0100" />
                    <attachment id="12391804" name="0002-JCR-1753-Allow-means-force-a-Repository-to-synchron.patch" size="2254" author="jukkaz" created="Thu, 9 Oct 2008 11:10:33 +0100" />
                    <attachment id="12394557" name="JCR-1753-sync-in-refresh.patch" size="3881" author="jukkaz" created="Mon, 24 Nov 2008 14:18:34 +0000" />
                    <attachment id="12390678" name="JCR-1753.tar.gz" size="1044" author="mkwhitacre" created="Mon, 22 Sep 2008 20:58:52 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 23 Sep 2008 17:00:00 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142838</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>192438</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>