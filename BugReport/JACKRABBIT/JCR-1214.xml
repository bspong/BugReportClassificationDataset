<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:50:06 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1214/JCR-1214.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1214] DocId.UUIDDocId should not have a string attr uuid</title>
                <link>https://issues.apache.org/jira/browse/JCR-1214</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>After &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt; will be solved, lots of DocId.UUIDDocId can be cached, and not being cleaned after every gc(). The number of cached UUIDDocId can grow very large, depending on the size of the repository.  Therefor, instead of storing the private String uuid; we can make it more memory efficient by storing 2 long&amp;#39;s, the lsb and msb of the uuid.  Storing 1.000.000 of parent UUIDDocId might differ about 100Mb of memory. &lt;br/&gt;
&lt;br/&gt;
I even did test by removing the entire uuid string, and not use msb or lsb, because, when everything works properly (with references to index reader segments (See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt;)), the uuid is never needed again: in &lt;br/&gt;
&lt;br/&gt;
UUIDDocId getDocumentNumber(IndexReader reader) throws IOException {&lt;br/&gt;
&lt;br/&gt;
we could set uuid = null just before the return. It works perfectly well, because when an index reader is recreated, the CachingIndexReader will be recreated, hence DocId[] parents will be recreated. &lt;br/&gt;
&lt;br/&gt;
So, IMO, I think we might be able to remove the uuid entirely when the docNumber is found in DocId.UUIDDocId (obviously after &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt;)&lt;br/&gt;
&lt;br/&gt;
WDOT?&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12382333">JCR-1214</key>
            <summary>DocId.UUIDDocId should not have a string attr uuid</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mreutegg">Marcel Reutegger</assignee>
                                <reporter username="aschrijvers">Ard Schrijvers</reporter>
                        <labels>
                    </labels>
                <created>Mon, 12 Nov 2007 11:06:55 +0000</created>
                <updated>Tue, 15 Jan 2008 23:27:03 +0000</updated>
                    <resolved>Mon, 19 Nov 2007 11:32:26 +0000</resolved>
                                            <fixVersion>1.4</fixVersion>
                                <component>jackrabbit-core</component>
                <component>query</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12542065" author="mreutegg" created="Tue, 13 Nov 2007 08:32:04 +0000"  >For simplicity I would rather use an instance of UUID instead of two longs.&lt;br/&gt;
&lt;br/&gt;
Ard wrote:&lt;br/&gt;
&amp;gt; I think we might be able to remove the uuid entirely ...&lt;br/&gt;
&lt;br/&gt;
no, that&amp;#39;s not possible. the critical use case is index segment merges. consider the following index segments:&lt;br/&gt;
&lt;br/&gt;
i1, i2, i3&lt;br/&gt;
&lt;br/&gt;
now let&amp;#39;s assume i1 contains a UUIDDocId, which refers to a node in i2. then i2 and i3 are merged and replaced by i4:&lt;br/&gt;
&lt;br/&gt;
i1, i4&lt;br/&gt;
&lt;br/&gt;
on next access to the above mentioned UUIDDocId it will realize that the reader that was used to get the document number is gone and as a consequence will be forced to get the document number again and adjust the reader reference to i4.&lt;br/&gt;
&lt;br/&gt;
hope that makes sense... ;)</comment>
                    <comment id="12542084" author="aschrijvers" created="Tue, 13 Nov 2007 09:38:07 +0000"  >&amp;quot;For simplicity I would rather use an instance of UUID instead of two longs. &amp;quot;&lt;br/&gt;
&lt;br/&gt;
Yes, that is easier&lt;br/&gt;
&lt;br/&gt;
&amp;quot;hope that makes sense... ;)&amp;quot;&lt;br/&gt;
&lt;br/&gt;
Yes it totally does (goog explanation also), and I actually saw this exact behavior already  occuring in my test setups.  I was having a little misunderstanding about the fact that, logically though, parents can be found in a different index (segment) and this index might be recreated while the index holding the UUIDDocId to this parent. I also have noticed while working on &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt; I found that it only worked when all indexes did not change, while it went wrong when I was having changing/merging indexes. Exactly the way you describe.  I am about to get all things sorted out regarding the combined index reader, which contains cachingmulti index readers, which contain in their turn lucene indexes. &lt;br/&gt;
&lt;br/&gt;
Might be an idea to picture this a little for documentation, or is there already something like it? &lt;br/&gt;
&lt;br/&gt;
I have only one thing I am still not yet sure about, which you might know from the top of your head: it is regarding &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt; and this one:&lt;br/&gt;
&lt;br/&gt;
I have the idea that the CombinedIndexReader when doing a search in a workspace, normally contains 2 index reader: the one for workspace and a parent index (containing repository index info like node types isn&amp;#39;t?), right? Now, I need to find out, wether when looking up a parent, if it is ever possible that a parent of a node can be found in the parent index (hope it is clear waht i mean?). I think it is not, and this might be quite important for me to implement &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt;, by caching regarding references to an index segment.&lt;br/&gt;
</comment>
                    <comment id="12542086" author="aschrijvers" created="Tue, 13 Nov 2007 09:42:10 +0000"  >One extra thing regarding &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt;: I also have to test that when merging like you describe above happens, the cached docNumber for an index that did not change, might have a different position in the MultiIndexReader after segment merging....ouchhhhh. Anyway, it makes it all a little more complex, but will find these kind of things during implementing this issue and 1213. &lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12542366" author="mreutegg" created="Wed, 14 Nov 2007 08:59:40 +0000"  >&amp;gt; Might be an idea to picture this a little for documentation, or is there already something like it?&lt;br/&gt;
&lt;br/&gt;
no, I&amp;#39;m afraid there isn&amp;#39;t, but it&amp;#39;s definitively a good idea&lt;br/&gt;
&lt;br/&gt;
&amp;gt; ... if it is ever possible that a parent of a node can be found in the parent index.&lt;br/&gt;
&lt;br/&gt;
that&amp;#39;s not possible. the parent index contains the nodes under /jcr:system (including the /jcr:system node). the opposite is possible, though just for one node, the mentioned jcr:system node. this one will have a UUIDDocId, which references the root node of the workspace.</comment>
                    <comment id="12542368" author="aschrijvers" created="Wed, 14 Nov 2007 09:25:33 +0000"  >&amp;gt;no, I&amp;#39;m afraid there isn&amp;#39;t, but it&amp;#39;s definitively a good idea &lt;br/&gt;
&lt;br/&gt;
:-) Perhaps I can make one (though i am terrible at making pics), because I want to have it here at the office as well, for a common understanding of the jackrabbit indexing &lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; ... if it is ever possible that a parent of a node can be found in the parent index.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;that&amp;#39;s not possible. the parent index contains the nodes under /jcr:system (including the /jcr:system node). the opposite is possible, &amp;gt;though just for one node, the mentioned jcr:system node. this one will have a UUIDDocId, which references the root node of the &amp;gt;workspace.&lt;br/&gt;
&lt;br/&gt;
That is good news, and makes it a little easier. Am thinking about a two step check, where first a reference to the entire MultiIndexReader  is checked. &lt;br/&gt;
&lt;br/&gt;
IF : check reference to the entire MultiIndexReader  instance is positive, return cached results.&lt;br/&gt;
ELSE IF :check the index reader segment instance the parent docnumber was in: if  instance present, recompute docNumber with respect to the new offsets in MultiIndexReader and return (almost) cached result.  &lt;br/&gt;
ELSE : recompute docNumber by search in MultiIndexReader  (the uncached case)&lt;br/&gt;
&lt;br/&gt;
I will try to implement it during the weekend because the next days I am really occupied. Will share my findings and tests (and performance issues) hopefully on sunday. </comment>
                    <comment id="12542387" author="mreutegg" created="Wed, 14 Nov 2007 10:07:13 +0000"  >I think this discussion rather belongs to &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt;. I&amp;#39;ll copy over your last comment and follow up there.</comment>
                    <comment id="12543527" author="mreutegg" created="Mon, 19 Nov 2007 11:32:26 +0000"  >Replaced the uuid String with a UUID instance.&lt;br/&gt;
&lt;br/&gt;
svn revision: 596274.</comment>
                    <comment id="12543530" author="aschrijvers" created="Mon, 19 Nov 2007 11:36:28 +0000"  >&amp;quot;For simplicity I would rather use an instance of UUID instead of two longs. &amp;quot; &lt;br/&gt;
&lt;br/&gt;
By the way I think the overhead of a UUID instance (12-16 bytes for an Object) seems to me redundant if only storing 2 longs is enough. My intention was to reduce memory consumption for the string uuid ( ~120 bytes) to two long&amp;#39;s. Ofcourse, a UUID instance is still smaller than the original 120 bytes but still uses redundant memory (though I admit probably UUID instances are small enough :-) )&lt;br/&gt;
&lt;br/&gt;
Thx for solving the issue! </comment>
                    <comment id="12543552" author="mreutegg" created="Mon, 19 Nov 2007 13:09:02 +0000"  >You are right. Let&amp;#39;s get rid of those remaining bytes as well.&lt;br/&gt;
&lt;br/&gt;
Replaced UUID instance with two longs.&lt;br/&gt;
&lt;br/&gt;
svn revision: 596286</comment>
                    <comment id="12543554" author="aschrijvers" created="Mon, 19 Nov 2007 13:17:35 +0000"  >:-) thanks again (by the way after filing the jira issue ofcourse I did not intend to not solve the issue. I thought trying &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1213&quot; title=&quot;UUIDDocId cache does not work properly because of weakReferences in combination with new instance for combined indexreader &quot;&gt;&lt;strike&gt;JCR-1213&lt;/strike&gt;&lt;/a&gt; in combination with this one to not create an extra patch because this one is such a basic one) Anyway, thanks for solving it, and I&amp;#39;ll try to get the patch with respect to 1213 somewhere this week/weekend. </comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                                <inwardlinks description="is related to">
                            <issuelink>
            <issuekey id="12382332">JCR-1213</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 13 Nov 2007 08:32:04 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142580</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>191900</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>