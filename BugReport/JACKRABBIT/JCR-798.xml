<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:54:14 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-798/JCR-798.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-798] ConcurrentModificationException during logout</title>
                <link>https://issues.apache.org/jira/browse/JCR-798</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>We regularly get the following exception:&lt;br/&gt;
&lt;br/&gt;
java.util.ConcurrentModificationException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.checkMod(AbstractReferenceMap.java:761)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.hasNext(AbstractReferenceMap.java:735)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.Collections$UnmodifiableCollection$1.hasNext(Collections.java:1009)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.Collections$UnmodifiableCollection$1.hasNext(Collections.java:1009)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.state.LocalItemStateManager.dispose(LocalItemStateManager.java:341)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.WorkspaceImpl.dispose(WorkspaceImpl.java:170)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.logout(SessionImpl.java:1225)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.XASessionImpl.logout(XASessionImpl.java:379)&lt;br/&gt;
&lt;br/&gt;
Two causes for this exception have been identified:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;(Taken from an email to the dev-list from Marcel Reutegger):&lt;br/&gt;
&amp;gt; - session A reads some items I&lt;br/&gt;
&amp;gt; - session B transiently removes items in I&lt;br/&gt;
&amp;gt; - session A logs out and starts to iterate over I in  LocalItemStateManager (LISM)&lt;br/&gt;
&amp;gt; - session B saves changes and removed items are evicted from A&amp;#39;s LISM&lt;br/&gt;
&amp;gt; - session A gets concurrent modification exception&lt;br/&gt;
&lt;br/&gt;
Another scenario is the following:&lt;br/&gt;
- Session A gets the iterator of the values of (the primary cache of) an ItemStateReferenceCache in LocalItemStateManager.dispose.&lt;br/&gt;
- Session B then does something that triggers the CacheManager.&lt;br/&gt;
- The CacheManager then calls resizeAll, and evicts some items from the secondary cache of the ItemStateReferenceCache of which the LocalItemStateManager has a values iterator.&lt;br/&gt;
- The garbage collector then runs and evicts the removed items also from the primary cache, which effectively modifies the set over which is iterated.&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&lt;br/&gt;
Martijn Hendriks</description>
                <environment>Jackrabbit 1.2.1</environment>
            <key id="12365223">JCR-798</key>
            <summary>ConcurrentModificationException during logout</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="stefan@jira">Stefan Guggisberg</assignee>
                                <reporter username="martijnh">Martijn Hendriks</reporter>
                        <labels>
                    </labels>
                <created>Mon, 19 Mar 2007 09:15:09 +0000</created>
                <updated>Wed, 25 Apr 2007 09:45:32 +0100</updated>
                    <resolved>Wed, 18 Apr 2007 10:10:43 +0100</resolved>
                                            <fixVersion>1.3</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12482047" author="stefan@jira" created="Mon, 19 Mar 2007 10:08:13 +0000"  >fixed in svn r519892.&lt;br/&gt;
&lt;br/&gt;
since i haven&amp;#39;t been able to reproduce the issue i couldn&amp;#39;t verify the fix.&lt;br/&gt;
please reopen this issue if the ConcurrentModificationException still&lt;br/&gt;
occur on session logout.&lt;br/&gt;
&lt;br/&gt;
thanks for reporting this issue,&lt;br/&gt;
cheers&lt;br/&gt;
stefan</comment>
                    <comment id="12482684" author="martijnh" created="Wed, 21 Mar 2007 09:04:09 +0000"  >Unfortunately, the CME still occurs:&lt;br/&gt;
&lt;br/&gt;
java.util.ConcurrentModificationException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.checkMod(AbstractReferenceM&lt;br/&gt;
ap.java:761)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceEntrySetIterator.nextEntry(AbstractReference&lt;br/&gt;
Map.java:770)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceValuesIterator.next(AbstractReferenceMap.jav&lt;br/&gt;
a:829)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.commons.collections.map.AbstractReferenceMap$ReferenceValues.toArray(AbstractReferenceMap.java:544)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.Collections$UnmodifiableCollection.toArray(Collections.java:1002)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.Collections$UnmodifiableCollection.toArray(Collections.java:1002)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.state.LocalItemStateManager.dispose(LocalItemStateManager.java:343)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.WorkspaceImpl.dispose(WorkspaceImpl.java:170)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.SessionImpl.logout(SessionImpl.java:1225)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.XASessionImpl.logout(XASessionImpl.java:379)&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&lt;br/&gt;
Martijn</comment>
                    <comment id="12483090" author="martijnh" created="Thu, 22 Mar 2007 10:27:01 +0000"  >It seems to me that the only way of avoiding such concurrent modifications is to have some form of synchronization. For instance, having a read-write lock in the LISM that serializes the calls to dispose and the ItemStateListener methods could prevent the first scenario as sketched above. This, however, does not solve the second scenario. I.e., when an item is to be evicted from a MLRUItemStateCache, it must be certain that nobody iterates over the related ItemStateReferenceMap (via the ItemStateReferenceCache).&lt;br/&gt;
&lt;br/&gt;
Martijn</comment>
                    <comment id="12483099" author="stefan@jira" created="Thu, 22 Mar 2007 10:54:04 +0000"  >i don&amp;#39;t think that the second scenario (i.e. garbage collector interfering while iterating over ReferenceMap entries) is realistic since this should IMO be taken care of by the commons-collections ReferenceMap class. since ReferenceMap is being heavily used in jackrabbit&amp;#39;s core we would see a lot more issues like this if that wouldn&amp;#39;t be the case. &lt;br/&gt;
&lt;br/&gt;
i think that marcel&amp;#39;s scenario and/or improper sharing of Session instances are the most plausible explanations for this issue.&lt;br/&gt;
&lt;br/&gt;
since i&amp;#39;ve never come across this issue myself i&amp;#39;d like to be able to reproduce it in order to further analyze it. &lt;br/&gt;
martjin, could you perhaps provide a simple test-case?&lt;br/&gt;
&lt;br/&gt;
cheers&lt;br/&gt;
stefan</comment>
                    <comment id="12483538" author="martijnh" created="Fri, 23 Mar 2007 11:35:22 +0000"  >We have finally found the cause of the CME.&lt;br/&gt;
&lt;br/&gt;
Consider the following scenario: Session A registers an EventListener B which uses A to process received events. Session A then logs out, and gets the Iterator in the LocalItemStateManager.dispose method. Then another thread modifies the repository and triggers the observation mechanism. EventListener B receives events, and processes them using Session A. This modifies the cache of Session A, and a CME is thrown.&lt;br/&gt;
&lt;br/&gt;
This scenario is caused by the fact that in the SessionImpl.logout the Workspace (including ObservationManager) is disposed of after the disposal of the SessionItemStateManager. A possible fix would be to swap the order there.&lt;br/&gt;
&lt;br/&gt;
I cannot find in the spec whether this is a valid use case of the JCR. I can image, however, that it is because otherwise each EventListener needs to create it&amp;#39;s own session in order to to something with the events.&lt;br/&gt;
&lt;br/&gt;
regards,&lt;br/&gt;
&lt;br/&gt;
Martijn</comment>
                    <comment id="12483623" author="stefan@jira" created="Fri, 23 Mar 2007 14:51:17 +0000"  >martjin, thanks for sharing this. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Consider the following scenario: Session A registers an &lt;br/&gt;
&amp;gt; EventListener B which uses A to process received events. &lt;br/&gt;
&amp;gt; Session A then logs out, and gets the Iterator in the &lt;br/&gt;
&amp;gt; LocalItemStateManager.dispose method. Then another thread &lt;br/&gt;
&amp;gt; modifies the repository and triggers the observation mechanism. &lt;br/&gt;
&amp;gt; EventListener B receives events, and processes them using &lt;br/&gt;
&amp;gt; Session A. This modifies the cache of Session A, and a CME is &lt;br/&gt;
&amp;gt; thrown.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
this confirms my assumption. session A is actually used by 2 &lt;br/&gt;
separate threads: &lt;br/&gt;
&lt;br/&gt;
1. the thread that&amp;#39;s logging out session A&lt;br/&gt;
2. the thread that is dispatching the events to the event listener&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(which in turn is using session A aswell)&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I cannot find in the spec whether this is a valid use case of the JCR. &lt;br/&gt;
&lt;br/&gt;
&amp;quot;7.5 Thread-Safety Requirements&amp;quot; states that you cannot assume Session&lt;br/&gt;
being thread-safe. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; I can image, however, that it is because otherwise each EventListener &lt;br/&gt;
&amp;gt; needs to create it&amp;#39;s own session in order to to something with the events.&lt;br/&gt;
&lt;br/&gt;
only if your EventListener interacts with the repository. that&amp;#39;s just one, but &lt;br/&gt;
certainly not the only use case. &lt;br/&gt;
&lt;br/&gt;
wrt your suggested fix (swapping the order of disposing the workspace/SISM):&lt;br/&gt;
while that would probably fix this issue i am somehow reluctant to apply it.&lt;br/&gt;
i am concerned that this could possibly cause new, more serious issues&lt;br/&gt;
since the order of those calls is quite delicate.&lt;br/&gt;
&lt;br/&gt;
i am tempted to resolve this issue as &amp;quot;Won&amp;#39;t fix&amp;quot; or &amp;quot;Invalid&amp;quot; since it&amp;#39;s imo caused&lt;br/&gt;
by improper session usage. wdyt?&lt;br/&gt;
&lt;br/&gt;
cheers&lt;br/&gt;
stefan</comment>
                    <comment id="12483625" author="jukkaz" created="Fri, 23 Mar 2007 15:01:23 +0000"  >Reading Martijn&amp;#39;s description it seems that the problem is simply that the event listener is not automatically unregistered when the session is closed. Session.logout() should always unregister all listeners associated with that session, after which the described problem shouldn&amp;#39;t occur.</comment>
                    <comment id="12483638" author="stefan@jira" created="Fri, 23 Mar 2007 15:49:44 +0000"  >&amp;gt; Reading Martijn&amp;#39;s description it seems that the problem is simply &lt;br/&gt;
&amp;gt; that the event listener is not automatically unregistered when the &lt;br/&gt;
&amp;gt; session is closed. Session.logout() should always unregister all &lt;br/&gt;
&amp;gt; listeners associated with that session, after which the described &lt;br/&gt;
&amp;gt; problem shouldn&amp;#39;t occur.&lt;br/&gt;
&lt;br/&gt;
event listeners registered by a session are already automatically &lt;br/&gt;
unregistered on Session.logout(). the core issue here is that&lt;br/&gt;
the same session is used by multiple threads (event dispatcher &lt;br/&gt;
and application thread). </comment>
                    <comment id="12483642" author="jukkaz" created="Fri, 23 Mar 2007 15:58:57 +0000"  >&amp;gt; event listeners registered by a session are already automatically&lt;br/&gt;
&amp;gt; unregistered on Session.logout().&lt;br/&gt;
&lt;br/&gt;
Looking at the code it seems like the even listeners are unregistered only after the item state and item managers have been disposed. That order should probably at least be changed.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; the core issue here is that the same session is used by multiple&lt;br/&gt;
&amp;gt; threads (event dispatcher and application thread).&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t think we can avoid that with the JCR observation design. At least the event dispatcher and the application thread need to share the local namespace mappings of the session.&lt;br/&gt;
&lt;br/&gt;
I agree that it&amp;#39;s an application problem if the event *listener* uses the same session that was used to register it. Such a solution is almost always incorrect, though I can see unwary developers easily falling into that trap. Perhaps we should log a warning or even throw an exception if we detect a call like Session.getItem() being issued from an event listener registered by the same session?&lt;br/&gt;
</comment>
                    <comment id="12484203" author="martijnh" created="Mon, 26 Mar 2007 20:23:48 +0100"  >I am not familiar with the mechanics of remapping a namespace as Jukka mentioned, but isn&amp;#39;t it possible to apply a namespace remapping to two sessions and use one in the application thread and one in the observation thread? If there is no usecase of two threads sharing a session then I guess that the issue can indeed be resolved as &amp;quot;Won&amp;#39;t fix&amp;quot; or &amp;quot;invalid&amp;quot; as Stefan suggested.&lt;br/&gt;
I don&amp;#39;t know whether trying to detect this kind of usage of sessions is worth the overhead. Maybe the &amp;quot;nondeterministic detection&amp;quot; by the CME that is in place right now is enough?&lt;br/&gt;
&lt;br/&gt;
Martijn</comment>
                    <comment id="12489654" author="jukkaz" created="Wed, 18 Apr 2007 09:44:44 +0100"  >For the record, the attached patch implements a simple check that prevents an observation listener from accessing the session it was registered with. I don&amp;#39;t think the overhead is worth the benefit, so I won&amp;#39;t apply this patch, but it&amp;#39;s here in case people start falling into that concurrency trap.</comment>
                    <comment id="12489660" author="jukkaz" created="Wed, 18 Apr 2007 10:10:43 +0100"  >Fixed in revision 529913 by explicitly removing all registered event listeners at the beginning of the logout() method.&lt;br/&gt;
&lt;br/&gt;
The EventConsumer class calls session.getAccessManager().isGranted() which in turn (depending on the configured AccessManager) can access session internals like the hierarchy and item state managers. This could previously happen in parallel with the logout() method.</comment>
                </comments>
                    <attachments>
                    <attachment id="12355735" name="currentObservationSession.patch" size="2272" author="jukkaz" created="Wed, 18 Apr 2007 09:44:44 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 19 Mar 2007 10:08:13 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142370</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>191907</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>