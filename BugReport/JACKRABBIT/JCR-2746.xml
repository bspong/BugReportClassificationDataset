<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:37:22 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2746/JCR-2746.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2746] Sleep in possibly endless loop in ObservationDispatcher</title>
                <link>https://issues.apache.org/jira/browse/JCR-2746</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The rate-limitation code we added in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2402&quot; title=&quot;Observation: avoid running out of memory&quot;&gt;&lt;strike&gt;JCR-2402&lt;/strike&gt;&lt;/a&gt; to prevent the observation queue from growing too large was a good idea, but the current implementation is a bit troublesome since it blocks the thread while it still holds the journal lock, the SISM reader lock, and the SessionState lock. This can cause a deadlock under heavy workloads if any of the observation listeners attempts to reuse the session (not recommended/supported, but can still happen) or write to the repository (quite likely).&lt;br/&gt;
&lt;br/&gt;
To solve this problem we should move the rate-limiter code to outside the scope of any internal locks.</description>
                <environment></environment>
            <key id="12474046">JCR-2746</key>
            <summary>Sleep in possibly endless loop in ObservationDispatcher</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="tmueller">Thomas Mueller</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Tue, 14 Sep 2010 10:30:48 +0100</created>
                <updated>Fri, 23 Sep 2011 15:23:04 +0100</updated>
                    <resolved>Tue, 21 Sep 2010 14:34:30 +0100</resolved>
                            <version>2.0</version>
                <version>2.1</version>
                <version>2.1.1</version>
                                <fixVersion>2.2</fixVersion>
                                <component>jackrabbit-core</component>
                <component>observation</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12912473" author="tmueller" created="Mon, 20 Sep 2010 15:16:22 +0100"  >Thread.sleep can&amp;#39;t be the root cause of a new deadlock. (Thread.sleep was added in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2402&quot; title=&quot;Observation: avoid running out of memory&quot;&gt;&lt;strike&gt;JCR-2402&lt;/strike&gt;&lt;/a&gt;, but no additional synchronization or locking was introduced). But Thread.sleep can *trigger* a deadlock that normally doesn&amp;#39;t show up. So it it&amp;#39;s really a deadlock, it could also occur even without &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2402&quot; title=&quot;Observation: avoid running out of memory&quot;&gt;&lt;strike&gt;JCR-2402&lt;/strike&gt;&lt;/a&gt; (but less likely).&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2402&quot; title=&quot;Observation: avoid running out of memory&quot;&gt;&lt;strike&gt;JCR-2402&lt;/strike&gt;&lt;/a&gt; calls Thread.sleep in a loop. If I replace the loop with an &amp;quot;if&amp;quot; then I can reproduce some kind of deadlock. Currently it looks more like a bug in DefaultISMLocking however... I&amp;#39;m analyzing it.</comment>
                    <comment id="12912477" author="tmueller" created="Mon, 20 Sep 2010 15:27:04 +0100"  >There seems to be a bug in DefaultISMLocking:&lt;br/&gt;
&lt;br/&gt;
1) The main thread gets a read lock.&lt;br/&gt;
&lt;br/&gt;
2) The ObservationManager thread tries to lock for writing, which is blocked because there is still a read lock.&lt;br/&gt;
&lt;br/&gt;
3) Then the main thread tries to get a second read lock, which is blocked because there is a waiting write lock.&lt;br/&gt;
&lt;br/&gt;
It looks like &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2402&quot; title=&quot;Observation: avoid running out of memory&quot;&gt;&lt;strike&gt;JCR-2402&lt;/strike&gt;&lt;/a&gt; is triggering this (so far hidden / undetected?) problem.</comment>
                    <comment id="12912864" author="tmueller" created="Tue, 21 Sep 2010 08:30:37 +0100"  >The bug in DefaultISMLocking was introduces with &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2089&quot; title=&quot;Use java.util.concurrent&quot;&gt;JCR-2089&lt;/a&gt; (Use java.util.concurrent), revisions 995411 and 995412. I think the safe solution is to revert those to commits. Test case:&lt;br/&gt;
&lt;br/&gt;
public void test() throws InterruptedException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final ISMLocking lock = new DefaultISMLocking();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ReadLock r1 = lock.acquireReadLock(null);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final InterruptedException[] ex = new InterruptedException[1];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thread = new Thread() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.acquireWriteLock(null).release();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ex[0] = e;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(100);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lock.acquireReadLock(null).release();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;r1.release();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.join();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (ex[0] != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw ex[0];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
This will result in a deadlock with the current DefaultISMLocking, but not with the old.&lt;br/&gt;
</comment>
                    <comment id="12912917" author="tmueller" created="Tue, 21 Sep 2010 11:07:42 +0100"  >The deadlock in DefaultISMLocking is now tracked in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2753&quot; title=&quot;Deadlock in DefaultISMLocking&quot;&gt;&lt;strike&gt;JCR-2753&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
Even if this is fixed, there is a problem with the ObservationDispatcher: the loop to wait for the observation queue to shrink may be endless, because locks are held by the current thread. It doesn&amp;#39;t looks like there is an easy solution, except for only waiting once (slowing down the main thread) instead of waiting until the queue is shorter. In most cases, this will solve the original problem (events are generated faster than processed), but it can&amp;#39;t result in an endless loop, even if the observation listener tries to read from or write to the repository. Another option is to never wait / sleep, only to log a warning.</comment>
                    <comment id="12912925" author="tmueller" created="Tue, 21 Sep 2010 11:32:54 +0100"  >Test case to get the endless loop.</comment>
                    <comment id="12912970" author="tmueller" created="Tue, 21 Sep 2010 14:34:12 +0100"  >Sleeping no longer happens in a loop. Also, instead of sleeping in the observation dispatcher (while locks are held), the delay is now done before the next operation (before locks are acquired).</comment>
                    <comment id="12913525" author="jukkaz" created="Wed, 22 Sep 2010 13:46:17 +0100"  >Could we come up with a solution that doesn&amp;#39;t require the extra bits of state and responsibility in SessionContext and the new public method in SessionImpl? Also, having the delay carried over to the next session operation seems a bit troublesome to me. It would be better to keep the extra delay within the scope of the currently executed operation.&lt;br/&gt;
&lt;br/&gt;
How about the attached patch where I move the delay to the finally block of SessionState.perform() and use just an extra ObservationDispatcher.isEventQueueOverloaded() predicate to carry the required bit of state across the system?</comment>
                    <comment id="12913553" author="jukkaz" created="Wed, 22 Sep 2010 14:39:25 +0100"  >The updated version of the patch changes the key method to ObservationDispatcher.delayIfEventQueueOverloaded(), and makes sure that no delay is added when executing within the observation thread.</comment>
                    <comment id="12914527" author="jukkaz" created="Fri, 24 Sep 2010 17:45:27 +0100"  >I committed the proposed patch in revision 1000950.</comment>
                </comments>
                    <attachments>
                    <attachment id="12455262" name="JCR-2746.patch" size="8991" author="jukkaz" created="Wed, 22 Sep 2010 14:39:25 +0100" />
                    <attachment id="12455258" name="JCR-2746.patch" size="9081" author="jukkaz" created="Wed, 22 Sep 2010 13:46:17 +0100" />
                    <attachment id="12455131" name="TestObservationEndlessLoop.java" size="2071" author="tmueller" created="Tue, 21 Sep 2010 11:32:54 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 20 Sep 2010 14:16:22 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>59558</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190354</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>