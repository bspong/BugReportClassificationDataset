<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:57:14 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2000/JCR-2000.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2000] Deadlock on concurrent commits</title>
                <link>https://issues.apache.org/jira/browse/JCR-2000</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>As reported in the followup to &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1979&quot; title=&quot;Deadlock  on concurrent read &amp;amp; transactional write operations&quot;&gt;&lt;strike&gt;JCR-1979&lt;/strike&gt;&lt;/a&gt;, there&amp;#39;s a case where two transactions may be concurrently inside a commit. This is bad as it breaks the main assumption in &lt;a href=&quot;http://jackrabbit.apache.org/concurrency-control.html&quot;&gt;http://jackrabbit.apache.org/concurrency-control.html&lt;/a&gt; about all transactions first acquiring the versioning write lock.&lt;br/&gt;
&lt;br/&gt;
Looking deeper into this I find that the versioning write lock is only acquired if the transaction being committed contains versioning operations. This is incorrect as all transactions in any case need to access the version store when checking for references.</description>
                <environment></environment>
            <key id="12415592">JCR-2000</key>
            <summary>Deadlock on concurrent commits</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Wed, 25 Feb 2009 15:49:00 +0000</created>
                <updated>Tue, 7 Apr 2009 14:24:18 +0100</updated>
                    <resolved>Thu, 5 Mar 2009 18:39:52 +0000</resolved>
                            <version>1.5.3</version>
                                <fixVersion>1.5.4</fixVersion>
                                <component>jackrabbit-core</component>
                <component>transactions</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12677954" author="jukkaz" created="Mon, 2 Mar 2009 10:57:06 +0000"  >Attached a patch that solves the issue for environments where the transaction manager does not use separate threads for preparing and committing a transaction (see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1334&quot; title=&quot;Deadlock due different Thread access while prepare and commit in same Transaction&quot;&gt;&lt;strike&gt;JCR-1334&lt;/strike&gt;&lt;/a&gt;). Support for &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1334&quot; title=&quot;Deadlock due different Thread access while prepare and commit in same Transaction&quot;&gt;&lt;strike&gt;JCR-1334&lt;/strike&gt;&lt;/a&gt; requires updating also the version manager lock to support switching the lock ownership from one thread to another.</comment>
                    <comment id="12677967" author="jukkaz" created="Mon, 2 Mar 2009 11:55:09 +0000"  >Here&amp;#39;s a new version of the patch that solves also the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1334&quot; title=&quot;Deadlock due different Thread access while prepare and commit in same Transaction&quot;&gt;&lt;strike&gt;JCR-1334&lt;/strike&gt;&lt;/a&gt; issues. I&amp;#39;ll run some more tests on it before committing to trunk and the 1.5 branch.</comment>
                    <comment id="12677973" author="mreutegg" created="Mon, 2 Mar 2009 12:35:56 +0000"  >I still see lockups when running ConcurrentVersioningWithTransactionsTest.&lt;br/&gt;
&lt;br/&gt;
We should eventually run those concurrency tests on a daily basis. All that&amp;#39;s needed is:&lt;br/&gt;
&lt;br/&gt;
mvn -Dtest=DailyIntegrationTest test&lt;br/&gt;
&lt;br/&gt;
Is this kind of daily test possible with our hudson instance?</comment>
                    <comment id="12677980" author="jukkaz" created="Mon, 2 Mar 2009 13:23:31 +0000"  >Yep, I&amp;#39;m seeing the same problem. Working on it now.&lt;br/&gt;
&lt;br/&gt;
Once solved, I&amp;#39;ll configure Hudson to periodically run the more extensive integration tests.</comment>
                    <comment id="12678306" author="jukkaz" created="Tue, 3 Mar 2009 12:39:59 +0000"  >As far as I can tell, the lockups are caused by the test case forcibly terminating long-lived threads. The Thread.stop() call does unlock any object monitors the thread has locked, but will leave the explicit lock objects locked.&lt;br/&gt;
&lt;br/&gt;
The proposed change extends the scope of the versioning lock used in transactions, and thus affects the performance of concurrent commits. This is probably the cause of the timeouts of the test case being reached.</comment>
                    <comment id="12678339" author="jukkaz" created="Tue, 3 Mar 2009 15:10:49 +0000"  >There are other lockups too. However, the test code violates the &amp;quot;Don&amp;#39;t mix concurrent transactional and non-transactional writes to a single workspace&amp;quot; guideline mentioned in &lt;a href=&quot;http://jackrabbit.apache.org/concurrency-control.html&quot;&gt;http://jackrabbit.apache.org/concurrency-control.html&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve disabled the Thread.stop() calls and the mixed normal and transactional saves, which seems to avoid all the problems. I&amp;#39;ll run a bigger randomized test over the night to see whether any problems remain.</comment>
                    <comment id="12678658" author="jukkaz" created="Wed, 4 Mar 2009 09:25:32 +0000"  >Yes, that seems to have fixed the issues. I&amp;#39;ll commit the changes and give people some time to check this out before cutting the 1.5.4 release with the fix.</comment>
                    <comment id="12678676" author="mreutegg" created="Wed, 4 Mar 2009 10:18:13 +0000"  >&amp;gt; As far as I can tell, the lockups are caused by the test case forcibly terminating long-lived threads.&lt;br/&gt;
&lt;br/&gt;
I disagree. The tasks in ConcurrentVersioningWithTransactionsTest time out one year in the future. Actually an unreasonable value ;), should be rather in the area of a couple of minutes, to make sure the test terminates at some point if a deadlock occurs. RandomOperationTest indeed uses a lower timeout of 60 seconds. If that&amp;#39;s a problem, we should rather increase that value to e.g. 5 minutes.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; However, the test code violates the &amp;quot;Don&amp;#39;t mix concurrent transactional and non-transactional writes to a single workspace&amp;quot; guideline&lt;br/&gt;
&lt;br/&gt;
Hmm, I understand, but the above mentioned test works just fine in the 1.4 branch.&lt;br/&gt;
&lt;br/&gt;
Przemo, does you application use XA transactions mixed with regular writes?</comment>
                    <comment id="12678683" author="jukkaz" created="Wed, 4 Mar 2009 10:44:10 +0000"  >The thread deaths I saw were caused by the RandomOperationTest class killing them. At least in a few cases the threads were still holding on locks, which made the test block indefinitely in the cleanup phase after all test threads had been killed.&lt;br/&gt;
&lt;br/&gt;
Why do we need the thread killing in the first place? A normal join() call with no timeout should be fine enough. If there&amp;#39;s a deadlock, then a manually generated thread dump is much more accurate (it contains all the locks held) than the stack traces that the test case now dumps.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Hmm, I understand, but the above mentioned test works just fine in the 1.4 branch.&lt;br/&gt;
&lt;br/&gt;
The proposed change here extends the scope of the versioning lock acquired in a transaction commit, which makes this deadlock (A: commit() -&amp;gt; versioning lock -&amp;gt; workspace lock; B: save() -&amp;gt; workspace lock -&amp;gt; versioning lock) more likely to happen, but the deadlock scenario already existed before, it probably just was never triggered due to lucky timing.</comment>
                    <comment id="12678698" author="jukkaz" created="Wed, 4 Mar 2009 11:24:07 +0000"  >Attached a patch (thread-join.patch) that replaces the thread timeouts with an unbounded Thread.join() call.</comment>
                    <comment id="12678711" author="mreutegg" created="Wed, 4 Mar 2009 12:17:52 +0000"  >&amp;gt; Why do we need the thread killing in the first place? A normal join() call with no timeout should be fine enough&lt;br/&gt;
&lt;br/&gt;
Right, that would work well when one runs the test on a local machine. I had some build infrastructure in mind, where I want a report after the tests finished, which means termination must be guaranteed.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12678714" author="jukkaz" created="Wed, 4 Mar 2009 12:26:24 +0000"  >I think something like the build timeout plugin for Hudson is better for catching runaway CI builds.</comment>
                    <comment id="12678715" author="mreutegg" created="Wed, 4 Mar 2009 12:37:50 +0000"  >Ah, cool. I didn&amp;#39;t know there is something like that...</comment>
                    <comment id="12678716" author="jukkaz" created="Wed, 4 Mar 2009 12:43:21 +0000"  >Anyway, I don&amp;#39;t feel too strongly about the join() issue. I suspect that the thread deaths I was seeing earlier were probably caused by an earlier deadlock blocking the threads that then were forcibly killed by the timeout mechanism, hiding the original cause of the problem.</comment>
                    <comment id="12678738" author="jukkaz" created="Wed, 4 Mar 2009 14:17:30 +0000"  >Applied the patch (latest &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2000&quot; title=&quot;Deadlock on concurrent commits&quot;&gt;&lt;strike&gt;JCR-2000&lt;/strike&gt;&lt;/a&gt;.patch) in revision 750011. Merged it and the related test case changes (749953 and 749965) to the 1.5 branch in revision 750013.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll still run some tests on the 1.5 branch before resolving this as fixed.</comment>
                    <comment id="12679122" author="jukkaz" created="Thu, 5 Mar 2009 08:41:21 +0000"  >Hmm, I&amp;#39;m still seeing some lockups. Investigating...</comment>
                    <comment id="12679159" author="jukkaz" created="Thu, 5 Mar 2009 11:19:12 +0000"  >The last problem appears to be an extra synchronization block in LocalItemStateManager, which prevents the SearchManager from accessing content when synchronous observation events are received. The relevant parts of the thread dump are:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;Thread-605&amp;quot; prio=10 tid=0xa6d8e400 nid=0xdba waiting for monitor entry [0xa430c000..0xa430cfa0]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState(LocalItemStateManager.java:153)&lt;br/&gt;
	- waiting to lock &amp;lt;0xad21eda0&amp;gt; (a org.apache.jackrabbit.core.state.LocalItemStateManager)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState(SessionItemStateManager.java:182)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager$1.nextNodeState(SearchManager.java:442)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager$1.next(SearchManager.java:435)&lt;br/&gt;
	at org.apache.commons.collections.iterators.TransformIterator.next(TransformIterator.java:87)&lt;br/&gt;
	at org.apache.commons.collections.IteratorUtils.toList(IteratorUtils.java:829)&lt;br/&gt;
	at org.apache.commons.collections.IteratorUtils.toList(IteratorUtils.java:805)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.SearchIndex.updateNodes(SearchIndex.java:588)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.onEvent(SearchManager.java:478)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.EventConsumer.consumeEvents(EventConsumer.java:244)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.ObservationDispatcher.dispatchEvents(ObservationDispatcher.java:201)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch(EventStateCollection.java:447)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher.dispatch(DelegatingObservationDispatcher.java:127)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher.dispatchEvents(DelegatingObservationDispatcher.java:99)&lt;br/&gt;
	at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch(EventStateCollection.java:447)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.end(SharedItemStateManager.java:749)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.commit(XAItemStateManager.java:172)&lt;br/&gt;
	at org.apache.jackrabbit.core.version.XAVersionManager.commit(XAVersionManager.java:497)&lt;br/&gt;
	at org.apache.jackrabbit.core.TransactionContext.commit(TransactionContext.java:206)&lt;br/&gt;
	- locked &amp;lt;0xb3b33ea0&amp;gt; (a org.apache.jackrabbit.core.TransactionContext)&lt;br/&gt;
	at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:346)&lt;br/&gt;
	at org.apache.jackrabbit.core.UserTransactionImpl.commit(UserTransactionImpl.java:150)&lt;br/&gt;
	at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest$1.execute(ConcurrentVersioningWithTransactionsTest.java:86)&lt;br/&gt;
	at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:164)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
&lt;br/&gt;
&amp;quot;Thread-604&amp;quot; prio=10 tid=0xa6d8d400 nid=0xdb9 in Object.wait() [0xa435d000..0xa435e020]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: WAITING (on object monitor)&lt;br/&gt;
	at java.lang.Object.wait(Native Method)&lt;br/&gt;
	- waiting on &amp;lt;0xad159240&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)&lt;br/&gt;
	at java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock.acquire(Unknown Source)&lt;br/&gt;
	- locked &amp;lt;0xad159240&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.&amp;lt;init&amp;gt;(DefaultISMLocking.java:96)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.&amp;lt;init&amp;gt;(DefaultISMLocking.java:89)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock(DefaultISMLocking.java:51)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock(SharedItemStateManager.java:1416)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState(SharedItemStateManager.java:253)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.getNodeState(LocalItemStateManager.java:93)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState(LocalItemStateManager.java:158)&lt;br/&gt;
	- locked &amp;lt;0xad21eda0&amp;gt; (a org.apache.jackrabbit.core.state.LocalItemStateManager)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState(SessionItemStateManager.java:182)&lt;br/&gt;
	at org.apache.jackrabbit.core.HierarchyManagerImpl.getItemState(HierarchyManagerImpl.java:150)&lt;br/&gt;
	at org.apache.jackrabbit.core.HierarchyManagerImpl.getPath(HierarchyManagerImpl.java:393)&lt;br/&gt;
	at org.apache.jackrabbit.core.CachingHierarchyManager.getPath(CachingHierarchyManager.java:229)&lt;br/&gt;
	at org.apache.jackrabbit.core.lock.LockManagerImpl.getPath(LockManagerImpl.java:701)&lt;br/&gt;
	at org.apache.jackrabbit.core.lock.LockManagerImpl.getLockInfo(LockManagerImpl.java:439)&lt;br/&gt;
	at org.apache.jackrabbit.core.lock.XAEnvironment.getLockInfo(XAEnvironment.java:234)&lt;br/&gt;
	at org.apache.jackrabbit.core.lock.XALockManager.checkLock(XALockManager.java:184)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemValidator.checkLock(ItemValidator.java:382)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemValidator.checkCondition(ItemValidator.java:305)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemValidator.checkModify(ItemValidator.java:267)&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:726)&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeImpl.internalAddNode(NodeImpl.java:683)&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeImpl.addNode(NodeImpl.java:2055)&lt;br/&gt;
	- locked &amp;lt;0xb3be44a0&amp;gt; (a org.apache.jackrabbit.core.NodeImpl)&lt;br/&gt;
	at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest$1.execute(ConcurrentVersioningWithTransactionsTest.java:83)&lt;br/&gt;
	at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:164)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m not sure yet why the SearchManager is accessing a *LocalItemStateManager* here, it should only ever access the SharedItemStateManager instance.</comment>
                    <comment id="12679167" author="jukkaz" created="Thu, 5 Mar 2009 11:55:26 +0000"  >The culprit seems to be the system search manager, that (like LockManager above) uses the SessionItemStateManager of the system session for looking up items. The attached patch (search-on-sism.patch) makes the system search manager use the underlying SharedItemStateManager instance instead of the SessionItemStateManager.</comment>
                    <comment id="12679177" author="jukkaz" created="Thu, 5 Mar 2009 12:25:44 +0000"  >The last problem above is a bit outside the scope of this issue, so I created &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2008&quot; title=&quot;System search manager uses a SessionItemStateManager&quot;&gt;&lt;strike&gt;JCR-2008&lt;/strike&gt;&lt;/a&gt; for that and resolved the issue by committed the proposed fix in both svn trunk and the 1.5 branch.&lt;br/&gt;
&lt;br/&gt;
Resolving this as Fixed.</comment>
                    <comment id="12679279" author="jukkaz" created="Thu, 5 Mar 2009 18:17:18 +0000"  >One more thing, detected in a test run I left for the night. The VersionItemStateProvider.hasNodeReferences() call inside the scope of a workspace lock conflicts with the versioning lock held by another thread. The conflict can be seen in the following thread dump:&lt;br/&gt;
&lt;br/&gt;
HOLDS WORKSPACE LOCK, WAITS FOR VERSIONING LOCK&lt;br/&gt;
&amp;quot;Thread-577&amp;quot; prio=10 tid=0x0859ac00 nid=0x6e86 in Object.wait() [0xa487a000..0xa487af20]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: WAITING (on object monitor)&lt;br/&gt;
	at java.lang.Object.wait(Native Method)&lt;br/&gt;
	- waiting on &amp;lt;0xad082b20&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)&lt;br/&gt;
	at java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock.acquire(Unknown Source)&lt;br/&gt;
	- locked &amp;lt;0xad082b20&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$ReaderLock)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.&amp;lt;init&amp;gt;(DefaultISMLocking.java:86)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking$ReadLockImpl.&amp;lt;init&amp;gt;(DefaultISMLocking.java:80)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock(DefaultISMLocking.java:44)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock(SharedItemStateManager.java:1403)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.hasNodeReferences(SharedItemStateManager.java:350)&lt;br/&gt;
	at org.apache.jackrabbit.core.version.VersionItemStateProvider.hasNodeReferences(VersionItemStateProvider.java:142)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.hasNodeReferences(SharedItemStateManager.java:369)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.addReference(SharedItemStateManager.java:898)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.addReferences(SharedItemStateManager.java:883)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.updateReferences(SharedItemStateManager.java:866)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:560)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1056)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.update(SharedItemStateManager.java:1086)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:337)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.update(XAItemStateManager.java:347)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.LocalItemStateManager.update(LocalItemStateManager.java:312)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SessionItemStateManager.update(SessionItemStateManager.java:313)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemImpl.save(ItemImpl.java:1105)&lt;br/&gt;
	- locked &amp;lt;0xb0cc9e00&amp;gt; (a org.apache.jackrabbit.core.XASessionImpl)&lt;br/&gt;
	at org.apache.jackrabbit.core.SessionImpl.save(SessionImpl.java:846)&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeImpl.checkout(NodeImpl.java:3340)&lt;br/&gt;
	at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest$2.execute(ConcurrentVersioningWithTransactionsTest.java:119)&lt;br/&gt;
	at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:164)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
&lt;br/&gt;
HOLDS VERSIONING LOCK, WAITS FOR WORKSPACE LOCK&lt;br/&gt;
&amp;quot;Thread-571&amp;quot; prio=10 tid=0xa7991400 nid=0x6e80 in Object.wait() [0xa4ddb000..0xa4ddbe20]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: WAITING (on object monitor)&lt;br/&gt;
	at java.lang.Object.wait(Native Method)&lt;br/&gt;
	- waiting on &amp;lt;0xad082c28&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)&lt;br/&gt;
	at java.lang.Object.wait(Object.java:485)&lt;br/&gt;
	at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source)&lt;br/&gt;
	- locked &amp;lt;0xad082c28&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking$1.&amp;lt;init&amp;gt;(DefaultISMLocking.java:55)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireWriteLock(DefaultISMLocking.java:52)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireWriteLock(SharedItemStateManager.java:1419)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.access$200(SharedItemStateManager.java:116)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:547)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:1056)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:156)&lt;br/&gt;
	at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154)&lt;br/&gt;
	- locked &amp;lt;0xb0f06868&amp;gt; (a org.apache.jackrabbit.core.TransactionContext)&lt;br/&gt;
	at org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:324)&lt;br/&gt;
	at org.apache.jackrabbit.core.UserTransactionImpl.commit(UserTransactionImpl.java:121)&lt;br/&gt;
	at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest$2.execute(ConcurrentVersioningWithTransactionsTest.java:117)&lt;br/&gt;
	at org.apache.jackrabbit.core.AbstractConcurrencyTest$Executor.run(AbstractConcurrencyTest.java:164)&lt;br/&gt;
	at java.lang.Thread.run(Thread.java:619)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The VersionItemStateManager already avoids this conflict in the way it overrides the setNodeReferences() method, but it should do the same also for the get/hasNodeReferences() methods that are invoked by SharedItemStateManager when persisting normal workspace content.&lt;br/&gt;
</comment>
                    <comment id="12679292" author="jukkaz" created="Thu, 5 Mar 2009 18:39:52 +0000"  >Fixed the last issue as described in revision 750536. Merged the fix to the 1.5 branch in revision 750539.&lt;br/&gt;
&lt;br/&gt;
Everything seems good again, but I&amp;#39;ll schedule another test run over the night to catch any other regressions.</comment>
                </comments>
                    <attachments>
                    <attachment id="12401233" name="JCR-2000.patch" size="12197" author="jukkaz" created="Mon, 2 Mar 2009 11:55:09 +0000" />
                    <attachment id="12401232" name="JCR-2000.patch" size="1258" author="jukkaz" created="Mon, 2 Mar 2009 10:57:06 +0000" />
                    <attachment id="12401512" name="search-on-sism.patch" size="1178" author="jukkaz" created="Thu, 5 Mar 2009 11:55:26 +0000" />
                    <attachment id="12401402" name="thread-join.patch" size="3406" author="jukkaz" created="Wed, 4 Mar 2009 11:24:06 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 2 Mar 2009 12:35:56 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78360</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>192181</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>