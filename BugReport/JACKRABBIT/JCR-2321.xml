<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:54:57 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2321/JCR-2321.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2321] ZombieHierarchyManager can return wrong child node entries for replaced nodes</title>
                <link>https://issues.apache.org/jira/browse/JCR-2321</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The ZombieHierarchyManager currently implements the two getChildNodeEntry methods like this:&lt;br/&gt;
&lt;br/&gt;
1) look up child node in old, overlayed state, which might contain removed child nodes&lt;br/&gt;
2) if not found, ask the super implementation (ie. get the child node from the up-to-date list)&lt;br/&gt;
&lt;br/&gt;
The purpose of the ZombieHM is to be able to return removed item ids from the attic. However, the behavior above is IMO wrong, as it should first find an existing child node with the given name (or id):&lt;br/&gt;
&lt;br/&gt;
1) look up child node in super implementation (ie. get the child node from the up-to-date list)&lt;br/&gt;
2) if not found, look in the old, overlayed state if it might have been removed&lt;br/&gt;
&lt;br/&gt;
I was able to reproduce this issue when replacing a node (but note the custom access manager in 1.4.x used as explained below): create /replaced/subnode structure, save the session, remove the replaced node and add /replaced and then /replaced/subnode again:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node rootNode = session.getRootNode();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 1. create structure /replaced/subnode&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node test = rootNode.addNode(&amp;quot;replaced&amp;quot;, NT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test.addNode(&amp;quot;subnode&amp;quot;, NT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 2. persist changes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;session.save();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 3. remove node and recreate it&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test.remove();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test = rootNode.addNode(&amp;quot;replaced&amp;quot;, NT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 4. create previous child with same name&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test.addNode(&amp;quot;subnode&amp;quot;, NT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 5. =&amp;gt; gives exception&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;test.getNode(&amp;quot;subnode&amp;quot;).getNodes();&lt;br/&gt;
&lt;br/&gt;
To complicate things further, this was only triggered by a custom access manager, and all based upon Jackrabbit 1.4.x. Back then (pre-1.5 and new security stuff era), the access manager would get a ZombieHM as its hierarchy manager. If its implementation called resolvePath() on the HM for checking read-access in the final getNodes() call, where the tree will be traversed using the getChildNdeEntry(NodeState, Name, int) method, it would get the old node id and hence fail if it would try to retrieve it from the real item state manager.&lt;br/&gt;
&lt;br/&gt;
Thus with a Jackrabbit &amp;gt;= 1.5 and 2.0 the above code will work fine, because the ZombieHM is not used.&lt;br/&gt;
&lt;br/&gt;
However, we might want to fix it for 1.4.x and also check the other uses of the ZombieHM in the current trunk, which I couldn&amp;#39;t test. These are (explicit and implicit): ChangeLogBasedHierarchyMgr, SessionItemStateManager.getDescendantTransientItemStates(NodeId), ItemImpl.validateTransientItems(Iterable&amp;lt;ItemState&amp;gt;, Iterable&amp;lt;ItemState&amp;gt;) and SessionItemStateManager.getDescendantTransientItemStatesInAttic(NodeId).&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12436440">JCR-2321</key>
            <summary>ZombieHierarchyManager can return wrong child node entries for replaced nodes</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="alexander.klimetschek">Alexander Klimetschek</assignee>
                                <reporter username="alexander.klimetschek">Alexander Klimetschek</reporter>
                        <labels>
                    </labels>
                <created>Wed, 23 Sep 2009 19:05:53 +0100</created>
                <updated>Mon, 11 Jan 2010 14:16:24 +0000</updated>
                    <resolved>Wed, 30 Sep 2009 17:34:52 +0100</resolved>
                            <version>core 1.4.11</version>
                <version>1.5.7</version>
                <version>1.6</version>
                <version>2.0-beta1</version>
                                <fixVersion>2.0-beta1</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12758809" author="alexander.klimetschek" created="Wed, 23 Sep 2009 19:09:36 +0100"  >Added patch for the 1.4 branch that fixed the problem for me.&lt;br/&gt;
&lt;br/&gt;
(In theory, this patch should work on the 1.5 and 1.6 branches as well)</comment>
                    <comment id="12758810" author="alexander.klimetschek" created="Wed, 23 Sep 2009 19:12:45 +0100"  >Added patch for the trunk (as the code is using generics there, it required a different patch). Didn&amp;#39;t test that one as I couldn&amp;#39;t find a way to trigger the issue.</comment>
                    <comment id="12759088" author="stefan@jira" created="Thu, 24 Sep 2009 11:30:02 +0100"  >+1 for the patch, thanks!</comment>
                    <comment id="12760948" author="alexander.klimetschek" created="Wed, 30 Sep 2009 17:34:52 +0100"  >Fixed in revision 820337 in the trunk for 2.0. As this is less critical, there is no need to backport it to the 1.4, 1.5 or 1.6 branches.</comment>
                </comments>
                    <attachments>
                    <attachment id="12420394" name="JCR-2321-branch-1.4.patch" size="3807" author="alexander.klimetschek" created="Wed, 23 Sep 2009 19:09:33 +0100" />
                    <attachment id="12420395" name="JCR-2321-trunk.patch" size="2881" author="alexander.klimetschek" created="Wed, 23 Sep 2009 19:12:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 24 Sep 2009 10:30:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78263</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>252558</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>