<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:46:00 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2554/JCR-2554.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2554] Deadlock inside XASession on Weblogic</title>
                <link>https://issues.apache.org/jira/browse/JCR-2554</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>In one of our client deployments on WebLogic 9.2 we observed JackRabbit sessions going stale in a load test. This was observed against release 1.6.1 (to which we migrated due to concurrency related issues &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2081&quot; title=&quot;NameSet does not implement equals(Object) and hashCode() methods&quot;&gt;&lt;strike&gt;JCR-2081&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2237&quot; title=&quot;ItemManager registers itself as listener too early&quot;&gt;&lt;strike&gt;JCR-2237&lt;/strike&gt;&lt;/a&gt;). Same effect with 2.0.0.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
I could finally reproduce this issue locally. And it seems to boil down to WLS invoking the sequence of &amp;lt;prepare&amp;gt; ... &amp;lt;release&amp;gt; ... &amp;lt;commit&amp;gt; on one XA session from multiple threads, as it seems breaking assumptions of the thread-bound java.util.concurrent-RWLock based DefaultISMLocking class.&lt;br/&gt;
Effectively the setActiveXid(..) method on DefaultISMLocking$RWLock fails as the old active XID was not yet cleared. With the result of more and more sessions deadlocking in below&amp;#39;s invocation stack.&lt;br/&gt;
&lt;br/&gt;
{code}&lt;br/&gt;
&amp;quot;[ACTIVE] ExecuteThread: &amp;#39;27&amp;#39; for queue: &amp;#39;weblogic.kernel.Default (self-tuning)&amp;#39;&amp;quot; daemon prio=1 tid=0x33fc3ec0 nid=0x2324 in Object.wait() [0x2156a000..0x2156beb0] at java.lang.Object.wait(Native Method) - waiting on &amp;lt;0x68a54698&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock) at java.lang.Object.wait(Object.java:474) at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock.acquire(Unknown Source) - locked &amp;lt;0x68a54698&amp;gt; (a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock$WriterLock) at org.apache.jackrabbit.core.state.DefaultISMLocking$1.&amp;lt;init&amp;gt;(DefaultISMLocking.java:64) at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireWriteLock(DefaultISMLocking.java:61) at org.apache.jackrabbit.core.version.AbstractVersionManager.acquireWriteLock(AbstractVersionManager.java:146) at org.apache.jackrabbit.core.version.XAVersionManager$1.prepare(XAVersionManager.java:562) at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:154) - locked &amp;lt;0x6dc2ad88&amp;gt; (a org.apache.jackrabbit.core.TransactionContext) at org.apache.jackrabbit.core.XASessionImpl.prepare(XASessionImpl.java:331) at org.apache.jackrabbit.jca.TransactionBoundXAResource.prepare(TransactionBoundXAResource.java:68) at weblogic.connector.security.layer.AdapterLayer.prepare(AdapterLayer.java:397) at weblogic.connector.transaction.outbound.XAWrapper.prepare(XAWrapper.java:297) at weblogic.transaction.internal.XAServerResourceInfo.prepare(XAServerResourceInfo.java:1276) at weblogic.transaction.internal.XAServerResourceInfo.prepare(XAServerResourceInfo.java:499) at weblogic.transaction.internal.ServerSCInfo$1.execute(ServerSCInfo.java:335) at weblogic.kernel.Kernel.executeIfIdle(Kernel.java:243) at weblogic.transaction.internal.ServerSCInfo.startPrepare(ServerSCInfo.java:326) at weblogic.transaction.internal.ServerTransactionImpl.localPrepare(ServerTransactionImpl.java:2516) at weblogic.transaction.internal.ServerTransactionImpl.globalPrepare(ServerTransactionImpl.java:2211) at weblogic.transaction.internal.ServerTransactionImpl.internalCommit(ServerTransactionImpl.java:266) at weblogic.transaction.internal.ServerTransactionImpl.commit(ServerTransactionImpl.java:227) at weblogic.transaction.internal.TransactionManagerImpl.commit(TransactionManagerImpl.java:283) at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1028) at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:709) at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:678)&lt;br/&gt;
{code}</description>
                <environment>Weblogic 9.2</environment>
            <key id="12458651">JCR-2554</key>
            <summary>Deadlock inside XASession on Weblogic</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="c_koell">Claus K&#246;ll</assignee>
                                <reporter username="rsauer">Robert Sauer</reporter>
                        <labels>
                        <label>thread</label>
                        <label>xa</label>
                    </labels>
                <created>Wed, 10 Mar 2010 12:26:07 +0000</created>
                <updated>Tue, 27 Apr 2010 15:15:12 +0100</updated>
                    <resolved>Mon, 22 Mar 2010 07:41:07 +0000</resolved>
                            <version>1.6.1</version>
                <version>2.0</version>
                                <fixVersion>1.6.2</fixVersion>
                <fixVersion>2.1</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12843549" author="rsauer" created="Wed, 10 Mar 2010 12:27:45 +0000"  >The test driver is relatively simple as it just involves multiple threads reading from the repository in parallel sessions. Downside is just that I&amp;#39;m currently using an in house developed library on top of JCR which unfortuantely I cannot pass around.&lt;br/&gt;
&lt;br/&gt;
Working on an isolated test driver that talks just plain JCR, though.&lt;br/&gt;
</comment>
                    <comment id="12843558" author="c_koell" created="Wed, 10 Mar 2010 13:38:21 +0000"  >Could you attach your Implementation of ISM ?</comment>
                    <comment id="12843635" author="rsauer" created="Wed, 10 Mar 2010 17:10:53 +0000"  >I tried to be conservative and not replace DefaultISMLocking. Instead I just installed a special ISMLocking instance for AbstractVersionManager which uses the XID aware implementation if an XID is present or falls back to DefaultISMLocking otherwise.&lt;br/&gt;
&lt;br/&gt;
This patch was created against the 1.6.1 tag. Test for both jackrabbit-core and jackrabbit-jca are passing.&lt;br/&gt;
&lt;br/&gt;
The initial implementation was using java.util.concurrent APIs and my ad hoc tests indicate this had a somewhat higher througput than the oswego-concurrent based implementation contained in this patch (200 TX/s vs 165 TX/s).&lt;br/&gt;
&lt;br/&gt;
With this patch applied my test driver could repeatedly perform about 45.000 TXs from 45 concurrent threads without deadlocking connections.</comment>
                    <comment id="12843655" author="rsauer" created="Wed, 10 Mar 2010 17:38:15 +0000"  >Attaching my test driver. This is currently using a proprietary service tier in front of the JCR session but still the intention should be clear.&lt;br/&gt;
&lt;br/&gt;
The getFolder call basically just looks for the appropriate nt:folder node via the given path, and extracts some core atributes as well as sub nodes.&lt;br/&gt;
&lt;br/&gt;
Where can I find an example on how to provide a plain JackRabbit test case that can be deployed to an app server?</comment>
                    <comment id="12843940" author="c_koell" created="Thu, 11 Mar 2010 06:38:59 +0000"  >Hi Robert,&lt;br/&gt;
&lt;br/&gt;
Thank you for the Attachements ..  i will take a look on it so i look forward to create a good patch against the deadlock&lt;br/&gt;
&lt;br/&gt;
greets&lt;br/&gt;
claus</comment>
                    <comment id="12844000" author="c_koell" created="Thu, 11 Mar 2010 10:32:12 +0000"  >Hi Robert,&lt;br/&gt;
&lt;br/&gt;
Dou you have seen the warn message &amp;quot;Unable to set the ActiveXid while a other one is associated with a different GloalTransactionId with this RWLock.&amp;quot;&lt;br/&gt;
with the original DefaultISMLocking ?&lt;br/&gt;
&lt;br/&gt;
greets&lt;br/&gt;
claus</comment>
                    <comment id="12844010" author="rsauer" created="Thu, 11 Mar 2010 10:53:27 +0000"  >Essentially yes. I had breakpoint on all critical places, and this one was triggered.&lt;br/&gt;
&lt;br/&gt;
I assume the call sequences is as follows (having the JCA adapter driven by a WLS workmanager pool):&lt;br/&gt;
1. thread-a invokes prepare on behalf of XID_1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- the write lock is granted to thread-a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- XID_1 is stored as the ActiveXID&lt;br/&gt;
2. thread-a now invokes prepare on behalf of XID_2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- tries to acquire the write lock, theoretically it should block until XID_1 was committed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- but due to the previous association between the write lock and thread-a locking succeeds&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- thread-a now tries to set the ActiveXID to XID_2, but as XID_1 is still active, it will just trace a warning&lt;br/&gt;
3. thread-b invokes commit on behalf of XID_1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- the ActiveXID is cleared&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- the write lock gets released&lt;br/&gt;
4. eventually some thread invokes commit on behalf of XID_2, but as the ActiveXID was not set, signalling readers fails&lt;br/&gt;
&lt;br/&gt;
I did not know how to easily fix 2. as the lock-to-thread association seems to be fundamentally wrong in this case. So I started with the different approach contained in the patch.</comment>
                    <comment id="12844032" author="c_koell" created="Thu, 11 Mar 2010 11:38:55 +0000"  >You are absolutly right with your assumption.&lt;br/&gt;
&lt;br/&gt;
I have tried to create a TestCase but it is a little bit hard but i will try to create one :-)&lt;br/&gt;
The Problem is that the prefered locking strategy in the DefaultISMLocking is per Thread. I will&lt;br/&gt;
write a patch that hanldes this a little bit easier than yours one without having two ISMLocking Instances.&lt;br/&gt;
&lt;br/&gt;
greets&lt;br/&gt;
claus</comment>
                    <comment id="12844034" author="c_koell" created="Thu, 11 Mar 2010 11:40:45 +0000"  >Can you please test this patch in your environment ?&lt;br/&gt;
thanks</comment>
                    <comment id="12844051" author="c_koell" created="Thu, 11 Mar 2010 12:43:24 +0000"  >Found one more problem .. i will investigate and let you know if it works&lt;br/&gt;
greets</comment>
                    <comment id="12844058" author="rsauer" created="Thu, 11 Mar 2010 12:58:31 +0000"  >Ok, I was just about to verify but will wait then.&lt;br/&gt;
&lt;br/&gt;
Admittedly your patch is pretty elegant due to the small change required.&lt;br/&gt;
Still I have some reservation on having the underlying assumption of locks being bound to threads, and working around this assumption if an XID is present. Wonder how this carries over to java.util.concurrency eventually.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Robert&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12844091" author="c_koell" created="Thu, 11 Mar 2010 15:11:35 +0000"  >Now at first the Xid&amp;#39;s will be checked and then the default thread bound logic will work if we are not in a XAEnvironment.</comment>
                    <comment id="12844097" author="rsauer" created="Thu, 11 Mar 2010 15:38:32 +0000"  >About to test this. But I think there still is a race condition with markedXid. It should be a SynchronizedRef as it is written from an unguarded code block.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12844109" author="rsauer" created="Thu, 11 Mar 2010 16:15:01 +0000"  >With Xid_v2 applied It&amp;#39;s still hitting the error condition in DefaultISMLocking:136. Concurent threads are now deadlocking in DefaultISMLocking:67.</comment>
                    <comment id="12844117" author="rsauer" created="Thu, 11 Mar 2010 16:25:15 +0000"  >Xid_v2 + SynchronizedRef for markedXid. Still the same error.</comment>
                    <comment id="12844405" author="c_koell" created="Fri, 12 Mar 2010 07:57:20 +0000"  >A new patch that creates a lock on a mutex to prevent race conditions. i think we can use the DefaultISMLocking instance itself as mutex but&lt;br/&gt;
it would be fine if you could test this patch first ..&lt;br/&gt;
thanks&lt;br/&gt;
claus</comment>
                    <comment id="12844408" author="c_koell" created="Fri, 12 Mar 2010 08:00:05 +0000"  >i think that the internal Xid check is now ok but the problem is the race condition as we see in your picture attachement. i don&amp;#39;t know&lt;br/&gt;
how you implemented the SynchronizedRef but i hope with a sync on a mutex should help now :-)</comment>
                    <comment id="12844429" author="c_koell" created="Fri, 12 Mar 2010 09:00:01 +0000"  >Better to synchronize on the Object iteslf</comment>
                    <comment id="12844438" author="rsauer" created="Fri, 12 Mar 2010 09:55:52 +0000"  >Unfortunately still the same error.&lt;br/&gt;
&lt;br/&gt;
Would you mind if we try to work backwards from my known to be good patch and provide a variant that covers both scenarios with one class? I think the core change will be adjusting the XidLockInfo class towards a simple LockInfo that may either be associated with an XID or just a thread.&lt;br/&gt;
Even if something like this would end up in an additional class (similar to FineGrainedISMLocking) that can be configured in repository.xml if someone likes that would be pretty fine with me.</comment>
                    <comment id="12844445" author="c_koell" created="Fri, 12 Mar 2010 10:16:51 +0000"  >I would like to have the XA specific locking based on Xids working in the DefaultISMLocking so that nobody must configure something special&lt;br/&gt;
if you change your environment to XA. &lt;br/&gt;
I don&amp;#39;t know how it is still possible to acquire a writeLock and then the setActiveXid has a other globalTransactionId than the Xid first marked inside a synchronized block &lt;br/&gt;
that creates a lock on the instance itself ?&lt;br/&gt;
I will try to investigate more time to create a TestCase to get more informations about that race condition ..&lt;br/&gt;
</comment>
                    <comment id="12844449" author="rsauer" created="Fri, 12 Mar 2010 10:34:29 +0000"  >Fully understood.&lt;br/&gt;
&lt;br/&gt;
Do you know of any scenario where one instance of ISMLocking might need to serve both XA as well as non-XA requests? &lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12845070" author="c_koell" created="Sun, 14 Mar 2010 12:33:39 +0000"  >I don&amp;#39;t think that there is such scenario to handle both requests at one time.</comment>
                    <comment id="12845071" author="c_koell" created="Sun, 14 Mar 2010 12:42:48 +0000"  >Implemented a Patch that checks in similar way as your patch if there is a Xid present and switches between 2 ReentrantReadWriteLocks.&lt;br/&gt;
The different is that it is handled inside the DefaultISMLocking and uses the reentrant logic from used concurrent package.</comment>
                    <comment id="12845286" author="rsauer" created="Mon, 15 Mar 2010 12:22:37 +0000"  >Thanks, Claus. The v4 patch seems to do the trick.&lt;br/&gt;
&lt;br/&gt;
One question: the allowReader() method in XidRWLock does not consult the waitingWriters_ member, contrary to the super implementation of allowReader(). I guess not doing so will loose the writer-preference property of the super class. Was this intended?&lt;br/&gt;
I applied this change locally and still things look fine.&lt;br/&gt;
&lt;br/&gt;
Will this patch go into 1.6.2? Is there already a release date planned for 1.6.2? We&amp;#39;re very eager to be able to put the fix into production.&lt;br/&gt;
&lt;br/&gt;
I agree that reusing edu-concurrent is probably be the safer way to implement this fix right now. However, in face of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2089&quot; title=&quot;Use java.util.concurrent&quot;&gt;JCR-2089&lt;/a&gt; I&amp;#39;m curious how this will translate eventually.</comment>
                    <comment id="12845334" author="c_koell" created="Mon, 15 Mar 2010 14:46:29 +0000"  >Sounds good that it works now :-)&lt;br/&gt;
&lt;br/&gt;
I dont know if we should consult the waitingWriters_ because this code was introduced in the internal RWLock while ago .. and i don&amp;#39;t know exactly why ?&lt;br/&gt;
Yes you are right we will look how we migrate that code to the java1.5 concurrent implementation ...&lt;br/&gt;
&lt;br/&gt;
I will tag this issue to 1.6.2 so it will be in that release but i don&amp;#39;t know the release date. &lt;br/&gt;
Please feel free to post to the dev-mailing list so we can discuss release date there&lt;br/&gt;
greets&lt;br/&gt;
claus</comment>
                    <comment id="12845349" author="c_koell" created="Mon, 15 Mar 2010 15:09:41 +0000"  >Fixed in rev. 923277</comment>
                    <comment id="12845355" author="rsauer" created="Mon, 15 Mar 2010 15:22:33 +0000"  >&lt;br/&gt;
My interpretation is that it implements the WriterPreference part of the WriterPreferenceReadWriteLock super class. Essentially allowing no new readers as long as there is someone waiting to write (see JavaDoc of WriterPreferenceReadWriteLock).&lt;br/&gt;
I would suggest to stay as close as possible to the super implementation of overridden methods. It&amp;#39;s part of both allowWriter() implementations for ReentrantWriterPreferenceReadWriteLock as well as WriterPreferenceReadWriteLock.&lt;br/&gt;
&lt;br/&gt;
Practical side effect should be that TX-finalization will tend to be quicker in a mixed read/write scenario as parallel readers will not be able to starve 2PC requests.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12845742" author="c_koell" created="Tue, 16 Mar 2010 06:42:14 +0000"  >I have taken a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1600&quot; title=&quot;Remove noLockHack in SharedItemStateManager&quot;&gt;&lt;strike&gt;JCR-1600&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-447&quot; title=&quot;deadlock on concurrent commit/locking&quot;&gt;&lt;strike&gt;JCR-447&lt;/strike&gt;&lt;/a&gt; where the code was introduced but i found no reason why this code was modified in that way to ignore the waitingWriters_ variable. I will change the code to work as the SuperClass should work.&lt;br/&gt;
greets</comment>
                    <comment id="12846809" author="c_koell" created="Thu, 18 Mar 2010 09:22:55 +0000"  >Found one more deadlock problem must reopen it ..</comment>
                    <comment id="12846817" author="rsauer" created="Thu, 18 Mar 2010 09:46:29 +0000"  >What&amp;#39;s the background? I would like to extend my test driver to may be expose this issue locally, too.&lt;br/&gt;
&lt;br/&gt;
Thanks&lt;br/&gt;
Robert &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12846822" author="c_koell" created="Thu, 18 Mar 2010 10:06:08 +0000"  >On the first look i think the problem is in the LockManagerImpl. With the last commit I have reverted the code from the internal lockMapLock (ReentrantLock).&lt;br/&gt;
In that ReentrantLock there was a code with Xid aware but i have removed that because i thought that we do not need it anymore but in our&lt;br/&gt;
environment it causes deadlocks. I will take a deeper look on that.&lt;br/&gt;
greets</comment>
                    <comment id="12848048" author="c_koell" created="Mon, 22 Mar 2010 07:41:07 +0000"  >Implemented a Xid aware ReentrantLock in LockManagerImpl and now no deadlocks have been occured anymore in our environment.</comment>
                    <comment id="12848100" author="rsauer" created="Mon, 22 Mar 2010 12:26:32 +0000"  >Thanks, Claus. Can you provide a patch against 1.6.1 so I can additionally verify against our environment, too?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12848642" author="c_koell" created="Tue, 23 Mar 2010 10:20:48 +0000"  >Hi .. here is the patch ...&lt;br/&gt;
&lt;br/&gt;
greets&lt;br/&gt;
claus</comment>
                    <comment id="12861405" author="jukkaz" created="Tue, 27 Apr 2010 15:15:12 +0100"  >Merged to the 1.6 branch in revision 938462.</comment>
                </comments>
                    <attachments>
                    <attachment id="12438424" name="ConcurrentReaders.java" size="5598" author="rsauer" created="Wed, 10 Mar 2010 17:38:15 +0000" />
                    <attachment id="12438417" name="jr-core-xid-aware-ism-locking1.patch" size="16175" author="rsauer" created="Wed, 10 Mar 2010 17:10:53 +0000" />
                    <attachment id="12439560" name="LockManager.patch" size="4307" author="c_koell" created="Tue, 23 Mar 2010 10:20:48 +0000" />
                    <attachment id="12438502" name="Xid.patch" size="3255" author="c_koell" created="Thu, 11 Mar 2010 11:40:45 +0000" />
                    <attachment id="12438515" name="Xid_v2 deadlock.jpg" size="63220" author="rsauer" created="Thu, 11 Mar 2010 16:07:54 +0000" />
                    <attachment id="12438514" name="Xid_v2.patch" size="5000" author="c_koell" created="Thu, 11 Mar 2010 15:11:35 +0000" />
                    <attachment id="12438518" name="Xid_v2 + SynchronizedRef for markedXid.jpg" size="64855" author="rsauer" created="Thu, 11 Mar 2010 16:25:14 +0000" />
                    <attachment id="12438599" name="Xid_v3.patch" size="5355" author="c_koell" created="Fri, 12 Mar 2010 09:00:01 +0000" />
                    <attachment id="12438750" name="Xid_v4.patch" size="12561" author="c_koell" created="Sun, 14 Mar 2010 12:42:48 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>9.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 10 Mar 2010 13:38:21 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78181</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>189826</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>