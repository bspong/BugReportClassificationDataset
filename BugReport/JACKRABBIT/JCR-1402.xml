<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:41:42 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1402/JCR-1402.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1402] Path.getAncestor and Path.isAncestor are not symmetric</title>
                <link>https://issues.apache.org/jira/browse/JCR-1402</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Although the method names refer to ancestors they operate on sub-paths. Consider:&lt;br/&gt;
&lt;br/&gt;
PathFactory pf = PathFactoryImpl.getInstance();&lt;br/&gt;
Path.Element p = pf.getParentElement();&lt;br/&gt;
&lt;br/&gt;
Path path = pf.create(new Path.Element[]{p, p});&lt;br/&gt;
Path ancestor = path.getAncestor(1);&lt;br/&gt;
&lt;br/&gt;
assertFalse(ancestor.isAncestorOf(path) )  &lt;br/&gt;
&lt;br/&gt;
This is not what one would expect from looking an the method signatures. &lt;br/&gt;
I suggest to rename getAncestor to getSubPath, clarify the javadoc, and deprecate getAncestorCount. &lt;br/&gt;
&lt;br/&gt;
A patch follows.&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12389121">JCR-1402</key>
            <summary>Path.getAncestor and Path.isAncestor are not symmetric</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="anchela">angela</assignee>
                                <reporter username="mduerig">Michael D&#252;rig</reporter>
                        <labels>
                    </labels>
                <created>Wed, 20 Feb 2008 13:53:54 +0000</created>
                <updated>Wed, 16 Jul 2008 14:45:32 +0100</updated>
                    <resolved>Thu, 10 Apr 2008 14:41:29 +0100</resolved>
                            <version>1.4</version>
                                                <component>jackrabbit-spi</component>
                <component>jackrabbit-spi-commons</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12570692" author="mduerig" created="Wed, 20 Feb 2008 13:57:22 +0000"  >Patch for renaming getAncestor, clarifying javadoc and deprecating getAncestorCount. Also contains a test case</comment>
                    <comment id="12571366" author="stefan@jira" created="Fri, 22 Feb 2008 11:54:35 +0000"  >-1 for the proposed change. &lt;br/&gt;
&lt;br/&gt;
the specified Path methods are IMO adequately named. they&amp;#39;re expected to operate on normalized paths. &lt;br/&gt;
the javadoc warns about unexpected results when called on non-normalized paths (such as &amp;quot;../..&amp;quot;).&lt;br/&gt;
&lt;br/&gt;
the real issue at hand is IMO a bug in the PathFactory implementation. &lt;br/&gt;
PathFactoryImpl creates illegal and inconsistent Path objects. see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1409&quot; title=&quot;PathFactoryImpl creates illegal Path objects&quot;&gt;&lt;strike&gt;JCR-1409&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
Path#isAncestorOf expects normalized paths and throws if that&amp;#39;s not the case.   &lt;br/&gt;
however, both paths used in your example (i.e. &amp;quot;../&amp;#39;..&amp;quot; and &amp;quot;..&amp;quot;) are non-normailzed&lt;br/&gt;
but Path#isNormalized returns true for both of them...&lt;br/&gt;
&lt;br/&gt;
it seems like the Path semantics got unfortunately somehow compromised by the&lt;br/&gt;
introduction of the PathFactory interface and the related refactoring to spi-commons.</comment>
                    <comment id="12571383" author="mduerig" created="Fri, 22 Feb 2008 12:45:28 +0000"  >&amp;gt; they&amp;#39;re expected to operate on normalized paths. &lt;br/&gt;
Then the documentation of the relevant methods of the Path interface should say so. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;s suggest: remove &amp;quot;Note that there migth be an unexpected result if this path is not normalized, e.g. the ancestor of degree = 1 of the path &amp;quot;../..&amp;quot; would be &amp;quot;..&amp;quot; although this is not the parent of &amp;quot;../..&amp;quot;.&amp;quot; and add &amp;quot;IllegalArgumentException if this path is not normalized&amp;quot; to the javadoc of getAncestor.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; it seems like the Path semantics got unfortunately somehow compromised&lt;br/&gt;
There are two different things which got mixed up: paths and the hierarchy they denote. Some methods make that separation pretty clear: getDepth refers to the hirarchy and getLength to the path. However with the ancestor/descendant methods this separation is currently not that clear: although one expects them to refer to the hierarchy the current default implementation does suggest otherwise and the documentation is not clear enough (see above).</comment>
                    <comment id="12571397" author="stefan@jira" created="Fri, 22 Feb 2008 13:10:29 +0000"  >[...]&lt;br/&gt;
&amp;gt;  &amp;gt; they&amp;#39;re expected to operate on normalized paths.&lt;br/&gt;
&amp;gt;  Then the documentation of the relevant methods of the Path interface should say so.&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;  I&amp;#39;s suggest: remove &amp;quot;Note that there migth be an unexpected result if this path is not normalized, e.g. the ancestor of degree = 1 of the path &amp;quot;../..&amp;quot; would be &amp;quot;..&amp;quot; although this is not the parent of &amp;quot;../..&amp;quot;.&amp;quot; and add &amp;quot;IllegalArgumentException if this path is not normalized&amp;quot; to the javadoc of getAncestor.&lt;br/&gt;
&lt;br/&gt;
+1 for javadoc improvement. i am not sure about the IllegalArgumentException...&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt;  &amp;gt; it seems like the Path semantics got unfortunately somehow compromised&lt;br/&gt;
&amp;gt;  There are two different things which got mixed up: paths and the hierarchy they denote. Some methods make that separation pretty clear: getDepth refers to the hirarchy and getLength to the path. However with the ancestor/descendant methods this separation is currently not that clear: although one expects them to refer to the hierarchy the current default implementation does suggest otherwise and the documentation is not clear enough (see above).&lt;br/&gt;
&lt;br/&gt;
the implementation suggesting otherwise is a bug, see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1409&quot; title=&quot;PathFactoryImpl creates illegal Path objects&quot;&gt;&lt;strike&gt;JCR-1409&lt;/strike&gt;&lt;/a&gt; ;)&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;IMO getAncestor clearly refers to the hierarchical nature of a path.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  </comment>
                    <comment id="12571402" author="mduerig" created="Fri, 22 Feb 2008 13:19:10 +0000"  >&amp;gt; i am not sure about the IllegalArgumentException&lt;br/&gt;
We could also leave the behavior undefined for not normalized paths. However I think throwing an exception is more explicit and make it easier to detect cases where some code (inadvertently) relies on such behavior.</comment>
                    <comment id="12571446" author="anchela" created="Fri, 22 Feb 2008 15:49:15 +0000"  >i&amp;#39;m in favor of the IllegalArgumentException. having undefined behaviour with an interface&lt;br/&gt;
looks strange to me.... and there are quite some other possibilities for illegalargumentexception.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12573184" author="anchela" created="Thu, 28 Feb 2008 08:49:22 +0000"  >i took a closer look at isAncestor, getAncestor and the original/current definition of a normalized path:&lt;br/&gt;
&lt;br/&gt;
- .. and ../.. are normalized according to the definition Path (normalized = no redundant elements)&lt;br/&gt;
- the problem is that getAncestor does not require the Path to be normalized (and nor does any of the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;implementation normalize it) before retrieving the ancestor. &lt;br/&gt;
- in contrast &amp;#39;isAncestor&amp;#39; does convert non-normalized path first (and throws if that fails)&lt;br/&gt;
- the problem with normalized paths containing the parent element is, that the parent of .. was ../.. &lt;br/&gt;
&amp;nbsp;&amp;nbsp;this special case not handled properly neither by isAncestor nor by getAncestor.&lt;br/&gt;
&lt;br/&gt;
i would therefore suggest to:&lt;br/&gt;
&lt;br/&gt;
= require Path.getAncestor to normalize the path before retrieving the ancestor.&lt;br/&gt;
= add RepositoryException to the method signature of Path.getAncestor (RepositoryException if the path&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;cannot be normalized).&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;[ question: would this be a huge backward compat problem?]&lt;br/&gt;
&lt;br/&gt;
= Clarify that &amp;#39;isAncestor&amp;#39; must treat the parent element properly&lt;br/&gt;
= Clarify that &amp;#39;getAncestor&amp;#39; must treat the parent element properly&lt;br/&gt;
= Clarify that &amp;#39;isAncestor&amp;#39; and &amp;#39;getAncestor&amp;#39; must be symmetric.&lt;br/&gt;
&lt;br/&gt;
what do you think?&lt;br/&gt;
angela</comment>
                    <comment id="12573206" author="mduerig" created="Thu, 28 Feb 2008 10:09:59 +0000"  >Another idea I recently had:&lt;br/&gt;
&lt;br/&gt;
Implement Path.getAncestor(n) by adding n parent elements to the end of the path. That way the ancestor is defined for any path. normalized or not, relative or absolute. &lt;br/&gt;
&lt;br/&gt;
Implement Path.isAncestorOf as follows: (isDescendant is similar)&lt;br/&gt;
&lt;br/&gt;
- if not both paths are either relative or absolute, throw some exception.&lt;br/&gt;
- If both paths are relative determine their depths n and m. Say n &amp;lt; m. If n &amp;lt; 0, add -n arbitrary elements at the beginning of both paths. &lt;br/&gt;
Normalize the paths and check if this paths elements are a prefix of that paths elements.&lt;br/&gt;
&lt;br/&gt;
With this approach the interface will not have to change and the implementation will be correct (i.e. isAncestor(getAncestor()) == true) for every path accepted by those methods. There might be a compatibility issue with implementations which rely on the current behavior of getAncestor returning ../ when called with ../../ However, I think this should be fixed in the implementation rather than keeping a core interface with a &amp;#39;bogus&amp;#39; specification. &lt;br/&gt;
</comment>
                    <comment id="12573670" author="stefan@jira" created="Fri, 29 Feb 2008 10:39:17 +0000"  >&amp;gt;  Another idea I recently had:&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;  Implement Path.getAncestor(n) by adding n parent elements to the end of the path. That way the ancestor is defined for any path. normalized or not, relative or absolute.&lt;br/&gt;
&lt;br/&gt;
while i think it&amp;#39;s an elegant approach and the result would be certainly correct i don&amp;#39;t think it&amp;#39;s what the api consumer needs.&lt;br/&gt;
&lt;br/&gt;
Path.getAncestor(int) is heavily used in jackrabbit core. here&amp;#39;s a common usage pattern:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parentPath = targetPath.getAncestor(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parentId = hierMgr.resolveNodePath(parentPath);&lt;br/&gt;
&lt;br/&gt;
the suggested approach would probably not improve efficiency ;)&lt;br/&gt;
&lt;br/&gt;
i&amp;#39;m further afraid that the change could break the current CachingHierarchyManager implementation;&lt;br/&gt;
here&amp;#39;s a usage example:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PathMap.Element parent = pathCache.map(path.getAncestor(1), true);&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
i&amp;#39;d therefore prefer angela&amp;#39;s suggestion.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;  Implement Path.isAncestorOf as follows: (isDescendant is similar)&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;  - if not both paths are either relative or absolute, throw some exception.&lt;br/&gt;
&amp;gt;  - If both paths are relative determine their depths n and m. Say n &amp;lt; m. If n &amp;lt; 0, add -n arbitrary elements at the beginning of both paths.&lt;br/&gt;
&amp;gt;  Normalize the paths and check if this paths elements are a prefix of that paths elements.&lt;br/&gt;
&amp;gt;  &lt;br/&gt;
&amp;gt;  With this approach the interface will not have to change and the implementation will be correct (i.e. isAncestor(getAncestor()) == true) for every path accepted by those methods. There might be a compatibility issue with implementations which rely on the current behavior of getAncestor returning ../ when called with ../../ However, I think this should be fixed in the implementation rather than keeping a core interface with a &amp;#39;bogus&amp;#39; specification.</comment>
                    <comment id="12573796" author="mduerig" created="Fri, 29 Feb 2008 15:47:43 +0000"  >Ok, I suggest the following for getAncestor (credits due to Angela):&lt;br/&gt;
&lt;br/&gt;
- If the path is absolute, normalize and determine ancestor of given degree. Throw if this would result in a &amp;#39;negative&amp;#39; path.&lt;br/&gt;
- If the path is relative just add an appropriate number of parent elements.&lt;br/&gt;
&lt;br/&gt;
Together with my proposal for isAncestorOf and isDescendant this is in accordance with Angela&amp;#39;s suggestion while still handling relative paths correctly (i.e. isAncestor(getAncestor()) == true). Moreover there is no problem for above usage patterns.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12587641" author="anchela" created="Thu, 10 Apr 2008 14:41:29 +0100"  >fixed with resolution of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1526&quot; title=&quot;Various improvment to Path and PathImpl&quot;&gt;&lt;strike&gt;JCR-1526&lt;/strike&gt;&lt;/a&gt;.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310010">
                <name>Incorporates</name>
                                                <inwardlinks description="is part of">
                            <issuelink>
            <issuekey id="12393417">JCR-1526</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12376023" name="path.patch" size="6544" author="mduerig" created="Wed, 20 Feb 2008 13:57:22 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 22 Feb 2008 11:54:35 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142676</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>279880</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>