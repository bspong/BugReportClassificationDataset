<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:58:58 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-3151/JCR-3151.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-3151] SharedFieldCache can cause a memory leak</title>
                <link>https://issues.apache.org/jira/browse/JCR-3151</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The SharedFieldCache has some problems with the way it builds the cache:&lt;br/&gt;
&amp;nbsp;- as key is has the IndexReader&lt;br/&gt;
&amp;nbsp;- as value it has a inner cache (another map) that has as a key a static inner class called &amp;#39;Key&amp;#39;.&lt;br/&gt;
&lt;br/&gt;
This &amp;#39;Key&amp;#39; holds a reference to the comparator used for in the queries ran.&lt;br/&gt;
Assuming this comparator is of any type that extends from AbstractFieldComparator (I think all of the custom JR comparators), then it keeps a reference to all the InderReader instances in order to be able to load the values as Comparable(s).&lt;br/&gt;
&lt;br/&gt;
So the circle is complete and the SharedFieldCache entries never get GC&amp;#39;ed.&lt;br/&gt;
&lt;br/&gt;
One option would have been to implement a &amp;#39;purge&amp;#39; method on the cache, similar to the lucene mechanism, and when an InderReader gets closed is could call &amp;#39;purge&amp;#39;. But that is both ugly AND is doesn&amp;#39;t seem to work that well :)&lt;br/&gt;
&lt;br/&gt;
A more radical option is to remove the cache completely. Each instance of SimpleFieldComparator (the only client of this cache) already builds an array of the available values, so the cache would only help other instances of the same type. We&amp;#39;ll not analyze this further.&lt;br/&gt;
&lt;br/&gt;
The proposed solution (patch will follow shortly) is to remove the Comparator reference from the Key class. &lt;br/&gt;
It looks like it has no real purpose there, just to impact the &amp;#39;equals&amp;#39; of the key, which makes no sense in the first place as the lucene query does not use the Comparator info at all.&lt;br/&gt;
If anything, using the same field and 2 different Comparators we&amp;#39;ll get 2 different cache entries based on the same values from the lucene index.&lt;br/&gt;
&lt;br/&gt;
Feedback is appreciated!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12532333">JCR-3151</key>
            <summary>SharedFieldCache can cause a memory leak</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="alex.parvulescu">Alex Parvulescu</assignee>
                                <reporter username="alex.parvulescu">Alex Parvulescu</reporter>
                        <labels>
                    </labels>
                <created>Tue, 22 Nov 2011 14:00:35 +0000</created>
                <updated>Tue, 6 Dec 2011 14:47:11 +0000</updated>
                    <resolved>Wed, 23 Nov 2011 10:52:01 +0000</resolved>
                                            <fixVersion>2.3.4</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13155156" author="alex.parvulescu" created="Tue, 22 Nov 2011 14:15:27 +0000"  >attached patch.&lt;br/&gt;
&lt;br/&gt;
fair warning;, it also contains some cosmetics involving Comparable (my eyes hurt from all those warnings in eclipse :)</comment>
                    <comment id="13155324" author="mduerig" created="Tue, 22 Nov 2011 18:24:27 +0000"  >After having looked at the code and the patch this looks good to me so far. I think the conclusion regarding granularity of equals of the Key class holds. That is, there is no harm in removing the comperator field from the Key class.&lt;br/&gt;
&lt;br/&gt;
The comperator field has been part of the Key class since beginning of times (since &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-106&quot; title=&quot;Minimize use of fields in lucene index&quot;&gt;&lt;strike&gt;JCR-106&lt;/strike&gt;&lt;/a&gt; that is). Maybe Marcel still remembers the rational for this. &lt;br/&gt;
&lt;br/&gt;
I will still do some testing of the patch to see whether it actually fixes the memory leak and document my findings here later. &lt;br/&gt;
</comment>
                    <comment id="13155350" author="mduerig" created="Tue, 22 Nov 2011 19:02:56 +0000"  >Testing indicates that the patch indeed works: Without the patch applied, executing a query with an order by clause in a loop will eat up memory very quickly and eventually result in an OOME. With the patch applied, I can see memory decreasing up to a certain limit where GC kicks in an the lower bound on free memory keeps stable. Also the jackrabbit-core test cases run. So I&amp;#39;m all fine with the patch.</comment>
                    <comment id="13155493" author="mduerig" created="Tue, 22 Nov 2011 22:20:56 +0000"  >On a second though removing the comperator field from the Key class might have some subtle side effects. The patch might break things in the situation where different ValueIndex instances should go into the cache for the same field and same prefix but a for a different FieldComparator implementation: despite different, both ValueIndex instances end up at the same cache slot.&lt;br/&gt;
&lt;br/&gt;
To be on the safe side I think the comperator should thus &amp;#39;somehow&amp;#39; stay in the Key class. One solution might be to use a WeakReference instead the comperator instance itself. Another (a bit hacky) solution might be to use the comepator&amp;#39;s hashCode instead of the comperator instance itself.</comment>
                    <comment id="13155528" author="alex.parvulescu" created="Tue, 22 Nov 2011 22:47:47 +0000"  >&amp;gt; The patch might break things in the situation where different ValueIndex instances should go into the cache for the same field and same prefix but a for a different FieldComparator implementation: despite different, both ValueIndex instances end up at the same cache slot.&lt;br/&gt;
&lt;br/&gt;
Agreed, what I cannot understand is the relation between the ValueIndex and the provided field comparator implementation. To me they are 2 different things. Just look at how the ValueIndex cache is being build.&lt;br/&gt;
So I&amp;#39;m not sure if them &amp;quot;ending up at the same cache slot&amp;quot; is actually a bad thing :)&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13155538" author="mduerig" created="Tue, 22 Nov 2011 22:54:17 +0000"  >&amp;gt; So I&amp;#39;m not sure if them &amp;quot;ending up at the same cache slot&amp;quot; is actually a bad thing :) &lt;br/&gt;
&lt;br/&gt;
Yes same here. That&amp;#39;s way I asked Marcel to comment on this. AFAIK the initial code is from him.</comment>
                    <comment id="13155547" author="mduerig" created="Tue, 22 Nov 2011 23:02:56 +0000"  >I tested both my suggestions from above. Both works so far. With the WeakReference based approach one has to take care to use a super class which overrides equals and hashCode delegating to the referent. Also this approach seems heavier on GC: I see more GC cycles than with the hash code based approach. </comment>
                    <comment id="13155797" author="mreutegg" created="Wed, 23 Nov 2011 10:28:02 +0000"  >Hmm, I can&amp;#39;t remember why the comparator source is part of the Key. I agree with both of you that it isn&amp;#39;t necessary because it has no influence on the ValueIndex that is created.&lt;br/&gt;
&lt;br/&gt;
+1 for the patch.</comment>
                    <comment id="13155798" author="alex.parvulescu" created="Wed, 23 Nov 2011 10:31:51 +0000"  >If we decide to keep any kind of reference to the comparator instance, I&amp;#39;d go with the hash code approach.&lt;br/&gt;
It seems really lightweight and it provides enough uniqueness for the cache key to avoid potential collision.</comment>
                    <comment id="13155799" author="alex.parvulescu" created="Wed, 23 Nov 2011 10:37:33 +0000"  >thanks for the feedback guys!&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll apply the patch shortly.</comment>
                    <comment id="13155802" author="alex.parvulescu" created="Wed, 23 Nov 2011 10:52:01 +0000"  >Fixed in revision 1205361.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                                <inwardlinks description="is depended upon by">
                            <issuelink>
            <issuekey id="12500061">JCR-2906</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12504752" name="JCR-3151.patch" size="16690" author="alex.parvulescu" created="Tue, 22 Nov 2011 14:15:27 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 22 Nov 2011 18:24:27 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>218067</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>235336</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>