<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:29:49 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2906/JCR-2906.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2906] Multivalued property sorted by last/random value</title>
                <link>https://issues.apache.org/jira/browse/JCR-2906</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Sorting on multivalued property may produce incorrect result because sorting is performed only by last value of multivalued property.&lt;br/&gt;
Steps to reproduce:&lt;br/&gt;
1. Create multivalued field in repository. Example from nodetypes file:&lt;br/&gt;
&amp;lt;propertyDefinition name=&amp;quot;MyProperty&amp;quot; requiredType=&amp;quot;String&amp;quot; autoCreated=&amp;quot;false&amp;quot; mandatory=&amp;quot;false&amp;quot;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;onParentVersion=&amp;quot;COPY&amp;quot; protected=&amp;quot;false&amp;quot; multiple=&amp;quot;false&amp;quot;&amp;gt;&lt;br/&gt;
2. Create few records so that all records except one would contain single value for MyProperty and one record would contain &lt;br/&gt;
first value which is greater then of any other record and the second value is somewhere in the middle. Here is an example:&lt;br/&gt;
1st record: &amp;quot;aaaa&amp;quot;&lt;br/&gt;
2nd record: &amp;quot;cccc&amp;quot;&lt;br/&gt;
3rd record: &amp;quot;dddd&amp;quot;, &amp;quot;bbbb&amp;quot;&lt;br/&gt;
3. Run some query which sorts Example of XPath query:&lt;br/&gt;
//*[...here are some criteria...] order by @MyProperty ascending&lt;br/&gt;
The query would return documents in such order:&lt;br/&gt;
&amp;quot;aaaa&amp;quot;&lt;br/&gt;
&amp;quot;dddd&amp;quot;, &amp;quot;bbbb&amp;quot;&lt;br/&gt;
&amp;quot;cccc&amp;quot;&lt;br/&gt;
which is not expected order (expected same order as they were entered - as &amp;quot;aaaa&amp;quot; &amp;lt; &amp;quot;cccc&amp;quot;, &amp;quot;cccc&amp;quot; &amp;lt; &amp;quot;dddd&amp;quot;)&lt;br/&gt;
&lt;br/&gt;
After some digging I found out that it happens because method &lt;br/&gt;
org.apache.jackrabbit.core.query.lucene.SharedFieldCache.getValueIndex&lt;br/&gt;
(called from org.apache.jackrabbit.core.query.lucene.SharedFieldSortComparator.SimpleScoreDocComparator constructor)&lt;br/&gt;
returns only last Comparable of the document. Here is overwrites previous value:&lt;br/&gt;
retArray[termDocs.doc()] = getValue(value, type);&lt;br/&gt;
&lt;br/&gt;
I tried to concatenate comparables (just to check if it would work for my case):&lt;br/&gt;
	if(retArray[termDocs.doc()] == null) {&lt;br/&gt;
		retArray[termDocs.doc()] = getValue(value, type);&lt;br/&gt;
	} else {&lt;br/&gt;
		retArray[termDocs.doc()] =&lt;br/&gt;
				retArray[termDocs.doc()] + &amp;quot; &amp;quot; + getValue(value, type);&lt;br/&gt;
	}&lt;br/&gt;
But it didn&amp;#39;t worked well either - TermEnum returns terms not in the same order as JackRabbit returns values of multivalued field&lt;br/&gt;
(as an example [&amp;quot;qwer&amp;quot;, &amp;quot;asdf&amp;quot;] may become [&amp;quot;asdf&amp;quot;, &amp;quot;qwer&amp;quot;] ). So, simple concatenation doesn&amp;#39;t help.&lt;br/&gt;
</description>
                <environment>Windows 7, Sun JDK 1.6.0_23</environment>
            <key id="12500061">JCR-2906</key>
            <summary>Multivalued property sorted by last/random value</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="alex.parvulescu">Alex Parvulescu</assignee>
                                <reporter username="paul.lysak">Paul Lysak</reporter>
                        <labels>
                        <label>multivalued</label>
                        <label>sort</label>
                    </labels>
                <created>Tue, 1 Mar 2011 15:31:51 +0000</created>
                <updated>Thu, 2 May 2013 03:30:55 +0100</updated>
                    <resolved>Thu, 1 Dec 2011 13:09:57 +0000</resolved>
                            <version>2.2</version>
                                <fixVersion>2.3.5</fixVersion>
                                <component>indexing</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13000990" author="alexander.klimetschek" created="Tue, 1 Mar 2011 17:58:00 +0000"  >&amp;gt; which is not expected order (expected same order as they were entered ...)&lt;br/&gt;
&lt;br/&gt;
But when you specify &amp;quot;order by @MyProperty ascending&amp;quot; you explicitly want to order by the property, not the document order.&lt;br/&gt;
&lt;br/&gt;
AFAICS the JCR 1.0 and 2.0 spec don&amp;#39;t define any behavior for comparing single-value properties to multi-value ones (or mv to mv), so I think the repository implementation is free to chose the most efficient one. Hence this is not a bug.&lt;br/&gt;
&lt;br/&gt;
Also, it is not clear how to define an ordering upon multi-value properties at all: Compare against the concatenation of the string representations of all the values in the property? Or compare against the first value?</comment>
                    <comment id="13001357" author="paul.lysak" created="Wed, 2 Mar 2011 09:54:53 +0000"  >I think lexicographical order would be the natural approach. Like this:&lt;br/&gt;
1) [&amp;quot;aaa&amp;quot;, &amp;quot;ddd&amp;quot;] comes before [&amp;quot;ccc&amp;quot;, &amp;quot;bbb&amp;quot;] because &amp;quot;aaa&amp;quot;&amp;lt;&amp;quot;ccc&amp;quot;&lt;br/&gt;
2) [&amp;quot;ccc&amp;quot;, &amp;quot;ddd&amp;quot;] comes after [&amp;quot;ccc&amp;quot;, &amp;quot;bbb&amp;quot;] because &amp;quot;ccc&amp;quot;==&amp;quot;ccc&amp;quot; and &amp;quot;ddd&amp;quot;&amp;gt;&amp;quot;bbb&amp;quot;.&lt;br/&gt;
</comment>
                    <comment id="13156612" author="alex.parvulescu" created="Thu, 24 Nov 2011 09:49:41 +0000"  >Really good analysis, thanks for pointing out where the problem is!&lt;br/&gt;
&lt;br/&gt;
The problem is not that the JCR spec may or may not define sorting on a multi-valued property. the problem is the sort behavior is not stable when dealing with MVPs.&lt;br/&gt;
&lt;br/&gt;
Like Paul correctly pointed out, whenever there is a MVP present, the value in the cache gets overwritten by the last value found by the lucene Term query. So in fact an MVP is represented in the sort by just one of its values (which can apparently change at runtime - that is easily reproducible by running the attached test a few times).&lt;br/&gt;
&lt;br/&gt;
The solution is to use the position info that comes via lucene&amp;#39;s TermPositions. This does contain the term&amp;#39;s position within the current document allowing us to use it as an index for MVPs.&lt;br/&gt;
The downside is that the Comparables have to support arrays as well as simple values, so I&amp;#39;ve added a class (ComparableArray) that simply delegates compareTo calls to the inner array of Comparables. This way all the sql languages (xpath&amp;amp;sql&amp;amp;sql2) have similar sort for MVPs.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Attaching patch.&lt;br/&gt;
</comment>
                    <comment id="13156625" author="mreutegg" created="Thu, 24 Nov 2011 10:09:35 +0000"  >Alex, your patch contains a lot of simplifications and reformating in test cases. Could you please create a separate patch for that? This would make it easier to review the proposed changes for exactly this issue.</comment>
                    <comment id="13156714" author="alex.parvulescu" created="Thu, 24 Nov 2011 13:52:26 +0000"  >yes, sorry for the noise. &lt;br/&gt;
you are totally right!&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve re-submitted the patch (with only the relevant changes).&lt;br/&gt;
</comment>
                    <comment id="13156724" author="mduerig" created="Thu, 24 Nov 2011 14:26:31 +0000"  >From looking at the code this makes sense and seems ok. However I get a test failure when I run this for UserManagerSearchTest#testSoertOrder1. AFAICS this is due to a bad interaction with the new array comperator and the uppercase respectively lowercase comperators. &lt;br/&gt;
However I also observe, that I get comperator arrays of different lengths for the same property of different nodes. In the test case mentioned I get for some nodes [null, null, null, null, WHITE] and for others [null, null, null, WHITE].</comment>
                    <comment id="13156745" author="mduerig" created="Thu, 24 Nov 2011 15:00:13 +0000"  >Ok there seems to be a problem with termPosition. In the above test case termPosition is sometimes 3 and sometimes 4 for the same value of the property (i.e. &amp;quot;WHITE&amp;quot;). This results in the arrays with trailing null values. So this has nothing to do with the upper/lower case comperators. It just seems to manifest itself there but the problem is more profound. &lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13156759" author="alex.parvulescu" created="Thu, 24 Nov 2011 15:30:06 +0000"  >ouch, good catch!&lt;br/&gt;
&lt;br/&gt;
the position is from the current doc, but it takes into account other properties as well. I missed that completely.&lt;br/&gt;
So if a node has a property &amp;quot;p1&amp;quot; and a property &amp;quot;text&amp;quot;, the &amp;quot;text&amp;quot;&amp;#39;s position can be 1 (0-based) as well. I was under the (poor) impression that running a term search on &amp;quot;text&amp;quot; would convey just term specific info (not document specific positioning info).&lt;br/&gt;
&lt;br/&gt;
The fix would be to just add a &amp;#39;shrink&amp;#39; method after building the array to remove the null values from the beginning of the array.&lt;br/&gt;
When dealing with MVP I&amp;#39;m pretty sure they are a contiguous interval within the index, even if with a tiny offset.&lt;br/&gt;
</comment>
                    <comment id="13156769" author="alex.parvulescu" created="Thu, 24 Nov 2011 15:44:21 +0000"  >attaching just the SharedFieldCache class with the &amp;quot;shrink&amp;quot; method&lt;br/&gt;
&lt;br/&gt;
the UserManagerSearchTest test now passes.</comment>
                    <comment id="13156785" author="mduerig" created="Thu, 24 Nov 2011 16:13:33 +0000"  >Ok works now: all core tests pass. &lt;br/&gt;
&lt;br/&gt;
Do we know about the impact on query performance? All this array creation and compacting. It seems to me this might happen quite a lot for nodes with a lot of indexed properties. </comment>
                    <comment id="13158310" author="mreutegg" created="Mon, 28 Nov 2011 09:17:53 +0000"  >I&amp;#39;d also suggest to be careful about potential impact on performance. IMO we shoulnd&amp;#39;t sacrifice performance for a use case, which isn&amp;#39;t properly described in the specification.</comment>
                    <comment id="13158982" author="alex.parvulescu" created="Tue, 29 Nov 2011 00:32:26 +0000"  >Attaching v3 of the patch.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve taken into consideration the point about performance (creating and compacting the arrays) and I&amp;#39;ve come up with a better offset-based version:&lt;br/&gt;
&lt;br/&gt;
It is optimized for the standard case when there is only one term to create a single-element array &amp;amp; save the term&amp;#39;s position in the index, as opposed to creating an array of considerable size. So no more shrink method.&lt;br/&gt;
&lt;br/&gt;
Next, based on the following terms&amp;#39; index, it uses an internal offset to optimize the creation of the array of terms.&lt;br/&gt;
&lt;br/&gt;
This should have a considerably smaller impact on perf.&lt;br/&gt;
&lt;br/&gt;
Thanks for the feedback so far.&lt;br/&gt;
</comment>
                    <comment id="13159284" author="mduerig" created="Tue, 29 Nov 2011 14:34:01 +0000"  >I think there is an off by one problem in the cases denoted by // inside and // after: Shouldn&amp;#39;t the comparisons be &amp;lt; and &amp;gt;=, respectively?</comment>
                    <comment id="13160094" author="alex.parvulescu" created="Wed, 30 Nov 2011 15:36:49 +0000"  >you are right. the sneaky offset tricked me.&lt;br/&gt;
&lt;br/&gt;
turns out that wasn&amp;#39;t the only problem...I&amp;#39;ve also added a new test checking the array insert stuff.&lt;br/&gt;
&lt;br/&gt;
attaching v4&lt;br/&gt;
&lt;br/&gt;
concerning the memory consumption, so you think this is a viable low-impact solution for MVP sort?</comment>
                    <comment id="13160162" author="mduerig" created="Wed, 30 Nov 2011 17:24:12 +0000"  >Looks better but ;-)... in the // after case I think the calculation of the new array size is incorrect. The tests work but that&amp;#39;s just bad luck.&lt;br/&gt;
&lt;br/&gt;
Instead of &lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int extraOffset = index - offset + c.length -1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c = Arrays.copyOf(c, c.length + extraOffset);&lt;br/&gt;
&lt;br/&gt;
shouldn&amp;#39;t that be&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int newSize = index - offset + 1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c = Arrays.copyOf(c, newSize);&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13160303" author="alex.parvulescu" created="Wed, 30 Nov 2011 20:27:47 +0000"  >yes, as usual you are right!&lt;br/&gt;
your solution is a lot clearer, and above all correct :)&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The tests work but that&amp;#39;s just bad luck. &lt;br/&gt;
Yeah, the MVP2 test was supposed to shed some light on how the sort works, but it&amp;#39;s not a proper unit test for the ComparableArray. &lt;br/&gt;
(note to self: being lazy does not pay off)&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m attaching v5 with a dedicated unit test for the ComparableArray.</comment>
                    <comment id="13160799" author="mduerig" created="Thu, 1 Dec 2011 10:35:58 +0000"  >Looks good now and all tests pass.</comment>
                    <comment id="13160801" author="alex.parvulescu" created="Thu, 1 Dec 2011 10:41:53 +0000"  >fantastic! I&amp;#39;ll apply the patch shortly.</comment>
                    <comment id="13160892" author="alex.parvulescu" created="Thu, 1 Dec 2011 13:09:57 +0000"  >Fixed in rev 1209063 and rev 1209111</comment>
                    <comment id="13160895" author="alex.parvulescu" created="Thu, 1 Dec 2011 13:12:23 +0000"  >This depends on refactoring done for &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3151&quot; title=&quot;SharedFieldCache can cause a memory leak&quot;&gt;&lt;strike&gt;JCR-3151&lt;/strike&gt;&lt;/a&gt;</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10030">
                <name>Reference</name>
                                <outwardlinks description="relates to">
                            <issuelink>
            <issuekey id="12612950">JCR-3450</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                <outwardlinks description="depends upon">
                            <issuelink>
            <issuekey id="12532333">JCR-3151</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12504998" name="JCR-2906.patch" size="25846" author="alex.parvulescu" created="Thu, 24 Nov 2011 09:49:41 +0000" />
                    <attachment id="12505014" name="JCR-2906-SharedFieldCache.patch" size="6735" author="alex.parvulescu" created="Thu, 24 Nov 2011 15:44:21 +0000" />
                    <attachment id="12505010" name="JCR-2906-v2.patch" size="9816" author="alex.parvulescu" created="Thu, 24 Nov 2011 13:52:26 +0000" />
                    <attachment id="12505423" name="JCR-2906-v3.patch" size="10867" author="alex.parvulescu" created="Tue, 29 Nov 2011 00:32:26 +0000" />
                    <attachment id="12505627" name="JCR-2906-v4.patch" size="11964" author="alex.parvulescu" created="Wed, 30 Nov 2011 15:36:49 +0000" />
                    <attachment id="12505657" name="JCR-2906-v5.patch" size="13345" author="alex.parvulescu" created="Wed, 30 Nov 2011 20:27:46 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 1 Mar 2011 17:58:00 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>36290</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>61289</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>