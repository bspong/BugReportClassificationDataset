<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:30:26 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2238/JCR-2238.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2238] Binary throws NullPointerException </title>
                <link>https://issues.apache.org/jira/browse/JCR-2238</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Precondition: repository with datastore disabled!&lt;br/&gt;
&lt;br/&gt;
Steps to reproduce:&lt;br/&gt;
&lt;br/&gt;
1) create binary from stream&lt;br/&gt;
2) set binary on property&lt;br/&gt;
3) dispose binary&lt;br/&gt;
4) get binary from property and dispose it immediately&lt;br/&gt;
5) go to 4)&lt;br/&gt;
&lt;br/&gt;
Binary.dispose() will throw a NullPointerException when 4) is executed the second time.&lt;br/&gt;
&lt;br/&gt;
The exception is not thrown if the property is saved after 2).&lt;br/&gt;
&lt;br/&gt;
See also attached test.</description>
                <environment></environment>
            <key id="12432039">JCR-2238</key>
            <summary>Binary throws NullPointerException </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Aug 2009 12:45:28 +0100</created>
                <updated>Tue, 18 Aug 2009 16:02:17 +0100</updated>
                    <resolved>Mon, 10 Aug 2009 08:35:41 +0100</resolved>
                                            <fixVersion>2.0-alpha8</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12738924" author="mreutegg" created="Tue, 4 Aug 2009 11:23:00 +0100"  >As can be seen in the test output, the property always returns the same Binary instance. For most implementations this is not an issue because they are immutable and Binary.dispose() is a noop. Without the data store, the binary instance is a BLOBInTempFile, which has state and will delete the underlying temp file on dispose().&lt;br/&gt;
&lt;br/&gt;
It seems to me that ownership of a binary instance is not well defined (that includes the spec, as well as in our jackrabbit modules). I think we should clarify the following questions and adjust the implementation accordingly:&lt;br/&gt;
&lt;br/&gt;
1) Does Value return a new instance of Binary on Value.getBinary()?&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;d say yes, because Binary.dispose() may change the state of the object. though an implementation may chose to return a binary that has no state and dispose() is a noop. see our various Binary implementations in jackrabbit-core.&lt;br/&gt;
&lt;br/&gt;
implementation consequences: we need to change our Binary implementations that are not immutable, otherwise a call to getBinary() will become potentially expensive because a new instance needs to be created (i.e. a new temp file spooled). some sort of reference counting might be a solution. we need to make sure dispose() is called whenever getBinary() is used internally in jackrabbit. it seems this is not always the case yet.&lt;br/&gt;
&lt;br/&gt;
- Does Value become the owner of the given Binary on ValueFactory.createValue() ?&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;d say no, because Value does not have a defined life cycle. there is no dispose (or similar) method on Value, hence a client does not know when the given Binary is disposed. furthermore a client may wish to still use the given binary after the call to createBinary().&lt;br/&gt;
&lt;br/&gt;
so, this is how we use Binaries already in our code:&lt;br/&gt;
&lt;br/&gt;
Node n = ...&lt;br/&gt;
Binary bin = ...&lt;br/&gt;
try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Value v = vf.createValue(bin);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.setProperty(&amp;quot;foo&amp;quot;, v);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.setProperty(&amp;quot;bar&amp;quot;, v);&lt;br/&gt;
} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bin.dispose();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
but it seems Value must come the owner of a Binary, even if it is not the instance passed in createValue(), because otherwise the following code will not work:&lt;br/&gt;
&lt;br/&gt;
Node n = ...&lt;br/&gt;
Binary bin = ...&lt;br/&gt;
Value v;&lt;br/&gt;
try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;v = vf.createValue(bin);&lt;br/&gt;
} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bin.dispose();&lt;br/&gt;
}&lt;br/&gt;
n.setProperty(&amp;quot;foo&amp;quot;, v);&lt;br/&gt;
n.setProperty(&amp;quot;bar&amp;quot;, v);&lt;br/&gt;
&lt;br/&gt;
question: is this valid?&lt;br/&gt;
&lt;br/&gt;
I think, yes. the implementation in jackrabbit core already creates a new Binary instance in this situation. (but the implementation in jcr-commons doesn&amp;#39;t :-/)&lt;br/&gt;
Unfortunately this has the consequence that we need to add a finalize method to either the temporary (?) resource backed Binary implementations or the Value implementation. whenever possible we should avoid creating a Value instance for a binary (at least internally in jackrabbit).&lt;br/&gt;
&lt;br/&gt;
does anyone have an alternative solution?</comment>
                    <comment id="12738927" author="tripod" created="Tue, 4 Aug 2009 12:11:44 +0100"  >i think the creator is responsible to dispose the binary, no matter if the binary was&lt;br/&gt;
&lt;br/&gt;
- created using ValueFactory.createBinary(InputStream)&lt;br/&gt;
- retrieved from a property, eg: Property.getValue().getBinary();&lt;br/&gt;
- created in a own object implementing javax.jcr.Binary&lt;br/&gt;
&lt;br/&gt;
the most common code is probably:&lt;br/&gt;
&lt;br/&gt;
Binary bin = vf.createBinary(in); &lt;br/&gt;
try { &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.setProperty(&amp;quot;foo&amp;quot;, bin); &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.setProperty(&amp;quot;bar&amp;quot;, bin); &lt;br/&gt;
} finally { &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bin.dispose(); &lt;br/&gt;
} &lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12738932" author="tmueller" created="Tue, 4 Aug 2009 12:49:14 +0100"  >&amp;gt; 1) Does Value return a new instance of Binary on Value.getBinary()?&lt;br/&gt;
&amp;gt; we need to change our Binary implementations that are not immutable, otherwise a call to getBinary() will become potentially expensive&lt;br/&gt;
&lt;br/&gt;
I think whether Value.getBinary() returns a new object should be implementation defined (not part of the spec). For Jackrabbit, we could do that always if that&amp;#39;s easier (even if using the data store). I know creating new objects is slow if the class has a finalize method, but I think it&amp;#39;s not such an important performance problem because most applications will not call Value.getBinary() multiple times I guess. Even creating a new temporary file each time it is called is probably OK - or is there an important use case where getBinary() needs to be called multiple times for the same value?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Value v;&lt;br/&gt;
&amp;gt; try {&lt;br/&gt;
&amp;gt;    v = vf.createValue(bin);&lt;br/&gt;
&amp;gt; } finally {&lt;br/&gt;
&amp;gt;     bin.dispose();&lt;br/&gt;
&amp;gt; }&lt;br/&gt;
&amp;gt; n.setProperty(&amp;quot;foo&amp;quot;, v); &lt;br/&gt;
&lt;br/&gt;
I think that should be valid.&lt;br/&gt;
&lt;br/&gt;
With the data store:&lt;br/&gt;
a) getBinary() could always return the same Binary object&lt;br/&gt;
b) dispose() would be a noop&lt;br/&gt;
&lt;br/&gt;
Without the data store (when using a temp file)&lt;br/&gt;
c) getBinary() could always create a new temp file (or use a shared file, if we find an important use case)&lt;br/&gt;
c) I think dispose() should close the stream and make the Binary object unusable (delete the temp file, maybe using a reference count)&lt;br/&gt;
d) finalize() should call dispose() for such Binary objects if needed&lt;br/&gt;
e) Maybe closing the session should call Binary.dispose() (session would need a weak reference to all Binary objects)&lt;br/&gt;
</comment>
                    <comment id="12739449" author="mreutegg" created="Wed, 5 Aug 2009 13:24:12 +0100"  >Proposed patch.</comment>
                    <comment id="12739471" author="tmueller" created="Wed, 5 Aug 2009 13:58:11 +0100"  >I&amp;#39;m not sure if RefCountingBLOBFileValue is really important... if yes refCount access should be synchronized &lt;br/&gt;
(or use java.util.concurrent.atomic.AtomicInteger).&lt;br/&gt;
&lt;br/&gt;
That&amp;#39;s all I found. I hope we can some day simplify blob handling, the code is really complicated...&lt;br/&gt;
</comment>
                    <comment id="12739962" author="mreutegg" created="Thu, 6 Aug 2009 10:35:56 +0100"  >Good point. I&amp;#39;ve updated the patch accordingly. Though, I think the RefCountingBLOBFileValue is currently only used by a single thread while a session writes to the repository.</comment>
                    <comment id="12740062" author="mreutegg" created="Thu, 6 Aug 2009 14:39:18 +0100"  >Updated patch.&lt;br/&gt;
&lt;br/&gt;
Removed BLOBFileValue.discard() and replaced calls to that method with dispose().</comment>
                    <comment id="12741216" author="mreutegg" created="Mon, 10 Aug 2009 08:35:41 +0100"  >Applied patch (with minor modifications: commented System.out.println() in test class) in revision: 802676</comment>
                    <comment id="12741227" author="mreutegg" created="Mon, 10 Aug 2009 09:25:23 +0100"  >Thomas reported a flaw in the use of AtomicInteger.&lt;br/&gt;
&lt;br/&gt;
Replaced usage of AtomicInteger with plain old synchronized methods.&lt;br/&gt;
&lt;br/&gt;
svn revision: 802690</comment>
                </comments>
                    <attachments>
                    <attachment id="12415353" name="BinaryValueTest.patch" size="3273" author="mreutegg" created="Mon, 3 Aug 2009 12:58:04 +0100" />
                    <attachment id="12415746" name="JCR-2238.patch" size="29253" author="mreutegg" created="Thu, 6 Aug 2009 14:39:18 +0100" />
                    <attachment id="12415716" name="JCR-2238.patch" size="25906" author="mreutegg" created="Thu, 6 Aug 2009 10:35:56 +0100" />
                    <attachment id="12415594" name="JCR-2238.patch" size="25776" author="mreutegg" created="Wed, 5 Aug 2009 13:24:11 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 4 Aug 2009 11:11:44 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78294</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>192273</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>