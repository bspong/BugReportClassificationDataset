<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:50:08 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-974/JCR-974.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-974] Manage Lucene FieldCaches per index segment</title>
                <link>https://issues.apache.org/jira/browse/JCR-974</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Jackrabbit uses an IndexSearcher which searches on a single IndexReader which is most likely to be an instance of CachingMultiReader. On every search that does sorting or range queries a FieldCache is populated and associated with this instance of a CachingMultiReader. On successive queries which operate on this CachingMultiReader you will get a tremendous speedup for queries which can reuse  those associated FieldCache instances.&lt;br/&gt;
The problem is that Jackrabbit creates a new CachingMultiReader _everytime_ one of the underlying indexes are modified. This means if you just change _one_ item in the repository you will need to rebuild all those FieldCaches because the existing FieldCaches are associated with the old instance of CachingMultiReader.&lt;br/&gt;
This does not only lead to slow search response times for queries which contains range queries or are sorted by a field but also leads to massive memory consumption (depending on the size of your indexes) because there might be multiple instances of CachingMultiReaders in use if you have a scenario where a lot of queries and item modifications are executed concurrently.&lt;br/&gt;
The goal is to keep those FieldCaches as long as possible.</description>
                <environment></environment>
            <key id="12371971">JCR-974</key>
            <summary>Manage Lucene FieldCaches per index segment</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="ckiehl">Christoph Kiehl</reporter>
                        <labels>
                    </labels>
                <created>Tue, 19 Jun 2007 17:01:07 +0100</created>
                <updated>Tue, 15 Jan 2008 23:26:44 +0000</updated>
                    <resolved>Mon, 25 Jun 2007 10:27:02 +0100</resolved>
                                            <fixVersion>1.4</fixVersion>
                                <component>jackrabbit-core</component>
                <component>query</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12506232" author="ckiehl" created="Tue, 19 Jun 2007 17:11:45 +0100"  >This is a first patch which uses a FieldCache per index segment. To make this work we had to use our own implementation of FieldCache.StringIndex which does not keep an array of sort indexes for the document, but which keeps an array terms associated which each document. This of course uses more memory and there need to be some performance/scaling tests done.&lt;br/&gt;
We had to modify SearchIndex.CombinedIndexReader and CachingMultiReader to allow access to the underlying IndexReaders because those IndexReaders are used as cache keys in SharedFieldCache.&lt;br/&gt;
I&amp;#39;m not absolutely satisfied about this solution, because SharedFieldSortComparator has to know that there is a CombinedIndexReader and currently even assumes it.&lt;br/&gt;
Performance wise we achieved a speed up by factor 5-15 for queries sorting by some field in our current application. In our scenario we have got a lot of write operations and more than 1000000 nodes . For read-only repositories this patch slightly degrades performance by a factor of about 2.</comment>
                    <comment id="12506497" author="mreutegg" created="Wed, 20 Jun 2007 12:47:02 +0100"  >Do you have test cases or a description of the queries that you execute?</comment>
                    <comment id="12506498" author="mreutegg" created="Wed, 20 Jun 2007 12:51:05 +0100"  >Here&amp;#39;s my attempt to keep FieldCaches per index reader.&lt;br/&gt;
&lt;br/&gt;
Not well documented, but it&amp;#39;s rather a prototype anyway.&lt;br/&gt;
&lt;br/&gt;
WDYT?</comment>
                    <comment id="12506499" author="mreutegg" created="Wed, 20 Jun 2007 12:52:16 +0100"  >btw, both SearchIndex.CombinedIndexReader and CachingMultiReader implement MultiIndexReader which exposes getIndexReaders().</comment>
                    <comment id="12506501" author="ckiehl" created="Wed, 20 Jun 2007 12:54:41 +0100"  >The query I&amp;#39;m doing my tests with looks like this:&lt;br/&gt;
&lt;br/&gt;
//element(*, app-mix:document) order by @app:modificationDate&lt;br/&gt;
&lt;br/&gt;
Unfortunately I&amp;#39;ve got no testcase yet. I&amp;#39;ll try to create one.</comment>
                    <comment id="12506506" author="ckiehl" created="Wed, 20 Jun 2007 13:11:56 +0100"  >Regarding your ItemStateManagerBasedSortComparator.patch: This patch doesn&amp;#39;t work well in our scenario because we&amp;#39;ve got fairly large resultsets. I think your patch might handle small result sets better than my patch, but for large result sets there are too many documents from different index segments. Using your patch my query takes about 100000ms while using our patch it needs between 200ms and 1000ms.&lt;br/&gt;
&lt;br/&gt;
One of the other features of my patch is that it creates the caches lazily per index segment. We also played around with a global term cache so if the same term is returned by different index segments the same String object is used for the FieldCache. This minimizes the FieldCache size if one term is contained in multiple index segments. In our case the default FieldCache was about 4MB for a certain field while the patched FieldCache was about 2.5MB.</comment>
                    <comment id="12506597" author="ckiehl" created="Wed, 20 Jun 2007 17:45:45 +0100"  >This is a revised version of the first patch. The following changes were applied:&lt;br/&gt;
&lt;br/&gt;
- Using MultiIndexReader interface instead of providing own methods on CombinedIndexReader and CachingMultiReader. This is not only better design but also improves performance a bit.&lt;br/&gt;
- Create caches proactive instead of lazily and use an array to access them. This improves performance a little bit for successive queries.</comment>
                    <comment id="12506599" author="ckiehl" created="Wed, 20 Jun 2007 17:54:04 +0100"  >I tried building a test case, but you need a fairly large index to really see the benefitsof my patch. In our production environment the workspace index is 500MB in size and the jcr:system index is about 1200MB (and both of course still growing). With indexes as big as that the effect of the operation systems file system cache is not as big as in small test cases. In my small test case the performance with my patch was a bit worse for repeating queries on an unchanged repository.&lt;br/&gt;
I think we should provide a little tool that takes the wikipedia content an puts it all into a test repository which could then be used for such test cases. What do you think?</comment>
                    <comment id="12507153" author="mreutegg" created="Fri, 22 Jun 2007 08:45:01 +0100"  >Thanks a lot for the revised patch. I was just going to write some comments about your previous version and now most of my concerns are already addressed ;)&lt;br/&gt;
&lt;br/&gt;
One of the concerns I had was regarding lazy loading, because it would have required synchronization on the map (which was missing in the previous patch).&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m using a fairly simple test case to measure performance. It involves creating 200&amp;#39;000 nodes with a LONG property set to distinct values and then executing the following query:&lt;br/&gt;
&lt;br/&gt;
stuff//*[@foo] order by @foo&lt;br/&gt;
&lt;br/&gt;
On average the execution time with the current codebase is 2200ms, with your initial patch: 265ms and with the latest patch: 235ms.&lt;br/&gt;
&lt;br/&gt;
Can you please make sure you consistently use space characters instead of tabs in the source code? Thanks.&lt;br/&gt;
&lt;br/&gt;
Now, there&amp;#39;s just one thing left. You introduced a cache for the ReadOnlyIndexReaders in AbstractIndex. I&amp;#39;d rather not want to have a cache there because it means that we have to maintain it. In your patch the map is cleaned when the index is invalidated. For older index segments (the bigger ones, which resulted from index merges) this means that the map is only cleaned when the index segment is closed (when it is part of a merge or on shutdown). IMO this is somewhat of a memory leak and should be changed.&lt;br/&gt;
&lt;br/&gt;
I would rather have these three lines at the beginning of the method SharedFieldCache.getStringIndex():&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (reader instanceof ReadOnlyIndexReader) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reader = ((ReadOnlyIndexReader) reader).getBase();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
It doesn&amp;#39;t win a price for beauty but has the same effect as the cache.&lt;br/&gt;
&lt;br/&gt;
WDYT?</comment>
                    <comment id="12507386" author="ckiehl" created="Fri, 22 Jun 2007 15:37:12 +0100"  >Patch3 incorporates changes as suggested. ReadOnlyIndexReaders are no longer cached in AbstractIndex. &lt;br/&gt;
&lt;br/&gt;
Thanks for taking the time to review the patches.</comment>
                    <comment id="12507830" author="mreutegg" created="Mon, 25 Jun 2007 10:27:02 +0100"  >Committed the latest patch in revision: 550429&lt;br/&gt;
&lt;br/&gt;
Christoph, thanks a lot for your work.</comment>
                </comments>
                    <attachments>
                    <attachment id="12360191" name="ItemStateManagerBasedSortComparator.patch" size="16072" author="mreutegg" created="Wed, 20 Jun 2007 12:51:05 +0100" />
                    <attachment id="12360216" name="patch2.txt" size="12840" author="ckiehl" created="Wed, 20 Jun 2007 17:45:45 +0100" />
                    <attachment id="12360366" name="patch3.txt" size="11544" author="ckiehl" created="Fri, 22 Jun 2007 15:37:11 +0100" />
                    <attachment id="12360124" name="patch.txt" size="13300" author="ckiehl" created="Tue, 19 Jun 2007 17:11:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>4.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 20 Jun 2007 11:47:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142458</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190052</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>