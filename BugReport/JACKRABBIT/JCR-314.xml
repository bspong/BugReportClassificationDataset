<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:44:11 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-314/JCR-314.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-314] Fine grained locking in SharedItemStateManager</title>
                <link>https://issues.apache.org/jira/browse/JCR-314</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The SharedItemStateManager (SISM) currently uses a simple read-write lock to ensure data consistency. Store operations to the PersistenceManager (PM) are effectively serialized.&lt;br/&gt;
&lt;br/&gt;
We should think about more sophisticated locking to allow concurrent writes on the PM.&lt;br/&gt;
&lt;br/&gt;
One possible approach:&lt;br/&gt;
&lt;br/&gt;
If a transaction is currently storing data in a PM a second transaction may check if the set of changes does not intersect with the first transaction. If that is the case it can safely store its data in the PM.&lt;br/&gt;
&lt;br/&gt;
This fine grained locking must also be respected when reading from the SISM. A read request for an item that is currently being stored must be blocked until the store is finished.</description>
                <environment></environment>
            <key id="12328518">JCR-314</key>
            <summary>Fine grained locking in SharedItemStateManager</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Fri, 3 Feb 2006 19:59:17 +0000</created>
                <updated>Thu, 2 May 2013 03:29:06 +0100</updated>
                    <resolved>Tue, 18 Dec 2007 10:42:53 +0000</resolved>
                            <version>0.9</version>
                <version>1.0</version>
                <version>1.0.1</version>
                <version>1.1</version>
                <version>1.1.1</version>
                <version>1.2.1</version>
                <version>1.2.2</version>
                <version>1.2.3</version>
                                <fixVersion>1.4</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>4</votes>
                        <watches>5</watches>
                                                    <comments>
                    <comment id="12479899" author="michaelneale" created="Sun, 11 Mar 2007 05:51:29 +0000"  >anyone for escalating this above a &amp;quot;minor&amp;quot; - its kind of a showstopper for some people ?</comment>
                    <comment id="12479919" author="stefan@jira" created="Sun, 11 Mar 2007 10:17:51 +0000"  >i agree with michael neale&amp;#39;s judgement &lt;br/&gt;
(&lt;a href=&quot;http://www.mail-archive.com/users@jackrabbit.apache.org/msg02503.html),&quot;&gt;http://www.mail-archive.com/users@jackrabbit.apache.org/msg02503.html),&lt;/a&gt;&lt;br/&gt;
changing priority to major.</comment>
                    <comment id="12488896" author="ozeigermann" created="Sat, 14 Apr 2007 23:02:28 +0100"  >Any idea how this could be achieved?&lt;br/&gt;
&lt;br/&gt;
If you use blocking locks, it is very hard to avoid deadlocks. Of course you can use an ordered sequence of locks for all requests to avoid deadlocks, but that would mean you need a list of all resources to be locked before you even start doing anything. &lt;br/&gt;
&lt;br/&gt;
After my experience with the Slide server I can only recommend non blocking locks. Such locks would make a request fail if it is not able to acquire all locks necessay instead of letting it wait. This would require a notion of a transaction, however.</comment>
                    <comment id="12493361" author="mreutegg" created="Thu, 3 May 2007 13:59:28 +0100"  >To drive this issue forward I created a patch that replaces the current rather hard coded use of a ReadWriteLock in SharedItemStateManager with an abstraction layer that allows alternative implementations.&lt;br/&gt;
&lt;br/&gt;
The way locking currently works is implemented in DefaultISMLocking and an initial implementation of a more fine grained locking is available in FineGrainedISMLocking.&lt;br/&gt;
&lt;br/&gt;
FineGrainedISMLocking does not allow concurrent writes but at least allows reads while a long running write takes place and the read does not conflict with the write. I think this is the most common use case (save a big file but still allow other sessions to read, which is currently not possible).&lt;br/&gt;
&lt;br/&gt;
All tests pass with both the DefaultISMLocking and the FineGrainedISMLocking.&lt;br/&gt;
&lt;br/&gt;
The first patch only includes the structural changes moving away from the hard coded ReadWriteLock in the SharedItemStateManager to the ISMLocking interface. It does not change the locking semantics that are currently in place. The second patch is the proposal for a more fine grained locking strategy.&lt;br/&gt;
&lt;br/&gt;
Comments are welcome.</comment>
                    <comment id="12493368" author="ozeigermann" created="Thu, 3 May 2007 14:50:35 +0100"  >As far as I can tell the FineGrainedISMLocking  implementation is prone to deadlocks. At least when a DB is used as storage. Such a deadlock can occur distributed between DB and the Jackrabbit locking. The DB can not resolve the deadlock, as internally it looks like there is none. A transaction timeout in the DB is the only way to resolve such a situation. &lt;br/&gt;
&lt;br/&gt;
In any case there should be a timeout for Jackrabbit locks. For one to to free locks that have never been freed, because some thread forgot to free them. Additionally, to make sure deadlocks between Jackrabbit and DB can be resolved quickly.&lt;br/&gt;
</comment>
                    <comment id="12493608" author="mreutegg" created="Fri, 4 May 2007 09:01:51 +0100"  >Oliver, thank you for your comment. However I do not see how a deadlock may occur between jackrabbit and the DB used in a persistence manager. Deadlocks always require that locks are acquired in a circular way. That&amp;#39;s never the case between Jackrabbit and the DB. A call that returns from the DB will always have released all DB locks. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;d appreciate if you were a bit more specific, e.g. provide a wait-for graph that shows a deadlock situation.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; In any case there should be a timeout for Jackrabbit locks. For one to to free locks that have&lt;br/&gt;
&amp;gt; never been freed, because some thread forgot to free them.&lt;br/&gt;
&lt;br/&gt;
I disagree. This would clearly be a bug in Jackrabbit and should rather be fixed than worked around with timeouts.</comment>
                    <comment id="12495700" author="jukkaz" created="Mon, 14 May 2007 19:01:04 +0100"  >I briefly reviewed the patches, good work! I like how you&amp;#39;ve applied the strategy pattern.&lt;br/&gt;
&lt;br/&gt;
My main concern is that this still doesn&amp;#39;t address the concurrency limitations in the current persistence managers. Should that be handled as a separate issue? A more general issue is that this whole ISM core keeps getting more complex, and adding 1+2 new interfaces and all the implementing classes doesn&amp;#39;t really help things. I&amp;#39;m not sure what to do about that...&lt;br/&gt;
&lt;br/&gt;
Also, it would be nice if we had at least a few parallel test cases for excercising such code.</comment>
                    <comment id="12495886" author="mreutegg" created="Tue, 15 May 2007 08:57:40 +0100"  >Jukka, thanks for your comments.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; My main concern is that this still doesn&amp;#39;t address the concurrency limitations in the current&lt;br/&gt;
&amp;gt; persistence managers.&lt;br/&gt;
&lt;br/&gt;
You are right, the proposed changes will not solve the concurrency limitations completely, but at least they should improve the current situation where no reads are possible through the SISM when a write is taking place. I think truely fine grained locking will not be possible with the current design and thus would require major re-structuring in the jackrabbit core. Something I&amp;#39;d rather like to postpone for a 2.0.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; [...] limitations in the current persistence managers. Should that be handled as a separate issue?&lt;br/&gt;
&lt;br/&gt;
There are a number of other issues that are related. Even if persistence managers are able to perform concurrent writes, the index will have to support that too otherwise concurrent writes in the PM will be of limited use. And then there&amp;#39;s the question how to process (synchronous) events for concurrent writes?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; A more general issue is that this whole ISM core keeps getting more complex, and adding 1+2&lt;br/&gt;
&amp;gt; new interfaces and all the implementing classes doesn&amp;#39;t really help things.&lt;br/&gt;
&lt;br/&gt;
I actually didn&amp;#39;t want to make it more complex but rather easier to understand. I think the interfaces are of some value because they describe the locking contract independant of the implementation. They also allow to easily try out a different locking implementation / strategy.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I&amp;#39;m not sure what to do about that...&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also not 100% happy with the proposed changes, but at least it solves the most annoying problem with the SISM, that it locks up completely during a large write.&lt;br/&gt;
&lt;br/&gt;
I see the following options:&lt;br/&gt;
- We don&amp;#39;t change anything right now and do it better the next time (NGP, jackrabbit 2.0, ...)&lt;br/&gt;
- Redesign the core now to better handle concurrency&lt;br/&gt;
- Accept the patch ISMLocking.patch and discuss a locking implementation/strategy that&amp;#39;s better suited than the current one.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m obviously in favour of the last option ;) because it gives us the most bang for the buck and is by far less risky than option two.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Also, it would be nice if we had at least a few parallel test cases for excercising such code.&lt;br/&gt;
&lt;br/&gt;
I agree. I already created some test cases that perform concurrent versioning operations and basic content modifications. So if anyone is interested, feel free to write more of them. The class AbstractConcurrencyTest and its sub classes are a good starting point.</comment>
                    <comment id="12495892" author="jukkaz" created="Tue, 15 May 2007 09:29:36 +0100"  >&amp;gt; I&amp;#39;m obviously in favour of the last option ;) because it gives us the most bang for the buck and is by far less risky than option two.&lt;br/&gt;
&lt;br/&gt;
Agreed.&lt;br/&gt;
&lt;br/&gt;
Note that without solving the concurrency issues in persistence managers (both db and bundle) we&amp;#39;re still stuck with fully serialized backend access. But this is one step in the correct direction; the second step would be to start removing the synchronization on the persistence managers.&lt;br/&gt;
</comment>
                    <comment id="12496317" author="stefan@jira" created="Wed, 16 May 2007 15:41:25 +0100"  >&amp;gt; - Accept the patch ISMLocking.patch and discuss a locking implementation/strategy that&amp;#39;s better suited than the current one.&lt;br/&gt;
&lt;br/&gt;
+1&lt;br/&gt;
&lt;br/&gt;
btw, i did a couple of test runs using ConcurrentReadWriteTest against&lt;br/&gt;
&amp;nbsp;a) current trunk&lt;br/&gt;
&amp;nbsp;b) a) with ISMLocking.patch applied (using DefaultISMLocking)&lt;br/&gt;
&amp;nbsp;c) b) with FineGrainedISMLocking.patch applied (using FineGrainedISMLocking)&lt;br/&gt;
&lt;br/&gt;
environment: macbook pro (intel, 2ghz), os-x 10.4.9, jre 1.4.2&lt;br/&gt;
&lt;br/&gt;
results: &lt;br/&gt;
&lt;br/&gt;
a)&lt;br/&gt;
**&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~2&amp;#39;300 #writes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~2&amp;#39;300&amp;#39;000 #reads&lt;br/&gt;
&lt;br/&gt;
b)&lt;br/&gt;
**&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~2&amp;#39;300 #writes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~2&amp;#39;300&amp;#39;000 #reads&lt;br/&gt;
&lt;br/&gt;
c)&lt;br/&gt;
**&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~1&amp;#39;700 #writes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;~2&amp;#39;300&amp;#39;000 #reads&lt;br/&gt;
&lt;br/&gt;
=&amp;gt; c) shows a significant decrease in #writes while #reads doesn&amp;#39;t seem&lt;br/&gt;
to be affected. i guess that FineGrainedISMLocking still has room for &lt;br/&gt;
improvement ;)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12498186" author="mreutegg" created="Wed, 23 May 2007 12:02:00 +0100"  >Here&amp;#39;s a new version of FineGrainedISMLocking.&lt;br/&gt;
&lt;br/&gt;
The performance should be better compared to the last version.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m not sure the test case is very representative though. Lot of monitor contention happens between the write thread and readers when item states are notified and the cache maps need to be accessed. I think finer grained locking makes this situation even worse because it allows more concurrency on the caches.</comment>
                    <comment id="12498226" author="mreutegg" created="Wed, 23 May 2007 14:22:30 +0100"  >Applied the patches ISMLocking.patch and FineGrainedISMLocking-v2.patch with one slight change: the SISM used the default implementation for now.&lt;br/&gt;
&lt;br/&gt;
Committed in revision: 540944&lt;br/&gt;
&lt;br/&gt;
There are some remaining issues before we can use FineGrainedISMLocking:&lt;br/&gt;
&lt;br/&gt;
- using FineGrainedISMLocking allows for concurrent access to item state caches, which were not possible before. We must ensure that all item state caches are prepared for that.&lt;br/&gt;
- do extensive testing&lt;br/&gt;
- we should check again if the performance is ok</comment>
                    <comment id="12498227" author="mreutegg" created="Wed, 23 May 2007 14:25:09 +0100"  >The chart shows the writes per second of the writer thread using the&lt;br/&gt;
ConcurrentReadWriteTest for DefaultISMLocking and FineGrainedISMLocking.&lt;br/&gt;
The duration of the test is 120 seconds.</comment>
                    <comment id="12506679" author="jukkaz" created="Wed, 20 Jun 2007 22:18:10 +0100"  >It seems that saving a single large binary property still (revision 549230) completely blocks read access to other nodes. See my last comment on &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-926&quot; title=&quot;Global data store for binaries&quot;&gt;&lt;strike&gt;JCR-926&lt;/strike&gt;&lt;/a&gt; for more details.</comment>
                    <comment id="12506804" author="jukkaz" created="Thu, 21 Jun 2007 09:52:21 +0100"  >Forget my last comment, the svn trunk still has DefaultISMLocking as the default.</comment>
                    <comment id="12525131" author="prios" created="Wed, 5 Sep 2007 16:46:00 +0100"  >It seems that during the time a versioning operation is in progress (writer) it is not possible to establish a new session to the repository. This seems to be so because access to the root node of the version histories (/jcr:system/jcr:versionStorage) is required to create a session and this node is included on the active writer changelog. In other words the reader need to access an item (root node of the version storage) that has a dependency on the active writer changelog.&lt;br/&gt;
&lt;br/&gt;
From XAVersionManager constructor&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state = (NodeState) stateMgr.getItemState(vMgr.getHistoryRootId());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (ItemStateException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
(An XAVersionManager is instantiated during the instantiation of an XASessionImpl)&lt;br/&gt;
&lt;br/&gt;
Note: I&amp;#39;ve observed this in an XA environment.&lt;br/&gt;
&lt;br/&gt;
Am I wrong or right ?&lt;br/&gt;
&lt;br/&gt;
What may be the consequences of allowing a reader to get a read lock in this situation even if the writer&amp;#39;s changelog includes the VERSION_STORAGE_NODE_ID ?&lt;br/&gt;
</comment>
                    <comment id="12527415" author="mreutegg" created="Fri, 14 Sep 2007 09:57:49 +0100"  >&amp;gt; What may be the consequences of allowing a reader to get a read lock in this situation even if the writer&amp;#39;s changelog includes&lt;br/&gt;
&amp;gt; the VERSION_STORAGE_NODE_ID ?&lt;br/&gt;
&lt;br/&gt;
That&amp;#39;s probably a bad idea. It may happen that a reader sees inconsistent data.&lt;br/&gt;
&lt;br/&gt;
But anyway, I think a versioning operation will modify only the version storage root node in rare cases. Merely when the version storage is nearly empty. As soon as there are enough versions created the version storage root node has all possible child nodes (named 00, 01, ... ff) and is not modified anymore.</comment>
                    <comment id="12527421" author="tmueller" created="Fri, 14 Sep 2007 10:18:34 +0100"  >From &lt;a href=&quot;http://www.mail-archive.com/users@jackrabbit.apache.org/msg02503.html&quot;&gt;http://www.mail-archive.com/users@jackrabbit.apache.org/msg02503.html&lt;/a&gt;&lt;br/&gt;
&amp;gt; for people wanting to store large blobs (something that people would look at using JCR for) - this is a showstopper.&lt;br/&gt;
&lt;br/&gt;
If reading/writing large objects blocks others, it is showstopper.&lt;br/&gt;
But Data Store should solve this: &lt;a href=&quot;http://issues.apache.org/jira/browse/JCR-926&quot;&gt;http://issues.apache.org/jira/browse/JCR-926&lt;/a&gt;&lt;br/&gt;
Is it still a problem? &lt;br/&gt;
&lt;br/&gt;
Are there other concurrency problems?&lt;br/&gt;
</comment>
                    <comment id="12550455" author="efranqueiro" created="Tue, 11 Dec 2007 14:28:35 +0000"  >This patch adds a lockingStrategy attribute to the Workspace and Versioning element tags. It&amp;#39;s possible values are default, fine, and fine+ (this one was a POC we did here).</comment>
                    <comment id="12552375" author="mreutegg" created="Mon, 17 Dec 2007 11:21:51 +0000"  >Esteban, thank you for your patch. I&amp;#39;ve modified it slightly and used a separate configuration element with a class attribute. I didn&amp;#39;t include your changes to the FineGrainedISMLocking because I think they may lead to inconsistencies. As described easier in this issue, once the version storage in sufficiently populated, the login will not block anymore when a version operation is in progress.&lt;br/&gt;
&lt;br/&gt;
I have also added a new version of the DTD (1.4) and updated all repository.xml files I found in the sources. Once the changes are committed I will add the DTD to the website.&lt;br/&gt;
&lt;br/&gt;
Please note that this change is backward compatible. The ISMLocking element is optional and defaults to DefaultISMLocking (the currently hard coded implementation).</comment>
                    <comment id="12552698" author="mreutegg" created="Tue, 18 Dec 2007 10:42:53 +0000"  >Committed ConfigurableISMLocking.patch in revision: 605173&lt;br/&gt;
&lt;br/&gt;
Please note that there are still some open synchronization issues when using FineGrainedISMLocking!</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                                <inwardlinks description="is depended upon by">
                            <issuelink>
            <issuekey id="12369872">JCR-935</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12371788" name="ConfigurableISMLocking.patch" size="33815" author="mreutegg" created="Mon, 17 Dec 2007 11:21:50 +0000" />
                    <attachment id="12356710" name="FineGrainedISMLocking.patch" size="6782" author="mreutegg" created="Thu, 3 May 2007 13:59:28 +0100" />
                    <attachment id="12357974" name="FineGrainedISMLocking-v2.patch" size="13651" author="mreutegg" created="Wed, 23 May 2007 12:02:00 +0100" />
                    <attachment id="12371436" name="fine-grained-locking-1.4.patch" size="18201" author="efranqueiro" created="Tue, 11 Dec 2007 14:28:31 +0000" />
                    <attachment id="12356709" name="ISMLocking.patch" size="18841" author="mreutegg" created="Thu, 3 May 2007 13:59:27 +0100" />
                    <attachment id="12357989" name="writes-per-second.jpg" size="63451" author="mreutegg" created="Wed, 23 May 2007 14:25:05 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 11 Mar 2007 05:51:29 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142104</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>191088</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>