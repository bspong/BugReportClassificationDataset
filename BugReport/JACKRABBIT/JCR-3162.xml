<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:43:45 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-3162/JCR-3162.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-3162] Index update overhead on cluster slave due to JCR-905</title>
                <link>https://issues.apache.org/jira/browse/JCR-3162</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt; is a quick and dirty fix and causes overhead on a cluster slave node when it processes revisions.</description>
                <environment></environment>
            <key id="12533305">JCR-3162</key>
            <summary>Index update overhead on cluster slave due to JCR-905</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="alex.parvulescu">Alex Parvulescu</reporter>
                        <labels>
                    </labels>
                <created>Wed, 30 Nov 2011 15:48:33 +0000</created>
                <updated>Thu, 19 Jan 2012 13:47:13 +0000</updated>
                    <resolved>Thu, 15 Dec 2011 16:30:51 +0000</resolved>
                                            <fixVersion>2.3.6</fixVersion>
                                <component>clustering</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13160113" author="alex.parvulescu" created="Wed, 30 Nov 2011 16:07:44 +0000"  >Studying this problem revealed that this issue happens whenever we are dealing with a cluster sync operation involving an instance that has been running for a really long time.&lt;br/&gt;
&lt;br/&gt;
At this point I&amp;#39;m not sure what really long time means exactly, but it would appear that after a while the journal revision resets to 0.&lt;br/&gt;
This causes the cluster slave to sync using a lower revision number, thus fetching the journal records again, which would determine the repository to index them again.&lt;br/&gt;
If the current index corresponds to a bigger revision number, re-indexing again means that there will be duplicates in the index.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt; tried to address that by first deleting all the records that come from an external source (the cluster sync) before adding them.&lt;br/&gt;
&lt;br/&gt;
The proposed solution tries to determine on repository startup if the index is stale and tries to force a full reindex by deleting it.&lt;br/&gt;
Index staleness is currently determined by checking if journal revision is 0 and if there are already index files present in the repository.&lt;br/&gt;
&lt;br/&gt;
Interestingly this happens a lot during tests when the index is conserved from one restart to the other, but the journal impl is memory based so it gets reset every time.&lt;br/&gt;
&lt;br/&gt;
The solution has some issues because of the asynchronous initialization of SearchIndex for workspaces other than &amp;quot;default&amp;quot;. Meaning that by the time the SearchIndex gets initialized, the cluster node has already sync&amp;#39;ed to a bigger revision than 0, even if it was 0 at the moment when the repo was starting up.&lt;br/&gt;
But this doesn&amp;#39;t apply to the default workspace.&lt;br/&gt;
</comment>
                    <comment id="13160116" author="alex.parvulescu" created="Wed, 30 Nov 2011 16:10:13 +0000"  >attaching patch.&lt;br/&gt;
&lt;br/&gt;
Warning: this is a work in progress, not really tested. &lt;br/&gt;
It includes changes from &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3160&quot; title=&quot;Session#move doesn&amp;#39;t trigger rebuild of parent node aggregation&quot;&gt;&lt;strike&gt;JCR-3160&lt;/strike&gt;&lt;/a&gt; (as some files overlap).&lt;br/&gt;
&lt;br/&gt;
Feedback needed.</comment>
                    <comment id="13160996" author="alex.parvulescu" created="Thu, 1 Dec 2011 17:36:23 +0000"  >Attaching v2 of the patch.&lt;br/&gt;
&lt;br/&gt;
It is basically v1 + a test + some feature flags.&lt;br/&gt;
I managed to find a way to test this problem within JR Core, which should allow us to have some meaningful progress.&lt;br/&gt;
&lt;br/&gt;
The test DbClusterTestJCR3162 contains 2 feature flags (which will be removed once the patch is good):&lt;br/&gt;
&amp;nbsp;- JCR3162_ENABLE_CLUSTER_DELETE this is the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt; fix which can be switched on/off with the help of this flag&lt;br/&gt;
&amp;nbsp;- JCR3162_ENABLE_REINDEX this controls the new code (reindexing if the index is considered stale)&lt;br/&gt;
&lt;br/&gt;
So basically: &lt;br/&gt;
&amp;nbsp;- both flags off: you can see the initial behaviour (pre &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt;) in action. The test fails (as it should).&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- just JCR3162_ENABLE_CLUSTER_DELETE represents the current behaviour of the repository (the test passes)&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;- just JCR3162_ENABLE_REINDEX represents the patch in action (the test passes!)&lt;br/&gt;
&lt;br/&gt;
The original problem still stands: how do we know if an index is stale or not. Default workspace will be covered, the other workspaces are going to be initializes asynchronously, so there are no guarantees.&lt;br/&gt;
</comment>
                    <comment id="13163553" author="alex.parvulescu" created="Tue, 6 Dec 2011 12:28:34 +0000"  >V3 comes with a complete redesign of the patch.&lt;br/&gt;
&lt;br/&gt;
After further analysis we&amp;#39;ve decided to go with inspecting the incoming journal changes in the case of an initial index re-build.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll try to clarify. The scope of &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt; fix should *only* be for an initial index build. &lt;br/&gt;
The initial indexing operation can cause doubles to appear, as some nodes can be seen by a slave before the ADD event has reached it. This happens because of shared storage between cluster nodes.&lt;br/&gt;
So, when a slave starts to re-index the repository content, it will include *everything* (potentially also nodes that is hasn&amp;#39;t received a ADD event for yet). &lt;br/&gt;
When the index finishes, the repository will continue its startup. A bit later, the cluster component will also initialize and consequently sync. This will pull in the ADD events that were pending in a newer revision, on the master.&lt;br/&gt;
&lt;br/&gt;
The V3 tries to poll the changes before the cluster.sync call, and preemptively generate DELETE events for all the ADD events that it finds on the current workspace.&lt;br/&gt;
(this is similar to the &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt; patch, but with a much smaller scope).&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Another feature introduced in the patch is to force flush the index after the initial index has been created.&lt;br/&gt;
This was artificially done in the original test case (no unit test though) by:&lt;br/&gt;
&amp;gt; However, when I debug clusternode 2 and have a breakpoint (i.e., a pause of a few seconds at line 306 of RepositoryImpl.java - just before the clusternode is started), then the resultset contains two results, both with the same UUID.&lt;br/&gt;
&lt;br/&gt;
So forcing the index flush will correctly reproduce the original problem. And I think should be the correct behaviour of the original index creation.&lt;br/&gt;
On the other hand, not flushing the index will hide the problem because the indexing queue is smart enough to remove doubles.&lt;br/&gt;
&lt;br/&gt;
But, flushing the index basically invalidates &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-905&quot; title=&quot;Clustering: race condition may cause duplicate entries in search index&quot;&gt;&lt;strike&gt;JCR-905&lt;/strike&gt;&lt;/a&gt;, which is a bit unexpected (see attached patch, by switching the feature flags off).&lt;br/&gt;
&lt;br/&gt;
On the code itself: I guess the AbstractJournal could use a bit of refactoring on the event polling side.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13168350" author="mreutegg" created="Tue, 13 Dec 2011 13:00:59 +0000"  >Thanks for the patch.&lt;br/&gt;
&lt;br/&gt;
I see that you moved the initial index creation from the SearchIndex to the MultiIndex. This is how it was before &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1064&quot; title=&quot;Optimize queries that check for the existence of a property&quot;&gt;&lt;strike&gt;JCR-1064&lt;/strike&gt;&lt;/a&gt;, where we had to move it out of the MultiIndex. I&amp;#39;m not sure if it is now safe to move the initial index creation trigger back to the SearchIndex...&lt;br/&gt;
&lt;br/&gt;
The are some imports which look odd. The class ClusterNode imports the MultiIndex, though this is probably just minor because it is not really required to compile the class, but only to resolve the javadoc reference. More troublesome is the import of DbClusterTestJCR3162 in SearchManager. That doesn&amp;#39;t work because DbClusterTestJCR3162 is a test class.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m also wordering if it is possible to fix this issue without introducing too much changes to the journal/cluster code. Wouldn&amp;#39;t it be sufficient to use the existing journal and cluster node interface to get changes from a given revision?</comment>
                    <comment id="13168354" author="alex.parvulescu" created="Tue, 13 Dec 2011 13:14:14 +0000"  >hi, thanks for the feedback.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I see that you moved the initial index creation from the SearchIndex to the MultiIndex. This is how it was before &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1064&quot; title=&quot;Optimize queries that check for the existence of a property&quot;&gt;&lt;strike&gt;JCR-1064&lt;/strike&gt;&lt;/a&gt;, where we had to move it out of the MultiIndex. I&amp;#39;m not sure if it is now safe to move the initial index creation trigger back to the SearchIndex... &lt;br/&gt;
&lt;br/&gt;
I wasn&amp;#39;t aware of that move. I can put it back, it just felt a bit off to have code that is potentially internal to MultiIndex outside controlled by SearchIndex.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The class ClusterNode imports the MultiIndex, though this is probably just minor because it is not really required to compile the class, but only to resolve the javadoc reference&lt;br/&gt;
True. We can remove that import.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; More troublesome is the import of DbClusterTestJCR3162 in SearchManager. That doesn&amp;#39;t work because DbClusterTestJCR3162 is a test class. &lt;br/&gt;
That is just the feature flag. It will be removed once we agree on what the code should look like.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;Wouldn&amp;#39;t it be sufficient to use the existing journal and cluster node interface to get changes from a given revision?&lt;br/&gt;
I&amp;#39;m not aware of any such interface. You have the local revision number available, but not the actual changes, that is why I&amp;#39;ve added the &amp;#39;poll&amp;#39; operation.&lt;br/&gt;
&lt;br/&gt;
Now I&amp;#39;m investigating a lock on Cluster.sync introduced by this patch, so I&amp;#39;ll upload another one soon that will take this feedback into consideration.</comment>
                    <comment id="13168372" author="mreutegg" created="Tue, 13 Dec 2011 13:28:45 +0000"  >I think Journal.getRecords(long startRevision) could be used for that purpose.</comment>
                    <comment id="13168410" author="alex.parvulescu" created="Tue, 13 Dec 2011 14:33:46 +0000"  >&amp;gt; I think Journal.getRecords(long startRevision) could be used for that purpose.&lt;br/&gt;
&lt;br/&gt;
yes,that makes perfect sense! (and it gets rid of my lock problem :)&lt;br/&gt;
&lt;br/&gt;
Attaching v4:&lt;br/&gt;
&amp;nbsp;- using Journal.getRecords&lt;br/&gt;
&amp;nbsp;- cleanup of imports&lt;br/&gt;
&amp;nbsp;- moved feature flags from &amp;#39;test&amp;#39; code to main code (I&amp;#39;ll remove them entirely once the code is good)&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="13169417" author="mreutegg" created="Wed, 14 Dec 2011 14:59:51 +0000"  >Looks better now to me.&lt;br/&gt;
&lt;br/&gt;
Some more comments:&lt;br/&gt;
&lt;br/&gt;
- I would rather put getting the change log records into the SearchIndex, to not expand the api of the cluster node unnecessarily.&lt;br/&gt;
- getChangeLogRecords() should check the producer id of the record&lt;br/&gt;
- processing of ClusterRecords can be done without instanceof check&lt;br/&gt;
- Record.getWorkspace() may return null for operations on the version storage (RepositoryImpl.getSearchManager() should pass null as workspace name?)&lt;br/&gt;
- instance revision is also available from ClusterNode.getRevision()&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll attach a patch.</comment>
                    <comment id="13169428" author="alex.parvulescu" created="Wed, 14 Dec 2011 15:26:01 +0000"  >thanks for taking the time to rewrite the patch!&lt;br/&gt;
&lt;br/&gt;
It looks good to me.&lt;br/&gt;
I&amp;#39;ll remove the feature flags and the ol&amp;#39; dirty fix and commit the code.</comment>
                    <comment id="13169494" author="alex.parvulescu" created="Wed, 14 Dec 2011 16:44:18 +0000"  >fixed in revision 1214329</comment>
                    <comment id="13169529" author="mreutegg" created="Wed, 14 Dec 2011 17:47:23 +0000"  >&amp;gt; I&amp;#39;ll remove the feature flags and the ol&amp;#39; dirty fix and commit the code.&lt;br/&gt;
&lt;br/&gt;
my patch was just a quick rewrite of the patch to illustrate my comments. I didn&amp;#39;t run any tests with the patch. Did you run the tests? Otherwise I suggest we revert the commit for now...</comment>
                    <comment id="13169535" author="alex.parvulescu" created="Wed, 14 Dec 2011 17:52:59 +0000"  >yes I did. do you see any tests failing?&lt;br/&gt;
&lt;br/&gt;
is there any reason for reverting the change?</comment>
                    <comment id="13170132" author="mreutegg" created="Thu, 15 Dec 2011 11:44:44 +0000"  >I also noticed that the test is not included in the TestAll suite of the respective package. This means the new test is not run with every build.&lt;br/&gt;
&lt;br/&gt;
The new test uses annotations to mark the test, which makes it difficult to use in the TestAll. Is there a specific reason why you used annotations instead of inheriting from JUnitTest.&lt;br/&gt;
&lt;br/&gt;
I quickly extended the test to make the test nodes versionable and check consistency on the complete workspace (including the version storage). Running the test now results in random failure for me.&lt;br/&gt;
&lt;br/&gt;
See attached patch.</comment>
                    <comment id="13170133" author="mreutegg" created="Thu, 15 Dec 2011 11:45:41 +0000"  >To me it looks like this is not yet fixed.</comment>
                    <comment id="13170246" author="alex.parvulescu" created="Thu, 15 Dec 2011 14:34:24 +0000"  >Reverted the patch.&lt;br/&gt;
&lt;br/&gt;
It seems that there are some problems with the consistency chech on the versioning store.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m not sure it is related to this code, but just to be on the safe side I&amp;#39;ve reverted the changes.&lt;br/&gt;
&lt;br/&gt;
There are 2 issues blocking this issue, both tied to the query on the versioning store:&lt;br/&gt;
&amp;nbsp;-  some queries just fail (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3182&quot; title=&quot;SQL2 Parser fails for some version paths&quot;&gt;&lt;strike&gt;JCR-3182&lt;/strike&gt;&lt;/a&gt;)&lt;br/&gt;
&amp;nbsp;- some queries are built wrong (possibly because of the same issue)&lt;br/&gt;
Path &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;#39;/jcr:system/jcr:versionStorage/00&amp;#39;&lt;br/&gt;
Generated SQL2: &lt;br/&gt;
&amp;nbsp;&amp;nbsp;SELECT NODE.* FROM [nt:base] AS NODE WHERE ISCHILDNODE(NODE, [/jcr:system/jcr:versionStorage/0])</comment>
                    <comment id="13170329" author="mreutegg" created="Thu, 15 Dec 2011 16:27:41 +0000"  >I can confirm that the test runs successful when the path in the query statement is quoted.&lt;br/&gt;
&lt;br/&gt;
I think now that we know what&amp;#39;s going on, we can apply the patch again. Sorry, for being overly cautious....</comment>
                    <comment id="13170332" author="alex.parvulescu" created="Thu, 15 Dec 2011 16:30:52 +0000"  >Fixed in rev 1214842.&lt;br/&gt;
&lt;br/&gt;
False alarm, the errors came from an issue with the SQL2 Parsed (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-3182&quot; title=&quot;SQL2 Parser fails for some version paths&quot;&gt;&lt;strike&gt;JCR-3182&lt;/strike&gt;&lt;/a&gt;).&lt;br/&gt;
As it turns out, we have a workaround for it: quoting the path helps the parser work properly.</comment>
                </comments>
                    <attachments>
                    <attachment id="12507509" name="DbClusterTestJCR3162.patch" size="2965" author="mreutegg" created="Thu, 15 Dec 2011 11:45:02 +0000" />
                    <attachment id="12505631" name="JCR-3162.patch" size="7283" author="alex.parvulescu" created="Wed, 30 Nov 2011 16:10:13 +0000" />
                    <attachment id="12505783" name="JCR-3162-v2.patch" size="15423" author="alex.parvulescu" created="Thu, 1 Dec 2011 17:36:23 +0000" />
                    <attachment id="12506250" name="JCR-3162-v3.patch" size="29205" author="alex.parvulescu" created="Tue, 6 Dec 2011 12:28:34 +0000" />
                    <attachment id="12507187" name="JCR-3162-v4.patch" size="24824" author="alex.parvulescu" created="Tue, 13 Dec 2011 14:33:46 +0000" />
                    <attachment id="12507369" name="JCR-3162-v5.patch" size="18193" author="mreutegg" created="Wed, 14 Dec 2011 15:01:40 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Tue, 13 Dec 2011 13:00:59 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>219034</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>250194</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>