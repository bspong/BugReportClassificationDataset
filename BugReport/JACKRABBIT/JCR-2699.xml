<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:54:43 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2699/JCR-2699.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2699] Improve read/write concurrency</title>
                <link>https://issues.apache.org/jira/browse/JCR-2699</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>I&amp;#39;d like to set up a few performance tests to help identify our worst bottlenecks for various kinds of concurrent read-only and read-write access patterns.&lt;br/&gt;
&lt;br/&gt;
Once identified, I&amp;#39;m hoping to fix at least some of those bottlenecks.</description>
                <environment></environment>
            <key id="12470805">JCR-2699</key>
            <summary>Improve read/write concurrency</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Wed, 4 Aug 2010 14:58:32 +0100</created>
                <updated>Tue, 8 Nov 2011 15:52:00 +0000</updated>
                    <resolved>Tue, 5 Oct 2010 11:06:53 +0100</resolved>
                                            <fixVersion>2.0.3</fixVersion>
                <fixVersion>2.1.2</fixVersion>
                <fixVersion>2.2</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12895606" author="jukkaz" created="Thu, 5 Aug 2010 08:39:41 +0100"  >The attached plot from last night shows that we&amp;#39;ve already been improving things over past releases. That&amp;#39;s a good baseline to work from.</comment>
                    <comment id="12907656" author="jukkaz" created="Thu, 9 Sep 2010 16:36:18 +0100"  >Based on some profiling and other analysis based on the concurrent read performance tests I added, here&amp;#39;s a few pointers for potential improvements:&lt;br/&gt;
&lt;br/&gt;
* The bundle cache is hidden behind the synchronization layer of the bundle persistence classes, which causes a single cache miss to block access to the entire cache while the missing bundle is fetched from disk. We should revise the synchronization level to allow the bundle cache to serve concurrent requests even when the persistence manager is busy waiting for I/O.&lt;br/&gt;
&lt;br/&gt;
* The synchronization overhead in DefaultISMLocking was pretty high. I was seeing some significant time spent there even though in a concurrent read test a thread should never get blocked by the ISMLocking implementation. I refactored the DefaultISMLocking class in revision 995411 for issue &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2089&quot; title=&quot;Use java.util.concurrent&quot;&gt;JCR-2089&lt;/a&gt;, which solved most of this problem. I didn&amp;#39;t try it yet, but I suspect that the FineGrainedISMLocking class may be even worse in this regard.&lt;br/&gt;
&lt;br/&gt;
* Path handling code shows up quite a bit (2-5% of active CPU time) in profiling results. We should be able to avoid that overhead as described in the follow-up issue &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2744&quot; title=&quot;Avoid element arrays in PathImpl&quot;&gt;&lt;strike&gt;JCR-2744&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
* The synchronized cache blocks in ItemManager and SharedItemStateManager show up as contention bottlenecks in highly concurrent read scenarios.&lt;br/&gt;
&lt;br/&gt;
* Access control checks with the DefaultAccessManager add significant amount of overhead when compared to the dummy SimpleAccessManager implementation. Even though ACL optimizations are somewhat orthogonal to concurrency improvements, the large number of usually very fine-grained content accesses done by the DefaultAccessManager puts significant extra pressure on the above-mentioned contention points, so we should see notable concurrency improvements also from optimized ACL evaluation.</comment>
                    <comment id="12917313" author="ianeboston" created="Sun, 3 Oct 2010 11:35:19 +0100"  >On the last 2 points. ItemManager and DefaultAccessManager&lt;br/&gt;
&lt;br/&gt;
I have found that binding AccessControlProviders to thread when they are created in the AccessControlProviderFactoryImpl (and providing a clean up mechanism when the thread goes) coupled with making the SystemSession a non singleton, effectively binding it to a threa by explicitly creating a SystemSession inside the AccessControlProviderFactoryImpl, rather than using the reporitoryImpl.getSystemSession() method..... these measures completely eliminate thread blocking in the ItemManager.getNode(), ItemManager.getItem and ItemManager.getChildNodes() via the DefaultAccessManager for highly concurrent reads where ACLs are being evaluated.&lt;br/&gt;
&lt;br/&gt;
Unfortunately I now see blocking in the DefaultPrincipalManager, although this might be due to modifications I have in my ACL Provider stack which is slightly non standard.&lt;br/&gt;
&lt;br/&gt;
Will attach a patch against my code base to illustrate and inform in a moment.</comment>
                    <comment id="12917315" author="ianeboston" created="Sun, 3 Oct 2010 11:41:23 +0100"  >The patch is to my modified version of DefaultSecurityManager, which is a very close copy of the original.&lt;br/&gt;
The AccessControlProviderHolder manages the binding of AccessControlProviders to threads and provides a cleanup mechanism when threads go. Initial profiling indicates that with a high volume of thread mortality memory is not leaking.&lt;br/&gt;
&lt;br/&gt;
Neither of these fully solve the problem of thread blocking for highly concurrent reads, but they do improve the situation a bit.&lt;br/&gt;
</comment>
                    <comment id="12917381" author="ianeboston" created="Sun, 3 Oct 2010 19:52:11 +0100"  >One more change that I have made locally that allows concurrent reads with blockages now appearing in the SharedItemCache is to eliminate the synchronization inside the AbrstractPrincipalProvider protecting the LRUMap. Instead of syncing I am not expecting concurrent modification exceptions and as per the LRUMap documentation NPE on concurrent access. If I take this approach I dont see any exceptions from the LRUMap at 50 concurrent threads, and I dont get any blocking at that level.</comment>
                    <comment id="12917914" author="jukkaz" created="Tue, 5 Oct 2010 10:26:29 +0100"  >I&amp;#39;m a bit worried about the potentially adverse effects of growing the number of SystemSessions per workspace. A better approach could be to refactor the ACL handling to use the ItemValidator.performRelaxed() mechanism from &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2714&quot; title=&quot;Selective disabling of checks in ItemValidator&quot;&gt;&lt;strike&gt;JCR-2714&lt;/strike&gt;&lt;/a&gt; instead of the SystemSession. I&amp;#39;d also take the ACL discussion to &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2573&quot; title=&quot;Performance of AC Evaluation&quot;&gt;&lt;strike&gt;JCR-2573&lt;/strike&gt;&lt;/a&gt; where a more general effort to improve ACL evaluation performance is taking place.</comment>
                    <comment id="12917927" author="jukkaz" created="Tue, 5 Oct 2010 10:54:54 +0100"  >I&amp;#39;ve now implemented all of the above improvements (except ACL evaluation changes, which are better handled in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2573&quot; title=&quot;Performance of AC Evaluation&quot;&gt;&lt;strike&gt;JCR-2573&lt;/strike&gt;&lt;/a&gt;) and some other changes like allowing concurrent reads on pooled bundle db persistence managers. Apart from the ACL handling, I think I&amp;#39;ve now cleared all the major concurrency bottlenecks above the persistence manager layer. Most notably a cache miss is no longer enough to block all concurrent readers.&lt;br/&gt;
&lt;br/&gt;
The attached plots show the current performance in comparison to previous 2.x releases. The test case randomly accesses 1000 nodes out of a hierarchy of 10,000 nodes (100x100) while 20 other readers are also concurrently accessing the nodes. In the read/write case a single random writer thread is also included.&lt;br/&gt;
&lt;br/&gt;
The lower bound (10th percentile) of all tests is at about 25ms, which corresponds to the case where all accessed content is immediately available in the item state or bundle cache. The median and the higher bound (90th percentile) show the effect of one or more cache misses. The performance improvements are about 20-25% compared to Jackrabbit 2.1.&lt;br/&gt;
&lt;br/&gt;
Note that these tests were run with the default Jackrabbit configuration, i.e. without access controls.</comment>
                    <comment id="12917932" author="jukkaz" created="Tue, 5 Oct 2010 11:06:53 +0100"  >Looking at this from the other way, the total throughput of the 20 background readers also improved about 20% (9.2m reads per minute vs. 7.6m in Jackrabbit 2.1).&lt;br/&gt;
&lt;br/&gt;
Resolving as fixed, as I think we&amp;#39;re about done here. See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2573&quot; title=&quot;Performance of AC Evaluation&quot;&gt;&lt;strike&gt;JCR-2573&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2762&quot; title=&quot;Optimize bundle serialization&quot;&gt;&lt;strike&gt;JCR-2762&lt;/strike&gt;&lt;/a&gt; for some further areas where performance could be improved.</comment>
                    <comment id="12919265" author="ianeboston" created="Fri, 8 Oct 2010 13:28:07 +0100"  >The AccessControlProviderHolder attached here does put more pressure on the Heap than before and we have seen it result in high GC levels as it extracts all the space it can out of the JVM under heavy load (100 concurrent request threads).  There is an updated version being maintained at &lt;a href=&quot;http://github.com/ieb/open-experiments/blob/master/bundles/server/src/main/java/org/apache/jackrabbit/core/AccessControlProviderHolder.java&quot;&gt;http://github.com/ieb/open-experiments/blob/master/bundles/server/src/main/java/org/apache/jackrabbit/core/AccessControlProviderHolder.java&lt;/a&gt; (for the record ASF License granted), this uses soft references and a reference queue to allow the GC to evict SystemSessions when under pressure, although I found that this still put the GC under undue pressure so it also explicitly evicts AccessControlProviders when they get old and full ensuring that heap is never overloaded. Teste with Jmeter scripts over several hours. Will make a brief comment on &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2573&quot; title=&quot;Performance of AC Evaluation&quot;&gt;&lt;strike&gt;JCR-2573&lt;/strike&gt;&lt;/a&gt;</comment>
                    <comment id="12923441" author="jukkaz" created="Thu, 21 Oct 2010 14:54:45 +0100"  >I&amp;#39;ve now backported the essential parts of these changes to the 2.1 branch.</comment>
                    <comment id="12923484" author="jukkaz" created="Thu, 21 Oct 2010 16:29:24 +0100"  >The changes are now also in the 2.0 branch.</comment>
                </comments>
                    <attachments>
                    <attachment id="12456234" name="AccessControlProviderHolder.java" size="1680" author="ianeboston" created="Sun, 3 Oct 2010 11:41:23 +0100" />
                    <attachment id="12456374" name="ConcurrentReadTest.png" size="14559" author="jukkaz" created="Tue, 5 Oct 2010 10:54:54 +0100" />
                    <attachment id="12451311" name="ConcurrentReadTest.png" size="33951" author="jukkaz" created="Thu, 5 Aug 2010 08:39:41 +0100" />
                    <attachment id="12456375" name="ConcurrentReadWriteTest.png" size="27839" author="jukkaz" created="Tue, 5 Oct 2010 10:54:54 +0100" />
                    <attachment id="12456233" name="DynamicSecurityManager-JCR2699.patch" size="6567" author="ianeboston" created="Sun, 3 Oct 2010 11:41:23 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>5.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Sun, 3 Oct 2010 10:35:19 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>97836</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231795</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>