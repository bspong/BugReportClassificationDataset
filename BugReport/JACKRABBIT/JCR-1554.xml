<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:46:37 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1554/JCR-1554.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1554] StaleItemStateException with distributed transactions</title>
                <link>https://issues.apache.org/jira/browse/JCR-1554</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>There seams to be a serious bug in jackrabbit when used in distributed transactions. It does not occur with local transactions! And it seams to be related to &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-566&quot; title=&quot;Versioning bug with restore and transactions&quot;&gt;JCR-566&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
There are 2 scenarios where a StaleItemStateException occurs reproducible that causes transactions to fail. All my operations (implemented in a custom ServiceBean) such as setProperty() or deleteNode() run in separate transactions. The transactions are configured through Spring Annotations (@Transactional).&lt;br/&gt;
&lt;br/&gt;
Scenario A (setProperty):&lt;br/&gt;
(1) multiple setProperty() with same property name on the same node (newly created or already existent)&lt;br/&gt;
=&amp;gt; With the 3. setProperty() (and sometimes also the 5.), a StaleItemStateException for the property state is raised when the transaction is commited. Following setProperty invocations will not fail!&lt;br/&gt;
&lt;br/&gt;
Scenario B (deleteNode):&lt;br/&gt;
(1) iterate 10 times:&lt;br/&gt;
(1.1) create new node n and a subnode for n&lt;br/&gt;
(1.2) delete node n&lt;br/&gt;
=&amp;gt; Deletion of node n raises a StaleItemStateException for node n in iteration 1, 3 and (6 or 7), when the related transaction is commited. Following deletions of node n will also fail with a predictable pattern.&lt;br/&gt;
&lt;br/&gt;
The Exception trace for scenario A (it&amp;#39;s the same for scenario B, with one difference: StaleItemStateException is raised for the node and not for the property):&lt;br/&gt;
&lt;br/&gt;
org.springframework.transaction.UnexpectedRollbackException: JTA transaction unexpectedly rolled back (maybe due to a timeout); nested exception is javax.transaction.RollbackException: Error during one-phase commit&lt;br/&gt;
	at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1031)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:709)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:678)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:321)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:116)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)&lt;br/&gt;
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)&lt;br/&gt;
	at $Proxy9.setNodeProperty(Unknown Source)&lt;br/&gt;
	at de.zeb.control.prototype.jrTxBug.test.TestJackrabbitTxBug.testTransactionBug001(TestJackrabbitTxBug.java:97)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:585)&lt;br/&gt;
	at org.testng.internal.MethodHelper.invokeMethod(MethodHelper.java:580)&lt;br/&gt;
	at org.testng.internal.Invoker.invokeMethod(Invoker.java:478)&lt;br/&gt;
	at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:607)&lt;br/&gt;
	at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:874)&lt;br/&gt;
	at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:125)&lt;br/&gt;
	at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)&lt;br/&gt;
	at org.testng.TestRunner.runWorkers(TestRunner.java:689)&lt;br/&gt;
	at org.testng.TestRunner.privateRun(TestRunner.java:566)&lt;br/&gt;
	at org.testng.TestRunner.run(TestRunner.java:466)&lt;br/&gt;
	at org.testng.SuiteRunner.runTest(SuiteRunner.java:301)&lt;br/&gt;
	at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:296)&lt;br/&gt;
	at org.testng.SuiteRunner.privateRun(SuiteRunner.java:276)&lt;br/&gt;
	at org.testng.SuiteRunner.run(SuiteRunner.java:191)&lt;br/&gt;
	at org.testng.TestNG.createAndRunSuiteRunners(TestNG.java:808)&lt;br/&gt;
	at org.testng.TestNG.runSuitesLocally(TestNG.java:776)&lt;br/&gt;
	at org.testng.TestNG.run(TestNG.java:701)&lt;br/&gt;
	at org.testng.remote.RemoteTestNG.run(RemoteTestNG.java:73)&lt;br/&gt;
	at org.testng.remote.RemoteTestNG.main(RemoteTestNG.java:124)&lt;br/&gt;
Caused by: javax.transaction.RollbackException: Error during one-phase commit&lt;br/&gt;
	at org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:281)&lt;br/&gt;
	at org.apache.geronimo.transaction.manager.TransactionManagerImpl.commit(TransactionManagerImpl.java:143)&lt;br/&gt;
	at org.apache.geronimo.transaction.context.InheritableTransactionContext.complete(InheritableTransactionContext.java:196)&lt;br/&gt;
	at org.apache.geronimo.transaction.context.InheritableTransactionContext.commit(InheritableTransactionContext.java:146)&lt;br/&gt;
	at org.apache.geronimo.transaction.context.OnlineUserTransaction.commit(OnlineUserTransaction.java:80)&lt;br/&gt;
	at org.jencks.factory.UserTransactionFactoryBean$GeronimoUserTransaction.commit(UserTransactionFactoryBean.java:118)&lt;br/&gt;
	at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1028)&lt;br/&gt;
	... 30 more&lt;br/&gt;
Caused by: javax.transaction.xa.XAException&lt;br/&gt;
	at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:155)&lt;br/&gt;
	at org.apache.jackrabbit.core.XASessionImpl.commit(XASessionImpl.java:337)&lt;br/&gt;
	at org.apache.jackrabbit.jca.TransactionBoundXAResource.commit(TransactionBoundXAResource.java:39)&lt;br/&gt;
	at org.apache.geronimo.transaction.manager.WrapperNamedXAResource.commit(WrapperNamedXAResource.java:47)&lt;br/&gt;
	at org.apache.geronimo.transaction.manager.TransactionImpl.commit(TransactionImpl.java:272)&lt;br/&gt;
	... 36 more&lt;br/&gt;
Caused by: org.apache.jackrabbit.core.TransactionException: Unable to prepare transaction.&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:150)&lt;br/&gt;
	at org.apache.jackrabbit.core.TransactionContext.prepare(TransactionContext.java:138)&lt;br/&gt;
	... 40 more&lt;br/&gt;
Caused by: org.apache.jackrabbit.core.state.StaleItemStateException: bef3c056-bc91-4195-a35c-aa184182b5ad/{}TEST_PROPERTY has been modified externally&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager$Update.begin(SharedItemStateManager.java:620)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate(SharedItemStateManager.java:843)&lt;br/&gt;
	at org.apache.jackrabbit.core.state.XAItemStateManager.prepare(XAItemStateManager.java:144)&lt;br/&gt;
	... 41 more&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
When debugging into jackrabbit you will see, that the cause of the StaleItemStateException is, that the local state und the overlayed state differ in the value of the &amp;#39;modCount&amp;#39; attribute: modCount of local state is lower than modCount of overlayed state. Perhaps its a state caching problem...&lt;br/&gt;
	&lt;br/&gt;
I&amp;#39;m attaching a simple java application configured with maven and ready to run standalone. The JCA container of JBoss is therefore replaced with jencks in order to support distributed transactions. The configured repository uses the InMemPersistenceManager. Both scenarios are implemented in a TestNG - test, that catches the occuring TransactionExceptions and prints out the stacktrace. Therefore you will see the exceptions, but the tests will not fail.</description>
                <environment>WinXP, jdk1.5.0_14, jboss_4.2.2.GA, jackrabbit 1.4.2, spring 2.5.3, spring-modules-jcr 0.8 (for integration of jackrabbit with spring)&lt;br/&gt;
PM of repository: OraclePersistenceManager; DB: Oracle</environment>
            <key id="12394686">JCR-1554</key>
            <summary>StaleItemStateException with distributed transactions</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="srieckhoff">Sven Rieckhoff</reporter>
                        <labels>
                    </labels>
                <created>Thu, 24 Apr 2008 11:01:58 +0100</created>
                <updated>Fri, 1 May 2009 12:07:50 +0100</updated>
                    <resolved>Fri, 6 Feb 2009 17:58:46 +0000</resolved>
                            <version>1.4</version>
                <version>core 1.4.2</version>
                                <fixVersion>1.5.3</fixVersion>
                                <component>jackrabbit-core</component>
                <component>transactions</component>
                        <due></due>
                    <votes>6</votes>
                        <watches>9</watches>
                                                    <comments>
                    <comment id="12591967" author="srieckhoff" created="Thu, 24 Apr 2008 11:04:32 +0100"  >As announced a simple java application demonstrating the bug...</comment>
                    <comment id="12599893" author="kalished" created="Mon, 26 May 2008 19:40:47 +0100"  >I have the same problem, and we won&amp;#39;t ever be able to go in production with it...&lt;br/&gt;
&lt;br/&gt;
I have the feeling it comes from the Session being reused but its cache not being cleared at the end of a transaction, when refresh(false) is called.&lt;br/&gt;
It seems the bug dissapears when I add a itemMgr.dispose(); in SessionImpl.refresh :&lt;br/&gt;
&lt;br/&gt;
public void refresh(boolean keepChanges) throws RepositoryException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// check sanity of this session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sanityCheck();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!keepChanges) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// optimization&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;itemStateMgr.disposeAllTransientItemStates();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;itemMgr.dispose();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;itemMgr.getRootNode().refresh(keepChanges);&lt;br/&gt;
&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m not sure of the impact of this change, so could somebody of Jackrabbit have a look at it, please?&lt;br/&gt;
&lt;br/&gt;
Thank you,&lt;br/&gt;
&lt;br/&gt;
St&amp;#xE9;phane Landelle&lt;br/&gt;
</comment>
                    <comment id="12600502" author="stefan@jira" created="Wed, 28 May 2008 16:18:14 +0100"  >&amp;gt; Stephane Landelle commented on &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1554&quot; title=&quot;StaleItemStateException with distributed transactions&quot;&gt;&lt;strike&gt;JCR-1554&lt;/strike&gt;&lt;/a&gt;:&lt;br/&gt;
&amp;gt; ----------------------------------------&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I have the same problem, and we won&amp;#39;t ever be able to go in production with it...&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I have the feeling it comes from the Session being reused but its cache not being cleared at the end of a transaction, when refresh(false) is called.&lt;br/&gt;
&amp;gt; It seems the bug dissapears when I add a itemMgr.dispose(); in SessionImpl.refresh :&lt;br/&gt;
&lt;br/&gt;
i&amp;#39;m afraid that your proposed workaround would violate ItemManager&amp;#39;s contract, see:&lt;br/&gt;
&lt;a href=&quot;http://jackrabbit.apache.org/api/1.4/org/apache/jackrabbit/core/ItemManager.html&quot;&gt;http://jackrabbit.apache.org/api/1.4/org/apache/jackrabbit/core/ItemManager.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
&amp;lt;quote&amp;gt;&lt;br/&gt;
The ItemManager&amp;#39;s responsabilities are:&lt;br/&gt;
[...]&lt;br/&gt;
guaranteeing that there aren&amp;#39;t multiple instances representing the same Node or Property associated with the same Session instance.&lt;br/&gt;
&amp;lt;/quote&amp;gt;&lt;br/&gt;
&lt;br/&gt;
your proposed change could lead to multiple Node or Property instances per session representing the same item.&lt;br/&gt;
this would cause serious consistency issues.&lt;br/&gt;
&lt;br/&gt;
-1 for the proposed change.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; public void refresh(boolean keepChanges) throws RepositoryException {&lt;br/&gt;
&amp;gt;        // check sanity of this session&lt;br/&gt;
&amp;gt;        sanityCheck();&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;        if (!keepChanges) {&lt;br/&gt;
&amp;gt;            // optimization&lt;br/&gt;
&amp;gt;            itemStateMgr.disposeAllTransientItemStates();&lt;br/&gt;
&amp;gt;            itemMgr.dispose();&lt;br/&gt;
&amp;gt;            return;&lt;br/&gt;
&amp;gt;        }&lt;br/&gt;
&amp;gt;        itemMgr.getRootNode().refresh(keepChanges);&lt;br/&gt;
&amp;gt;  }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; I&amp;#39;m not sure of the impact of this change, so could somebody of Jackrabbit have a look at it, please?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12625540" author="yoav" created="Mon, 25 Aug 2008 23:40:21 +0100"  >We have the same problem which is also becoming a production issue. Any idea if there is a valid patch for this or when it will be resolved?</comment>
                    <comment id="12668045" author="astrograph" created="Wed, 28 Jan 2009 15:00:33 +0000"  >this issue is breaking most of our automated tests. It looks like jackrabbit transaction support is thoroughly broken. &lt;br/&gt;
&lt;br/&gt;
Redhat Enterprise Linux WS Rel 4, jrockit_150_12, bea weblogic 9.2, jackrabbit 1.5, spring 2.5.5, spring-modules-jcr 0.9 </comment>
                    <comment id="12670446" author="losandos" created="Wed, 4 Feb 2009 20:17:08 +0000"  >&lt;br/&gt;
It might be that the following explanation is not as it really is, so feel free to correct me:&lt;br/&gt;
&lt;br/&gt;
An ItemState might have an overlayedState. What I have seen from debugging with lots of logging is that an itemState could have an overlayedState and this overlayedState could also have an overlayedState and so on. &lt;br/&gt;
If there is a e.g. a property change the ItemStateManger(s) gets &amp;quot;informed&amp;quot; and the &amp;quot;stateModified&amp;quot; method is called. &lt;br/&gt;
In transactions the the XAItemStateManager&amp;#39;s (which is a sub class of the LocalItemStateManager) &amp;quot;stateModified&amp;quot; method is called.&lt;br/&gt;
If the state already exists the &amp;quot;pull()&amp;quot; method is called on that state (ItemState.pull()). The idea of the pull method is to sync up the modification counter with the overlayedState. And here is the issue IMHO because it is only done &amp;quot;one layer down&amp;quot; and not top down. &lt;br/&gt;
If I saw it correctly, with the provided test class, setting a property the first time will end up in one ItemState, setting it the 2nd time you will have an itemState with an overlayedState, calling it the 3rd time, you have itemState-&amp;gt;overlayedState-&amp;gt;overlayedState. If than &amp;quot;pull()&amp;quot; is called to sync up the modCount, it is only done with the itemState-&amp;gt;overlayedState and not with the itemState-&amp;gt;overlayedState-&amp;gt;overlayedState....thats IMHO the reason why you see it at the 3rd time and not before. &lt;br/&gt;
&lt;br/&gt;
To cut a long story short, here what i changed:&lt;br/&gt;
&lt;br/&gt;
ItemState.java (line 152ff): &lt;br/&gt;
&lt;br/&gt;
original:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized void pull() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ItemState state = overlayedState;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (state != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// sync modification count&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;copy(state, true);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
my modification:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized void pull() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ItemState state = overlayedState;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (state != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// sync modification count top down&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (state.isConnected()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state.pull();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;copy(state, true);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
With that change I was able to a) build jackrabbit and b) run the provided TestNG successfully without the RollbackException (for both tests, setting the item property and deleting a node).&lt;br/&gt;
&lt;br/&gt;
Jackrabbit guys, could you please take a look at my proposal.&lt;br/&gt;
&lt;br/&gt;
Thanks!!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12670760" author="astrograph" created="Thu, 5 Feb 2009 14:42:09 +0000"  >with this fix in place:&lt;br/&gt;
&lt;br/&gt;
$ diff ItemState.java ItemState.java.bak&lt;br/&gt;
152c152&lt;br/&gt;
&amp;lt;      synchronized void pull() {&lt;br/&gt;
---&lt;br/&gt;
&amp;gt;     synchronized void pull() {&lt;br/&gt;
155,158c155&lt;br/&gt;
&amp;lt;             // sync modification count top down&lt;br/&gt;
&amp;lt;             if (state.isConnected()) {&lt;br/&gt;
&amp;lt;                 state.pull();&lt;br/&gt;
&amp;lt;             }&lt;br/&gt;
---&lt;br/&gt;
&amp;gt;             // sync modification count&lt;br/&gt;
161c158&lt;br/&gt;
&amp;lt;     }&lt;br/&gt;
---&lt;br/&gt;
&amp;gt;     }&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
I was able to run our regression suite without unexpected rollback transaction coming up, additionally manual tests in variouse parts of our application did not show issues.</comment>
                    <comment id="12670826" author="losandos" created="Thu, 5 Feb 2009 16:50:21 +0000"  >If this is the fix for that issue, updating also the push method might be good as well.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void push() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ItemState state = overlayedState;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (state != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (state.isConnected()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state.getOverlayedState().copy(this, false);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state.copy(this, false);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}</comment>
                    <comment id="12670829" author="dpfister" created="Thu, 5 Feb 2009 17:13:54 +0000"  >Hi,&lt;br/&gt;
&lt;br/&gt;
Martin and Philipp, thanks for your input, which helped me a lot understanding what is going wrong here and why. As far as I can tell right now, the issue is caused by the local property state, referenced in the XAItemStateManager&amp;#39;s change log, which is not being updated (&amp;quot;pulled&amp;quot;) correctly at the end of a save operation. Usually, this happens inside SharedItemStateManager.Update.end():&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/* Let the shared item listeners know about the change */&lt;br/&gt;
---&amp;gt;         shared.persisted();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// downgrade to read lock&lt;br/&gt;
&lt;br/&gt;
Among others, this will notify the XAItemStateManager about the changes made to the property state (modcount increased by 1). Its stateModified() implementation, which is actually contained in the super class LocalItemStateManager, looks like this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// shared state was modified&lt;br/&gt;
---&amp;gt;     local = cache.retrieve(modified.getId());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (local != null &amp;amp;&amp;amp; local.isConnected()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// this instance represents existing state, update it&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;local.pull();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Without transactions, the local state will be contained in the cache. With transactions, on the other hand, the local state will only be contained in the current transaction&amp;#39;s change log, so there will be no update to this state and the modcount stays at its current value.&lt;br/&gt;
&lt;br/&gt;
Looking at the modcounts of the property states in the transient (T), local (L) and shared (S) layers, one can watch the following behaviours in the successive calls to Property.setValue():&lt;br/&gt;
&lt;br/&gt;
1)  T: 0,  L: N/A, S:N/A   (obviously, because the first operation *creates* the property state)&lt;br/&gt;
2)  T: 0,  L: 0, S: 0&lt;br/&gt;
3)  T: 0,  L: 0, S: 1&lt;br/&gt;
&lt;br/&gt;
which explains why the 3rd operation wil fail.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll further look into this tomorrow, so please stay tuned!&lt;br/&gt;
&lt;br/&gt;
Kind regards&lt;br/&gt;
Dominique</comment>
                    <comment id="12671220" author="dpfister" created="Fri, 6 Feb 2009 17:58:46 +0000"  >Fixed by updating the states contained in the transactional change log, as well. Added 2 test cases in XATest (testSetProperty and testDeleteNode) that mimic the behaviour of the TestNG test cases, especially reusing the same session for subsequent transactions, which effectively let the different transactions operate on the same PropertyImpl and NodeImpl instances, respectively.&lt;br/&gt;
&lt;br/&gt;
Fixed in revision 741652.&lt;br/&gt;
</comment>
                    <comment id="12671225" author="dpfister" created="Fri, 6 Feb 2009 18:07:13 +0000"  >Verified that if the fix to XAItemStateManager is applied to jackrabbit-core-1.4.2, the TestNG tests will run without failures and no exceptions occur.</comment>
                    <comment id="12672262" author="astrograph" created="Tue, 10 Feb 2009 13:44:20 +0000"  >Hi Dominique,&lt;br/&gt;
&lt;br/&gt;
thnx for resolving the issue! Any idea when this will be released?&lt;br/&gt;
&lt;br/&gt;
thx,&lt;br/&gt;
&lt;br/&gt;
Philipp</comment>
                    <comment id="12672288" author="dpfister" created="Tue, 10 Feb 2009 15:09:06 +0000"  >Hi Philipp,&lt;br/&gt;
&lt;br/&gt;
Not sure about this: since the change is very small and unlikely to cause problems, I assume that a fix for this will be contained in 1.5.3, which should be released quite soon. Are you already using 1.5 or able to upgrade?&lt;br/&gt;
&lt;br/&gt;
Kind regards&lt;br/&gt;
Dominique</comment>
                    <comment id="12672294" author="astrograph" created="Tue, 10 Feb 2009 15:34:42 +0000"  >we are using 1.5&lt;br/&gt;
&lt;br/&gt;
thx,&lt;br/&gt;
&lt;br/&gt;
Philipp</comment>
                    <comment id="12672640" author="jukkaz" created="Wed, 11 Feb 2009 14:26:40 +0000"  >Merged to the 1.5 branch in revision 743343. This fix will be included in the 1.5.3 release.</comment>
                    <comment id="12704944" author="jukkaz" created="Fri, 1 May 2009 11:18:54 +0100"  >&amp;gt; I still get this error with 1.4.9. &lt;br/&gt;
&lt;br/&gt;
The fix is included in the 1.5.3 release.</comment>
                    <comment id="12704951" author="jukkaz" created="Fri, 1 May 2009 11:41:38 +0100"  >I don&amp;#39;t see your point, JCR -1554 is listed as a known issue for 1.4.5. In other words, we knew that this issue was *not* fixed in 1.4.5.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="12310000">
                <name>Duplicate</name>
                                                <inwardlinks description="is duplicated by">
                            <issuelink>
            <issuekey id="12413226">JCR-1953</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12380830" name="jackrabbit-tx-bug.zip" size="19940" author="srieckhoff" created="Thu, 24 Apr 2008 11:04:32 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 26 May 2008 18:40:47 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78511</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190165</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>