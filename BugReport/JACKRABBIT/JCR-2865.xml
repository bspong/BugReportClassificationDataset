<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:33:55 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2865/JCR-2865.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2865] a dead lock in DefaultISMLocking</title>
                <link>https://issues.apache.org/jira/browse/JCR-2865</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The jackrabbit 2.2 &amp;#39;s org.apache.jackrabbit.core.state.DefaultISMLocking has a defect which will cause a dead lock in concurrent use cases.&lt;br/&gt;
The use case is as follows:&lt;br/&gt;
1.	Thread A apply a read lock, now there is an active reader hold the read lock.&lt;br/&gt;
&lt;br/&gt;
2.	Thread B apply a write lock, and then thread B will wait for thread A&amp;#39;s reading end. You could see below code snippet from the Jackrabbit source. readerCount is the current active reader.&lt;br/&gt;
writersWaiting++;&lt;br/&gt;
while (writerId != null? !isSameThreadId(writerId, currentId) : readerCount &amp;gt; 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
3.	Thread A apply another read lock, then it will wait too, since there is a writer is waiting.  Then a dead lock happens.&lt;br/&gt;
while (writerId != null? (writerCount &amp;gt; 0 &amp;amp;&amp;amp; !isSameThreadId(writerId, currentId)): writersWaiting &amp;gt; 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;wait();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
Since the lock in DefaultISMLocking is global lock, so I think if a thread has already hold a reader lock, it could get the reader lock again. I create a fix with this idea.&lt;br/&gt;
</description>
                <environment>winXP/JDK1.6</environment>
            <key id="12495952">JCR-2865</key>
            <summary>a dead lock in DefaultISMLocking</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="codeparser">codeparser</reporter>
                        <labels>
                    </labels>
                <created>Wed, 19 Jan 2011 02:34:57 +0000</created>
                <updated>Thu, 17 Feb 2011 15:49:54 +0000</updated>
                    <resolved>Mon, 31 Jan 2011 13:42:05 +0000</resolved>
                            <version>2.2</version>
                                <fixVersion>2.1.5</fixVersion>
                <fixVersion>2.2.4</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>2</watches>
                                                    <comments>
                    <comment id="12983504" author="codeparser" created="Wed, 19 Jan 2011 02:36:59 +0000"  >a fix to track the reader</comment>
                    <comment id="12983636" author="jukkaz" created="Wed, 19 Jan 2011 10:07:02 +0000"  >Do you have a real case of thread A applying for another read lock? If yes, can you please post a thread dump of the deadlock?&lt;br/&gt;
&lt;br/&gt;
Such a double-read should never occur, so instead of adding code and complexity in DefaultISMLocking (which is a very performance-critical component) we should get rid of such possible double-reads.</comment>
                    <comment id="12984052" author="codeparser" created="Thu, 20 Jan 2011 07:11:33 +0000"  >The dead lock thread is as follows:&lt;br/&gt;
&lt;br/&gt;
thread 1148 first time get read lock: InternalVersionManagerImpl line 324&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;second time get : InternalVersionImpl line 149&lt;br/&gt;
&lt;br/&gt;
&amp;quot;Thread-1148&amp;quot; daemon prio=6 tid=0x4a409400 nid=0x15a0 in Object.wait() [0x4d27f000..0x4d27fb94]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;java.lang.Thread.State: WAITING (on object monitor)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.Object.wait(Native Method)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- waiting on &amp;lt;0x099abc00&amp;gt; (a org.apache.jackrabbit.core.state.DefaultISMLocking)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.Object.wait(Object.java:485)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock(DefaultISMLocking.java:92)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- locked &amp;lt;0x099abc00&amp;gt; (a org.apache.jackrabbit.core.state.DefaultISMLocking)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionManagerBase.acquireReadLock(InternalVersionManagerBase.java:196)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionImpl.getSuccessors(InternalVersionImpl.java:149)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.init(InternalVersionHistoryImpl.java:165)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- locked &amp;lt;0x03a6d180&amp;gt; (a org.apache.jackrabbit.core.version.InternalVersionHistoryImpl)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.&amp;lt;init&amp;gt;(InternalVersionHistoryImpl.java:113)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionManagerBase.createInternalVersionItem(InternalVersionManagerBase.java:806&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionManagerImpl.getItem(InternalVersionManagerImpl.java:329)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- locked &amp;lt;0x099abd08&amp;gt; (a org.apache.commons.collections.map.ReferenceMap)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalXAVersionManager.getItem(InternalXAVersionManager.java:429)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionManagerBase.getVersionHistory(InternalVersionManagerBase.java:134)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalXAVersionManager.getVersionHistory(InternalXAVersionManager.java:58)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalVersionManagerBase.checkin(InternalVersionManagerBase.java:583)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.InternalXAVersionManager.checkin(InternalXAVersionManager.java:236)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.version.VersionManagerImplBase.checkoutCheckin(VersionManagerImplBase.java:190)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl.access$1(VersionManagerImpl.java:1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl$1.perform(VersionManagerImpl.java:121)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl$1.perform(VersionManagerImpl.java:1)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.session.SessionState.perform(SessionState.java:200)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl.perform(VersionManagerImpl.java:95)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl.checkin(VersionManagerImpl.java:114)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.VersionManagerImpl.checkin(VersionManagerImpl.java:100)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at org.apache.jackrabbit.core.NodeImpl.checkin(NodeImpl.java:2844)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.service.jcr.access.JcrAccessUtil.checkin(JcrAccessUtil.java:580)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.service.jcr.JcrLeaveNodeImpl.checkin(JcrLeaveNodeImpl.java:54)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.service.core.CoreModel.checkin(CoreModel.java:101)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.service.core.CoreModel.checkin(CoreModel.java:66)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.service.proxy.local.LocalModel.checkin(LocalModel.java:62)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.usecase.transaction.ModelModifier.action(DeadLockTest.java:197)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at com.vitria.modeling.repository.sapi.usecase.transaction.AbstractTestThread.run(DeadLockTest.java:156)</comment>
                    <comment id="12984133" author="jukkaz" created="Thu, 20 Jan 2011 11:05:51 +0000"  >OK, thanks! See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2828&quot; title=&quot;InternalVersionManager deadlock&quot;&gt;&lt;strike&gt;JCR-2828&lt;/strike&gt;&lt;/a&gt; for an earlier related issue, and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2753&quot; title=&quot;Deadlock in DefaultISMLocking&quot;&gt;&lt;strike&gt;JCR-2753&lt;/strike&gt;&lt;/a&gt; for a case where the reentrancy requirement came up earlier.&lt;br/&gt;
&lt;br/&gt;
In general I think we shouldn&amp;#39;t use DefaultISMLocking as a generic read/write lock in InternalVersionManagerBase, but I don&amp;#39;t have a direct replacement in mind.</comment>
                    <comment id="12984172" author="jukkaz" created="Thu, 20 Jan 2011 13:16:07 +0000"  >To follow up on the above, the reason why a normal ReentrantReadWriteLock instance isn&amp;#39;t appropriate in this case is that the lock needs to be reentrant also for transactions that may span over multiple threads.</comment>
                    <comment id="12985510" author="codeparser" created="Mon, 24 Jan 2011 04:26:11 +0000"  >are you going to give a official fix about it? This problem could be encountered easily in our environment.</comment>
                    <comment id="12985597" author="jukkaz" created="Mon, 24 Jan 2011 09:54:17 +0000"  >Here&amp;#39;s the best quick solution I came up with: We&amp;#39;ll copy the DefaultISMLocking class into a VersioningLock class for use only by the version manager code. This way we can keep the DefaultISMLocking class clean and focused to just one use case, while still leveraging the code and your fix in the version manager. Would you mind preparing a patch like that?</comment>
                    <comment id="12985684" author="c_koell" created="Mon, 24 Jan 2011 13:44:41 +0000"  >Why we can not modify the DefaultISMLocking class to allow re-read as it was implemented before changing code not to use oswego code ?</comment>
                    <comment id="12988734" author="jukkaz" created="Mon, 31 Jan 2011 11:40:14 +0000"  >&amp;gt; Why we can not modify the DefaultISMLocking class&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s a very performance-critical piece of code in highly concurrent and fully cached use cases (i.e. a typical web server). See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2699&quot; title=&quot;Improve read/write concurrency&quot;&gt;&lt;strike&gt;JCR-2699&lt;/strike&gt;&lt;/a&gt; for the work I did to streamline the synchronized acquireReadLock() method as much as possible. Currently the method doesn&amp;#39;t allocate any new memory or make any structural changes to any data structures, and I&amp;#39;d like to keep it that way until we can come up with a way to avoid synchronization.&lt;br/&gt;
&lt;br/&gt;
The improved logic in DefaultISMLocking was based on a rather thorough review of the concurrency requirements of the ISMLocking interface. Unfortunately I failed to take into account the fact that the DefaultISMLocking class is also being used directly by the version manager outside the ISMLocking contract. This and the other referenced issues are a result of this.&lt;br/&gt;
&lt;br/&gt;
ISM and version locking are really two separate cases with somewhat different requirements, which is why I don&amp;#39;t think it&amp;#39;s a good idea to use a single class for both cases. I&amp;#39;ll go forward and implement the idea I suggested earlier about splitting the class into two different copies.</comment>
                    <comment id="12988740" author="c_koell" created="Mon, 31 Jan 2011 12:10:22 +0000"  >It would also be my intention not to use the DefaultISMLocking everywhere as locking class&lt;br/&gt;
As you mentionent it breaks the ISM contract. It would be great to have sepereted classes to handle the uses cases (re-read) in a proper way&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12988758" author="jukkaz" created="Mon, 31 Jan 2011 13:42:05 +0000"  >Fixed in revision 1065599 and merged to the 2.2 branch in revision 1065610.&lt;br/&gt;
&lt;br/&gt;
The solution I implemented was to take an earlier version of the DefaultISMLocking class from before &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2699&quot; title=&quot;Improve read/write concurrency&quot;&gt;&lt;strike&gt;JCR-2699&lt;/strike&gt;&lt;/a&gt; and adapt it into a versioning-only read-write lock class. Besides solving the problem, this change helps reduce coupling between the o.a.j.core.version and o.a.j.core.state packages.</comment>
                    <comment id="12989676" author="tmueller" created="Wed, 2 Feb 2011 15:44:31 +0000"  >The obvious disadvantage is code duplication.</comment>
                    <comment id="12989683" author="jukkaz" created="Wed, 2 Feb 2011 16:02:56 +0000"  >&amp;gt; The obvious disadvantage is code duplication.&lt;br/&gt;
&lt;br/&gt;
In fact the amount of duplication in this case is pretty small, as the two use cases are quite different. In fact I think there are less than ten lines that these two classes have in common.</comment>
                    <comment id="12989699" author="tmueller" created="Wed, 2 Feb 2011 16:28:51 +0000"  >You are right, it&amp;#39;s not source code duplication, sorry. But it&amp;#39;s duplicating logic. The two classes do almost the same thing, with one small but important difference: DefaultISMLocking isn&amp;#39;t re-entrant for in all cases (is that documented in the source code?), and was the root cause for this bug and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2753&quot; title=&quot;Deadlock in DefaultISMLocking&quot;&gt;&lt;strike&gt;JCR-2753&lt;/strike&gt;&lt;/a&gt;.</comment>
                    <comment id="12989707" author="jukkaz" created="Wed, 2 Feb 2011 16:50:03 +0000"  >That crucial difference (documented in the ISMLocking javadocs) is what makes the design of these two classes so different and what enables the  performance optimizations implemented in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2699&quot; title=&quot;Improve read/write concurrency&quot;&gt;&lt;strike&gt;JCR-2699&lt;/strike&gt;&lt;/a&gt;. By similar logic also the ArrayList and LinkedList classes in java.util are duplicates.</comment>
                    <comment id="12993513" author="jukkaz" created="Fri, 11 Feb 2011 14:31:27 +0000"  >Merged to the 2.1 branch in revision 1069811.</comment>
                </comments>
                    <attachments>
                    <attachment id="12468719" name="trackReader.diff" size="3043" author="codeparser" created="Wed, 19 Jan 2011 02:36:59 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 19 Jan 2011 10:07:02 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>78146</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231797</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>