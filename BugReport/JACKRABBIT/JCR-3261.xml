<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:53:57 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-3261/JCR-3261.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-3261] Problems with BundleDbPersistenceManager getAllNodeIds</title>
                <link>https://issues.apache.org/jira/browse/JCR-3261</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>When using MySQL:&lt;br/&gt;
The problem arises when the method parameter maxcount is less than the total amount of records in the bundle table.&lt;br/&gt;
&lt;br/&gt;
First of all I found out that mysql orders the nodeid objects different than jackrabbit does. The following test describes this idea:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void testMySQLOrderByNodeId() throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId1 = new NodeId(&amp;quot;7ff9e87c-f87f-4d35-9d61-2e298e56ac37&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId2 = new NodeId(&amp;quot;9fd0d452-b5d0-426b-8a0f-bef830ba0495&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PreparedStatement stmt = connection.prepareStatement(&amp;quot;SELECT NODE_ID FROM DEFAULT_BUNDLE WHERE NODE_ID = ? OR NODE_ID = ? ORDER BY NODE_ID&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object[] params = new Object[] { nodeId1.getRawBytes(), nodeId2.getRawBytes() };&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stmt.setObject(1, params[0]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stmt.setObject(2, params[1]);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ArrayList&amp;lt;NodeId&amp;gt; nodeIds = new ArrayList&amp;lt;NodeId&amp;gt;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ResultSet resultSet = stmt.executeQuery();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while(resultSet.next()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId = new NodeId(resultSet.getBytes(1));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(nodeId);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nodeIds.add(nodeId);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Collections.sort(nodeIds);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (NodeId nodeId : nodeIds) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(nodeId);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Which results in the following output:&lt;br/&gt;
&lt;br/&gt;
7ff9e87c-f87f-4d35-9d61-2e298e56ac37&lt;br/&gt;
9fd0d452-b5d0-426b-8a0f-bef830ba0495&lt;br/&gt;
9fd0d452-b5d0-426b-8a0f-bef830ba0495&lt;br/&gt;
7ff9e87c-f87f-4d35-9d61-2e298e56ac37&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Now the problem with the getAllNodeIds method is that it fetches an extra 10 records on top of maxcount (to avoid a problem where the first key is not the one you that is wanted). Afterwards it skips a number of records again, this time using nodeid.compareto. This compareto statement returns true unexpectedly for mysql because the code doesn&amp;#39;t expect the mysql ordering.&lt;br/&gt;
&lt;br/&gt;
I had the situation where I had about 17000 records in the bundle table but consecutively getting the ids a thousand records at a time returned only about 8000 records in all.&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12546788">JCR-3261</key>
            <summary>Problems with BundleDbPersistenceManager getAllNodeIds</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="schans">Bart van der Schans</assignee>
                                <reporter username="unico@apache.org">Unico Hommes</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Mar 2012 14:24:05 +0000</created>
                <updated>Sun, 27 May 2012 10:49:17 +0100</updated>
                    <resolved>Mon, 19 Mar 2012 13:47:09 +0000</resolved>
                            <version>2.4</version>
                                <fixVersion>2.4.1</fixVersion>
                <fixVersion>2.5</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13231231" author="unico@apache.org" created="Fri, 16 Mar 2012 14:27:26 +0000"  >Patch against 2.4.x branch.&lt;br/&gt;
&lt;br/&gt;
The special handling of maxcount is only necessary in the case of longlong storage model. In the case of a binary storage model I can easily understand that ordering is not well defined and can vary from database to database. Therefore only do the special handling for longlong storage model. </comment>
                    <comment id="13232038" author="unico@apache.org" created="Sat, 17 Mar 2012 18:47:33 +0000"  >Updated title and description because another problem with the same method was found for Derby DB. Attaching an updated patch.</comment>
                    <comment id="13232046" author="unico@apache.org" created="Sat, 17 Mar 2012 19:05:23 +0000"  >Problem was at my end apparently. No problem with Derby DB after all.</comment>
                    <comment id="13232498" author="tmueller" created="Mon, 19 Mar 2012 08:12:43 +0000"  >What is your use case, that is, why do you need getAllNodeIds? I&amp;#39;m just wondering if we really need this method... If we could remove it then we wouldn&amp;#39;t have to deal with such problems.</comment>
                    <comment id="13232529" author="reschke" created="Mon, 19 Mar 2012 09:52:30 +0000"  >&amp;gt; What is your use case, that is, why do you need getAllNodeIds? I&amp;#39;m just wondering if we really need this method... If we could remove it then we wouldn&amp;#39;t have to deal with such problems. &lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s needed by the datastore garbage collector and the consistency checker.</comment>
                    <comment id="13232540" author="unico@apache.org" created="Mon, 19 Mar 2012 10:43:57 +0000"  >I was using the Jackrabbit consistency checker. See &lt;a href=&quot;http://svn.apache.org/repos/asf/jackrabbit/tags/2.4.0/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/persistence/bundle/ConsistencyCheckerImpl.java&quot;&gt;http://svn.apache.org/repos/asf/jackrabbit/tags/2.4.0/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/persistence/bundle/ConsistencyCheckerImpl.java&lt;/a&gt;&lt;br/&gt;
</comment>
                    <comment id="13232556" author="tmueller" created="Mon, 19 Mar 2012 11:00:07 +0000"  >OK I see. For data store garbage collection, you could live without the method, as persistence manager scan is optional there. But the consistency checker needs it, and changing the consistency checker to do a regular node traversal would be probably quite a lot of work.&lt;br/&gt;
&lt;br/&gt;
Not sure how to solve it, possibly use &amp;quot;order by desc&amp;quot;? I guess more tests would be required (it seems we use varbinary(16) in MySQL, which might deal with trailing zeroes differently and binary(16))</comment>
                    <comment id="13232558" author="unico@apache.org" created="Mon, 19 Mar 2012 11:09:52 +0000"  >I think the supplied patch is probably the right solution. Order by descending won&amp;#39;t work because it&amp;#39;s not exactly the other way around that MySQL orders the nodes.</comment>
                    <comment id="13232584" author="schans" created="Mon, 19 Mar 2012 12:48:03 +0000"  >The problem seems to be that the following block should only be applied for LONGLONG keys and not for BINARY keys.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (lowId != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// skip the keys that are smaller or equal (see above, maxCount += 10)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// only required for SM_LONGLONG_KEYS&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (current.compareTo(lowId) &amp;lt;= 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;continue;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                    <comment id="13232585" author="schans" created="Mon, 19 Mar 2012 12:50:27 +0000"  >Patch committed in r1302401 in slightly adjusted form to trunk.</comment>
                    <comment id="13232598" author="reschke" created="Mon, 19 Mar 2012 13:14:00 +0000"  >&amp;gt; OK I see. For data store garbage collection, you could live without the method, as persistence manager scan is optional there. But the consistency checker needs it, and changing the consistency checker to do a regular node traversal would be probably quite a lot of work. &lt;br/&gt;
&lt;br/&gt;
It would also defeat part of the purpose of the consistency checker (finding orphaned nodes). </comment>
                    <comment id="13232605" author="tmueller" created="Mon, 19 Mar 2012 13:28:36 +0000"  >&amp;gt; It would also defeat part of the purpose of the consistency checker (finding orphaned nodes).&lt;br/&gt;
&lt;br/&gt;
Yes, absolutely true.</comment>
                    <comment id="13232616" author="schans" created="Mon, 19 Mar 2012 13:46:24 +0000"  >Merged in 2.4 in r1302430.</comment>
                </comments>
                    <attachments>
                    <attachment id="12518675" name="bdbpm_allids.patch" size="1393" author="unico@apache.org" created="Fri, 16 Mar 2012 14:27:26 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 19 Mar 2012 08:12:43 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231947</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>252501</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>