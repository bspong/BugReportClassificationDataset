<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:32:29 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-851/JCR-851.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-851] Handling of binary properties (streams) in QValue interface</title>
                <link>https://issues.apache.org/jira/browse/JCR-851</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The current SPI requires QValue to return new streams upon each call to getStream(). As far as I can tell, this essentially requires a QValue implementation to preserve the whole content of a stream, be it in memory or on disk.&lt;br/&gt;
&lt;br/&gt;
In particular (and unless I&amp;#39;m missing something), when importing large content into a repository, this causes the whole data stream to be written twice. We really should try to avoid that.&lt;br/&gt;
</description>
                <environment></environment>
            <key id="12367475">JCR-851</key>
            <summary>Handling of binary properties (streams) in QValue interface</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="reschke">Julian Reschke</reporter>
                        <labels>
                    </labels>
                <created>Wed, 18 Apr 2007 14:42:34 +0100</created>
                <updated>Tue, 15 Jan 2008 23:26:37 +0000</updated>
                    <resolved>Tue, 3 Jul 2007 17:55:55 +0100</resolved>
                                            <fixVersion>1.4</fixVersion>
                                <component>jackrabbit-spi</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12489845" author="jukkaz" created="Wed, 18 Apr 2007 19:12:32 +0100"  >In most cases, especially when working with large binaries, the client will not try to read the stream from transient space when storing the binary in the repository. Thus a reasonable SPI implementation would stream (large) binaries to the backend server already during QValueFactory.create(InputStream) and use internal of identifiers to keep track of the values.&lt;br/&gt;
&lt;br/&gt;
Just like with the normal JCR ValueFactory interface, the most reasonable implementation is to consume the entire InputStream when the create() method is called instead of lazily keeping just the reference.</comment>
                    <comment id="12489866" author="reschke" created="Wed, 18 Apr 2007 21:02:26 +0100"  >I&amp;#39;m not sure I understand.&lt;br/&gt;
&lt;br/&gt;
The code implementing QValue has no way to predict who is going to call getStream(), and in which order this will occur. If it doesn&amp;#39;t copy the data upon creation, it will have to when it&amp;#39;s read first. How exactly does that help, except by delaying the issue, and by potentially optimizing the case that getStream() never get&amp;#39;s called?</comment>
                    <comment id="12489870" author="jukkaz" created="Wed, 18 Apr 2007 21:20:09 +0100"  >The most usual (only?) reason for a client to create QValues is when the client wants to store content in the repository. I would argue that in 99% of those cases the created QValue is never read by the client.</comment>
                    <comment id="12489872" author="reschke" created="Wed, 18 Apr 2007 21:23:18 +0100"  >In which case we should change the contract, right? Right now, making the 99% use case work both correctly and efficiently is just harder than it needs to be...&lt;br/&gt;
</comment>
                    <comment id="12489878" author="jukkaz" created="Wed, 18 Apr 2007 21:41:22 +0100"  >I&amp;#39;m not sure I follow you. What kind of an alternative contract do you have in mind?&lt;br/&gt;
&lt;br/&gt;
AFAIUI it never makes sense to have (large) binaries associated directly with the QValue instances. They should always be stored on the server-side and the QValue instance should only hold a reference or identifier to the backend storage. Calling getStream() will request the binary to be streamed from the backend. This solution should cover both reading and writing of values pretty well.</comment>
                    <comment id="12489939" author="anchela" created="Thu, 19 Apr 2007 07:19:54 +0100"  >jukka, maybe i didn&amp;#39;t get your post. from what i understood, i think you are mistaken about the current &lt;br/&gt;
usage of QValue in the SPI:&lt;br/&gt;
they are used both for reading from the SPI impl and upon creation/modification of existing properties.&lt;br/&gt;
&lt;br/&gt;
therefore:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The most usual (only?) reason for a client to create QValues is when the client wants to &lt;br/&gt;
&amp;gt; store content in the repository&lt;br/&gt;
&lt;br/&gt;
is probably not totally correct, isn&amp;#39;t it? i was told recently that almost everything was reading :)&lt;br/&gt;
&lt;br/&gt;
since in contrast to the jackrabbit core QValue objects are always created by a factory and both QValueFactory and QValue itself are interfaces defined by the SPI api,  i would argue that it&amp;#39;s an implementation detail (which might or might not be crucial) if a large binary is stored on the server upon creation or not.</comment>
                    <comment id="12489942" author="jukkaz" created="Thu, 19 Apr 2007 07:37:56 +0100"  >&amp;gt; &amp;gt; The most usual (only?) reason for a client to create QValues is when the client wants to&lt;br/&gt;
&amp;gt; &amp;gt; store content in the repository&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt; is probably not totally correct, isn&amp;#39;t it? i was told recently that almost everything was reading :) &lt;br/&gt;
&lt;br/&gt;
Note the part &amp;quot;for a client&amp;quot;. The SPI implementation obviously creates QValues whenever content is read, but I don&amp;#39;t believe that is a problem in this case.</comment>
                    <comment id="12489966" author="reschke" created="Thu, 19 Apr 2007 09:01:15 +0100"  >Agreed for the case where the client just gets the property from the store.&lt;br/&gt;
&lt;br/&gt;
However, in the &amp;quot;set&amp;quot; case, JCR2SPI currently caches the QValue, and re-uses it. Thus, a test case that first sets a binary property and then reads it fails, unless the QValue preserves the stream contents. This is a problem.&lt;br/&gt;
</comment>
                    <comment id="12489968" author="anchela" created="Thu, 19 Apr 2007 09:26:46 +0100"  >&amp;gt; The current SPI requires QValue to return new streams upon each call to getStream(). &lt;br/&gt;
&lt;br/&gt;
oh i see.... you meant jcr2spi... not spi...&lt;br/&gt;
so, what are the modifications you propose?&lt;br/&gt;
&lt;br/&gt;
kind regards&lt;br/&gt;
angela&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12489978" author="reschke" created="Thu, 19 Apr 2007 10:20:21 +0100"  >I really meant &amp;quot;SPI&amp;quot;: the SPI contract needs to be sufficiently clear, and JCR2SPI has to work against that.&lt;br/&gt;
&lt;br/&gt;
That being said, the problem seems to be that JCR2SPI likes to keep the QValue, thus SPI requires QValue to allow multiple calls to getStream() (requiring new stream instances to be returned). Supporting multiple calls to getStream() is simple for multiple reads, but not for the case where a property is set and then re-read (such as in some of the TCK tests).&lt;br/&gt;
&lt;br/&gt;
One solution to that would be to:&lt;br/&gt;
&lt;br/&gt;
- require getStream() to *either* return a new stream instance, or to throw an IllegalStateException, and&lt;br/&gt;
- modify JCR2SPI to obtain a new QValue if getStream() on the cached value yielded that exception.&lt;br/&gt;
&lt;br/&gt;
That would allow JCR2SPI to keep QValue instances in most cases (read/read), but would make it much simpler to implement the write/read sequence.&lt;br/&gt;
</comment>
                    <comment id="12489979" author="jukkaz" created="Thu, 19 Apr 2007 10:36:14 +0100"  >You&amp;#39;ll need to have the re-read feature somewhere in any case, so why not put it inside the QValue implementation? You don&amp;#39;t need to keep the entire value inside the QValue instance, just enough information that you can retrieve the value when requested.&lt;br/&gt;
&lt;br/&gt;
Leaving the contract as-is allows an implementation for example to decide that it&amp;#39;ll cache small binaries locally but keep large binaries only on the backend server, accessing them only as needed.</comment>
                    <comment id="12489995" author="reschke" created="Thu, 19 Apr 2007 11:28:41 +0100"  >Maybe I&amp;#39;m a bit slow, but I don&amp;#39;t see how to do that.&lt;br/&gt;
&lt;br/&gt;
In the write/read case, the QValue is instantiated without any knowledge where the InputStream finally will be written to (or more precisely: who is going to read it).&lt;br/&gt;
&lt;br/&gt;
In the general case (I don&amp;#39;t know the consumer), I will have to make a copy of every byte read from it, and also have to take into account the case where the consumer actually doesn&amp;#39;t consume the whole stream. In this case, I can preserve the contents of the stream either in memory or on disk.&lt;br/&gt;
&lt;br/&gt;
The write to repository case theoretically can be optimized: the InputStream held by the QValue would be replaced with the information required to get the contents from the backing store later on. However, this assumes that the write operation will succeed. It also doesn&amp;#39;t take care of the case where the binary property in the repository later on gets replaced by a new value, in which case the information in the QValue object would become invalid.&lt;br/&gt;
&lt;br/&gt;
Hint: if you feel the current interface is good enough, please propose a change to SPI2JCR that implements QValue.getStream without making a copy of the contents...&lt;br/&gt;
&lt;br/&gt;
Best regards, Julian&lt;br/&gt;
</comment>
                    <comment id="12509511" author="jukkaz" created="Mon, 2 Jul 2007 09:18:15 +0100"  >Suggested patch</comment>
                    <comment id="12509517" author="jukkaz" created="Mon, 2 Jul 2007 09:45:09 +0100"  >Some background on the patch above. We discussed this issue with Marcel, Angela, and Julian, and it seems like the best way to manage binary streams is to use some sort of a binary handle (a temporary file or a reference to the backend store) instead of the live InputStream reference.</comment>
                    <comment id="12509937" author="anchela" created="Tue, 3 Jul 2007 17:55:55 +0100"  >applied patch with rev. 552909 and modified the QValueTest class accordingly&lt;br/&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12360910" name="QValue.patch" size="1143" author="jukkaz" created="Mon, 2 Jul 2007 09:18:15 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 18 Apr 2007 18:12:32 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142397</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190621</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>