<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:46:05 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-741/JCR-741.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-741] Handling of multiple residual prop defs in EffectiveNodeTypeImpl</title>
                <link>https://issues.apache.org/jira/browse/JCR-741</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeTypeImpl currently rejects multiple residual property definitions, if they do not differ in getMultiple(). In fact, it should accept all combinations, so differing values for getOnParentVersionAction and other aspects should be accepted as well.&lt;br/&gt;
&lt;br/&gt;
See JSR 170, 6.7.8:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;For purposes of the above, the notion of two definitions having the same name does not apply to two residual definitions. Two (or more) residual property or child node definitions with differing subattributes must be permitted to co-exist in the same effective node type. They are interpreted as disjunctive (ORed) options.&amp;quot;</description>
                <environment></environment>
            <key id="12362604">JCR-741</key>
            <summary>Handling of multiple residual prop defs in EffectiveNodeTypeImpl</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="reschke">Julian Reschke</assignee>
                                <reporter username="reschke">Julian Reschke</reporter>
                        <labels>
                    </labels>
                <created>Mon, 12 Feb 2007 16:59:17 +0000</created>
                <updated>Thu, 12 Jul 2007 20:09:44 +0100</updated>
                    <resolved>Mon, 9 Jul 2007 13:51:18 +0100</resolved>
                                                            <component>jackrabbit-spi</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12474224" author="reschke" created="Mon, 19 Feb 2007 16:33:20 +0000"  >Fixing this properly requires several changes.&lt;br/&gt;
&lt;br/&gt;
(1) Do not consider multiple residual prop defs when they differ in their OnParentVersionAction value,&lt;br/&gt;
&lt;br/&gt;
(2) Rewrite the transient layer so that in presence of multiple residuals it will pick the &amp;quot;right&amp;quot; one (such as for Property.getDefinition()).&lt;br/&gt;
&lt;br/&gt;
As (1) is simple and allows my SPI stack to continue to work for now, I&amp;#39;ll fix that right away.&lt;br/&gt;
&lt;br/&gt;
For (2), I&amp;#39;d recommend to change getMatchingPropDef () as below:&lt;br/&gt;
&lt;br/&gt;
- only one method&lt;br/&gt;
- each of the definition&amp;#39;s aspects can be marked as &amp;quot;don&amp;#39;t care&amp;quot; (by changing int-&amp;gt;Integer, boolean-&amp;gt;Boolean and allowing null values here).&lt;br/&gt;
&lt;br/&gt;
Feedback appreciated.&lt;br/&gt;
</comment>
                    <comment id="12475647" author="reschke" created="Sat, 24 Feb 2007 19:54:40 +0000"  >(1) Done earlier.&lt;br/&gt;
&lt;br/&gt;
(2) I just spent more time on this, and the key problem seems to be that JCR2SPI does not use RepositoryService.getPropertyDefinition() at all. Changing WorkspaceItemStateFactory.createPropertyState(...) so that the property definition is always fetched from the repository service fixes the problem, because it avoids having to ask the EffectiveNodeType at all. Now this is probably a problem performance-wise -- wouldn&amp;#39;t it make sense to add getDefinition to ItemInfo on SPI, so the additional roundtrip is not necessary?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12475846" author="mreutegg" created="Mon, 26 Feb 2007 09:04:08 +0000"  >Hmm, this would move the responsibility to pick an item definition to the SPI implementation but at the same time  also increase the complexity of the SPI implementation. ItemInfo can currently be implemented as a simple bean without the need for additional logic. Your suggestion would break this rule, but maybe it&amp;#39;s worth it.&lt;br/&gt;
&lt;br/&gt;
I see two other options:&lt;br/&gt;
&lt;br/&gt;
A) JCR2SPI first tries to resolve the ItemDefinition based on the available node type information. E.g. the property jcr:primaryType is always well defined. If there is more than one matching residual definition present, JCR2SPI asks the repository service for a matching definition.&lt;br/&gt;
&lt;br/&gt;
B) Change methods RepositoryService.get[Node|Property]Definition() in a way that they can be implemented without a need for a server roundtrip and then always use those methods to lookup an ItemDefinition.&lt;br/&gt;
&lt;br/&gt;
Or even better implement both A &amp;amp; B?&lt;br/&gt;
&lt;br/&gt;
Angela, what do you think?</comment>
                    <comment id="12475858" author="reschke" created="Mon, 26 Feb 2007 09:59:05 +0000"  >- I do agree that we should avoid server round trips if the property definition is precisely known ahead of time.&lt;br/&gt;
&lt;br/&gt;
- Not sure how you would do B). Can you be a bit more specific?&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12476110" author="mreutegg" created="Tue, 27 Feb 2007 09:48:44 +0000"  >I was thinking of a method that provides all the required information to resolve the ambiguous definitions. Something along the lines: &amp;#39;hey, you gave me multiple matching property definitions when I wanted to create a property named &amp;#39;foo&amp;#39;, which one should I use?&amp;#39;&lt;br/&gt;
&lt;br/&gt;
RepositoryService.resolvePropertyDefinition(SessionInfo sessionInfo, NodeInfo nodeInfo, QName propertyName, QPropertyDefinition[] definitions)&lt;br/&gt;
&lt;br/&gt;
And similar for node definitions.</comment>
                    <comment id="12476122" author="reschke" created="Tue, 27 Feb 2007 10:17:55 +0000"  >That would work, but why would the SPI implementation would ever need the definitions parameter? For an existing property, an SPI implementation should always precisely know the QPropDef right?&lt;br/&gt;
&lt;br/&gt;
Or is this about requesting the definition of a property *before* it is being created? That would be useful, but again I don&amp;#39;t see what the definitions parameters would do here?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12476578" author="mreutegg" created="Wed, 28 Feb 2007 13:06:31 +0000"  >The definitions are passed to avoid a potential server call-back. The SPI implementation may not have the property definitions at hand when just the node info and the property name is passed.</comment>
                    <comment id="12476925" author="reschke" created="Thu, 1 Mar 2007 13:23:42 +0000"  >Not convinced. If the node type allows multiple property definitions here, obtaining the right one from the store doesn&amp;#39;t seem to be any harder than selecting one of the ones supplied by the caller. But maybe I&amp;#39;m missing something here.&lt;br/&gt;
&lt;br/&gt;
Anyway; if we do that (as proposed in &amp;lt;&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-741#action_12476110&amp;gt;),&quot;&gt;https://issues.apache.org/jira/browse/JCR-741#action_12476110&amp;amp;gt;),&lt;/a&gt; do we still need RepositoryService.getPropertyDefinition? Right now it&amp;#39;s not used by JCR2SPI which makes me a bit nervous :-).&lt;br/&gt;
</comment>
                    <comment id="12477963" author="mreutegg" created="Mon, 5 Mar 2007 10:08:08 +0000"  >&amp;gt; Not convinced. If the node type allows multiple property definitions here, obtaining the right one from the&lt;br/&gt;
&amp;gt; store doesn&amp;#39;t seem to be any harder than selecting one of the ones supplied by the caller.&lt;br/&gt;
&lt;br/&gt;
my point is to possibly avoid a call (by an spi implementation) to the store and give an spi implementation the opportunity to implement the method as an entirely local call. Would this work in your case, or would you still have to ask the store to pick the right definition?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Anyway; if we do that, do we still need RepositoryService.getPropertyDefinition? Right now it&amp;#39;s not used&lt;br/&gt;
&amp;gt; by JCR2SPI which makes me a bit nervous :-).&lt;br/&gt;
&lt;br/&gt;
IMO we should remove the method RepositoryService.getPropertyDefinition() anyway. It does not scale well and in almost all cases it can be infered from the node type definition which property definition applies to a certain property. I think the same also applies to child node definitions (jcr2spi only uses the method to get the node definition for the root node).&lt;br/&gt;
&lt;br/&gt;
Using the node type definition and its item definitions require much lesser calls to the SPI than using getPropertyDefinition() and getNodeDefinition(). So, I think jcr2spi does it the right way, even though it doesn&amp;#39;t use getPropertyDefinition().</comment>
                    <comment id="12478035" author="reschke" created="Mon, 5 Mar 2007 13:31:57 +0000"  >&amp;gt; my point is to possibly avoid a call (by an spi implementation) to the store and give an spi implementation the opportunity to implement the method as an entirely local call. Would this work in your case, or would you still have to ask the store to pick the right definition?&lt;br/&gt;
&lt;br/&gt;
In my case it wouldn&amp;#39;t make a difference; only the store knows the right answer.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; IMO we should remove the method RepositoryService.getPropertyDefinition() anyway. It does not scale well and in almost all cases it can be infered from the node type definition which property definition applies to a certain property. I think the same also applies to child node definitions (jcr2spi only uses the method to get the node definition for the root node).&lt;br/&gt;
&lt;br/&gt;
+1 on removing stuff from the API that isn&amp;#39;t used by JCR2SPI.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Using the node type definition and its item definitions require much lesser calls to the SPI than using getPropertyDefinition() and getNodeDefinition(). So, I think jcr2spi does it the right way, even though it doesn&amp;#39;t use getPropertyDefinition().&lt;br/&gt;
&lt;br/&gt;
Avoiding round-trips is good; we just need to make the special cases work. So what&amp;#39;s the next step? Add resolvePropertyDefinition() as proposed?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12478345" author="mreutegg" created="Tue, 6 Mar 2007 10:33:49 +0000"  >Hmm, if you have to do the call to the store anyway then I propose the following:&lt;br/&gt;
&lt;br/&gt;
- Keep the methods RepositoryService.getPropertyDefinition() and RepositoryService.getNodeDefinition()&lt;br/&gt;
- Resolve the item definitions using the node type information whenever possible.&lt;br/&gt;
- If there is a conflicting situation with multiple residual definitions that match, ask the repository service for the correct one using RepositoryService.getPropertyDefinition() or RepositoryService.getNodeDefinition()&lt;br/&gt;
&lt;br/&gt;
Does that work for you? Is there enough information in the parameters to decide which definition to use? Please also note that those calls will use ids that reference items that do not yet exist.</comment>
                    <comment id="12478423" author="reschke" created="Tue, 6 Mar 2007 14:30:53 +0000"  >I think this will work for me; I&amp;#39;ll try to adapt EffectiveNodeTypeImpl accordingly.&lt;br/&gt;
&lt;br/&gt;
The fact that getPropertyDefinition() and getNodeDefinition() need to work on not-yet existing items probably should be added to the Javadoc, it may not be obvious to everybody...&lt;br/&gt;
</comment>
                    <comment id="12478573" author="reschke" created="Tue, 6 Mar 2007 20:57:39 +0000"  >OK, back to the drawing board.&lt;br/&gt;
&lt;br/&gt;
It seems to me that EffectiveNodeTypeImpl is the wrong place, because it doesn&amp;#39;t have access to the other ingredients, such as service, session, or propertyId.&lt;br/&gt;
&lt;br/&gt;
Revised proposal: add EffectiveNodeType.getApplicablePropertyDefinitions()[], and let the caller (in this case WorkspaceItemStateFactory) sort things out.&lt;br/&gt;
&lt;br/&gt;
Feedback appreciated.&lt;br/&gt;
</comment>
                    <comment id="12478798" author="reschke" created="Wed, 7 Mar 2007 15:31:44 +0000"  >OK, I&amp;#39;ve added the most simple thing that will work for my case in Revision r515598. With this change, WorkspaceItemStateFactory will ask the SPI impl whenever there are multiple property definitions (this may cause an additional request in some edge cases compared to the previous approach).&lt;br/&gt;
</comment>
                    <comment id="12511105" author="reschke" created="Mon, 9 Jul 2007 13:51:18 +0100"  >Closing issue for now; test cases pass for my JCR2SPI based custom implementation.&lt;br/&gt;
</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10020">
                <name>Cloners</name>
                                <outwardlinks description="is cloned as">
                            <issuelink>
            <issuekey id="12373669">JCR-1029</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 26 Feb 2007 09:04:08 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142343</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>252820</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>