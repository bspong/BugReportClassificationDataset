<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:29:00 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1663/JCR-1663.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1663] REFERENCE properties produce duplicate strings in memory</title>
                <link>https://issues.apache.org/jira/browse/JCR-1663</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>When reference property is loaded from PM, Serializer.deserialize(NodeReferences, InputStream) is called, which calls PropertyId.valueOf(String), which in turn calls NameFactoryImpl.create(String) which finally splits a full property name to namespace and local name. Namespace is internalized, but local name is not (comments say that this is done to avoid perm space overfilling).&lt;br/&gt;
So, in the end, a new String instance is created for local name. This leads to considerable memory waste when repository has a lot of nodes with REFERENCE properties.&lt;br/&gt;
It seems that local name part could be internalized here too because in the most repositories it&amp;#39;s not allowed to create properties with arbitrary names, so the danger of perm space exhaust does not seem to be an argument.&lt;br/&gt;
&lt;br/&gt;
As for ways to resolve this, maybe a new NameFactory implementation could be created which would be used for properties only (and, possibly, mainly in the PropertyId.valueOf(String)) which would extend an existing NameFactoryImpl overriding its create(String) method.&lt;br/&gt;
&lt;br/&gt;
What do you think about all this?</description>
                <environment></environment>
            <key id="12399062">JCR-1663</key>
            <summary>REFERENCE properties produce duplicate strings in memory</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="rpuch">Roman Puchkovskiy</reporter>
                        <labels>
                    </labels>
                <created>Thu, 26 Jun 2008 07:07:39 +0100</created>
                <updated>Mon, 8 Dec 2008 11:09:40 +0000</updated>
                    <resolved>Tue, 22 Jul 2008 12:30:48 +0100</resolved>
                                            <fixVersion>1.5</fixVersion>
                                <component>jackrabbit-spi-commons</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>3</watches>
                                                    <comments>
                    <comment id="12608289" author="jukkaz" created="Thu, 26 Jun 2008 07:14:35 +0100"  >Instead of interning the local part of the name but still creating new Name instances I&amp;#39;d rather see the NameFactory maintain a set of flywheel Name instances for commonly used names. Then we perhaps wouldn&amp;#39;t even need to intern the namespace strings!</comment>
                    <comment id="12608329" author="stefan@jira" created="Thu, 26 Jun 2008 09:04:13 +0100"  >at one point we actually did intern the local Name part. we ran into the said perm space issues at some installations, that&amp;#39;s why we only intern the namespace uri. that helped to considerable improve performance (equals() method) and reduce memory footprint.&lt;br/&gt;
&lt;br/&gt;
therefore, -1 for interning local name strings&lt;br/&gt;
&lt;br/&gt;
i agree with jukka that NameFactory maintaining a chache of commonly used names would be a good alternative.&lt;br/&gt;
however, unless there&amp;#39;s a real issue, i&amp;#39;d prefer to stick with interning namespace uri&amp;#39;s.</comment>
                    <comment id="12608457" author="rpuch" created="Thu, 26 Jun 2008 15:44:58 +0100"  >We have a big repository with several tenths of thousands of nodes (which have versions). Each node has 4 reference properties.&lt;br/&gt;
I&amp;#39;m now looking at our application heap snapshot. Its overall size is 400+ mb and almost 200 mb are strings (nearly 1.4 million of them). Most of those strings are in NameImpl instances (more than 1.3 million of instances). And nearly 1.3 million of strings are actually duplicates of 8 different strings which are local names and full names of our 4 reference properties.&lt;br/&gt;
So I think it&amp;#39;s a real issue that needs to be resolved :) Our use case is an example when Jackrabbit uses memory inefficiently.&lt;br/&gt;
&lt;br/&gt;
Jukka&amp;#39;s suggestion looks much better than mine: consider 1.3 million of NameImpl instances in the example.</comment>
                    <comment id="12608556" author="jukkaz" created="Thu, 26 Jun 2008 20:28:56 +0100"  >Do you have a chance of trying out the attached patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1663&quot; title=&quot;REFERENCE properties produce duplicate strings in memory&quot;&gt;&lt;strike&gt;JCR-1663&lt;/strike&gt;&lt;/a&gt;.patch)? It&amp;#39;s a rather simple implementation of the flyweight pattern with the added twist that it uses a fixed-size hash table to avoid blowing up too much memory in the worst case.&lt;br/&gt;
&lt;br/&gt;
The change seems to work fine (i.e. no regressions), but I don&amp;#39;t have a good performance/memory test suite at hand to verify whether this is worth the added complexity.</comment>
                    <comment id="12608658" author="rpuch" created="Fri, 27 Jun 2008 06:26:32 +0100"  >Thanks for the patch, we will try it.&lt;br/&gt;
As a little improvement, can we avoid creation of NameImpl and splitting a full name string at all in cases where the cache is hit? I.e. can we calculate array index using nameString.hashCode() and then compare nameString with name&amp;#39;s toString() result instead of using name.hashCode() and comparing current name with cached name?</comment>
                    <comment id="12608661" author="jukkaz" created="Fri, 27 Jun 2008 06:39:43 +0100"  >Re: improvement. Sure, so far I just did the easiest thing. Also, it could well be that a smart JVM could defer the creation of the new object... or perhaps I&amp;#39;m counting too much on the optimizations.</comment>
                    <comment id="12609160" author="rpuch" created="Mon, 30 Jun 2008 06:58:20 +0100"  >The patch works great, now we have only a little number of NameImpl instances in memory, and number of strings is less too. As for NameImpl instances (and corresponding strings) which are created before checking the cache, it seems that they are garbage-collected early.</comment>
                    <comment id="12611589" author="acarballo" created="Tue, 8 Jul 2008 15:03:24 +0100"  >Jukka,&lt;br/&gt;
&lt;br/&gt;
We have a series of memory tests with our application and would like to test the latest changes to this module. Will it be possible for you to upload the source file for &amp;quot;NameFactoryImpl.java&amp;quot;? We are running the latest build but we are now getting a compile errors (localName &amp;amp; namespaceURI &amp;quot;var. not found&amp;quot;) after the latest changes were incorporated into this module. Thanks.&lt;br/&gt;
&lt;br/&gt;
/Antonio C.&lt;br/&gt;
</comment>
                    <comment id="12611685" author="tmueller" created="Tue, 8 Jul 2008 17:52:21 +0100"  >Hi,&lt;br/&gt;
&lt;br/&gt;
This patch looks good, but there is a flaw. Not a bug, but it might lead to a bug later on when somebody (for whatever reason) changes the code later on. See &lt;a href=&quot;http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-2707.pdf&quot;&gt;http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-2707.pdf&lt;/a&gt;  page 38ff. I don&amp;#39;t want to spoil it in case you like to solve the puzzle yourself... By the way, I can highly recommend the book &amp;quot;Java Puzzlers&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
Something completely different: did you know that % (mod) is slower than &amp;amp; (bitwise and)? Also the following wouldn&amp;#39;t require Math.abs. You _need_ to use a power of 2 size then, but you could document that as follows:&lt;br/&gt;
&lt;br/&gt;
private final static int SIZE_POWER_OF_2 = 1 &amp;lt;&amp;lt; 10;&lt;br/&gt;
private final Name[] names = new Name[SIZE_POWER_OF_2];&lt;br/&gt;
...&lt;br/&gt;
int position = name.hashCode() &amp;amp; (SIZE_POWER_OF_2 - 1);&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
Thomas</comment>
                    <comment id="12612577" author="acarballo" created="Thu, 10 Jul 2008 18:11:11 +0100"  >Hmmm...Looks like everyone is on vacation this week. Oh well. I&amp;#39;d appreciate anybody sending this file to my e-mail (see my profile). We&amp;#39;ve some testing tools that we&amp;#39;d like to run against this patch. Like I said earlier. We applied the patch to the latest trunk and now the build is broken because of this particular source file (&amp;quot;NameFactoryImpl.java&amp;quot;). Thanks.&lt;br/&gt;
</comment>
                    <comment id="12614369" author="acarballo" created="Thu, 17 Jul 2008 15:44:00 +0100"  >Thank you Roman for the java file and comments.&lt;br/&gt;
==&lt;br/&gt;
We ran more tests (2gb, 30,000+ documents, 10 different doc types) over the weekend and concluded that the patch does alleviate this particular memory issue. However, the JCR engine continues to hang on to memory. Eventually it hits the &amp;#39;wall&amp;#39; and slows down the response time. Thanks for the patch.&lt;br/&gt;
</comment>
                    <comment id="12615583" author="jukkaz" created="Tue, 22 Jul 2008 12:30:48 +0100"  >Back form vacation... Thanks for the reviews, tests and suggestions!&lt;br/&gt;
&lt;br/&gt;
I committed an improved version of the proposed solution in revision 678719.&lt;br/&gt;
&lt;br/&gt;
Resolving as fixed.</comment>
                </comments>
                    <attachments>
                    <attachment id="12384783" name="JCR-1663.patch" size="2701" author="jukkaz" created="Thu, 26 Jun 2008 20:28:56 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 26 Jun 2008 06:14:35 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142790</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190205</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>