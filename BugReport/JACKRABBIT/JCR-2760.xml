<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:43:52 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2760/JCR-2760.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2760] Use hash codes instead of sequence numbers for string indexes</title>
                <link>https://issues.apache.org/jira/browse/JCR-2760</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>We use index numbers instead of namespace URIs or other strings in many places. The two-way mapping between namespace URIs and index numbers is by default stored in the repository-global ns_idx.properties file, and the index numbers are allocated using a linear sequence. The problem with this approach is that two repositories will easily end up with different string index mappings, which makes it practically impossible to make low-level copies of workspace content across repositories.&lt;br/&gt;
&lt;br/&gt;
The ultimate solution for this problem would be to store the namespace URIs closer to the stored content, ideally as an implementation detail of a persistence manager.&lt;br/&gt;
&lt;br/&gt;
An easier short-term solution would be to decrease the chances of two repositories having different string index mappings. A simple (and backwards-compatible) way to do this is to use the hash code of a namespace URI as the basis of allocating a new index number. Hash collisions are fairly unlikely, and can be handled by incrementing the intial hash code until the collision is avoided. In the common case of no collisions (with a uniform hash function the chance of a collision is less than 1% even with tousands of registered namespaces) this solution allows workspaces to be copied between repositories without worrying about the namespace index mappings.</description>
                <environment></environment>
            <key id="12475314">JCR-2760</key>
            <summary>Use hash codes instead of sequence numbers for string indexes</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Tue, 28 Sep 2010 17:06:48 +0100</created>
                <updated>Tue, 8 Nov 2011 15:52:07 +0000</updated>
                    <resolved>Tue, 5 Oct 2010 09:37:59 +0100</resolved>
                                            <fixVersion>2.2</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12915804" author="jukkaz" created="Tue, 28 Sep 2010 17:14:54 +0100"  >The attached patch implements the proposed solution.&lt;br/&gt;
&lt;br/&gt;
It turned out that the BundleBinding class uses only 24 bits of the index number, so this implementation does the same when allocating the index numbers.&lt;br/&gt;
&lt;br/&gt;
The solution is fully backwards compatible with existing repositories (existing index numbers are used as-is), and avoids hash collisions by explicitly incrementing the index number until no collision occurs.</comment>
                    <comment id="12916051" author="tmueller" created="Wed, 29 Sep 2010 07:41:15 +0100"  >I&amp;#39;m not sure if this is really a big problem, so this is just FYI: With 24 bit, the probability of collision is higher. With 1024 entries, the probability is about 3%. The 1% Jukka mentioned is correct for 32 bit. The same formula as for UUIDs applies, see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;http://en.wikipedia.org/wiki/Universally_unique_identifier&lt;/a&gt; and &lt;a href=&quot;http://www.h2database.com/html/advanced.html#uuid&quot;&gt;http://www.h2database.com/html/advanced.html#uuid&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
2^5=32 probability: 0.003051711246848665%&lt;br/&gt;
2^6=64 probability: 0.012206286222260498%&lt;br/&gt;
2^7=128 probability: 0.04881620601105974%&lt;br/&gt;
2^8=256 probability: 0.19512188925244756%&lt;br/&gt;
2^9=512 probability: 0.7782061739756485%&lt;br/&gt;
2^10=1024 probability: 3.076676552365587%&lt;br/&gt;
2^11=2048 probability: 11.750309741540455%&lt;br/&gt;
2^12=4096 probability: 39.346934028736655%&lt;br/&gt;
2^13=8192 probability: 86.46647167633873%&lt;br/&gt;
2^14=16384 probability: 99.96645373720975%&lt;br/&gt;
&lt;br/&gt;
double x = Math.pow(2, 24);&lt;br/&gt;
for (int i = 5; i &amp;lt; 15; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double n = Math.pow(2, i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;double p = 1 - Math.exp(-(n * n) / 2 / x);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;2^&amp;quot; + i + &amp;quot;=&amp;quot; + (1L &amp;lt;&amp;lt; i) +&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot; probability: &amp;quot; + (p * 100) + &amp;quot;%&amp;quot;);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12916157" author="mreutegg" created="Wed, 29 Sep 2010 15:10:12 +0100"  >+1&lt;br/&gt;
&lt;br/&gt;
looks good to me.</comment>
                    <comment id="12917899" author="jukkaz" created="Tue, 5 Oct 2010 09:37:59 +0100"  >Patch committed in revision 1004568.&lt;br/&gt;
&lt;br/&gt;
The restriction to 24 bits is an unfortunate side-effect of the way the bundle serialization format chops off the first eight bits from the namespace index of the name of the primary type of a node. As mentioned by Thomas, this has a notable effect on the likelihood of collisions, but that seems OK since this only affects the non-standard use case of copying raw workspace data between repositories and even there the chance of problems is pretty low for reasonably sized repositories.&lt;br/&gt;
&lt;br/&gt;
A more complete solution would be to drop the use of namespace and name indexes in favour of a more efficient serialization format.</comment>
                    <comment id="12917912" author="tmueller" created="Tue, 5 Oct 2010 10:14:31 +0100"  >+1&lt;br/&gt;
&lt;br/&gt;
looks good to me for Jackrabbit 2.x. I think for Jackrabbit 3 we should use a different solution (if we still want to use a name index it shouldn&amp;#39;t be global). But that&amp;#39;s something we can discuss later.&lt;br/&gt;
&lt;br/&gt;
I guess in most cases there are only few namespaces (typically less than 100). For the name index (property names) I&amp;#39;m not sure.</comment>
                    <comment id="12918447" author="yabon" created="Wed, 6 Oct 2010 10:25:25 +0100"  >These changes are interesting for low-level copies of workspace content across repositories but also for clustering because it was possible to have collision between indexes for the same namespace on two nodes. &lt;br/&gt;
&lt;br/&gt;
I agree with Thomas that a different solution should be considered in JR 3  for sharing namespaces (maybe also for nodetypes) especially for cluster nodes (see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1558&quot; title=&quot;Namespace not registered yet prevent BundleDbPersistenceManager to detect already existing root node and leads to workspace initialization failure in a cluster environment&quot;&gt;JCR-1558&lt;/a&gt;).&lt;br/&gt;
</comment>
                </comments>
                    <attachments>
                    <attachment id="12455838" name="0001-JCR-2760-Use-hash-codes-instead-of-sequence-numbers.patch" size="3384" author="jukkaz" created="Tue, 28 Sep 2010 17:14:54 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 29 Sep 2010 06:41:15 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>97844</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>280285</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>