<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:38:14 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-3047/JCR-3047.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-3047] OperandEvaluator should be able to handle Nodes as well, not just Rows</title>
                <link>https://issues.apache.org/jira/browse/JCR-3047</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>OperandEvaluator is used to evaluate Operands values against given Rows, and in an effort to improve the sorting part of SQL2 (&lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2959&quot; title=&quot;SQL2 QueryEngine should use Lucene for sort&quot;&gt;JCR-2959&lt;/a&gt;), I need it to handle plain Nodes as well.&lt;br/&gt;
&lt;br/&gt;
This is a small change, as the OperandEvaluator already extracts the Node info from the Row, so there is no obvious reason no to expose the Node operations directly.</description>
                <environment></environment>
            <key id="12518606">JCR-3047</key>
            <summary>OperandEvaluator should be able to handle Nodes as well, not just Rows</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="5" iconUrl="https://issues.apache.org/jira/images/icons/priorities/trivial.png">Trivial</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="alex.parvulescu">Alex Parvulescu</assignee>
                                <reporter username="alex.parvulescu">Alex Parvulescu</reporter>
                        <labels>
                    </labels>
                <created>Thu, 11 Aug 2011 17:20:45 +0100</created>
                <updated>Thu, 2 May 2013 03:29:43 +0100</updated>
                    <resolved>Tue, 27 Sep 2011 15:51:52 +0100</resolved>
                                            <fixVersion>2.3</fixVersion>
                                <component>jackrabbit-jcr-commons</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="13084066" author="jukkaz" created="Fri, 12 Aug 2011 13:21:53 +0100"  >I had to use Row instead of a Node in the OperantEvaluator class to properly implement the FullTextSearchScore operand. The score is only available through Row.getScore().</comment>
                    <comment id="13084087" author="alex.parvulescu" created="Fri, 12 Aug 2011 14:01:00 +0100"  >Yes, you are right, but then it doesn&amp;#39;t make sense to get the score out of the node. So it will just return the default score.&lt;br/&gt;
&lt;br/&gt;
I got distracted, and forgot to commit :)&lt;br/&gt;
</comment>
                    <comment id="13084093" author="alex.parvulescu" created="Fri, 12 Aug 2011 14:03:08 +0100"  >fixed in revision 1157081</comment>
                    <comment id="13084188" author="jukkaz" created="Fri, 12 Aug 2011 16:27:45 +0100"  >I&amp;#39;m not too much of a fan of duplicating so much of the code in OperandEvaluator.&lt;br/&gt;
&lt;br/&gt;
It would be nice if instead the Node to be used was simply wrapped into a simple row instance with a default full text search score and then passed to the existing code. The attached patch does this by moving the generic Row implementations to -core to -jcr-commons and then using the SelectorRow class in the OperandEvaluator to support also Nodes in addition to Rows.&lt;br/&gt;
&lt;br/&gt;
PS. What&amp;#39;s the use of the getAffectedPropertyName() method? Note that the property under a given Operand also depends on the selector name, so just getting the property name doesn&amp;#39;t tell you much unless you already have more context information for interpreting it (in which case you might already have also the property name).</comment>
                    <comment id="13084199" author="alex.parvulescu" created="Fri, 12 Aug 2011 16:40:16 +0100"  >I&amp;#39;ve seen the option with wrapping a Node in a Row just to use the OperandEvaluator, but then it kinda feels hacky. Everything is there already.&lt;br/&gt;
&lt;br/&gt;
The property name thing will make sense when you take a look at &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2959&quot; title=&quot;SQL2 QueryEngine should use Lucene for sort&quot;&gt;JCR-2959&lt;/a&gt;. I couldn&amp;#39;t find another way of extracting the property that is used by an Operand. But you may be right, this could fail in certain scenarios.&lt;br/&gt;
&lt;br/&gt;
I needed to build a lucene sort mechanism, and all the info you have is the Ordering, which holds an Operand, and a bunch of nodes. As the sort should happen before the Row is actually constructed.&lt;br/&gt;
Ok, there may be better ways of extracting this info, I&amp;#39;ll digg into it</comment>
                    <comment id="13084208" author="alex.parvulescu" created="Fri, 12 Aug 2011 16:51:08 +0100"  >Actually in the context of Orderings, the property thing works ok.&lt;br/&gt;
&lt;br/&gt;
I tested with a prefix (&amp;#39;order by a.[pname]&amp;#39;), and without one (&amp;#39;order by [pname]&amp;#39;) and it seems to be able to identify the property. &lt;br/&gt;
I guess it is a bit confusing that the order info (Ordering) takes an Operand, as I haven&amp;#39;t seen examples to promote such complexity in sql2 queries.</comment>
                    <comment id="13084218" author="jukkaz" created="Fri, 12 Aug 2011 17:06:49 +0100"  >To properly implement the mapping from an Ordering to a Lucene SortField you&amp;#39;d need to consider also other information than just the property name. For example &amp;quot;ORDER BY UPPER(pname)&amp;quot; or &amp;quot;ORDER BY LENGTH(pname)&amp;quot; must be handled differently from &amp;quot;ORDER BY pname&amp;quot;, and an ordering like &amp;quot;ORDER BY b.pname&amp;quot; can&amp;#39;t be used if you&amp;#39;re constructing the Lucene query for selector a. Thus I don&amp;#39;t think an isolated method like getAffectedPropertyName() really serves a useful purpose.</comment>
                    <comment id="13084221" author="alex.parvulescu" created="Fri, 12 Aug 2011 17:16:18 +0100"  >Yes I agree :)&lt;br/&gt;
&lt;br/&gt;
To map Orderings to properties, you can use getAffectedPropertyName, otherwise there is no way of knowing from a list of Orderings which goes where.&lt;br/&gt;
So you can go from (o1, o2) to a map p1 -&amp;gt; o1, p2 -&amp;gt; o2&lt;br/&gt;
&lt;br/&gt;
After having this info, you can create a custom sort field in lucene (one for p1 and another one for p2) that can apply via OperandEvaluator all the above mentioned functions, like v1 = evaluator.getValues(o1.getOperand(), node), then sort on v1, and so on&lt;br/&gt;
&lt;br/&gt;
But this sorting related talk should happen on the other issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2959&quot; title=&quot;SQL2 QueryEngine should use Lucene for sort&quot;&gt;JCR-2959&lt;/a&gt;</comment>
                    <comment id="13084236" author="jukkaz" created="Fri, 12 Aug 2011 17:39:22 +0100"  >The mapping you suggest doesn&amp;#39;t work. Consider &amp;quot;ORDER BY LENGTH(p1), p1&amp;quot; which is supposed to order results first by the length and then by the contents of a property. That&amp;#39;s probably not a very likely scenario, but ideally the implementation should be able to handle also cases like that.&lt;br/&gt;
&lt;br/&gt;
More generally, you&amp;#39;ll lose any performance benefits as soon as the custom Lucene sort field tries to access the full node instance. More about this in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2959&quot; title=&quot;SQL2 QueryEngine should use Lucene for sort&quot;&gt;JCR-2959&lt;/a&gt;.</comment>
                    <comment id="13084246" author="alex.parvulescu" created="Fri, 12 Aug 2011 17:55:20 +0100"  >you are right!&lt;br/&gt;
&lt;br/&gt;
so, here goes my quick fix: you remove getAffectedPropertyName, and use operand.toString as a lucene field name.&lt;br/&gt;
In your example that would be: LENGTH(nt:base.p1)&lt;br/&gt;
&lt;br/&gt;
By using this custom name, you then define a custom lucene index on this field, where you can safely use evaluator.getValues(o1.getOperand(), node), which will work.&lt;br/&gt;
&lt;br/&gt;
This way we can get rid of that persky getAffectedPropertyName, and use a more reliable source, the operand itself.</comment>
                    <comment id="13084288" author="alex.parvulescu" created="Fri, 12 Aug 2011 19:10:55 +0100"  >I removed the &amp;#39;getAffectedPropertyName&amp;#39; method in revision #1157200</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10001">
                <name>dependent</name>
                                                <inwardlinks description="is depended upon by">
                            <issuelink>
            <issuekey id="12506172">JCR-2959</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12490256" name="0001-JCR-3047-OperandEvaluator-should-be-able-to-handle-N.patch" size="77450" author="jukkaz" created="Fri, 12 Aug 2011 16:27:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Fri, 12 Aug 2011 12:21:53 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>19378</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>250250</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>