<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:34:05 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-160/JCR-160.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-160] Query index not in sync with workspace</title>
                <link>https://issues.apache.org/jira/browse/JCR-160</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>After some time the search index is not in sync anymore with the data in the workspace and returns uuids which have no corresponding Node in the workspace. This results in a NodeIterator which throws an ItemNotFoundException on nextNode().&lt;br/&gt;
&lt;br/&gt;
Instructions how to reproduce this error are not yet available.&lt;br/&gt;
&lt;br/&gt;
Possible areas for further investigation are:&lt;br/&gt;
- NodeType registry which maps the node types into the workspace with the use of virtual item states&lt;br/&gt;
- versioning?&lt;br/&gt;
- atomicity of indexing?</description>
                <environment></environment>
            <key id="12311969">JCR-160</key>
            <summary>Query index not in sync with workspace</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mreutegg">Marcel Reutegger</assignee>
                                <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Tue, 5 Jul 2005 20:54:34 +0100</created>
                <updated>Tue, 9 Aug 2005 18:08:16 +0100</updated>
                    <resolved>Tue, 9 Aug 2005 18:08:03 +0100</resolved>
                                            <fixVersion>1.0</fixVersion>
                                <component>query</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>1</watches>
                                                    <comments>
                    <comment id="12315295" author="mreutegg" created="Fri, 8 Jul 2005 21:52:26 +0100"  >Fixing issue &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-164&quot; title=&quot;SharedItemStateManager not properly synchronized&quot;&gt;&lt;strike&gt;JCR-164&lt;/strike&gt;&lt;/a&gt; should also improve stability of the search index, because it depends on a atomic commit of data in SharedItemStateManager.store().&lt;br/&gt;
&lt;br/&gt;
Also improved NodeIterator implementation for QueryResults. The next Node instance is now fetched ahead together with the hasNext() call. Thus it should not happen again, that after hasNext() returned true, a call to nextNode() will throw a NoSuchElementException. The Node that is returned may still be invalid (because it has been deleted by another session) and throw an InvalidItemStateException when reading its state. But that may happen to any Node instance obtained.&lt;br/&gt;
&lt;br/&gt;
Committed at svn revision: 209739</comment>
                    <comment id="12315483" author="fgiust" created="Mon, 11 Jul 2005 23:26:58 +0100"  >I got this error once more with revision &amp;lt; 209739:&lt;br/&gt;
the search index became corrupted after an OutOfMemoryError (note that no write operations were in place when the out of memory occurred, only read). I can&amp;#39;t see any particular stacktrace involving the lucene indexer in the out of memory log.&lt;br/&gt;
&lt;br/&gt;
Anyway, after restarting the application a write lock on the search index was set and an uncommitted redo log was present:&lt;br/&gt;
&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.PersistentIndex 11.07.2005 14:13:02 -- Removing write lock on search index.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.MultiIndex 11.07.2005 14:13:02 -- Found uncommitted redo log. Applying changes now...&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.MultiIndex 11.07.2005 14:23:23 -- Redo changes applied.&lt;br/&gt;
&lt;br/&gt;
after this, the search index is definitively out of sync and it need to be deleted...&lt;br/&gt;
</comment>
                    <comment id="12315546" author="fgiust" created="Tue, 12 Jul 2005 19:51:25 +0100"  >Updated stacktrace with latest svn revision (after the changes in rev. 209739).&lt;br/&gt;
Now the exception is thrown directly in the hasNext() method. Note that the exception occours also while trying to fetch valid nodes, since it&amp;#39;s always thrown while trying to sort nodes in document order.&lt;br/&gt;
&lt;br/&gt;
ERROR  org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl DocOrderNodeIteratorImpl.java(compare:186) 11.07.2005 22:06:44  Exception while sorting nodes in document order: javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemManager.createItemInstance(ItemManager.java:523)&lt;br/&gt;
	at org.apache.jackrabbit.core.ItemManager.getItem(ItemManager.java:374)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl$1.compare(DocOrderNodeIteratorImpl.java:142)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1284)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1296)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1296)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1295)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1296)&lt;br/&gt;
	at java.util.Arrays.mergeSort(Arrays.java:1296)&lt;br/&gt;
	at java.util.Arrays.sort(Arrays.java:1223)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl.initOrderedIterator(DocOrderNodeIteratorImpl.java:136)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl.hasNext(DocOrderNodeIteratorImpl.java:95)</comment>
                    <comment id="12315557" author="mreutegg" created="Tue, 12 Jul 2005 22:01:17 +0100"  >Thanks for the update on the stacktrace, but it does not seem to match the current svn revision.&lt;br/&gt;
&lt;br/&gt;
Are you sure you were using the latest compiled version of the DocOrderNodeIteratorImpl class?&lt;br/&gt;
&lt;br/&gt;
Any chance that you can provide the node type of that node by looking up the lucene document in the index?&lt;br/&gt;
&lt;br/&gt;
Thanks a lot for your help.</comment>
                    <comment id="12315599" author="fgiust" created="Wed, 13 Jul 2005 01:55:51 +0100"  >Updated jackrabbit to rev. 215946.&lt;br/&gt;
With the same currupted index I don&amp;#39;t get any error anymore, only a warning log for the missing nodes:&lt;br/&gt;
&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:45:11 -- Node e6c5b588-50a5-4148-afbd-f7ff95104d36 does not exist anymore: javax.jcr.ItemNotFoundException: e6c5b588-50a5-4148-afbd-f7ff95104d36&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:45:12 -- Node b14139fb-01ab-492d-a465-e183cb43b484 does not exist anymore: javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:45:12 -- Node 7bb7855c-8317-40fd-b3b8-2cc27bb555db does not exist anymore: javax.jcr.ItemNotFoundException: 7bb7855c-8317-40fd-b3b8-2cc27bb555db&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:45:54 -- Node b14139fb-01ab-492d-a465-e183cb43b484 does not exist anymore: javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:46:06 -- Node e6c5b588-50a5-4148-afbd-f7ff95104d36 does not exist anymore: javax.jcr.ItemNotFoundException: e6c5b588-50a5-4148-afbd-f7ff95104d36&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:46:06 -- Node b14139fb-01ab-492d-a465-e183cb43b484 does not exist anymore: javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:46:06 -- Node 7bb7855c-8317-40fd-b3b8-2cc27bb555db does not exist anymore: javax.jcr.ItemNotFoundException: 7bb7855c-8317-40fd-b3b8-2cc27bb555db&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:46:58 -- Node f3b725ae-bab7-438b-9576-abb1cf65ffeb does not exist anymore: javax.jcr.ItemNotFoundException: f3b725ae-bab7-438b-9576-abb1cf65ffeb&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:46:58 -- Node 5852da20-2adb-4a20-8856-bd2d29023e9d does not exist anymore: javax.jcr.ItemNotFoundException: 5852da20-2adb-4a20-8856-bd2d29023e9d&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node c0853856-766d-46ed-b40d-4a781a2c798a does not exist anymore: javax.jcr.ItemNotFoundException: c0853856-766d-46ed-b40d-4a781a2c798a&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 7bb7855c-8317-40fd-b3b8-2cc27bb555db does not exist anymore: javax.jcr.ItemNotFoundException: 7bb7855c-8317-40fd-b3b8-2cc27bb555db&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 96e901e6-68e3-4807-8eb5-14cadb732ec9 does not exist anymore: javax.jcr.ItemNotFoundException: 96e901e6-68e3-4807-8eb5-14cadb732ec9&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 26f9fdd6-1aba-43c9-99d7-8ceef89cfcbf does not exist anymore: javax.jcr.ItemNotFoundException: 26f9fdd6-1aba-43c9-99d7-8ceef89cfcbf&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 0bbbd9de-cd5e-48b1-95b3-8e1f51ddb199 does not exist anymore: javax.jcr.ItemNotFoundException: 0bbbd9de-cd5e-48b1-95b3-8e1f51ddb199&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 436c5b31-bfcb-4e91-8d92-b8763ced742c does not exist anymore: javax.jcr.ItemNotFoundException: 436c5b31-bfcb-4e91-8d92-b8763ced742c&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 8572edac-0783-4a1d-a1b7-41431ffcf999 does not exist anymore: javax.jcr.ItemNotFoundException: 8572edac-0783-4a1d-a1b7-41431ffcf999&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node cca4774f-18a7-4f3b-ba9f-2207af630a45 does not exist anymore: javax.jcr.ItemNotFoundException: cca4774f-18a7-4f3b-ba9f-2207af630a45&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node 90f036dc-83fc-448e-a467-3c608b23976f does not exist anymore: javax.jcr.ItemNotFoundException: 90f036dc-83fc-448e-a467-3c608b23976f&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node b14139fb-01ab-492d-a465-e183cb43b484 does not exist anymore: javax.jcr.ItemNotFoundException: b14139fb-01ab-492d-a465-e183cb43b484&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.DocOrderNodeIteratorImpl 12.07.2005 17:47:02 -- Node c244633b-ff6c-43ef-843d-cd343b29ff61 does not exist anymore: javax.jcr.ItemNotFoundException: c244633b-ff6c-43ef-843d-cd343b29ff61&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
A lot better now, the latest enhancement could be removing any invalid node found during the search... since the index can be easily corrupted by a forced shutdown or an OutOfMemoryError I think there is no way to be totally sure that this will never happen: a &amp;quot;self-reparing&amp;quot; index could probably be the better solution.&lt;br/&gt;
&lt;br/&gt;
Thanks, good work!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12315695" author="mreutegg" created="Wed, 13 Jul 2005 17:37:51 +0100"  >I&amp;#39;m currently working on integrity check which is executed on startup if the index detects a prior forced shutdown. Removing nodes from the index on the fly would be harmful to the design of the query handler. The query result shouldn&amp;#39;t have to know about the actual index.</comment>
                    <comment id="12315710" author="mreutegg" created="Wed, 13 Jul 2005 21:41:52 +0100"  >Improved query handler:&lt;br/&gt;
&lt;br/&gt;
- A possible commit.lock is now also removed on startup. Previously only a write.lock was removed.&lt;br/&gt;
- An integrity check is run if the search index detects a commit or write lock on startup. This check removes nodes from the index that are not available anymore through the ItemStateManager.&lt;br/&gt;
- Applying the redo log on startup is now more failsafe.&lt;br/&gt;
&lt;br/&gt;
svn revision: 216142</comment>
                    <comment id="12316031" author="mreutegg" created="Mon, 18 Jul 2005 22:22:29 +0100"  >Extended consistency check to also include:&lt;br/&gt;
- Missing ancestor&lt;br/&gt;
- Unknown parent&lt;br/&gt;
- Nodes indexed more than once&lt;br/&gt;
&lt;br/&gt;
Per default a consistency check is performced when the search index detects a prior forced shutdown. The search index can also be configured to perform a consistency check on each startup. Inconsistencies are repaired per default. The search index can also be configured to just report those errors to the log.&lt;br/&gt;
&lt;br/&gt;
svn revision: 219477</comment>
                    <comment id="12316453" author="fgiust" created="Fri, 22 Jul 2005 18:36:00 +0100"  >An interesting stacktrace coming from the consistency checker: this is coming from a development environment where the tomcat instance has been killed.&lt;br/&gt;
The repository can&amp;#39;t be started anymore due to an error caught in the ConsistencyCheck$MissingAncestor.repair&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.MultiIndex MultiIndex.java(&amp;lt;init&amp;gt;:178) 22.07.2005 10:22:21  Found uncommitted redo log. Applying changes now...&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.MultiIndex MultiIndex.java(&amp;lt;init&amp;gt;:195) 22.07.2005 10:22:23  Redo changes applied.&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.CachingIndexReader CachingIndexReader.java(cacheInit:212) 22.07.2005 10:22:23  Duplicate index entry for node: 93625c1b-1cc7-4be7-9ee4-8cf932af57eb&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.CachingIndexReader CachingIndexReader.java(cacheInit:212) 22.07.2005 10:22:23  Duplicate index entry for node: 548eda92-f29f-4031-b277-a077c01a0d00&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.CachingIndexReader CachingIndexReader.java(cacheInit:212) 22.07.2005 10:22:23  Duplicate index entry for node: 2c49ecbd-9263-42a4-9f71-20c7a128d38e&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.CachingIndexReader CachingIndexReader.java(cacheInit:212) 22.07.2005 10:22:23  Duplicate index entry for node: f95273a5-c7e5-46f8-b3c4-3e2cb8c06979&lt;br/&gt;
WARN   org.apache.jackrabbit.core.query.lucene.CachingIndexReader CachingIndexReader.java(cacheInit:212) 22.07.2005 10:22:23  Duplicate index entry for node: afa51196-d9af-4160-8dfe-ea3f5e6b893b&lt;br/&gt;
ERROR  org.apache.jackrabbit.core.RepositoryImpl RepositoryImpl.java(&amp;lt;init&amp;gt;:208) 22.07.2005 10:22:23  Unable to start repository. forcing shutdown.&lt;br/&gt;
ERROR  RepositoryNotInitializedException: uuid can not be null: uuid can not be null: uuid can not be null: uuid can not be null: uuid can not be null&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3669)&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4104)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardHost.start(StandardHost.java:718)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442)&lt;br/&gt;
	at org.apache.catalina.core.StandardService.start(StandardService.java:450)&lt;br/&gt;
	at org.apache.catalina.core.StandardServer.start(StandardServer.java:683)&lt;br/&gt;
	at org.apache.catalina.startup.Catalina.start(Catalina.java:537)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:585)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:271)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:409)&lt;br/&gt;
Caused by: javax.jcr.RepositoryException: uuid can not be null: uuid can not be null: uuid can not be null&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.&amp;lt;init&amp;gt;(SearchManager.java:125)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1141)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.getSearchManager(RepositoryImpl.java:550)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:412)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.&amp;lt;init&amp;gt;(RepositoryImpl.java:204)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:358)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.init(BindableRepository.java:116)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.create(BindableRepository.java:104)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.RegistryHelper.registerRepository(RegistryHelper.java:57)&lt;br/&gt;
	... 21 more&lt;br/&gt;
Caused by: java.lang.IllegalArgumentException: uuid can not be null&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeId.&amp;lt;init&amp;gt;(NodeId.java:37)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck$MissingAncestor.repair(ConsistencyCheck.java:259)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck.repair(ConsistencyCheck.java:117)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:140)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:39)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.&amp;lt;init&amp;gt;(SearchManager.java:123)&lt;br/&gt;
	... 30 more&lt;br/&gt;
javax.jcr.RepositoryException: uuid can not be null: uuid can not be null: uuid can not be null&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.&amp;lt;init&amp;gt;(SearchManager.java:125)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1141)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.getSearchManager(RepositoryImpl.java:550)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:412)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.&amp;lt;init&amp;gt;(RepositoryImpl.java:204)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:358)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.init(BindableRepository.java:116)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.create(BindableRepository.java:104)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.RegistryHelper.registerRepository(RegistryHelper.java:57)&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3669)&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4104)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardHost.start(StandardHost.java:718)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442)&lt;br/&gt;
	at org.apache.catalina.core.StandardService.start(StandardService.java:450)&lt;br/&gt;
	at org.apache.catalina.core.StandardServer.start(StandardServer.java:683)&lt;br/&gt;
	at org.apache.catalina.startup.Catalina.start(Catalina.java:537)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:585)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:271)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:409)&lt;br/&gt;
Caused by: java.lang.IllegalArgumentException: uuid can not be null&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeId.&amp;lt;init&amp;gt;(NodeId.java:37)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck$MissingAncestor.repair(ConsistencyCheck.java:259)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck.repair(ConsistencyCheck.java:117)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:140)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:39)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.&amp;lt;init&amp;gt;(SearchManager.java:123)&lt;br/&gt;
	... 30 more&lt;br/&gt;
java.lang.IllegalArgumentException: uuid can not be null&lt;br/&gt;
	at org.apache.jackrabbit.core.NodeId.&amp;lt;init&amp;gt;(NodeId.java:37)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck$MissingAncestor.repair(ConsistencyCheck.java:259)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.ConsistencyCheck.repair(ConsistencyCheck.java:117)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:140)&lt;br/&gt;
	at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:39)&lt;br/&gt;
	at org.apache.jackrabbit.core.SearchManager.&amp;lt;init&amp;gt;(SearchManager.java:123)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl$WorkspaceInfo.getSearchManager(RepositoryImpl.java:1141)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.getSearchManager(RepositoryImpl.java:550)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.initWorkspace(RepositoryImpl.java:412)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.&amp;lt;init&amp;gt;(RepositoryImpl.java:204)&lt;br/&gt;
	at org.apache.jackrabbit.core.RepositoryImpl.create(RepositoryImpl.java:358)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.init(BindableRepository.java:116)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.BindableRepository.create(BindableRepository.java:104)&lt;br/&gt;
	at org.apache.jackrabbit.core.jndi.RegistryHelper.registerRepository(RegistryHelper.java:57)&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3669)&lt;br/&gt;
	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4104)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardHost.start(StandardHost.java:718)&lt;br/&gt;
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012)&lt;br/&gt;
	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442)&lt;br/&gt;
	at org.apache.catalina.core.StandardService.start(StandardService.java:450)&lt;br/&gt;
	at org.apache.catalina.core.StandardServer.start(StandardServer.java:683)&lt;br/&gt;
	at org.apache.catalina.startup.Catalina.start(Catalina.java:537)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:585)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:271)&lt;br/&gt;
	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:409)</comment>
                    <comment id="12316455" author="mreutegg" created="Fri, 22 Jul 2005 19:27:36 +0100"  >Thanks for reporting this issue. The problem was, that the repair did not stop when it encountered the root node :-/&lt;br/&gt;
&lt;br/&gt;
Fixed in svn revision: 220279</comment>
                    <comment id="12318123" author="mreutegg" created="Tue, 9 Aug 2005 18:08:03 +0100"  >After depending issues &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-168&quot; title=&quot;Observation events are not triggered for intermediate nodes in version storage&quot;&gt;&lt;strike&gt;JCR-168&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-170&quot; title=&quot;VirtualItemStates of node types definitions not accessible with uuid&quot;&gt;&lt;strike&gt;JCR-170&lt;/strike&gt;&lt;/a&gt; have been fixed, I&amp;#39;m now quite confident that this issue can be resolved.&lt;br/&gt;
&lt;br/&gt;
If there should arise new inconsistent situations with the search index, a new issue should be created.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                                <inwardlinks description="is blocked by">
                            <issuelink>
            <issuekey id="12312271">JCR-168</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12312308">JCR-170</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                    </issuelinks>
                <attachments>
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>0.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Mon, 11 Jul 2005 22:26:58 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>141975</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>191070</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>