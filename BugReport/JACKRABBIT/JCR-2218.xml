<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:39:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2218/JCR-2218.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2218] NodeEntryImpl.getWorkspaceId() very inefficient </title>
                <link>https://issues.apache.org/jira/browse/JCR-2218</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>NodeEntryImpl.getWorkspaceId() calculates its path on each call by calling itself recursively. Further each call to getWorkspaceId() results in various calls to the path and item factories which might be somewhat expensive by themselves. &lt;br/&gt;
&lt;br/&gt;
In my test scenario I have a RepositoryService.getItemInfos() call returning ~1000 items. Processing these items results in about 2700000 (!) calls to getWorkspaceId(). Profiler data shows, that 98% of the time to process the 1000 items is spent in getWorkspaceId()  and related calls. </description>
                <environment></environment>
            <key id="12430668">JCR-2218</key>
            <summary>NodeEntryImpl.getWorkspaceId() very inefficient </summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="mduerig">Michael D&#252;rig</assignee>
                                <reporter username="mduerig">Michael D&#252;rig</reporter>
                        <labels>
                    </labels>
                <created>Thu, 16 Jul 2009 15:00:22 +0100</created>
                <updated>Tue, 18 Aug 2009 16:02:17 +0100</updated>
                    <resolved>Tue, 11 Aug 2009 16:32:31 +0100</resolved>
                                            <fixVersion>2.0-alpha8</fixVersion>
                                <component>jackrabbit-jcr2spi</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12731953" author="mduerig" created="Thu, 16 Jul 2009 15:13:59 +0100"  >To fix this I propose to cache the NodeId and/or path per NodeEntry. On certain operations (like move, further operation to be identified) the cache needs to be invalidated. To avoid having to invalidate the cache of each entry in the sub tree rooted at a specific item, I propose that cache validity checks are deferred as much as possible (i.e. until getWorkspaceId() is called). The cache for an entry is valid, if neither of its parents nor itself are marked as invalid . If the cache for an entry is determined to be invalid, its path is recalculated thereby clearing any invalid cache marker on the path to the root. Note that when a marker of an entry is cleared, all child entries of that entry need to be marked (with the exception of the child entry which path is being recalculated). </comment>
                    <comment id="12735039" author="mduerig" created="Fri, 24 Jul 2009 13:13:07 +0100"  >I just checked the effect of an alternative approach: call site caching of IdFactory calls. &lt;br/&gt;
&lt;br/&gt;
public NodeId getId() throws InvalidItemStateException, RepositoryException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IdFactory idFactory = getIdFactory();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PathFactory pathFactory = getPathFactory();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IdCache idCache = getIdCache();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (uniqueID != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId = idCache.get(uniqueID);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (nodeId == null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nodeId = idFactory.createNodeId(uniqueID);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;idCache.put(uniqueID, nodeId);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return nodeId;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else if (parent == null) { // root&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId = idCache.get(&amp;quot;ROOT&amp;quot;);  &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (nodeId == null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nodeId = idFactory.createNodeId((String) null, pathFactory.getRootPath());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;idCache.put(&amp;quot;ROOT&amp;quot;, nodeId);  &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return nodeId;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId parentId = parent.getId();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Name name = getName();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int index = getIndex();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NodeId nodeId = idCache.get(parentId, name, index);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (nodeId == null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Path path = pathFactory.create(name, index);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nodeId = idFactory.createNodeId(parentId, path);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;idCache.put(parentId, name, index, nodeId);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return nodeId;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
My profiling shows, that there is nothing much to be gained from this. This is in line with an earlier observation, that looking up ItemIds from a hash map comes with about the same cost as creating new itemIds. The main contribution coming from the equals and hashCode methods from the various classes involved when comparing ItemIds. &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12739985" author="mduerig" created="Thu, 6 Aug 2009 11:49:26 +0100"  >Another alternative approach (due to Angela): Instead of constructing the ids from the parent  id and the name (which is quite expensive), traverse up to either root or a uuid and collect the respective path elements. The use the root or the uuid respectively and the collected path elements to construct the id.</comment>
                    <comment id="12739988" author="mduerig" created="Thu, 6 Aug 2009 11:55:11 +0100"  >Proposed patch implementing the approach from my last comment. While this shouldn&amp;#39;t have any negative performance impact on flat hierarchies, it shows an overall (*) performance gain up to 20% on deep hierarchies. &lt;br/&gt;
&lt;br/&gt;
(*) Session.getItem() on a deep hierarchy. </comment>
                    <comment id="12741914" author="mduerig" created="Tue, 11 Aug 2009 16:32:31 +0100"  >Applied path in revision 803164</comment>
                </comments>
                    <attachments>
                    <attachment id="12415726" name="JCR-2218.patch" size="3409" author="mduerig" created="Thu, 6 Aug 2009 11:55:11 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>1.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>143065</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>192213</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>