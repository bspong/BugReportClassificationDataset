<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:37:33 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-890/JCR-890.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-890] concurrent read-only access to a session</title>
                <link>https://issues.apache.org/jira/browse/JCR-890</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Even though the JCR specification does not make a statement about Sessions shared across a number of threads I think it would be great for many applications if we could state that sharing a read-only session is supported by Jackrabbit.&lt;br/&gt;
On many occasions in the mailing lists we stated that there should not be an issue with sharing a read-only session, however I think it has never been thoroughly tested or even specified as a &amp;quot;design goal&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
If we can come to an agreement that this is desirable I think it would be great to start including testcases to validate that behaviour and update the documentation respectively.</description>
                <environment></environment>
            <key id="12368122">JCR-890</key>
            <summary>concurrent read-only access to a session</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="uncled">David Nuescheler</reporter>
                        <labels>
                    </labels>
                <created>Thu, 26 Apr 2007 13:28:13 +0100</created>
                <updated>Tue, 8 Nov 2011 15:52:11 +0000</updated>
                    <resolved>Tue, 10 Aug 2010 12:54:18 +0100</resolved>
                                            <fixVersion>2.2</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>1</votes>
                        <watches>3</watches>
                                                    <comments>
                    <comment id="12496251" author="mreutegg" created="Wed, 16 May 2007 11:49:25 +0100"  >I agree that this &amp;#39;feature&amp;#39; is desirable however I would rather implement sharing read only session in a decoration layer or some sort of proxy on top of the JCR repository. We already have enough synchronization statements in the code and introducing even more will slow down clients that are not interested to share a session, e.g. a client that writes to a session would also be heavily synchronized, which is unnecessary in this case.&lt;br/&gt;
&lt;br/&gt;
I think we should choose a similar approach like the collections framework in java. All collection implementations are not thread-safe (except the very old ones from java 1.0 and 1.1), but there are wrapper classes that make them thread-safe if the client wishes so.&lt;br/&gt;
&lt;br/&gt;
This approach also has the advantage that the wrapper/decorator/proxy can throw an exception if a client still tries to call a method that writes to the repository. If we build the thread-safeness into the jackrabbit core we don&amp;#39;t have this control and clients could still write to a session that is shared.&lt;br/&gt;
&lt;br/&gt;
I therefore propose the following:&lt;br/&gt;
&lt;br/&gt;
- remove all synchronization in the core that is meant to support concurrent read access to a session&lt;br/&gt;
- create a read only decorator that synchronizes access to session&lt;br/&gt;
&lt;br/&gt;
someting along the lines:&lt;br/&gt;
&lt;br/&gt;
Session session = Util.synchronizedSession(session);&lt;br/&gt;
// use session from multiple threads</comment>
                    <comment id="12524065" author="mreutegg" created="Fri, 31 Aug 2007 13:32:26 +0100"  >I hereby withdraw my proposal and state another one:&lt;br/&gt;
&lt;br/&gt;
Move all synchronization in Jackrabbit that deals with concurrent read to the classes that implement the JCR API. In other words, make Jackrabbit entirely thread-safe for a client using the API. This includes all interfaces and not just the Repository.&lt;br/&gt;
&lt;br/&gt;
Why did I change my mind? With a wrapper approach a client may (by mistake) still use Jackrabbit &amp;#39;directly&amp;#39; and then use a single session instance from concurrent threads. So far we just say: well,  that&amp;#39;s not supported, so it&amp;#39;s your fault. If JCR is supposed to be infrastructure than an implementation should be robust and must not break just because some code does not behave as it should.&lt;br/&gt;
&lt;br/&gt;
I even think the performance will be better compared to the current jackrabbit-core because we currently have many low level data structures that need to be synchronized. If we decide to synchronize on a coarser grained level like the API we can get rid of those low level synchronizations and as a result there will be less synchronized blocks that are entered.</comment>
                    <comment id="12524070" author="tmueller" created="Fri, 31 Aug 2007 13:39:49 +0100"  >+1&lt;br/&gt;
&lt;br/&gt;
Robustness is very important in my view. Even if it has an effect on performance (I think it does not, but we could measure it).</comment>
                    <comment id="12524073" author="tmueller" created="Fri, 31 Aug 2007 13:43:41 +0100"  >Write access within the same session should also be synchronized.&lt;br/&gt;
But read access is more important.</comment>
                    <comment id="12524130" author="jukkaz" created="Fri, 31 Aug 2007 17:20:44 +0100"  >So you&amp;#39;d have something like this on all non-trivial API methods:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/** The session this object is associated with */&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private final Session session;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void someMethod() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (session) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// do something&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
I like the idea.</comment>
                    <comment id="12524166" author="hannonpi" created="Fri, 31 Aug 2007 20:06:38 +0100"  >I think this is similar to the discussion from &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1050&quot; title=&quot;Remove synchronization from JNDI data sources&quot;&gt;&lt;strike&gt;JCR-1050&lt;/strike&gt;&lt;/a&gt;. Perhaps we need a larger effort to look at synchronization within the lower levels of Jackrabbit?</comment>
                    <comment id="12524261" author="tmueller" created="Sat, 1 Sep 2007 09:48:05 +0100"  >In a many cases, parameters can be processed outside the synchronized block. Also, I would catch throwables and convert them to RepositoryExceptions, or at least log them:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void someMethod(parameters) throws RepositoryException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log(...)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prepare parameters&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (session) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// do something&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Throwable e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw logAndConvert(e);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;gt; effort to look at synchronization within the lower levels of Jackrabbit?&lt;br/&gt;
&lt;br/&gt;
Why not. In my view testing with specific use cases / benchmarks helps a lot to find improvements.&lt;br/&gt;
&lt;br/&gt;
Thomas</comment>
                    <comment id="12858893" author="jukkaz" created="Tue, 20 Apr 2010 15:10:43 +0100"  >I&amp;#39;ll see what I can do about this in the Jackrabbit 2.2 timescale.&lt;br/&gt;
&lt;br/&gt;
Instead of synchronizing things on the SessionImpl instance, I&amp;#39;m thinking of adding a lower-level SessionState class that encapsulates all per-session state that needs to be guarded from concurrent access.</comment>
                    <comment id="12868258" author="jukkaz" created="Mon, 17 May 2010 16:53:47 +0100"  >As a first step to implementing this, I&amp;#39;d like to make the following moves of session-related classes form o.a.j.core to a new o.a.j.core.session package. As discussed on dev@, the rationale for this change is to be able to better manage the code paths to and from the internal state of each session.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cd jackrabbit-trunk/src/main/java/org/apache/jackrabbit/core&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn mkdir session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move AbstractNodeData.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move BatchedItemOperations.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ItemData.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ItemImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ItemLifeCycleListener.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ItemManager.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ItemValidator.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move LazyItemIterator.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move NodeData.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move NodeDataRef.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move NodeImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move PropertyData.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move PropertyImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move ProtectedItemModifier.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move SessionImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move SessionListener.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move SystemSession.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move VersionManagerImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move WorkspaceImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move XASessionImpl.java session&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;svn move XAWorkspace.java session&lt;br/&gt;
&lt;br/&gt;
The attached patch (session-class-move.patch) contains all the import statement changes and other minor refactorings required to make the trunk compile and pass all tests after the above moves.&lt;br/&gt;
&lt;br/&gt;
Note that the patch includes dummy child classes in org.apache.jackrabbit.core for the JCR implementation classes ItemImpl, NodeImpl, PropertyImpl, SessionImpl, VersionManagerImpl and WorkspaceImpl. These classes simply inherit the similarly named classes that were moved to o.a.j.core.session. The purpose of these classes is to maintain compatibility with client code that casts JCR objects to Jackrabbit implementation classes. Later on it may be a good idea to turn these classes into facades that access the underlying functionality in o.a.j.core.session after taking care of trivial operations like name/path parsing, etc.&lt;br/&gt;
&lt;br/&gt;
This step is a purely structural refactoring, it does not introduce any functional changes in the code. All code outside o.a.j.core and o.a.j.core.session can be updated to reflect these changes simply by updating the relevant import statements. To make reviewing the patch easier, I&amp;#39;ve attached also a version without all the trivial package renames (session-class-move-rename.patch). Note that the new package boundary required changes to the visibility of a number of methods and classes. My plan is to refactor these cases so that we don&amp;#39;t expose more of the Jackrabbit internals to client code.</comment>
                    <comment id="12868599" author="anchela" created="Tue, 18 May 2010 11:37:39 +0100"  >my comments from a quick first glance at the patches:&lt;br/&gt;
&lt;br/&gt;
why is the package called &amp;#39;session&amp;#39;? from your explanation on the dev list (&amp;quot;[...] to move most of the session-related classes from o.a.j.core to &lt;br/&gt;
a new o.a.j.core.session package [...]&amp;quot;) i would have expected that this is related to either JCR API implementations in close relationship to &lt;br/&gt;
the Session or modifications on the Session level (aka transient modifications).&lt;br/&gt;
but now the patch moves classes that i wouldn&amp;#39;t have expected to be affected based your explanation: BatchedItemOperations (purely workspace operations on the  item state level), ItemData and subclasses (really internal stuff) just to mention 2 of them. what was the design behind those moves?&lt;br/&gt;
&lt;br/&gt;
second i have strong concern regarding changing the visibility of so many classes and methods that i consider to be repository internals.&lt;br/&gt;
making them all public feels really wrong to me.... what exactly do you mean by &amp;quot;My plan is to refactor these cases so that we don&amp;#39;t expose more of the Jackrabbit internals to client code.&amp;quot;? if you plan major refactoring of other core classes not affected by the move, why not addressing this first before&lt;br/&gt;
moving classes that from my point of view don&amp;#39;t belong to the target package?&lt;br/&gt;
&lt;br/&gt;
-1 for the current patch.</comment>
                    <comment id="12868623" author="jukkaz" created="Tue, 18 May 2010 13:32:27 +0100"  >Thanks for the review!&lt;br/&gt;
&lt;br/&gt;
&amp;gt; why is the package called &amp;#39;session&amp;#39;?&lt;br/&gt;
&lt;br/&gt;
Perhaps some other term than &amp;quot;session&amp;quot; would be clearer. The way I see the current Jackrabbit architecture (as muddy as it at times is), there are basically two main parts:&lt;br/&gt;
&lt;br/&gt;
1) &amp;quot;repository&amp;quot; part that consists of the global persisted state stored in persistence managers, node type registry, etc. This state is seen and shared by all clients that access the repository.&lt;br/&gt;
&lt;br/&gt;
2) &amp;quot;session&amp;quot; part that consist of the transient changes that have not yet been persisted. This part is private to each client. Note that I also consider things like immediately persisted workspace operations (imports, copies and moves, etc.) as part of the &amp;quot;session&amp;quot; layer up to the point when the relevant ChangeLog gets persisted. Thus I count also classes like BatchedItemOperations as part of this architectural layer.&lt;br/&gt;
&lt;br/&gt;
Would &amp;quot;global&amp;quot; and &amp;quot;local&amp;quot; be better terms? Note that I&amp;#39;d rather avoid labels like &amp;quot;persisted&amp;quot; and &amp;quot;transient&amp;quot; to prevent confusion with things like &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2051&quot; title=&quot;Disk based transient space&quot;&gt;JCR-2051&lt;/a&gt; (and since &amp;quot;transient&amp;quot; is a reserved word in Java).&lt;br/&gt;
&lt;br/&gt;
Basically, when I talk about &amp;quot;session-related classes&amp;quot; above, I mean code related to point 2 above.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; visibility&lt;br/&gt;
&lt;br/&gt;
I was planning to move these classes first so I&amp;#39;d have a better picture of these package-private dependencies (as seen in session-class-move-norename.patch) before refactoring them away. Note that in most cases I expect these changes to be minor refactorings, like replacing a call to RepositoryImpl.getSomething() with an injected dependency. But yes, I can take care of this also before other changes.&lt;br/&gt;
</comment>
                    <comment id="12869170" author="stefan@jira" created="Wed, 19 May 2010 16:26:36 +0100"  >i don&amp;#39;t have a strong opinion regarding the suggested refactoring in general.&lt;br/&gt;
if it enables a better tool support, that&amp;#39;s ok with me.&lt;br/&gt;
&lt;br/&gt;
however, i do share angela&amp;#39;s concerns regarding changing the visibility of&lt;br/&gt;
internal classes/methods. &lt;br/&gt;
&lt;br/&gt;
since jukka said that he will address those concerns in another patch, &lt;br/&gt;
i&amp;#39;ll wait for the next patch.</comment>
                    <comment id="12871131" author="jukkaz" created="Tue, 25 May 2010 14:11:37 +0100"  >See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2640&quot; title=&quot;Internal repository context&quot;&gt;JCR-2640&lt;/a&gt; for a proposed way (and initial patch) to get rid of the troublesome getters.</comment>
                    <comment id="12881557" author="c_koell" created="Wed, 23 Jun 2010 06:54:11 +0100"  >Hi Jukka,&lt;br/&gt;
I saw your commits with the new SessionOperations.&lt;br/&gt;
First good work but i want to let you know that the locking is only Thread based and we will&lt;br/&gt;
get some problems in a xa environment on a applicationserver because the reentrant calls must not come from the same thread. I would prefere to handle now the whole locking semantic in our own classes to handle this behaviours in a global way.&lt;br/&gt;
See &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2089&quot; title=&quot;Use java.util.concurrent&quot;&gt;JCR-2089&lt;/a&gt;</comment>
                    <comment id="12881593" author="jukkaz" created="Wed, 23 Jun 2010 08:27:12 +0100"  >The SessionOperation mechanism is meant to synchronize only session-related JCR API calls, so unlike with XA transactions there should never be a need for two threads to use the same lock concurrently. I&amp;#39;m using a java.util.concurrent lock instead of a synchronized block only to enable more accurate logging of potential concurrency problems.</comment>
                    <comment id="12896863" author="jukkaz" created="Tue, 10 Aug 2010 12:54:18 +0100"  >I&amp;#39;ve now updated most of the public Session and Item (incl. Node and Property) method as well as search and versioning operations to use the new SessionOperation mechanism. This should cover the majority of normal use cases, and practically all cases where concurrent session access has caused problems in the past. Resolving as fixed.</comment>
                </comments>
                    <attachments>
                    <attachment id="12444696" name="session-class-move-norename.patch" size="29381" author="jukkaz" created="Mon, 17 May 2010 16:53:47 +0100" />
                    <attachment id="12444697" name="session-class-move.patch" size="164887" author="jukkaz" created="Mon, 17 May 2010 16:54:56 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>2.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 16 May 2007 10:49:25 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>97874</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231744</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>