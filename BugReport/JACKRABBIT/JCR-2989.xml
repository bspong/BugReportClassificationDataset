<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:54:10 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2989/JCR-2989.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2989] Support for embedded index aggregates</title>
                <link>https://issues.apache.org/jira/browse/JCR-2989</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Index aggregates could contain other index aggregates. JR should be able to handle a complete hierarchy of aggregates. &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m working on a patch.</description>
                <environment></environment>
            <key id="12510415">JCR-2989</key>
            <summary>Support for embedded index aggregates</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                    <parent id="12504265">JCR-2947</parent>
                        <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="alex.parvulescu">Alex Parvulescu</assignee>
                                <reporter username="alex.parvulescu">Alex Parvulescu</reporter>
                        <labels>
                    </labels>
                <created>Wed, 15 Jun 2011 09:52:53 +0100</created>
                <updated>Tue, 8 Nov 2011 15:40:19 +0000</updated>
                    <resolved>Wed, 12 Oct 2011 15:00:43 +0100</resolved>
                                            <fixVersion>2.3.2</fixVersion>
                                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="13049720" author="alex.parvulescu" created="Wed, 15 Jun 2011 12:07:04 +0100"  >attached support for embedded index aggregates (fix + test)&lt;br/&gt;
&lt;br/&gt;
any comments?</comment>
                    <comment id="13050305" author="jukkaz" created="Thu, 16 Jun 2011 10:07:55 +0100"  >I&amp;#39;m a bit worried about the possibility of accidentally creating huge aggregates with this. For example, will the following create index aggregates of an entire folder structure, traversed recursively whenever any of the folders gets modified?&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;aggregate primaryType=&amp;quot;nt:folder&amp;quot;&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;include primaryType=&amp;quot;nt:folder&amp;quot;&amp;gt;*&amp;lt;/include&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;lt;/aggregate&amp;gt;&lt;br/&gt;
&lt;br/&gt;
It might be good to either prevent recursive aggregates (only allow different aggregate definitions to be embedded) or to require some explicit recursive=&amp;quot;true&amp;quot; annotation on such aggregate definitions to make sure the user knows what they&amp;#39;re doing. </comment>
                    <comment id="13050327" author="alex.parvulescu" created="Thu, 16 Jun 2011 11:04:06 +0100"  >Yes, on update the structure will be traversed up, so the parents will be updated. For each change, you&amp;#39;ll have as many updates as there are levels of inclusion.&lt;br/&gt;
&lt;br/&gt;
But I&amp;#39;m not sure how big this problem is. I&amp;#39;d say it depends on the number of levels you hierarchy has, and the number of fields a node has indexed. But you can easily abuse both :)&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll tweak the code a bit so that it tries to optimize the upward update. Basically when checking a node&amp;#39;s root aggregate, if this is already on the update list, stop there, as all its parents are already included in this update.&lt;br/&gt;
&lt;br/&gt;
I agree on having a soft rule in place for recursive aggregates (lets say max 5 levels deep), but I think having a recursive=true rule doesn&amp;#39;t help the average copy-paste-from-the-wiki user :)  &lt;br/&gt;
(and by the way that includes me too, as the docs are not excellent ;)&lt;br/&gt;
</comment>
                    <comment id="13051057" author="alex.parvulescu" created="Fri, 17 Jun 2011 14:00:11 +0100"  >Attached a reworked patch.&lt;br/&gt;
&lt;br/&gt;
It includes a soft limit for recursive aggregates. &lt;br/&gt;
After talking with others about this, I&amp;#39;ve decided to put the limit at 100, this should give us plenty of room to breathe.&lt;br/&gt;
So for the same type nodes, it only goes 100 (same type) parents up, then it stops updating.&lt;br/&gt;
&lt;br/&gt;
The trick is that the limit is upward, because the way aggregation works. You start with a child node that has been updated, and go up it&amp;#39;s hierarchy.&lt;br/&gt;
&lt;br/&gt;
The patch also includes the tiny optimisation I mentioned earlier, if it runs into a known parent, it will stop, as the entire hierarchy is already on the update list.</comment>
                    <comment id="13051101" author="jukkaz" created="Fri, 17 Jun 2011 15:44:17 +0100"  >The recursive behaviour I&amp;#39;m worried about is due to the way aggregates are built by the indexer. For example say that you have a subtree of 1m nt:folders organized in three levels (100 child nodes for each non-leaf folder). Now, given the above example aggregate definition, whenever any one of these folders gets updated, the search index will also trigger an update of the index entry of the top-level folder. The SearchIndex.createDocument() call would then have to recursively traverse the entire subtree of 1m folders just to build the correct new index entry. That&amp;#39;s a performance nightmare just waiting to happen.&lt;br/&gt;
&lt;br/&gt;
Recursive aggregates can be a pretty useful tool and I&amp;#39;d certainly like to see them fully supported, but I&amp;#39;d like to avoid a situation where it&amp;#39;s too easy to shoot yourself in the foot with careless configuration.</comment>
                    <comment id="13061218" author="alex.parvulescu" created="Thu, 7 Jul 2011 12:27:45 +0100"  >take 3, action!&lt;br/&gt;
&lt;br/&gt;
Updated the patch.&lt;br/&gt;
Now the same type node aggregates are not included by default.&lt;br/&gt;
Followed Jukka&amp;#39;s advice and included a &amp;#39;recursive&amp;#39; flag on the aggregate definition (default is false).&lt;br/&gt;
I also added &amp;#39;recursiveLimit&amp;#39; to control the number of levels up the indexing should go (default 100 / 0 for infinite recusion).&lt;br/&gt;
&lt;br/&gt;
This is how the config looks like now:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;lt;aggregate primaryType=&amp;quot;nt:folder&amp;quot; recursive=&amp;quot;true&amp;quot; recursiveLimit=&amp;quot;10&amp;quot;&amp;gt;&lt;br/&gt;
&lt;br/&gt;
So basically, now we are sure that the aggregates will not just sneak up on you :)&lt;br/&gt;
&lt;br/&gt;
For more info, you can also look at the tests.</comment>
                    <comment id="13125863" author="alex.parvulescu" created="Wed, 12 Oct 2011 15:00:43 +0100"  >Fixed in revision 1182367 and 1182368.</comment>
                </comments>
                    <attachments>
                    <attachment id="12482650" name="JCR-2989.patch" size="7345" author="alex.parvulescu" created="Wed, 15 Jun 2011 12:07:04 +0100" />
                    <attachment id="12482930" name="JCR-2989_v2.patch" size="10569" author="alex.parvulescu" created="Fri, 17 Jun 2011 14:00:11 +0100" />
                    <attachment id="12485573" name="JCR-2989_v3.patch" size="40452" author="alex.parvulescu" created="Thu, 7 Jul 2011 12:27:45 +0100" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 16 Jun 2011 09:07:55 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>36266</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>280327</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>