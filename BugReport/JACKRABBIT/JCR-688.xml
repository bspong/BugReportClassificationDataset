<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:48:56 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-688/JCR-688.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-688] Improve name resolution</title>
                <link>https://issues.apache.org/jira/browse/JCR-688</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>As discussed in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-685&quot; title=&quot;Remove some synchronization on CachingNamespaceResolver&quot;&gt;&lt;strike&gt;JCR-685&lt;/strike&gt;&lt;/a&gt;, the current CachingNamespaceResolver class contains excessive synchronization causing monitor contention that reduces performance.&lt;br/&gt;
&lt;br/&gt;
In &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-685&quot; title=&quot;Remove some synchronization on CachingNamespaceResolver&quot;&gt;&lt;strike&gt;JCR-685&lt;/strike&gt;&lt;/a&gt; there&amp;#39;s a proposed patch that replaces synchronization with a read-write lock that would allow concurrent read access to the name cache.</description>
                <environment></environment>
            <key id="12359192">JCR-688</key>
            <summary>Improve name resolution</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="anchela">angela</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Thu, 21 Dec 2006 09:46:29 +0000</created>
                <updated>Tue, 15 Jan 2008 23:26:35 +0000</updated>
                    <resolved>Tue, 30 Oct 2007 10:12:24 +0000</resolved>
                                            <fixVersion>1.4</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12460221" author="mreutegg" created="Thu, 21 Dec 2006 11:22:29 +0000"  >I have to apologize, my post in &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-685&quot; title=&quot;Remove some synchronization on CachingNamespaceResolver&quot;&gt;&lt;strike&gt;JCR-685&lt;/strike&gt;&lt;/a&gt; was not precise enough.&lt;br/&gt;
&lt;br/&gt;
What acutally happens when multiple threads access the CachingNamespaceResolver is the following: because even a get() call on the LRUMap modifies the internal data structures those calls must be synchronized. This basically serializes access on the LRUMap even though only a small critical section should be synchronized: the method moveToMRU(). Calculating the hash code, doing the lookup in the hashtable and checking whether the keys are equal does not require synchronization and multiple threads can do this concurrently.&lt;br/&gt;
&lt;br/&gt;
I agree that this does not necessarily have to go into the 1.2 release, but it certainly is a problem, because the CachingNamespaceResolver in the NamespaceRegistry is a single instance repository wide and used by all threads that access the repository. Since name resolution is involved in nearly every operation I think it should allow maximum concurrent threads.&lt;br/&gt;
&lt;br/&gt;
It is correct that the proposed change will not lower the number of synchronized sections but the sections will be significantly smaller. So to be precise this improvement is not really to avoid monitor contention but to allow more concurrent access to the CachingNamespaceResolver.</comment>
                    <comment id="12460243" author="jukkaz" created="Thu, 21 Dec 2006 12:30:25 +0000"  >Is the cache even required?&lt;br/&gt;
&lt;br/&gt;
It seems to me that the operations that we try to speed up using the cache are very small and fast in any case, i.e. simple string parsing and concatenation. Sure, it adds up to a large number of short-lived object allocations, but a generational garbage collector shouldn&amp;#39;t have much trouble handling that.&lt;br/&gt;
&lt;br/&gt;
Do we have some performance numbers to validate the need for caching in this case?</comment>
                    <comment id="12460272" author="mreutegg" created="Thu, 21 Dec 2006 14:06:17 +0000"  >One example is regularly accessing properties with the same name. In an application you will usually have a fixed set of property names (unless you use residual properties).&lt;br/&gt;
&lt;br/&gt;
The following test case executes 5 times faster with name caching:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void testPropertyAccess() throws RepositoryException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 100; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;testRootNode.addNode(&amp;quot;node&amp;quot; + i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;testRootNode.save();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long time = System.currentTimeMillis();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// loop 1000 times over child nodes and access two properties&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 1000; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (NodeIterator it = testRootNode.getNodes(); it.hasNext(); ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node n = it.nextNode();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.getProperty(jcrPrimaryType);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n.hasProperty(jcrMixinTypes);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;time = System.currentTimeMillis() - time;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;test took: &amp;quot; + time + &amp;quot; ms.&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                    <comment id="12460349" author="jukkaz" created="Thu, 21 Dec 2006 21:59:50 +0000"  >&amp;gt; The following test case executes 5 times faster with name caching&lt;br/&gt;
&lt;br/&gt;
Good point. :-)&lt;br/&gt;
&lt;br/&gt;
Digging deeper in the performance figures I noticed that most of this performance hit is caused by the heavy use of regexp matching in NameFormat. I was able to get a major performance gain simply by replacing the regexp&amp;#39;s with custom parsing code (I&amp;#39;ll clean it up attach as an example patch). The performance is still clearly worse than with caching, but not nearly as bad as before.&lt;br/&gt;
&lt;br/&gt;
Some other observations:&lt;br/&gt;
&lt;br/&gt;
* The performance requirements and expected data sets for the QName-&amp;gt;String and String-&amp;gt;QName conversions seem quite different. For example the above test case is almost entirely governed by the String-&amp;gt;QName conversion speed. It would probably make sense to consider using separate mechanisms for the two types of conversions.&lt;br/&gt;
&lt;br/&gt;
* Moving the name cache from the global namespace registry to the session level would probably make sense. That would avoid the synchronization requirements at the expense of extra memory use. An extra benefit would be that the name cache could also be used when session-local namespace remappings are in effect.&lt;br/&gt;
&lt;br/&gt;
* The individual resolution operations are very fast in any case, so the performance is only relevant when doing a large number of operations. Thus the cost of occasional heavier optimization operations (if available) could probably be easily amortized.&lt;br/&gt;
</comment>
                    <comment id="12461033" author="jukkaz" created="Wed, 27 Dec 2006 16:22:57 +0000"  >Attached &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-688&quot; title=&quot;Improve name resolution&quot;&gt;&lt;strike&gt;JCR-688&lt;/strike&gt;&lt;/a&gt;.LocalCache.patch (against jackrabbit-core) that replaces the CachingNamespaceResolver in NamespaceRepository with a simple LRUMap in LocalNamespaceMappings.&lt;br/&gt;
&lt;br/&gt;
This achieves the same performance as before without any of the concurrence issues. It also works fine with local namespace remappings.</comment>
                    <comment id="12461041" author="reschke" created="Wed, 27 Dec 2006 17:08:45 +0000"  >If we know that name prefix resolution causes this amount of pain, shouldn&amp;#39;t we consider adding QName-based addressing in JSR-283?</comment>
                    <comment id="12461047" author="jukkaz" created="Wed, 27 Dec 2006 17:31:31 +0000"  >&amp;gt; If we know that name prefix resolution causes this amount of pain,&lt;br/&gt;
&amp;gt; shouldn&amp;#39;t we consider adding QName-based addressing in JSR-283?&lt;br/&gt;
&lt;br/&gt;
This issue is just a minor implementation detail. There is a price in performance of doing the String&amp;lt;-&amp;gt;QName conversions, but the performance hit is probably only noticeable for heavily cached workloads like the example above. The cost of the string operations is likely insignificant as soon as the repository starts hitting the disk.&lt;br/&gt;
&lt;br/&gt;
The reason I&amp;#39;m passionate about this is not the performance, but the creeping complexity introduced by the concurrency control. More generally I think the whole name resolution infrastructure in Jackrabbit is much more complex than it really needs to be.</comment>
                    <comment id="12461946" author="mreutegg" created="Wed, 3 Jan 2007 13:05:09 +0000"  >&amp;gt; * The performance requirements and expected data sets for the QName-&amp;gt;String&lt;br/&gt;
&amp;gt; and String-&amp;gt;QName conversions seem quite different. For example the above&lt;br/&gt;
&amp;gt; test case is almost entirely governed by the String-&amp;gt;QName conversion speed.&lt;br/&gt;
&amp;gt; It would probably make sense to consider using separate mechanisms for the&lt;br/&gt;
&amp;gt; two types of conversions.&lt;br/&gt;
&lt;br/&gt;
I agree with you. The cost for converting a QName into its resolved String is probably&lt;br/&gt;
not worth caching the result. We should probably remove the cache for this conversion.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; * Moving the name cache from the global namespace registry to the session&lt;br/&gt;
&amp;gt; level would probably make sense. That would avoid the synchronization&lt;br/&gt;
&amp;gt; requirements at the expense of extra memory use. An extra benefit would be&lt;br/&gt;
&amp;gt; that the name cache could also be used when session-local namespace&lt;br/&gt;
&amp;gt; remappings are in effect.&lt;br/&gt;
&lt;br/&gt;
While it certainly helps to avoid the concurrency issue it introduces a cache per session&lt;br/&gt;
which is in most cases filled with mappings that are just duplicates from other sessions.&lt;br/&gt;
&lt;br/&gt;
I think the current location of the cache is the better choice because it uses the occupied&lt;br/&gt;
memory more effectively (shared with other sessions), though at the price of increased&lt;br/&gt;
concurrency on the cache. But that&amp;#39;s IMO just a technical detail of the cache implementation.</comment>
                    <comment id="12462183" author="tripod" created="Thu, 4 Jan 2007 10:16:34 +0000"  >i think using a simple ConcurrentReaderHashMap improves the performance quite a lot since NO synchronization needs to be done (if the element is found). And instead of maintaining a LRU mechanism, i would just clear the map if it reaches a certain size (e.g. 10&amp;#39;000 names). i think an application either uses few similar names or many different. and in the later case, an LRU map does not help either. the costs of rebuilding the cache after it was cleared are not higher than if the elements get shifted out of the LRU it this one is too small.</comment>
                    <comment id="12462760" author="jukkaz" created="Sun, 7 Jan 2007 00:59:43 +0000"  >Attached a &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-688&quot; title=&quot;Improve name resolution&quot;&gt;&lt;strike&gt;JCR-688&lt;/strike&gt;&lt;/a&gt;.NameResolver.patch that includes 1) a proposed new NameResolver interface, and 2) a generational name cache. For now the patch simply replaces the CachingNamespaceResolver class, but if the NameResolver proposal gets accepted, it has potential to simplify quite a lot of the current name resolution code.&lt;br/&gt;
&lt;br/&gt;
1) NameResolver interface&lt;br/&gt;
&lt;br/&gt;
The previous and current mechanisms of putting JCR name parsing and formatting operations respectively in the NamespaceResolver interface and the NameFormat static class are both not very clean. The methods in NamespaceResolver imply extra responsibilities even to classes that would only need to handle namespace mappings and not individual names, and the static NameFormat methods are very inflexible, for example support for name caching requires explicit instanceof operations.&lt;br/&gt;
&lt;br/&gt;
The NameResolver interface is a proposal to simplify this. The interface implies only the responsibilities of parsing and formatting JCR names and leaves the handling of namespace mappings or name caching as implementation details.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve included two basic implementations of the NameResolver interface in the patch: the ParsingNameResolver class contains the basic name parsing and formatting routines and uses a NamespaceResolver to access the prefix mappings, while the CachingNameResolver class can be used to decorate another NameResolver (most likely a ParsingNameResolver) with name caching. Those two implementations should be enough to cover almost all of the current name resolution needs.&lt;br/&gt;
&lt;br/&gt;
2) Generational name cache&lt;br/&gt;
&lt;br/&gt;
Both the LRUMap and ConcurrentReaderHashMap alternatives cause the entire name cache to get flushed when a client generates a long sequence of different names, for example &amp;quot;itemN&amp;quot; where N is a sequence number. To better handle this situation and to get rid of all synchronization for most cases, the CachingNameResolver class implements a &amp;quot;generational&amp;quot; name cache that borrows ideas from modern garbage collectors.&lt;br/&gt;
&lt;br/&gt;
The basic idea of a generational name cache is that there are three cache maps: one is a long term cache and two represent &amp;quot;generations&amp;quot; of cached entries, one &amp;quot;young&amp;quot; and one &amp;quot;old&amp;quot; generation. Name entries in the long term cache are always looked up and returned directly without any synchronization or counting taking place. If the long term cache is missed, the entry is looked up in either of the generations or explicitly resolved using the decorated NameResolver. Finally the resolved name entry added to the &amp;quot;young&amp;quot; generation to mark it as recently requested.&lt;br/&gt;
&lt;br/&gt;
After a configurable number of such long term cache misses (the &amp;quot;age&amp;quot; of the generation) have been made, the union of the two generations is calculated and added to the long term cache. I.e. the names that have been accessed continuously over two cache generations will probably be used frequently in the long term. Then the previous &amp;quot;young&amp;quot; generation is becomes the new &amp;quot;old&amp;quot; generation, and a new empty &amp;quot;young&amp;quot; generation is started. Once the long term cache reaches a specified maximum size, it gets replaced with just the union of the last two generations.&lt;br/&gt;
&lt;br/&gt;
The CachingNameResolver is also implemented so that no synchronization is required for accessing the long term cache. Synchronization is only used when a long term cache miss occurs and even then concurrent reads to the long term cache can continue.&lt;br/&gt;
</comment>
                    <comment id="12462987" author="mreutegg" created="Mon, 8 Jan 2007 10:04:47 +0000"  >I think the patch is very good, I just have one issue: name resolution through the CachingNameResolver is serialized. The call resolver.getQName(name) within CachingNameResolver.getQName() is in a synchronized(this). Can this be change in a way that multiple thread can resolve names concurrently?</comment>
                    <comment id="12462989" author="jukkaz" created="Mon, 8 Jan 2007 10:17:10 +0000"  >&amp;gt; The call resolver.getQName(name) within CachingNameResolver.getQName() is in&lt;br/&gt;
&amp;gt; a synchronized(this).Can this be change in a way that multiple thread can resolve&lt;br/&gt;
&amp;gt; names concurrently?&lt;br/&gt;
&lt;br/&gt;
I think so. The reason for the synchronization is to guard access to the &amp;quot;young&amp;quot; generation maps that gets modified. I think it would be enough to make just the &amp;quot;young&amp;quot; map and the increaseGenerationAge() method synchronized. I&amp;#39;ll take a look at this later today.</comment>
                    <comment id="12463005" author="stefan@jira" created="Mon, 8 Jan 2007 11:09:23 +0000"  >i agree with jukka&amp;#39;s rationale, +1 for the redesign/patch (assuming the synchronization issue mentioned by marcel gets resolved).&lt;br/&gt;
&lt;br/&gt;
it would be very  interesting to see some &amp;#39;before/after&amp;#39; benckmark/profiling results.</comment>
                    <comment id="12463021" author="jukkaz" created="Mon, 8 Jan 2007 12:30:03 +0000"  >Attached &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-688&quot; title=&quot;Improve name resolution&quot;&gt;&lt;strike&gt;JCR-688&lt;/strike&gt;&lt;/a&gt;.NameResolver.v2.patch with reduced synchronization and a slightly improved increaseGenerationAge() method.&lt;br/&gt;
&lt;br/&gt;
A quick ad-hoc test with the above testPropertyAccess method running in 20 concurrent threads is about 6% faster using this implementation than with the current CachingNamespaceResolver. A few more percents can probably be achieved by getting rid of the current NameFormat indirections obsoleted by the new NameResolver interface.&lt;br/&gt;
&lt;br/&gt;
Careful analysis of the performance tradeoffs could improve the cache even more. For example it might make sense to make the &amp;quot;young&amp;quot; generation write-only (i.e. only add mappings to it within the synchronized increaseGenerationAge()) to avoid extra monitor contention.&lt;br/&gt;
</comment>
                    <comment id="12463150" author="jukkaz" created="Mon, 8 Jan 2007 22:45:29 +0000"  >Committed version 3 of the NameResolver classes in revision 494219. The committed classes have some minor differences to the above proposals, most notably:&lt;br/&gt;
&lt;br/&gt;
a) ParsingNameResolver was further optimized and is now most likely the fastest validating JCR name parser there is.&lt;br/&gt;
&lt;br/&gt;
b) CachingNameResolver now caches both parsed and formatted names, as benchmarking showed noticeable gain from doing so.&lt;br/&gt;
&lt;br/&gt;
c) CachingNameResolver was simplified so that only a single synchronized method is required for controlling concurrency.</comment>
                    <comment id="12463206" author="tripod" created="Tue, 9 Jan 2007 07:02:29 +0000"  >what about caching of paths?</comment>
                    <comment id="12463212" author="jukkaz" created="Tue, 9 Jan 2007 07:57:43 +0000"  >&amp;gt; what about caching of paths?&lt;br/&gt;
&lt;br/&gt;
A similar PathResolver solution would IMHO nicely cover path handling. I&amp;#39;ll look at it.</comment>
                    <comment id="12488278" author="jukkaz" created="Thu, 12 Apr 2007 08:16:59 +0100"  >Dropping the 1.3 target as there&amp;#39;s still more to do.</comment>
                    <comment id="12535493" author="anchela" created="Wed, 17 Oct 2007 11:02:39 +0100"  >i guess, this issue will be covered by  issue &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1169&quot; title=&quot;Distribution of commons classes&quot;&gt;&lt;strike&gt;JCR-1169&lt;/strike&gt;&lt;/a&gt; Distribution of commons classes.&lt;br/&gt;
&lt;br/&gt;
The proposed distribution replaces the *Format classes by  the *Resolver interfaces. Both&lt;br/&gt;
interfaces and jukkas implementations are copied to the spi-commons. The Parsing*Resolver got adjusted according to tobis feedback.</comment>
                    <comment id="12538721" author="anchela" created="Tue, 30 Oct 2007 10:12:24 +0000"  >completed with rev. 590014 (adjusting jackrabbit-core to reflect changes introduced with issue &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1169&quot; title=&quot;Distribution of commons classes&quot;&gt;&lt;strike&gt;JCR-1169&lt;/strike&gt;&lt;/a&gt;.</comment>
                </comments>
                <issuelinks>
                        <issuelinktype id="10032">
                <name>Blocker</name>
                                                <inwardlinks description="is blocked by">
                            <issuelink>
            <issuekey id="12379961">JCR-1169</issuekey>
        </issuelink>
                    </inwardlinks>
                            </issuelinktype>
                        <issuelinktype id="12310010">
                <name>Incorporates</name>
                                <outwardlinks description="incorporates">
                            <issuelink>
            <issuekey id="12359467">JCR-691</issuekey>
        </issuelink>
                    </outwardlinks>
                                            </issuelinktype>
                    </issuelinks>
                <attachments>
                    <attachment id="12347940" name="JCR-688.LocalCache.patch" size="11236" author="jukkaz" created="Wed, 27 Dec 2006 16:22:57 +0000" />
                    <attachment id="12348442" name="JCR-688.NameResolver.patch" size="22710" author="jukkaz" created="Sun, 7 Jan 2007 00:27:25 +0000" />
                    <attachment id="12348494" name="JCR-688.NameResolver.v2.patch" size="22955" author="jukkaz" created="Mon, 8 Jan 2007 12:13:24 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Thu, 21 Dec 2006 11:22:29 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142312</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>231724</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>