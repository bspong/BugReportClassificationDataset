<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:38:53 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1865/JCR-1865.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1865] Add the Data Store to the Jackrabbit API</title>
                <link>https://issues.apache.org/jira/browse/JCR-1865</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Currently, the garbage collection is not part of the Jackrabbit API. However, the data store garbage collection must be used once in a while if the data store is enabled. I propose to add the required interfaces to the Jackrabbit API. This will also allow to call garbage collection using RMI.</description>
                <environment></environment>
            <key id="12408811">JCR-1865</key>
            <summary>Add the Data Store to the Jackrabbit API</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="tmueller">Thomas Mueller</assignee>
                                <reporter username="tmueller">Thomas Mueller</reporter>
                        <labels>
                    </labels>
                <created>Wed, 19 Nov 2008 10:57:52 +0000</created>
                <updated>Mon, 11 Jan 2010 14:18:27 +0000</updated>
                    <resolved>Fri, 2 Oct 2009 09:11:21 +0100</resolved>
                                            <fixVersion>2.0-beta1</fixVersion>
                                <component>jackrabbit-core</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12648985" author="tmueller" created="Wed, 19 Nov 2008 11:07:49 +0000"  >Required changes in Jackrabbit Core</comment>
                    <comment id="12648986" author="tmueller" created="Wed, 19 Nov 2008 11:08:17 +0000"  >Required changes in the Jackrabbit API</comment>
                    <comment id="12649032" author="fmeschbe" created="Wed, 19 Nov 2008 13:23:05 +0000"  >+1 with comments for the propose extensions:&lt;br/&gt;
&lt;br/&gt;
* I suggest adding a MarkEventListener.started() method, which is called when scanning starts. This would be the logical lifecycle bracket to the done() method.&lt;br/&gt;
&lt;br/&gt;
* I suggest renaming the getPersistenceManagerScan() method to isPersistenceManagerScan()&lt;br/&gt;
&lt;br/&gt;
* I suggest defining the millis parameter to the setSleepBetweenNodes as long (instead of int) since all time related methods in Java take long rather than int. In addition I would add a getSleepBetweenNodes() to return that value, at least for completeness sake&lt;br/&gt;
&lt;br/&gt;
* I am unclear as to what the stopScan method is all about. Shouldn&amp;#39;t cleanup be done at the end of the scan method ? In addition I think the name &amp;quot;stopScan&amp;quot; is misleading: According to JavaDoc it does not actually stop something but cleanup after scanning is complete.&lt;br/&gt;
&lt;br/&gt;
* Since the API looks much like a Mark&amp;amp;Sweep algorithm is foreseen to collect data store garbage, it might be sensible to name the methods accordingly: mark() instead of scan() and sweep() instead of deleteUnused(). This would also create a cognitive link to the MarkEventListener, which is called while the mark() method is running.&lt;br/&gt;
&lt;br/&gt;
* As a corrollary to the previous comments: Why is the scan() (or mark()) method separate from the stopScan() and deleteUnused() methods ? If the three should be called in succession anyway, there should probably be just a single method &amp;quot;gc()&amp;quot; (or similar), which does everything and would also leave the actual algorithm choice to the implementation.</comment>
                    <comment id="12649043" author="jukkaz" created="Wed, 19 Nov 2008 14:20:43 +0000"  >-1 Why should we put the client be in control of a server process like garbage collection? I would prefer a configuration option, a user interface in jackrabbit-webapp, or perhaps a JMX bean for such purposes. See also the related discussions about the shutdown method and the proposed cluster sync method.&lt;br/&gt;
&lt;br/&gt;
If we really do need to expose this in a client API, I&amp;#39;m with Felix in preferring to hide the implementation details and make this just a single no-argument method like JackrabbitSesssion.gc().&lt;br/&gt;
</comment>
                    <comment id="12649062" author="tmueller" created="Wed, 19 Nov 2008 14:57:26 +0000"  >* MarkEventListener.started(): agreed. I&amp;#39;m not sure if this would be fully backward compatible: existing ScanEventListeners don&amp;#39;t implement this method. When calling this method on an old implementation, the JVM would throw a java.lang.AbstractMethodError. This could be caught and ignored.&lt;br/&gt;
&lt;br/&gt;
* getPersistenceManagerScan() method to isPersistenceManagerScan(): agreed.&lt;br/&gt;
&lt;br/&gt;
* millis parameter to the setSleepBetweenNodes as long: agreed. getSleepBetweenNodes(): agreed.&lt;br/&gt;
&lt;br/&gt;
* stopScan(): you are right, it doesn&amp;#39;t belong to the interface. It is used for testing only.&lt;br/&gt;
&lt;br/&gt;
* mark() and sweep(): agreed. We could still call it getPersistenceManagerScan however&lt;br/&gt;
&lt;br/&gt;
* single method &amp;quot;gc()&amp;quot;: multiple repositories can use the same data store (sharing the data store). In that case, you need to call mark() of all repositories before calling sweep() (on the first repository).</comment>
                    <comment id="12649072" author="tmueller" created="Wed, 19 Nov 2008 15:12:28 +0000"  >&amp;gt; client API&lt;br/&gt;
&lt;br/&gt;
It is a &amp;#39;management API&amp;#39;. There is no separate management API section at the moment, we could create a package org.apache.jackrabbit.api.management.data. Also we could create an interface org.apache.jackrabbit.api.management.JackrabbitManagedRepository.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Why should we put the client be in control of a server process like garbage collection?&lt;br/&gt;
&lt;br/&gt;
I agree it should be a background process. Unfortunately it&amp;#39;s not so easy to implement that, specially not when multiple repositories use the same data store.</comment>
                    <comment id="12649079" author="jukkaz" created="Wed, 19 Nov 2008 15:48:41 +0000"  >+1 to o.a.j.api.management. Separating the client and management APIs is good since then we don&amp;#39;t need to worry about authorization of management operations.&lt;br/&gt;
&lt;br/&gt;
About the multiple repository case; I would for now declare that as a special case and expect people who use such configurations to explicitly manage things like garbage collection using our lower level APIs. I would rather move cautiously with exposing the implementation details in a public API as we might well want to switch to a different garbage collection mechanism in the future.&lt;br/&gt;
</comment>
                    <comment id="12649292" author="fmeschbe" created="Thu, 20 Nov 2008 07:43:01 +0000"  >&amp;gt; I&amp;#39;m not sure if this would be fully backward compatible&lt;br/&gt;
&lt;br/&gt;
Well, you already renamed the interface, right ? So you already have kind of a backwards compatibility issue.&lt;br/&gt;
&lt;br/&gt;
In addition, there has not been an official API yet (interfaces &amp;quot;hidden&amp;quot; in implementation code should not be called API ;-) ), so IMHO there is no need to worry.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; * single method &amp;quot;gc()&amp;quot;: multiple repositories can use the same data store (sharing the data store). In that case,&lt;br/&gt;
&amp;gt; you need to call mark() of all repositories before calling sweep() (on the first repository).&lt;br/&gt;
&lt;br/&gt;
As Jukka already said, sharing the store among multiple repositories is an implementation detail of the data store and is of no concern to the administrator (+1 for making it a management API BTW). Synchronization among the repositories sharing the data store is the task of the data store.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; our lower level APIs&lt;br/&gt;
&lt;br/&gt;
What is &amp;quot;lower level APIs&amp;quot; ?</comment>
                    <comment id="12649358" author="alexander.klimetschek" created="Thu, 20 Nov 2008 12:56:19 +0000"  >+1 for the data store api with Felix&amp;#39; extensions + the separate management API package&lt;br/&gt;
&lt;br/&gt;
For the mark()/sweep() vs. gc() I would opt for the mark/sweep variant, since I guess the synchronization inside the datastore implementation would be very hard to do, since the datastore itself doesn&amp;#39;t know all the repositories that use the same datastore location. If there will be a future garbage collection mechanism that can directly delete items for example, the implementation of mark() would simply be empty and everything happens in sweep(). Most clients will call mark() and sweep() in a row and the ones that work in a shared situation would do it as Thomas noted. And we don&amp;#39;t want people to use the &amp;quot;lower-level APIs&amp;quot;.</comment>
                    <comment id="12747414" author="tmueller" created="Tue, 25 Aug 2009 14:56:08 +0100"  >New version. &lt;br/&gt;
&lt;br/&gt;
Backward compatibility: existing applications that cast Session to SessionImpl should still work.&lt;br/&gt;
The existing method in the GarbageCollector didn&amp;#39;t change, except &lt;br/&gt;
setSleepBetweenNodes, which is probably not used by most applications.&lt;br/&gt;
The new interface MarkEventListener is a subclass of ScanEventListener, so this is not a problem,&lt;br/&gt;
but adding a method to MarkEventListener would be a problem.&lt;br/&gt;
&lt;br/&gt;
gc(): while it&amp;#39;s possible to create a new method &amp;quot;gc() { mark(); sweep(); }&amp;quot;,&lt;br/&gt;
I think using two distinct methods shouldn&amp;#39;t be a problem. &lt;br/&gt;
Having separate method allows sharing the data store _storage_ among multiple repositories&lt;br/&gt;
(where the repositories can be on separate machines). With only gc() there is now way to&lt;br/&gt;
run garbage collection. With mark() and sweep(), it&amp;#39;s easy: rep1.mark(), rep2.mark(), &lt;br/&gt;
wait until both methods return, rep1.sweep(), rep1.close(), rep2.close().</comment>
                    <comment id="12750413" author="alexander.klimetschek" created="Wed, 2 Sep 2009 13:09:56 +0100"  >+1 for the new version&lt;br/&gt;
&lt;br/&gt;
I only noticed a small javadoc typo: in GarbageCollector.setScanEventListener it should probably be &amp;quot;@deprecated use setMarkEventListener().&amp;quot;</comment>
                    <comment id="12750452" author="jukkaz" created="Wed, 2 Sep 2009 15:28:58 +0100"  >Why do we need to modify JackrabbitSession for this? As discussed earlier, I&amp;#39;d be perfectly happy with a ManagedRepository interface with the createDataStoreGarbageCollector() method.&lt;br/&gt;
&lt;br/&gt;
Some other concerns:&lt;br/&gt;
&lt;br/&gt;
* I&amp;#39;d just put all the management interfaces in o.a.j.api.management, no need to create subpackages&lt;br/&gt;
&lt;br/&gt;
* I&amp;#39;d drop the DataStore part of the interface and method names, as in future we may well want to extend the mechanism to cover other uses, for example optimizing the search indexes or removing old journal records.&lt;br/&gt;
&lt;br/&gt;
* Do we really need the MarkEventListener mechanism? I can see how it can be useful in creating a nice progress bar display, but is having such a feature important enough to make the API more complex and thus noticeably limit implementation options? &lt;br/&gt;
&lt;br/&gt;
* The sleepBetweenNodes property seems really implementation specific. What if we later find out that a better way to control the impact of garbage collection is to for example use the Thread.setPriority() method? I&amp;#39;d rather not fix such implementation details in the API unless there&amp;#39;s a very good reason for having it there.&lt;br/&gt;
&lt;br/&gt;
* If we do the above, do we then need to expose a close() method on the garbage collector?&lt;br/&gt;
&lt;br/&gt;
As a summary, here&amp;#39;s what I&amp;#39;d expose as the *only* new interfaces and methods:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ManagedRepository repository = ...;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GarbageCollector collector = repository.getGarbageCollector();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collector.mark();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collector.sweep();&lt;br/&gt;
&lt;br/&gt;
This covers the basic use case while giving us maximum implementation flexibility. &lt;br/&gt;
</comment>
                    <comment id="12750464" author="tmueller" created="Wed, 2 Sep 2009 16:01:35 +0100"  >&amp;gt; Why do we need to modify JackrabbitSession for this&lt;br/&gt;
&lt;br/&gt;
To ensure the session is authorized. Otherwise how do you ensure only authorized users use the facility?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I&amp;#39;d just put all the management interfaces in o.a.j.api.management&lt;br/&gt;
&lt;br/&gt;
Ok, I don&amp;#39;t care.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I&amp;#39;d drop the DataStore part of the interface and method names&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s for the data store, so I think it makes sense to keep the name. But I don&amp;#39;t care that much. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Do we really need the MarkEventListener mechanism&lt;br/&gt;
&lt;br/&gt;
Yes, we do, it&amp;#39;s important. However I could document that it may return null if not supported by the given implementation.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The sleepBetweenNodes property seems really implementation specific&lt;br/&gt;
&lt;br/&gt;
You are right, it&amp;#39;s not that important. I will remove it.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; do we then need to expose a close() method on the garbage collector?&lt;br/&gt;
&lt;br/&gt;
Yes. The current implementation can add an observation listener, and this needs to be removed.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12750543" author="jukkaz" created="Wed, 2 Sep 2009 18:17:34 +0100"  >&amp;gt; To ensure the session is authorized. Otherwise how do you ensure only authorized users use the facility? &lt;br/&gt;
&lt;br/&gt;
By controlling access to the proposed ManagedRepository interface. My point is that management operations like garbage collection, shutdown, etc. should be outside the scope of normal client connections. This way we don&amp;#39;t need to invent new access control privileges for such operations.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; &amp;gt; Do we really need the MarkEventListener mechanism &lt;br/&gt;
&amp;gt; Yes, we do, it&amp;#39;s important.&lt;br/&gt;
&lt;br/&gt;
Why? Could we achieve the same use case with a simpler API?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The current implementation can add an observation listener, and this needs to be removed. &lt;br/&gt;
&lt;br/&gt;
Could the listener rather be passed as an argument to mark()?&lt;br/&gt;
&lt;br/&gt;
PS. My concerns are a -0, not a veto. I just want to ensure that we strike the best balance between exposed functionality and implementation flexibility. Anything we put in o.a.j.api is something that we most likely need to live with for at least the next 3-5 years.&lt;br/&gt;
</comment>
                    <comment id="12750548" author="tmueller" created="Wed, 2 Sep 2009 18:27:47 +0100"  >&amp;gt; By controlling access to the proposed ManagedRepository interface.&lt;br/&gt;
&lt;br/&gt;
And how do you do that? For the admin session, getRepository() returns a ManagedRepositoryImpl, and for non-admin sessions, it returns RepositoryImpl? That sounds like a weird solution. Access rights are &amp;#39;usually&amp;#39; bound to the user that is logged in (Repository.login()). This is true for the rest of Jackrabbit, and for other common APIs such as the JDBC API.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;  My point is that management operations like garbage collection, shutdown, etc. should be outside the scope of normal client connections.&lt;br/&gt;
&lt;br/&gt;
Why is that?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; This way we don&amp;#39;t need to invent new access control privileges for such operations.&lt;br/&gt;
&lt;br/&gt;
So you want to have a completely different access rights mechanism? Why?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; &amp;gt; &amp;gt; Do we really need the MarkEventListener mechanism&lt;br/&gt;
&amp;gt; &amp;gt; Yes, we do, it&amp;#39;s important.&lt;br/&gt;
&amp;gt; Why? &lt;br/&gt;
&lt;br/&gt;
I need it to do display the progress.  &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Could we achieve the same use case with a simpler API?&lt;br/&gt;
&lt;br/&gt;
Not as far as I know.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The current implementation can add an observation listener, and this needs to be removed.&lt;br/&gt;
&lt;br/&gt;
Could the listener rather be passed as an argument to mark()? &lt;br/&gt;
&lt;br/&gt;
The observation listener is an implementation detail of the garbage collector. The user of the API should have to deal with it.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; best balance&lt;br/&gt;
&lt;br/&gt;
Sure! API design is hard, and it&amp;#39;s always good if multiple people look at it.</comment>
                    <comment id="12750589" author="jukkaz" created="Wed, 2 Sep 2009 19:27:39 +0100"  >&amp;gt; And how do you do that? For the admin session, getRepository() returns a ManagedRepositoryImpl,&lt;br/&gt;
&amp;gt; and for non-admin sessions, it returns RepositoryImpl?&lt;br/&gt;
&lt;br/&gt;
Nope, the ManagedRepository (or perhaps some other name) interface would *not* extend javax.jcr.Repository and would not be implemented by the Repository instance. Only clients that have explicitly been given a ManagedRepository reference could access management operation like garbage collection, shutdown, backup, etc.&lt;br/&gt;
&lt;br/&gt;
Access to the ManagedRepository reference can be controlled by for example selectively making the JNDI reference available to applications that need such access, or for remote access for example by using the standard RMI or JMXMP access controls. The way I see it, access to such management features is more a configuration/deployment question than normal JCR authentication/authorization issue. Of course that&amp;#39;s just one point of view.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I need it to do display the progress.&lt;br/&gt;
&lt;br/&gt;
The API as proposed only tells what the collector is currently doing not how much work still remains. Is that enough?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; &amp;gt; Could we achieve the same use case with a simpler API? &lt;br/&gt;
&amp;gt; Not as far as I know.&lt;br/&gt;
&lt;br/&gt;
Does the MarkEventListener interface need to extend EventListener? Why do we need separate before/after events? Do the event methods need a Node argument, or would a path (or identifier) string be enough? Is the done() method needed or could the same information be inferred from the mark( ) method returning?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The observation listener is an implementation detail of the garbage collector. The user of the API should have to deal with it.&lt;br/&gt;
&lt;br/&gt;
Sorry, I misunderstood your earlier comment about the listener, I thought you referred tot he MarkEventListener instance. :-)&lt;br/&gt;
&lt;br/&gt;
I now see your point about the close() method, but couldn&amp;#39;t the sweep() method already release any reserved resources? AFAIK they&amp;#39;re not needed after sweep() returns.&lt;br/&gt;
</comment>
                    <comment id="12750611" author="tmueller" created="Wed, 2 Sep 2009 19:53:02 +0100"  >Could you provide code examples, and all interfaces required for your solution? How would a user get the DataStoreGarbageCollector object in a _standalone_ application using the JCR 2.0 API (not within an app server, no JNDI and such), and could you explain how this would be secure (so that only people with access right can get the object)? And what would be the advantage over my proposal?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; the standard RMI or JMXMP access controls&lt;br/&gt;
&lt;br/&gt;
Access control should stay within the Jackrabbit API I believe. Why would we have to &amp;#39;outsource&amp;#39; access control to such APIs?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The API as proposed only tells what the collector is currently doing not how much work still remains. Is that enough?&lt;br/&gt;
&lt;br/&gt;
Yes, this is enough.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Does the MarkEventListener interface need to extend EventListener?&lt;br/&gt;
&lt;br/&gt;
We can still discuss the details about this, let&amp;#39;s first solve the getDataStoreGarbageCollector problem.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I now see your point about the close() method, but couldn&amp;#39;t the sweep() method already release any reserved resources?&lt;br/&gt;
&lt;br/&gt;
No, because the user may not want to call sweep(). If multiple repositories share the same data store, garbage collection would work like this:&lt;br/&gt;
&lt;br/&gt;
rep1gc.mark()&lt;br/&gt;
rep2gc.mark()&lt;br/&gt;
rep3gc.mark()&lt;br/&gt;
rep1gc.sweep()&lt;br/&gt;
&lt;br/&gt;
(rep2gc.sweep() and rep3gc.sweep() must not be called, otherwise used objects may be deleted).&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12750636" author="jukkaz" created="Wed, 2 Sep 2009 20:59:15 +0100"  >&amp;gt; Could you provide code examples, and all interfaces required for your solution?&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s a quick example of how this could work:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ManagedRepository mr = new ManagedRepositoryImpl(RepositoryConfig.create(...));&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Accessing the repository through normal JCR API&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Repository  repository = mr.getRepository();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Getting an administrative session (see the similar Sling API)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Session admin = mr.loginAdministrative();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Collecting garbage&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GarbageCollector collector = mr.getGarbageCollector();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collector.mark();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collector.sweep();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collector.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Closing the repository&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mr.shutdown();&lt;br/&gt;
&lt;br/&gt;
The advantage of this approach over adding things to JackrabbitSession is that access control to such admin features becomes a deployment issue, not an authorization issue. We won&amp;#39;t need to extend the JCR access control mechanism with custom privileges like &amp;quot;garbage collection&amp;quot; or &amp;quot;repository shutdown&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; No, because the user may not want to call sweep()&lt;br/&gt;
&lt;br/&gt;
Good point.&lt;br/&gt;
</comment>
                    <comment id="12750857" author="tmueller" created="Thu, 3 Sep 2009 08:17:26 +0100"  >&amp;gt; ManagedRepository mr = new ManagedRepositoryImpl(RepositoryConfig.create(...)); &lt;br/&gt;
&lt;br/&gt;
Your solution is not JCR 2.0 spec compliant. According to the spec, page 77, creating a Repository object goes like this: RepositoryFactory.getRepository(Map parameters).&lt;br/&gt;
&lt;br/&gt;
ManagedRepositoryImpl is a class, not an interface. So the application would become dependent on a specific class. The point about APIs is to use interfaces if possible. Using classes directly in an application will again lead to problems, such as if you want to use the same application remotely, against another implementation, and so on.&lt;br/&gt;
&lt;br/&gt;
Your solution doesn&amp;#39;t include any access rights checks. How do you ensure only authorized users create a new ManagedRepositoryImpl or call getGarbageCollector? Let&amp;#39;s say the &amp;#39;configuration&amp;#39; (which is again a class and not an interface) points to a remote repository.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; The advantage of this approach over adding things to JackrabbitSession is that access control to such admin features becomes a deployment issue&lt;br/&gt;
&lt;br/&gt;
Sorry why would that be an advantage? For me that&amp;#39;s a disadvantage: you could not call garbage collection remotely for example.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; We won&amp;#39;t need to extend the JCR access control mechanism with custom privileges like &amp;quot;garbage collection&amp;quot; or &amp;quot;repository shutdown&amp;quot;. &lt;br/&gt;
&lt;br/&gt;
So you would need to create another access control mechanism. Why, if we already have one?&lt;br/&gt;
</comment>
                    <comment id="12750881" author="jukkaz" created="Thu, 3 Sep 2009 09:05:03 +0100"  >My point here is that operations like garbage collection are IMHO not something that a JCR client should be doing, especially when the implementation still doesn&amp;#39;t have any access controls and it relies on the client doing the right thing in the multi-repository case.&lt;br/&gt;
&lt;br/&gt;
Nothing that we expose through a client-visible API should be able to break the internal consistency of the repository.&lt;br/&gt;
&lt;br/&gt;
Note that the garbage collection operation is in principle a &amp;quot;safe&amp;quot; operation so I&amp;#39;m not totally opposed to putting it in a client-visible API, but until we either declare the multi-repository data store configuration as unsupported or solve the obvious safety issue with this API I&amp;#39;m quite reluctant to expose such functionality to all clients.&lt;br/&gt;
</comment>
                    <comment id="12750912" author="tmueller" created="Thu, 3 Sep 2009 09:47:46 +0100"  >I think for the caller it shouldn&amp;#39;t matter from _where_ the method is called (client or server side). The implementation itself may throw an exception if not implemented however.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; the implementation still doesn&amp;#39;t have any access controls&lt;br/&gt;
&lt;br/&gt;
The current implementation in Jackrabbit doesn&amp;#39;t check access rights, that&amp;#39;s true. Of course we could implement it. In any case, an access rights check can be implemented in a subclass.&lt;br/&gt;
&lt;br/&gt;
Thinking about &amp;#39;shutdown&amp;#39;, what if we instead use instead:&lt;br/&gt;
&lt;br/&gt;
// subject to access rights restrictions and availability&lt;br/&gt;
JackrabbitSession.getManagedRepository()&lt;br/&gt;
&lt;br/&gt;
interface ManagedRepository {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;getDataStoreGarbageCollector();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;shutdown();&lt;br/&gt;
}&lt;br/&gt;
</comment>
                    <comment id="12750922" author="tmueller" created="Thu, 3 Sep 2009 10:01:14 +0100"  >I believe we should have a solution for Jackrabbit 2.0</comment>
                    <comment id="12750923" author="jukkaz" created="Thu, 3 Sep 2009 10:03:50 +0100"  >&amp;gt; Of course we could implement it.&lt;br/&gt;
&lt;br/&gt;
I would consider that a blocker for this issue unless we come up with some other way to prevent potential data loss in the multi-repository case.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Thinking about &amp;#39;shutdown&amp;#39;&lt;br/&gt;
&lt;br/&gt;
IMHO the shutdown operation should only be available to someone who can also start the repository. The ManagedRepository idea makes this possible, it could have both a startup() and a shutdown() method for controlling the full lifecycle of the repository. But then the ManagedRepository reference can not be something that you only can get to through an already running repository!&lt;br/&gt;
&lt;br/&gt;
But that&amp;#39;s another discussion...</comment>
                    <comment id="12750936" author="tmueller" created="Thu, 3 Sep 2009 10:35:09 +0100"  >Again, according to the spec, creating a Repository object is done using RepositoryFactory.getRepository(Map parameters). I do think Jackrabbit should be spec compliant. So far I don&amp;#39;t see how your solution could be spec compliant.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; the shutdown operation should only be available to someone who can also start the repository&lt;br/&gt;
&lt;br/&gt;
How would you solve this problem, while staying spec compliant?&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12751071" author="jukkaz" created="Thu, 3 Sep 2009 17:11:23 +0100"  >I branched the general discussion about a management API to the dev@ list. Let&amp;#39;s focus on the specific garbage collection issue here.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m ready to accept the JackrabbitSession.createGarbageCollector() approach. However, the following concerns still stand:&lt;br/&gt;
&lt;br/&gt;
* How do we protect against the multi-repository sweep() issue? I would be fine either with simply not supporting such deployments, or with enforcing administrator-only access to the garbage collection feature.&lt;br/&gt;
&lt;br/&gt;
* Does the MarkEventListener interface need to extend EventListener?&lt;br/&gt;
&lt;br/&gt;
* Do we need separate before/after events?&lt;br/&gt;
&lt;br/&gt;
* Do the event methods need a Node argument, or would a path (or identifier) string be enough?&lt;br/&gt;
&lt;br/&gt;
* Is the done() event needed or could the same information be inferred from the mark() method returning? &lt;br/&gt;
</comment>
                    <comment id="12753641" author="tmueller" created="Thu, 10 Sep 2009 15:46:22 +0100"  >This new patch introduces the management API.&lt;br/&gt;
&lt;br/&gt;
Other changes: MarkEventListener no longer extends EventListener and only has a &amp;#39;before&amp;#39; method. I kept the Node argument, a &amp;quot;String path&amp;quot; would be fine as well for me, probably even better would be a &amp;quot;String location&amp;quot; argument (the path when using a traversal, and the node id when using IterablePersistenceManager).</comment>
                    <comment id="12753644" author="tmueller" created="Thu, 10 Sep 2009 15:52:23 +0100"  >This includes a RepositoryManagerImpl, however only for the RepositoryFactoryImpl which always seems to return a TransientRepository. The method createDataStoreGarbageCollector may only be called if the repository is started.</comment>
                    <comment id="12754878" author="jukkaz" created="Mon, 14 Sep 2009 09:54:14 +0100"  >I have a few suggestions for improvements, but it&amp;#39;s easier to do that in patch form as they&amp;#39;re just minor tweaks.&lt;br/&gt;
&lt;br/&gt;
+1 to committing the latest patches (v3). I&amp;#39;ll then follow up with my proposals.</comment>
                </comments>
                    <attachments>
                    <attachment id="12417617" name="api_2.patch" size="7440" author="tmueller" created="Tue, 25 Aug 2009 14:56:08 +0100" />
                    <attachment id="12419181" name="api-3.patch" size="11326" author="tmueller" created="Thu, 10 Sep 2009 15:46:21 +0100" />
                    <attachment id="12394240" name="api.patch" size="6325" author="tmueller" created="Wed, 19 Nov 2008 11:08:17 +0000" />
                    <attachment id="12417618" name="core_2.patch" size="20151" author="tmueller" created="Tue, 25 Aug 2009 14:56:08 +0100" />
                    <attachment id="12419182" name="core-3.patch" size="30064" author="tmueller" created="Thu, 10 Sep 2009 15:52:23 +0100" />
                    <attachment id="12394239" name="core.patch" size="11923" author="tmueller" created="Wed, 19 Nov 2008 11:07:49 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 19 Nov 2008 13:23:05 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142893</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>280029</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>