<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 05:53:52 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-1337/JCR-1337.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-1337] Optimize first execution queries for DescendantSelfAxisWeight/ChildAxisQuery</title>
                <link>https://issues.apache.org/jira/browse/JCR-1337</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>The first execution of a query involving DescendantSelfAxisWeight/ChildAxisQuery is slow. Consecutive queries are faster because the hierarchy is cached</description>
                <environment></environment>
            <key id="12386879">JCR-1337</key>
            <summary>Optimize first execution queries for DescendantSelfAxisWeight/ChildAxisQuery</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="-1">Unassigned</assignee>
                                <reporter username="aschrijvers">Ard Schrijvers</reporter>
                        <labels>
                    </labels>
                <created>Tue, 22 Jan 2008 19:58:10 +0000</created>
                <updated>Thu, 26 Feb 2009 13:19:24 +0000</updated>
                    <resolved>Fri, 25 Jan 2008 14:13:31 +0000</resolved>
                            <version>1.4</version>
                                <fixVersion>core 1.4.9</fixVersion>
                <fixVersion>1.5</fixVersion>
                                <component>query</component>
                        <due></due>
                    <votes>0</votes>
                        <watches>0</watches>
                                                    <comments>
                    <comment id="12561448" author="aschrijvers" created="Tue, 22 Jan 2008 20:11:00 +0000"  >When per-document payloads and unique doc ids are implemented in lucene, we might be able to optimize the hierarchical cache, because we might base it on uid instead of the current doc id (based on uid, we might keep the hierarchical cache intact for ever, even after segment merges and pre-warming / caching will be trivial)&lt;br/&gt;
&lt;br/&gt;
See dev list lucene mail about the subject:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200801.mbox/%3c4795CE64.6090206@gmail.com%3e&quot;&gt;http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200801.mbox/%3c4795CE64.6090206@gmail.com%3e&lt;/a&gt;</comment>
                    <comment id="12561625" author="mreutegg" created="Wed, 23 Jan 2008 10:26:03 +0000"  >In the meantime we could also initialize the cache when the index reader is created.</comment>
                    <comment id="12561626" author="mreutegg" created="Wed, 23 Jan 2008 10:28:17 +0000"  >Proposed patch.</comment>
                    <comment id="12561627" author="aschrijvers" created="Wed, 23 Jan 2008 10:43:48 +0000"  >That is a quick you patch have there :-) &lt;br/&gt;
&lt;br/&gt;
Looks like a useful optimization, i only have concerns in its current form:&lt;br/&gt;
&lt;br/&gt;
IIUC, merging of 2 indexes also introduces a new CachingIndexReader: if the new formed index is *large*, initializeParents(delegatee) might consume a lot of time and cpu. Therefor a background thread (with low priority) might be better, or would this again impose synchronization problems perhaps?&lt;br/&gt;
&lt;br/&gt;
Also, since this patch is only pre-warming newly created CachingIndexReaders, and initializes its parents, it does still imply slow uncached queries when 2 large indexes merge and create a new CachingIndexReaders. These two indexes might contains *many parents* of lucene docs residing in other segments, which obviously are not re-warmed (strange non-existing word, but hopefully clear :-) ), so still having not the hierarchical cache up2date.&lt;br/&gt;
&lt;br/&gt;
Think this patch is an improvement, but does not cover the entire pre-warming issue and might lead to hickups for large index merges. &lt;br/&gt;
&lt;br/&gt;
Perhaps a nonstop background thread with low priority from time to time updating the hierarchical cache would be more efficient. OTOH, with low priority threads we are pretty much jvm dependant on how they are handled, isn&amp;#39;t? &lt;br/&gt;
&lt;br/&gt;
WDYT?</comment>
                    <comment id="12561664" author="mreutegg" created="Wed, 23 Jan 2008 13:17:52 +0000"  >I already had those changes in my checkout ;)&lt;br/&gt;
&lt;br/&gt;
Populating the cache is quite fast. On my machine I&amp;#39;m able to initialize the cache at a rate of 180k nodes a second. But you are right the tough work still is to resolve DocIds that point to other segments. I&amp;#39;d argue that those DocIds are only a fraction, unless you have an application that heavily modifies existing content.</comment>
                    <comment id="12561665" author="mreutegg" created="Wed, 23 Jan 2008 13:19:36 +0000"  >I&amp;#39;ve added logging information to the CachingIndexReader, which now write the percentage of UUIDDocIds.</comment>
                    <comment id="12561669" author="aschrijvers" created="Wed, 23 Jan 2008 13:32:31 +0000"  >180k  nodes a sec is really fast, but might also be in your test setup where the parent ids are not scattered around over many different indexes. It might get quite a bit slower then isn&amp;#39;t?  Even if  2 large indexes merge, the amount of time needed for pre-warming is small compared to the time taken for merging I suppose? &lt;br/&gt;
&lt;br/&gt;
&amp;gt; I&amp;#39;ve added logging information to the CachingIndexReader, which now write the percentage of UUIDDocIds&lt;br/&gt;
&lt;br/&gt;
This is nice info to monitor!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12561680" author="mreutegg" created="Wed, 23 Jan 2008 13:48:56 +0000"  >Reading the parent information is independent of how the ids are distributed. The read is fast because there is no random access involved. The lucene documents can be read sequentially from disk.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; ... pre-warming is small compared to the time taken for merging I suppose?&lt;br/&gt;
&lt;br/&gt;
yes, I think that&amp;#39;s correct. On my machine indexes are merged at about 10k nodes per second. Though merging is completely done in the background, while initializing the cache (using the current patch) is done by the first thread that accesses the new index segment after the merge.</comment>
                    <comment id="12561686" author="aschrijvers" created="Wed, 23 Jan 2008 13:59:01 +0000"  >&amp;quot;Reading the parent information is independent of how the ids are distributed. The read is fast because there is no random access involved. The lucene documents can be read sequentially from disk. &amp;quot;&lt;br/&gt;
&lt;br/&gt;
But if the number of foreignParents becomes larger (through many node updates for example) then looking up parent information and thus pre-warming becomes slower, or am i missing something? If&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;else if (info.parent != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;foreignParents++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;parents[info.docId] = DocId.create(info.parent);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} &lt;br/&gt;
&lt;br/&gt;
needs to be executed more often I suppose the initializeParents becomes slower. Either I am missing something or my previous comment was unclear.&lt;br/&gt;
&lt;br/&gt;
&amp;quot;On my machine indexes are merged at about 10k nodes per second. Though merging is completely done in the background, while initializing the cache (using the current patch) is done by the first thread that accesses the new index segment after the merge.&amp;quot; &lt;br/&gt;
&lt;br/&gt;
Might background pre-warming be an option? </comment>
                    <comment id="12561696" author="mreutegg" created="Wed, 23 Jan 2008 14:44:29 +0000"  >&amp;gt; But if the number of foreignParents becomes larger (through many node updates for example) then looking up parent&lt;br/&gt;
&amp;gt; information and thus pre-warming becomes slower, or am i missing something?&lt;br/&gt;
&lt;br/&gt;
the only difference between DocId.create(String) and DocId.create(int) is parsing the uuid string. I&amp;#39;m not sure how significant that is. It is certainly slower than the int variant, but it&amp;#39;s much less called.</comment>
                    <comment id="12561698" author="mreutegg" created="Wed, 23 Jan 2008 14:57:53 +0000"  >&amp;gt; Might background pre-warming be an option?&lt;br/&gt;
&lt;br/&gt;
Done. The index merger thread forces initialization of the CachingIndexReader before the index segments are replaced.</comment>
                    <comment id="12561699" author="aschrijvers" created="Wed, 23 Jan 2008 14:58:42 +0000"  >&amp;gt;the only difference between DocId.create(String) and DocId.create(int) is parsing the uuid string. I&amp;#39;m not sure how significant that is. It is certainly &amp;gt;slower than the int variant, but it&amp;#39;s much less called.&lt;br/&gt;
&lt;br/&gt;
Ooow, that is certainly not what i meant (i am certainly not pushing on the difference between parsing a uuid string and just an int!! ): I thought that for building the hierarchy cache in your pre-warming the getDocumentNumber(MultiIndexReader reader) in DocId.UUIDDocId was also executed. I scanned your patch and must have interpreted it incorrectly (also because I assumed it would do some parts regarding looking up parents). I assumed it would call the &amp;#39;expensive&amp;#39;  getDocumentNumber(MultiIndexReader reader).... I am a little puzzled ATM how it works, and what is pre-warmed. I just need to test your patch because I am clearly off track. Disregard my remarks, I&amp;#39;ll try to find some time to take a better look. Sry for any confusion</comment>
                    <comment id="12561700" author="aschrijvers" created="Wed, 23 Jan 2008 15:03:53 +0000"  >&amp;gt;Done. The index merger thread forces initialization of the CachingIndexReader before the index segments are replaced.&lt;br/&gt;
&lt;br/&gt;
having a hard time keep up with you :-)  I&amp;#39;ll try your patch tomorrow evening. Curious about the statistics, I&amp;#39;ll keep yo posted&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12562407" author="mreutegg" created="Fri, 25 Jan 2008 09:05:28 +0000"  >I&amp;#39;m sorry, that&amp;#39;s probably my fault. I didn&amp;#39;t describe the patch well enough.&lt;br/&gt;
&lt;br/&gt;
The UUIDDocIds are not resolved when the cache is filled. The pre-warming is limited to creating the DocId instances. Because most DocIds are PlainDocIds, which do not need to be resolved, the pre-warming is quite effective IMO.</comment>
                    <comment id="12562409" author="aschrijvers" created="Fri, 25 Jan 2008 09:13:54 +0000"  >&amp;quot;Because most DocIds are PlainDocIds, which do not need to be resolved, the pre-warming is quite effective IMO&amp;quot;&lt;br/&gt;
&lt;br/&gt;
Yes I already figured this out. It is indeed effective as long as the indexes have not very many deleted/updated nodes (when the number of parent nodes in foreign segment grows).  I agree this is an easy first iteration optimization. Also, when the number of foreign parent might get very high, users good choose to recreate the index by deleting it (if it is an option ofcourse :-) )&lt;br/&gt;
&lt;br/&gt;
I think that when Lucene would have support for uid in the future, we might also be able to pre-warm the parents when they are in different indexes. &lt;br/&gt;
&lt;br/&gt;
+1 for your patch (though i have not yet had time to test performance gain. Still try to find some time for it soon)</comment>
                    <comment id="12562496" author="mreutegg" created="Fri, 25 Jan 2008 13:46:54 +0000"  >Applied most recent patch in revision: 615223.&lt;br/&gt;
&lt;br/&gt;
Ard, are you OK with setting this issue to fixed? I think once there are more features available in lucene we can create new jira issue.</comment>
                    <comment id="12562509" author="aschrijvers" created="Fri, 25 Jan 2008 14:10:01 +0000"  >I am ok with it. Not sure either when and how exactly Lucene will add the uid feature. If it makes it to a release,  we can indeed create an issue to make advantage of it&lt;br/&gt;
&lt;br/&gt;
Do you close the issue? </comment>
                    <comment id="12562512" author="mreutegg" created="Fri, 25 Jan 2008 14:13:31 +0000"  >Forgot to commit new class FieldSelectors. Done in revision: 615227.</comment>
                    <comment id="12676987" author="mreutegg" created="Thu, 26 Feb 2009 13:19:24 +0000"  >Merged into 1.4 branch together with changes from &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-1884&quot; title=&quot;CachingIndexReader.initializeParents() does not scale well with large indexes&quot;&gt;&lt;strike&gt;JCR-1884&lt;/strike&gt;&lt;/a&gt; in revision: 748135</comment>
                </comments>
                    <attachments>
                    <attachment id="12373834" name="JCR-1337.patch" size="6738" author="mreutegg" created="Wed, 23 Jan 2008 14:57:53 +0000" />
                    <attachment id="12373823" name="JCR-1337.patch" size="5705" author="mreutegg" created="Wed, 23 Jan 2008 13:19:36 +0000" />
                    <attachment id="12373815" name="JCR-1337.patch" size="5167" author="mreutegg" created="Wed, 23 Jan 2008 10:28:16 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>3.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 23 Jan 2008 10:26:03 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>142643</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>192723</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>