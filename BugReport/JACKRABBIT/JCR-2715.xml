<!-- 
RSS generated by JIRA (5.2.8#851-sha1:3262fdc28b4bc8b23784e13eadc26a22399f5d88) at Sat Jul 27 06:01:58 UTC 2013

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/JCR-2715/JCR-2715.xml?field=key&field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>5.2.8</version>
        <build-number>851</build-number>
        <build-date>26-02-2013</build-date>
    </build-info>

<item>
            <title>[JCR-2715] Improved join query performance</title>
                <link>https://issues.apache.org/jira/browse/JCR-2715</link>
                <project id="10591" key="JCR">Jackrabbit Content Repository</project>
                        <description>Our current implementation of SQL2 join queries does not perform very well on pretty much any non-trivial data set.</description>
                <environment></environment>
            <key id="12471697">JCR-2715</key>
            <summary>Improved join query performance</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                    <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png">Closed</status>
                    <resolution id="1">Fixed</resolution>
                                <assignee username="jukkaz">Jukka Zitting</assignee>
                                <reporter username="jukkaz">Jukka Zitting</reporter>
                        <labels>
                    </labels>
                <created>Mon, 16 Aug 2010 15:13:43 +0100</created>
                <updated>Tue, 8 Nov 2011 15:52:03 +0000</updated>
                    <resolved>Tue, 30 Nov 2010 10:12:39 +0000</resolved>
                                            <fixVersion>2.2</fixVersion>
                                <component>jackrabbit-core</component>
                <component>query</component>
                        <due></due>
                    <votes>2</votes>
                        <watches>3</watches>
                                                    <comments>
                    <comment id="12905029" author="jukkaz" created="Wed, 1 Sep 2010 15:01:40 +0100"  >I&amp;#39;m currently working on this, targeting the 2.2 release. The optimization plan I&amp;#39;m following is:&lt;br/&gt;
&lt;br/&gt;
1. Map single-selector queries directly to underlying Lucene queries, like we&amp;#39;ve so far done for XPath and SQL1&lt;br/&gt;
2. Split join queries into a set of per-selector queries, and combine these partial results into the join result set&lt;br/&gt;
3. When splitting join queries, use the results of the already executed left component query to turn the join condition into an extra constraint for the right component query</comment>
                    <comment id="12920495" author="bhillou" created="Wed, 13 Oct 2010 11:02:35 +0100"  >We are seeing this issue also, so we would be very interested in the work you are doing. Is there anything already available to test ?&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12921338" author="bhillou" created="Fri, 15 Oct 2010 14:09:33 +0100"  >If I understand this ticket properly, this doesn&amp;#39;t only happen for join queries but for all SQL-2 queries no ?&lt;br/&gt;
&lt;br/&gt;
In the first solution, do you mean you intend to map the single selector queries along with using BooleanQuery objects to map constraints directly to the underlying Lucene query ?&lt;br/&gt;
&lt;br/&gt;
Anyway, I&amp;#39;d be willing to help anyway possible as this is become the biggest performance issue we are seeing in testing Jackrabbit with non-trivial data sets and loads.&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12922030" author="jukkaz" created="Mon, 18 Oct 2010 10:34:12 +0100"  >Sorry about the delay on this, and thanks for the offer to help in testing! I&amp;#39;ll start pushing my changes to svn now.</comment>
                    <comment id="12922058" author="bhillou" created="Mon, 18 Oct 2010 13:51:51 +0100"  >Thank you for your reply, I will pull the changes from SVN, test it and give you feedback. &lt;br/&gt;
&lt;br/&gt;
I am using another unit test that does a lot of concurrent read, writes and searches. Maybe this is something I could contribute but it is not yet generic to Jackrabbit and currently has dependencies t our product. Basically we are testing with larger loads than the currently available tests do.&lt;br/&gt;
&lt;br/&gt;
Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12922469" author="bhillou" created="Tue, 19 Oct 2010 08:30:20 +0100"  >Hello Jukka, &lt;br/&gt;
&lt;br/&gt;
I see you have been committing quite a lot of changes yesterday. Thank you very much ! I have been looking at the changes. Do you still have more to commit ? I have some trouble understanding how it works currently, as there seems to be no references to the QueryEngine in the code. I&amp;#39;m assuming you haven&amp;#39;t &amp;quot;glued&amp;quot; it together yet, is that correct or that you will commit this soon ? Did I miss something ? &lt;br/&gt;
&lt;br/&gt;
Best regards, &lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12922476" author="jukkaz" created="Tue, 19 Oct 2010 08:55:08 +0100"  >Yes, I&amp;#39;m still working on fixing some remaining issues before I plug the new implementation in as the QueryObjectModelImpl.execute() method. I also have some pending work on tighter integrating the new join query code with the underlying Lucene index so we can avoid the extra layer of SQL1 queries that the implementation now uses.&lt;br/&gt;
&lt;br/&gt;
For now it&amp;#39;s possible to use this implementation by directly instantiating the QueryEngine class like this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;QueryObjectModel qom = ...;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;QueryResult result  = new QueryEngine(session).execute(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;qom.getColumns(), qom.getSource(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;qom.getConstraint(), qom.getOrderings());&lt;br/&gt;
</comment>
                    <comment id="12922595" author="jukkaz" created="Tue, 19 Oct 2010 16:44:49 +0100"  >As of revision 1024283 the new join implementation has been hooked up for handling inner equi-joins. Support for other join types still requires more work, and I still need to add the tighter Lucene integration.</comment>
                    <comment id="12922872" author="bhillou" created="Wed, 20 Oct 2010 07:50:03 +0100"  >Thanks for all the work ! I&amp;#39;ve tested the QueryEngine and results do indeed seem to be faster, although I had an issue I&amp;#39;m not sure is due to my code regarding reading results twice.&lt;br/&gt;
&lt;br/&gt;
Also, concerning limits, do they currently work with sorting ? If I limit to 100 results, will it be the sorted 100 first results ? Or is sorting done after limiting ?&lt;br/&gt;
&lt;br/&gt;
Let me know how I can help,&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12922972" author="jukkaz" created="Wed, 20 Oct 2010 15:02:36 +0100"  >Good point about the limits! The current code applies limits before sorting, which is obviously wrong. I&amp;#39;ll fix that.</comment>
                    <comment id="12923846" author="bhillou" created="Fri, 22 Oct 2010 14:07:25 +0100"  >Hi Jukka, &lt;br/&gt;
&lt;br/&gt;
I just tested the latest commits, and it&amp;#39;s looking quite good. I only saw 2 tests that don&amp;#39;t seem to work yet, but I&amp;#39;m assuming you&amp;#39;re already aware of this ? &lt;br/&gt;
&lt;br/&gt;
EquiJoinConditionTest&lt;br/&gt;
&lt;br/&gt;
	testInnerJoin1(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest)	0.692&lt;br/&gt;
	testInnerJoin2(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest)	0.608&lt;br/&gt;
	testRightOuterJoin1(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest) + [ Detail ]	0.138&lt;br/&gt;
|/testroot/node1| is not part of the result set	&lt;br/&gt;
	testRightOuterJoin2(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest)	0.09&lt;br/&gt;
	testLeftOuterJoin1(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest)	0.103&lt;br/&gt;
	testLeftOuterJoin2(org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest) + [ Detail ]	0.071&lt;br/&gt;
/testroot/node1|| is not part of the result set	&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12933438" author="bhillou" created="Thu, 18 Nov 2010 14:33:35 +0000"  >Hello Jukka,&lt;br/&gt;
&lt;br/&gt;
I was going over some performance tests, and I was wondering if the new code could be used for general SQL-2 queries ? I noticed that in the QueryObjectModelImpl we have the following check in the execute method: &lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (JCR_JOIN_TYPE_INNER.equals(join.getJoinType())&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; join.getJoinCondition() instanceof EquiJoinCondition) {&lt;br/&gt;
&lt;br/&gt;
But in the execution of the query engine we seem to be able to handle non-join cases in an optimized way that delegates back to the SQL-1 implementation.&lt;br/&gt;
&lt;br/&gt;
Because it seems that in the case of simple queries like SELECT * FROM [nt:base] where CONDITION we are still going through non-optimized code that checks the constraints after loading all the results from Lucene.&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12935371" author="jukkaz" created="Wed, 24 Nov 2010 15:54:09 +0000"  >There are still a few failing TCK tests with the new SQL2 query engine. I&amp;#39;ll remove the extra condition from the code once I&amp;#39;ve fixed all those tests.</comment>
                    <comment id="12935375" author="bhillou" created="Wed, 24 Nov 2010 16:02:57 +0000"  >Ok nice to know. Do you think this can be done for 2.2.0 ?&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12935378" author="jukkaz" created="Wed, 24 Nov 2010 16:07:08 +0000"  >Yes, I&amp;#39;m still targeting 2.2.0 for having this fully resolved.</comment>
                    <comment id="12935379" author="bhillou" created="Wed, 24 Nov 2010 16:08:53 +0000"  >Great ! Thanks a lot. I&amp;#39;ll be away in the next few days but I&amp;#39;ll test it as soon as possible.</comment>
                    <comment id="12964560" author="jukkaz" created="Sun, 28 Nov 2010 15:07:13 +0000"  >I fixed the last TCK test failures in revision 1039888 and enabled the new implementation for all QOM and SQL2 queries. There&amp;#39;s still some minor cleanup, documentation and testing to be done, but overall the implementation should now be ready for release.</comment>
                    <comment id="12965183" author="jukkaz" created="Tue, 30 Nov 2010 10:11:59 +0000"  >See the attached graphs for the achieved performance improvements. That&amp;#39;s two orders of magnitude (from 1341ms to 10ms) for a two-way join, and almost as much (from 1851ms to 90ms) for a three-way join.</comment>
                    <comment id="12965184" author="jukkaz" created="Tue, 30 Nov 2010 10:12:39 +0000"  >Resolving as fixed.</comment>
                    <comment id="12965187" author="bhillou" created="Tue, 30 Nov 2010 10:20:33 +0000"  >Great improvements, thanks a lot. Did you also test simple (non join) SQL-2 performance as you also improved this part ? I wanted to run these tests but as I am traveling I probably won&amp;#39;t be able to do so until next week.&lt;br/&gt;
&lt;br/&gt;
Best Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12965191" author="jukkaz" created="Tue, 30 Nov 2010 10:47:27 +0000"  >Yes, also non-join SQL2 query performance is now significantly better. The attached SQL2SearchTest graph shows the performance of a simple non-join SQL2 query that selects 100 nodes out of a set of 10k nodes using a simple property constraint. The performance improvement is pretty impressive, from 9740ms to 189ms per 100 queries.</comment>
                    <comment id="12965201" author="bhillou" created="Tue, 30 Nov 2010 11:18:41 +0000"  >Very impressive indeed ! Thanks for answering so fast :)&lt;br/&gt;
&lt;br/&gt;
Best Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber</comment>
                    <comment id="12965248" author="clemensdev" created="Tue, 30 Nov 2010 14:58:17 +0000"  >I see big improvements too :-) thanks!&lt;br/&gt;
&lt;br/&gt;
BUT I have some real world examples where a simple sql2 queries perform very bad compared to their sql1 pendants. The query .&lt;br/&gt;
&lt;br/&gt;
SQL1:&lt;br/&gt;
select * from project order by jcr:score&lt;br/&gt;
returns 1&amp;#39;126 nodes and takes 84ms :-)&lt;br/&gt;
&lt;br/&gt;
SQL2:&lt;br/&gt;
select * from [project] order by [jcr:score]&lt;br/&gt;
returns 1&amp;#39;126 nodes and takes 600ms , absolutely seen still ok, but compared to the sql1 execution time&lt;br/&gt;
&lt;br/&gt;
SQL1: &lt;br/&gt;
select * from task order by jcr:score&lt;br/&gt;
returns 76&amp;#39;281 nodes/rows and takes ~1.5s :-)&lt;br/&gt;
&lt;br/&gt;
SQL2:&lt;br/&gt;
select * from [task] order by [jcr:score]&lt;br/&gt;
returns 76&amp;#39;281 nodes/rows and takes, fasten your seat belt, ~95s (!) :-(&lt;br/&gt;
&lt;br/&gt;
My test where performed with the latest-greatest JR sources (2.3 SNAPSHOT)</comment>
                    <comment id="12965256" author="bhillou" created="Tue, 30 Nov 2010 15:15:06 +0000"  >Hello Clement,&lt;br/&gt;
&lt;br/&gt;
Thank you for the feedback. Could you provide more information about your tests ? Maybe there is something that can be put into a unit test so that performance analysis is easier to reproduce ? Or at the minimum the CND ? &lt;br/&gt;
&lt;br/&gt;
Best Regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber</comment>
                    <comment id="12965257" author="clemensdev" created="Tue, 30 Nov 2010 15:23:42 +0000"  >As I have no special node types (cnd)&lt;br/&gt;
&lt;br/&gt;
...&lt;br/&gt;
[project] &amp;gt; nt:unstructured, mix:shareable&lt;br/&gt;
[task] &amp;gt; nt:unstructured, mix:shareable&lt;br/&gt;
...&lt;br/&gt;
&lt;br/&gt;
my guess is that it has to do with the &amp;quot;amount of nodes&amp;quot; being returned/looked up...</comment>
                    <comment id="12965259" author="bhillou" created="Tue, 30 Nov 2010 15:31:39 +0000"  >Ok thanks. &lt;br/&gt;
&lt;br/&gt;
It is plausible that the number of results if affecting performance because from previous traces I saw that some constraints seemed to be evaluated on the results. But I didn&amp;#39;t get around to testing the latest code yet. Would it be possible for your to capture some snapshots with Yourkit or an equivalent ?&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber</comment>
                    <comment id="12965273" author="clemensdev" created="Tue, 30 Nov 2010 16:24:03 +0000"  >jRat output. Hope this helps...?</comment>
                    <comment id="12965284" author="jukkaz" created="Tue, 30 Nov 2010 16:46:46 +0000"  >Did you measure just the query.execute() time or also the time it takes to iterate over the results? The SQL2/QOM implementation loads all matching rows into memory during the execute() call, so you&amp;#39;ll see an expensive query.execute() but can then very quickly iterate over the query results.</comment>
                    <comment id="12965287" author="clemensdev" created="Tue, 30 Nov 2010 16:50:41 +0000"  >just the query.execute() time...</comment>
                    <comment id="12966965" author="bhillou" created="Sun, 5 Dec 2010 15:18:37 +0000"  >Thanks Clemens for the JRat data.&lt;br/&gt;
&lt;br/&gt;
From looking at it seems that the sorting of the results is taking up the most time, so I wonder how the sorting is done in the case of the SQL-1 implementation ?&lt;br/&gt;
&lt;br/&gt;
Jukka, is there a reason why we load all the data in the SQL-2/QOM implementations at query execution time ?&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge... </comment>
                    <comment id="12967005" author="jukkaz" created="Sun, 5 Dec 2010 19:10:19 +0000"  >&amp;gt; Jukka, is there a reason why we load all the data in the SQL-2/QOM implementations at query execution time?&lt;br/&gt;
&lt;br/&gt;
The SQL2/JQOM code needs to take joins and some new constraint types into account, which makes it easiest to simply load the full result set into memory during execute(). In practice this only causes problems when your query matches lots of rows but you&amp;#39;re only interested in some of them (see &lt;a href=&quot;https://issues.apache.org/jira/browse/JCR-2830&quot; title=&quot;JCR-SQL2 : Query on large node-set is (too) slow even when offset and limit is used&quot;&gt;JCR-2830&lt;/a&gt;).&lt;br/&gt;
</comment>
                    <comment id="12967111" author="bhillou" created="Mon, 6 Dec 2010 07:27:06 +0000"  >Hello Jukka, &lt;br/&gt;
&lt;br/&gt;
Thanks for clarifying this. But it seems to me that a lot of developers will generate such queries. I&amp;#39;ll continue on the other ticket anyway, so that we can close this one.&lt;br/&gt;
&lt;br/&gt;
Best regards,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Serge Huber.</comment>
                    <comment id="12985105" author="my1234" created="Sat, 22 Jan 2011 13:06:04 +0000"  >Hello&lt;br/&gt;
&lt;br/&gt;
i have attached a script.&lt;br/&gt;
&lt;br/&gt;
The execution gives different results in the new implemention and the old one(before 2.2).&lt;br/&gt;
Also some annotiations:&lt;br/&gt;
With large Nodeset in the left Side of left outer join the executiontime is very big. (Minutes)&lt;br/&gt;
&lt;br/&gt;
This query is not possible:&lt;br/&gt;
Select * from [sling:SamplePage] as c left outer join [sling:SampleContent] as a on ISDESCENDANTNODE(a,c) where contains(c.key1,&amp;#39;value1&amp;#39;) or contains(a.key1,&amp;#39;value1&amp;#39;)&lt;br/&gt;
I think this is a correct query and in the old implementation it works.&lt;br/&gt;
&lt;br/&gt;
I have also attached an hacked SQL2-Code from 2.1.&lt;br/&gt;
&lt;br/&gt;
This implementation is very fast and gives the same Results as before 2.2.&lt;br/&gt;
You can dropin this in 2.3-Source tree and it works&lt;br/&gt;
&amp;nbsp;</comment>
                    <comment id="12985111" author="my1234" created="Sat, 22 Jan 2011 13:33:33 +0000"  >The groovy script  runs in Sling&lt;br/&gt;
&lt;br/&gt;
the expected output&lt;br/&gt;
&lt;br/&gt;
Output(2.2)&lt;br/&gt;
(contact1)|(activity1)|&lt;br/&gt;
&lt;br/&gt;
Output(2.3)&lt;br/&gt;
(contact1)|activity1)|&lt;br/&gt;
(contact2)||&lt;br/&gt;
(contact3)||&lt;br/&gt;
&lt;br/&gt;
</comment>
                    <comment id="12985112" author="my1234" created="Sat, 22 Jan 2011 13:35:19 +0000"  >Testing joins in jackrabbit 2.1 and 2.3</comment>
                    <comment id="12985113" author="my1234" created="Sat, 22 Jan 2011 13:38:18 +0000"  >Hacked SQL2-Code from Jackrabbit 2.1&lt;br/&gt;
can be used in 2.3.&lt;br/&gt;
&lt;br/&gt;
Performance improvend</comment>
                </comments>
                    <attachments>
                    <attachment id="12464966" name="2010-11-30_PM-04-55-23.zip" size="1493836" author="clemensdev" created="Tue, 30 Nov 2010 16:24:03 +0000" />
                    <attachment id="12469044" name="org.apache.jackrabbit.core.query.tgz" size="249361" author="my1234" created="Sat, 22 Jan 2011 13:38:18 +0000" />
                    <attachment id="12464954" name="SQL2SearchTest.png" size="28346" author="jukkaz" created="Tue, 30 Nov 2010 10:47:27 +0000" />
                    <attachment id="12469043" name="test.groovy" size="1897" author="my1234" created="Sat, 22 Jan 2011 13:35:19 +0000" />
                    <attachment id="12464951" name="ThreeWayJoinTest.png" size="32963" author="jukkaz" created="Tue, 30 Nov 2010 10:11:59 +0000" />
                    <attachment id="12464950" name="TwoWayJoinTest.png" size="30493" author="jukkaz" created="Tue, 30 Nov 2010 10:11:59 +0000" />
                </attachments>
            <subtasks>
        </subtasks>
                <customfields>
                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                <customfieldname>Attachment count</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>6.0</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                <customfieldname>Date of First Response</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>Wed, 13 Oct 2010 10:02:35 +0000</customfieldvalue>

                </customfieldvalues>
            </customfield>
                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Global Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>97807</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                            <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                <customfieldname>Rank</customfieldname>
                <customfieldvalues>
                    <customfieldvalue>190349</customfieldvalue>
                </customfieldvalues>
            </customfield>
                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                <customfieldname>Time in Status</customfieldname>
                <customfieldvalues>
                    
                </customfieldvalues>
            </customfield>
                            </customfields>
    </item>
</channel>
</rss>