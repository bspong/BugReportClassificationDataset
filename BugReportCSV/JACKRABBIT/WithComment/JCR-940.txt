add db connection autoConnect for BundleDbPersistenceManager.
Since bundled db pm doesn t inherited from database pm it can t reconnect once database is bounced. it would be nice to add this feature.Here s a patch that adds reconnection logic to the bundle persistence managers. I ve made an attempt to put this in a separate class such that it can be reused. I ve tested it with MSSQL and with Oracle 10. Feedback is much appreciated martijn thanks for the patch. the patch looks very good in general excellent job i quickly browsed through the patch and i got a few comments - some changes in BundleDbPersistenceManager seem to have gone lost    in your patch e.g. 566985 563900 . - Oracle9PersistenceManager storeBundle the blob parameter is never set - - what was the reason for removing resetStatement stmt calls    see e.g. PostgreSQLPersistenceManager line 120 - tabs should be avoided in the source code cheers stefanHi Stefan Thanks for the feedback I ll check out the lost changes you mention and you re absolotely right on the blob parameter. The resetStatement calls are not removed but are now placed in the ConnectionRecoveryManager.executeStmt method. What do you think about letting Jackrabbit only return when a query succeeded i.e. if the database connection is lost then Jackrabbit code retries until it succeeds I ll try to make a second version of the patch asap. Best regards Martijn What do you think about letting Jackrabbit only return when a query succeeded i.e. if the database connection is lost then Jackrabbit code retries until it succeeds personally i don t think that this would be a good idea since JCR api calls could as a result block forever.one thing i forgot to mention the new classes ConnectionRecoverable ConnectionRecoveryManager would IMO be better placed in the o.a.j.core.persistence.util package instead of o.a.j.core .Hi Stefan I m preparing a new version of the patch. I see that 563900 belongs to JCR-1039 but where is 566385 Best regards Martijn Martijn Hendriks commented on JCR-940 Hi Stefan I m preparing a new version of the patch. I see that 563900 belongs to JCR-1039 but where is 566385 sorry my mistake. it s 566985. it s just a trivial typo correction http svn.apache.org viewvc view rev revision 566985 cheers stefan Best regards Martijn Hi Here s a second version of the patch. Best regards MartijnHi I have a few comments SLEEP BEFORE RECONNECT 10000 TRIALS 1 I would use SLEEP BEFORE RECONNECT 500 TRIALS 20 public synchronized boolean addStatement String sql ...         log.warn failed to add statement         return false      It s easy to forget checking the return value. Actually you did not check it. I would throw an exception if preparing a statement failed. initPreparedStatements why not prepare the statements when they are first used Like that you only prepare statements that are actually used. This saves time. So I would change PreparedStatement stmt PreparedStatement preparedStatements.get sql if stmt null   throw new Exception unknown SQL statement sql to PreparedStatement stmt PreparedStatement preparedStatements.get sql if stmt null   stmt connection.prepareStatement sql   preparedStatements.add sql stmt There is anyway a loop to reconnect if this failed. So you can get rid of addStatement .. rePrepareStatements and sqlStatements. if params i instanceof Long stmt.setLong i 1 Long params i .longValue else if params i instanceof byte stmt.setBytes i 1 byte params i else if params i instanceof Blob stmt.setBlob i 1 Blob params i else stmt.setObject i 1 params i Only the last line is required. close shared prepared statements This is not required. If the connection is closed the prepared statements are closed. Just calling preparedStatements.clear is enough. boolean reestablishConnection .. Again using a return value... private Set sqlStatements new HashSet - stmt con.prepareStatement - select NODE ID BUNDLE DATA from - schemaObjectPrefix BUNDLE stmt connectionManager.getConnection .prepareStatement select NODE ID BUNDLE DATA from BUNDLE The schemaObjectPrefix is lost here. store log.warn storing and committing changes failed e.getMessage exception stack traces must be logged as well log.warn storing and committing changes failed e.getMessage e stmt connectionManager.getConnection .prepareStatement select NODE ID BUNDLE DATA from BUNDLE The SQL statement should stored in one of the member variables in my view but it was also not done before... . if connectionManager.setAutoCommit false throw new ItemStateException disabling autoCommit failed Using a return value for an exception. Object keys getKey bundle.getId .getUUID Object params new Object keys.length 1 params 0 out.toByteArray for int i 1 i params.length i params i keys i-1               What about using an ArrayList List params getKey bundle.getId .getUUID params.add out.toByteArray - stmt.setBytes 2 bundle.getId .getUUID .getRawBytes This is code you removed... Strange how did this work with getStorageModel SM BINARY KEYS Connection con connectionManager.getConnection if con null DatabaseMetaData metaData con.getMetaData if metaData.getDriverMajorVersion 10 Connection con connectionManager.getConnection if con null try con.rollback In some places the return value is checked in other places not. I would make sure getConnection never returns null otherwise you get NullPointerExceptions in strange places and you don t really know what was the reason. return the database connection that is managed possibly null public synchronized Connection getConnection int trials TRIALS while trials 0 First try to reconnect if needed if isClosed autoReconnect reestablishConnection Then try to return the connection if isClosed return connection log.warn failed to get connection return null I would write return the database connection that is managed possibly null public synchronized Connection getConnection throws SQLException reconnect if needed if isClosed autoReconnect reestablishConnection return connection In my view reestablishConnection should loop and if it can t connect throw an exception. And once it failed it should set autoReconnect to false otherwise other code will try to re-connect again and again maybe endlessly . You have used reestablishConnection in many places in the code I think it should only be called in one place. Thomas Hi Thomas Thanks for your detailed comments I ll take a good look at them when I have time probably after the weekend and prepare a third version. MartijnHi Thomas Here s a third version of the patch. Thanks for your useful comments I think that they have improved it significantly. I also have added a blockOnConnectionLoss property that can be configured from the repository.xml default value is false . Your last comment suggested to set autoReconnect to false after a failed reconnection attempt. I haven t included that because I have no idea who and when should set it to true again. Best regards MartijnHi Great The patch looks very good I will apply it in my environment test it and then commit it. The blockOnConnectionLoss feature is OK what is your use case Just one remark currently SLEEP BEFORE RECONNECT is 0.5 seconds that s great because re-creating a TCP IP connection usually is quick no need to wait many seconds before the first re-try if we expect MySQL to be the customer for this feature . Currently TRIALS is 2 that means giving up after at most 1 second. I think that s a bit short. What about setting TRIALS to 10 It will then try at most 5 seconds enough for a unstable wireless connection not sure if this is a use case . Thomas Great The patch looks very good Thanks I will apply it in my environment test it and then commit it. The blockOnConnectionLoss feature is OK what is your use case Just one remark Our application caches query results that we know to be stable. If some nodes in the result set of such a query are not yet in the Jackrabbit caches and the connection is lost then they are skipped in the NodeIterator for the queries result. I.e. our caches could get out-of-sync when the connection is lost which would require a restart. Blocking within Jackrabbit solves this transparently and this patch makes a first attempt at that. Currently one statement changelog fails before blocking i.e. that statement changelog is lost so with very bad luck our caches could still get out of sync. I m still thinking on how to block on this first statement changelog in an elegant way. Of course we get a lot of contention but that would - in theory be resolved - when the connection comes up again. Currently TRIALS is 2 that means giving up after at most 1 second. I think that s a bit short. What about setting TRIALS to 10 It will then try at most 5 seconds enough for a unstable wireless connection not sure if this is a use case . Yes 10 is fine. MartijnI have run the unit tests with this patch and that works. I wanted to test if auto-reconnect works using PostgreSQL on a remote machine. Unfortunately it is quite complex to enable remote connections in PostgreSQL you need to change pg hba.conf and postgresql.conf the GUI doesn t really work and I was not fully successful Remote connections still don t work except if I use a TCP IP redirect utility actually one I made myself some time ago . But this is very slow. I tried out auto-reconnect remove network cable but I found some problems Unlike the regular DatabasePersistenceManager BundleDbPersistenceManager.store doesn t try to re-connect void store ChangeLog changeLog   ..   connectionManager.setAutoReconnect false   super.store changeLog   .. So the feature still needs to be improved and tested more. But the patch doesn t seem to break anything so I will commit it shortly. ThomasRevision 575734 BundleDbPersistenceManager auto-reconnect I have implemented the loop BundleDbPersistenceManager.store ChangeLog but unfortunately the feature still doesn t work always in the following case - enabling blockOnConnectionLoss - run mvn install - stop the database server for example PostgreSQL while the test runs - start the database server Sometimes the SQLException is thrown and the test fails. This needs to be tested some more.Hi Thomas I think that besides the BundleDbPM.store method the ConnectionrecoveryManager.execute methods also need to be wrapped by a retry-loop. I ve patched this locally and want to execute the unit tests using the MSSQL bundle PM. I m not familiar with the test harness...how should I do this Some initial attempts to alter the repository.xml and workspace.xmls in the jackrabbit-core applications test directory failed.Here s a cumulative patch that wraps the ConnectionRecoveryManager.execute methods and the BundleDbPM.store method in a retry loop. I tested this using the unit tests with a remote MSSQL database. The blockOnConnectionLoss true option now seems to work as expected all tests still pass when the network cable is unplugged one or more times during the tests.Sorry I have attached my comments to the wrong bug JCR-1138 . Hi The patch looks good. I tried with PostgreSQL and got this problem ConnectionRecoveryManager could not setup connection reason could not load driver org.postgresql.Driver state code null 0 ConnectionRecoveryManager.java line 430 ConnectionRecoveryManager blocking until database connection is up again... ConnectionRecoveryManager.java line 368 Do you agree that retry doesn t make sense if the driver could not be loaded If yes I will change the code. Also it would probably make sense to write the database URL and the user name not the password to the log file so the person alias poor guy who has to start the database knows which one and can test the connection using some other tool. If that s OK with you I will make it throw a RepositoryException if the database driver could not be loaded or initialized ExceptionInInitializerError     private void setupConnection throws SQLException RepositoryException         try             Class driverClass Class.forName driver              Workaround for Apache Derby              The JDBC specification recommends the Class.ForName method without the .newInstance method call              but adding the newInstance guarantees that Derby will be booted on any Java Virtual Machine.             driverClass.newInstance          catch Throwable e             throw new RepositoryException Could not load or initialize the database driver class driver e          Revision 578043 apply patch submitted by Martijn Hendriks plus RepositoryException if the driver could not be loaded . Do you agree that retry doesn t make sense if the driver could not be loaded Yes good point If yes I will change the code. Also it would probably make sense to write the database URL and the user name not the password to the log file so the person alias poor guy who has to start the database knows which one and can test the connection using some other tool. Yes that s more informative than the current situation. It seems to work now. Please re-open or create a new bug if not.
