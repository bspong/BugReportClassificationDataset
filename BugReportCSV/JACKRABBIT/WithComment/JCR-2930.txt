same named child nodes disappear on restore
When restoring a versionable node which has several non-versionable child nodes with the same name some child nodes disappear.             Node node session.getRootNode .addNode myNode             node.addMixin mix versionable             for int i 1 i 6 i                 Node child node.addNode child                 child.setProperty name child i                          session.save             VersionManager versionManager session.getWorkspace .getVersionManager             versionManager.checkin node.getPath             System.out.println number of child nodes node.getNodes .getSize             versionManager.checkout node.getPath             node.getNode child .setProperty name modified             session.save             Version baseVersion versionManager.getBaseVersion node.getPath             versionManager.restore baseVersion true             System.out.println number of child nodes in restored node node.getNodes .getSize produces the following output number of child nodes 5 number of child nodes in restored node 3 Giving unique names or adding the mixin versionable to the child nodes solves the problem. The error occurs at org.apache.jackrabbit.core.version.VersionManagerImplRestore.internalRestoreFrozen VersionManagerImpl.java 493 when replacing all existing child nodes on N if node is present remove it state.removeNode entry.getName entry.getIndex Let N node and F frozen node have 2 child nodes. This removes the correct node from the state object at the first cycle but at the second when the first child node has been removed from position 1 and added to position 2 on the state object the indices in the state object have moved and the childnode that has been added at the first cycle is removed at the second cycle. The second cycle also removes the 2nd child node from the state object in line 505                  check for existing                 if f.getFrozenId null                     if stateMgr.hasItemState f.getFrozenId                         NodeStateEx existing state.getNode f.getFrozenId                         if removeExisting                             NodeStateEx parent existing.getParent                             parent.removeNode existing                             parent.store                             ... Finally the 2nd child node of F is added resulting in a restored state where the first child node of the frozen node is missing.repro test caseproposed patch minimally changed includes test caseFixed based on Marlis Lamps patch thanks 
