Support multi-selector OR constraints in join queries
Our current join implementation doesn t support OR constraints that refer to more than one selector. For example the following query is not possible     SELECT a. FROM my type AS a INNER JOIN my type as b ON a.foo b.bar WHERE a.baz x OR b.baz y This limitation is a result of the way the join execution splits the query into per-selector components and merges the result based on the given join condition. A simple but often inefficient solution would be to process such OR constraints as post-processing filters like we already do for some other more complex constraint types.Patch to split an affected query one that has an OR that spans over both sides of a JOIN run the 2 splits and then merge the results.Looks good thanks I committed the patch in revision 1080186. Some comments The many if multiple conditions in ConstraintSplitInfo and related code suggest that we might want to use the strategy pattern instead of treating ConstraintSplitInfo as just a data class. Something like that could also simplify the current ConstraintSplitter class. I find the if ... ... return ... pattern you use somewhat confusing. I d rather just use if ... ... else ... . If that leads to too much indentation it s time to break the method to smaller subtasks. It would be good to have an outer join test case as well. I m not sure how the OR conditions interact with outer join semantics. I removed some trailing whitespace from here and there in the patch. Not a big issue. While looking at a test with outer joins I found this nice NPE just waiting to happen In case of outer joins the right row variable can be null thus breaking the toString implementation of the JoinRow class.Good catch Patch committed in revision 1080540.Attached a simple Outer Join testApparently JCR-2933 stumbled upon a case that does not fit into my patch If we have an outer join with an OR condition that references the 2 sides of the join on both branches of the condition. The Constraint splitter fails to recognize that and executes 2 wrong queries thus resulting in a 0 set. Ex Select from test SamplePage as page left outer join test SampleContent as content on ISDESCENDANTNODE content page where page.prop1 page1 and content.prop1 content3 or page.prop1 page2 and content.prop1 content3 The Or has 2 branches that reference both sides 1. page.prop1 page1 and content.prop1 content3   OR 2. page.prop1 page2 and content.prop1 content3 A suggested workaround as I think this will have horrible performance anyway is to rewrite the query in a more simple way to not cross reference anymore  where page.prop1 page1 or page.prop1 page2 and content.prop1 content3 but this does not fix the issue I ve submitted a patch on JCR-2933 that incorporates an upgrade for this issue. Further development on this issue will be continued over there.parent issue is resolved JCR-2933Hi I just updated to jackrabbit 2.2.7. The javax.jcr.UnsupportedRepositoryOperationException Unable to split a constraint that references both sides of a join. exception is actually gone but another issue seems to have arisen. I have a query like this select mytype. from my type as mytype inner join my child as mychild on ischildnode mychild mytype where contains mytype. foo or contains mychild. foo Regardless of whether foo is there or not the entire dataset is returned every time.OK just seen this https issues.apache.org jira browse JCR-3000 so you should be aware that things still don t work as expected. And running a test performing a query similar to the one above against 2.2.7 actually raised junit.framework.AssertionFailedError Wrong hit count. expected 0 but was 35 Hi Frederico you are right I ll put a link to the new issue. We ve managed to find more interesting test cases so I can debug this issue further make sure everything works as expected. I m trying to keep 2.2 up to date with all the fixed I push on the trunk. You are welcome to join in on the testing any feedback is appreciated 
