Modify LazyQueryResultImpl to allow resultFetchSize to be set programmatically
In our application we have a search which only shows part of a query result. We always know which part of the result needs to be shown. This means we know in advance how many results need to be fetched. I would like to be able to programmatically set resultFetchSize to minimize the number of loaded lucene docs and therefore improve the performance. I know it is already possible to the set the resultFetchSize via the index configuration but this number is fixed and doesn t work well in environments where you use paging for your results because if you set this number too low the query will be executed multiple times and if you set it too high too many lucene docs are loaded.This patch modifies LazyQueryResultImpl to provide a setter-method for resultFetchSize. I also fixed the class which is used for the Logger and optimized LazyScoreNodeIterator.skip to only fetch more results if necessary.This patch modifies the previous patch to fix a small bug which caused LazyQueryResultImpl.getResults int to be called on each successive call to LazyQueryResultImpl.getNodeIterator Thank you for the patch. Wouldn t it be more intuitive to set the resultFetchSize on the Query instance instead of the QueryResult With your current patch one will call QueryManager qm ... Query q qm.createQuery myQuery Query.XPath QueryResult result q.execute LazyQueryResultImpl result .setResultFetchSize 10 NodeIterator nodes result.getNodes ... I think the following is more intuitive QueryManager qm ... Query q qm.createQuery myQuery Query.XPath QueryImpl query .setResultFetchSize 10 QueryResult result q.execute NodeIterator nodes result.getNodes ...QueryImpl is located in org.apache.jackrabbit.core.query and is not lucene specific but resultFetchSize is lucene specific. This is why I chose to provide the setResultFetchSize -method on a lucene specific class. I think it would be better to have a QueryImpl.setMaxResultSize instead which could be used by any search engine implementation. In the case of the lucene implementation we could guest resultFetchSize from maxResultSize. Or do you think we should provide a setResultFetchSize method regardless of how the search engine is implemented QueryImpl is located in org.apache.jackrabbit.core.query and is not lucene specific. You are right. I forgot about that. How about a generic method like QueryImpl.setOption String name String value The method would then fill a map with the name value pairs and pass the map to the implementation lucene specific query handler in method QueryHandler.createExecutableQuery ... To be honest I don t like this generic setOption method. Methods like that tend to transport some configuration options that are not obvious to the user but I have to confess that LazyQueryResultImpl result .setResultFetchSize 10 isn t that obvious either If we provide such a setOption method I would at least like to provide some constants like QueryImpl.setOption LazyQueryResultImpl.RESULT PREFETCH SIZE 123 which doesn t really make things better. I think the main problem is that resultPrefetchSize is not only lucene specific but also specific to LazyQueryResultImpl. I just got another idea. What do you think of some Timer that checks LazyScoreNodeIterator for activeness and closes the reader if there hasn t been any activity on the iterator for the last say 1 or 2 seconds If the Iterator is used again the query can still be executed again and the current mechanism could be used. I think in most cases you iterate through the results quite quickly so the reader will only be closed when you are finished. This would eleminate the need to set resultPrefetchSize and would give better performance to most users without configuring anything while taking up a bit more resources.I completely agree with you that both our suggestions are quite ugly Here s another idea we could already anticipate what JSR 283 will most probably specify on the Query interface. See https jsr-283.dev.java.net issues show bug.cgi id 214 Would that work for you 1 I ll try to provide a patch the next days.I finally made it. Took me a bit more than a few days however I decided to create a new interface JackrabbitQuery in jackrabbit-api which includes the two methods setOffset and setLimit which will probably be part of JCR 2.0. This way you don t have to cast your Query instance to QueryImpl but rather JackrabbitQuery. This hopefully makes it more accessible to users and looks less like a hack. QueryImpl query .setLimit 123 vs JackrabbitQuery query .setLimit 123 This opens the possibility to provide an RMI implementation to support those two methods over RMI as well. Everything else was quite straight forward. There are two patches one for jackrabbit-api containing the interface and one for jackrabbit-core containing the actual code changes. WDYT 1 I like the addition to jackrabbit-api. Any other solution would prevent usefullness in environments where access to jackrabbit-core is not possible such as in a web application running in a different class loader than the repository.committed in revision 563688Nice work I m not 100 sure if we should place JCR 2.0 extensions in jackrabbit-api after all they are still subject to change and it might well be that the interfaces will change before JCR 2.0 is final. Putting the extensions in jackrabbit-api implies that we are ready to offer backwards compatibility to these new methods even if JCR 2.0 decides to drop them or implement them in some other way. More on dev in a moment...I d like to second Jukkas opinion. We should not introduce new methods in the jackrabbit API for enhancements we expect to be available in JCR 2.0.Okay. What to do now Based on the discussion on the dev list http www.nabble.com JCR-2.0-extensions-tf4235046.html a12049594 it seems like everyone agrees that we should start to make the jsr283 api available in Jackrabbit e.g. in the org.apache.jackrabbit.jsr283 package . Should I remove the JackrabbitQuery interface But I think we should the push the effort make the jsr283 api availble.For the time being I suggest we remove the JackrabbitQuery interface and require a client to cast to the implementation class QueryImpl. When we introduce the jsr283 component we can still change introduce the interface again or even wait until the official jcr-2.0.jar is available.
