Deadlock on concurrent save checkin operations possible
Save and checkin operations are trying to acquire 2 locks in different order what leads to deadlock. - save 1.SharedItemStateManager.acquireWriteLock 2.AbstractVersionManager.acquireWriteLock - locked - checkin 1.AbstractVersionManager.acquireWriteLock 2.SharedItemStateManager.acquireReadLock - locked Thread-4 prio 6 tid 0x0312d840 nid 0x824 in Object.wait 0x03cef000..0x03cefa68 at java.lang.Object.wait Native Method - waiting on 0x23210968 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock at java.lang.Object.wait Unknown Source at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock.acquire Unknown Source - locked 0x23210968 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock at org.apache.jackrabbit.core.version.AbstractVersionManager.acquireWriteLock AbstractVersionManager.java 124 at org.apache.jackrabbit.core.version.VersionManagerImpl.setNodeReferences VersionManagerImpl.java 413 at org.apache.jackrabbit.core.version.VersionItemStateProvider.setNodeReferences VersionItemStateProvider.java 125 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.end SharedItemStateManager.java 699 at org.apache.jackrabbit.core.state.SharedItemStateManager.update SharedItemStateManager.java 810 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 326 at org.apache.jackrabbit.core.state.XAItemStateManager.update XAItemStateManager.java 313 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 302 at org.apache.jackrabbit.core.state.SessionItemStateManager.update SessionItemStateManager.java 295 at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 1204 - locked 0x2332eaa0 a org.apache.jackrabbit.core.XASessionImpl at JrTestDeadlock.run JrTestDeadlock.java 87 Thread-3 prio 6 tid 0x0312db18 nid 0xa04 in Object.wait 0x03caf000..0x03cafae8 at java.lang.Object.wait Native Method - waiting on 0x232d1360 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at java.lang.Object.wait Unknown Source at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock.acquire Unknown Source - locked 0x232d1360 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock SharedItemStateManager.java 1361 at org.apache.jackrabbit.core.state.SharedItemStateManager.hasItemState SharedItemStateManager.java 270 at org.apache.jackrabbit.core.state.LocalItemStateManager.hasItemState LocalItemStateManager.java 180 at org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState XAItemStateManager.java 252 at org.apache.jackrabbit.core.state.SessionItemStateManager.hasItemState SessionItemStateManager.java 188 at org.apache.jackrabbit.core.ItemManager.itemExists ItemManager.java 256 at org.apache.jackrabbit.core.NodeImpl.hasProperty NodeImpl.java 1509 at org.apache.jackrabbit.core.version.InternalFrozenNodeImpl.checkin InternalFrozenNodeImpl.java 276 at org.apache.jackrabbit.core.version.InternalFrozenNodeImpl.checkin InternalFrozenNodeImpl.java 248 at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.checkin InternalVersionHistoryImpl.java 440 at org.apache.jackrabbit.core.version.AbstractVersionManager.checkin AbstractVersionManager.java 397 at org.apache.jackrabbit.core.version.VersionManagerImpl 2.run VersionManagerImpl.java 289 at org.apache.jackrabbit.core.version.VersionManagerImpl DynamicESCFactory.doSourced VersionManagerImpl.java 611 - locked 0x2320c5d8 a org.apache.jackrabbit.core.version.VersionManagerImpl DynamicESCFactory at org.apache.jackrabbit.core.version.VersionManagerImpl.checkin VersionManagerImpl.java 285 at org.apache.jackrabbit.core.version.XAVersionManager.checkin XAVersionManager.java 161 at org.apache.jackrabbit.core.NodeImpl.checkin NodeImpl.java 2944 at JrTestDeadlock.run JrTestDeadlock.java 103 could have been introduced by JCR-546.You marked this as occurring in 1.1 If correct then it shouldn t be caused by JCR-546 since it s not included in either 1.1 or 1.1.1.The proper solution to this issue would probably be to acquire the SharedItemStateManager read lock for the entire checkin operation.It is occuring in trunk. I have checked 1.1 by accident then I couldn t change this ...Cleared the 1.1 tag. However I still don t think this is caused by JCR-546 as the deadlock occurs on line 397 of the AbstractVersionManager.checkin method. That line was covered by the AbstractVersionManager write lock already before JCR-546 extended the scope of that lock. Can you reproduce this issue on Jackrabbit 1.1.1 You re right deadlock has not been introduced by JCR-546 but it seems that currently is easier to reproduce it. Inconsistent order of acquiring locks was already there. SharedItemStateManager read lock should be acquired first or if both components SharedItemStateManager AbstractVersionManager ae really coupled together maybe solution is to get rid of one and use single lock instead. You re right deadlock has not been introduced by JCR-546 but it seems that currently is easier to reproduce it. This sounds reasonable since the write lock in AbstractVersionManager covers and extra getProperty JCR PREDECESSORS call now after JCR-546. This increases the time the write lock is acquired thus increasing the window when the deadlock can occur. SharedItemStateManager read lock should be acquired first or if both components SharedItemStateManager AbstractVersionManager ae really coupled together maybe solution is to get rid of one and use single lock instead. Having two locks makes sense since a versioning operation in one workspace shouldn t affect normal operations in another workspace. Thus I think the proper solution is indeed to extend the scope of the SharedItemStateManager read lock.Is there anything a non-Jackrabbit-developer can do to help This bug is regularly locking up one of my projects and in consequence the entire Tomcat process and I need it fixed ASAP but I don t know my way around the codebase enough to fix it myself. Is there anything a non-Jackrabbit-developer can do to help I m afraid there s relatively little to do. Reporting all known deadlock occurrences with as much detail as possible would help but in the end someone needs to bite the bullet and start rethinking the locking behaviour within jackrabbit-core. Some people have workarounds that explicitly synchronize all the versioning operations of concurrent sessions. Documenting such a workaround with example code on the Jackrabbit wiki would be appreciated but of course it s still just a workaround. Reporting all known deadlock occurrences with as much detail as possible would help Well there s not much to report. My stack traces are pretty much identical to the ones in the report. The program uses versioning but no transactions. Some people have workarounds that explicitly synchronize all the versioning operations of concurrent sessions. Yes looks like I ll have to take the performance hit and do that. The extremely coarse-grained locking of this does not make me happy ... The calls to VirtualItemStateProvider.setNodeReferences do not have to be within the scope of the write lock. All virtual item state providers are repository wide anyway and must implement their own locking. Locking the workspace where the call originated is unnecessary and does not help here. Moved the code further down where the write lock had been downgraded to a read-lock. Also added test cases ConcurrentVersioningTest The tests cover the following cases - concurrently create version histories - concurrently do checkin checkouts - concurrently create version histories and do checkin checkouts Fixed in revision 533152Probably occurs in all released versions.Merged to the 1.3 branch in revision 544244.
