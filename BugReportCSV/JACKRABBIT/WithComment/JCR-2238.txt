Binary throws NullPointerException
Precondition repository with datastore disabled Steps to reproduce 1 create binary from stream 2 set binary on property 3 dispose binary 4 get binary from property and dispose it immediately 5 go to 4 Binary.dispose will throw a NullPointerException when 4 is executed the second time. The exception is not thrown if the property is saved after 2 . See also attached test.As can be seen in the test output the property always returns the same Binary instance. For most implementations this is not an issue because they are immutable and Binary.dispose is a noop. Without the data store the binary instance is a BLOBInTempFile which has state and will delete the underlying temp file on dispose . It seems to me that ownership of a binary instance is not well defined that includes the spec as well as in our jackrabbit modules . I think we should clarify the following questions and adjust the implementation accordingly 1 Does Value return a new instance of Binary on Value.getBinary I d say yes because Binary.dispose may change the state of the object. though an implementation may chose to return a binary that has no state and dispose is a noop. see our various Binary implementations in jackrabbit-core. implementation consequences we need to change our Binary implementations that are not immutable otherwise a call to getBinary will become potentially expensive because a new instance needs to be created i.e. a new temp file spooled . some sort of reference counting might be a solution. we need to make sure dispose is called whenever getBinary is used internally in jackrabbit. it seems this is not always the case yet. - Does Value become the owner of the given Binary on ValueFactory.createValue I d say no because Value does not have a defined life cycle. there is no dispose or similar method on Value hence a client does not know when the given Binary is disposed. furthermore a client may wish to still use the given binary after the call to createBinary . so this is how we use Binaries already in our code Node n ... Binary bin ... try     Value v vf.createValue bin     n.setProperty foo v     n.setProperty bar v finally     bin.dispose but it seems Value must come the owner of a Binary even if it is not the instance passed in createValue because otherwise the following code will not work Node n ... Binary bin ... Value v try     v vf.createValue bin finally     bin.dispose n.setProperty foo v n.setProperty bar v question is this valid I think yes. the implementation in jackrabbit core already creates a new Binary instance in this situation. but the implementation in jcr-commons doesn t - Unfortunately this has the consequence that we need to add a finalize method to either the temporary resource backed Binary implementations or the Value implementation. whenever possible we should avoid creating a Value instance for a binary at least internally in jackrabbit . does anyone have an alternative solution i think the creator is responsible to dispose the binary no matter if the binary was - created using ValueFactory.createBinary InputStream - retrieved from a property eg Property.getValue .getBinary - created in a own object implementing javax.jcr.Binary the most common code is probably Binary bin vf.createBinary in try     n.setProperty foo bin     n.setProperty bar bin finally     bin.dispose 1 Does Value return a new instance of Binary on Value.getBinary we need to change our Binary implementations that are not immutable otherwise a call to getBinary will become potentially expensive I think whether Value.getBinary returns a new object should be implementation defined not part of the spec . For Jackrabbit we could do that always if that s easier even if using the data store . I know creating new objects is slow if the class has a finalize method but I think it s not such an important performance problem because most applications will not call Value.getBinary multiple times I guess. Even creating a new temporary file each time it is called is probably OK - or is there an important use case where getBinary needs to be called multiple times for the same value Value v try v vf.createValue bin finally bin.dispose n.setProperty foo v I think that should be valid. With the data store a getBinary could always return the same Binary object b dispose would be a noop Without the data store when using a temp file c getBinary could always create a new temp file or use a shared file if we find an important use case c I think dispose should close the stream and make the Binary object unusable delete the temp file maybe using a reference count d finalize should call dispose for such Binary objects if needed e Maybe closing the session should call Binary.dispose session would need a weak reference to all Binary objects Proposed patch.I m not sure if RefCountingBLOBFileValue is really important... if yes refCount access should be synchronized or use java.util.concurrent.atomic.AtomicInteger . That s all I found. I hope we can some day simplify blob handling the code is really complicated... Good point. I ve updated the patch accordingly. Though I think the RefCountingBLOBFileValue is currently only used by a single thread while a session writes to the repository.Updated patch. Removed BLOBFileValue.discard and replaced calls to that method with dispose .Applied patch with minor modifications commented System.out.println in test class in revision 802676Thomas reported a flaw in the use of AtomicInteger. Replaced usage of AtomicInteger with plain old synchronized methods. svn revision 802690
