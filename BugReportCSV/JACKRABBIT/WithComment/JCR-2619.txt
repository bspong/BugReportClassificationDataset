improved internal representation of DATE values
DATE values are currently internally represented as java.util.Calendar objects. Calendar objects have a huge memory footprint approx 200bytes per instance and are mutable. i suggest to replace the internal DATE representation with a ISO8601 format string immutable and approx. 85-90 smaller footprint .patch with proposed changes. there doesn t seem to be a significant impact on performance test cases run times are more or less identical .the memory footprint of a 25 char long string is about 88bytes 56 less - if you really want to save space why not use a byte array of the size 10 for time and timezone The tradeoff between a string and a binary representation is the performance impact on having to generate the string when the getString method is called. If that s not a concern then I d actually suggest that we simply use a single long value and avoid all object or array overhead.You would need at least a long and an int to represent the date with the timezone. A String does use quite a lot of memory but it s easier than writing a separate serialization. Actually a 64-bit long is quite enough to store all the information in the ISO8601 date string subset used by JCR. a 64-bit long is quite enough Yes if we restrict the year don t support weird time zones. For me it s not a problem but for some applications it may be.It should support all values that a Calendar object can have including any timezone offset. The maximum that I know is 14 so having the timezone running from -15h to 15h which would be -900 to 900 minutes should cover every case. http www.worldtimezone.com faq.html It should support all values that a Calendar object can have If we want to do that then a long is not enough. Even long int is not enough because a java.util.TimeZone which is used internally in each java.util.Calendar is not just an offset but also includes rules. If we want to support each possible java.util.Calendar then we either need to use a String or store the Calendar object. If we only want to support possible values according to the JCR 2.0 specification this I m not sure then a long is enough for example in the format yyyymmddhhMMssMMMZZZZ.i ve chosen the ISO8601 string representations for the following reasons a smaller footprint b immutable no cloning required c human readable d the ISO8601 format is used extensively for serialization     persistence layer remoting protocols xml etc     getString toString are very effiicient i ve deliberately not chosen a more space-efficient binary representation because of d If we only want to support possible values according to the JCR 2.0 specification this I m not sure That s what I actually meant. Most notably JCR 1.0 and 2.0 specifies the date based on the iso8601 string representation without the timezone ID only with the current offset. Hence including the timezone ID and thus potentially changing the date upon access because of the re-interpretation of the rules and thus a different offset could break existing applications that currently must work around this issue by storing the timezone ID separately. It would be nice to have the timezone ID included of course but the spec unfortunately did not get this 100 right. for example in the format yyyymmddhhMMssMMMZZZZ Might work. ZZZZ would probably be shifted into the positive region eg. by adding -900 if we say -900 is the smallest negative timezone offset in minutes. d the ISO8601 format is used extensively for serialization persistence layer remoting protocols xml etc If the persistence layer can t currently be changed to use the same serialization format eg. the optimized long w o conversion I agree that the string rep is probably better.committed patch in svn r938969
