AccessManager CachingHierarchyManager problem
The problem we have is the implementation of the CachingHierarchyManager to which the SimpleAccessManager holds a reference. Let s consider following example i add 3 subnodes a b c to a node and after that i reorder b and c .. so i have a c b. in the process of reordering using the function orderBefore of javax.jcr.Node our AccessManager is called several times to check the permissions of the nodes. In this AccessManager we use some functions of the CachingHierarchyManager f.ex. Path itemPath hierMgr.getPath id return itemPath.denotesRoot or Path itemPath hierMgr.getPath itemId Path parentPath itemPath.getAncestor 1 return hierMgr.resolvePath parentPath the problem is that when calling the methods of the CachingHierarchyManager the nodes i ask for will be cached in the idCache in a wrong state i. e. before actually reordering the elements . so if i want f.ex. delete the node b after reordering the node will be looked up in the idCache. in the cache the index of node b is still 2 actually it should be 3 and so the wrong node will be deleted Thanks to your test case I could easily reproduce the issue it happens when transient items are reordered. The CachingHierarchyManager uses the method NodeState.getReorderedChildNodeEntries to retrieve the set of reordered items but this returns only changes between some state and its overlayed i.e. persistent state. Your test case performs the following operations in pseudo code - addNode - N1 - addNode - N2 - addNode - N3 - orderBefore N3 N2 which leaves the CachingHierarchyManager with an empty reordered list since the nodes have not yet been persisted. The CachingHierarchyManager should better evict its associated cache entry if it detects a purely transient reorder.Fixed as described CachingHierarchyManager evicts its cache entry if it cannot detect the reordering of the child node entries that took place. Reran the test case and verified that it works. Fixed in r488325.Reopening issue to edit metadata. PS. When resolving issues please just mark it as resolved but don t close it as there may still be a need to edit the issue metadata a closed issue can t be edited before a release. Also in general an issue shouldn t be considered closed until it has gone out in an official release. See the initial Jira guidelines I recently sent to dev .Re-resolving. I merged the change also to the 1.2 branch so this fix will be going out in the upcoming 1.2 release.
