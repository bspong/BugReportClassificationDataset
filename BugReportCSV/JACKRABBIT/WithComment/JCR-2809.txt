Lock expires almost immediately
When a timeoutHint other than Long.MAX VALUE is given to the javax.jcr.lock.LockManager API    lock String absPath boolean isDeep boolean isSessionScoped long timeoutHint String ownerInfo a timeoutTime in seconds will be computed as follows o.a.j.core.lock.LockInfo updateTimeoutTime    long now System.currentTimeMillis 999 1000 round up    this.timeoutTime now timeoutHint the TimeoutHandler in o.a.j.core.lock.LockManagerImpl running every second will then check whether the timeout has expired o.a.j.core.lock.LockInfo isExpired     public boolean isExpired         return timeoutTime Long.MAX VALUE              timeoutTime 1000 System.currentTimeMillis      Obviously the latter condition is true from the very beginning. Replacing with or should do the trick.or swapping the expressions for better understanding     public boolean isExpired         return timeoutTime Long.MAX VALUE              System.currentTimeMillis timeoutTime 1000      And why not keep the timeout as ms internally to prevent the repeated multiplication by 1000 I agree with Felix repeated multiplication by 1000 could be avoided. There are more bugs it seems - there is a space missing in the toString representation - the lock timeout is ignored when using XA - is this on purpose There is one more bug when using XA the timeout time when will it expire since 1970 is used as the timeout hint number of seconds until it expires . But anyway the timeout was ignored when using XA.The existing ConcurrentLocking tests are not included in TestAll. I don t know the reason it looks like a bug why having tests if they are not used . I will add them unless somebody objects.Proposed patchFixed in the trunk
