UserManager concurrent user creation using same intermediate path fails
concurrently creating users using same intermediate path fails with node ... has been modified externally . the problem is the intermediate path. if it doesn t exist multiple threads try to create it concurrently o.a.jackrabbit.core.security.user.UserManagerImpl line 1310ff             String segmts defaultPath.split             NodeImpl folder NodeImpl session.getRootNode             String authRoot isGroup groupsPath usersPath             for String segment segmts                 if segment.length 1                     continue                                  if folder.hasNode segment                     folder NodeImpl folder.getNode segment                     if Text.isDescendantOrEqual authRoot folder.getPath                              folder.isNodeType NT REP AUTHORIZABLE FOLDER                         throw new ConstraintViolationException Invalid intermediate path. Must be of type rep AuthorizableFolder.                                       else                     Node parent folder                     folder addNode folder session.getQName segment NT REP AUTHORIZABLE FOLDER                               the attached test case illustrates this issue test caseModified test case that uses random intermediate paths and user IDs so it can be run multiple time also switches to common concurrent test utilities. Cleanup remains a problem in the absence of a way to remove Users.OK it seems there are two straightforward ways to fix this depending how important we feel it is to parallelize user creation. 1 serialize all user group creation or 2 try a retry strategy. 2 seems to be a bit shaky due to session ownership. 1 seems to be simple. Opinions Angela notes that this is not specific to the intermediate path signature. The user manager might be configured to introduce intermediate paths automatically in which case the same problem can occur.test case modified to attempt user cleanupTo measure the impact on serializing user creation I just did a simple benchmark     public void testBenchUserCreation throws RepositoryException         long ms System.currentTimeMillis         int cnt 0                  while System.currentTimeMillis - ms 10000             JackrabbitSession s null             try                 s JackrabbitSession getHelper .getSuperuserSession                 String name newname- UUID.randomUUID                 Authorizable authorizable s.getUserManager .createUser                         name password1 new TestPrincipal name                         INTERMEDIATE PATH                 s.save                 userIDs.add authorizable.getID                 log.println authorizable created                 cnt 1              finally                 s.logout                                        System.err.println created cnt users in 10s          public void testBenchUserCreation2 throws Exception         runTask new Task             public void execute Session session Node test                     throws RepositoryException                 testBenchUserCreation                       8 testPath      On my old quad core machine a single thread can create 60 users per second. 8 threads without serialization create 100 users 8 threads with serialization create 70. Note that in the non-serialized case some requests did fail and the caller would need to be prepared to repeat them. It s a trade-off between robustness and performance...Proposed patchNote the current patch will not solve completely the problem in clustered installations. Alternatives 1 JCR lock on parent node will prevent other changes in principals such as changing properties also that node is not lockable right now 2 lock file used to serialize access 3 if the common modus operandi is the autoSave mode the createUser code could indeed do a retry after refreshing the session.For archival purposes here s an attempt of doing 3 for createUser            see UserManager createUser String String java.security.Principal String           public User createUser String userID String password                            Principal principal String intermediatePath             throws AuthorizableExistsException RepositoryException         checkValidID userID         if password null             throw new IllegalArgumentException Cannot create user null password.                   NOTE principal validation during setPrincipal call.                  int tryCount isAutoSave 3 1         User user null         NodeImpl userNode null                  while tryCount 0 user null             tryCount - 1                          try                 userNode NodeImpl nodeCreator.createUserNode userID intermediatePath                 setPrincipal userNode principal                 setProperty userNode P PASSWORD getValue UserImpl.buildPasswordValue password true                 user createUser userNode                 if isAutoSave                     session.save                               catch RepositoryException e                  something went wrong                 user null                  revert changes                 session.refresh false                 if e instanceof InvalidItemStateException tryCount 0                      try again                     log.debug Failed to create new User retrying.                  else                      re-throw                     log.debug Failed to create new User reverting changes.                     throw e                                                assert user null                  log.debug User created userID userNode.getPath         return user      Note that this doesn t help for the non-autosave case and would need to be extended to createGroup Option 4 for completeness use a helper session to create the intermediate nodes this would be retry-able without affecting the caller s session. After discussions with Angela and Marcel the proposal is to live with the restriction but to document it properly in Javadoc.Proposed patch adding the test case modified to do retries and adding to the Javadoc explaining why retries may be needed.looks good. just 2 minor comments regarding the the javadoc Note that all code create code calls will modify the current session. If i would stress that it s the current session associated with the user manager. if users are not stored in a different session that session may differ from the one the user manager was originally obtained from see difference between the 2 user manager implementations we are having in jackrabbit core . the user manager is em not em in autosave mode see link UserManager isAutoSave problems like overlapping creation of intermediate nodes may only surface upon a subsequent link Session save operation callers should be prepared to repeat them in case this happens. in that case the editing session which in the non-autosave mode is by definition the same that is associated with the user manager could also use the JCR locking functionality to prevent collisions while creating users.fixed in trunk with r1177648I updated the note about the session but left out a mention of JCR locks in general the caller will not know the location of the nodes in the repository if they are there at all . Also locking the whole tree would required the containing node to be lockable.
