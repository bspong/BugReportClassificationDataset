Memory is not freed up when jackrabbit-server war is redeployed in tomcat
This bug was introduced with the new CacheManager feature. See JCR-619. The CacheManager starts a new background thread which optimizes memory distribution every second accross the various caches. When a jackrabbit repository is shutdown this background thread is still running and prevents the GC from collecting the classloader when jackrabbit is deployed in a web application. Steps to reproduce 1 build jackrabbit and jcr-server from trunk and deploy into a tomcat 2 touch the web.xml file of the jcr-server web app this will force a redeployment After step 2 two things may happen. Either - The memory consumption increases because the CacheManager thread is not shutdown or - The CacheManager thread dies unexpectedly with a NullPointerException Exception in thread org.apache.jackrabbit.core.state.CacheManager java.lang.NullPointerException         at org.apache.jackrabbit.core.state.CacheManager.run CacheManager.java 90         at java.lang.Thread.run Unknown Source Obviously this is really bad. It didn t help to make it a daemon thread and to use a WeakHashMap. I will change the CacheManager instead of being a singleton the CacheManager will be associated with a PersistentManager or Repository . And the thread must be stopped when the PersistentManager Repository is closed. This should solve the problem. Unfortunately it will be harder to avoid OutOfMemory if many repositories are open at the same time but this is probably not that big a problem. ThomasHow about starting the background thread only when there are caches to manage Or stop the background thread when there are no more caches to manage respectively Starting stopping the CacheManager thread on demand would probably be a solution I didn t think about this. The singleton pattern would still not work when using different class loaders. Also configuring the cache size per repository is not possible. I made a patch to keep the cache managers in the RepositoryImpl. Unfortunately this means adding it to many constructors. The test case with the jcr-server works now the unit tests work as well .CacheManager in the RepositoryImplI don t really like the idea of having to use a separate thread to do this. Can t the various caches just call the CacheManager whenever an object is placed in the cache. You can amortize the performance hit by requesting reallocation only every N caching operations. This structure would avoid the need to manage a separate thread. Also it would be cleaner if you passed around a factory object instead of the CacheManager. That would make it much easier to plug in alternative caching behaviours. Something like this     public interface ItemStateCacheFactory         ItemStateCache newItemStateCache      and     public class ManagedMLRUItemStateCacheFactory         private final CacheManager manager         public ManagedCacheFactory CacheManager manager             this.manager manager                  public ItemStateCache newItemStateCache             ItemStateCache cache new MLRUItemStateCache             manager.add cache             return cache               A simpler alternative to using the factory pattern would be to pull the instantiation of the cache as high up the call chain as possible. It would still be cleaner to pass the cache instance to an ItemStateManager than the CacheManager since the manager is really a detail of the cache implementation and should not be exposed to other components like the ItemStatemanagers.Hi As requested by Jukka Zitting I made a few changes to the cache manager. There is no new functionality and the current behaviour changed only very slightly Instead of passing the CacheManager to various constructors now an ItemStateCacheFactory is passed this is a new interface and there is a single new class implementing this interface ManagedMLRUItemStateCacheFactory . Now the caches calls the CacheManager from time to time each time a cache was accessed 128 more times . This is not done directly but using a new interface CacheAccessListener. The CacheManager is the only class implementing this interface. The CacheManager then checks if it s time to resize the caches this is done at most every second . There is no more cache manager thread. The disadvantages are The caches will not shrink if none of them is accessed or accessed infrequently. And there is a very small overhead on each cache access. Again for me the CacheManager is a workaround. I hope we can soon replace this with a more unified cache. ThomasThe CacheManager slows a few things down at the moment for example the unit tests. I found the problem The caches are never disposed and therefore the CacheManager sometimes has a lot of caches to manage at one point in the unit test over 3000 . Garbage collection will eventually reclaim the unused objects the CacheManager uses a WeakHashMap so this is not a memory problem. I will submit a patch later today.As far as I know this problem has been fixed since a long time. Please reopen if not.
