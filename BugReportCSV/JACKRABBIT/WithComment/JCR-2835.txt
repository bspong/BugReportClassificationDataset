Poor performance of ISDESCENDANTNODE on SQL 2 queries
Using the latest source code I have noticed very bad performance on SQL-2 queries that use the ISDESCENDANTNODE constraint on a large sub-tree. For example the query select from jnt news as news where ISDESCENDANTNODE news root site order by news. date desc executes in 600ms select from jnt news as news order by news. date desc executes in 4ms From looking at the problem in the Yourkit profiler it seems that the culprit is the constraint building that uses recursive Lucene searches to build the list of descendant node IDs     private Query getDescendantNodeQuery             DescendantNode dn JackrabbitIndexSearcher searcher             throws RepositoryException IOException         BooleanQuery query new BooleanQuery         try             LinkedList NodeId ids new LinkedList NodeId             NodeImpl ancestor NodeImpl session.getNode dn.getAncestorPath             ids.add ancestor.getNodeId             while ids.isEmpty                 String id ids.removeFirst .toString                 Query q new JackrabbitTermQuery new Term FieldNames.PARENT id                 QueryHits hits searcher.evaluate q                 ScoreNode sn hits.nextScoreNode                 if sn null                     query.add q SHOULD                     do                         ids.add sn.getNodeId                         sn hits.nextScoreNode                      while sn null                                        catch PathNotFoundException e             query.add new JackrabbitTermQuery new Term                     FieldNames.UUID invalid-node-id never matches                     SHOULD                  return query      In the above example this generates over 2800 Lucene queries which is the culprit. I wonder if it wouldn t be faster to retrieve the IDs by using the JCR to retrieve the list of child IDs This was probably also missed because I didn t seem to find any performance tests on this constraint.Added fix version please correct if needed. I am attaching a patch to the LuceneQueryFactory that replaces the recursive Lucene queries with JCR sub-tree traversing. This seems to yield a little bit better performance x3 in my tests but this is still slow if the sub-tree has a lot of nodes. I welcome any feedback you may have. I am also ready to commit this if you d like. Best regards   Serge Huber.This probably won t make it in the 2.2 timeframe so targetting just 2.3 for now. When fixing this we should start by adding a test case to the peformance test suite possibly with an option to compare SQL2 against XPath . That way we ll have solid numbers to back any improvement ideas. In general subtree queries are troublesome even for XPath but there s still a lot we can do to bring SQL2 at least close to that level. One idea I had but didn t yet have time to implement was to collect the parent UUIDs of the entire subtree not by traversing each node separately but by per-level queries like 1 parent-id uuid-of-ancestor 2 parent-id uuid-of-child1 parent-id uuid-of-child2 ... 3 same for grandchildren etc. That way we d only need to execute a handful of Lucene queries per one subtree constraint.Hello Jukka Thanks again for your quick answer. Yes agreed we should provide a test case. Where should this be included I might have the opportunity to help develop this but I don t really know the best place to add such a case Interesting approach for the levels this would indeed reduce the number of queries although the clauses could get quite large not sure if that s an issue for Lucene. Best regards   Serge Huber.See the . test performance directory within Jackrabbit trunk. I just added some instructions in the README.txt file for adding new tests. The simplest way to get started is to copy and adapt the SimpleSearchTest and SQL2SearchTest classes to something like DescendantSearchTest and SQL2DescendantSearchTest classes. Re large clauses Yes we d probably need some extra code that automatically splits the queries into smaller subqueries like is currently being done by the QueryEngine.execute method for large joins.I am attaching a first pass at the descendant search tests. These tests were performed on the trunk WITHOUT the proposed patch. I will work on implementing Jukka s proposal now that I have the tests. Please review the XPath one as I am not that fluent in those queries. The current difference is huge provided my tests are correct XPath DescendantSearchTest min 10 50 90 max 2.2 25 34 43 59 265 SQL-2 SQL2DescendantSearchTest min 10 50 90 max 2.2 395318 395318 395318 395318 395318 If the test implementations look ok I can commit them once reviewed. Best regards    Serge Huber.I just tested with the patch I proposed here the results are slightly better but still very far from the XPath implementation SQL2DescendantSearchTest min 10 50 90 max 2.2 224662 224662 224662 224662 224662 Best regards   Serge Huber.Thanks for adding the test Feel free to commit it.Ok I have committed the perf tests in revision 1044239. I will be working on trying out your suggestion today. Best regards   Serge Huber.BTW when adding new files remember to always include the Apache license header. I added the header to the new test classes in revision 1044613 to fix the Hudson failure caused by this.Sorry about that Jukka my bad. Didn t know this could cause Hudson to fail. Btw unfortunately I didn t have the time to test your proposal. I was working on comparing the Lucene queries between the XPath and SQL-2 tests and saw that the DescendantChildNodeQuery is being used in the case of XPath but not in the case of SQL-2. I m not yet an expert at Lucene but maybe that s a place to start I also notice that the SimpleQueryResult does not support result fetch size as the other SingleColumnQueryResult and MultipleColumnQueryResult do. I realize this is because of the join merging but maybe we should look at being able to do progressive merging alongside with merges in order to reduce the number of results being loaded systematically. Again I haven t thought this through completely and maybe there is some limitation on doing so. These query problems are difficult because we are basically rewriting a full-fledged SQL optimizer and maybe we should look at how databases perform these Regards   Serge Huber.Hi I just made some improvements in the DescendantNode constraint using the same kind of subquery we do in XPATH DescendantSelfAxisQuery First I had to slightly change the XPath test in order to make it more comparable with the one SQL-2 as the current query in DescendantSearchTest does not return any result - So instead of testroot testcount i I used jcr root testroot element nt base testcount i added a the jcr root and an nt base constraint to have the same constraint as in sql-2 - btw this could also be improved as a constraint on nt base does not make much sense and does not need to be expanded to all sub types Before patching i had theses figures - similar to what serge got before DescendantSearchTest                   min     10     50     90     max 2.2                                      411     416     430     450     690 SQL2DescendantSearchTest               min     10     50     90     max 2.2                                   203530  203530  203530  203530  203530 After patching DescendantSearchTest                   min     10     50     90     max 2.3                                      420     429     448     479    1208 SQL2DescendantSearchTest               min     10     50     90     max 2.3                                      319     327     339     351     375 Which make the SQL2 queries even faster than the XPATH one. Basically I use a DescendantSelfAxisQuery with subqueries when possible. Compared to Xpath the context query is simpler the one that gets the ancestor node as it is based on nodeid instead of nested ChildAxisQuery queries - which can explain that sql-2 is slightly faster. For example an xpath query like jcr root folder1 folder2 element nt type Is translated to DescendantSelfAxisQuery        ChildAxisQuery              ChildAxisQuery                   PARENT                   folder1              folder2        PROPERTIES 1570322 primaryType 14877513 type       1 Where an equivalent select from nt type as obj where ISDESCENDANTNODE obj folder1 folder2 gives        DescendantSelfAxisQuery UUID a4137e73-6a16-4148-9d61-2353230a15d0        PROPERTIES 1570322 primaryType 14877513 type       1 Note that it currently only works in the first level of constraint - an isDescendantNode constraint inside an OR NOT boolean query won t use the subquery. I don t think it s a big issue for the OR - but it can be for the NOT .. The patch is attached .. Regards I have generated the performance graphs and indeed this patch looks really good Btw I had a lot of trouble generating the graphs under Mac OS X. It took me a while to understand that I needed to install the following packages from fink imagemagick2-svg gnuplot I have added to the README.txt instructions on how to use the script under Mac OS X to generate the graphs. If nobody has any objections I d like to commit this patch since the results are really much better Best regards   Serge Huber.Also maybe we should port this to 2.2.1 Regards   Serge Huber. 1 Looks great Re 2.2.1 Yes I think it would be a good idea to backport this even though strictly speaking it s not just a bug fix. We don t introduce any externally visible API or behaviour changes and this change should also fix the too many clauses problem already reported on users .Thanks Jukka will you take care of the backport or should I do it Regards   Serge...Ok I have committed this in the trunk as revision 1050346 Regards   Serge Huber.Merged to the 2.2 branch in revision 1054716.
