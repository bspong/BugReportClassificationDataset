Impossible comparison in NodeTypeImpl
org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeImpl does     public boolean isNodeType Name nodeTypeName         return getName .equals nodeTypeName ent.includesNodeType nodeTypeName      as getName is a string and nodeTypeName is a Name this will always be false. Perhaps you meant     public boolean isNodeType Name nodeTypeName         return getName .equals nodeTypeName.getLocalName ent.includesNodeType nodeTypeName      I think it should rather be Index src main java org apache jackrabbit jcr2spi nodetype NodeTypeImpl.java src main java org apache jackrabbit jcr2spi nodetype NodeTypeImpl.java revision 741110 src main java org apache jackrabbit jcr2spi nodetype NodeTypeImpl.java working copy -132 7 132 7        from the specified node type otherwise false.             public boolean isNodeType Name nodeTypeName - return getName .equals nodeTypeName ent.includesNodeType nodeTypeName return nodeTypeName.equals ntd.getName ent.includesNodeType nodeTypeName               note that I reversed the equals because ntd.getName may return null.the problem was never appearing because of the ... therefore i would say that we should get rid of the initial equality comparison altogether      public boolean isNodeType Name nodeTypeName - return getName .equals nodeTypeName ent.includesNodeType nodeTypeName return ent.includesNodeType nodeTypeName       I think you are right. The first check doesn t buy us too much I guess. And it simplifies the code.FWIW i guess the code in question is based on the node type implementation in core. i remember that i added the redundant call to name.equalsI as an optimization. some extensive profiling sessions a long time ago showed that EffectiveNodeType includesNodeType is somewhat expensive as it creates a number of objetcs thus keeping the gc busy.both in core and in jcr2spi EffectiveNodeType includesNodeType just does a lookup in a set. i don t see any object creation there. both in core and in jcr2spi EffectiveNodeType includesNodeType just does a lookup in a set. i don t see any object creation there. you re right. so the optimization is obsolete anyway. i believe it used to check EffectiveNodeTypeCache at some point creating WeightedKey objects.Classifying this as an improvement since even though the code wasn t correct AFAUI it didn t cause anything to break. Classifying this as an improvement agreed... i was already tempted to make that change Reopening for 1.5.0Fixed at revision 766747
