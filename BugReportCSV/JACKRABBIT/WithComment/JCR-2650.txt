don t silently merge session-local transient changes with external changes before save .
currently external changes i.e. changes committed by other sessions are silently merged with transient changes. this might potentially cause concurrency issues inconsistent transient state see e.g. JCR-2632 . it would probably be better to isolate transient changes from external changes until they re saved true copy-on-write .proposed patchattached patch with proposed changes.new patch removed some unwanted changes to test cases applied patch in trunk svn r966697 Nice work It looks like you proactively fixed the following deadlock scenario that we ran into with Jackrabbit 2.0    java.lang.Thread.State BLOCKED on object monitor at org.apache.jackrabbit.core.state.NodeState.copy NodeState.java 117 - waiting to lock 0xffffffff69f83dc0 a org.apache.jackrabbit.core.state.NodeState - locked 0xffffffff69f83d80 a org.apache.jackrabbit.core.state.NodeState at org.apache.jackrabbit.core.state.ItemState.pull ItemState.java 156 - locked 0xffffffff69f83d80 a org.apache.jackrabbit.core.state.NodeState at org.apache.jackrabbit.core.state.SessionItemStateManager.stateCreated SessionItemStateManager.java 907 at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateCreated StateChangeDispatcher.java 92 at org.apache.jackrabbit.core.state.LocalItemStateManager.stateCreated LocalItemStateManager.java 426 at org.apache.jackrabbit.core.state.StateChangeDispatcher.notifyStateCreated StateChangeDispatcher.java 92 at org.apache.jackrabbit.core.state.SharedItemStateManager.stateCreated SharedItemStateManager.java 397 at org.apache.jackrabbit.core.state.ItemState.notifyStateCreated ItemState.java 235 at org.apache.jackrabbit.core.state.ChangeLog.persisted ChangeLog.java 320 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.end SharedItemStateManager.java 775 at org.apache.jackrabbit.core.state.SharedItemStateManager.update SharedItemStateManager.java 1488 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 349 at org.apache.jackrabbit.core.state.XAItemStateManager.update XAItemStateManager.java 354 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 324 at org.apache.jackrabbit.core.state.SessionItemStateManager.update SessionItemStateManager.java 328 at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 1141    java.lang.Thread.State BLOCKED on object monitor at org.apache.jackrabbit.core.state.NodeState.getPropertyNames NodeState.java 436 - waiting to lock 0xffffffff69f83d80 a org.apache.jackrabbit.core.state.NodeState at org.apache.jackrabbit.core.NodeImpl.makePersistent NodeImpl.java 802 - locked 0xffffffff69f83dc0 a org.apache.jackrabbit.core.state.NodeState at org.apache.jackrabbit.core.ItemImpl.persistTransientItems ItemImpl.java 661 at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 1126 - locked 0xfffffffef2bc04d8 a com.day.crx.core.CRXSessionImpl at org.apache.jackrabbit.core.SessionImpl.save SessionImpl.java 920 In fact the above deadlock scenario still exists see JCR-3226 . Instead of stateCreated this issue fixed the potential problem with the much more frequent stateModified method.
