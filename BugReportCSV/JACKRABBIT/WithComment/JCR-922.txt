jcr mapping layer OCM should expose lock owner
jcr mapping layer s persistencemanager.java does not expose an API for returning lockowner. Ideally the following method public String lock final String absPath final boolean isDeep final boolean isSessionScoped should return a hashmap String array containing locktoken as well as lockowner. I tried having lockowner as a field in my java object and mapping it to jcr lockOwner so that I can just use getLockOwner . But the problem is this property gets introduced in the node only if the node is locked. So when I try to insert a node before I can even lock it the insertion fails since there is no property like jcr lockOwner till then . So I feel there is need for the above API. It is ok to have it exposed via separate call in order to maintain backward compatability Just 2 comments 1 Concerning the method lock it should be better to return an object instead of an hashmap. This object could be similar to the Lock object defined in the JCR spec but this is tedious to create a wrapper class for this kind of JCR object. We have exaclty the same kind of issues with the versionning support. 2 Supporting the mix lockable node type I understand your issue. The ocm framework has to have a better secondary node type support in term of field definition. I think we have to list the different use cases before taking a decision. I have a use case to implement where I am locking the checked out nodes and unlocking them after checkin. The latter half cannot be implemented without this feature. So what is the best and quickest way to resolve this For the the first issue see my previous comment it is quite easy to implement it with a class instead of an hashmap. For second one I have no solution until now. Let me think about that but I cannot work on it now. Any kind of proposal is welcome.If we go by your first comment We need the following 1. Wrapper class for Lock. 2. The method lock should return object of the wrapper class which can be used by caller to obtain lockowner. Does it not break backward compatability I mean the same method now returning a different object type Is that acceptable For the second problem maybe 3 possibilities 1 Don t add the Lock info lockowner ... in the pojo. This solution requires a new method in the persistence managers eg. PersistenceManager.getLock path . This method returns the Wrapper Lock object. 2 JCR mixin node types can be added and removed at any time. That s the case for the mix lockable. Each field-descriptor bean-descriptor and collection-descriptor element can have a new attribute which specify the associated mixin node type reference. If the mixin node type is not yet assigned to the node the mapping can be ignored for that attribute. class-descriptor className .... field-descriptor fieldName path path true field-descriptor fieldName title jcrName graffito title field-descriptor fieldName lockOwner jcrName jcr lockOwner mixintype mix lockable class-descriptor    3 Add a collection or a map in the pojo which will contain all available mixin type properties. It should be possible to create a new collection converter specific to mixin type property management. In your specific case the first solution is interesting. What is the interest to add lock info in the data value object Other solutions are more interesting for a generic support of mixin node types. I will create a new JIRA issue for this kind of support. What do you think about that Maybe another solution Answering your question What is the interest to add lock info in the data value object I am designing the checkin checkout in the following way User A checks out node X. User A locks node X. User B cannot update node X since it is locked by User A. User B can read the node X. User A unlocks node X User A checks in the node X. User B checks out node X User B locks node X. Basically a mutually exclusive lock for a checked out node. In my pojo I have the following method which allows checkin only if the lockowner is the one who is trying to checkin  public void checkin String path throws CMSException          pm getPersistenceManager          try             if pm.isLocked path                 String lockOwner getLockOwner get lockowner                 if lockOwner.equals session.getUserID                     String lockToken doc.getLockToken                     pm.checkin path                     pm.unlock path lockToken this call is already adding lock token in the session if that lock token is not present.                                         catch Exception e              throw new CMSException e.getMessage e.getCause                May be in the above method I can try checkin without checking for the node state locked or unlocked since now you have the check of checking in by the lockowner already incorporated in CheckIfNodeIsLocked . This might just work . In case lockowner is checking in this succeeds else throws exception. For a better understanding see the following code for checkout.  public void checkout String path throws CMSException         pm getPersistenceManager          try             pm.checkout path             if pm.isLocked path                 String lockToken pm.lock path true false                 Document doc this.getDocument path                 doc.setToken lockToken currently using property checkedOutBy for persisting lockToken can be changed later                 doc.save                        catch LockedException le            System.out.println Error le.getLockedNodePath is locked by le.getLockOwner           catch Exception e              throw new CMSException e.getMessage e.getCause                Can you check the code I made the following modifications 1 Review the method lock. Now it returns a Lock object. 2 I added new unit tests. See the class PersistenceManagerLockTest. the test called testLockWithNodeType uses an object containing the attribute lockowner. This attribute is null when the object is not locked and not null when it is locked. Let me know if it match to your needs. Feel free to comment this issue. This looks good. I think this meets all requirements. But I am not still able to build the new jcr-mapping jar . Still getting the same errors. Can you please comment on my last mail with subject error compiling jcr-mapping in Jackrabbit source treeRuchi Can you tell me if it is ok for you I m still thinking on a better mix node type support but I think the mix lockable is well supported and the persistence method now returns a lock object. Thanks
