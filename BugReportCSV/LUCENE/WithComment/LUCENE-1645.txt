Deleted documents are visible across reopened MSRs
If you reopen MSR with unchanged segments the resulting MSR will share SR instances for these segments. Consequently when you delete a doc in one of said segments through new MSR deletion will be visible in original MSR as no checks for shared SRs are done in delete . The patch illustrates the bug by altering existing test to reopen MSR- MSR instead of SR- MSR. Good catch So we are missing a clone on the old subreaders when referencing them from the new MultiSegmentReader Either that. Or having boolean readerShared as a property of MSR and check it on each modification attempt - lazy clone . rant on Or make readers immutable I already have a patch that removes norm updates lazy loading and synchronization. Then we only need to do deletes in IndexWriter without resorting to its reader pool. By the way do we need public IR cloneability Not for Lucene internals but for actual users That really looks like one more feature that can be safely removed. Lazy clone is a bad idea since it has to be synced. Lazy clone is a bad idea since it has to be synced. Right I think we should simply clone shared subreaders on reopen. Or make readers immutable I think it s too soon to do this. In theory NRT should enable us to deprecate deletions from IW but 1 we need NRT released and some real experience before doing so and 2 we still need to get setNorm working from IW. By the way do we need public IR cloneability I think we do Eg it enables you to clone a readOnly reader to a read write one in order to do deletes setNorm. Right I think we should simply clone shared subreaders on reopen. IFF the subreader being cloned is not readonly I think it s too soon to do this. Hey let s reverse readonly writeable reader inheritance WriteableSegmentReader extends SegmentReader. SegmentReader is readonly by behaviour and in code - there are no syncs and mutator methods throw UOE. WriteableSegmentReader adds a writeability layer over SegmentReader and all the gory syncs. I think we do Eg it enables you to clone a readOnly reader to a read write one in order to do deletes setNorm. Hey open a new IR if you want to write. Cloning reopening an IR while simultaneously switching readonly flag is a feature that gives user zero new functionality absolutely nothing he can t accomplish using a new IR but makes reopening cloning code more complex. IFF the subreader being cloned is not readonly OK. Hey let s reverse readonly writeable reader inheritance WriteableSegmentReader extends SegmentReader. SegmentReader is readonly by behaviour and in code - there are no syncs and mutator methods throw UOE. WriteableSegmentReader adds a writeability layer over SegmentReader and all the gory syncs. That sounds right but let s do this as a separate issue And leave this issue on fixing this particular bug. Hey open a new IR if you want to write. Cloning reopening an IR while simultaneously switching readonly flag is a feature that gives user zero new functionality absolutely nothing he can t accomplish using a new IR but makes reopening cloning code more complex. Opening a new IR is quite a bit more costly than cloning reopening. Plus the reopen cloning code will still need the complexity because internal to Lucene we still need to do this. We are only discussing whether the functionality should remain public which I think it should. Here s the fix. Plus slightly modified test that fails without the fix. Looks good... I ll commit shortly. Thanks Earwin 
