TopTermsScoringBooleanQueryRewrite minscore
when using the TopTermsScoringBooleanQueryRewrite LUCENE-2123 it would be nice if MultiTermQuery could set an attribute specifying the minimum required score once the Priority Queue is filled. This way FilteredTermsEnums could adjust their behavior accordingly based on the minimal score needed to actually be a useful term i.e. not just pass thru the pq An example is FuzzyTermsEnum at some point the bottom of the priority queue contains words with edit distance of 1 and enumerating any further terms is simply a waste of time. This is because terms are compared by score then termtext. So in this case FuzzyTermsEnum could simply seek to the exact match then end. This behavior could be also generalized for all n for a different impl of fuzzyquery where it is only looking in the term dictionary for words within edit distance of n which is the lowest scoring term in the pq they adjust their behavior during enumeration of the terms depending upon this attribute . Other FilteredTermsEnums could make use of this minimal score in their own way to drive the most efficient behavior so that they do not waste time enumerating useless terms. I would add this extra seeting to BoostAttribute itsself because it correlates with the retunred boost. This way the attribute is used in two directions. The only thing clear should leave this setting untouched equals and hashcode maybe should also ignore this too the default will be Float.NEGATIVE INFINITY The code to support this is added into the newest patch of LUCENE-2123 with few lines as it now also did not even try to insert uncompetitive hits into the PQ. The TermCollector would be changed from interface to abstract class that has a protected final accessor to the boostAttr. But for now we should wait with adding this to BoostAttr. I would add this extra seeting to BoostAttribute itsself 1 So BoostAttr would have something like set getMinCompetiveValue or something This same sort of optimization would be interesting to explore for Lucene s sorting btw. EG say I m sorting by an int field keeping top 10 resuls and I m collecting alot of hits. I see at some point that the bottom of the queue has int value 7. At this point because the int from FieldCache is RAM resident it d likely be faster possibly much faster for complex queries to jump into the field cache skip forward until you find a doc that has 7 as its value and ask the Scorer to advance to that doc. Ie there comes a time in the search where the int value of that field is a more performant way to drive the scoring. I wonder if sorting by relevance could do something similar... eg if we know at some point the worst bottom relevance in our queue is 2.0 can any Scorer out there somehow use that info to efficiently skip forward. Maybe only TermScorer when norms aren t in use though... Here the patch. Robert Is this what you need Any better method names Maybe the method should have a better name instead of minXXXX This is not the minimum possible boost that would go into the PQ it is the largest boost that would not go into the PQ so the check in the enum should be accept term only if its boost is boost hint . minCompetitiveBoost minRequiredBoost The problem with minCompetitiveBoost minRequiredBoost is that exactly that boost is not competitive it must be slightly larger... get setMaxNonCompetitiveBoost ... get setYouMustBeTallerThanThisToRide get setMaxNonCompetitiveBoost 1 Patch with further access modifier changes and new method name javadocs. I will commit this patch later today. Committed revision 890308 Thanks all 
