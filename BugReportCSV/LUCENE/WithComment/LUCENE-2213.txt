Small improvements to ArrayUtil.getNextSize
Spinoff from java-dev thread Dynamic array reallocation algorithms started on Jan 12 2010. Here s what I did Keep the 3 for small sizes Added 2nd arg number of bytes per element. Round up to 4 or 8 byte boundary if it s 32 or 64 bit JRE respectively Still grow by 1 8th If 0 is passed in return 0 back I also had to remove some asserts in tests that were checking the actual values returned by this method Ð I don t think we should test that it s an impl. detail . Algorithm looks good. The addition of the mandatory second argument works well. Nice work. Looks like there s a typo in the currently unused constant NUM BYTES DOUBLT . As for the tests... Testing that optimizations like these are working properly is a pain so I understand why you zapped em. Sometimes inequality or proportional testing can work in these situations assertTrue t.termBuffer .length t.termLength That assertion wouldn t always hold true for this object because sometimes the term will fill the whole array. And in a perfect world you d want to test that each and every array growth happens as expected Ð but that s not practical. Still in my opinion a fragile imperfect test in this situation is OK. Thanks Marvin I fixed the typo. I don t really like that test since conceivably though unlikely it could fail with a false positive. So I made a new test case TestArrayUtil which in fact uncovered serious problems with my first patch due to overflowing int Sigh. I ve fixed those problems and the test now passes. The test measures the amortized copying cost over a series of reallocations and then somewhat arbitrarily asserts that the cost per element is less than 10.0 through all reallocations up to size Integer.MAX INT. Also I found one more place where we were assuming ArrayUtil.grow X returned the same value regardless of type which is no longer true. Amazing how tricky such a low-level utility function is.... Not to be picky Michael but is long promotion required here Would it be easier to see if you overflow into negative integers and if so set to MAX VALUE Another thing Ð given the fact that the parameter is an int you ll never be able to grow beyond Integer.MAX VALUE because no int value exists . I d change the contract to reflect this fact Ð if the signature takes two parameters int currentSize int expectedAdditions then it s easy to throw an unchecked exception if you simply can t meet the contract if currentSize expectedAdditions 0 throw new RuntimeException Cannot allocate array larger than Integer.MAX VALUE When reallocating you can call it with grow currentSize 1 just to make sure the array will be at least one element larger than previously the method can then make its best effort in estimating the growth ratio but have a cap on MAX SIZE before overflowing into negative integers and avoid looping endlessly when Integer.MAX VALUE is passed as an input argument . These are just thoughts of course Ð I ve just finished implementing something like this for another project... Yeah... it s not great promoting to long. It s because of the intermediate computation to do the byte alignment. I could instead do that computation back in the num elements space... let me try that. Then I can check for negative ints to catch the overflow. Note that the args are different from above Ð first arg is min target size ie this method must return a size that requested size. 2nd arg is the element size. Like calloc. Instead of masking with 7fff... you can mask with ffff... and let it naturally overflow to a negative. No need to check the return value it should then fail immediately when the value is used. What Yonik suggested is yet another alternative just return negative size and an exception will be thrown elsewhere. Instead of masking with 7fff... you can mask with ffff... and let it naturally overflow to a negative The thing is if we blindly add the extra allocation return we ll lose up to 1 8th of the usable size of the array Ie we ll return a negative number when in fact we could have returned MAX INT and allowed the caller to use the full allowed extent for arrays in java. How about if you assert that minTargetSize is not negative first then check if minTargetSize extra is negative if so round to the largest possible value that fits within the positive range New rev. No longer promotes to long does the rounding in element space instead of bytes space uses wraparound on ints to negative numbers to detect overflow return Integer.MAX VALUE. How about if you assert that minTargetSize is not negative first then check if minTargetSize extra is negative if so round to the largest possible value that fits within the positive range That s the approach I took in the last patch. Perhaps the getNextSize method could be renamed to overAllocate or overAllocateSize. I don t really like overAllocate overAllocateSize since this method isn t actually doing any allocation. getNextAllocation getOverAllocation getOverAllocationSize too verbose Actually I sort of like grow growth better Ð getGrowth getNextGrowth Translating from Dutch groeischeut how about getShootGrowth fromSize The thing is if we blindly add the extra allocation return we ll lose up to 1 8th of the usable size of the array Yep - depends on what this is being used for. Some thing you know will never go that high something you don t. All this generification is super-lightweight for arrays of any kind of size... but if it starts getting used very often for very small arrays the overhead will start to matter. Seems like the one permutation of over allocation and size you ve omitted is oversize minimum width . It s a style thing but I try to use get for accessors and avoid it elsewhere. if it starts getting used very often for very small arrays the overhead will start to matter I think in most cases usage will only occur after an inequality test when it s known that reallocation will be occurring. In my experience the overhead of allocation will tend to swamp this kind of calculation. if needed capacity int amount ArrayUtil.oversize needed RamUsageEstimator.NUM BYTES CHAR buffer new char amount Seems like the one permutation of over allocation and size you ve omitted is oversize minimum width . It s a style thing but I try to use get for accessors and avoid it elsewhere. Actually I like oversize minimum width New patch just renaming to ArrayUtil.oversize. Here a patch that merges the duplicate test class. Patch looks good Ð I ll commit. Thanks Uwe This somehow found its way to 3x I believe it was before the branch . And now we have a case where a code is compiled against 3.0.1 and does not run when 3.1 dev version is used. I don t this change on 3.0.2 so perhaps we should just rename it back on the 3x branch I just noticed it s lucene.internal so I guess the rename is justified. There is however a deprecated public ctor which is silly because the class contains nothing but static methods. So why would anyone instantiate it And why do we go overboard preventing it by declaring a private ctor ... I think we can just remove the ctor. Any objections Having a private constructor is a nice way of indicating that the class just contains static methods and will only ever contain static methods. That s more the methodology w the singleton pattern. If we want to achieve what you mention we can make the class abstract. But really - how stupid do we think our users are It s a Util class w static methods - why would they ever instantiate it Then make it abstract. My suggestion has nothing to do with user level but stems from a pattern I see very regularly in code. But since you seem so vehemently against it I ll happily support removing it. I m not vehemently against anything . It s just that in the rest of our classes or at least UnicodeUtil which I was reading few minutes ago we didn t follow that behavior so why with this one Thats a good question. Its definitely best to be consistent so if its just this in this class then lets remove it.
