Numeric range searching with large value sets
I have a set of enhancements that build on the numeric sorting cache introduced by Tim Jones and that provide integer and floating point range searches over numeric ranges that are far too large to be implemented via the current term range rewrite mechanism. I m new to Apache and trying to find out how to attach the source files for the changes for your consideration. Created an attachment id 15999 The query component for large integer ranges Created an attachment id 16000 The scorer component complementing the integer range Created an attachment id 16001 large floating point range class Created an attachment id 16002 scorer for floating point range Created an attachment id 16003 modification to rewrite method of RangeQuery This allows you to control the use of the larger numeric range queries by manipulating the maximum subclause member of BooleanQuery. It catches the TooManyClauses exception from the construction of the range and attempts to create either an integer or floating point query of the new variety. Created an attachment id 16004 some quick sort implementations for the range query implementation Maybe there are better places to get these algorithm implementations but this implementation requires the fastest possible indirect sort of document numbers against field values. I hit fields with many repeated values in testing and decided it was worth having a fat pivot implementation. The sort used in actual query execution is everyday non-recursive quicksort. Created an attachment id 16005 two new constants for use against the sorting cache Okay found the attachments. IMHO numeric range query capability is pretty useful BUT this implementation like the sorting implementation introduces a fairly lengthy cache-warming cost for the first query executed like 0.5 seconds . The implications of this will vary with application but should certainly be considered in a dynamically updated installation. Created an attachment id 16006 FieldCacheImpl.java Extensions of the field cache implementation that build the range data structures for integers and floating point How about rewriting to BitSetQuery instead of BooleanQueries How I cracked this nut was to manipulate numbers such that they index properly and then use a ConstantScoreRangeQuery http issues.apache.org bugzilla show bug.cgi id 34673 In reply to comment 11 How I cracked this nut was to manipulate numbers such that they index properly and then use a ConstantScoreRangeQuery http issues.apache.org bugzilla show bug.cgi id 34673 Thanks Yonik using a filter like this will certainly work functionally but I need range queries to perform well and filtering is kind of like full table scans in the relational world. In my use cases the range queries are the primary document reduction mechanism so I wouldn t benefit from skip to implementation to avoid reading a lot of field values. In reply to comment 10 How about rewriting to BitSetQuery instead of BooleanQueries I m not familiar with BitSetQuery and it isn t in the released version I m using. What does it do Randy I haven t looked at the source yet but is the aim to allow for queries such as give me documents that have a price in a range from 0.99 to 9.99 From the sound of this this looks useful. I hardly ever use range queries so could you please explain what you mean by ... searches over numeric ranges that are far too large to be implemented via the current term range rewrite mechanism How does the current implementation deal with a large numeric range and how does your contribution fix it Thanks. In reply to comment 14 Randy I haven t looked at the source yet but is the aim to allow for queries such as give me documents that have a price in a range from 0.99 to 9.99 From the sound of this this looks useful. I hardly ever use range queries so could you please explain what you mean by ... searches over numeric ranges that are far too large to be implemented via the current term range rewrite mechanism How does the current implementation deal with a large numeric range and how does your contribution fix it Thanks. Yes this change will efficiently implement floating point ranges like .99 to 9.99. The current rewrite scans terms therefore lexicographically from the beginning of the range and generates a boolean query that is the disjunction of all the terms falling in the lexicographic range. Any large range throws TooManyClauses. You ll note in an earlier comment that 34673 is a contribution that fixes this case essentially by turning the query into a filter. My submission catches the TooManyExceptions exception within the rewrite method of RangeQuery then attempts to construct either an IntegerRangeQuery or FloatRangeQuery this permits you to control the mechanism by manipulating the maximum boolean clauses . Both of these work by 1 pulling field values for all docnos as in the numeric sorting solution 2 creating an array of docnos then sorting that array relative to the field values 3 at query time the bounds are found using indirect binary search on the docnos to find the set of docnos that match the range 4 the query sorts this set of docnos back into docno order and returns that set Range sorting is useful for e.g. prices heights etc. etc. Created an attachment id 16115 IntStack.java Doh My fault for not including the attachment I juste made some junit test using some IntegerRangeQuery s and I get some strange results. I attached the junit test I used. It fails on the last assert. I am expecting only one result the date between 1981 and 1983 but I get 2 The test output is term date 1980 term date 1982 term date 1984 RangeQuery q date 1981 TO 1983 Document stored uncompressed indexed tokenized date 1982 IntegerRangeQuery q date 1981 TO 1983 Document stored uncompressed indexed tokenized date 1982 Document stored uncompressed indexed tokenized date 1984 Fix for the bug found by IntegerRangeQueryTest Closing - a few years old now and we currently have NumericRangeQuery.
