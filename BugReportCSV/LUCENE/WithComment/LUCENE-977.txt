internal hashing improvements
Internal power-of-two closed hashtable traversal in DocumentsWriter and CharArraySet could be better. Here is the current method of resolving collisions if text2 null equals text len text2 final int inc code 1347 1 do code inc pos code mask text2 entries pos while text2 null equals text len text2 The problem is that two different hashCodes with the same lower bits will keep picking the same slots the upper bits will be ignored . This is because multiplication 1347 only really shifts bits to the left... so given that the two codes already matched on the right they will both pick the same increment and this will keep them on the same path through the table even though it s being added to numbers that differ on the left . To resolve this some bits need to be moved to the right when calculating the increment. Here is a patch that adds in 7 new bits the rightmost bit is destroyed to make the number odd when calculating the incrementor via final int inc code 8 code 1 And thus gives 128 different possible paths to follow per slot on the first collision on that slot. Ideally we would shift log2 size of hashtable but it s probably not worth calculating that and I chose a small shift so it would work well for small hashCodes say from a very short string . Given that equals in these cases is probably pretty fast the average speedup is probably relatively minimal. Comments This is an excellent change and makes complete sense that it will resolve conflicts faster than the first way. I say commit it committed.
