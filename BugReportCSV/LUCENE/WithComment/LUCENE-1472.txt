DateTools.stringToDate can cause lock contention under load
Load testing our application the JIRA Issue Tracker has shown that threads spend a lot of time blocked in DateTools.stringToDate . The stringToDate method uses a singleton SimpleDateFormat object to parse the dates. Each call to SimpleDateFormat.parse is synchronized because SimpleDateFormat is not thread safe. The following methods would potentially suffer contention as well depending on usage patterns of the particular app stringToTime dateToString timeToString SimpleDateFormat javadoc Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently it must be synchronized externally. Could you try changing the code to create a new object every time and then run your load test again We original did that but it was slower at least according to this commit comment from two years ago Don t re-create SimpleDateFormat objects use static ones instead. Gives about a 2x performance increase in a micro benchmark. ThreadLocal My original thought was ThreadLocal but I tend to try and avoid these where possible. I wanted to test the speed on creating a new Calendar rather than SimpleDateFormat for each request but was worried about the instantiation overhead. Daniel s comment above reinforces this concern to some extent so we ll have to wait and compare benchmarks. If you review the source for SimpleDateFormat you will see that it internally performs some synchronization during initialization anyway uses some Hashtables and also that the initialization cost is pretty high lots of code so a static sync d copy is probably best. Outside of that the ThreadLocal is the way to go. My tests shows that the instantiation time is 2x longer than the typical parse time. The last comment was tested using Java 5. It is my understanding that in Java 6 synchronization has become even cheaper - although object creation is cheaper as well - although 99 of the instantiation time of SimpleDateFormat is in the init code not the object creation. I know there has been a lot of discussion of the problems with ThreadLocals... I ve been a part of most of them - but for these very small objects the typical ThreadLocal memory issues don t really apply. I agree ThreadLocal despite its problems is probably the best solution here. The memory cost ought to be tiny. We could also use CloseableThreadLocal which works around the problems of ThreadLocal and then allow DateTools to be instantiated and add a close method to it vs the all-static methods we have today . This way the application could close the DateTools instance and reliably free up the tiny amount of memory used. An update for anyone interested The test run that showed this contention suffered even worse contention in another component of our application. Since we have fixed that component we have no longer observed contention in DateTools.stringToDate . For that reason this issue is not now considered a priority for us. Removing 2.9 target. This is not longer highest priority but the fix using ThreadLocal without close seems to be the best possibility. We use this in our local applications too when we have a pool of DateFormats. I will take care on applying this patch. In general this NumericRangeQuery and NumericField should be used when dates should be indexed. Here the patch using one ThreadLocal statically. theoretically this class still contains a non-enum which shold in reality an enum. We can change this later or deprecate this class at all I will commit tomorrow to trunk and 3.x Better patch with also the stupid enum declared as enum. Now the constant lookup should even faster in table-switch statement . Will commit soon. Committed trunk revision 1063493 Committed 3.x revision 1063494 Bulk close for 3.1
