PersistentNode.store ignores status when storing
While looking for a performance bottle neck I came across this issue When a PersistentNodeState is asked to store itself in the PersistentNodeState.store method it calls its PersistenceManager to store it. This is not a problem in itself. The problem is that if the PersistentNodeState has not been modified the object does not need to be stored. Doiing it anyway just consumes cycles In the case of a deep unmodified hierarchy this just results in nodes being written to persistence for nothing. Comes to it that this method sends an event which in the case of an unmodified node state will be notifyStateUpdated which is complete nonsense because nothing has actually been updated. I suggest to modify the PersistentNodeState.store method to only do work if modified. Note I encountered this issue whily tracking down performance problems when creating versionable nodes which turned out to be located somewhere within the PersistentVersionManager.createVersionHistory NodeImpl method. And there predominantly the store methods consume time.Just for checking I added if status STATUS EXISTING return at the beginning of the PersistentNodeState.store and performance increased depending on the number of history entries from 2x times way up to 10x and more BTW I just noticed that PersistentPropertyState has the same issue of storing without checking for the need to store.The concept here is that the PersistentNodeState should not be to intelligent it is rather managed from outside. so store will store and does not repsect the status. the performance bottleneck in versioning is caused by the PersistenNode which is a helper class for easily modifying persistent node states and in the PersistentVersionManager. the status of the underlaying node state should be respected there. so store will store and does not repsect the status. Ok but why does it use the status to decide on which event to send As it may be the case that the instance is not modified an updated message does not make sense to me. On the other hand there is not enough JavaDoc for me to know it - added check to org.apache.jackrabbit.core.version.PersistentNode. rev 56421 Now those additions provide a real performance boost. Unfortunately the version history is lost when the repository is shutdown... The problem is that ItemState and its descendents NodeState PersistentNodeState do not properly handle the status field. For example the NodeState.addChildNodeEntry does not set the status to modified. Consequently the NodeState is not transient when it is time to store and therefore it is never stored. What happens is    - create a mix versionable node      - internally creates the version history call it XX below            jcr persistentVersionStorage      - creates nodes and properties below XX and stores them      - but as XX itself is not transient XX is not stored. The net effect is that the version history nodes and properties exist but the jcr persistentVersionStorage node has no link to the version history node just created. The next time the repository is started a NullPointerException is thrown if the version history of the node initially created is accessed. Steps to reproduce    - Start empty repository    - Create a mix versionabl node root    - Save    - Shutdown the repository    - Start the repository    - Access the version history of root At that point you get a NullPointerException on line 103 of the InternalVersionHistory class. SVN Version 56602 of the class PersistentNode now sets proper status to underlaying PersistentNodeStates when beeing altered.closing resolved issue
