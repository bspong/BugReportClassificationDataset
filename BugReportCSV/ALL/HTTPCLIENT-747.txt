No entry created for this pool.
Followup to https issues.apache.org jira browse HTTPCLIENT-741 as reported by Sam Berlin java.lang.IllegalStateException No entry created for this pool. HttpRoute - http 74.160.66.42 14561     at org.apache.http.impl.conn.tsccm.RouteSpecificPool.freeEntry RouteSpecificPool.java 137     at org.apache.http.impl.conn.tsccm.ConnPoolByRoute.freeEntry ConnPoolByRoute.java 337     at org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager.releaseConnection ThreadSafeClientConnManager.java 230     at org.apache.http.impl.client.DefaultClientRequestDirector.execute DefaultClientRequestDirector.java 427     at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 500     at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 455     at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 421     at com.limegroup.gnutella.http.DefaultHttpExecutor.performRequest DefaultHttpExecutor.java 97     at com.limegroup.gnutella.http.DefaultHttpExecutor.access 000 DefaultHttpExecutor.java 26     at com.limegroup.gnutella.http.DefaultHttpExecutor MultiRequestor.run DefaultHttpExecutor.java 139     at org.limewire.concurrent.ThreadPoolExecutor.runWorker ThreadPoolExecutor.java 1006     at org.limewire.concurrent.ThreadPoolExecutor Worker.run ThreadPoolExecutor.java 549     at java.lang.Thread.run Thread.java 613 DefaultHttpExecutor MultiRequestor basically is just a Runnable Cancellable exposes a cancel method that can be cancelled from any thread. cancel just calls abort on the current AbortableHttpRequest but is called on a thread other than the one that s doing the client.execute request . The last one is the most common exception and seems to happen with some regularity. The other two we ve only seen once so may just be a memory quirk we ve seen some crazy bugs including recursive NPEs while constructing an NPE. Roland I think there is still time to fix this one so it could go into alpha3 OlegHi Oleg I don t have cycles available to take care of it in the short term. If you have please go ahead. One possible explanation is that a connection goes stale after being checked for consistency but before the big lock of the connection pool is obtained. That could be the case if two threads try to release the connection at about the same time. But after your changes in HTTPCLIENT-741 only the allocating thread should be releasing the connection right To catch this one would need a second consistency check after the lock is obtained. Another more simple explanation is that the route stored in the connection is incorrect at release time. cheers   Roland We re still being hit by this in the httpclient-4.0-alpha4-20080303.184117-1.jar snapshot so I sleuthed around to see what I could dig up. I added some debugging log-statements into the code and was able to retrigger the bug. This is what printed 1968 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Requesting from http one.ip.address.and port request-uri 1968 DEBUG PushProxy Requests tsccm.RouteSpecificPool.createdEntry - Creating an entry will be 1 for route HttpRoute - http one.ip.address.and port 18818235 3968 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Requesting from http one.ip.address.and port request-uri 3968 DEBUG PushProxy Requests tsccm.RouteSpecificPool.createdEntry - Creating an entry will be 2 for route HttpRoute - http one.ip.address.and port 18818235 6968 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Request finished http one.ip.address.and port request-uri 8609 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Requesting from http one.ip.address.and port another-uri 8968 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Request finished http one.ip.address.and port request-uri 13968 DEBUG Timer-0 http.DefaultHttpExecutor.shutdown - Aborting request to http one.ip.address.and port another-uri 33203 DEBUG RefQueueWorker org.apache.http.impl.conn.tsccm.ConnPoolByRoute 1e081c5 tsccm.RouteSpecificPool.dropEntry - Dropping an entry will be 1 for route HttpRoute - http one.ip.address.and port 18818235 33203 DEBUG RefQueueWorker org.apache.http.impl.conn.tsccm.ConnPoolByRoute 1e081c5 tsccm.RouteSpecificPool.dropEntry - Dropping an entry will be 0 for route HttpRoute - http one.ip.address.and port 18818235 33218 DEBUG PushProxy Requests tsccm.RouteSpecificPool.createdEntry - Creating an entry will be 1 for route HttpRoute - http one.ip.address.and port 18818235 33828 DEBUG PushProxy Requests tsccm.RouteSpecificPool.freeEntry - Freeing an entry for route HttpRoute - http one.ip.address.and port 33212367 java.lang.IllegalStateException No entry created for this pool. HttpRoute - http one.ip.address.and port         at org.apache.http.impl.conn.tsccm.RouteSpecificPool.freeEntry RouteSpecificPool.java 142         at org.apache.http.impl.conn.tsccm.ConnPoolByRoute.freeEntry ConnPoolByRoute.java 337         at org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager.releaseConnection ThreadSafeClientConnManager.java 230         at org.apache.http.impl.client.DefaultClientRequestDirector.execute DefaultClientRequestDirector.java 427         at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 500         at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 455         at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 421         at com.limegroup.gnutella.http.DefaultHttpExecutor.performRequest DefaultHttpExecutor.java 102         at com.limegroup.gnutella.http.DefaultHttpExecutor.access 0 DefaultHttpExecutor.java 93         at com.limegroup.gnutella.http.DefaultHttpExecutor MultiRequestor.run DefaultHttpExecutor.java 146         at org.limewire.concurrent.ThreadPoolExecutor.runWorker ThreadPoolExecutor.java 1006         at org.limewire.concurrent.ThreadPoolExecutor Worker.run ThreadPoolExecutor.java 549         at java.lang.Thread.run Unknown Source 33828 DEBUG PushProxy Requests http.DefaultHttpExecutor.performRequest - Request finished http one.ip.address.and port another-uri Keep in that that for better or worse every method execution is done with a different instance of HttpClient. Also note that more than 1 thread is named PushProxy Requests so don t be confused thinking that s all one thread. This is what the lines in the logs mean  DefaultHttpExecutor.performRequest with Requesting from HttpClient.execute HttpUriRequest is about to be called.  DefaultHttpExecutor.performRequest with Requested finished after HttpClient.execute HttpUriRequest has returned.  RouteSpecificPool.createdEntry createdEntry is called with the given route. The will be number is what numEntries will increment too. The number at the end after the comma is System.identityHashcode of the RouteSpecificPool object.  DefaultHttpExecutor.shutdown HttpUriRequest.abort is about to be called.  RouteSpecificPool.dropEntry dropEntry is called with the given route. The will be is what numEntries will decrement too and the number after the comma is the identityhashcode of RouteSpecificPool.  RouteSpecificPool.freeEntry freeEntry is called with the given route. The number after the gonna is the identityhashcode of the RouteSpecificPool. Things that confuse me  - Why did it take so long between the 8609 request for another-uri till the 33218 createdEntry Could a delay in connecting at the socket-level cause this Are the two entries even related  - If the request was aborted at 13968 why did it still try to to create an entry 33218 and what could cause the long delay  - Why is the identityhashcode for the 33828 freeEntry different from the identityhashcode of every other RouteSpecificPool There were connections to other hosts intermingled in the logs but I stripped those out. If they re useful for debugging let me know and I can attach the whole thing. Let me know if there s other things that could be useful and I ll try to recreate this again. If I can figure out what can cause those log statements to be printed out I should be able to reproduce this more easily.Also if it s useful the first two connect attempts to request-uri both failed at the socket-connect level with a timeout of 5 seconds.Some more investigation some possible bugs It doesn t look like entries are cleaned up correctly if the socket connection fails. DefaultClientRequestDirector.execute allocates an entry for a route before opening a connection. Then if there s an exception while opening the socket it doesn t look like the entry is freed up. That means that subsequent requests to the same route will fail if it s over the maximum limit per host . This explains why it took so long to create a third entry after the first two failed it happened whenever the system just-so-happened to GC. I suspect this is also a problem with exceptions during normal i o exchange but I m not sure. It also doesn t look like abort will correctly terminate a connection that s waiting to receive a ManagedClientConnection from the ClientConnectionManager. There s an abort sequence set on the HttpUriRequest but it s set to be the ManagedClientConnection which is only created when allocateConnection returns. This explains why it tried to create an entry after an abort was called because the wait-for-connection didn t finish. Normally I would suggest requiring the caller to call Thread.interupt to abort the wait but that isn t terribly safe especially with I O being performed on that thread there s no way to know from the outside if the internals have succeeded in getting a connection and moved onto I O. There s two ways of fixing it that I can see one is to add a releaseTrigger prior to calling allocateConnection that just calls Thread.interrupt and then overwriting it afterwards. Another way is to pass the AbortableHttpRequest down the chain eventually into ConnPoolByRoute.getEntry and let it install a more proper releaseTrigger probably using a method in WaitingThread that signals completion but has await return false it could also use Thread.interrupt I m just not the biggest fan of that method . I m still boggled by the freeEntry call. It s as if a connection succeeded but one with an entirely different RouteSpecificPool. No clue on how to explain that one.Hi Sam the abort problem is HTTPCLIENT-734 cheers   Roland Thanks I ll think about it and post some comments there. Happen to have any ideas about the socket connect timeout not releasing an entry issue Is it an actual problem or am I thinking about it wrong Sam Tim are you still seeing this exception I am unable to reproduce it no matter what I try. Do you have some code not necessarily a unit test case you could share OlegWe haven t released a new beta yet with the volatile fixes so that might have fixed it. Without the volatile fixes we definitely saw the exception. Will try to get a new release out w the updates... been a crazy week.Tim I am closing this issue as cannot reproduce for now. Please re-open it if you manage to reproduce the bug with the latest code snapshot. OlegThe problem is still there. Issue reopened OlegCan t reproduce this issue anymore looks like the recent changes have fixed it.Neither can I. Let s hope it s been fixed for good now. Oleg
