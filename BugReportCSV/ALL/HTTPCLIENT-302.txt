exception during writeRequest leaves the connection un-released
The execute method has the following simplified flow 1 get connection 2 write request 3 read result 4 release connection. The release in step 4 happens when the input is completely read which works fine. If an exception occurs between steps 1 and 2 the connection is also released properly. However if an exception occurs during step 2 the connection is never released back and the connection manager eventually runs out of connections. The easiest way to test this is to make a simple subclass of PostMethod that overrides the writeRequest method public class TestConnectionReleaseMethod extends PostMethod     protected void writeRequest HttpState state HttpConnection conn throws IOException HttpException               throw new IOException for testing      Hhm I O exceptions thrown in writeRequest method are supposed to be treated as recoverable causing the writeRequest method to be retried without releasing the connection. What kind of exception are you getting exactly Besides any idea if CVS HEAD also exhibits this problem OlegThe unfortunate reality with IOExceptions is that they can occur when you least expect them. I ran into this while doing rigorous exception testing see the test code below . The statement writeRequest method are supposed to be treated as recoverable appears to be false the method signature has IOException in it. It is not possible to remove that either because an IOException can truly occur during the write. Of course it is possible to change the method signature to throws HttpRecoverableException and catch other exceptions and wrap them as HttpRecoverableException. However from the HTTP spec a generic writeRequest is not simply retriable it is not considered idempotent for POST PUT etc see section 9.1 of the RFC . I would strongly discourage wrapping the IOException inside writeRequest. The statement writeRequest method are supposed to be treated as recoverable appears to be false the method signature has IOException in it Feel free to examine the source code and double-check. There is one situation I know of when I O exceptions would not be rethrown as HttpRecoverableException that is the connection is not known to have successfully completed a write operation at least once. In all other cases I O exceptions are rethrown as HttpRecoverableException derived from IOException . However from the HTTP spec a generic writeRequest is not simply retriable it is not considered idempotent for POST PUT etc see section 9.1 of the RFC . I would strongly discourage wrapping the IOException inside writeRequest If understand the word of the spec correctly the section 9.1 postulates that ... methods can also have the property of idempotence in that ... the side-effects of N 0 identical requests is the same as for a single request... HttpClient never automatically re-executes requests on a read operation failure. Auto-recovery MAY takes place if enabled on a write operation that is the request body never makes it to the server in its entirety . That guarantees that there s at least one but not more that one successful request for a given resource. Feel free to correct me if I am missing something. Besides auto-recovery can be customized through the use of MethodRetryHandler interface Again any idea under what circumstances the reported problem occurs Do you happen to know if CVS HEAD also exhibits the problem OlegThis is an interesting discussion and I really appreciate the attention time and effort that goes into answering this. Let me answer the questions first any idea under what circumstances the reported problem occurs The problem has not yet occured in running code. It was detected during exception testing . By exception testing I mean I put a line of code that says if CAUSE RANDOM ERROR if Math.random ERROR RATE throw new IOException Random error for testing only anywhere an IO operation can occur. You d be amazed the kinds of issue that come to light when you do this. Essentially it is a decent way to test all the error handling code that people write but only execute under rare circumstances. Do you happen to know if CVS HEAD also exhibits the problem This is against RC2. The CVS codepath is quite different but from reading the source I m don t think the problem is fixed. Essentially the connection is only released if the response body is consumed. If the write failed there is no body to consume and therefore the release won t occur. Feel free to examine the source code and double-check. There is one situation I know of when I O exceptions would not be rethrown as HttpRecoverableException that is the connection is not known to have successfully completed a write operation at least once. In all other cases I O exceptions are rethrown as HttpRecoverableException derived from IOException . From reading the code it seems the outputstream is wrapped inside WrappedOutputStream which rethrows any exceptions inside its methods as recoverable. There are two problems with this approach. 1 IOExceptions can and do occur outside the methods wrapped by WrappedOutputStream. 2 examples a FilePart.java line 258 is reading a file. That can throw an IOException. No amount of wrapping of the OutputStream will catch this. b A custom method that further wraps the stream e.g. with an ObjectOutputStream may throw errors without ever touching the underlying stream e.g. NotSerializableException . 2 RuntimeExceptions have the same effect. HttpClient never automatically re-executes requests on a read operation failure. Auto-recovery MAY takes place if enabled on a write operation that is the request body never makes it to the server in its entirety . That guarantees that there s at least one but not more that one successful request for a given resource. Feel free to correct me if I am missing something. Besides auto-recovery can be customized through the use of MethodRetryHandler interface Thanks for the clarification. You still have to be extremely careful if you enable auto recovery on write. Just because the write failed somewhere doesn t mean the server didn t do anything. Take the simple case of a multi-part mime message consisting of several files to be saved on the server . If the last file being sent dies with an IOException e.g. the network drive it was on went to lala land the server very likely already received and processed all the files prior to that. Resending those files can cause major issues for example the server may refuse to overwrite an existing file a batch process waiting for a file may rerun some transactions etc . How about this fix add                 catch IOException e                     releaseConnection true                     throw e                  catch RuntimeException e                     releaseConnection true                     throw e                  to the last try clause in HttpMethodDirector executeWithRetry Thanks Moh if CAUSE RANDOM ERROR if Math.random ERROR RATE throw new IOException Random error for testing only OK. I see. From reading the code it seems the outputstream is wrapped insideWrappedOutputStream which rethrows any exceptions inside its methods asrecoverable. There are two problems with this approach. Mohammad actually that is that way it is supposed to be. IOException thrown when retrieving request content or runtime exceptions are not recoverable HTTP transport exceptions and should not be treated as such Thanks for the clarification. You still have to be extremely careful if you enable auto recovery on write. Agreed. I personally am not in favour of having auth-recovery activated per default but according to the feedback we were getting from our users the majority did not appear to share that conviction. How about this fix add catch IOException e releaseConnection true throw e catch RuntimeException e releaseConnection true throw e to the last try clause in HttpMethodDirector executeWithRetry That can be done. I would not like to change 2.0 branch though for the following reason the invocation of HttpClient execute HttpMethod MUST be followed by HttpMethod releaseconnection regardless of the outcome preferably by calling it in the finally clause . This is a part of HttpClient API contract. So personally do not see this bug serious enough to warrant modification of HttpClient 2.0 which is the release candidate phase. OlegCreated an attachment id 9607 Test case and 2.0 patch Here s a test case and a possible fix for 2.0. I m not sure this is exactly what we want but it s a start. Mikei believe that this has something to do with the fact that the connection would have to be closed because HttpClient cannot finish the request due to the lack of data. the anoying thing for me was that HttpClient tries to finish a HTTP-request if one calls releaseConnection . finishing a HTTP-request ment downloading the rest of the requested data for me. in this case this behaviour is even more fatal. this is a serious issue since it causes connections to idle around if this error happens - if i understand everything correctly.Same condition occurs on a RuntimeException. Mike s patch can easily be updated to take care of it. Thanks Moh Created an attachment id 9617 Possible patch 2 Okay. Here it is. This one releases and closes the connection in the event of an unrecoverable exception in HttpMethodBase.processRequest . Let s give it a try and see how it holds up. Mike 1 to be committed. OlegPatch applied to 2.0. MikeCreated an attachment id 9904 Patch against HEAD take 1 Mike s patch ported to CVS HEAD. Please reviewLooks good. MikePatch committed to CVS HEAD. Oleg.
