BooleanQuery assumes everything else implements skipTo
skipTo seems to be optional functionality on the Scorer class BooleanScorer doesn t implement it . BooleanQuery.scorer tests all subclauses using instanceof BooleanQuery to determine if it can use a ConjunctionScorer that requires skipTo functionality. This means that any other new Query Scorer that don t implement skipTo will get into trouble when included in a BooleanQuery. If skipTo is really optional then there should be some way of telling by the Scorer or the Query in a more generic manner. Some options 1 have a boolean Scorer.hasSkipTo method 2 have a boolean Query.hasSkipTo method 3 remove Scorer.skipTo and have a public interface ScorerSkipTo boolean skipTo int doc that scorers may implement Yonik Please have a look at bug 33019. The point you make here is not mentioned there. With term doc enumerator implementing skipTo all scorers can implement skipTo efficiently. During development of a new scorer one can temporarily use the code shown in the javadocs of Scorer that implements skipTo with next and doc . Btw. it also possible to implement next as skipTo doc 1 . A bit of history The early versions of Lucene did not have skipTo on term doc enumerators. At some point 1.2 Doug added this and used it in ConjunctionScorer which proved to be a great speedup for a BooleanQuery that requires all terms. For a smooth transition of adding skipTo on the remaining scorers it might be worthwhile to add the code mentioned in the javadocs of Scorer as the default implementation of skipTo. This needs to be investigated so I m making bug 33019 dependent on this one. Thanks for bringing this up Regards Paul Elschot Thanks for the reference Paul looks like some pretty cool stuff With term doc enumerator implementing skipTo all scorers can implement skipTo efficiently. Well maybe all scorers currently in Lucene that is. The Scorer hierarchy looks like it means to be open users can implement their own . Requiring all scorers to implement skipTo is a pretty high hurdle esp when there is a backup execution plan already implemented that works without it. During development of a new scorer one can temporarily use the code shown in the javadocs of Scorer that implements skipTo with next and doc . I m not sure I can do that. What I m trying to do is develop a replacement for RangeQuery that is fast and always works no expanding to BooleanQuery . I don t even care about scoring since it almost never makes sense for a RangeQuery. Using the same techniques as RangeFilter I think it should be pretty easy to do except for implementing skipTo. It seems like skipTo for UnscoredRangeQuery would require either enumerating all docs beforehand store in a BitSet or whatever or keeping a termdoc enumerator open for every term in the range. Neither option seems attractive. -Yonik In reply to comment 2 ... During development of a new scorer one can temporarily use the code shown in the javadocs of Scorer that implements skipTo with next and doc . I m not sure I can do that. What I m trying to do is develop a replacement for RangeQuery that is fast and always works no expanding to BooleanQuery . I don t even care about scoring since it almost never makes sense for a RangeQuery. Using the same techniques as RangeFilter I think it should be pretty easy to do except for implementing skipTo. A scorer that is only used in isolation or on the top level will only have next called. For these it is safe to throw an UnsupportedOperationException from skipTo . For an OR like query one could use the same technique as RangeFilter by using the scorers of the clauses separately. You might call this a DisjunctionFilter. Each of the separate scorers could implement skipTo but it wouldn t normally be used. Using skipTo would be only useful for very dense results to skip to the doc corresponding to the next unset bit in the BitSet. However such dense results are not normal for text searching. Once a BitSet filter is available bug 32965 can also be useful. This uses skipTo on the scorer of the filtered query to skip over documents not present in the filter. It seems like skipTo for UnscoredRangeQuery would require either enumerating all docs beforehand store in a BitSet or whatever or keeping a termdoc enumerator open for every term in the range. Neither option seems attractive. skipTo requires that the documents are accessed in order. That means some form of sorting is needed for example a PriorityQueue with all termdoc enumerators open or a BitSet for distribution sort. BooleanScorer with skipTo allowed uses a form of distribution sort the buckets combined with local sorting. Other methods are also possible eg. merge sort but these are currently not used in Lucene scorers. BooleanScorer without skipTo uses distribution and an incomplete form of sorting by working over intervals of document numbers. I don t think scoring disjunctions can be made faster than that. Since the sorting is not complete the next method does not guarantee that documents are accessed in order. BooleanScorers without skipTo using the same interval can be nested nicely though. Regards Paul Elschot Paul thanks for the reference to 32965... more very interesting stuff. I m new at this scorer stuff - trying to wrap my mind around it all... My motivation for a RangeQuery is not making it faster for the average case it s making it possible in any scenario any place in a query any number of terms etc . We have some search collections with over 100M documents. Now imagine a range query on a unique id field... I don t think any method utilizing 100M termdoc enumerators is really feasible am I understanding correctly As for speed I guess I could have my planned UnscoredRangeQuery.rewrite return a BooleanQuery if the number of terms are small enough otherwise use another method such as a simple scorer that doesn t implement skipTo . -Yonik In reply to comment 4 .. My motivation for a RangeQuery is not making it faster for the average case it s making it possible in any scenario any place in a query any number of terms etc . We have some search collections with over 100M documents. Now imagine a range query on a unique id field... I don t think any method utilizing 100M termdoc enumerators is really feasible am I understanding correctly This is very similar to a date range. Try searching for this on the web yyyy yyyymm yyyymmdd lucene The results are getting dense in this way and for performance you might consider caching intermediate results in BitSet filters. Lucene itself is meant for smaller numbers of results. 100M docs means about 12Mbyte per BitSet filter. When your filters contain fewer docs than 12M and you need many filters you might consider the sparse filters of bug 32921 . However these filters require skipTo on all their filtered scorers meaning that they require the development version of BooleanQuery at the moment. Regards Paul Elschot P.S. Perhaps someone is interested in writing a story about Lucene and the ordered document skippers. It s getting a bit involved. I think all scorers in the trunk implement skipTo now so this can be closed. Regards Paul Elschot
