Failed CONNECT leaves connection in an inconsistent state
Opening a HTTPS Connection over an authenticating Proxy Basic auth. scheme fails if proxy credentials are not provided at the first try. The following example code will fail HttpClient client new HttpClient new MultiThreadedHttpConnectionManager URL url new URL https examplehttpsurl    first try GetMethod get new GetMethod url.toExternalForm HostConfiguration hc new HostConfiguration hc.setHost url.getHost 443 https hc.setProxy proxyhost 4711 try   client.executeMethod hc get catch Exception e   LOG.error e finally   get.releaseConnection returns 407 expected LOG.debug Answer get.getStatusLine .toString retry with credentials normally requested from the user client.getState .setProxyCredentials new AuthScope proxyhost 4711       new NTCredentials USER PASS get new GetMethod url.toExternalForm try   client.executeMethod hc get catch Exception e   e.printStackTrace finally   get.releaseConnection should be 200 but is 407 LOG.debug Answer get.getStatusLine .toString From what I see from HttpMethodDirector.executeWithRetry final HttpMethod method the cause is that the connection is kept open and thus the connect is never retried if this.conn.isOpen    this connection must be opened before it can be used    This has nothing to do with opening a secure tunnel   this.conn.open   if this.conn.isProxied this.conn.isSecure        method instanceof ConnectMethod      we need to create a secure tunnel before we can execute the real method     if executeConnect        abort the connect method failed       return         If I add a conn.close before returning on executeConnect the above code will work the CONNECT is reattempted.Created an attachment id 17812 Wire log of the execution of the sample code This is the wire log of the execution of the example code. Hostnames are anonymized.If CONNECT method fails due to an authentication failure for instance and the proxy requests the connection to be kept alive the connection is returned back to the connection manager in an inconsistent state the connection is kept open but the tunnel has not been established . This causes the subsequent methods that reuse this connection generate invalid HTTP requests OlegOleg Do you consider this a violation of the proxy protocol I doubt that Squid is so bad at it. Or do we have a chance to catch this situation and close the connection anyway ignoring the keep-alive header . We can always close a connection without violating the HTTP specs. In reply to comment 3 Oleg Do you consider this a violation of the proxy protocol I doubt that Squid is so bad at it. No I do not. This is clearly a problem on the HttpClient side  Or do we have a chance to catch this situation and close the connection anyway ignoring the keep-alive header . We can always close a connection without violating the HTTP specs. This is correct. HTTP connection may be closed at any point of time without any prior notice. Connection headers are purely informational. They imply no mandatory action. It should be technically possible to recover from this situation without dropping the connection but I would rather choose to incur a slight performance hit by reopening the connection if the recovery logic proves too complicated. Otherwise it is a one line fix Oleg Created an attachment id 17821 Patch take 1 This should take care of the problem. Please review Oleg In reply to comment 5 Created an attachment id 17821 edit Patch take 1 This should take care of the problem. Please review Oleg Did work for me.I m not familiar with all the details of the code but this change looks OK to me. cheers   RolandLooks fine to me. We should probably add a test case if possible so this one doesn t pop up again. MikeYeah test case is dearly needed. It s a reoccuring issue that one of those combinations of proxy SSL auth scheme proxy auth scheme server breaks. I am not very good at combinatorics but there seem to be about 32 possibilities to combine those. It s very hard to achieve full test coverage of the possible state space. I was thinking of refactoring the test suite so it can be run with any combination of the above. But I guess that s something for another summer-of-code... In reply to comment 9 Yeah test case is dearly needed. It s a reoccuring issue that one of those combinations of proxy SSL auth scheme proxy auth scheme server breaks. I am not very good at combinatorics but there seem to be about 32 possibilities to combine those. It s very hard to achieve full test coverage of the possible state space. I was thinking of refactoring the test suite so it can be run with any combination of the above. But I guess that s something for another summer-of-code... Odi I seriously doubt that refactoring of the test suite will help. It is HttpClient that is in need of refactoring. Presently SSL tunneling authentication redirects handling connection persistence aspects are all inseparably coupled in the HttpMethodDirector and cannot be adequately unit-tested. I considered writing a test case for this bug and decided to not ivest time into that as I do not see a good way to test the bug independently from the underlying connection manager the connection manager would have to return THE SAME connection for the test case to be meaningful . Essentially the test case would test the assumptions of the inner working of the connection manager rather than SSL tunneling code OlegPatch checked in Oleg
