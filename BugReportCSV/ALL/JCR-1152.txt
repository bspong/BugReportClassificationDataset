SPI implementations currently need to provide implementations of both ValueFactory and QValueFactory
This should be simplified so that an implementation of QValueFactory is sufficient. hi julian from my understanding the SPI impl must only provide a QValueFactory. maybe i don t get your point... angela There s   RepositoryConfig.getValueFactory and it s used within JCR2SPI.... ah... so the subject is wrong. should be jcr2spi right I don t think so. Obviously as a JCR implementation JCR2SPI needs to provide a ValueFactory to the JCR client. However right now an SPI implementation needs to provide implementations of both jcr.ValueFactory and spi.QValueFactory. Optimally only the latter would be needed and JCR2SPI would provide a ValueFactory implementation wrapping just the spi QValueFactory. Now clearer Plan - remove getValueFactory from RepositoryConfig - let JCR2SPI implement it s own ValueFactory wrapping the QValueFactory implemented by the SPI impl - use Value instances that wrap QValues - push most functionality down from Value to QValue NOTE this means that QValue implementations now have to deal with value conversions while before this was done by the ValueFactory that was used. from my understanding this would also mean - QValue or its factory is in charge of defining the required format of a Reference values    i.e. this is delegated to the SPI implementation. consequently we can probably get rid if the second valuefactory i moved to jcr-commons can t we - I would be possible to have SPI implementation that uses a separate data store for   binaries and have the entries created immediately upon creation of a JCR Value. at   least theoretically...    - QValue or its factory is in charge of defining the required format of a Reference values i.e. this is delegated to the SPI implementation. Correct. consequently we can probably get rid if the second valuefactory i moved to jcr-commons can t we We won t need the ValueFactory and the ValueImpls anymore. Maybe we can also get rid of some utility classes for conversion. - I would be possible to have SPI implementation that uses a separate data store for binaries and have the entries created immediately upon creation of a JCR Value. at least theoretically... Correct. Revision 589720 parametrize RepositoryConfig.getValueFactory this is an intermediate step towards resolving the issue completely . Next step the plan is to update jcr-spi-commons with - an implementation of Value JCR that just wraps a QValue SPI instance and - an implementation of ValueFactory JCR that just wraps QValueFactory SPI and NamePathResolver SPI commons instances. Note that this means that all the logic for converting between property types and comparing values will be pushed down into the QValue instance. The Value implementation will only be responsible for the JCR-specific stream handling. Fixed with revision 590140. and removed the extra ValueFactory implementation that is now obsolete from jcr-commons with rev. 592698
