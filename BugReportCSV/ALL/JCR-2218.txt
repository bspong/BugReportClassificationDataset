NodeEntryImpl.getWorkspaceId very inefficient
NodeEntryImpl.getWorkspaceId calculates its path on each call by calling itself recursively. Further each call to getWorkspaceId results in various calls to the path and item factories which might be somewhat expensive by themselves. In my test scenario I have a RepositoryService.getItemInfos call returning 1000 items. Processing these items results in about 2700000 calls to getWorkspaceId . Profiler data shows that 98 of the time to process the 1000 items is spent in getWorkspaceId and related calls.To fix this I propose to cache the NodeId and or path per NodeEntry. On certain operations like move further operation to be identified the cache needs to be invalidated. To avoid having to invalidate the cache of each entry in the sub tree rooted at a specific item I propose that cache validity checks are deferred as much as possible i.e. until getWorkspaceId is called . The cache for an entry is valid if neither of its parents nor itself are marked as invalid . If the cache for an entry is determined to be invalid its path is recalculated thereby clearing any invalid cache marker on the path to the root. Note that when a marker of an entry is cleared all child entries of that entry need to be marked with the exception of the child entry which path is being recalculated .I just checked the effect of an alternative approach call site caching of IdFactory calls. public NodeId getId throws InvalidItemStateException RepositoryException     IdFactory idFactory getIdFactory     PathFactory pathFactory getPathFactory     IdCache idCache getIdCache     if uniqueID null         NodeId nodeId idCache.get uniqueID         if nodeId null             nodeId idFactory.createNodeId uniqueID             idCache.put uniqueID nodeId                  return nodeId          else if parent null root         NodeId nodeId idCache.get ROOT         if nodeId null             nodeId idFactory.createNodeId String null pathFactory.getRootPath             idCache.put ROOT nodeId                  return nodeId          else         NodeId parentId parent.getId         Name name getName         int index getIndex         NodeId nodeId idCache.get parentId name index         if nodeId null             Path path pathFactory.create name index             nodeId idFactory.createNodeId parentId path             idCache.put parentId name index nodeId                  return nodeId      My profiling shows that there is nothing much to be gained from this. This is in line with an earlier observation that looking up ItemIds from a hash map comes with about the same cost as creating new itemIds. The main contribution coming from the equals and hashCode methods from the various classes involved when comparing ItemIds. Another alternative approach due to Angela Instead of constructing the ids from the parent id and the name which is quite expensive traverse up to either root or a uuid and collect the respective path elements. The use the root or the uuid respectively and the collected path elements to construct the id.Proposed patch implementing the approach from my last comment. While this shouldn t have any negative performance impact on flat hierarchies it shows an overall performance gain up to 20 on deep hierarchies. Session.getItem on a deep hierarchy.Applied path in revision 803164
