Deadlock during checkin
Under a load of 3 threads performing checkin and restore operations it s possible for all to become deadlocked in AbstractVersionManager.checkin . This method attempts to upgrade a read lock to a write lock with the following code     aquireReadLock     ....     try         aquireWriteLock         releaseReadLock         ... If 2 or more threads acquire the read lock then neither can acquire the write lock resulting in the deadlock and after that any other thread that calls this method will block waiting for the write lock. The release of the read lock needs to be done before acquiring the write lock this is documented Concurrent library javadoc. There is another area where there is an attempt to upgrade a read lock to write lock RepositoryImpl.WorkspaceInfo.disposeIfIdle acquires a read lock and calls dispose which then acquires a write lock this maybe ok as I assume there is only 1 thread that will attempt to dispose of idle workspaces. Attached a proposed patch for fixing this and the related JCR-632. The problem with just switching the order of the read and write lock operations is that then the underlying state that was read during the first half of the checkin state may already have been modified when the second half persists the modifications. The proposed resolution simply extends the write lock to guard the entire checkin operation. This introduces a minor performance loss for concurrent reads but avoids the deadlock. The patch also introduces a WriteOperation helper class to simplify the following repeating code pattern     aquireWriteLock     try         stateMgr.edit      catch IllegalStateException e         releaseWriteLock          boolean success false     try         ...         stateMgr.save         success true         ...      catch ...         ...      finally         if success             stateMgr.cancel                  releaseWriteLock      into this     WriteOperation operation startWriteOperation     try         ...         operation.save         ...      catch ...         ...      finally         operation.close      The idea is to separate the locking and state manager handling from the general versioning logic. I also fixed spelling from aquire to acquire and guarded even some trivial locked operations with try-finally to more gracefully handle unexpected conditions like NPEs. thanks jukka...i will take a look at this asap.Did you already have time to look at this It seems correct to me passes all unit tests and worked fine with an ad-hoc test run with a number of concurrent threads doing repeated checkin checkout operations. If you re fine with the suggested changes I d like to have them included already in the 1.1.1 release. It s no problem to postpone the fix to 1.2 if you prefer to have more time to consider and or test the change.no i haven t closely. if it passes the tests you can check it in. i will test it after my vacation. i just wanted to make sure it also works with concurrent transactions.Applied the proposed changes in a sequence of commits to make selective reverting easier if a problem is detected. The commits are     revision 478634 s aquire acquire     revision 478641 Consistently use the try-finally pattern for acquiring locks     revision 478644 Introduced the WriteOperation helper class to hide the handling of the StateManager and the write lock.     revision 478645 Guard the entire checkin method with the write lock Only the last change should introduce functional changes extended use of the write lock the other changes are pure refactorings to clarify the code structure. I ll leave these changes in the trunk for now and not include them in the 1.1.1 release since I m not 100 certain that I haven t missed some subtle concurrency issues.
