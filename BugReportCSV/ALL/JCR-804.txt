Avoid using MultiTermDocs
Similar to MatchAllQuery also RangeQuery and WildcardQuery will result in use of MultiTermDocs. Those queries should also use the MultiScorer. See also issue JCR-791.Fixed in revision 520841Marcel Your solution breaks JDK 1.4 compatibility jackrabbit-core now requires JDK 5.0 to compile No enclosing instance of type RangeQuery is accessible. Must qualify the allocation with an enclosing instance of type RangeQuery e.g. x.new A where x is an instance of RangeQuery . jackrabbit-core src main java org apache jackrabbit core query lucene RangeQuery.java line 189 No enclosing instance of type WildcardQuery is accessible. Must qualify the allocation with an enclosing instance of type WildcardQuery e.g. x.new A where x is an instance of WildcardQuery . jackrabbit-core src main java org apache jackrabbit core query lucene WildcardQuery.java line 163  Hi Ate What kind of java compiler are you using My Sun javac 1.4.2 12 does not show this error. I think the relevant section in the JLS is the following http java.sun.com docs books jls second edition html expressions.doc.html 253028 In our case C is an inner member class. Furthermore we are using an unqualified class instance creation expression and then it s the second sub case Otherwise if C is a member of an enclosing class then let O be the innermost lexically enclosing class of which C is a member and let n be an integer such that O is the nth lexically enclosing class of the class in which the class instance creation expression appears. The immediately enclosing instance of i is the nth lexically enclosing instance of this. If C is the RangeQueryScorer class then O is the RangeQuery class. The enclosing classes of the class in which the class instance creating expression appears are 0th anonymous ScorerFactory class 1st RangeQueryWeight 2nd RangeQuery Therefore n is 2 because O is the RangeQuery class and the immediately enclosing instance of i i is the instance being created is RangeQuery.this. According to the JLS a qualified class instance creation expression is not necessary here. Thus both should work return new RangeQueryScorer searcher.getSimilarity reader as well as return RangeQuery.this.new RangeQueryScorer searcher.getSimilarity reader The problem appears when the Eclipse compiler at least in Eclipse 3.2 is set to Java 1.4 compliance mode. It seems to interpret the JLS more strictly than the Sun javac the relevant section being 8.8.5.1 Explicit Constructor Invocations which says     If an anonymous class instance creation expression appears within an explicit     constructor invocation statement then the anonymous class may not refer to any     of the enclosing instances of the class whose constructor is being invoked. I already worked around this issue in JCR-835 by replacing the ScorerFactory interface with an abstract createScorer factory method.Hi Marcel I just want to confirm Jukka s comment that is what I encountered with Eclipse 3.2. Building using JDK1.4 does work but Eclipse gives the above compile errors. Sorry for my incorrect initial statement about this but it would be nice if the compile error in Eclipse could be worked around.
