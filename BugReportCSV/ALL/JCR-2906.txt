Multivalued property sorted by last random value
Sorting on multivalued property may produce incorrect result because sorting is performed only by last value of multivalued property. Steps to reproduce 1. Create multivalued field in repository. Example from nodetypes file propertyDefinition name MyProperty requiredType String autoCreated false mandatory false    onParentVersion COPY protected false multiple false 2. Create few records so that all records except one would contain single value for MyProperty and one record would contain first value which is greater then of any other record and the second value is somewhere in the middle. Here is an example 1st record aaaa 2nd record cccc 3rd record dddd bbbb 3. Run some query which sorts Example of XPath query ...here are some criteria... order by MyProperty ascending The query would return documents in such order aaaa dddd bbbb cccc which is not expected order expected same order as they were entered - as aaaa cccc cccc dddd After some digging I found out that it happens because method org.apache.jackrabbit.core.query.lucene.SharedFieldCache.getValueIndex called from org.apache.jackrabbit.core.query.lucene.SharedFieldSortComparator.SimpleScoreDocComparator constructor returns only last Comparable of the document. Here is overwrites previous value retArray termDocs.doc getValue value type I tried to concatenate comparables just to check if it would work for my case if retArray termDocs.doc null retArray termDocs.doc getValue value type else retArray termDocs.doc retArray termDocs.doc getValue value type But it didn t worked well either - TermEnum returns terms not in the same order as JackRabbit returns values of multivalued field as an example qwer asdf may become asdf qwer . So simple concatenation doesn t help. which is not expected order expected same order as they were entered ... But when you specify order by MyProperty ascending you explicitly want to order by the property not the document order. AFAICS the JCR 1.0 and 2.0 spec don t define any behavior for comparing single-value properties to multi-value ones or mv to mv so I think the repository implementation is free to chose the most efficient one. Hence this is not a bug. Also it is not clear how to define an ordering upon multi-value properties at all Compare against the concatenation of the string representations of all the values in the property Or compare against the first value I think lexicographical order would be the natural approach. Like this 1 aaa ddd comes before ccc bbb because aaa ccc 2 ccc ddd comes after ccc bbb because ccc ccc and ddd bbb . Really good analysis thanks for pointing out where the problem is The problem is not that the JCR spec may or may not define sorting on a multi-valued property. the problem is the sort behavior is not stable when dealing with MVPs. Like Paul correctly pointed out whenever there is a MVP present the value in the cache gets overwritten by the last value found by the lucene Term query. So in fact an MVP is represented in the sort by just one of its values which can apparently change at runtime - that is easily reproducible by running the attached test a few times . The solution is to use the position info that comes via lucene s TermPositions. This does contain the term s position within the current document allowing us to use it as an index for MVPs. The downside is that the Comparables have to support arrays as well as simple values so I ve added a class ComparableArray that simply delegates compareTo calls to the inner array of Comparables. This way all the sql languages xpath sql sql2 have similar sort for MVPs. Attaching patch. Alex your patch contains a lot of simplifications and reformating in test cases. Could you please create a separate patch for that This would make it easier to review the proposed changes for exactly this issue.yes sorry for the noise. you are totally right I ve re-submitted the patch with only the relevant changes . From looking at the code this makes sense and seems ok. However I get a test failure when I run this for UserManagerSearchTest testSoertOrder1. AFAICS this is due to a bad interaction with the new array comperator and the uppercase respectively lowercase comperators. However I also observe that I get comperator arrays of different lengths for the same property of different nodes. In the test case mentioned I get for some nodes null null null null WHITE and for others null null null WHITE .Ok there seems to be a problem with termPosition. In the above test case termPosition is sometimes 3 and sometimes 4 for the same value of the property i.e. WHITE . This results in the arrays with trailing null values. So this has nothing to do with the upper lower case comperators. It just seems to manifest itself there but the problem is more profound. ouch good catch the position is from the current doc but it takes into account other properties as well. I missed that completely. So if a node has a property p1 and a property text the text s position can be 1 0-based as well. I was under the poor impression that running a term search on text would convey just term specific info not document specific positioning info . The fix would be to just add a shrink method after building the array to remove the null values from the beginning of the array. When dealing with MVP I m pretty sure they are a contiguous interval within the index even if with a tiny offset. attaching just the SharedFieldCache class with the shrink method the UserManagerSearchTest test now passes.Ok works now all core tests pass. Do we know about the impact on query performance All this array creation and compacting. It seems to me this might happen quite a lot for nodes with a lot of indexed properties.I d also suggest to be careful about potential impact on performance. IMO we shoulnd t sacrifice performance for a use case which isn t properly described in the specification.Attaching v3 of the patch. I ve taken into consideration the point about performance creating and compacting the arrays and I ve come up with a better offset-based version It is optimized for the standard case when there is only one term to create a single-element array save the term s position in the index as opposed to creating an array of considerable size. So no more shrink method. Next based on the following terms index it uses an internal offset to optimize the creation of the array of terms. This should have a considerably smaller impact on perf. Thanks for the feedback so far. I think there is an off by one problem in the cases denoted by inside and after Shouldn t the comparisons be and respectively you are right. the sneaky offset tricked me. turns out that wasn t the only problem...I ve also added a new test checking the array insert stuff. attaching v4 concerning the memory consumption so you think this is a viable low-impact solution for MVP sort Looks better but - ... in the after case I think the calculation of the new array size is incorrect. The tests work but that s just bad luck. Instead of     int extraOffset index - offset c.length -1     c Arrays.copyOf c c.length extraOffset shouldn t that be     int newSize index - offset 1     c Arrays.copyOf c newSize yes as usual you are right your solution is a lot clearer and above all correct The tests work but that s just bad luck. Yeah the MVP2 test was supposed to shed some light on how the sort works but it s not a proper unit test for the ComparableArray. note to self being lazy does not pay off I m attaching v5 with a dedicated unit test for the ComparableArray.Looks good now and all tests pass.fantastic I ll apply the patch shortly.Fixed in rev 1209063 and rev 1209111This depends on refactoring done for JCR-3151
