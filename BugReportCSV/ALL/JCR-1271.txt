NullPointerException when iterating over properties
Running ConcurrentReadWriteTest NUM NODES 5 NUM THREADS 3 RUN NUM SECONDS 120 resulted in a NullPointerException Exception in thread Thread-11 java.lang.NullPointerException at org.apache.commons.collections.map.AbstractReferenceMap ReferenceEntry.getValue AbstractReferenceMap.java 596 at org.apache.commons.collections.map.AbstractReferenceMap.containsKey AbstractReferenceMap.java 204 at org.apache.jackrabbit.core.state.ItemStateMap.contains ItemStateMap.java 66 at org.apache.jackrabbit.core.state.ItemStateReferenceCache.isCached ItemStateReferenceCache.java 91 at org.apache.jackrabbit.core.state.LocalItemStateManager.hasItemState LocalItemStateManager.java 173 at org.apache.jackrabbit.core.state.XAItemStateManager.hasItemState XAItemStateManager.java 252 at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState SessionItemStateManager.java 174 at org.apache.jackrabbit.core.ItemManager.createItemInstance ItemManager.java 495 at org.apache.jackrabbit.core.ItemManager.getItem ItemManager.java 326 at org.apache.jackrabbit.core.LazyItemIterator.prefetchNext LazyItemIterator.java 90 at org.apache.jackrabbit.core.LazyItemIterator.next LazyItemIterator.java 203 at org.apache.jackrabbit.core.LazyItemIterator.nextProperty LazyItemIterator.java 118 at org.apache.jackrabbit.core.ConcurrentReadWriteTest 1 1.execute ConcurrentReadWriteTest.java 64 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 110 at java.lang.Thread.run Thread.java 619 The cache is not synchronized and is accessed at the same time by the current thread and another thread that notified ItemStates about changes.Proposed fix.Revised patch. Previous version may produce a deadlock.Wouldn t be enough to replace public ItemStateReferenceMap         super new ReferenceMap ReferenceMap.HARD ReferenceMap.WEAK with public ItemStateReferenceMap         super Collections.synchronizedMap new ReferenceMap ReferenceMap.HARD ReferenceMap.WEAK and only make those parts synchronized on the map where we iterate over some collection of the map I must be missing something - http java.sun.com j2se 1.4.2 docs api java util Collections.html synchronizedMap java.util.Map This will turn ItemStateReferenceMap into a synchonized map which is not necessary for other usages. Furthermore there is also the ItemStateReferenceCache.cache which might not be thread-safe as well.Okay. Do you know experience if you changes regarding synchronized make things slower or is this hardly noticeable Well as with any synchronization it will slow down execution. But if I can to choose between a correct program and a slightly faster one that is incorrect I will go for the first one... - True but if it is like a big difference other options might be worth looking at. But I agree incorrect is worse....obviously - AFAICS the difference is minimal. Running times for tests only differ slightly.Could we not fix the problem at its source instead of in a synchronization wrapper I d just synchronize the methods in ItemStateReferenceCache.That would be an alternative but as mentioned before there are use cases where synchronization is not needed. The cache in SharedItemStateManager does not need additional synchronization when DefaultISMLocking is used. We have three potential usages of ItemStateReferenceCache 1 LocalItemStateManager cache 2 SharedItemStateManager cache with DefaultISMLocking 3 SharedItemStateManager cache with FineGrainedLocking 1 and 3 require a thread-safe ItemStateCache implementation. 2 does not have to be thread-safe. I m also OK with synchronizing the ItemStateReferenceCache directly. WDOT Our codebase is already pretty complex so avoiding an extra wrapper class and the complexity of is this thread-safe and does it need to be is IMHO well worth the minor overhead of synchronization. Especially if in the long run we re even going to get rid of the only case that doesn t need to be thread-safe.This patch turns ItemStateReferenceCache into a thread-safe implementation. I also had to tweak LocalItemStateManager to avoid an deadlock in getItemState .Attached JCR-1271.jz.patch is a slight revision of your latest patch. This one replaces the size keySet and values methods in ItemStateCache with a single retrieveAll method that nicely avoids all need for external synchronization.Definitively better than mine. Committed Jukkas patch in revision 605510Merged to the 1.3 branch in revision 641272.
