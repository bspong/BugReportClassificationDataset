Problem with redirect on HEAD when bad naughty server returns body content
I ve been testing using HttpClient 2.0a3 with Resin 2.1.9. I ve found that when using a HEAD request on a JSP Resin returns the body content along with the headers. In this case something in the HttpClient breaks. Looking at the httpclient logs it looks like 1 HttpClient does a HEAD against the original URL 2 Resin returns valid status line and headers 3 HttpClient parses the headers and recognizes the redirect header 4 HttpClient does a HEAD against the new URL from the Location header 5 HttpMethodBase calls readStatusLine which eventually calles readRawLine in HttpConnection which reads from the internal inputStream 6 readRawLine returns the first line in the body from the original HEAD request in 1 . It looks like the original body content in response to the first HEAD is being buffered somewhere but I can t figure out where. I know that this is invalid behavior on the server s part but I would like to be able to recover from it. redir test.jsp xml version 1.0   response.setStatus response.SC MOVED TEMPORARILY   response.setHeader Location redirect pass.xml some    dummy      data attr yea well    dummy some Paul I have heard about this problem before but so far have been unable to reproduce it. I ll look into it one more time. OlegOleg - I think it can be reproduced using Resin 2.1.9 as the JSP container. If you would like I ll try to get a JSP together.Paul I am a bit reluctant to install Resin unless the bug can t be reproduced using other tools at my disposal. The test JSP will be highly appreciated Cheers OlegCreated an attachment id 6192 Patch take 1 I guess that should fix the problem. OlegOleg I do not think this will fix the problem. I have no way of testing this so I may be completely wrong though It does not seem that the response invalid though it may be is ever being read. I would suggest adding the following instead of responseBodyConsumed         if getResponseBodyAsStream null             getResponseBodyAsStream .close          MikeMike You are right. The patch does not fix the problem. On top of that the solution you proposed seems to be causing some side-effects as well. It looks like the fix will require a bit more work than I initially thought. I am going to target the resolution of this bug for beta-2 as this bug is no show-stopper for the pending beta-1 release. OlegPart of the difficulty with the HEAD response is that it is supposed to indicate a content length if available but not return any content. If HttpClient attempts to treat the HEAD method like any other that would mean of course that HttpClient would attempt to consume the indicated length of content even though in most cases it will never be there. Badness ensues. If you want to recover from an HTTP server that erroneously returns content on a HEAD request it might be better to improve the code that scans for the HTTP response line - for example by looking for HTTP 1.0 or HTTP 1.1 in the input stream rather than CR LF HTTP which presupposes that a response with extra data would be so kind as to terminate with a CR LF.Absolutely correct. However I believe there s another approach possible. Since we already have a PushbackInputStream wrapper around our socket input stream anyway I am thinking about implementing a read ahead method which would allow me to peek into the data that is about to come without really reading it sort of . OlegDo we actually want HttpClient to look for HTTP 1.x strings in the response Can we not just use the information given by the Headers to read skip as many bytes as necessary didn t look at the code recently... Odi I am afraid chunk-encoded content unfortunately spoils this kind of scheme. OlegOleg why With chunked-TransferEncoding the end of the body is also well-defined. The only difference to Content-Length is that you have to parse the chunks and can not just skip a known number of bytes.Odi What I meant was that we couldn t just blindly skip the number of bytes given in the Content-Length header. I do agree that we should leverage the content information given in the headers. OlegAh I guess I understand the problem now. So forget about my comments. Well actually it s a little hard to try and fix this server problem on the client side... I mean if the server sends a body even though it is supposed not to then who on earth tells us that it sent this body. The real problem is we do not when this body will arrive. The body could in theory arrive a long time HTTP 1.1 keep-alive connections after the headers were sent. We can not just wait for an indefinite time after each HEAD request just because some response body might arrive unexpectedly can we As I see it we can not recover from such a protocol violation on the same connection - we just can not detect this situation well enough. We can only detect that there is not HTTP 1.x response in the body and correctly assume taht something went wrong. We can then only close the connection and retry with a fresh one.Odi it ll never work 100 . However we still wait a little while to see if there s anything coming our way to make sure that we can gracefuly recover in most of the cases. OlegCreated an attachment id 6212 Patch take 2 Another attempt at fixing the problem. Minor ChunkedInputStream class clean-ups that are related to the fix. Feedback welcome. OlegMaybe we should check for strict mode here and throw an exception in strict mode.That of course can be done. OlegCreated an attachment id 6226 Patch take 3 Odi s suggestion has been implemented. Any additional comments objections OlegI still think we re chasing the wrong problem here and the patch makes me uncomfortable on several fronts. I don t think that a GET or POST response with too much data should be treated any differently than a HEAD response with too much data. The scan for HTTP 1.1 exists for precisely that reason. I have not personally tried the scenario that the original poster indicated but it seems no different in principle than a server that tacks an extra CRLF pair at the end of a GET response - when we read the next response we have to scan for the HTTP 1.1 line start. The current code might be a problem though if the previous response has extra data but doesn t end with a CRLF. I think THAT is the problem we should be solving. I looked through the patch and as best I can tell it changes the default behavior of the HeadMethod to wait for 100ms for invalid content. That seems like a bad default at a minimum. My application uses HEAD in a number of places and having to revisit all my code where HEAD is invoked just to solve a problem I never encounter seems weird to me. And if I miss a case I get an inexplicably performance penalty. Ugh. Maybe I read the code wrong though. testNoncompliantHeadStrickMode - strict is misspelled. I like the test cases you provided It is certainly a clever way to reproduce the problem.Eric I see your point. However this is where we differ quite radically it is one story to skip a few blank lines mistakenly appended to the response body and it is an entirely different story to scan an arbitrary sequence of characters for a rather common pattern such as HTTP. I personally find it fairly pointless due to the high probability of erroneous results. Even if we attempt to be a bit more creating about pattern matching mistakes are still quite likely. It s just not worth the trouble imho since we can t make it work 100 On the other hand my intention was to address only a very specific problem where we can have significantly more certainty about being able to gracefully recover from most of non-compliant responses. I do admit that the price in terms of performance degradation is high. Therefore I provided an option to disable the check. Maybe the check should be off by default as the overwhelming majority of HTTP servers are spec compliant in this particular regard I apologize for spelling mistakes OlegWell I definitely think the wait should be avoided by default otherwise you ve defeated most of the client value of the HEAD method as a less expensive alternative to GET. Since the original poster knows that he is going against a non-compliant server is it more appropriate to simply work around it there Perhaps not or they wouldn t have posted the bug. I m torn about the pattern matching problem. The only time looking for byte level HTTP 1.1 would generate problems is if server is genuinely misbehaving. The code we have now consumes the entire response even if the caller doesn t read it all solving many of the potential response alignment issues. Thus in most cases except this one my experience suggests we only have to worry about the occassional stray CRLF pair. These wouldn t cause a problem with my alternative. Of course the problem with this particular case is that you could easily imagine the server returning html body h1 HTTP 1.1 301 Moved permanently h1 p Ask server admin for details. p body html Which would cause the problem that I m guessing the original poster saw if there was no CRLF after the html tag. Yet if you did a byte level search for HTTP 1.1 as I suggest it would still fail as my approach would find the first occurrance and try to read the header prematurely. In the absence of a wire log and thinking about the potentially diabolically misbehaved servers I concede that your approach might be better. Your change to HttpMethodBase puzzled me for a while as I was worried that it might change the performance. Now that I look at it again it makes more sense and it might prevent an exception for badly behaved servers. Might this be a behavior change that should be aware of strict mode though Except wait - I just did a search for isStrictMode uses and I didn t find any except in your new patch. Did this sneak in while I wasn t watching Sorry about the rambling but I ve been puzzling through this one and you seem to be quite a bit ahead of my thinking. Eric The status line does not have to be preceded by a CRLF at all. The only thing that defines the end of the response body is the Content-Length Header or the ending chunk if Chunked Transfer Ecoding is used. The HTTP response body is to be treated as a binary entity and should not be parsed for CRLF by HTTP servers nor clients.Eric Both approaches in question have their advantages and disadvantages. None of them is a panacea and is guaranteed to be able to recover gracefully in all possible scenarios. This of course is subjective but I just do not like the idea of scanning through the response body that may contain any arbitrary sequence of bytes. The use of header information is by no means a more effective method that the one you suggest but it does appear a more proper more compliant approach at least to me . If a particular server sends just an arbitrary stream of garbage that has no correlation with information in the header I do not think we should go at extraordinary lengths to recover from this kind of HTTP spec abuse. As to those modifications I made to HttpMethodBase they are intended to be mere clean-ups. They should have no performance impact of what so ever or so I d like to hope I just moved the check for improperly terminated empty chunk- encoded body from the ChunkedInputStream class to HttpMethodBase where we have more information about the execution environment and therefore are in a better position to take appropriate corrective measures. I agree this check may be inappropriate when executing in the strict mode. Unfortunately the RFC is a bit vague on whether an empty chunk-encoded response body must have a closing chunk or may be omitted altogether. There are conflicting opinions. For instance the company that produces the IIS web server seems to subscribe to the latter point of view. Oleg Created an attachment id 6237 Patch take 4 Let me recall the two main user groups of HttpClient 1. People who want to transfer data They just want it to work flawlessly with the most common servers Apache httpd Tomcat IIS Squid most popular app servers and proxies . They will most reasonably run HttpClient in non-strict mode. 2. People who want to test servers for standards compliance. They will most reasonably run HttpClient in strict mode. We are not supposed to make a client that works with everything out there that calls itself a Http server. For group 1 it s enough if it works for the big servers that are usually regarded as standards compliant. For group 2 it s enough if HttpClient notifies them exceptions logs misbehaviour that their implementation is not good. Note that for group 2 we do not have to be very explicit or verbose about what went wrong. It s sufficient that they can actually notice an error. So in my humble opinion we should refrain from building ugly work-arounds for gross violations of the Http standard.Created an attachment id 6256 Patch take 5 Some minor tweaks regarding HTTP spec compliance in the strict mode. Summary of changes - Minor ChunkedInputStream class clean-ups. - HttpExcption is thrown in the strict mode when chunk-encoded body has been declared with Transfer-Encoding header but not sent. - Per default HttpClient does not check for presence of HTTP HEAD response body. Such check can be optionally activated on an individual HEAD method when necessary. In the strict mode presence of a content body in response to HTTP HEAD request will cause an HttpException to be thrown. OlegIn general it looks good to me. Just a few comments.  - I haven t tried this but I wonder if the isResponseAvailable calls will cause problems with HTTPS in pre 1.4 JVMs ala the isStale problem.  - There seems to be tab characters in HeadMethod. I am guessing the bodyCheckTimeout accessor methods were autogenerated with tabs by Eclipse. MikeMike I was also concerned about possible side effects on HTTPS connections. I have run a few really nasty tests in order to simulate the potential problem. Everything seems quite all right at least in my usual development environment. I have tweaked RequestBodyServlet to pause for 5 seconds prior to sending out the response body to the client. I hit the server over SSL with two consecutive request a GET followed by a POST. The connection was declared stale after the GET and re-opened. POST method did pause for approximately 5 seconds before the chunk-encoded body started arriving. At least as far I can tell things look ok to me OlegPatch committed. Oleg
