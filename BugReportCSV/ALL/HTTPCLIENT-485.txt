Connection is not released back to the pool if a runtime exception is thrown in HttpMethod releaseConnection method
the default config of leaving the HttpClientParams.CONNECTION MANAGER TIMEOUT as zero means that the first time the connection manager fails to immediately get a connection you application hangs. at least using MultiThreadedHttpConnectionManager. this is because the zero gets passed onto a call to Object.wait long timeout and from the docs If timeout is zero however then real time is not taken into consideration and the thread simply waits until notified. . since nothing ever notify s the thread everything just stops... the default behaviour of the client more should be more predictable. you don t expect it to hang your entire app if it can t get a connection you expect it to timeout then throw an exception or give some other kind of feedback. it would make sense to give a default of say arbitrarily 10 seconds or so. this would save every single user of the classes having to dig around in the code documentation and explictly set this param. they might decide that the default value isn t right and hence change it but that s tweaking behaviour not correcting it. i certainly thought it was a bug in the code yours or mine not my config and have been fretting around it for a while. best garryHi Gary The default timeout of zero does seem reasonable to me. The MultiThreadedHttpConnectionManager manages a pool of connections and requests that call getConnection without a timeout wait until one is available. Threads will only block forever if the acquired connections are never returned. If HttpMethod.releaseConnection is called for all requests this will never be an issue. I m going to mark this one as invalid. Please feel free to reopen it if you can make a strong case for changing the default behavior. MikeI share Mike s oppinion. Moreover every OS on this planet will eventually shut down a connection that never ACKs a SYN. Just to save on resources. It may take quite long platform dependent though. But the socket will not hang forever. Ortwin Glück hey there. ok. i think i m getting a handle on this and maybe there is a more serious problem lurking in the code... i might be wrong but bear with me. the situation seems to be this i m repeatedly connecting to the same server using a multi threaded connection manager which however is only managing a single thread. but the server or my connection is unstable and goes down. here s the tail of the log from the session in question ... 07 30 01 18 12 DEBUG HttpMethodBase 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpMethodBase.readResponseBody HttpConnection 07 30 01 18 12 DEBUG HttpConnection 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpConnection.getResponseInputStream 07 30 01 18 12 DEBUG HttpMethodBase 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpMethodBase.canResponseHaveBody int 07 30 01 18 12 DEBUG HttpConnection 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpConnection.close 07 30 01 18 12 DEBUG HttpConnection 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpConnection.closeSockedAndStreams 07 30 01 18 12 DEBUG HttpMethodBase 5948 http humboldt.craigslist.org 80 sfo eby 3 - Resorting to protocol version default close connection policy 07 30 01 18 12 DEBUG HttpMethodBase 5948 http humboldt.craigslist.org 80 sfo eby 3 - Should NOT close connection using HTTP 1.1 07 30 01 18 12 DEBUG HttpConnection 5948 http humboldt.craigslist.org 80 sfo eby 3 - enter HttpConnection.isResponseAvailable 07 30 01 18 14 DEBUG GetMethod 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - enter GetMethod String 07 30 01 18 14 DEBUG HttpMethodBase 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - HttpMethodBase.addRequestHeader Header 07 30 01 18 14 DEBUG HttpClient 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - enter HttpClient.executeMethod HttpMethod 07 30 01 18 14 DEBUG HttpClient 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - enter HttpClient.executeMethod HostConfiguration HttpMethod HttpState 07 30 01 18 14 DEBUG MultiThreadedHttpConnectionManager 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - enter HttpConnectionManager.getConnectionWithTimeout HostConfiguration long 07 30 01 18 14 DEBUG MultiThreadedHttpConnectionManager 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - HttpConnectionManager.getConnection config HostConfiguration host http humboldt.craigslist.org timeout 0 07 30 01 18 14 DEBUG MultiThreadedHttpConnectionManager 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - enter HttpConnectionManager.ConnectionPool.getHostPool HostConfiguration 07 30 01 18 14 DEBUG MultiThreadedHttpConnectionManager 5948 http humboldt.craigslist.org 80 sfo eby mis 3 - Unable to get a connection waiting... hostConfig HostConfiguration host http humboldt.craigslist.org that s where it hung I think the key is that the connection manager is only handing one thread. your assumption is that eventually there ll be another open connection that closes and notifies the connection manager so that it stops waiting. but what if there aren t any other running threads there s nothing waiting for an ACK since our only connecting thread is stopped in Thread.wait 0 ... so what s going to pop us out of the wait Now my understanding is fuzzy especially the effect of the loss of internet connectivity on the connection manager that s running as HTTP 1.1 and not closing connections but i think there s a genuine deadlock situation with this edge condition of a MultiThreaded...ConnectionManager that s only running one thread. Maybe your answer will be simply don t use MultiThreaded...ConnectionManager if you only want to run one thread I m tempted to REOPEN this but i think i ll leave that as your call... i feel like a salmon in a barrel. cheers garry P.S. I should have added that this was consistently happening on two platforms linux and mac. It wasn t just a one off it was every time. It took varying amounts of time to happen but it always happened and the machine sat there for hours. I have a controller thread that asks for checkpoints every ten minutes and all my logs showed were about 20-30 of these checkpoint requests falling on deaf ears. If threads have ears of course. gGarry The MTCM manages one connection pool per host config. There is a limit of simultaneous connections to a certain host which by default is something like 2 as recommended by RFC-2616 . So if the MTCM has handed out the 2 connections the next call to getConnection will block until one of the connections is handed back to the connection manager. Of course this will never happen if you never call releaseConnection on the method. So it is vitally important that the releaseConnection call is in a finally clause. Please check your code for ommissions of that. Ortwin Glück In reply to comment 5 So it is vitally important that the releaseConnection call is in a finally clause. Please check your code for ommissions of that. Yes all method calls have their corresponding finally method.releaseConnection calls. I have my MTCM configured to just one connection per host since that s all i need. We re talking about code that runs fine for hours and hours but then inevitably hangs in that wait 0 method. Well maybe not inevitably but certainly whenever there s any kind of instability in the connection to the internet which in my case seems to be inevitable. Hmm but looking at the trace that last page http humboldt.craigslist.org 80 sfo eby leads you to a infinite redirect blinking - . Could that be affecting the way the connection is closed I see your point my trace shows no call to HttpConnection.releaseConnection but i can promise you that i ve got a call to it via the method in my finally block. An infinite redirect would certainly keep your only connection open forever and keep it from being returned to the pool. There is an option to limit the maximum number of redirects and to allow circular redirects. Normally circular redirects are not allowed and lead to an exception. If you did not change any parameters then a circular redirect should not happen. If you have used the finally clause correctly your connection will be returned to the pool and there is no problem. Without seeing the code I can not tell more... The two options are controlled like this HttpClient client new HttpClient mtcm client.getParams .setParameter http.protocol.max-redirects new Integer 10 client.getParams .setParameter http.protocol.allow-circular-redirects Boolean.FALSE In reply to comment 7 An infinite redirect would certainly keep your only connection open forever and keep it from being returned to the pool. There is an option to limit the maximum number of redirects and to allow circular redirects. the default config limits you to 100 redirects in total circular or not. i left it at this and the trace shows that it does indeed give up after 100 - so no infinite loop that was stopping the connection being released. and my releaseConnections ARE IN A FINALLY BLOCK just in case that comes up again. ok i have an update. the problem seems to be that the method gets into an illegal state and instead of properly releasing the connection back to the pool throws this instead java.lang.IllegalStateException Connection is not open         at org.apache.commons.httpclient.HttpConnection.assertOpen HttpConnection.java 1269         at org.apache.commons.httpclient.HttpConnection.isResponseAvailable HttpConnection.java 872         at org.apache.commons.httpclient.MultiThreadedHttpConnectionManager HttpConnectionAdapter.isResponseAvailable MultiThreadedHttpConnectionManager.java 1307         at org.apache.commons.httpclient.HttpMethodBase.responseBodyConsumed HttpMethodBase.java 2272         at org.apache.commons.httpclient.HttpMethodBase 1.responseConsumed HttpMethodBase.java 1755         at org.apache.commons.httpclient.AutoCloseInputStream.notifyWatcher AutoCloseInputStream.java 180         at org.apache.commons.httpclient.AutoCloseInputStream.close AutoCloseInputStream.java 140         at org.apache.commons.httpclient.HttpMethodBase.releaseConnection HttpMethodBase.java 1086 ... this i think as i ve said before comes about as a result of an unstable connection - no idea if that s at my end or the server end. this is the situation that gives you the hang the last method didn t close release properly and so on the next call to MTCM.getConnection just wait s forever. unfortunately i turned off the trace of the httpclient just hours before this happened ain t that always the way. hope this helps to clarify the issue. cheers garryGarry I guess you dug up a dead body. Thanks a lot In reply to comment 10 Garry I guess you dug up a dead body. i knew something smelled rotten. Thanks a lot i m assuming you re not being sarcastic - in which case a pleasure. good luck fixing it... cheers gCreated an attachment id 15900 Patch take1 Folks please review and let me know what you think. OlegOleg You have changed the contract of isResponseAvailable no exception thrown any more. Is this change necessary If yes please change the Javadocs as well. OdiCreated an attachment id 15901 Patch take2 All right. How about this OlegI like this one better.It looks pretty good. My only concern is with the potential performance penalty of adding another call to isOpen . Is there any way to do this without testing if the connection is open MikeIt s possible to catch the IllegalStateException instead. That would certainly be faster boolean avail try   avail responseConnection.isResponseAvailable catch IllegalStateException e   avail false if avail ... In reply to comment 17 It s possible to catch the IllegalStateException instead. That would certainly be faster I seriuosly doubt that a boolean variable test would be slower than setting up a try catch finally frame. Symantically at least IMO IllegalStateException should represent a fatal exception one should not attempt to recover from. I would rather not throw it all see my original patch Oleg boolean avail try avail responseConnection.isResponseAvailable catch IllegalStateException e avail false if avail ... Oleg right I did not see isOpen was just a simple wrapped boolean check. I do not like the semantics of that exception either. Is it feasible to change the contract that late in the release process I mean personally I d say fix it rather earlier than later and go with patch 1. But I don t know about our users... Maybe ask on the list I just read this thread with interest as a simple junit test on my end reproduced this quite easily although without all the waiting around - by using a proxy server instead. Here is code that will reproduce this for me every time. HttpClient httpClient new HttpClient new MultiThreadedHttpConnectionManager final HttpConnectionManagerParams params     httpClient.getHttpConnectionManager .getParams params.setMaxTotalConnections 20 params.setDefaultMaxConnectionsPerHost 20 httpClient.getParams .setCookiePolicy CookiePolicy.IGNORE COOKIES this next line helps trigger IllegalStateException without a proxy we get an UnknownHostException instead the proxy server is running normally httpClient.getHostConfiguration .setProxy 127.0.0.1 8222 use a non-reachale url final PostMethod post new PostMethod http foo bar baz final NameValuePair data new NameValuePair name value post.setRequestBody data try      next line throws non-doc d IllegalStateException     httpClient.executeMethod post      print response to stdout     System.out.println post.getResponseBodyAsStream finally     post.releaseConnection Trace this creates from the call to executeMethod java.lang.IllegalStateException Connection is not open         at org.apache.commons.httpclient.HttpConnection.assertOpen HttpConnection.java 1269         at org.apache.commons.httpclient.HttpConnection.write HttpConnection.java 968         at org.apache.commons.httpclient.HttpConnection.write HttpConnection.java 937         at org.apache.commons.httpclient.HttpConnection.print HttpConnection.java 1027         at org.apache.commons.httpclient.MultiThreadedHttpConnectionManager HttpConnectionAdapter.print MultiThreadedHttpConnectionManager.java 1622         at org.apache.commons.httpclient.HttpMethodBase.writeRequestHeaders HttpMethodBase.java 2046         at org.apache.commons.httpclient.HttpMethodBase.writeRequest HttpMethodBase.java 1919         at org.apache.commons.httpclient.HttpMethodBase.execute HttpMethodBase.java 993         at org.apache.commons.httpclient.HttpMethodDirector.executeWithRetry HttpMethodDirector.java 393         at org.apache.commons.httpclient.HttpMethodDirector.executeMethod HttpMethodDirector.java 168         at org.apache.commons.httpclient.HttpClient.executeMethod HttpClient.java 396         at org.apache.commons.httpclient.HttpClient.executeMethod HttpClient.java 324 In reply to comment 19 Oleg right I did not see isOpen was just a simple wrapped boolean check. I do not like the semantics of that exception either. Is it feasible to change the contract that late in the release process I mean personally I d say fix it rather earlier than later and go with patch 1. But I don t know about our users... Maybe ask on the list Firstly HttpConnection is not meant to be used directly. Effectively it is a private class. Secondly IllegalStateException is an unchecked exception so no code should be broken if it is no longer thrown. This said one meager boolean test seems to solve the problem so I think it is a rather modest price to pay for keeping everyone content. Oleg Sorry never mind. I was confusing isOpen with isStale . My preference would be for the first patch. It does introduce a small API change but HttpConnection is essentially only used by HttpClient classes. A quick poll on the dev list would be good but my guess is that virtualy no-one uses HttpConnection directly. Mike In reply to comment 20 I just read this thread with interest as a simple junit test on my end reproduced this quite easily although without all the waiting around - by using a proxy server instead. Here is code that will reproduce this for me every time. That s pretty cool. I ll see if I reproduce the bug using our proxy mockup. Should I succeed I ll incorporate your test case into the patch OlegJust being careful Oleg. People writing their own connection mananagers might use it don t know what for... . Removing an unchecked exception is a subtle change in that no IDE will signal the change in your code when you drop in the new HttpClient jar. So if anyone is relying on the exception being thrown if the connection is closed their code will break. I am sounding really academic now I must say... Just go for patch 1 and cross fingers. .- In reply to comment 23 In reply to comment 20 I just read this thread with interest as a simple junit test on my end reproduced this quite easily although without all the waiting around - by using a proxy server instead. Here is code that will reproduce this for me every time. That s pretty cool. I ll see if I reproduce the bug using our proxy mockup. Should I succeed I ll incorporate your test case into the patch Oleg Nope. No luck with the test case. I get a org.apache.commons.httpclient.NoHttpResponseException from our proxy mockup which seems quite reasonable to me. Folks If I get it right the consensus is that we go with the patch take 1 . If I hear no complaints I ll commit the patch take 1 in a few days OlegIs it acceptable that for the same code one could expect either UnknownHostException OR NoHttpResponseException FWIW the proxy server I was using is here http www.proxomitron.info In reply to comment 26 Is it acceptable that for the same code one could expect either UnknownHostException OR NoHttpResponseException Peter What we have is a rather simple proxy server mockup which I think simply drops the connection on unsuspecting HttpClient in case of DNS name resolution failure hence NoHttpResponseException thrown by HttpClient. This is not an issue with HttpClient or the test code but rather with the mockup proxy Oleg FWIW the proxy server I was using is here http www.proxomitron.info Patch 1 committed. Oleg
