Don t use ensureOpen excessively in IndexReader and IndexWriter
A spin off from here http www.nabble.com Excessive-use-of-ensureOpen -td24127806.html. We should stop calling this method when it s not necessary for any internal Lucene code. Currently this code seems to hurt properly written apps unnecessarily. Will post a patch soon Patch includes remove all calls to ensureOpen in IndexReader and deprecated ensureOpen . remove most of the calls to ensureOpen in IndexWriter those that happen at the beginning of methods . added isOpen to both IndexReader and IndexWriter. deleted some test cases that checked this functionality. fixed tag removed test cases CHANGES All tests pass except for TestRussianStem under contrib analyzers. But that does not seem to be related to this patch as it fails on a clean trunk checkout also. I think it has to do w encoding but I don t know if I m the only one that experiences that. I d actually rather not remove the ensureOpen calls I think it s better when the user sees an AlreadyClosedException than an NPE from somewhere deeper in IndexReader but instead change it to a best effort impl ie don t use volatile . I think for nearly all the methods where we have ensureOpen today the cost once we stop checking volatile is tiny this coming from someone who is normally a freak about performance . I d actually rather not remove the ensureOpen calls I think it s better when the user sees an AlreadyClosedException than an NPE from somewhere deeper in IndexReader but instead change it to a best effort impl ie don t use volatile . I agree that it s better to see ACE than NPE. However I thought we agreed that nearly all applications do not rely on ACE. And even if we make it super fast I still don t see why for a properly written application which knows it does not access a closed reader writer we should check ensureOpen . And our merge code calls document while reading from an IndexReader which obviously cannot be close so why check there True ACE helps developers of good apps which forgot they closed the reader few lines above track the problem faster ... But then this issue becomes just changing refCount to not volatile And nothing to do on IndexWriter If that was the intention then I don t think an issue is needed and a committer can just commit this one line change However I thought we agreed that nearly all applications do not rely on ACE It s not that apps are relying on ACE it s that the unlucky user who has problems is informed much more clearly that the problem is in their code and not a bug in Lucene. It s a trap. In the past there were a good number of users posting with confusing exceptions coming out Lucene thinking they had hit a bug. These users spent time others spent time reading it answering it etc. Now I haven t seen one of those emails in quite a while. But then this issue becomes just changing refCount to not volatile I think we should leave refCount volatile but just assign false to a new write-once isOpen that s not volatile when refCount drops to false. IndexReader already has a closed member which is set to true in close . Why not use it In fact it s strange - close decreases refCount and set closed to true but if decRef is called from another reader it is a public method so maybe even from an outside app and refCount is 0 close will call decRef again and fail on assert refCount 0. Shouldn t that be fixed IndexReader already has a closed member which is set to true in close . Why not use it Ahh perfect let s use that In fact it s strange - close decreases refCount and set closed to true but if decRef is called from another reader it is a public method so maybe even from an outside app and refCount is 0 close will call decRef again and fail on assert refCount 0. If decRef is called and refCount is 0 doClose not close is called. I think this is right I tried using closed but TestIndexReaderReopen fails. It appears that closed is used mainly to not execute close twice i.e. after you call it once calling it again will do nothing on the same instance. Even after I set closed to false wherever it should be wherever refCount is increased or set to greater than 0 and set it to true in decRef s if refCount 1 section the test fails. If I come up w isOpen the test passes. I think it s because IndexWriter.ReadersPool closes a reader and the test then attempts to close the reader again then comparing the ref counts. So I m not sure closed can be used. If decRef is called and refCount is 0 doClose not close is called. I think this is right If you call decRef and then close it ll be wrong I think the solution is to set closed true in decRef after doClose has returned So I m not sure closed can be used. Woops sorry closed cannot be used it simply reflects whether the referrer who had opened the reader has closed it. So even once they ve closed it the reader can stibe open because others are holding references. We need a separate member that s set as soon as refCount hits 0. If you call decRef and then close it ll be wrong I think the solution is to set closed true in decRef after doClose has returned But if refCount hits 0 and closed is false then there s some bug lurking in the app code or the Lucene code Ie someone did an extra decRef. I d rather things fail then hide the bug in that case. But if refCount hits 0 and closed is false then there s some bug lurking in the app code or the Lucene code Ie someone did an extra decRef. I d rather things fail then hide the bug in that case. By that you re saying that calling decRef and then close is wrong which I agree but still possible. Why not protect against it by setting closed true in decRef if refCount drops to 0 What good does not hiding that bug do Currently the tests pass whether I protect against it or not so our code works fine no surprises here . But I just think that decRef and close are public which doesn t prevent anyone from calling them in whatever order one wants . If you don t think it s necessary to protect against it I ll post a patch w o it. Patch with protecting against decRef and close . Lines 28-30 include this particular change so if you disapprove just delete these lines assuming everything else is good . I see all access to refCount is synchronized. Why is it volatile then Just because of ensureOpen Patch looks good thanks Shai Why is it volatile then Good question. Only the ctor which I believe is fine and ensureOpen access it un-synchronized so I think we should make it un-volatile I ll change it before committing. What good does not hiding that bug do EG say we re working on SegmentReader an accidentally create a bug that sometimes over decRefs. By no longer throwing an exception on close with this change unit tests might happily pass when previously they would fail and the bug could go undetected for longer. Hopefully some tests would still catch the bug but maybe not . I think catching a bug sooner rather than later is better. Calling close many times is allowed not a bug and we handle that by only doing one decRef. But too many calls to decRef is a real bug and I think we shouldn t mask delay it. Patch looks good thanks Shai Note that decRef sets closed true if refCount 0. This will protect against the other bug calling close then decRef or vice versa . So if you don t want it there we should remove it before committing. so I think we should make it un-volatile I ll change it before committing. If we change refCount to not volatile is this patch still needed I.e. what s wrong w checking in ensureOpen if refCount 0 same as before But too many calls to decRef is a real bug and I think we shouldn t mask delay it. That would not be possible since decRef asserts refCount 0 and asserts are enabled in tests and calls ensureOpen . So calling decRef twice in a raw would hit either an assert exception tests or ACE assertions disabled . I think So calling decRef twice in a raw would hit either an assert exception tests or ACE assertions disabled . I think Let s say I open a reader I incRef it once somewhere.... then the reader is passed around and some other code somewhere incorrectly calls decRef twice then finally at the end I close the reader. Today that trips an assertion because you decRef d too many times and one of them stole the ref you got from open. But with this change we would not trip an assertion. If we change refCount to not volatile is this patch still needed I.e. what s wrong w checking in ensureOpen if refCount 0 same as before Duh right I think we in fact have nothing to do here... Ok I won t argue about that - these are hypothetical things anyway . Duh right I think we in fact have nothing to do here... Except making refCount not volatile . BTW Yonik has just sent an email to java-dev on the semantics of close . Maybe if things need to change we can do it as part of this issue. Except making refCount not volatile OK I just committed that. How crazy to have a one-line change Such contrast BTW Yonik has just sent an email to java-dev on the semantics of close . Maybe if things need to change we can do it as part of this issue. Let s do that don t allow double-closing under a new issue Do you think that changing ensureOpen to check if refCount 0 will speed things up a bit Alas I don t think we should do that. Eg if an app over-decRef s and refCount becomes -1 but doesn t trip the assert because assertions are off we want to still hit the ACE. Do you think that changing ensureOpen to check if refCount 0 will speed things up a bit Nope - not on any common CPUs. There is normally a test instruction which sets a bunch of status flags - branching on those status flags for less-or-equal is the same exact cycle count as equal. I also just double-checked and confirmed that the macro-op fusion in intel s latest processors treats CMP followed by JNE JE the same as if followed by JA JAE JB JBE. if an app over-decRef s and refCount becomes -1 but doesn t trip the assert Following assert we call ensureOpen so I don t think refCount will ever be less than 0. Right Following assert we call ensureOpen so I don t think refCount will ever be less than 0. Right Heh you are correct The only place where we change refCount we also always call ensureOpen. So there s currently no way for it to slip past zero without ensureOpen noticing. Still I d prefer to leave it defensively eg in case things ever change such that refCount could become negative. sure especially if 0 and 0 perform the same in modern CPUs Shai I am curious did you resolve your issue with TestRussianStem Although I do not experience this problem it is unclear why RussianAnalyzer exists when it appears to be a duplicate of snowball functionality in contrib snowball Russian stemming algorithm implementation see http snowball.sourceforge.net for detailed description . I haven t tried since then ... I think it s an encoding issue one of the .txt files was checked out using incorrect encoding . I did change my SVN config file to add eol-style native to a bunch of extensions but I m not sure if that s related. Anyway this seemed to happen after these changes. my code was a little out of date. I am now experiencing this problem too. I think you hit the nail on the head the related files wordsUnicode.txt and stemsUnicode.txt are in UTF-16 encoding. this might be causing the issue because EOL is very different in that encoding so do we need to change those back to not eol-style native I know Mike updated a lot of files recently to eol-style native I think one of those two was updated as well . Why doesn t Hudson encounter this problem I ve commented out the .txt line in my SVN config. Previously I didn t have it but I followed a page from Solr wiki http wiki.apache.org solr CommitterInfo head-849f78497222f424339b79417056f4e510349fcb which recommended to put it. I ll try to checkout again though I m not sure if that will help. I think we need to revert the change that was done on r787424. I see that on r153431 Feb 2005 the comment is change eol style to LF - maybe it was for a reason Why doesn t Hudson encounter this problem Forgive my ignorance does hudson also run tests or just verify build These files are only used in tests I agree we should correct it and perhaps to prevent other problems these files should be converted to UTF-8. For the record I am still confused about these java-code analyzers that implement snowball algorithms why do they exist when the same functionality is in contrib snowball 
