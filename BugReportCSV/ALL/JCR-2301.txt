CND support in jackrabbit-jcr-commons
It would be nice if the CND parsing functionality in spi-commons could be made available in jcr-commons for use by JCR clients that shouldn t have to know anything about the SPI.Initially the CND parser moved from core to spi-commons. See JCR-1516. The parser is useful for both JCR and SPI. So there will always be an additional dependency. Since SPI implementations almost always depend on jcr-commons anyway moving the parser might be a good idea. However the different representations of Names Types etc would have to be factored out. Currently the parser uses builders for constructing the types QNodeDefinitionBuilder QNodeTypeDefinitionBuilder QPropertyDefinitionBuilder . These would need to be generalized. Both jcr-commons and spi-commons need to provide their specific versions for these builders.I can imagine a copied new cnd parser that does not use the QNodeType Node PropertyDefinition classes at all. It would directly implement the JCR 2.0 NodeTypeDefinition NodeTypeTemplate et al. classes and instantiate them. For parsing valid names it could directly use the session s getNamespaceUri and getNamespacePrefix methods without using spi s flexible NameResolver mechanism. Any problem that I missed IMHO a version in jcr-commons should not implement the Definition and Template classes. Instead it should use the standard JCR factory methods to build the type templates based on the parsed CND files. Any problem that I missed Yes SPI implementations need to read cnd files and create QNode... representations from them.The process needs to be a bit more general. We need the parser to be able to generate QNodeTypeDefinitions SPI usage and NodeTypeDefinitions JCR usage . So I suggest to split the parser into a front end for lexical syntactical analysis and a back end for generating the specific representation. AFAIR the split is more or less there already see usage of QNodeDefinitionBuilder QNodeTypeDefinitionBuilder QPropertyDefinitionBuilder . Only the back ends would have to be factored out. Instead it should use the standard JCR factory methods to build the type templates Ah you are right I missed them. Well that makes it even simpler. The process needs to be a bit more general. I think it would be ok to duplicate the parser code here since it s stable and for the sake of library minification. That way the parser in spi-commons can be optimized for the spi use case and the one in jcr-commons is as simple as possible.14 commits to jackrabbit-spi-commons src main java org apache jackrabbit spi commons nodetype compact in 2009 only doesn t seem too stable to me - I dont like the idea of duplicate code here. I d still go with factoring out the differences. 14 commits ... in 2009 only doesn t seem too stable to me All those commits were related to JCR 2.0 changes or general clean up not fixing actual parsing bugs. I think moving all those QNode classes over to jcr-commons is really a bit of overkill if you can get them simply via NodeTypeManager.createNodeTypeTemplate et al. Otherwise I think one could share the lexer and an abstract base class for CND reading that operates on JCR 2.0 NodeTypeTemplate interfaces and gets them from an abstract method createNodeTypeTemplate same for node defs and property defs . If this will be used by spi-commons as well it would be forced to have QNode to extend from the new JCR 2.0 templates. Or one would provide yet another wrapper that implements both Template and QNode interfaces internal to the spi cnd parser.Instead of using inheritance for parametrization of the parser I d use composition as explained above The parser already uses a builder QNodeTypeDefinitionsBuilder to build the final representation. That is the parser itself is rather independent of the spi classes. The builder is not. I suggest to change things along the line of class CompactNodeTypeDefReader ... to class CompactNodeTypeDefReader T ... The constructor which now takes a QNodeTypeDefinitionsBuilder would then take a NodeTypeDefinitionsBuilder T and getNodeTypeDefinitions would return List T . Like this jcr-commons and spi-commons both need to provide a builder which can be used with the parser. The parser itself can be reused amongst both modules. Proof of concept patch. Class CompactNodeTypeDefReader is parametrized now   class CompactNodeTypeDefReader T N where T is the types to build and N the namespace mapping to use. CompactNodeTypeDefReader constructor takes a builder for these types. Builders must derived from AbstractItemTypeDefinitionsBuilder T N . CompactNodeTypeDefReader AbstractItemTypeDefinitionsBuilder and related classes do not have any SPI dependencies anymore Missing yet - JavaDoc is hopefully out dated - everything still in spi-commons - CompactNodeTypeDefReader.read needs to move to utility class since it ties in spi dependencies. Just thinking why does the CND reader even need to be able to directly create the Q objects With my patch it isn t anymore. Creating the type representations is delegated to a builder.Sure but why do we need the builder layer instead of directly using the JCR 2.0 API ..because you would loose the namespaces if pure NodeTypeDefinitions would be builded. but if the provided namespaces are exposed from the reader thats probably ok.I would also prefer usage of the JCR 2.0 API Template interfaces. SPI could be rewritten to have the Q interfaces extend from them. A subclass of the cnd parser in jcr-commons in spi-commons could then set the parsed variants of names and namespace mappings on the Q objects.I still prefer to keep the parser independent. Although it adds some complexity in particular AbstractItemTypeDefinitionsBuilder and its implementations it adds a great deal of flexibility. Also that way changes to client code is minimal. With the proposed patch it is quite easy to parametrize the parser such that it generates a JCR 2.0 API Template bases representation of the CND. Just implement an AbstractItemTypeDefinitionsBuilder NodeTypeTemplate N... and pass it to CompactNodeTypeDefReader s constructor. Also note that the parser is currently used to create two different representations of the CND one in core another in spi . AFAIU you want to use it to create yet another representation JCR API node types templates . Therefore I think it doesn t make sense to move the parser close to one specific representation. BTW it was moved from core to spi already JCR-1516 because we then thought the spi representation would be the more general one.JCR-2301.patch contains the same changes like the previous patch and in addition moves the parser to jcr-commons. In addition it adds ItemTemplatesBuilder which can be used with CompactNodeTypeDefReader to build NodeTypeTemplate instances from a CND. I like this approach.I would not object against this approach - the only thing I d like to see is a simple CND reader subclass that works out of the box for JCR 2.0 Templates without having to worry about any Builder classes. The reason is that we need a plain simple replacement for the deprecated register node types via InputStream of the Jackrabbit API.Ok I ll add such an utility class then and commit the patch next week . Note however that you will still have to either pass a Session or a Worspace or a NodeTypeManager a ValueFactory and possibly a NamespaceRegistry to such a utility class.Feedback on JCR-2301.patch - can we move the Q DefinitionsBuilder one package up I think those are not only useful in context of CND reading but in general to build a Q Definition instances. - can we move the Q DefinitionsBuilder one package up Ok ack. I ll do so. Note however that you will still have to either pass a Session or a Worspace or a NodeTypeManager a ValueFactory and possibly a NamespaceRegistry to such a utility class. Session should be fine.Fixed in revision 814610 In addition to the changes in the patch I added the CndImporter utility class which can be used for importing CNDs.
