TestFSTs.testRealTerms produces a corrupt index
seems to be prox skip related the test passes but the checkindex upon closing fails. ant test-core -Dtestcase TestFSTs -Dtests.seed -4012305283315171209 0 -Dtests.multiplier 3 -Dtests.nightly true -Dtests.linedocsfile c data enwiki.random.lines.txt.gz Note to get the enwiki.random.lines.txt.gz you have to fetch it from hudson warning 1 gigabyte file . you also have to run the test a few times to trigger it. ill upload the index this thing makes to this issue. see https hudson.apache.org hudson job Lucene-trunk 1533 testReport junit org.apache.lucene.util.automaton.fst TestFSTs testRealTerms for the exception. attached is the broken segment 3 files . i played around with disabling d penum skipper reuse to figure out why we have a bad offset in the skip but i didnt get anywhere... I think this is an off-by-one lots of terms pass thru checkindex fine but then the problematic term happens to have df 1000... this segment has skipInterval 10 here s a much faster fails in 2 seconds test case. I noticed with this one it fails with StandardPostingsReader so I think the problem is general to multi-level skipping. The patch forces our random skip interval to be 2 10 instead of 2 64 thus causing us to test higher skiplevels more than usual. ant test-core -Dtestcase TestLongPostings -Dtestmethod testLongPostings -Dtests.seed 7951749419575219720 5894148324166575802 -Dtests.codec MockRandom again the same pattern here it fails when docFreq is a skipInterval N in this case docFreq 243 skipInterval 3 the problem is in our computation of number of skip Levels in this case Math.log 243 Math.log 3 0.499999999999 which is floored to 4 but there are really 5 skipLevels here. Attached is a patch to use StrictMath which fixes the bug. Maybe there is a cleaner way though... I don t like the floating point math here by the way existing indexes all with skipInterval 16 are unaffected. I ll commit this patch for now but keep the issue open in case someone is willing to write an integer version here which would be greatly preferred Committed revision 1095147 I don t know how applicable is this but floor log n log m p can be transformed into a simple equation find first p for which n m p is true. Assuming m p grows quickly this can be computed in a tight loop quite fast and with an exact result. hi dawid thanks i used this returns x 0 0 Math.floor Math.log x Math.log base static int log int x int base int ret 0 while x base x base ret return ret i did a quick test and this seems faster than our old calculation but speed isn t particularly important here though when initting the skipper at this place we are doing i o... its more important that the calculation isnt wrong. This should be even faster public static int log int x int base assert base 2 int ret 0 long n base needs to be a long to avoid overflow while x n n base ret return ret Hi Yonik looks good you want to just commit it committed. Robert your instinct to avoid floating point was good. StrictMath would not have eliminated all of the errors. For example log 380204032 52 using StrictMath still returns 4 while the integer versions correctly return 5. yeah strictmath didnt really help that much actually it only fixed a few cases but many were still broken. log 1000 10 with strictmath is another example it will still be 2 instead of 3. personally I really like that we eliminated the floating point stuff here maybe we should think about backporting to 3.x. It should be safe as there aren t any problems with a base of 16. I implemented the theoretically O log log n complexity algorithm described here and compared timing for Robert s Yonik s and my implementation. Yonik s is fastest . Timings log1 is Robert s log2 is Yonik s and log3 is mine log1 2384ms for 100000000 iterations. log2 1068ms for 100000000 iterations. log3 1697ms for 100000000 iterations. Here s the test which also compares log2 and log3 against log1 for correctness or at least consistency -Xmx4g required to avoid OOMs with 100M iterations public void testLogMethodPerformance Random r new Random int iterations 100000000 int docFreqs new int iterations int skipIntervals new int iterations int log1Results new int iterations int log2Results new int iterations int log3Results new int iterations for int i 0 i iterations i docFreqs i r.nextInt 1000000000 skipIntervals i r.nextInt 1023 2 long start System.currentTimeMillis for int i 0 i iterations i log1Results i MultiLevelSkipListReader.log docFreqs i skipIntervals i long stop System.currentTimeMillis System.err.println log1 stop - start ms for iterations iterations. start System.currentTimeMillis for int i 0 i iterations i log2Results i MultiLevelSkipListReader.log2 docFreqs i skipIntervals i stop System.currentTimeMillis System.err.println log2 stop - start ms for iterations iterations. start System.currentTimeMillis for int i 0 i iterations i log3Results i MultiLevelSkipListReader.log3 docFreqs i skipIntervals i stop System.currentTimeMillis System.err.println log3 stop - start ms for iterations iterations. for int i 0 i iterations i assertEquals log1Results i log2Results i assertEquals log1Results i log3Results i Here s my implementation public static int log3 int x int b long b lo 1 long b hi b long b mid int lo 0 int hi 1 int mid Bracket the solution by recursively squaring the base until the result exceeds x while b hi x b lo b hi b hi b hi lo hi hi 1 Find the solution by performing a binary search between the bracketing values lo hi found above while hi - lo 1 mid lo hi 1 b mid b lo b mid-lo Java has no integer pow method - use a loop instead. Yes Math.pow double double would work but it s slower than this. b mid b lo for int i 0 i mid - lo i b mid b if b mid x hi mid b hi b mid else if b mid x lo mid b lo b mid else return mid return b hi x hi lo Guys again keep in mind that this log calculation is less than one-thousandth of the time spent in this skipper init.... The original method was waaaaaaaaay slower. I added this to my test int log0Results new int iterations ... start System.currentTimeMillis for int i 0 i iterations i log0Results i docFreqs i 0 0 int Math.floor StrictMath.log docFreqs i StrictMath.log skipIntervals i stop System.currentTimeMillis System.err.println log0 stop - start ms for iterations iterations. Result log0 17933ms for 100000000 iterations. log1 2420ms for 100000000 iterations. log2 1139ms for 100000000 iterations. log3 1697ms for 100000000 iterations. Guys again keep in mind that this log calculation is less than one-thousandth of the time spent in this skipper init.... Yeah just having fun. I know can you speed up the rest of the skipping too can you speed up the rest of the skipping too Well the code I posted is slower so I m afraid that if history is any guide here I can only promise pessimization...
