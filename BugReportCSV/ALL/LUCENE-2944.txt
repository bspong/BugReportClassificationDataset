BytesRef reuse bugs in QueryParser and analysis.jsp
Some code uses BytesRef as if it were a String in this case consumers of TermToBytesRefAttribute. The thing is while our general implementation works on char and then populates the consumers BytesRef not all TermToBytesRefAttribute implementations do this specifically ICU collation it reuses the bytes and simply sets the pointers Override public int toBytesRef BytesRef target collator.getRawCollationKey toString key target.bytes key.bytes target.offset 0 target.length key.size return target.hashCode Most of the blame falls on me as I added this to the queryparser in LUCENE-2514. Attached is a patch so that these consumers re-use a spare and copy the bytes when they are going to make a long lasting object such as a Term. I reviewed all uses of this attribute and fixed some more problems in contrib and solr. So in my opinion there are two options 1. apply this patch and fix the javadoc for this expert attribute which does say that it makes a copy of the bytes. 2. Don t apply this patch but instead change Test2BTerms and ICUCollationAttribute to make useless copies of the bytes for each term. The indexer has no problems either way the problem is only other consumers. I m just bringing up the second option because any performance improvement saved from not copying the bytes might be negligible and clearly its easy to screw this up. IMO this is ICUs problem here. This code should not give the key.bytes array to the outer world in this particular case unless its documented that you must not use modify the BytesRef you pass to toBytesRef anywhere else. Well its not just the ICU implementation... Test2BTerms does this too. In general the attributes are owned by the producer for example the char in TermAttribute is owned by the analysis chain if you want to do something with it you should copy it. So it would be very strange from the analysis api to treat byte in the complete opposite fashion... but I m fine with making steps to prevent bugs. here s the alternative patch also adding documentation that you must make a new copy of the byte for each term. I think producer should own the BytesRef and if consumer wants to hang onto it it should make a deep copy This is consistent w TermAttribute... I think producer should own the BytesRef and if consumer wants to hang onto it it should make a deep copy This is consistent w TermAttribute... Here s a new patch implementing it this way. I refactored TermToBytesRefAttribute into two methods getBytesRef and hash ... I find this less confusing removes some wasted bytesrefs being needlessly created here and there e.g. queryparser and does things like allow an attribute to say pre-size its reusable BytesRef to a huge size or other things custom attributes might want to do. Here is the consumer code sample I added from the javadoc Consumers of this attribute call getBytesRef up-front and then invoke hash for each term. Example final TermToBytesRefAttribute termAtt tokenStream.getAttribute TermToBytesRefAttribute.class final BytesRef bytes termAtt.getBytesRef while termAtt.incrementToken you must call termAtt.hash even if you don t need this hashCode. this encodes the term value internally it might be a char etc into the bytes. int hashCode termAtt.hash if isInteresting bytes because the bytes are reused by the attribute like CharTermAttribute s char buffer you should make a copy if you need persistent access to the bytes otherwise they will be rewritten across calls to incrementToken doSomethingWith new BytesRef bytes sorry previous patch was missing the new javadoc i added to TermToBytesRefAttribute... here it is with the javadocs. guys any comments on the api I am no good at naming so... But this bug is blocking some of my stuff I had a brief review - naming looks good from my side though... simon How about .fillBytesRef returns hash code instead of .hash How about .fillBytesRef returns hash code instead of .hash 1 I don t like solely hash . i agree guys here s the updated patch. Patch looks good Looks fine will do closer review tomorrow Committed revision 1083784.
