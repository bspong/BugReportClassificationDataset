Errors during concurrent session import of nodes with same UUIDs
21.08.2009 16 22 14 ERROR Executor 0 ConnectionRecoveryManager could not execute statement reason The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by SQL090821042140130 defined on DEFAULT BUNDLE . state code 23505 20000 ConnectionRecoveryManager.java line 453 21.08.2009 16 22 14 ERROR Executor 0 BundleDbPersistenceManager failed to write bundle 6c292772-349e-42b3-8255-7729615c67de BundleDbPersistenceManager.java line 1212 ERROR 23505 The statement was aborted because it would have caused a duplicate key value in a unique or primary key constraint or unique index identified by SQL090821042140130 defined on DEFAULT BUNDLE . at org.apache.derby.iapi.error.StandardException.newException Unknown Source at org.apache.derby.impl.sql.execute.IndexChanger.insertAndCheckDups Unknown Source at org.apache.derby.impl.sql.execute.IndexChanger.doInsert Unknown Source at org.apache.derby.impl.sql.execute.IndexChanger.insert Unknown Source at org.apache.derby.impl.sql.execute.IndexSetChanger.insert Unknown Source at org.apache.derby.impl.sql.execute.RowChangerImpl.insertRow Unknown Source at org.apache.derby.impl.sql.execute.InsertResultSet.normalInsertCore Unknown Source at org.apache.derby.impl.sql.execute.InsertResultSet.open Unknown Source at org.apache.derby.impl.sql.GenericPreparedStatement.execute Unknown Source at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement Unknown Source at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement Unknown Source at org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute Unknown Source at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal ConnectionRecoveryManager.java 371 at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmtInternal ConnectionRecoveryManager.java 298 at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt ConnectionRecoveryManager.java 261 at org.apache.jackrabbit.core.persistence.bundle.util.ConnectionRecoveryManager.executeStmt ConnectionRecoveryManager.java 239 at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.storeBundle BundleDbPersistenceManager.java 1209 at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.putBundle AbstractBundlePersistenceManager.java 709 at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.storeInternal AbstractBundlePersistenceManager.java 651 at org.apache.jackrabbit.core.persistence.bundle.AbstractBundlePersistenceManager.store AbstractBundlePersistenceManager.java 527 at org.apache.jackrabbit.core.persistence.bundle.BundleDbPersistenceManager.store BundleDbPersistenceManager.java 563 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.end SharedItemStateManager.java 724 at org.apache.jackrabbit.core.state.SharedItemStateManager.update SharedItemStateManager.java 1101 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 351 at org.apache.jackrabbit.core.state.XAItemStateManager.update XAItemStateManager.java 354 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 326 at org.apache.jackrabbit.core.state.SessionItemStateManager.update SessionItemStateManager.java 326 at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 1098 at org.apache.jackrabbit.core.SessionImpl.save SessionImpl.java 925 at org.apache.jackrabbit.core.ConcurrentImportTest 1.execute ConcurrentImportTest.java 73 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 209 at java.lang.Thread.run Thread.java 637 Added org apache jackrabbit core ConcurrentImportTest.java that reproduces this issue. attached a patch which causes an InvaliditemStateException to be thrown on coliding node creations ConcurrentImportTest.testConcurrentImport fails now with an InvalidItemStateException as expected the test should IMO be fixed. ConcurrentImportTest.testConcurrentImportVersionable fails now with a VersionException History already exists ... i am not sure whether that s a VersionManager issue.revised patchApplying the revised patch exposes another problem with an ItemState s internal data object which results in a NullPointerException when a session tries to modify an item that has been destroyed concurrently by another session. Submitting a cumulative patch JCR-2272 NPE.patch that fixes this issue and lets ConcurrentImportTest throw an unexpected exception - such as NPE - again as RepositoryException.adapted patch to current trunk r825918 however applying the patch causes a test failure Test set org.apache.jackrabbit.core.integration.JCRAPITest Tests run 1895 Failures 0 Errors 1 Skipped 0 Time elapsed 47.385 sec FAILURE testUpdate org.apache.jackrabbit.test.api.NodeTest Time elapsed 0.015 sec ERROR javax.jcr.RepositoryException org.apache.jackrabbit.core.state.StaleItemStateException d1edb4c2-a258-4fe4-864b-1bb73252b55f has been created externally at org.apache.jackrabbit.core.VersionManagerImpl.mergeOrUpdate VersionManagerImpl.java 350 at org.apache.jackrabbit.core.VersionManagerImpl.update VersionManagerImpl.java 287 at org.apache.jackrabbit.core.NodeImpl.update NodeImpl.java 3126 at org.apache.jackrabbit.test.api.NodeTest.testUpdate NodeTest.java 305 Caused by org.apache.jackrabbit.core.state.StaleItemStateException d1edb4c2-a258-4fe4-864b-1bb73252b55f has been created externally at org.apache.jackrabbit.core.state.SharedItemStateManager Update.begin SharedItemStateManager.java 677 at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate SharedItemStateManager.java 1087 at org.apache.jackrabbit.core.state.SharedItemStateManager.update SharedItemStateManager.java 1117 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 351 at org.apache.jackrabbit.core.state.XAItemStateManager.update XAItemStateManager.java 354 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 326 at org.apache.jackrabbit.core.version.VersionManagerImplBase WriteOperation.save VersionManagerImplBase.java 463 at org.apache.jackrabbit.core.version.VersionManagerImplMerge.merge VersionManagerImplMerge.java 109 at org.apache.jackrabbit.core.VersionManagerImpl.mergeOrUpdate VersionManagerImpl.java 348 ... 23 more See JCR-2295 for an occasional query test failure that was caused by the ConcurrentImportTest class introduced here. Marcel disabled the test in revision 812032.The last patch applies against trunk if   public static final int STATUS STALE MODIFIED 5 gets re-added not sure about the rational for removing it . Confirming that testUpdate fails. I also get four failures in the ShareableNodesTests.as of JCR-2650 STATUS STALE MODIFIED is not applicable anymore I also get four failures in the ShareableNodesTests. Apparently known issue JCR-2756 - was running from Eclipse. Stefan as of JCR-2650 STATUS STALE MODIFIED is not applicable anymore So is there another state that could be used I tried STATUS UNDEFINED which seems to yield exactly the same result.Patch updated for trunk with STATUS STALE MODIFIED replaced by STATUS UNDEFINED. The problem in NodeTest.testUpdate remains though.NodeTest.testUpdate fails. because the update operation happens on a node which has an additional child node in the workspace the update imports from. This node handled as addedState and detected as status STATUS NEW thus the operation fails. Wild guess maybe the update merge code needs to create a NodeState with a different status here Stefan wrote ConcurrentImportTest.testConcurrentImportVersionable fails now with a VersionException History already exists ... i am not sure whether that s a VersionManager issue. I think it s correct that an exception occurs here the question seems to be mainly whether it s the correct exception to throw and whether the save operation is properly aborted... Proposed patch.Summary so far - the problem on update was caused by the node state of the new node being flipped from NEW to EXISTING MODIFIED while removing the jcr mixins property which apparently isn t seen on the source node not sure why the pattern to change the state only for NEW was already common in NodeStateEx so it was probably an oversight that it wasn t followed in this case as well. - the change for ItemStateManager used STATUS STALE MODIFIED previously which has been removed in the meantime somebody needs to have a look whether STATUS UNDEFINED is correct here ...ConcurrentImportTests - these had be excluded both in pom.xml and not being added in TestAll before. testConcurrentImport works for me in Eclipse when I move addNode test uuid JcrConstants.NT UNSTRUCTURED uuid mixins inside the try block so the exception happens early before save . It doesn t work for me when run from Maven me confused - testConcurrentImportVersionable aborts as it should but with a VersioningException instead of the expected StaleItemException not sure how we should address this tune the test expectation What is the reason for the change in the ItemManager STATUS UNDEFINED This doesn t sound correct but all other alternative seem inappropriate as well. Maybe we should introduce a STATUS STALE NEW After all the node is still new because it had been added. We just want to make sure it isn t persisted. STATUS UNDEFINED On the other hand we also use it in ItemState.discard . So the status isn t just used as default value for uninitialized ItemState. What is the reason for the change in the ItemManager Dunno it seems it was added by Dominique in the 2009-09-10 patch.Running ConcurrentImportTest.testConcurrentImport some more I still see various different non-reproducible exceptions not entirely surprisingly given the nature of the test . We probably need to go through each of them and decide whether they are just cases where the wrong exception is thrown or whether there s an issue left. I think it would make sense to add code that tests for the repository corruption we re after. Is there something more elegant than doing a query for all nodes and checking getPath on each of them ...attached a new patch that a attempts to explain why we set the state UNDEFINED and b adds a sanity check to the test case for a subsequent save after a failed save . The remaining issues still are - how do we in general test for RM corruption - fix the remaining test failures are these acceptable or do they need more tests and fixes b adds a sanity check to the test case for a subsequent save the session.save must happen before the session.refresh otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in the Task thread must be reported back to the main test thread which then calls fail. how do we in general test for RM corruption This is a more general problem with the checkConsistency method on the PersistenceManager. It does not have a return value nor does it throw an exception when it detects inconsistencies. I think we should open a new issue about this. fix the remaining test failures Are there other test failures other than JCR-3068 the session.save must happen before the session.refresh otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in the Task thread must be reported back to the main test thread which then calls fail. Indeed. Will fix. This is a more general problem with the checkConsistency method on the PersistenceManager. It does not have a return value nor does it throw an exception when it detects inconsistencies. I think we should open a new issue about this. Will open a separate ticket for this TODO. Are there other test failures other than JCR-3068 1 ConcurrentImportTest occasionally falls with other exceptions. 2 ConcurrentImportTest.testConcurrentImportVersionable fails with VersionException History already exists and we need to decide whether this is ok Given the fact that in theory the save operation should not fail at all see JCR-3068 we probably can treat it like the other exception for now.I agree the version history issue probably has the same root cause. It would be nice when the test did not throw an exception at all but I don t consider this a critical issue right now. The use case is IMO rather theoretical and an application could still handle the exception caused by a concurrent import. I think the important part of this issue is to make sure the repository keeps consistent. the session.save must happen before the session.refresh otherwise it will always succeed and fail is called. Unfortunately fail is called within the Task thread and will not cause the test case to fail. A failure in the Task thread must be reported back to the main test thread which then calls fail. Updated the test so it doesn t use fail and does the 2nd save without a refresh Surprise or not the subsequent save actually succeeds . This is not that surprising as we have a race condition and the save should have succeeded anyway.More observations - concurrent import fails with different kinds of RepositoryExceptions not only InvalidItemStateExceptions as for this case there shouldn t be any exceptions it seems to be ok to allow all kinds of RepositoryExceptions for now and address this problem later on - exceptions sometimes happen before save and thus are not accepted I think that behavior is ok so we should move addNode into the try block The most important issue continues to fix those exceptions which are caused by the attempt to add a node to the persistence although it is already there on the PersistenceManager level we should a change BundleDBPersistenceManager to produce a more useful exception in this case and b in the test case follow the exception chain checking for an SQLIntegrityViolationException treating that as a test failure. Patch follow with that patch we still see occasional failures and we probably need to dig deeper. Updated patch now aborts suspicious call into BundleDBPersistenceManager running ConcurrentImportTest frequently enough still causes this constraint violations on the DB level to happen.Traces obtained by adding debug output to various places. It shows that the new code in LocalItemStateManager does not catch the change done in thread 1 as thread 1 s beginUpdate happens too late.Another trace now logging the downgrade of the write log as well. Note that threads 1 and 2 finish before 0 and 3 start so it s only two threads 0 and 3 involved here.The latest patch looks like a reasonable step forward. I ll try to review the attached traces to better understand also the deeper interactions here. Meanwhile some comments The SQLIntegrityConstraintViolationException class is only available since Java 6. As an alternative we could try to interpret the value returned by the SQLException.getSQLState method. I couldn t get the ConcurrentImportTest to fail with the latest patch despite numerous attempts but that might be just due to my pretty fast server and the relatively low level of concurrency in the test case. Or then everything is just fine. - What I do see instead is plenty of warnings like the following. I didn t check yet if this is because of the changes in the patch or something we d in any case need to fix. 15 01 43.975 WARN Executor 0 ItemSaveOperation.java 885 testroot 9afd33fd-b66d-4c8f-9d02-0fe16245d0bc jcr mixinTypes failed to restore transient state javax.jcr.RepositoryException org.apache.jackrabbit.core.state.ItemStateException there s already a property state instance with id 9afd33fd-b66d-4c8f-9d02-0fe16245d0bc http www.jcp.org jcr 1.0 mixinTypes         at org.apache.jackrabbit.core.PropertyImpl.restoreTransient PropertyImpl.java 197 classes na         at org.apache.jackrabbit.core.ItemSaveOperation.restoreTransientItems ItemSaveOperation.java 879 classes na         at org.apache.jackrabbit.core.ItemSaveOperation.perform ItemSaveOperation.java 277 classes na         at org.apache.jackrabbit.core.session.SessionState.perform SessionState.java 200 classes na         at org.apache.jackrabbit.core.ItemImpl.perform ItemImpl.java 91 classes na         at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 329 classes na         at org.apache.jackrabbit.core.session.SessionSaveOperation.perform SessionSaveOperation.java 64 classes na         at org.apache.jackrabbit.core.session.SessionState.perform SessionState.java 200 classes na         at org.apache.jackrabbit.core.SessionImpl.perform SessionImpl.java 360 classes na         at org.apache.jackrabbit.core.SessionImpl.save SessionImpl.java 809 classes na         at org.apache.jackrabbit.core.ConcurrentImportTest 1.execute ConcurrentImportTest.java 95 test-classes na         at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 209 test-classes na         at java.lang.Thread.run Thread.java 662 na 1.6.0 23 Caused by org.apache.jackrabbit.core.state.ItemStateException there s already a property state instance with id 9afd33fd-b66d-4c8f-9d02-0fe16245d0bc http www.jcp.org jcr 1.0 mixinTypes         at org.apache.jackrabbit.core.state.SessionItemStateManager.createTransientPropertyState SessionItemStateManager.java 631 classes na         at org.apache.jackrabbit.core.PropertyImpl.restoreTransient PropertyImpl.java 191 classes na         ... 12 common frames omitted The SQLIntegrityConstraintViolationException class is only available since Java 6. As an alternative we could try to interpret the value returned by the SQLException.getSQLState method. Will fix. I couldn t get the ConcurrentImportTest to fail with the latest patch despite numerous attempts but that might be just due to my pretty fast server and the relatively low level of concurrency in the test case. Or then everything is just fine. - On my test machine it usually requires 10 iterations. What I do see instead is plenty of warnings like the following. I didn t check yet if this is because of the changes in the patch or something we d in any case need to fix. I don t believe I have seen those will pay attention.I created the JCR-2272 branch for this so we can better exchange code until the tests no longer fail and we can merge the work back to trunk. In revision 117316 I committed your latest patch to the branch and in revision 1173169 I broke the Java 6 dependency.There s a pretty nasty case of an IllegalStateException a RuntimeException being thrown by ItemState.connect when it detects an inconsistency caused by this problem. To make such issues more visible and easier to catch I changed the exception to an ItemStateException in revision 1173558 of the JCR-2272 branch. One very troublesome effect of that exception is that it can cause a repository deadlock since the cluster lock never gets released in SISM.Update.end when the exception gets thrown from within the ChangeLog.persisted call. I ll look into making the cluster lock handling more robust move the unlocking to a finally block before digging deeper into this consistency problem.See revisions 1173578 and 1173579 for the changes required to prevent an unexpected exception from locking the entire cluster. I digged deeper into this problem and I think I now have a pretty good idea of what goes wrong. When a session creates a node with an explicitly given UUID it can be that the new transient NodeState gets created right after some other thread has persisted another node with the exact same UUID. In such a case the new NodeState doesn t necessarily receive notifications about the other node having been created and thus its status is still STATUS NEW. The attached patch contains an initial patch that attempts to prevent such cases by explicitly checking the underlying persistence manager for duplicate ids once a new NodeState has already been connected to the state notification mechanism. This check is only done when a predefined UUID is used so it shouldn t affect performance too badly though I ll still need to check how the creation of the localState instance in NodeImpl.makePersistent affects this assumption since there the id of a transient node gets copied . The patch passes all tests and as far as I can tell fixes also the ConcurrentImportTest. However it s a pretty complex change so code reviews would be welcome.I committed the proposed patch to the JCR-2272 branch in revision 1174016. In the followup revision 1174017 I fixed a problem for handling of transient spaces that both remove and add a node with the same UUID. The followup revision also avoids the duplicate id checks in NodeImp.makePersistent which should prevent the extra performance hit.It seems to me that the changes really help but I still see occasional failures from running ConcurrentImportTest in a loop I d say it happen roughly 2 of the time.With the current code I see occasional NPEs such as Exception in thread Executor 0 java.lang.NullPointerException         at org.apache.jackrabbit.core.ItemSaveOperation.validateTransientItems I temSaveOperation.java 493         at org.apache.jackrabbit.core.ItemSaveOperation.perform ItemSaveOperatio n.java 216         at org.apache.jackrabbit.core.session.SessionState.perform SessionState. java 200         at org.apache.jackrabbit.core.ItemImpl.perform ItemImpl.java 91         at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 329         at org.apache.jackrabbit.core.session.SessionSaveOperation.perform Sessi onSaveOperation.java 64         at org.apache.jackrabbit.core.session.SessionState.perform SessionState. java 200         at org.apache.jackrabbit.core.SessionImpl.perform SessionImpl.java 360         at org.apache.jackrabbit.core.SessionImpl.save SessionImpl.java 809 or Exception in thread Executor 1 java.lang.NullPointerException         at org.apache.jackrabbit.core.ItemManager.getDefinition ItemManager.java 206         at org.apache.jackrabbit.core.ItemData.getDefinition ItemData.java 99         at org.apache.jackrabbit.core.AbstractNodeData.getNodeDefinition Abstrac tNodeData.java 73         at org.apache.jackrabbit.core.NodeImpl.getDefinition NodeImpl.java 2423         at org.apache.jackrabbit.core.xml.SessionImporter.startNode SessionImpor ter.java 349         at org.apache.jackrabbit.core.xml.SysViewImportHandler.processNode SysVi ewImportHandler.java 94         at org.apache.jackrabbit.core.xml.SysViewImportHandler.endElement SysVie wImportHandler.java 249         at org.apache.jackrabbit.core.xml.ImportHandler.endElement ImportHandler .java 195         at org.apache.jackrabbit.core.ConcurrentImportTest.addNode ConcurrentImp ortTest.java 200         at org.apache.jackrabbit.core.ConcurrentImportTest 1.execute ConcurrentI mportTest.java 95         at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run Abstr actConcurrencyTest.java 209 To solve JCR-3063 it looks like we may need to revert the changes of JCR-2171. That shouldn t be a problem since Stefan has meanwhile modified how transient items are handled and the original deadlock scenario of JCR-2171 should no longer be possible. Reverting JCR-2171 should help also here as doing so would move the troublesome item state notifications back inside the SISM write lock.Together with JCR-3063 that explains the above NPEs and some last touches I added in revision 1176545 I think we re pretty much done here. I merged the branch work back to trunk in revision 1176546. I also merged the changes back to the 2.2 branch in revision 1176577 for inclusion in the 2.2.9 release.
