 PATCH Some Field methods use Classcast check instead of instanceof which is slow
I am not sure if this is because Lucene historically needed to work with older JVM s but with modern JVM s instanceof is much quicker. The Field.stringValue .readerValue and .binaryValue methods all use ClassCastException checking. Using the following test-bed class you will see that instanceof is miles quicker package com.aconex.index public class ClassCastExceptionTest private static final long ITERATIONS 100000 param args public static void main String args runClassCastTest 1 once for warm up runClassCastTest 2 runInstanceOfCheck 1 runInstanceOfCheck 2 private static void runInstanceOfCheck int run long start System.currentTimeMillis Object foo new Foo for int i 0 i ITERATIONS i String test if foo instanceof String System.out.println Is a string should never print long end System.currentTimeMillis long diff end - start System.out.println InstanceOf checking run run diff ms private static void runClassCastTest int run long start System.currentTimeMillis Object foo new Foo for int i 0 i ITERATIONS i String test try test String foo catch ClassCastException c ignore long end System.currentTimeMillis long diff end - start System.out.println ClassCast checking run run diff ms private static final class Foo Results Run 1 ClassCast checking run 1 1660ms ClassCast checking run 2 1374ms InstanceOf checking run 1 8ms InstanceOf checking run 2 4ms Run 2 ClassCast checking run 1 1280ms ClassCast checking run 2 1344ms InstanceOf checking run 1 7ms InstanceOf checking run 2 2ms Run 3 ClassCast checking run 1 1347ms ClassCast checking run 2 1250ms InstanceOf checking run 1 7ms InstanceOf checking run 2 2ms This could explain why Documents with more Fields scales worse as in for lots of Documents with lots of Fields the effect is exacerbated. Created an attachment id 15142 Patch to change Field class to use instanceof check instead of ClassCast It s important to note than it s only slower if the exception is actually thrown. Just using the try catch block doesn t isn t bad for performance. If the exception is never thrown the additional instanceof will actually make things slightly slower. You might want to double check that assumption on modern VMs. The type check must be done anyway and VMs optimize away the second type check cast which is immediately followed by the first one instanceof since at this point the type is already known. Daniel you are correct that the cost of the exception catching is only incurred if the exception is actually thrown. I was a bit stunned to see this crop up in performance analysis. See Bug 34930 where some performance profiling highlights this area as one of the higher CPU consumers so it must be getting called. now over a large Document set being indexed if it is invoked quite a bit it ends up causing a reasonable impact on the overall timeline for indexing. Isn t the proposed patch a better way to do the same thing even if it s NOT called that often We just need to make sure to optimize for the common use case not for some special case. If the exception was never thrown try catch was 30-40 faster because it doesn t require the additional instanceof tested with Java 1.4 . I suggest we first find out how often the exception is thrown on average. I don t know what you were measuring but that s not the the case in any environment I ve seen since JDK 1.3 even with the client VM. To see for yourself try this with and without cast cast2 . public static void main String args throws Exception int iters Integer.parseInt args 0 e.g. 1000 int runs Integer.parseInt args 1 e.g. 3 int sum 0 Object arr new Object 10000 Object obj xx if Boolean.valueOf args 2 .booleanValue obj new Integer 0 for int i 0 i arr.length i arr i obj for int run 0 run runs run System.out.println nrun run long start System.currentTimeMillis for int j 0 j iters j for int i 0 i arr.length i sum cast2 arr i .charAt 0 sum cast arr i .charAt 0 long end System.currentTimeMillis System.out.println secs end-start 1000.0f System.out.println checksum sum private static String cast Object x if x instanceof String return String x return yy private static String cast2 Object x try return String x catch ClassCastException e return yy The area of code that is affected by this is in DocumentWriter.invertDocument Document ... Reader reader find or make Reader if field.readerValue null reader field.readerValue else if field.stringValue null reader new StringReader field.stringValue else throw new IllegalArgumentException field must have either String or Reader value In my test scenario I do not use a reader all my Fields are created as normal String values so the first if to determine if the reader comes back null will always result in an ClassCastException. That s 1 ClassCastException for each Indexed Tokenized field per Document. I m not sure of whether String Reader is more prevelant out there in the wild but I would have thought String would have been common. Sure for large documents like PDF s etc it s more likely a Reader will be used. Anyway for the try catch block the JVM performs an implicit ClassCast check anyway that s how it determines whether it should throw an exception or not so there is no way to avoid some form of an instanceof. Modern JVM s are quicker with instanceof. However this may not probably not true for older 1.2 or earlier VM s although I don t have access to that anymore test that theory. Paul I also use mostly String instead of Readers... but testing the patch by adding 10000 small documents to a RAMDirectory I couldn t see any difference. Even running the same code multiple times gives varying results for me. I guess my desktop environment and the Pentium M just aren t appropriate for these kind of tests. Wolfganfg I used the code pasted in the original report but modified so that instanceof is always true and a cast is done after that and so that the exception is never thrown. See above my setup is probably not appropriate for measuring small differences. Daniel If there s a lot other stuff going on that introduces measurement variance and perturbation it makes sense to isolate the cast issue into a small microbenchmark. I think the code I sent demonstrates beyond doubt that the instanceOf cast version is always faster no matter which branch is taken. It doesn t matter which branch is more common it s always faster. The catch ClassCastException is an idiom that may have worked well in JDK 1.2 but it is demonstrably counterproductive on more recent VMs. Daniel could you post your test class so I can try your same test on my end cheers Paul Created an attachment id 15188 simple indexing performance test Thanks for you test case Daniel I appreciate your time in analysing this pardon the pun... maybe only a little... . I ran your test and got similar results as in with class cast or instanceof they were about the same which I thought odd indeed... Then I spotted something. You re test case uses Field.Index.NO for the non-stringreader case. This ends up bypassing the bit of code I mentioned in DocumentWriter see the if block on line 140 of DocumentWriter for our test the Field has to be an Indexed tokenized field . Try these lines instead doc.add new Field body laber Field.Store.YES Field.Index.TOKENIZED doc.add new Field body2 blubb Field.Store.YES Field.Index.TOKENIZED doc.add new Field body3 bla Field.Store.YES Field.Index.TOKENIZED I got about 10-30 slower results with class cast because using this example of Tokenised text the class cast does actually get thrown and caught. Yes results are quite broad but the instanceof test slowest result was always better than the faster classcast results. Modern VM s exception creation is miles better than it used to be but older VM s were pretty awful. I wonder what the difference is with say JDK 1.3. At the end of the day this is only a minor performance improvement but it can add up when doing a LOT of documents with a lot of fields hence I thought this would be a worth while improvement. I thought I would add one more comment. Perhaps the current implementation doesn t suffer from class cast problem because most people don t actually tokenize Strings Perhaps they always use Readers which ends up being lucky in that it s always checked for first and therefore never suffers from the class cast exception I think the key observation for this issue backed up by benchmarks and profiling is that instanceOf followed by cast is always faster no matter which branch ends up being taken. It doesn t matter which use cases might be more common than others because it s always faster no matter what. I think that catching the Exception here is bad style Exceptions should not be used for control flow in ordinary circumstances. It should also be faster but I m not sure whether this is a significant or a premature optimization. Regardless I vote to accept this patch on the basis of style alone. As another style comment the else clause is unnecessary if fieldsData instanceof String return String fieldsData return null Eclipse highlights the current patches else return null with a warning. I was also wondering why Field.java is not indented... instanceof is faster for me faster than testing getClass otherClass too and it s better style. fix applied.
