An IOException or RuntimeException leaves the underlying socket in an undetermined state
If an application level IOException or RuntimeException occurs the underlying socket will be in an undetermined state. In many cases this will lead to zombie connections in the pool that do not respond properly. Simple example uploading a file via POST. If we promise the server 1MB of data. Shortly after starting the transfer an IOException occurs e.g. the NFS server the file was residing on stops responding . The connection is returned to the pool see HTTPCLIENT-302 but the the server is still expecting close to 1MB of data on that socket. The next request on that socket e.g. a GET will send the HTTP header but the server thinks the header is part of the old stream and doesn t respond.Mohammad I did not forget about this one. But again as pain in the rear as I can be I am not sure it this bug warrants a fix for 2.0 for the following reason bugs like that are horribly difficult to test comprehensively and 2.0 architecture is too convoluted not to stand a risk of breaking something else while trying to fix this bug. Am I getting too paranoid Anyone seeing the situation differently I ll happily provide a fix for CVS HEAD though. OlegYou know the code much better than I do. I ll trust your judgement and therefore have no objection to seeing this fix in 2.1. Thanks MohI do not favour a 2.0 patch either as I am pretty sure you can easily handle this situation outside HttpClient by catching the exception and forceClose the connection.So how can somebody close a connection if he cannot get the ConnectionObject without restructuring the whole code I m only using the executeMethod -method and i don t see any way of getting the HttpConnection-object that s used. Your suggestion would also workaround my HttpClient finished downloads even if there are gigabytes to download -problem too. But after all it s still a workaround.Sven that was my problem exactly. Currently my workaround is to subclass the method and add the try catch blocks in the writeRequest method. At that point the connection is available. Mike what exactly is forceClose The only reference I see to it are a couple of test cases that send Connection close headers which is not appropriate in this case. Thanks MohMohammad Your strategy is absolutely correct subclass PostMethod provide try catch block in execute method call HttpMethodBase setForceCloseConnection true or and simply close the connection that you get as a parameter to the method. OlegI agree this is something that we should add. As for where to add it I m not sure. We should definitely take care of it in CVS HEAD but I m wondering if we should include the connection.close as part of HTTPCLIENT-302. My thinking being that if we re releasing the connection anyway what harm will closing it cause    Like Oleg though I m quite wary about changing this so late. I suggest we come up with a patch quickly that we can test in the next few days. If after a few days of testing we feel confident that all is working we should include it in rc3. If we have any trouble the change should be backed out and left until after 2.0 final. How does everyone feel about this For Moh s workaround I think calling connection.close is probably better than setting via HttpMethodBase setForceCloseConnection true . Setting forceClose only closes the connection after the response body has been consumed. MikeThe patch for the HTTPCLIENT-302 should have taken care of this one too. Oleg
