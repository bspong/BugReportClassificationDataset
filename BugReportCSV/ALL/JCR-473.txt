Some enhancements to jackrabbit commons
I would like to suggest a couple of enhancements to the commons module. The patch was created against rev. 417443 and the tests did not reveal any problems. Summary of suggestion modifications QName - reduce QName to its core functionality and put conversion from and to JCR name to   a separate class NameFormat - in order not to break existing code all methods that deal with the conversion in QName   are marked deprecated. - add constant for the name of the root node. Path - reduce Path to its core functionality and put conversion from and to JCR path to   a separate class PathFormat - in order not to break existing code all methods that deal with the conversion in Path   are marked deprecated. - introduce new constants for UNDEFINED INDEX 0 and DEFAULT INDEX 1 that    are currently hardcoded throughout the jackrabbit project. - new method Path.getElement int PathElement - make PathElement constants public used by PathFormat Path.PathBuilder - additional constructor PathBuilder Path Path.PathElement - add PathElement.getNormalizedIndex that always asserts a 1-based index. - change subclasses to be private no usage within the jackrabbit except inside Path . PathMap - move o.a.j.core.PathMap to o.a.j.util.PathMap in order to make it available in the   commons module. NamespaceResolver - add methods for resolution of paths     getQPath String jcrPath Path     getJCRPath Path qPath String NamespaceListener - add method namespaceRemove String ValueHelper currently JCR value objects are manually created in the ValueHelper despite the fact that JSR170 defines a ValueFactory interface. Consequently the ValueHelper present in the commons module can only be used by implementations that use the same value implementations. - add new helper methods that take a ValueFactory as argument. - in order not to break existing code the original methods are marked deprecated and   may be removed at a later time. consequently - modify signature of InternalValue.create that include a value conversion to take a   ValueFactory param and adjust all usages inside the core package. ValueFactoryImpl - createValue String int used to call the conversion on ValueHelper. with the    changes suggested to ValueHelper the code must be changed in order to    created instances of the Value implementations within the factory. - together with the modification to ValueHelper stefan suggested to replace the public   constructor with a static getInstance method. All usages within jackrabbit.core were    modified accordingly. Text - add getName String boolean where the boolean flag indicates whether a trailing slash    should be ignored. - add getRelativeParent String int boolean where the boolean flag indicates whether a   trailing slash should be ignored. 1 I especially like the approach of separating responsibilities from QName and Path. Would it make sense to go even further along this way like this     public class QName implements ...         public String getNamespaceURI         public String getLocalName          and the Object and Comparable overrides          public class Path implements ... ...     public interface NamespaceResolver         String getURI String prefix throws NamespaceException         String getPrefix String uri throws NamespaceException          public interface QNameResolver         QName getQName String jcrName throws NameException         String getJCRName String qName throws NameException          public interface PathResolver         Path getPath String jcrPath throws PathException         String getJCRPath Path path throws PathException      1 This separation of concerns would for example make it possible to implement QName or Path caches as independent and easily composable classes. regarding interfaces for Path QName i used to have interfaces for them and keep the implementation in commons. but i felt that the impact on the existing jackrabbit code would be too big. in addition i did not see enough benefit of this approach for the jackrabbit project. but i might be wrong.... regarding split of NamespaceResolver perhaps it s worth taking a closer look at this. at first glance it looks a little exaggerated to me. in any case and as long as nobody objects i would prefer applying the patch as is and discuss additional enhancements in a separate thread. having a patch that shows the impact of a modification makes it easier to decide about the benefits or drawbacks . kind regards angelaAngela regarding interfaces for Path QName Ah sorry for being a bit unclear. I d still keep them as concrete classes preferably final. regarding split of NamespaceResolver perhaps it s worth taking a closer look at this. at first glance it looks a little exaggerated to me. in any case and as long as nobody objects i would prefer applying the patch as is and discuss additional enhancements in a separate thread. having a patch that shows the impact of a modification makes it easier to decide about the benefits or drawbacks . Agreed sorry for muddying the water. 1 to this patch. I ll see if I can come up with compelling enough rationale for the extended proposal and follow up on the mailing list later on. 1 for applying the patch cheers stefan consequently - modify signature of InternalValue.create that include a value conversion to take a ValueFactory param and adjust all usages inside the core package. i don t like the ValueFactory passed all over the classes. this is only because InternalValue now needs it. either we pass the namespace resolver or the value factory but not both. especially since the internal value is an internal representation of the value and should actually have nothing to do with the string- name path conversion. we should find something nicer. for example drop the to methods that take the nsresolver create Value value NamespaceResolver nsResolver is only used 6 times create Value value int targetType NamespaceResolver nsResolver is used 11 times. create String value int targetType NamespaceResolver nsResolver is used 8 times. and put them to the valuehelper. in this case the caler has to deal with it and not the InternalValue. -1 for applying this patchInternalValue we should find something nicer. for example drop the to methods that take the nsresolver maybe i m missing your point. from my point of view the NamespaceResolver is a different story than Value-conversion. While the NamespaceResolver is always used to build a qualified value from a JCR Value for Name and Path values the value conversion takes place if the create methods specifies a targetType which may differ from the type of the passed String or Value. the conversion helper methods are offered by the ValueHelper but currently the ValueHelper itself knows about which value objects to create and i would argue that this should be done by the ValueFactory only. i guess this was the point of the ValueFactory in jsr170 which was introduced quite a while after the initial version of the spec. moving the InternalValue.create to the ValueHelper looks strange to me - the InternalValue is a core functionality and named internal - the ValueHelper is a utility class only and in the commons module. - moving the IV-create methods to ValueHelper would require the InternalValue to become a common one. - and last it would not solve my point that the ValueHelper should not know about the Value implementations. So not passing the ValueFactory throughout the code could be solved by - don t deprecate InternalValue.create Value String int NamespaceResolver - remove the new methods in InternalValue that take the ValueFactory - in any case directly use ValueFactoryImpl within InternalValue such as in the patch in order to retrieved a converted jcr value from the ValueHelper. Since currently ValueHelper creates Value objects itself in addition to the ValueFactoryImpl and from the same value implementations see above this would not change the resulting InternalValue... i simply didn t like that the InternalValue knows which ValueFactory to use. but maybe i m wrong... would that be acceptable for you 2. So not passing the ValueFactory throughout the code could be solved by - leave InternalValue as proposed in the patch - remove usage of InternalValue.create String int ValueFactory and InternalValue.create Value int ValueFactory and replace it by the original call whereever the ValueFactory was not accessible before.... means everywhere except in PropertyImpl and NodeImpl. i had this during an intermediate stage since i didn t want to touch too much core classes. whatever you like jukka you re right. ValueFactory has nothing to do with resolving names. moving the InternalValue.create to the ValueHelper looks strange to me this was just a first ides but you re right. i didn t thought of moving the create methods to the value helper in commons but to somewhere in code. the InternalValue is a internal abstraction of values and has nothing to do with jcr Values. Maybe if we look at it as an InternalValueFactory. so we can leave them there. If it s just for the sake for not having duplicate conversion code we can also use static methods in the ValueFactoryImpl. i would put all convertion code into ValueHelper and ValueFactoryImpl and InternalValue can then make use of it. sorry. i m a bit dizzy today - this was just a first ides but you re right. this was just a first idea but you re right. - somewhere in code. somewhere else in core. Tobias jukka you re right It was Angela credit where credit is due. - I think you re right about questioning the excessive passing of parameters around. We should encapsulate the functionality somehow but I don t think that any of the quick solutions are very clean design-wise. Unfortunately I don t have any better ideas at the top of my head. - a bit i m angela not jukka... unfortunately i would put all convertion code into ValueHelper and ValueFactoryImpl and InternalValue can then make use of it. the conversion is in fact done by the ValueHelper. this did not changed by the patch. what changes with the patch is - ValueHelper does not create the various JCR value object instead it delegates this to the ValueFactory. - ValueFactoryImpl ValueFactory.createValue String value int type does   not call the ValueHelper any more. Instead it creates the value objects on its own. - the reason this is again that i think that ValueHelper should not know which JCR values to create. this is what the ValueFactory has been designed for. you are right that currently the InternalValue is both an internal abstraction and factory. however i tried to fix the problem i considered to be present with the ValueHelper without changing the basic design of core functionality. This would definitely be a different issue. maybe you can take a look at my suggestions regarding your original commont tomorrow or next week whenever you feel fine again. if you generally disagree regarding the issue with the ValueHelper i d say this a different story than if you feeling uneasy with the modifications in core classes. and for the latter modifications within core classes i suggested 2 solutions from the top of my head because i was thinking about this before . if you want me too i can take a look at the code again. there will be many others.... Tobias jukka you re right It was Angela credit where credit is due. - but i ment jukka . it was a response to your post - - ValueFactoryImpl ValueFactory.createValue String value int type does not call the ValueHelper any more. Instead it creates the value objects on its own. but it must possible to have both. imo there is a convertion from string type - Value string type - Internal-Value-Object where the first needs a value factory and the second the namespace resolver. internal value only uses the second. IMO this can be all solved in the ValueHelper. btw can we do 2 patches one with the valuestuff and one with the QName Path stuff i think we all agree on the later.Tobias but i ment jukka . it was a response to your post - Ah OK. Just got confused as I didn t mention anything about ValueFactories before my previous comment. btw can we do 2 patches one with the valuestuff and one with the QName Path stuff 1 Regarding QName... Did anybody consider to require JAXP 1.3 available as seperate download for JDK 1.4 and just to use javax.xml.namespace.QName Yes I did but the JCR QName are different from an XML QName. E.g. in JCR you may start a name with a digit which is not possible in an XML name.Tobi but i ment jukka . it was a response to your post - i guess you responded to a post which gmail considered to be written by jukka... heh....they start getting subversive... it was me. btw can we do 2 patches one with the valuestuff and one with the QName Path stuff we do you mean jukka again or angela before i spent a lot of time creating and testing 2 patches i d like to get an answer to my questions. are you concerned about the changes in the core a or do you disagree regarding the issue i keep pointing out with the ValueHelper b a - i d rather find a solution for this than creating 2 patches. 2 proposals are already available. and we may find some more. b - tjo...Julian Did anybody consider to require JAXP 1.3 available as seperate download for JDK 1.4 and just to use javax.xml.namespace.QName The XML QName is slightly different from the JCR QName. Unlike in XML the JCR prefix is not an inherent part of the QName and the set of allowed local names is different. Of course these differences are nothing major but add to the cost of requiring another external dependency. So I prefer to keep the Jackrabbit-specific QName. Julian Reschke commented on JCR-473 Regarding QName... Did anybody consider to require JAXP 1.3 available as seperate download for JDK 1.4 and just to use javax.xml.namespace.QName of course i looked at the various QName classes but none of them filled the bill. the XML QName is very similar to jackrabbit s QName but there are significant differences. jr s QName is e.g. not interested in the prefix it only stores the ns uri. a JCR localname has a different syntax than an XML NCName. btw the license of the JAXP 1.3 RI sun s CDDL is AFAIK not compatible with the apache license. i guess you responded to a post which gmail considered to be written by jukka... heh....they start getting subversive... it was me. hmmm....now when i look at the posts again...sorry for this confusion - jukkangela - btw can we do 2 patches one with the valuestuff and one with the QName Path stuff we do you mean jukka again or angela the patchmaster i.e. you angela - before i spent a lot of time creating and testing 2 patches i d like to get an answer to my questions. are you concerned about the changes in the core a or do you disagree regarding the issue i keep pointing out with the ValueHelper b as i said   i don t like the valuefactory in the internalvalue. there is not need for it there. thats all of my concern. i agree with all the rest that ValueHelper should be in commons and that it should use ValueFactory.attached a new patch that reverts the modifications made to InternalValue and the modifications within the core nodetype and core xml packages that resulted from them . I.e. revert InternalValue.create Value int NamespaceResolver and InternalValue.create String int NamespaceResolver which both need a value conversion to its original form and remove the additional methods taking ValueFactory as additional param. You tobi stefan may still discuss together whether the InternalValue should implicitely perform any value conversion or not and whether there exists a smarter solution for this. I would avoid fundamental reworking in the core with this patch. If we reached consensus about the enhancements i proposed for the commons module i would apply the patch. regards angela aka jukka note i let the tests run again having the new patch applied same rev. as before and no failures occured that were not present in the untouched checkout being testRemoveVersion and testMultiValue. according to stefan these are known issues . besides some javadoc errors the patch looks ok. 1 for patch V2 1 for 2nd patch from me as wellmerged patch into the latest revision. completed at revision 420449 i will adjust all deprecated calls....oh. i can help you if you want me to. apart from the deprecated calls it would be nice to have all the hardcoded index 0 1 the depth and the name of the root-node replaced by the corresponding constants. i didn t do that in order to keep the patch as small as possible. regarding deprecation maybe QName.toJCRName and fromJCRName can be replaced by the corresponding namespace resolver calls. this might be better than the NameFormat calls since the resolvers may have caches. similar for paths. QName.toJCRName and fromJCRName can be replaced by the corresponding namespace resolver calls. currently i avoided this since IMO the namespace resolver has nothing to do with parsing formatting QNames and Paths. this should be hidden transparently in the NameFormat. i resolved the deprecations as follows QName.create - NameFormat.parse QName.toJCRName - NameFormat.format QName.checkFormat - NameFormat.checkFormat Path.create path ns false - PathFormat.parse path ns Path.create path ns true - PathFormat.parse path ns .getNormalizedPath Path.create parent path ns false - PathFormat.parse parent path ns Path.create parent path ns true - PathFormat.parse parent path ns .getCanonicalPath Path.toJCRPath - PathFormat.fomat Path.checkFormat - PathFormat.checkFormat ValueHelper.convert value type    - ValueHelper.convert value type ValueFactoryImpl.getInstance 
