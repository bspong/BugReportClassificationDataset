MultiThreadedHttpConnectionManager does not properly respond to thread interrupts
MultiThreadedHttpConnectionManager uses interrupts to notify waiting threads when a connection is ready for them. Issues arise if the threads are interrupted by someone else while they are still waiting on a thread because doGetConnection does not remove the threads from the queue of waiting threads when they are interrupted                         connectionPool.wait timeToWait                          we have not been interrupted so we need to remove ourselves from the                          wait queue                         hostPool.waitingThreads.remove waitingThread connectionPool.waitingThreads.remove waitingThread                      catch InterruptedException e                          do nothing finally                         if useTimeout                             endWait System.currentTimeMillis                             timeToWait - endWait - startWait Under ordinary circumstances the queue maintenance is done by the notifyWaitingThread method. However if the thread is interrupted by any other part of the system it will 1 not actually be released since the loop in doGetConnection will force it back to the wait and 2 will be added the waiting thread to the queue repeatedly which basically means that the thread will eventually receive the interrupt from notifyWaitingThread at some later point when it is no longer actually waiting for a connection. This code could probably be re-architected to make it less error-prone but the fundamental issue seems to be the use of interrupts to signal waiting threads as opposed to something like a notify.Hi John I would agree using object notification is probably a cleaner way to do this. I m not sure why I did it this way originally simplicity perhaps. My question is if interrupting a waiting thread outside of the connection manager is something we want to support. If we did would we just throw a ConnectionPoolTimeoutException when it occurs This would seem to break the contract of doGetConnection. I m not sure how we will handle HttpConnection getConnection HostConfiguration hostConfiguration without an API change. Assuming we did want to change this we would need to wait on the HostConnectionPool instead of the ConnectionPool. Doing this brings up a couple of potential issues but I think they re all fixable. In particular  - We would have two layers of synchronization to go through ConnectionPool and HostConnectionPool and would need to handle this carefully to avoid potential dead-locks race conditions etc.  - We lose the FIFO nature currently guaranteed to waiting threads. Object.notify makes no guarantees about which thread will be woken first. To get this into 3.1 we will definitely want to have an RC release with this change first. Given the complexity of synchronization I would want to give it some time for testing. Any other thoughts MikeI did a little more digging on this last night and have narrowed down our choices for correctly responding to external interrupts  - Change from using interrupt to ConnectionPool.wait and ConnectionPool.notifyAll . This would allow us to correctly identify interrupts and handle them appropriately. There are two downsides however. 1 We lose the FIFO nature of the waiting threads. 2 We significantly reduce the performance of the ConnectionPool since all threads would have to be notified on any connection release.  - Switch to nested locking one for the connection pool and another for the individual host pools. This would allow for finer grained control of waiting threads. Again there are downsides. FIFO would be lost. Also given the inherent limitations of Java monitors the only way to correctly implement this would be with mutexes. Since we re not using 1.4 we would have to implement these ourselves.  - The third option is to create a way to determine who interrupted the waiting thread the connection pool or some other thread. We could then cleanup appropriately and re-throw the InterruptedException if we want. The only issue here is that I don t see a foolproof way to do this. If a waiting thread were interrupted by the connection pool and then again by an external thread before it resumed processing it would not be able to accurately tell who interrupted. I m assuming this is a fairly rare occurrence but it could technically still happen.  - The fourth option is to ignore external interrupts and fix the bug where they corrupt the internal state of the ConnectionManager. At this point my preference is for either 3 or 4. Does anyone see a better way to go MikeHere s a quick patch to resolve the bug. It doesn t address the question of what to do about re-throwing the external interruption but that s more of a question of if how we want to make an API change. MikeHi Michael I appreciate the quick response and follow-up. In the longer term I at least would lobby for a re-throw of the interrupt. My application is a high-load highly concurrent system where we need the ability to interrupt threads if they have been working too long. NB a HUGE help to us would be an HttpClient that uses NIO but I realize that s pretty out there. I agree however that the FIFO feature is quite desireable. You could use a fair lock but that obviously has negative performance side-effects perhaps FIFO could be optional and is another component that would have to be built from scratch unless you mandate Java 5.0 . Thanks JohnHi Mike I think this is as good as it gets for HttpClient 3.1. As far as InterruptedException caused by an external interrupt is concerned we can t simply re-throw it. I see two options here. Both are quite ugly so alternative ideas are very welcome 1 Quietly shutdown the connection manager. At the end of day this is likely to be the main reason for interrupting the connection manager s thread in the first place. 2 Re-throw InterruptedException as an exception derived from ConnectionPoolTimeoutException yes I know OlegI would vote against option 1. The connection manager has a shutdown method if that is the desired result. Interrupting a single thread might be done simple for throughput maintenance.Hi all one more alternative which Mike already mentioned on the dev list 3 Re-throw InterruptedException as a RuntimeException for example IllegalThreadStateException I m also for re-throwing and a RuntimeException would make sure that this doesn t trigger application code explicitly handling the ConnectionManagerTimeoutException exception. Yes it s an API change but one that only affects the application in situations where MTHCM would be screwing up. Applications that work correctly now will work correctly despite the change and applications that fail because of the RuntimeException will be better off than before where they would fail in some unpredictable way because of the corrupted state in MTHCM. That we can t reliably tell whether there is an external InterruptedException or not can t be helped. If the thread was interrupted just after getting the connection it would simply return with the connection and have it s interrupted flag set. I don t see a problem with keeping this behavior if two interruptions occur in quick succession. cheers   Roland This one fixes a small bug in the previous patch adds the IllegalThreadStateException and includes a test case. If there are no objections I will apply this in the next few days. MikeLooks good to me OlegHi Mike please declare the interruptedByConnectionPool attribute volatile. Otherwise it looks like a straightforward fix for the problem. cheers   Roland HttpClient is the only component existing in 3.1.Patch appliedHi group I need to know what problem Can I have with this extract org apache commons httpclient MultiThreadedHttpConnectionManager Connect ionPool 0x00000000408C3638 0x00000000408C3644 unowned Waiting to be notified     WebContainer 0 0x0000000031B71C00     WebContainer 1 0x0000000031AE6700     WebContainer 2 0x0000000031E22900     WebContainer 3 0x000000003202AF00     WebContainer 5 0x0000000031CCDB00     WebContainer 6 0x0000000032294B00      ..................       WebContainer 55 0x0000000032620000       WebContainer 56 0x000000003266F200       WebContainer 58 0x000000003267CE00       WebContainer 59 0x000000003267DE00                                                                          WebContainer 0 J9VMThread 0x0000000031B71C00 j9thread t 0x000000011A85AD40 java lang Object.wait Native Method                                                                          java lang Object.wait Object.java 196 Compiled Code org apache commons httpclient MultiThreadedHttpConnectionManager.doGetConnectin org apache commons httpclient MultiThreadedHttpConnectionManager.getConn org apache commons httpclient HttpMethodDirector.executeMethod HttpMetho org apache commons httpclient HttpClient.executeMethod HttpClient.java 3 org apache commons httpclient HttpClient.executeMethod HttpClient.java 3 com citibank latam sgway service HttpConnectorImpl.doPost HttpConnectorI com citibank latam sgway service HttpConnectorImpl.doPost HttpConnectorI com citibank latam sgway service LegacySgConnector.doPost LegacySgConnec com citibank latam sgway service LegacySgConnector.authenticateFull Lega com citi acam session impl SGTokenGenerator.getToken SGTokenGenerator.ja com citi acam session ACAMCredential. init ACAMCredential.java 24 Compi com citi common transaction web CtrlLogin.actionSetLogin CtrlLogin.java com citi common transaction web CtrlLogin.doPost CtrlLogin.java 67 Compi Can you help me please Can be MultiThreadedHttpConnectionManager don t properly respond to thread interrupts 
