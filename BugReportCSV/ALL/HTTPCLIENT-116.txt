Request Response race condition when doing multiple requests on the same connection.
If one tries to do multiple request over the same socket connection a race condition occurs in the input output streams. eg. Some request - HTTP 1.1 200 OK - Some Headers - - The body. Next request - HTTP 1.1 200 OK - More Headers - - Some data. If the second request is sent but the second response isn t yet received before the client starts to try to read it it ll get a org.apache.commons.httpclient.HttpRecoverableException Error in parsing the status line from the response unable to find line starting with HTTP exception it will think The body. is part of the second response . The following code will reproduce the problem import java.io. import java.net. import java.util. import org.apache.commons.httpclient. import org.apache.commons.httpclient.methods. public class HttpClientRaceBug     public static void main String args         try             SimpleHttpServer.listen 8987             HttpClient client new HttpClient             client.startSession localhost 8987             client.getState .setCredentials Test Realm                 new UsernamePasswordCredentials foo bar                          for int i 0 i 100 i                 GetMethod meth new GetMethod                 client.executeMethod meth                       catch Exception e             e.printStackTrace                        private static final class SimpleHttpServer implements Runnable         private Socket socket         public SimpleHttpServer Socket socket             this.socket socket                  public static void listen final int port             Thread server new Thread                 public void run                     try                         ServerSocket ss new ServerSocket port                         while true                             new Thread new                                 SimpleHttpServer ss.accept .start                                               catch Exception e                         e.printStackTrace                                                                             server.setDaemon true             server.start                  public void run             try                 BufferedReader in new BufferedReader new                     InputStreamReader this.socket.getInputStream                                  int len 0                 boolean auth false                 String line                 while line in.readLine null                     System.out.println line                                          if line.trim .equals                         in.read new char len                         doOutput auth                         auth false                         len 0                                               else if line.indexOf -1                         StringTokenizer tok new StringTokenizer line                         String key tok.nextToken .toLowerCase                         if key.equals content-length                             len Integer.parseInt tok.nextToken .trim                          else if key.equals authorization                             auth true                                                                             catch Exception e                  private static int count 0         public void doOutput boolean authorized throws IOException             Writer out new OutputStreamWriter this.socket.getOutputStream             count                          String id count 100                  count 10 00 count 0 count count             if authorized                 write out HTTP 1.1 200 OK r n              else                 write out HTTP 1.1 401 Unauthorized r n                          write out WWW-Authenticate Basic realm Test Realm r n             write out Response-Id id r n             write out Content-Type text html charset iso-8859-1 r n             write out Content-Length 17 r n r n             write out My Response id             out.close                  private void write Writer out String text throws IOException             System.out.print text             out.write text               According to Adrian the issue causing this bug has been fixed. The test code included by the orginator of this bug runs with the correct sequence of authorization challenges and authentication responses. However there is still an unexplained HttpRecoverable exception when writing the request not when reading from it that should be investigated org.apache.commons.httpclient.HttpMethodBase processRequest INFO Recoverable exception caught when writing request GET HTTP 1.1 Host localhost 8987 User-Agent Jakarta Commons-HttpClient 2.0alpha2 HTTP 1.1 401 Unauthorized WWW-Authenticate Basic realm Test Realm Response-Id 199 Content-Type text html charset iso-8859-1 Content-Length 17 My Response 199 Feb 5 2003 1 54 30 AM org.apache.commons.httpclient.HttpMethodBase processRequest INFO Recoverable exception caught when writing request GET HTTP 1.1 Authorization Basic Zm9vOmJhcg Host localhost 8987 User-Agent Jakarta Commons-HttpClient 2.0alpha2 HTTP 1.1 200 OK WWW-Authenticate Basic realm Test Realm Response-Id 200 Content-Type text html charset iso-8859-1 Content-Length 17 My Response 200 I ve encountered this bug in 2.0a2 and in the nightly from today 02 13 03 and It s a bigger bug than it seems My conf I m using a MultiThreadedConnectionManager to make lots of request towards one server. Each time I need a connection I use the getConnection hostConfig and execute the method using the connection. I always do a releaseconnection in my try - finally to be sure the connection is really closed. With an old nightly around may 2002 using HttpMultiClient and its connectionmanager everything was right. With the new release and the nightly everything goes fine if requests are made one after the other. If two requests are made simultaneously I have many many exceptions of this kind java.lang.IllegalStateException Connection is not open at org.apache.commons.httpclient.HttpConnection.assertOpen HttpConnection.java 1019 at org.apache.commons.httpclient.HttpConnection.readLine HttpConnection.java 896 at org.apache.commons.httpclient.HttpMethodBase.readStatusLine HttpMethodBase.java 1898 at org.apache.commons.httpclient.HttpMethodBase.readResponse HttpMethodBase.java 1704 at org.apache.commons.httpclient.HttpMethodBase.processRequest HttpMethodBase.java 2304 at org.apache.commons.httpclient.HttpMethodBase.execute HttpMethodBase.java 957 and sometimes I also have the INFO Recoverable exception caught when writing request it depends. I ll try to make a testcase this afternoon to reproduce it cause here all I do is open many browser and refresh them I m afraid this bug isn t over yet.Created an attachment id 4858 To reproduce the bug of handling multiple connections and multiple simultaneous requests to same host I created an attachment to reproduce the bug. If I understand well how works HttpClient this attachment should always end. Sometimes it simply blocks waiting for a connection even if I did the releaseconnection at the end of my getmethod sometimes it throws exceptions saying connection isn t open... I personnaly have to go back to my nightly that used HttpMultiClient cause this is a major bug for my project my webapp could wait for a connection for ever - It seems that there may be a few things going on. If you could please try the following 1 - change the following line in SimpleRequest.run   aConnection.releaseConnection to   method.releaseConnection 2 - I think there may be something wrong in the implementation of the SimpleHttpServer. Please try running against a real http server. I tried it will Tomcat running locally. After doing these two things I was able to get everything working reliably. Please let me know how things fare for you. Thanks MikeOk I think I ve figured it out. It seems that calling HttpConnection.releaseConnection is inherently unsafe. Connections are used on a per method basis but have no reference to the method they are being used by. Here s a scenario 1 A method A gets a connection from the connectionManager 2 A is executed 3 The response from A is read fully and the connection is implicitly released 4 The released connection is given to another method B 5 Following the execution of A the user code calls HttpConnection.releaseConnection 6 The connection is released again 7 B executes but is using a released connection As you can see the connection was released twice for the method A. Currently there is no way for a connection to know that it has already been released from a particular method. This is not a problem if the HttpMethod.releaseConnection is always used since it knows to only release its connection once. So for a quick fix HttpConnection.releaseConnection should not be used in client code. I ll try to come up with a solution that fixes it but we may just have to remove it from public consumption. MikeThanks a lot Michael now all errors I said before are gone. But I have new troubles about stream being closed that I didn t have with the old httpMultiClient. The fact is my app is parsing the stream XHTML with Xerces parser and I have errors I never add before java.lang.NullPointerException at org.apache.commons.httpclient.HttpMethodBase.responseBodyConsumed HttpMethodBase.java 2438 at org.apache.commons.httpclient.HttpMethodBase 1.responseConsumed HttpMethodBase.java 2466 at org.apache.commons.httpclient.AutoCloseInputStream.notifyWatcher AutoCloseInputStream.java 215 at org.apache.commons.httpclient.AutoCloseInputStream.checkClose AutoCloseInputStream.java 187 at org.apache.commons.httpclient.AutoCloseInputStream.read AutoCloseInputStream.java 123 and above is called by Xerces Parser reading the stream Do you have any idea where it might come from It only happens when doing multiple simultaneous requests. One user is ok... I m still using the nightly from 13 02Ok a quick look at httpmethod.releaseconnection told me if responseStream null      try            FYI - this may indirectly invoke responseBodyConsumed.           responseStream.close So I told to myself well let s remove the releaseconnection method... But it s still there even removing all the releaseconnection ni my code I get this exception when multiple requests are made simultenaously... Thx again for your fast answer and help Created an attachment id 4878 Test MultiThreadedHttpConnectionManager I just attached a test version of MultiThreadedHttpConnection manager. Mind you this code is quite ugly. This seems to have fixed the problem for me. Please give this a shot if you can. MikeCreated an attachment id 4908 Fix patch 1 Patch committed. Please retest and close.Tested CVS today works for me. But now it seems I m encountering HTTPCLIENT-147 about httpclient using 100 CPU http nagoya.apache.org bugzilla show bug.cgi id 16458 I ll explain the trouble there since httpclient seems to continue working but is using 90 CPU after like half an hour of using.I ve retested my webapp using CVS from yesterday evening and I still have many exceptions of this type Error in parsing the status line from the response unable to find line starting with HTTP I compared my new sources to my old ones that were using HttpMultiClient they re identical in term of using httpclient lib. Except the new one is using HttpMultiThreadConnectionManager instead of HttpMultiClient The old one never throws HttpException and in the new one while testing a great number of users using Opensta if I open a browser myself and try to see what happens I sometimes have the exception aboved and sometimes streams are being exchanged one another looks like the original request race bug where a getresponsebodyasstream is not returning the good stream... Do you have a test case that shows this problem The original test you created seems to be working correctly. I have one idea about what might be causing this. It sounds like you are using the getResponseBodyAsStream method. Could you be using this response stream after the method has been released MikeI m currently working on making another test case with aconnectionmanager to keep a pool of connections and a servlet to maintain session cause it seems some requests of my app are made without session in cookies. I m not using getresponseasstream after releasing the connection here is my using try    new Method    method.execute astate connectionmanager.getconnection    work with the stream    return what i have to return catch exception    log it finally    method.releaseconnection Created an attachment id 4970 A new testcase Ok I ve attached a new test case that shows the trouble. I m sorry for the code it s not beautiful but it should work. In fact I m trying to reproduce what I m doing in my webapp in this testcase and the bug shows up so maybe I m doing something wrong I hope I m not... . Here the way it works Multiple simultaneous requests towars a servlet. request are this kind httpclient servlet parameter i I use a global state that I initialize at first to make a session with the servlet All requests have unique i parameter The servlet takes the request if session is valid - returns i else return new session or session not valid As the method knows what it asked it checks if it s what he asked. Yes - do nothing No - print I asked for myuniqueid and got responsebodystring For few requests it goes ok for a lot there are exceptions and then you see errors of not getting the good result you see the http parse exception can t find HTTP ... As I might be doing something wrong please test this case and if I m not doing something wrong could you include it in a real test case I don t know how to do testcase yet Thx AurelienI have tried this new test case but it seems to work fine for me. I m running the servet in Tomcat 4.1.18 and have tried it with 1000 concurrent requests. Does this test fail for you MikeCreated an attachment id 4975 Test case the original problem revisited The original problem the race condition still exists though the reason for it may have changed. Consider this scenario 1 The Method executes using a connection aquired from the SimpleHttpConnectionManager. 2 The response is read until there is no more data i.e. InputStream.read -1 . 3 The connection gets returned to the manager ready to be used again i.e. no sockets streams are closed. 4 A new Method submits a request to an HTTP server using the existing connection. 5 The Method attempts to read the server s response before the server has prepared it its a very inefficient server...not like tomcat 6 The connection s InputStream.read will return -1 and the Method will assume the response is invalid it ll throw the HttpRecoverableException Error in parsing the status line from the response unable to find line starting with HTTP exception . Hopefully my test case will demonstrate this scenario. It can quite easily be fixed by simply waiting for the response before starting to read it. HttpConnection already has a waitForResponse method which could be used although waitForResponse will seriously burn some CPU cycles if not tweeked a little . 6 The connection s InputStream.read will return -1 and the Method will assume the response is invalid.....   This is incorrect. An InputStream will block until the requested amount of data has become available or the connection is closed EOF . See JDK JavaDoc for InputStream .   If the socket is still connected on both ends calling int read on the client end will block until one byte is available. It will only return -1 on EOF.Thanks Sam. You re exactly correct. If I modify my test case server to simply flush its output rather than close it everything works perfectly. It begs the question however should this client fully support HTTP 1.1 servers which don t necessarily maintain a persistent connection The HTTP 1.1 RFC says the servers SHOULD meet this requirement not that they MUST meet it.Ok now I m sure my troubles don t come from this anymore so as I m the one that reopened it I ll close it The following program produces the bug almost always. It uses the util.concurrent package to let 2 threads start simultaneously. I tried the program with the nightly build 20030429 and release 2 Alpha 1. The program is a rewrite of mike.vannoord brainna.com s program. But only the main method has been changed. import java.io. import java.net. import java.util. import org.apache.commons.httpclient. import org.apache.commons.httpclient.methods. import EDU.oswego.cs.dl.util.concurrent.Latch     br   version Revision   public class HttpClientRaceBug Source control revision number public static final String RCS VERSION Revision     public static void main String args         try             SimpleHttpServer.listen 8987             final HttpClient client new HttpClient             client.startSession localhost 8987             client.getState .setCredentials Test Realm                 new UsernamePasswordCredentials foo bar final Latch go new Latch Thread thread1 new Thread 1 public void run try go.acquire GetMethod meth new GetMethod int lState client.executeMethod meth byte aData meth.getResponseBody System.out.println String 1 new String aData catch Exception ex ex.printStackTrace Thread thread2 new Thread 2 public void run try go.acquire GetMethod meth new GetMethod int lState client.executeMethod meth byte aData meth.getResponseBody System.out.println String 2 new String aData catch Exception ex ex.printStackTrace thread1.start thread2.start Thread.sleep 1000L sleep 1s go.release Thread.sleep 3000L sleep 3s          catch Exception e             e.printStackTrace                        private static final class SimpleHttpServer implements Runnable         private Socket socket         public SimpleHttpServer Socket socket             this.socket socket                  public static void listen final int port             Thread server new Thread                 public void run                     try                         ServerSocket ss new ServerSocket port                         while true                             new Thread new                                 SimpleHttpServer ss.accept .start                                               catch Exception e                         e.printStackTrace                                                                             server.setDaemon true             server.start                  public void run             try                 BufferedReader in new BufferedReader new                     InputStreamReader this.socket.getInputStream                                  int len 0                 boolean auth false                 String line                 while line in.readLine null                     System.out.println line                                          if line.trim .equals                         in.read new char len                         doOutput auth                         auth false                         len 0                                               else if line.indexOf -1                         StringTokenizer tok new StringTokenizer line                         String key tok.nextToken .toLowerCase                         if key.equals content-length                             len Integer.parseInt tok.nextToken .trim                          else if key.equals authorization                             auth true                                                                             catch Exception e                  private static int count 0         public void doOutput boolean authorized throws IOException             Writer out new OutputStreamWriter this.socket.getOutputStream             count                          String id count 100                  count 10 00 count 0 count count             if authorized                 write out HTTP 1.1 200 OK r n              else                 write out HTTP 1.1 401 Unauthorized r n                          write out WWW-Authenticate Basic realm Test Realm r n             write out Response-Id id r n             write out Content-Type text html charset iso-8859-1 r n             write out Content-Length 17 r n r n             write out My Response id             out.close                  private void write Writer out String text throws IOException             System.out.print text             out.write text               I think the trouble you have come from the out.close that closes the outputstream instead of simply flushing it... try to change this write out Content-Type text html charset iso-8859-1 r n write out Content-Length 17 r n r n write out My Response id out.close with out.flush see it it works then and close the bug.Unfortunately for the latest poster the default connection manager for HttpClient is not MultiThreadedConnectionManager so of course his alteration with multiple threads fails. If we do anything for this bug it would be that we change the default HttpClient connection manager to the multi-threaded one but that has some potential bad side effects for code apparent lock-ups that does not have the discipline to ensure that releaseConnection gets called for all requests.Perhaps that can be solved by always creating new connections when the pool of connections is empty. That is if it works for a pool. The MultiThreadedHttpConnectionManager must be used for multi-threading to work.  Please take a look at the folowing example http cvs.apache.org viewcvs jakarta-commons httpclient src examples MultiThreadedExample.java rev 1.1 content-type text vnd.viewcvs-markup I am also working on some documentation regarding threading to be added to the user guide. MikeThanks Michael. Using the MultiThreadedHttpConnectionManager works. I did not close the bug because it does not work with the latest build 20030429 . It seems to be an issue with the SimpleHttpServer. I tried this code against Tomcat and Apache running locally and had no trouble. In particular I believe the call to close the output stream at the end of the response is the culprit. Removing this line fixes things. I forget where I read this recently but closing the stream explictly can cause problems. It has something to do with the stream being reset before the data can be read on the client side. MikeIt should be noted that my SimpleHttpServer reports that it is an HTTP 1.1 server but it doesn t support persistant connections. So for future reference anybody who wants to use this code ought to change the output header to HTTP 1.0 or to simply flush the output stream rather than close it.It seems that the problem re-appeared again in my code even with the multi threaded http connection manager . I ll move to using one HttpClient instance per request.     Erik. Erik Simply moving to using multiple HttpClient instances isn t a particularly good option as if this bug is still causing problems other people will eventually run into it. It would be really good if you could take a little time going through the trouble shooting guide at http jakarta.apache.org commons httpclient troubleshooting.html and in particular provide the wire trace log. Also make sure you are using the latest nightly of HttpClient and that you aren t using the SimpleHttpServer that was posted in this thread as it was the cause of the problem last time. Details of your exact setup JRE version server you re using and a specific test case are also invaluable in these situations. While it s quite possible that the bug has been reintroduced most of the people who were seeing this problem are no longer seeing it so that suggest the problem is specific to your configuration and we ll need as much detail to reproduce it as possible. Regards Adrian Sutton.I am sorry for all the fuss I have created so far. Being inspired by Adrian I went into the matter again and found out that the bug was in my own code. Thanks for the support.     Erik. I hate concurrency bugs. I am almost ashamed to mention this again but now we actually use the stuff en mass a problem showed up again.   Unfortunaly turning on the log as described in the trouble shooting did not help. When logging is turned on the bug no longer appears What we do see is a number of broken pipes reported by HttpClient. Why this could be the case is unclear to me. The servlet it is talking to is no where near its maximum capacity. So maybe the problem is no longer a concurreny problem. Here is some information on the configuration - We are using HttpClient from a servlet running in Tomcat 4.1.18 to connect to another servlet running in Tomcat 4.0.3 . The latter is heavilly tested for concurrency. - Both Tomcats run on the same Linux host Red hat 8.0 with an abundance of memory and CPU power - Both Tomcats use the same jdk jdk1.3 06 but run in a different jvm. - We are using the MulitThreadedConnectionManager Do any of the methods fail throwing an exception If so what does the error look like Which version of HttpClient are you using Are you using SSL Is it possible that the methods complete but that errors are being printed internally In normal use connections will time and you will get broken pipe errors but this should be handled internally and retried. Mike
