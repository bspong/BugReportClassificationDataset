JSR 283 JCR Path
with jsr 283 the jcr path is defined to consist of a combination of the following segments • a name segment J I where J is a JCR name and I is an integer index I ≥ 1 . • an identifier segment U where U is a JCR identifier. • the root segment. • the self segment. • the parent segment. - the name segment can be in extended or qualified form - see issue JCR-1712 - the identifier segment is new for jsr283 and always identifies a node - see new method Node.getIdentifier Non-standard parts always need to be standardized. Any of the following makes a path non-standard - expanded name segments - trailing - index 1 Identifier-segments - get resolved upon being passed to any API calls that take path to an existing Node - don t get resolved when being used to create a PATH value object. Except for PATH values all jcr paths returned by the API are normalized and standard thus never identifier-based. PATH values in contrast - must be converted to standard form - must NOT be normalized. i.e. redundant segments and identifiers must be preserved. Initial proposal for the identifier-based path attempting to incorporate that extension into the general path handling used with both jackrabbit-core and jsr2spi. Main goal was to avoid spreading identifier-path handling through the core jcr2spi code but instead having it localized in a single place. This implies from my point of view the following if we want to stick with the current path handling - Normalization of identifier-based paths is defined to be its replacement by a root-based   absolute path which depends on an Session that is able to resolve id to path.   Since the Path object we are having is uncoupled from any Session normalization of   identifier-based paths must occur before the Path object is created. - PATH values on the other hand need to preserve there standard from as entered.   Immediate normalization to the an absolute path consisting of qualified name segments is   not desired not allowed . Which means that the internal representation of the jcr path   must be able to deal with identifier-segments. This lead to the following changes - Path may consist of a single IdentifierElement - Path has additional method denotesIdentifier - Path.Element can be created from an identifier which currently is String and gets a   method to determine if a given element is an identifier-element.   The validation of the id same as with jcr name is left to the parser. - PathParser is extended to handle identifier-based paths upon demand    validation of the format without requirement that the normalization would succeed.    normalization that requires that a Node exists with that identifier. - Introduction of a IdentifierResolver   Used to convert identifier-based paths to a normalized path and validate the validity   of an identifier during parsing. - PathResolver additional method getQPath String jcrPath boolean normalizeIdentifier   that allows to trigger normalization of identifiers before creating the path objects.   the existing method without the flag by default resolves identifier-based path or throws if   no IdentifierResolver present i.e. identifier-based not supported - path syntax invalid - The changes required to make core jcr2spi properly deal with identifier-based paths   where ever normalization is required API calls except for values generation seemed   to be straight forward and very limited ... not included in the patches . Still I came accross of the following issues which I didn t address yet since i wanted to get some input regarding the overall approach before digging into the details here. Issues - In order to properly validate the format of PATH values the ValueFactory will have a   dependency to the implementation that defines the format of the identifiers.   This was straight forward with the ValueFactory present in spi-commons and thus with   jcr2spi that consistently uses the ValueFactory defined on the Session object. - In jackrabbit-core the session s valuefactory is rarely used. Instead instance   of the jcr-commons ValueFactory are used which is neither enabled to standardize   expanded name-segments nor able to deal with identifiers. - In the InternalValue the Value objects are even created directly without make use of   any ValueFactory... this seems to cause troubles in contrast to jcr2spi where all   jcr and internal values are handled created by the factories exposed by the Session. Notes about the identifier path elements - I first thought about forcing the identifier-element be constructed from an ItemID   instead of a simple String but dropped that again... for simplicity of the initial proposal...   and because I wasn t totally convinced if it would be any beneficial. The tests included in the 3rd attachement are just for completeness TCK and to have them saved away. Failing at the moment due to missing functionality in core jcr2spi. angela Value handling in jackrabbit-core I spent some time with the issues listed above and came to the conclusion that we should take a similar approach as in jcr2spi Instead of using the commons ValueFactory and creating the Value objects manually in the InternalValue the jackrabbit-core should have it s own ValueFactory implementation that creates value objects directly based on the InternalValue. With some minor effort this could be based on code already present in spi-commons ValueFactoryQImpl QValueValue created by Julian some time ago which would be beneficial for the conversion from JCR-value to InternalValue and vice versa... those are already used within jackrabbit-core query-row somewhere. I will prepare a patch and upload it here as soon as possible. Patch for jackrabbit-core containing the following modifications - Session implements the IdentifierResolver interface in order to be able to deal   with identifier based paths properly. - ValueFactory implementation new that always creates jcr-values wrapping an InternalValue - consistently use this factory instead of jcr-commons valuefactory except for those classes   that do not have any relation to a Session . - InternalValue implements QValue - InternalValueFactory new is the QValueFactory used within the jcr ValueFactory - InternalValue.getJCRValue which used to create the JCR value instances directly has been   deprecated and refactored to use the valuefactory. - the ValueFactoryQImpl and QValueFactory used within RowIteratorImpl are replaced   by the ValueFactory exposed by the Session. The former code is only used as fallback. - changes to the Path interface lead to a couple of changes in catch statements. changes to jcr2spi and the spi implementationspatch for SPI SPI-commons and JCR-commons replacing the previous patches for SPI and SPI-commons.Hi A few remarks about JCR-2028 core.patch   try     addPathValue doc fieldName value.getPath    catch RepositoryException e      will never occur    This is very dangerous. Maybe the implementation of addPathValue change and the method sometimes does throw an exception. What about converting the RepositoryException to a RuntimeException instead if value null throw new IllegalArgumentException null value          if USE DATA STORE              return new InternalValue BLOBInResource.getInstance value           I would prefer a NullPointerException in that case. Could this be simplified for example using a method checkNull Or moved the check to the constructor to avoid copy paste - val new Long value - type PropertyType.LONG super new Long value Now that we can use Java 1.5 we should use Long.valueOf ... because it has a cache. Did you overload equals without overloading hashCode That s dangerous it might break hash tables. hi tom thanks for the quick feedback. i ll address the issues you listed above as discussed and check whether the datastore tests that are not executed by default are passing... i will keep you informed.I committed the changes including the those addressing thomas feedback at rev. r772659. Modifications - Implementation for the identifier-based JCR Path see above - Adjusting the value handling in jackrabbit-core in order to allow for expanded names in Name and Path values as   well as for Identifier-based path values see above for a short discussion of the problem - some trivial javadoc fixes not related to the changes made regarding thomas remarks a catching RepositoryException in the BundleBinding rethrown as IOException as some of the other prop type     already did instead of ignoring b handling attempt to create InternalValue from null check moved to the various constructors as discussed     and adjusted the QValue tests accordingly... not yet changed to NullPointerException. c usage of Long.valueOf done in InternalValue and where ever I happen to see it while looking at the diffs and the     other QValues. similarly treated the doubles. d equals hashCode fixed Testing jackrabbit-jcr-test - added 2 test classes NameTest and PathTest that cover the basics of the various variants of jcr names and jcr paths - TODO add more sophisticated tests jackrabbit-core - jackrabbit-core tests including api test pass with datastore enabled and disabled - i added some initial tests for InternalValue and the corresponding factory jackrabbit-spi2jcr - the api test for path handling still fail for Node.getIdentifier is not yet implemented. jackrabbit-spi - added QValueTest jackrabbit-spi-commons - added test for ValueFormat. currently only a single test regarding the changes made. this was path values   are never meant to be normalized before being stored in the content. - added various tests for the changes made to Path PathFactory PathParser and PathResolver for the handling   of identifier based path TODO - PathParser stills needs some trivial adjustments as the list of illegal characters in JCR names changed marked with   TODO in the code - added a couple of TODOs where I saw room for improvement or wasn t sure. Up to now InternalValue s behaviour was not covered by test cases. Therefore the changes made may introduce bugs that were not detected by the existing tests... though i obviously tried to avoid that - . For this reason and due the remaining TODOs I will keep this issue open...rev. 779624 resolved TODO regarding illegal character handling
