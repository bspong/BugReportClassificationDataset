DirectoryTaxonomyReader.refresh misbehaves with ref counts
DirectoryTaxonomyReader uses the internal IndexReader in order to track its own reference counting. However when you call refresh it reopens the internal IndexReader and from that point all previous reference counting gets lost since the new IndexReader s refCount is 1 . The solution is to track reference counting in DTR itself. I wrote a simple unit test which exposes the bug will be attached with the patch shortly . Forgot to mention that Doron actually discovered the bug I just had the time to provide the fix . Patch fixes the bug by moving to track reference count by DTR. Also added a test which covers that bug. On the go fixed close to synchronize on this if the instance is not already closed. Otherwise two threads that call close concurrently might fail one of them in decRef . I think it s ready to commit will wait until tomorrow for review. Patch looks good builds and passes for me thanks for fixing this Shai. Few comments CHANGES rephrase the e.g. part like this e.g. if application called incRef decRef . New test LTC.newDirectory instead of new RAMDirectory . text messages in the asserts. DTR Would it be simpler to make close synchronized just like IR.close Would it - again - be simpler to keep maintaining the ref-counts in the internal IR and just in refresh decRef as needed in the old one and incRef accordingly in the new one This way we continue to delegate that logic to IR and do not duplicate it. Current patch removes the ensureOpen check from getRefCount . I think this is correct - in fact I needed that when debugging this. Perhaps should document about it in CHANGES entry. Thanks for reviewing Doron CHANGES rephrase the e.g. part like this e.g. if application called incRef decRef . Will fix thanks. LTC.newDirectory instead of new RAMDirectory I wrote a comment in the test no need for random directories here Ð it s really not related to any Directory. text messages in the asserts. added. Would it be simpler to make close synchronized just like IR.close It would but then it d mean everyone who calls close will wait even if the TR is already closed. The code now is a nice way to only block threads which discover that TR is not already closed. I don t think it s that critical how often do you call close anyway so I don t mind to keep it make the entire method synchronized. Would it - again - be simpler to keep maintaining the ref-counts in the internal IR I think that the code would look odd Ð we ll ir.openIfChanged then call incRef until newIR.getRefCount oldIR.getRefCount . And I m not sure how will that play with someone calling concurrently to DTR.decRef ... it might be a mess. Even though we duplicate ref counting logic I think it s safer but perhaps I misunderstood what you meant Perhaps should document about it in CHANGES entry. I will mention it as well. Patch addresses Doron s comments. Missed that test comment about no need for random directory. About the decRef dup code yeah that s what I meant but okay. I think this is ready to commit. Committed revision 1234450 3x 1234451 trunk . Thanks Doron 
