Remaining reallocation should use ArrayUtil.getNextSize 
See recent discussion on ArrayUtils.getNextSize . Makes sense Actually the patch isn t quite right I think First it just calls ArrayUtil.getNextSize w o passing that to resizeBytes Second it needs to pass lastBytePos MAX BYTES PER INT as the arg to ArrayUtil.getNextSize ie that s the min target size Indeed the patch isn t quite right. I ll fix that and provide another patch. All test cases pass though so I ll also try and add a test case that fails when an allocation larger than the current initial size is needed. The MAX BYTE PER INT has disappeared into an added comment that states a minimum initial size. The underlying problem is that ArrayUtils.getNextSize does not have an argument for a minimum increase. Would it make sense to add that too The code there has some strange constants 3 6 and 9 that could perhaps be dropped when an extra argument for a minimum increase is added. Looking at the comment there for the growth pattern shouldn t the second number after 0 be 3 instead of 4 I ll also try and add a test case that fails when an allocation larger than the current initial size is needed That would be much appreciated I hit that too . The underlying problem is that ArrayUtils.getNextSize does not have an argument for a minimum increase. Would it make sense to add that too Well... the arg to getNextSize is already the minimum size that must be returned so can t you just pass in lastBytePos MAX BYTES PER INT The code there has some strange constants 3 6 and 9 that could perhaps be dropped when an extra argument for a minimum increase is added. Looking at the comment there for the growth pattern shouldn t the second number after 0 be 3 instead of 4 We re working on cleaning up this method under LUCENE-2213. The growth pattern in the comment is in fact correct if you were to call getNextSize on 1 the current size ie this progression getNextSize 1 getNextSize 1 getNextSize 1 ....getNextSize 1 0 Fixed the reallocation to be actually done and added a test case that fails the previous patch because of the missing reallocation. Btw. shouldn t IndexInput.bytes also be reallocated using ArrayUtils.getNextSize The growth factor there is a hardcoded 1.25 . Btw. shouldn t IndexInput.bytes also be reallocated using ArrayUtils.getNextSize 1 Wanna fold it into this patch And any others you find.. . Well it s not that I m searching but I ll provide another patch that includes IndexInput for this. Would you have any idea about testcases for that Patch of 20 Jan also includes use of ArrayUtil.getNextSize for allocation in IndexInput. Small tweaks on the last patch also adding ArrayUtil.getNextSize when allocating the char in IndexInput. Since I missed the second one in IndexInput I used this regex to search the java files in trunk src java new . . and found that these are still suspicious PorterStemmer 85 485 StandardTokenizerImpl 447 ByteBlockPool 86 CharBlockPool 45 MultipleTermPositions 86 TermInfosWriter 210 TermsHashPerField 527 maybe TermVectorsReader 463 472 FastCharStream 58 BufferedIndexInput 61 157 UnicodeUtil 7 times or more. I agree we should cutover these additional places Ð wanna work into the patch Paul I just committed LUCENE-2213 which changes name signature of ArrayUtil.getNextSize.... so be sure to update merge before taking the patch further That was expected. The next patch will be about 5 times bigger so I ll need some more time. Patch of 21 Jan is as anticipated except for the following UnicodeUtil.java last reallocation at line 332 unchanged. FastCharStream.java change might affect speed not included in patch. TermsHashPerField unchanged. BufferedIndexInput unchanged only used by clone in MultiLevelSkipListReader. New iteration of patch attached Recovered the fixes in my first patch Cutover some ArrayUtil.oversize - ArrayUtil.grow We can t change StandardTokenizerImpl.java Ð it s autogen d from JFlex Patch looks good all tests pass. Thanks for simplifying the added testcase. After this I ll post a clean patch at LUCENE-2232 . Thanks Paul 
