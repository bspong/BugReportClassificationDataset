a dead lock in DefaultISMLocking
The jackrabbit 2.2 s org.apache.jackrabbit.core.state.DefaultISMLocking has a defect which will cause a dead lock in concurrent use cases. The use case is as follows 1. Thread A apply a read lock now there is an active reader hold the read lock. 2. Thread B apply a write lock and then thread B will wait for thread A s reading end. You could see below code snippet from the Jackrabbit source. readerCount is the current active reader. writersWaiting while writerId null isSameThreadId writerId currentId readerCount 0                                 wait 3. Thread A apply another read lock then it will wait too since there is a writer is waiting. Then a dead lock happens. while writerId null writerCount 0 isSameThreadId writerId currentId writersWaiting 0                                 wait Since the lock in DefaultISMLocking is global lock so I think if a thread has already hold a reader lock it could get the reader lock again. I create a fix with this idea. a fix to track the readerDo you have a real case of thread A applying for another read lock If yes can you please post a thread dump of the deadlock Such a double-read should never occur so instead of adding code and complexity in DefaultISMLocking which is a very performance-critical component we should get rid of such possible double-reads.The dead lock thread is as follows thread 1148 first time get read lock InternalVersionManagerImpl line 324             second time get InternalVersionImpl line 149 Thread-1148 daemon prio 6 tid 0x4a409400 nid 0x15a0 in Object.wait 0x4d27f000..0x4d27fb94    java.lang.Thread.State WAITING on object monitor         at java.lang.Object.wait Native Method         - waiting on 0x099abc00 a org.apache.jackrabbit.core.state.DefaultISMLocking         at java.lang.Object.wait Object.java 485         at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock DefaultISMLocking.java 92         - locked 0x099abc00 a org.apache.jackrabbit.core.state.DefaultISMLocking         at org.apache.jackrabbit.core.version.InternalVersionManagerBase.acquireReadLock InternalVersionManagerBase.java 196         at org.apache.jackrabbit.core.version.InternalVersionImpl.getSuccessors InternalVersionImpl.java 149         at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl.init InternalVersionHistoryImpl.java 165         - locked 0x03a6d180 a org.apache.jackrabbit.core.version.InternalVersionHistoryImpl         at org.apache.jackrabbit.core.version.InternalVersionHistoryImpl. init InternalVersionHistoryImpl.java 113         at org.apache.jackrabbit.core.version.InternalVersionManagerBase.createInternalVersionItem InternalVersionManagerBase.java 806         at org.apache.jackrabbit.core.version.InternalVersionManagerImpl.getItem InternalVersionManagerImpl.java 329         - locked 0x099abd08 a org.apache.commons.collections.map.ReferenceMap         at org.apache.jackrabbit.core.version.InternalXAVersionManager.getItem InternalXAVersionManager.java 429         at org.apache.jackrabbit.core.version.InternalVersionManagerBase.getVersionHistory InternalVersionManagerBase.java 134         at org.apache.jackrabbit.core.version.InternalXAVersionManager.getVersionHistory InternalXAVersionManager.java 58         at org.apache.jackrabbit.core.version.InternalVersionManagerBase.checkin InternalVersionManagerBase.java 583         at org.apache.jackrabbit.core.version.InternalXAVersionManager.checkin InternalXAVersionManager.java 236         at org.apache.jackrabbit.core.version.VersionManagerImplBase.checkoutCheckin VersionManagerImplBase.java 190         at org.apache.jackrabbit.core.VersionManagerImpl.access 1 VersionManagerImpl.java 1         at org.apache.jackrabbit.core.VersionManagerImpl 1.perform VersionManagerImpl.java 121         at org.apache.jackrabbit.core.VersionManagerImpl 1.perform VersionManagerImpl.java 1         at org.apache.jackrabbit.core.session.SessionState.perform SessionState.java 200         at org.apache.jackrabbit.core.VersionManagerImpl.perform VersionManagerImpl.java 95         at org.apache.jackrabbit.core.VersionManagerImpl.checkin VersionManagerImpl.java 114         at org.apache.jackrabbit.core.VersionManagerImpl.checkin VersionManagerImpl.java 100         at org.apache.jackrabbit.core.NodeImpl.checkin NodeImpl.java 2844         at com.vitria.modeling.repository.sapi.service.jcr.access.JcrAccessUtil.checkin JcrAccessUtil.java 580         at com.vitria.modeling.repository.sapi.service.jcr.JcrLeaveNodeImpl.checkin JcrLeaveNodeImpl.java 54         at com.vitria.modeling.repository.sapi.service.core.CoreModel.checkin CoreModel.java 101         at com.vitria.modeling.repository.sapi.service.core.CoreModel.checkin CoreModel.java 66         at com.vitria.modeling.repository.sapi.service.proxy.local.LocalModel.checkin LocalModel.java 62         at com.vitria.modeling.repository.sapi.usecase.transaction.ModelModifier.action DeadLockTest.java 197         at com.vitria.modeling.repository.sapi.usecase.transaction.AbstractTestThread.run DeadLockTest.java 156 OK thanks See JCR-2828 for an earlier related issue and JCR-2753 for a case where the reentrancy requirement came up earlier. In general I think we shouldn t use DefaultISMLocking as a generic read write lock in InternalVersionManagerBase but I don t have a direct replacement in mind.To follow up on the above the reason why a normal ReentrantReadWriteLock instance isn t appropriate in this case is that the lock needs to be reentrant also for transactions that may span over multiple threads.are you going to give a official fix about it This problem could be encountered easily in our environment.Here s the best quick solution I came up with We ll copy the DefaultISMLocking class into a VersioningLock class for use only by the version manager code. This way we can keep the DefaultISMLocking class clean and focused to just one use case while still leveraging the code and your fix in the version manager. Would you mind preparing a patch like that Why we can not modify the DefaultISMLocking class to allow re-read as it was implemented before changing code not to use oswego code Why we can not modify the DefaultISMLocking class It s a very performance-critical piece of code in highly concurrent and fully cached use cases i.e. a typical web server . See JCR-2699 for the work I did to streamline the synchronized acquireReadLock method as much as possible. Currently the method doesn t allocate any new memory or make any structural changes to any data structures and I d like to keep it that way until we can come up with a way to avoid synchronization. The improved logic in DefaultISMLocking was based on a rather thorough review of the concurrency requirements of the ISMLocking interface. Unfortunately I failed to take into account the fact that the DefaultISMLocking class is also being used directly by the version manager outside the ISMLocking contract. This and the other referenced issues are a result of this. ISM and version locking are really two separate cases with somewhat different requirements which is why I don t think it s a good idea to use a single class for both cases. I ll go forward and implement the idea I suggested earlier about splitting the class into two different copies.It would also be my intention not to use the DefaultISMLocking everywhere as locking class As you mentionent it breaks the ISM contract. It would be great to have sepereted classes to handle the uses cases re-read in a proper way Fixed in revision 1065599 and merged to the 2.2 branch in revision 1065610. The solution I implemented was to take an earlier version of the DefaultISMLocking class from before JCR-2699 and adapt it into a versioning-only read-write lock class. Besides solving the problem this change helps reduce coupling between the o.a.j.core.version and o.a.j.core.state packages.The obvious disadvantage is code duplication. The obvious disadvantage is code duplication. In fact the amount of duplication in this case is pretty small as the two use cases are quite different. In fact I think there are less than ten lines that these two classes have in common.You are right it s not source code duplication sorry. But it s duplicating logic. The two classes do almost the same thing with one small but important difference DefaultISMLocking isn t re-entrant for in all cases is that documented in the source code and was the root cause for this bug and JCR-2753.That crucial difference documented in the ISMLocking javadocs is what makes the design of these two classes so different and what enables the performance optimizations implemented in JCR-2699. By similar logic also the ArrayList and LinkedList classes in java.util are duplicates.Merged to the 2.1 branch in revision 1069811.
