CachingSpanFilter synchronizing on a none final protected object
CachingSpanFilter and CachingWrapperFilter expose their internal cache via a protected member which is lazily instantiated in the getDocSetId method. The current code yields the chance to double instantiate the cache and internally synchronizes on a protected none final member. My first guess is that this member was exposed for testing purposes so it should rather be changed to package private. This patch breaks backwards compat while I guess the cleanup is kind of worth breaking it. This patch breaks serialization because the de-serializer does not call ctors and so the cache keeps unintialized null . Fixed patch. Uwe I m so glad that you are so keen on stuff like Java serialization Thanks New patch. The previous one had the problem that it also blocked during creating the Filter SpanResult. Now it only locks correctly before creating the WeakHashMap at all and when requesting putting entries. The only problem is that two threads may create the same DocIdSet at the same time because of cache miss but that is not a problem at all for correct behaviour. New patch that uses ReentrantLock from Java5 s concurrent package. This lock is serializable. All tests pass will commit soon. Committed revision 833934
