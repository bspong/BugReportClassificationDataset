Deadlock on concurrent commits
As reported in the followup to JCR-1979 there s a case where two transactions may be concurrently inside a commit. This is bad as it breaks the main assumption in http jackrabbit.apache.org concurrency-control.html about all transactions first acquiring the versioning write lock. Looking deeper into this I find that the versioning write lock is only acquired if the transaction being committed contains versioning operations. This is incorrect as all transactions in any case need to access the version store when checking for references.Attached a patch that solves the issue for environments where the transaction manager does not use separate threads for preparing and committing a transaction see JCR-1334 . Support for JCR-1334 requires updating also the version manager lock to support switching the lock ownership from one thread to another.Here s a new version of the patch that solves also the JCR-1334 issues. I ll run some more tests on it before committing to trunk and the 1.5 branch.I still see lockups when running ConcurrentVersioningWithTransactionsTest. We should eventually run those concurrency tests on a daily basis. All that s needed is mvn -Dtest DailyIntegrationTest test Is this kind of daily test possible with our hudson instance Yep I m seeing the same problem. Working on it now. Once solved I ll configure Hudson to periodically run the more extensive integration tests.As far as I can tell the lockups are caused by the test case forcibly terminating long-lived threads. The Thread.stop call does unlock any object monitors the thread has locked but will leave the explicit lock objects locked. The proposed change extends the scope of the versioning lock used in transactions and thus affects the performance of concurrent commits. This is probably the cause of the timeouts of the test case being reached.There are other lockups too. However the test code violates the Don t mix concurrent transactional and non-transactional writes to a single workspace guideline mentioned in http jackrabbit.apache.org concurrency-control.html. I ve disabled the Thread.stop calls and the mixed normal and transactional saves which seems to avoid all the problems. I ll run a bigger randomized test over the night to see whether any problems remain.Yes that seems to have fixed the issues. I ll commit the changes and give people some time to check this out before cutting the 1.5.4 release with the fix. As far as I can tell the lockups are caused by the test case forcibly terminating long-lived threads. I disagree. The tasks in ConcurrentVersioningWithTransactionsTest time out one year in the future. Actually an unreasonable value should be rather in the area of a couple of minutes to make sure the test terminates at some point if a deadlock occurs. RandomOperationTest indeed uses a lower timeout of 60 seconds. If that s a problem we should rather increase that value to e.g. 5 minutes. However the test code violates the Don t mix concurrent transactional and non-transactional writes to a single workspace guideline Hmm I understand but the above mentioned test works just fine in the 1.4 branch. Przemo does you application use XA transactions mixed with regular writes The thread deaths I saw were caused by the RandomOperationTest class killing them. At least in a few cases the threads were still holding on locks which made the test block indefinitely in the cleanup phase after all test threads had been killed. Why do we need the thread killing in the first place A normal join call with no timeout should be fine enough. If there s a deadlock then a manually generated thread dump is much more accurate it contains all the locks held than the stack traces that the test case now dumps. Hmm I understand but the above mentioned test works just fine in the 1.4 branch. The proposed change here extends the scope of the versioning lock acquired in a transaction commit which makes this deadlock A commit - versioning lock - workspace lock B save - workspace lock - versioning lock more likely to happen but the deadlock scenario already existed before it probably just was never triggered due to lucky timing.Attached a patch thread-join.patch that replaces the thread timeouts with an unbounded Thread.join call. Why do we need the thread killing in the first place A normal join call with no timeout should be fine enough Right that would work well when one runs the test on a local machine. I had some build infrastructure in mind where I want a report after the tests finished which means termination must be guaranteed. I think something like the build timeout plugin for Hudson is better for catching runaway CI builds.Ah cool. I didn t know there is something like that...Anyway I don t feel too strongly about the join issue. I suspect that the thread deaths I was seeing earlier were probably caused by an earlier deadlock blocking the threads that then were forcibly killed by the timeout mechanism hiding the original cause of the problem.Applied the patch latest JCR-2000.patch in revision 750011. Merged it and the related test case changes 749953 and 749965 to the 1.5 branch in revision 750013. I ll still run some tests on the 1.5 branch before resolving this as fixed.Hmm I m still seeing some lockups. Investigating...The last problem appears to be an extra synchronization block in LocalItemStateManager which prevents the SearchManager from accessing content when synchronous observation events are received. The relevant parts of the thread dump are Thread-605 prio 10 tid 0xa6d8e400 nid 0xdba waiting for monitor entry 0xa430c000..0xa430cfa0    java.lang.Thread.State BLOCKED on object monitor at org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState LocalItemStateManager.java 153 - waiting to lock 0xad21eda0 a org.apache.jackrabbit.core.state.LocalItemStateManager at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState SessionItemStateManager.java 182 at org.apache.jackrabbit.core.SearchManager 1.nextNodeState SearchManager.java 442 at org.apache.jackrabbit.core.SearchManager 1.next SearchManager.java 435 at org.apache.commons.collections.iterators.TransformIterator.next TransformIterator.java 87 at org.apache.commons.collections.IteratorUtils.toList IteratorUtils.java 829 at org.apache.commons.collections.IteratorUtils.toList IteratorUtils.java 805 at org.apache.jackrabbit.core.query.lucene.SearchIndex.updateNodes SearchIndex.java 588 at org.apache.jackrabbit.core.SearchManager.onEvent SearchManager.java 478 at org.apache.jackrabbit.core.observation.EventConsumer.consumeEvents EventConsumer.java 244 at org.apache.jackrabbit.core.observation.ObservationDispatcher.dispatchEvents ObservationDispatcher.java 201 at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch EventStateCollection.java 447 at org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher.dispatch DelegatingObservationDispatcher.java 127 at org.apache.jackrabbit.core.observation.DelegatingObservationDispatcher.dispatchEvents DelegatingObservationDispatcher.java 99 at org.apache.jackrabbit.core.observation.EventStateCollection.dispatch EventStateCollection.java 447 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.end SharedItemStateManager.java 749 at org.apache.jackrabbit.core.state.XAItemStateManager.commit XAItemStateManager.java 172 at org.apache.jackrabbit.core.version.XAVersionManager.commit XAVersionManager.java 497 at org.apache.jackrabbit.core.TransactionContext.commit TransactionContext.java 206 - locked 0xb3b33ea0 a org.apache.jackrabbit.core.TransactionContext at org.apache.jackrabbit.core.XASessionImpl.commit XASessionImpl.java 346 at org.apache.jackrabbit.core.UserTransactionImpl.commit UserTransactionImpl.java 150 at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest 1.execute ConcurrentVersioningWithTransactionsTest.java 86 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 164 at java.lang.Thread.run Thread.java 619 Thread-604 prio 10 tid 0xa6d8d400 nid 0xdb9 in Object.wait 0xa435d000..0xa435e020    java.lang.Thread.State WAITING on object monitor at java.lang.Object.wait Native Method - waiting on 0xad159240 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at java.lang.Object.wait Object.java 485 at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock.acquire Unknown Source - locked 0xad159240 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at org.apache.jackrabbit.core.state.DefaultISMLocking ReadLockImpl. init DefaultISMLocking.java 96 at org.apache.jackrabbit.core.state.DefaultISMLocking ReadLockImpl. init DefaultISMLocking.java 89 at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock DefaultISMLocking.java 51 at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock SharedItemStateManager.java 1416 at org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState SharedItemStateManager.java 253 at org.apache.jackrabbit.core.state.LocalItemStateManager.getNodeState LocalItemStateManager.java 93 at org.apache.jackrabbit.core.state.LocalItemStateManager.getItemState LocalItemStateManager.java 158 - locked 0xad21eda0 a org.apache.jackrabbit.core.state.LocalItemStateManager at org.apache.jackrabbit.core.state.SessionItemStateManager.getItemState SessionItemStateManager.java 182 at org.apache.jackrabbit.core.HierarchyManagerImpl.getItemState HierarchyManagerImpl.java 150 at org.apache.jackrabbit.core.HierarchyManagerImpl.getPath HierarchyManagerImpl.java 393 at org.apache.jackrabbit.core.CachingHierarchyManager.getPath CachingHierarchyManager.java 229 at org.apache.jackrabbit.core.lock.LockManagerImpl.getPath LockManagerImpl.java 701 at org.apache.jackrabbit.core.lock.LockManagerImpl.getLockInfo LockManagerImpl.java 439 at org.apache.jackrabbit.core.lock.XAEnvironment.getLockInfo XAEnvironment.java 234 at org.apache.jackrabbit.core.lock.XALockManager.checkLock XALockManager.java 184 at org.apache.jackrabbit.core.ItemValidator.checkLock ItemValidator.java 382 at org.apache.jackrabbit.core.ItemValidator.checkCondition ItemValidator.java 305 at org.apache.jackrabbit.core.ItemValidator.checkModify ItemValidator.java 267 at org.apache.jackrabbit.core.NodeImpl.internalAddNode NodeImpl.java 726 at org.apache.jackrabbit.core.NodeImpl.internalAddNode NodeImpl.java 683 at org.apache.jackrabbit.core.NodeImpl.addNode NodeImpl.java 2055 - locked 0xb3be44a0 a org.apache.jackrabbit.core.NodeImpl at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest 1.execute ConcurrentVersioningWithTransactionsTest.java 83 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 164 at java.lang.Thread.run Thread.java 619 I m not sure yet why the SearchManager is accessing a LocalItemStateManager here it should only ever access the SharedItemStateManager instance.The culprit seems to be the system search manager that like LockManager above uses the SessionItemStateManager of the system session for looking up items. The attached patch search-on-sism.patch makes the system search manager use the underlying SharedItemStateManager instance instead of the SessionItemStateManager.The last problem above is a bit outside the scope of this issue so I created JCR-2008 for that and resolved the issue by committed the proposed fix in both svn trunk and the 1.5 branch. Resolving this as Fixed.One more thing detected in a test run I left for the night. The VersionItemStateProvider.hasNodeReferences call inside the scope of a workspace lock conflicts with the versioning lock held by another thread. The conflict can be seen in the following thread dump HOLDS WORKSPACE LOCK WAITS FOR VERSIONING LOCK Thread-577 prio 10 tid 0x0859ac00 nid 0x6e86 in Object.wait 0xa487a000..0xa487af20    java.lang.Thread.State WAITING on object monitor at java.lang.Object.wait Native Method - waiting on 0xad082b20 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at java.lang.Object.wait Object.java 485 at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock.acquire Unknown Source - locked 0xad082b20 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock ReaderLock at org.apache.jackrabbit.core.state.DefaultISMLocking ReadLockImpl. init DefaultISMLocking.java 86 at org.apache.jackrabbit.core.state.DefaultISMLocking ReadLockImpl. init DefaultISMLocking.java 80 at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireReadLock DefaultISMLocking.java 44 at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireReadLock SharedItemStateManager.java 1403 at org.apache.jackrabbit.core.state.SharedItemStateManager.hasNodeReferences SharedItemStateManager.java 350 at org.apache.jackrabbit.core.version.VersionItemStateProvider.hasNodeReferences VersionItemStateProvider.java 142 at org.apache.jackrabbit.core.state.SharedItemStateManager.hasNodeReferences SharedItemStateManager.java 369 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.addReference SharedItemStateManager.java 898 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.addReferences SharedItemStateManager.java 883 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.updateReferences SharedItemStateManager.java 866 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.begin SharedItemStateManager.java 560 at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate SharedItemStateManager.java 1056 at org.apache.jackrabbit.core.state.SharedItemStateManager.update SharedItemStateManager.java 1086 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 337 at org.apache.jackrabbit.core.state.XAItemStateManager.update XAItemStateManager.java 347 at org.apache.jackrabbit.core.state.LocalItemStateManager.update LocalItemStateManager.java 312 at org.apache.jackrabbit.core.state.SessionItemStateManager.update SessionItemStateManager.java 313 at org.apache.jackrabbit.core.ItemImpl.save ItemImpl.java 1105 - locked 0xb0cc9e00 a org.apache.jackrabbit.core.XASessionImpl at org.apache.jackrabbit.core.SessionImpl.save SessionImpl.java 846 at org.apache.jackrabbit.core.NodeImpl.checkout NodeImpl.java 3340 at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest 2.execute ConcurrentVersioningWithTransactionsTest.java 119 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 164 at java.lang.Thread.run Thread.java 619 HOLDS VERSIONING LOCK WAITS FOR WORKSPACE LOCK Thread-571 prio 10 tid 0xa7991400 nid 0x6e80 in Object.wait 0xa4ddb000..0xa4ddbe20    java.lang.Thread.State WAITING on object monitor at java.lang.Object.wait Native Method - waiting on 0xad082c28 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock at java.lang.Object.wait Object.java 485 at EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock.acquire Unknown Source - locked 0xad082c28 a EDU.oswego.cs.dl.util.concurrent.WriterPreferenceReadWriteLock WriterLock at org.apache.jackrabbit.core.state.DefaultISMLocking 1. init DefaultISMLocking.java 55 at org.apache.jackrabbit.core.state.DefaultISMLocking.acquireWriteLock DefaultISMLocking.java 52 at org.apache.jackrabbit.core.state.SharedItemStateManager.acquireWriteLock SharedItemStateManager.java 1419 at org.apache.jackrabbit.core.state.SharedItemStateManager.access 200 SharedItemStateManager.java 116 at org.apache.jackrabbit.core.state.SharedItemStateManager Update.begin SharedItemStateManager.java 547 at org.apache.jackrabbit.core.state.SharedItemStateManager.beginUpdate SharedItemStateManager.java 1056 at org.apache.jackrabbit.core.state.XAItemStateManager.prepare XAItemStateManager.java 156 at org.apache.jackrabbit.core.TransactionContext.prepare TransactionContext.java 154 - locked 0xb0f06868 a org.apache.jackrabbit.core.TransactionContext at org.apache.jackrabbit.core.XASessionImpl.prepare XASessionImpl.java 324 at org.apache.jackrabbit.core.UserTransactionImpl.commit UserTransactionImpl.java 121 at org.apache.jackrabbit.core.ConcurrentVersioningWithTransactionsTest 2.execute ConcurrentVersioningWithTransactionsTest.java 117 at org.apache.jackrabbit.core.AbstractConcurrencyTest Executor.run AbstractConcurrencyTest.java 164 at java.lang.Thread.run Thread.java 619 The VersionItemStateManager already avoids this conflict in the way it overrides the setNodeReferences method but it should do the same also for the get hasNodeReferences methods that are invoked by SharedItemStateManager when persisting normal workspace content. Fixed the last issue as described in revision 750536. Merged the fix to the 1.5 branch in revision 750539. Everything seems good again but I ll schedule another test run over the night to catch any other regressions.
