JCR2SPI remove node operation missing in submitted SPI batch
In JCR2SPI the following sequence of operations seems to lead to an incorrect SPI batch being submitted 1 remove a 2 add a 3 add a b 4 session.save This seems to create an SPI batch where the first remove operation is missing. Note that the problem only seems to occur when step 3 is part of the sequence. Full Java source for test     try       if session.getRepository .getDescriptor Repository.LEVEL 2 SUPPORTED .equals true         Node testnode         String name delete-test                    Node root session.getRootNode                   make sure it s there         if root.hasNode name           root.addNode name nt folder           session.save                            now test remove add in one batch         if root.hasNode name           testnode root.getNode name           testnode.remove            session.save un-commenting this makes the test pass                           testnode root.addNode name nt folder          add one child         testnode.addNode name nt folder commenting this out makes the test pass                  session.save             finally       session.logout               This seems to be non trivial. The code in o.a.j.jcr2spi.state.ChangeLog tries to sanitize the operations but seems to go to far. a statusChanged EXISTING REMOVED- REMOVED removes the Remove operation. b Taking out that code leads to a ConstraintViolation in checkIsSelfContained . c Taking out that check leads to a Batch being submitted which does contain the Remove operation but now another issue becomes visible looking at the sequence of operations again 1 remove a 2 add a 3 add a b The third operation s parent id now refers to the node a that was removed in step 1 and thus will cause a failure in the SPI implementation because that node is gone when step 3 is executed . This requires more research... Angela S. pointed out that the removed node a should be in the attic but isn t. A similar case is a move operation such as 1 move a to a2 2 add a 3 add a b Turns out that this doesn t work either. Test case       if session.getRepository .getDescriptor Repository.LEVEL 2 SUPPORTED .equals true         Node testnode         String name delete-test                    Node root session.getRootNode                   make sure it s there         if root.hasNode name           root.addNode name nt folder           session.save                   make sure target is not there         if root.hasNode name 2           root.getNode name 2 .remove           session.save                            now test remove add in one batch         if root.hasNode name           testnode root.getNode name           session.move name name 2            session.save un-commenting this makes the test pass                           testnode root.addNode name nt folder          add one child         testnode.addNode name nt folder commenting this out makes the test pass                  session.save               This fails with javax.jcr.nodetype.ConstraintViolationException ChangeLog is not self contained. at org.apache.jackrabbit.jcr2spi.state.ChangeLog.checkIsSelfContained ChangeLog.java 364 at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.getChangeLog SessionItemStateManager.java 567 at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.save SessionItemStateManager.java 145 at org.apache.jackrabbit.jcr2spi.ItemImpl.save ItemImpl.java 239 at org.apache.jackrabbit.jcr2spi.SessionImpl.save SessionImpl.java 317 at com.xythos.jcr.NodeCreationRemovalTest.testMoveAddInRoot NodeCreationRemovalTest.java 475 hi julian i tried to reproduce the problem you describe but i don t get neither get a wrong ChangeLog nor a wrong Batch. What i did - starting from both the root-node and the configured testRootNode - adding a nt folder node a and save changes - then remove the node previously created adding new node with same name nt and   an additional child node b nt folder . - and saving all changes. the removed node-state has status EXISTING REMOVED until the save is completed. ChangeLog contains 3 Operations 1x Remove 2x AddNode and all affected states. all Operations are executed on the Batch. similarly the example with the move seemed to work for me. am i missing something my questions to you - were you able to reproduce the problem with the setup from the checkout jcr2spi - spi2jcr - what revision were you using mine 563477 Hi Angela I have tried to repro the bug with the test cases in contrib spi client and failed to do so. So what s different over here The first thing that comes to mind is that in my SPI implementation all Nodes are referenceable and the NodeId returned upon NodeInfo.getId are always built just from the unique id. I just changed that experimentally now always building the Id from an absolute Path and sure enough the tests pass now. So it has to do with the Id format. Does that ring a bell Turns out adding addMixin mix referenceable makes the test fail here as well     public void testRemoveThenAdd throws RepositoryException       Session session testRootNode.getSession       Node testnode       String name delete-test                Node root session.getRootNode               make sure it s there       if root.hasNode name         testnode root.addNode name nt folder         testnode.addMixin mix referenceable         session.save                      now test remove add in one batch       if root.hasNode name         testnode root.getNode name         testnode.remove          session.save un-commenting this makes the test pass                     testnode root.addNode name nt folder       testnode.addMixin mix referenceable        add one child       testnode testnode.addNode name nt folder commenting this out makes the test pass       testnode.addMixin mix referenceable       session.save      ...yields... testRemoveThenAdd org.apache.jackrabbit.jcr2spi.RemoveReferenceableTest Time elapsed 0.015 sec ERROR javax.jcr.ItemExistsException Cannot add child node delete-test to delete-test colliding with same-named existing node. at org.apache.jackrabbit.jcr2spi.state.ItemStateValidator.checkCollision ItemStateValidator.java 594 at org.apache.jackrabbit.jcr2spi.state.ItemStateValidator.checkAddNode ItemStateValidator.java 387 at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.addNodeState SessionItemStateManager.java 610 at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.visit SessionItemStateManager.java 263 at org.apache.jackrabbit.jcr2spi.operation.AddNode.accept AddNode.java 63 at org.apache.jackrabbit.jcr2spi.state.SessionItemStateManager.execute SessionItemStateManager.java 229 the problem was caused upon creating the effective node type for the new replacement node which tried to load the jcr mixinTypes from the persistent storage. consequently the jcr uuid was retrieved with the effects mentioned above. fix in case of a NEW node entry it does not make sense to try to load props child nodes from the persistent storage.Confirming this fixes the problem I saw. Thanks Angela.
