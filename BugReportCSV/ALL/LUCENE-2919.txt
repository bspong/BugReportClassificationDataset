IndexSplitter that divides by primary key term
Index splitter that divides by primary key term. The contrib MultiPassIndexSplitter we have divides by docid however to guarantee external constraints it s sometimes necessary to split by a primary key term id. I think this implementation is a fairly trivial change. First cut. Roughly divides an index by the exclusive mid term given. Patch looks good Jason Sorry for the long delay... I ll commit shortly. One small thing I fixed I think the term.compareTo endTermExcl 0 should be a 0 I would implement this stuff a little bit more flexible You could use a standard Filter to do the split e.g. TermRangeFilter and use its returned DocIdSet as BitSet if Filter returns no BitSet can be checked by instanceof Bits use OpenBitSetDISI as wrapper - like CachingWrapperFilter . This makes it more flexible as this Filter again has some code duplication with the other IndexSplitter but is again very specific. A simple tool let it be an DocumentExtractor could extract parts of a bigger Index using any filter. How about that Too late already committed I will still provide patch tomorrow Here patch that changes PKIndexSplitter to use a Filter of allowed documents. Its yet hardcoded to be a TermRangeFilter but a second flexible version could e.g. also use NumericRangeFilter WildCardFilter or whatever. The test in the committed code had a bug the second half of the index had to contain 1 more document maybe that was the bug Mike mentioned or introduced . The documentation says If the midTerm is in the index its document will be in the second index. I think the test should also be improved to check indexes with deleted documents. Maybe the Filter could automatically be negated by a boolean parameter to the FilterIndexReader s ctor. New patch simplified the Filter logic added option to negate the filter in the IndexReader this enabled use of only one TermRangeFilter and simply negate it for the second pass. made code correctly close using IOUtils.closeSafely Tests are still ugly. Patch looks great Uwe I love how generic it is now that you can just provide any Filter. Here s patch for back-porting original approach to 3.x. I will fix the test and commit this then backport again using your TermPositions. Final patch improved tests changed api to be able to pass arbitrary filter This ready to commit will do this soon as the current trunk is unfortunately broken splits incorrect Committed trunk revision 1137162 Backporting... Patch for 3.x not merged one . Committed 3.x revision 1137166 Thanks Uwe Thanks committing this means I can remove a custom GitHub branch with only this patch. Also it d be great if we somehow published nightly versions to Maven repositories. Though they d accumulate over time. to get the current maven build check https builds.apache.org job Lucene-Solr-Maven-trunk lastSuccessfulBuild artifact maven artifacts Ryan Thanks What would one place as the artifact info into the pom.xml Jason... not really sure what you are asking 4.0-SNAPSHOT https builds.apache.org job Lucene-Solr-Maven-trunk lastSuccessfulBuild artifact maven artifacts org apache lucene lucene-core 4.0-SNAPSHOT maven-metadata.xml bulk close for 3.3 Sorry for the naive off on-topic question. Ryan what s the repository info that needs to be added to the pom.xml so that the project downloads the 4.0 snapshot Eg I don t think it s repository id lucene id url https builds.apache.org job Lucene-Solr-Maven-trunk lastSuccessfulBuild artifact maven artifacts org apache url snapshots enabled true enabled snapshots repository This was exactly what I was looking for FTR for this to work in Lucene 3.1.0 and 3.2.0 only 2 calls to IOUtils.closeSafely boolean suppressExceptions Closeable... objects need to be changed IOUtils.closeSafely success reader - IOUtils.closeSafely reader IOUtils.closeSafely success w - IOUtils.closeSafely w Thanks You should upgrade to 3.5 3.1 and 3.2 contains serious index corru m ption bugs 
