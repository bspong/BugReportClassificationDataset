Improved join query performance
Our current implementation of SQL2 join queries does not perform very well on pretty much any non-trivial data set.I m currently working on this targeting the 2.2 release. The optimization plan I m following is 1. Map single-selector queries directly to underlying Lucene queries like we ve so far done for XPath and SQL1 2. Split join queries into a set of per-selector queries and combine these partial results into the join result set 3. When splitting join queries use the results of the already executed left component query to turn the join condition into an extra constraint for the right component queryWe are seeing this issue also so we would be very interested in the work you are doing. Is there anything already available to test Regards   Serge Huber.If I understand this ticket properly this doesn t only happen for join queries but for all SQL-2 queries no In the first solution do you mean you intend to map the single selector queries along with using BooleanQuery objects to map constraints directly to the underlying Lucene query Anyway I d be willing to help anyway possible as this is become the biggest performance issue we are seeing in testing Jackrabbit with non-trivial data sets and loads. Regards   Serge Huber.Sorry about the delay on this and thanks for the offer to help in testing I ll start pushing my changes to svn now.Thank you for your reply I will pull the changes from SVN test it and give you feedback. I am using another unit test that does a lot of concurrent read writes and searches. Maybe this is something I could contribute but it is not yet generic to Jackrabbit and currently has dependencies t our product. Basically we are testing with larger loads than the currently available tests do. Regards   Serge Huber.Hello Jukka I see you have been committing quite a lot of changes yesterday. Thank you very much I have been looking at the changes. Do you still have more to commit I have some trouble understanding how it works currently as there seems to be no references to the QueryEngine in the code. I m assuming you haven t glued it together yet is that correct or that you will commit this soon Did I miss something Best regards   Serge Huber.Yes I m still working on fixing some remaining issues before I plug the new implementation in as the QueryObjectModelImpl.execute method. I also have some pending work on tighter integrating the new join query code with the underlying Lucene index so we can avoid the extra layer of SQL1 queries that the implementation now uses. For now it s possible to use this implementation by directly instantiating the QueryEngine class like this     QueryObjectModel qom ...     QueryResult result new QueryEngine session .execute             qom.getColumns qom.getSource             qom.getConstraint qom.getOrderings As of revision 1024283 the new join implementation has been hooked up for handling inner equi-joins. Support for other join types still requires more work and I still need to add the tighter Lucene integration.Thanks for all the work I ve tested the QueryEngine and results do indeed seem to be faster although I had an issue I m not sure is due to my code regarding reading results twice. Also concerning limits do they currently work with sorting If I limit to 100 results will it be the sorted 100 first results Or is sorting done after limiting Let me know how I can help Best regards   Serge Huber.Good point about the limits The current code applies limits before sorting which is obviously wrong. I ll fix that.Hi Jukka I just tested the latest commits and it s looking quite good. I only saw 2 tests that don t seem to work yet but I m assuming you re already aware of this EquiJoinConditionTest testInnerJoin1 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest 0.692 testInnerJoin2 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest 0.608 testRightOuterJoin1 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest Detail 0.138 testroot node1 is not part of the result set testRightOuterJoin2 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest 0.09 testLeftOuterJoin1 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest 0.103 testLeftOuterJoin2 org.apache.jackrabbit.test.api.query.qom.EquiJoinConditionTest Detail 0.071 testroot node1 is not part of the result set Best regards   Serge Huber.Hello Jukka I was going over some performance tests and I was wondering if the new code could be used for general SQL-2 queries I noticed that in the QueryObjectModelImpl we have the following check in the execute method             if JCR JOIN TYPE INNER.equals join.getJoinType                      join.getJoinCondition instanceof EquiJoinCondition But in the execution of the query engine we seem to be able to handle non-join cases in an optimized way that delegates back to the SQL-1 implementation. Because it seems that in the case of simple queries like SELECT FROM nt base where CONDITION we are still going through non-optimized code that checks the constraints after loading all the results from Lucene. Best regards   Serge Huber.There are still a few failing TCK tests with the new SQL2 query engine. I ll remove the extra condition from the code once I ve fixed all those tests.Ok nice to know. Do you think this can be done for 2.2.0 Best regards   Serge Huber.Yes I m still targeting 2.2.0 for having this fully resolved.Great Thanks a lot. I ll be away in the next few days but I ll test it as soon as possible.I fixed the last TCK test failures in revision 1039888 and enabled the new implementation for all QOM and SQL2 queries. There s still some minor cleanup documentation and testing to be done but overall the implementation should now be ready for release.See the attached graphs for the achieved performance improvements. That s two orders of magnitude from 1341ms to 10ms for a two-way join and almost as much from 1851ms to 90ms for a three-way join.Resolving as fixed.Great improvements thanks a lot. Did you also test simple non join SQL-2 performance as you also improved this part I wanted to run these tests but as I am traveling I probably won t be able to do so until next week. Best Regards   Serge Huber Yes also non-join SQL2 query performance is now significantly better. The attached SQL2SearchTest graph shows the performance of a simple non-join SQL2 query that selects 100 nodes out of a set of 10k nodes using a simple property constraint. The performance improvement is pretty impressive from 9740ms to 189ms per 100 queries.Very impressive indeed Thanks for answering so fast Best Regards   Serge HuberI see big improvements too - thanks BUT I have some real world examples where a simple sql2 queries perform very bad compared to their sql1 pendants. The query . SQL1 select from project order by jcr score returns 1 126 nodes and takes 84ms - SQL2 select from project order by jcr score returns 1 126 nodes and takes 600ms absolutely seen still ok but compared to the sql1 execution time SQL1 select from task order by jcr score returns 76 281 nodes rows and takes 1.5s - SQL2 select from task order by jcr score returns 76 281 nodes rows and takes fasten your seat belt 95s - My test where performed with the latest-greatest JR sources 2.3 SNAPSHOT Hello Clement Thank you for the feedback. Could you provide more information about your tests Maybe there is something that can be put into a unit test so that performance analysis is easier to reproduce Or at the minimum the CND Best Regards   Serge HuberAs I have no special node types cnd ... project nt unstructured mix shareable task nt unstructured mix shareable ... my guess is that it has to do with the amount of nodes being returned looked up...Ok thanks. It is plausible that the number of results if affecting performance because from previous traces I saw that some constraints seemed to be evaluated on the results. But I didn t get around to testing the latest code yet. Would it be possible for your to capture some snapshots with Yourkit or an equivalent Best regards   Serge HuberjRat output. Hope this helps... Did you measure just the query.execute time or also the time it takes to iterate over the results The SQL2 QOM implementation loads all matching rows into memory during the execute call so you ll see an expensive query.execute but can then very quickly iterate over the query results.just the query.execute time...Thanks Clemens for the JRat data. From looking at it seems that the sorting of the results is taking up the most time so I wonder how the sorting is done in the case of the SQL-1 implementation Jukka is there a reason why we load all the data in the SQL-2 QOM implementations at query execution time Best regards   Serge... Jukka is there a reason why we load all the data in the SQL-2 QOM implementations at query execution time The SQL2 JQOM code needs to take joins and some new constraint types into account which makes it easiest to simply load the full result set into memory during execute . In practice this only causes problems when your query matches lots of rows but you re only interested in some of them see JCR-2830 . Hello Jukka Thanks for clarifying this. But it seems to me that a lot of developers will generate such queries. I ll continue on the other ticket anyway so that we can close this one. Best regards   Serge Huber.Hello i have attached a script. The execution gives different results in the new implemention and the old one before 2.2 . Also some annotiations With large Nodeset in the left Side of left outer join the executiontime is very big. Minutes This query is not possible Select from sling SamplePage as c left outer join sling SampleContent as a on ISDESCENDANTNODE a c where contains c.key1 value1 or contains a.key1 value1 I think this is a correct query and in the old implementation it works. I have also attached an hacked SQL2-Code from 2.1. This implementation is very fast and gives the same Results as before 2.2. You can dropin this in 2.3-Source tree and it works  The groovy script runs in Sling the expected output Output 2.2 contact1 activity1 Output 2.3 contact1 activity1 contact2 contact3 Testing joins in jackrabbit 2.1 and 2.3Hacked SQL2-Code from Jackrabbit 2.1 can be used in 2.3. Performance improvend
