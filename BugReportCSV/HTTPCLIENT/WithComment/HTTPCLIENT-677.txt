Connection pool uses Thread.interrupt 
The connection pool for TSCCM uses Thread.interrupt to wake up waiting threads. This interferes with application interrupts. - expose InterruptedException in interface - change pool implementation to use wait notify This is a nasty one. Currently all synchronization is done on the pool level to protect access to the various queues. Threads wait on the pool thereby releasing the lock while they wait. There are no notifications instead the chosen threads are interrupted. To avoid the interrupt threads have to wait on distinct objects at least one per route queue better one per thread. To wait on those objects a thread needs to synchronize on the object. During the wait only the lock on the extra object will be released but not the lock on the pool. The following sequence is necessary to make this work - create thread specific object - acquire lock on the pool - update queues - release lock on the pool - acquire lock on the object - call wait on the object - release lock on the object - acquire a new lock on the pool - update queues - release lock on the pool The obvious weak spot is the time between releasing the first lock on the queue and calling wait on the object. The wakeup notification from another thread may be triggered inbetween and must not be lost. Therefore the object needs to remember a notification until a thread comes to wait. A second potential weak spot is the time from wakeup until the lock on the pool is re-acquired. A thread might be chosen for notification a second time in this timeframe. Either the object must carry an indicator that it has already been chosen or the first notifier must remove the object from the queues before notification. In the second case the thread has to reacquire the pool lock and to update the queues only if it is interrupted externally rather than being notified. Which still leaves a window for notification to the interrupted thread. I know how to deal with but I need a bit more time to think about . yuck. - release lock on the object - acquire a new lock on the pool I think granular lock management should be relatively simple since we have an option of using java.util.concurrent. CountDownLatch may be the right thing to use in this situation. http java.sun.com j2se 1.5.0 docs api java util concurrent CountDownLatch.html Alternatively this may be the right moment to evaluate Commons Pool or some other external pooling library and see if that would make our life somewhat simpler. OlegYes I was hoping for java.util.concurrent too. Lock and Condition seem to fit the problem http java.sun.com j2se 1.5.0 docs api java util concurrent locks Condition.html http java.sun.com j2se 1.5.0 docs api java util concurrent locks Lock.html One lock for the pool one condition for each thread. I ll have to dig through the JavaDocs. cheers   Roland Done. Thread.interrupt is now used only during shutdown. The code didn t get prettier though. Plenty of cleanup pending. Thread.interrupt shouldn t be used during shutdown either. Locks are not guaranteed to implement interrupts. Use regular signal plus a shutdown flag to detect that case throw dedicated shutdown exception instead of InterruptedException. Done.
