Incorrect handling of InputStreams when connecting to a server that requires authentication
I m trying to upload a file to a WebDav server mod dav on Apache Web Server 2.2.14 that has basic or digest the result is the same authentication enabled. I m using the following code         String url http myserver dir test2.gif         File file new File d test2.gif         DefaultHttpClient httpClient new DefaultHttpClient         HttpPut put new HttpPut url         put.setEntity new InputStreamEntity new FileInputStream file file.length                  URI uri put.getURI         httpClient.getCredentialsProvider .setCredentials new AuthScope uri.getHost uri.getPort                 getCredentials         put.getParams .setBooleanParameter CoreProtocolPNames.USE EXPECT CONTINUE true         HttpResponse response httpClient.execute put         System.out.println response.getStatusLine When running the above code I m getting a org.apache.http.client.NonRepeatableRequestException Cannot retry request with a non-repeatable request entity. I tested both the latest alpha the svn head. Doing the same thing in HttpClient 3.1 worked as expected. This could be normal as I m using an InputStream that is indeed not repeatable but as I m also using Expect 100-Continue the stream shouldn t have been consumed with the first connection the one that gets a code 401 from the WebDav server and only in the second one when the credentials are provided. The problem is that DefaultRequestDirector.execute doesn t take this into account and assumes that if a request has been tried once its associated entity if any has been consumed. Here s the fix that I came up with Change DefaultRequestDirector.execute so that if the wrapper is an EntityEnclosingRequestWrapper it checks if the entity has actually been consumed before throwing a NonRepeatableRequestException. I m using the method isStreaming from HttpEntity as it s the closest thing to what I was looking for. Reading the JavaDoc it could lead to the situation where an entity has started streaming but has not yet finished and so is not in a state where it can be used. However I don t think that s a problem as the javadoc for HttpEntity.getContent states that it can t be called two times on a non-repeatable entity so it s just a matter of when the request will fail. This lead me to also modify InputStreamEntity from the httpCore project as it didn t comply with the javadoc. With these two modifications The file upload completes successfully. I also modified   TestInputStreamEntity.testBasics from the httpCore project test so that it complies with getContent s Javadoc.   TestDefaultClientRequestDirector.FaultyHttpRequestExecutor because it didn t consume the entity s content. All the tests from both httpCore and httpClient pass. I tested both InputStreamEntity and BasicHttpEntity.   Please keep in mind that I am by no means an httpClient or http for that matter expert and these modifications may have some unexpected side-effects that I did not foresee contain plain dumb code or whatever so it would be great if someone could review my changes and give their opinion. Here are the diffs against tag 4.0.1 of both httpClient and httpCoreThierry Would it be a big deal for you to re-create the diffs against HttpCore trunk 1 There has been a number of changes in HttpCore since the last official release. In particular HttpEntity contract has been simplified and clarified. It is quite possible you will no longer need to patch HttpCore. A test case for the bug would also be just great - . You might use this class as a starting point 2 Oleg 1 http svn.apache.org repos asf httpcomponents httpcore trunk 2 http svn.apache.org repos asf httpcomponents httpclient trunk httpclient src test java org apache http impl client TestClientAuthentication.javaHere are the diffs against the trunk. Reason I did them first against the 4.0.1 tag is that my goal is to use this on a production server and I m kind of not inclined to use versions that are labeled alpha I also couldn t find if there was a planned bugFix release 4.0.2 do you think this could happen in the somewhat near future Anyway back to the changes the new HttpEntity contract indeed clarifies isStreaming but it raises two new problems InputStreamEntity does not comply with this isStreaming still returns consumed whereas it should always return true there is no way now to test whether a stream has been consumed or not. For now I kept the fix the same as for 4.0.1 I m using isStreaming to check if a stream has been consumed but I think HttpEntity needs a isConsumed method otherwise I don t see how I can make this work without relying on code that doesn t comply with the contract. What do you think As for the test case thanks for providing the starting point I must admit I didn t know where to start... I ll try to find the time to do it by the end of the week I also couldn t find if there was a planned bugFix release 4.0.2 do you think this could happen in the somewhat near future At the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider InputStreamEntity does not comply with this isStreaming still returns consumed whereas it should always return true I am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot. there is no way now to test whether a stream has been consumed or not. The trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying content stream which is something I would like to avoid. For now I kept the fix the same as for 4.0.1 I m using isStreaming to check if a stream has been consumed but I think HttpEntity needs a isConsumed method otherwise I don t see how I can make this work without relying on code that doesn t comply with the contract. What do you think I think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking EntityEnclosingRequestWrapper class. That is why it is super-critical that we have a test case for the problem. Oleg At the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider ok. As for me I find it a pretty severe bug because the workaround is to use ByteArrayInputStreams and this would quickly be a memory hog but then again as no one reported this bug before I guess not many people use the same scenario as me InputStreamEntity does not comply with this isStreaming still returns consumed whereas it should always return true I am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot. my bad didn t update before diffing. getContent is still broken though there is no way now to test whether a stream has been consumed or not. The trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying content stream which is something I would like to avoid. I think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking EntityEnclosingRequestWrapper class. Well seeing that EntityEnclosingRequestWrapper has no way of knowing what s done with the entity once getEntity has been called I don t really see how you would know the enclosed entity has been written out to the socket without wrapping the entity itself and overriding writeTo other than using events but I don t think you want to go there . The solution may lie in RequestWrapper.getExecCount which only seems targeted at knowing if a request can be repeated and is the source of the bug in DefaultRequestDirector.tryExecute wrapper.getExecCount 1 wrapper.isRepeatable . From what I understand a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn t been consumed Is this correct If so then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated and it doesn t reflect the entity s status. What do you think That is why it is super-critical that we have a test case for the problem. Here they are testClientAuthentication.diff . Unfortunately the testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue test can t pass even if the bug is fixed because LocalTestServer sends a 100 instead of a 401 during the handshake when it receives a header with Expect Continue. I don t feel confident enough with the code to try and fix that sorry. The second test testBasicAuthenticationFailureOnNonRepeatablePutDontExpectContinue is somewhat redundant with testBasicAuthenticationFailureOnNonRepeatablePost but as it explicitly specifies setBooleanParameter CoreProtocolPNames.USE EXPECT CONTINUE false I find it useful. Feel free to discard it. Thierry ok. As for me I find it a pretty severe bug Look. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug. I have a one month old daughter grumpy wife and lots of other things I need to take care of besides HttpClient. There has been a few other bug reports recently which makes 4.0.2 more likely. getContent is still broken though Huh why HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do with the content stream. a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn t been consumed Is this correct Correct If so then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated and it doesn t reflect the entity s status. I disagree. The exec count is merely a request count. It does what it does. The core of the problem is that HttpClient currently can t know whether expect-continue handshake was used or not. There are different ways of addressing the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping HttpClientConnection and monitoring sendRequestEntity method. because LocalTestServer sends a 100 instead of a 401 during the handshake when it receives a header with Expect Continue This behaviour can be changed by using a custom expectation verifier. Oleg Look. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug. I have a one month old daughter grumpy wife and lots of other things I need to take care of besides HttpClient. As always smileys can t convey entirely one s thoughts so let me try to be more clear I d be glad to have a 4.0.2 but I understand that this bug cannot be labeled as breaking the 4.0.1 release and warranting a new release on its own seeing that it doesn t look to bother anyone but me. And I appreciate the time you re putting into this. I m just trying to help please bear with me as English is not my primary language and I know what I m writing can be tactless. This is not my intent at all. Huh why HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do with the content stream. Well as I told you I m no HttpCore Client expert so I m relying on the API and the code and in httpCore trunk here s the javaDoc for HttpEntity.getContent       Creates a new InputStream object of the entity. It is an interface       violation to return the same link InputStream object more than       once. Entities that are not link isRepeatable repeatable       should throw an exception if this method is called multiple times. Looks like it s not up to date so disregard my comment on getContent being broken. If so then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated and it doesn t reflect the entity s status. I disagree. The exec count is merely a request count. It does what it does. What I meant is that it looked to me that the exec count was created to know if an entityEnclosingRequest could be repeated as I couldn t find any other uses in the code for it and so its purpose was not fulfilled. Didn t think it could have been created without this purpose in mind my bad. The core of the problem is that HttpClient currently can t know whether expect-continue handshake was used or not. There are different ways of addressing the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping HttpClientConnection and monitoring sendRequestEntity method. This behaviour can be changed by using a custom expectation verifier. Thanks for the pointers I ll look into it next week My apologies for being such a grumpy old man. Thanks for pointing out inconsistencies in Javadocs of the HttpEntity interface I overlooked. Please review the updated version http svn.apache.org viewvc rev 953893 view rev I committed the test cases with some minor tweaks. The testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue test case now verifies user credentials during the expect-continue phase by means of a custom HttpExpectionVerifier. Please review http svn.apache.org viewvc rev 953890 view rev Thanks for all your help and contributions. Oleg     After looking at HttpRequestExecutor would it be ok to use the ExecutionContext to store the fact that the request entity has been consumed just as HttpRequestExecutor does it for the whole http request cf line 252 context.setAttribute ExecutionContext.HTTP REQ SENT Boolean.TRUE It would only require to add a constant to ExecutionContext HTTP REQ ENT CONSUMED for instance and change the test in DefaultRequestDirector to check for this boolean instead of the wrapper request count. I did a quick test and it works as expected what do you think Thierry Feel free to raise a separate JIRA for this change against HttpCore. However I suggest we go for the entity decorator wrapper approach as it would enable us to back-port the fix to 4.0.x branch without too much trouble. Cheers OlegOleg I m a bit confused here as looking at the 4.0.x sources the code change would be exactly the same setting a boolean in the HttpContext during HttpRequestExecutor doSendRequest and changing DefaultRequestDirector to take that into account . Am I missing something Still if you prefer wrapping the HttpClientConnection I ll look into it but I m not sure I ll have time before mid-July holidays . Am I missing something The problem is the change would require a release of HttpCore before it could be employed by HttpClient. Still if you prefer wrapping the HttpClientConnection I ll look into it but I m not sure I ll have time before mid-July holidays . Of course my sinister plan was to talk you into seeing the whole issue to some sort of a logical conclusion. No problem though I ll come up with a fix within a few days. OlegOleg had some spare time so here are the changes using a connection wrapper. Are you still interested in the diff to core 4.1 that adds the HTTP REQ ENT CONSUMED to the context when the entity It would avoid having the wrapper and make for nicer code IMHO. cheers Thierry had some spare time so here are the changes using a connection wrapper. Yep. Almost there. I can t help thinking though wrapping HttpEntity would probably be somewhat cleaner. I did not like the idea of wrapping the underlying content stream but wrapping the entity should be perfectly fine. Are you still interested in the diff to core 4.1 that adds the HTTP REQ ENT CONSUMED to the context when the entity Yes I am. Please raise a separate issue for this change against HttpCore module. Cheers OlegFixed in SVN trunk and 4.0.x branch. Please review. OlegI am using the latest in trunk for both httpClient and httpCore I am getting this error on some devices cell phones not all Here is the code InputStreamEntity reqEntity new InputStreamEntity new MyFileInputStream file upl fileLength reqEntity.setContentType binary octet-stream reqEntity.setChunked false httppost.setEntity reqEntity HttpResponse response httpclient.execute httppost failure HttpEntity resEntity response.getEntity org.apache.http.client.ClientProtocolException at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 702 at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 625 at org.apache.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 603 Caused by org.apache.http.client.NonRepeatableRequestException Cannot retry request with a non-repeatable request entity. The cause lists the reason the original request failed. Any ideas You can use wire context logging to find out why the request had to be retried. http hc.apache.org httpcomponents-client-4.0.1 logging.html OlegThanks Oleg It seems to be something with the SSL I added the logs Here is a sample log from a working upload I removed the host and IP It has a lot of debug here I Think its the file content then..... 08-22 12 23 52.979 HTTP 1.1 200 OK r n 08-22 12 23 52.981 Date Sun 22 Aug 2010 16 25 20 GMT r n 08-22 12 23 52.991 Server Microsoft-IIS 6.0 r n 08-22 12 23 52.991 X-Powered-By ASP.NET r n 08-22 12 23 52.991 X-AspNet-Version 2.0.50727 r n 08-22 12 23 53.001 Cache-Control private r n 08-22 12 23 53.001 Content-Type text html charset utf-8 r n 08-22 12 23 53.001 Content-Length 484 r n 08-22 12 23 53.001 r n 08-22 12 23 53.011 Receiving response HTTP 1.1 200 OK 08-22 12 23 53.011 HTTP 1.1 200 OK 08-22 12 23 53.011 Date Sun 22 Aug 2010 16 25 20 GMT 08-22 12 23 53.011 Server Microsoft-IIS 6.0 08-22 12 23 53.011 X-Powered-By ASP.NET 08-22 12 23 53.011 X-AspNet-Version 2.0.50727 08-22 12 23 53.011 Cache-Control private 08-22 12 23 53.011 Content-Type text html charset utf-8 08-22 12 23 53.011 Content-Length 484 08-22 12 23 53.021 Connection can be kept alive for ever 08-22 12 23 53.021 Shutting down 08-22 12 23 53.021 Connection closed 08-22 12 23 53.091 Get connection HttpRoute s - https .com timeout 10000 08-22 12 23 53.091 HttpRoute s - https .com total kept alive 0 total issued 0 total allocated 0 out of 20 08-22 12 23 53.091 No free connections HttpRoute s - https .com null 08-22 12 23 53.091 Available capacity 2 out of 2 HttpRoute s - https .com null 08-22 12 23 53.091 Creating new connection HttpRoute s - https .com 08-22 12 23 53.091 Connecting to .com . . . 443 08-22 12 23 53.461 CookieSpec selected best-match 08-22 12 23 53.461 Attempt 1 to execute request 08-22 12 23 53.501 Shutting down 08-22 12 23 53.501 Sending request POST UploadFiles.aspx HTTP 1.1 08-22 12 23 53.501 POST UploadFiles.aspx HTTP 1.1 r n 08-22 12 23 53.501 Cache-Control no-cache r n 08-22 12 23 53.501 Pragma no-cache r n 08-22 12 23 53.501 Authorization Basic r n 08-22 12 23 53.511 ty 0 r n 08-22 12 23 53.511 v 252 r n 08-22 12 23 53.511 u 354957030634904 r n 08-22 12 23 53.511 postType 0 r n 08-22 12 23 53.511 filenum -999 r n 08-22 12 23 53.511 pl 1 r n 08-22 12 23 53.511 on 1 r n 08-22 12 23 53.521 mf 5 r n 08-22 12 23 53.521 Transfer-File-Name r n 08-22 12 23 53.521 Transfer-File-Chunk-Count 1 r n 08-22 12 23 53.521 Transfer-File-Chunk 0 r n 08-22 12 23 53.521 filelength 5120 r n 08-22 12 23 53.521 Cookie ASP.NET SessionId 4eypxj45tsnabe45ficbnd55 path HttpOnly r n 08-22 12 23 53.521 Content-Length 5120 r n 08-22 12 23 53.521 Content-Type binary octet-stream r n 08-22 12 23 53.521 Host .com r n 08-22 12 23 53.521 Connection Keep-Alive r n 08-22 12 23 53.531 r n 08-22 12 23 53.531 POST UploadFiles.aspx HTTP 1.1 08-22 12 23 53.531 Cache-Control no-cache 08-22 12 23 53.531 Pragma no-cache 08-22 12 23 53.531 Authorization Basic 08-22 12 23 53.531 ty 0 08-22 12 23 53.531 v 252 08-22 12 23 53.531 u 354957030634904 08-22 12 23 53.531 postType 0 08-22 12 23 53.531 filenum -999 08-22 12 23 53.531 pl 1 08-22 12 23 53.531 on 1 08-22 12 23 53.531 mf 5 08-22 12 23 53.531 Transfer-File-Name 08-22 12 23 53.531 Transfer-File-Chunk-Count 1 08-22 12 23 53.531 Transfer-File-Chunk 0 08-22 12 23 53.531 filelength 5120 08-22 12 23 53.531 Cookie ASP.NET SessionId 4eypxj45tsnabe45ficbnd55 path HttpOnly 08-22 12 23 53.531 Content-Length 5120 08-22 12 23 53.531 Content-Type binary octet-stream 08-22 12 23 53.531 Host .com 08-22 12 23 53.531 Connection Keep-Alive And here is the same log from a non working device It has a lot of debug here I Think its the file content then..... 08-22 12 19 18.374 D Connection closed 08-22 12 19 18.374 D Closing the connection. 08-22 12 19 18.374 D Connection closed 08-22 12 19 18.374 I I O exception java.io.IOException caught when processing request SSL shutdown failed I O error during system call Broken pipe 08-22 12 19 18.397 D SSL shutdown failed I O error during system call Broken pipe 08-22 12 19 18.397 D java.io.IOException SSL shutdown failed I O error during system call Broken pipe 08-22 12 19 18.397 D at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose Native Method 08-22 12 19 18.397 D at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close OpenSSLSocketImpl.java 958 08-22 12 19 18.397 D at org.apache41.http.impl.SocketHttpClientConnection.close SocketHttpClientConnection.java 259 08-22 12 19 18.397 D at org.apache41.http.impl.conn.DefaultClientConnection.close DefaultClientConnection.java 162 08-22 12 19 18.397 D at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close AbstractPooledConnAdapter.java 152 08-22 12 19 18.397 D at org.apache41.http.protocol.HttpRequestExecutor.execute HttpRequestExecutor.java 129 08-22 12 19 18.397 D at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 623 08-22 12 19 18.397 D at org.apache41.http.impl.client.DefaultRequestDirector.execute DefaultRequestDirector.java 453 08-22 12 19 18.397 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 700 08-22 12 19 18.397 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 625 08-22 12 19 18.397 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 603 08-22 12 19 18.397 D at hg.a ProGuard 2446 08-22 12 19 18.397 D at b.a ProGuard 1962 08-22 12 19 18.397 D at b.a ProGuard 1563 08-22 12 19 18.397 D at e.run ProGuard 1509 08-22 12 19 18.397 I Retrying request 08-22 12 19 18.405 D Reopening the direct connection. 08-22 12 19 18.405 D Connecting to .com . . . 443 08-22 12 19 20.288 D Cannot retry non-repeatable request 08-22 12 19 20.296 D Connection shut down 08-22 12 19 20.296 D Released connection is not reusable. 08-22 12 19 20.296 D Releasing connection HttpRoute s - https .com null 08-22 12 19 20.296 D Notifying no-one there are no waiting threads 08-22 12 19 20.311 E null 08-22 12 19 20.311 E org.apache41.http.client.ClientProtocolException 08-22 12 19 20.311 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 702 08-22 12 19 20.311 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 625 08-22 12 19 20.311 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 603 08-22 12 19 20.311 E at hg.a ProGuard 2446 08-22 12 19 20.311 E at b.a ProGuard 1962 08-22 12 19 20.311 E at b.a ProGuard 1563 08-22 12 19 20.311 E at e.run ProGuard 1509 08-22 12 19 20.311 E Caused by org.apache41.http.client.NonRepeatableRequestException Cannot retry request with a non-repeatable request entity. The cause lists the reason the original request failed. 08-22 12 19 20.311 E at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 610 08-22 12 19 20.311 E at org.apache41.http.impl.client.DefaultRequestDirector.execute DefaultRequestDirector.java 453 08-22 12 19 20.311 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 700 08-22 12 19 20.311 E ... 6 more 08-22 12 19 20.311 E Caused by java.io.IOException SSL shutdown failed I O error during system call Broken pipe 08-22 12 19 20.311 E at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose Native Method 08-22 12 19 20.311 E at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close OpenSSLSocketImpl.java 958 08-22 12 19 20.311 E at org.apache41.http.impl.SocketHttpClientConnection.close SocketHttpClientConnection.java 259 08-22 12 19 20.311 E at org.apache41.http.impl.conn.DefaultClientConnection.close DefaultClientConnection.java 162 08-22 12 19 20.311 E at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close AbstractPooledConnAdapter.java 152 08-22 12 19 20.311 E at org.apache41.http.protocol.HttpRequestExecutor.execute HttpRequestExecutor.java 129 08-22 12 19 20.311 E at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 623 08-22 12 19 20.311 E ... 8 more 08-22 12 19 20.319 D Shutting down 08-22 12 19 22.507 D Shutting downRichard The log does not seem complete. It starts with Connection closed entry which is strange. What kind of JRE are you using It is Harmony OlegOleg Thanks again for the quick reply The log starts with beginning of dev log main then I see a bunch of unreadable text I am assuming its base64 of the file content then Connection closed. Message This is running on Android It seems the close is getting called from httpclient Any more ideas Right but I need to know what leads to that close method call. Try disabling wire logs while leaving context header logs on. OlegOK.. The new log has no wire just context it s not failing all the time just intermittently in this case there was one pass and one fail after it. I am suspecting that the socket is not getting closed properly from the pass although I am calling httpclient.getConnectionManager .shutdown Here are the logs 08-23 13 11 27.759 D Get connection HttpRoute s - https .com timeout 10000 08-23 13 11 27.767 D HttpRoute s - https .com total kept alive 0 total issued 0 total allocated 0 out of 20 08-23 13 11 27.767 D No free connections HttpRoute s - https .com null 08-23 13 11 27.767 D Available capacity 2 out of 2 HttpRoute s - https .com null 08-23 13 11 27.767 D Creating new connection HttpRoute s - https .com 08-23 13 11 27.876 D Connecting to .com . . . 443 08-23 13 11 28.509 D CookieSpec selected best-match 08-23 13 11 28.540 D Attempt 1 to execute request 08-23 13 11 28.540 D Sending request POST UploadFiles.aspx HTTP 1.1 08-23 13 11 28.556 D POST UploadFiles.aspx HTTP 1.1 08-23 13 11 28.556 D Cache-Control no-cache 08-23 13 11 28.556 D Pragma no-cache 08-23 13 11 28.556 D Authorization Basic 08-23 13 11 28.556 D ty 0 08-23 13 11 28.556 D v 252 08-23 13 11 28.556 D u A000002201F102 08-23 13 11 28.556 D postType 1 08-23 13 11 28.556 D filenum 0 08-23 13 11 28.556 D pl 1 08-23 13 11 28.556 D on 1 08-23 13 11 28.556 D mf 5 08-23 13 11 28.556 D Transfer-File-Name file1 08-23 13 11 28.556 D Transfer-File-Chunk-Count 1 08-23 13 11 28.556 D Transfer-File-Chunk 0 08-23 13 11 28.556 D filelength 39024636 08-23 13 11 28.556 D Cookie ASP.NET SessionId v2jltw45cmu4wtiznidhavnx path HttpOnly 08-23 13 11 28.556 D Content-Length 39024636 08-23 13 11 28.556 D Content-Type binary octet-stream 08-23 13 11 28.556 D Host .com 08-23 13 11 28.556 D Connection Keep-Alive 08-23 13 13 12.150 D Get connection HttpRoute s - https .com timeout 10000 08-23 13 13 12.150 D HttpRoute s - https .com total kept alive 0 total issued 0 total allocated 0 out of 20 08-23 13 13 12.150 D No free connections HttpRoute s - https .com null 08-23 13 13 12.150 D Available capacity 2 out of 2 HttpRoute s - https .com null 08-23 13 13 12.150 D Creating new connection HttpRoute s - https .com 08-23 13 13 12.197 D Connecting to .com . . . 443 08-23 13 13 12.868 D CookieSpec selected best-match 08-23 13 13 12.868 D Attempt 1 to execute request 08-23 13 13 12.868 D Sending request POST UploadFiles.aspx HTTP 1.1 08-23 13 13 12.876 D POST UploadFiles.aspx HTTP 1.1 08-23 13 13 12.876 D Cache-Control no-cache 08-23 13 13 12.876 D Pragma no-cache 08-23 13 13 12.876 D Authorization Basic 08-23 13 13 12.876 D ty 0 08-23 13 13 12.876 D v 252 08-23 13 13 12.876 D u A000002201F102 08-23 13 13 12.876 D postType 1 08-23 13 13 12.876 D filenum 0 08-23 13 13 12.876 D pl 1 08-23 13 13 12.876 D on 1 08-23 13 13 12.876 D mf 5 08-23 13 13 12.884 D Transfer-File-Name file2 08-23 13 13 12.884 D Transfer-File-Chunk-Count 1 08-23 13 13 12.884 D Transfer-File-Chunk 0 08-23 13 13 12.884 D filelength 39024636 08-23 13 13 12.884 D Cookie ASP.NET SessionId v2jltw45cmu4wtiznidhavnx path HttpOnly 08-23 13 13 12.884 D Content-Length 39024636 08-23 13 13 12.884 D Content-Type binary octet-stream 08-23 13 13 12.884 D Host .com 08-23 13 13 12.884 D Connection Keep-Alive 08-23 13 13 57.556 D Connection closed 08-23 13 13 57.587 D Closing the connection. 08-23 13 13 57.587 D Connection closed 08-23 13 13 57.650 I I O exception java.io.IOException caught when processing request SSL shutdown failed I O error during system call Broken pipe 08-23 13 13 57.665 D SSL shutdown failed I O error during system call Broken pipe 08-23 13 13 57.665 D java.io.IOException SSL shutdown failed I O error during system call Broken pipe 08-23 13 13 57.665 D at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose Native Method 08-23 13 13 57.665 D at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close OpenSSLSocketImpl.java 958 08-23 13 13 57.665 D at org.apache41.http.impl.SocketHttpClientConnection.close SocketHttpClientConnection.java 259 08-23 13 13 57.665 D at org.apache41.http.impl.conn.DefaultClientConnection.close DefaultClientConnection.java 162 08-23 13 13 57.665 D at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close AbstractPooledConnAdapter.java 152 08-23 13 13 57.665 D at org.apache41.http.protocol.HttpRequestExecutor.execute HttpRequestExecutor.java 129 08-23 13 13 57.665 D at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 623 08-23 13 13 57.665 D at org.apache41.http.impl.client.DefaultRequestDirector.execute DefaultRequestDirector.java 453 08-23 13 13 57.665 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 700 08-23 13 13 57.665 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 625 08-23 13 13 57.665 D at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 603 08-23 13 13 57.665 D at hg.a ProGuard 2446 08-23 13 13 57.665 D at b.a ProGuard 1962 08-23 13 13 57.665 D at b.a ProGuard 1563 08-23 13 13 57.665 D at e.run ProGuard 1509 08-23 13 13 57.665 I Retrying request 08-23 13 13 57.665 D Reopening the direct connection. 08-23 13 13 57.665 D Connecting to .com . . . 443 08-23 13 13 58.025 D Cannot retry non-repeatable request 08-23 13 13 58.033 D Connection shut down 08-23 13 13 58.033 D Released connection is not reusable. 08-23 13 13 58.033 D Releasing connection HttpRoute s - https .com null 08-23 13 13 58.040 D Notifying no-one there are no waiting threads 08-23 13 13 58.056 E null 08-23 13 13 58.056 E org.apache41.http.client.ClientProtocolException 08-23 13 13 58.056 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 702 08-23 13 13 58.056 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 625 08-23 13 13 58.056 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 603 08-23 13 13 58.056 E at hg.a ProGuard 2446 08-23 13 13 58.056 E at b.a ProGuard 1962 08-23 13 13 58.056 E at b.a ProGuard 1563 08-23 13 13 58.056 E at e.run ProGuard 1509 08-23 13 13 58.056 E Caused by org.apache41.http.client.NonRepeatableRequestException Cannot retry request with a non-repeatable request entity. The cause lists the reason the original request failed. 08-23 13 13 58.056 E at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 610 08-23 13 13 58.056 E at org.apache41.http.impl.client.DefaultRequestDirector.execute DefaultRequestDirector.java 453 08-23 13 13 58.056 E at org.apache41.http.impl.client.AbstractHttpClient.execute AbstractHttpClient.java 700 08-23 13 13 58.056 E ... 6 more 08-23 13 13 58.056 E Caused by java.io.IOException SSL shutdown failed I O error during system call Broken pipe 08-23 13 13 58.056 E at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose Native Method 08-23 13 13 58.056 E at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close OpenSSLSocketImpl.java 958 08-23 13 13 58.056 E at org.apache41.http.impl.SocketHttpClientConnection.close SocketHttpClientConnection.java 259 08-23 13 13 58.056 E at org.apache41.http.impl.conn.DefaultClientConnection.close DefaultClientConnection.java 162 08-23 13 13 58.056 E at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close AbstractPooledConnAdapter.java 152 08-23 13 13 58.056 E at org.apache41.http.protocol.HttpRequestExecutor.execute HttpRequestExecutor.java 129 08-23 13 13 58.056 E at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute DefaultRequestDirector.java 623 08-23 13 13 58.056 E ... 8 more 08-23 13 13 58.064 D Shutting downOleg Any ideas on the log I posted please... ThanksSo do I understand it correctly that your application is posting 30MB of stuff using a non-repeatable entity Well what are the changes of temporarily losing the connection while such amount of data is being uploaded over a wireless link The only problem on the HttpClient side is that the original I O exception gets lost because the HttpConnection close method called by HttpRequestExecutor also terminates abnormally with an I O exception. Feel free to raise a JIRA for this issue. OlegIn the mean time.. Is there a work around.. when it retries why does it fail is it not shutting down properly Use self-contained repeatable entity implementation. http hc.apache.org httpcomponents-client-4.0.1 tutorial html fundamentals.html d4e93 Please post all your further questions to the user list. Olegrepeatable entity means that I have to buffer the whole file into memory this is why I started using httpclient to start with because URLConnection buffers the whole thing and I get outofmemory exception Are you saying this is a bug with httpClient repeatable entity means that I have to buffer the whole file into memory No it does not. An entity does not have to be buffered in memory in order to be repeatable. It just need to be able to recreate its input stream Are you saying this is a bug with httpClient No it is not. Did you read the section of the tutorial I referred you to If you have any further questions post them to the user list. Oleg
