New Preferences Architecture
An architectural solution is needed to configure various aspects of HttpClient Methods and Connections. Features - can configure certain properties per request per connection - all configuration is done in a consistant way - do not use system properties - configuration is completely optional default values should be used if no configuration is made This is a refactoring request reminder. File configuration issues as dependencies of this bug.Obviously this Bugzilla is not configured to allow dependencies. So just add comments with the bug numbers 8288 10790 10791 10793 10797 I have new preference architecure almost ready. I ll submit the first revision of the patch as soon as I get back from Croatia. It turned out to be much more difficult than I initally though. At least three attempts to come up with acceptable solution bogged down. But the 4th one looks promising. Oleg.See my comments aboveCreated an attachment id 8053 Patch take 1 Important points - collections of HTTP parameters may be linked together to form a hierarchy - Parameters can be set at the global level Http client level or Http method level - If a parameter is not defined at the current level its value is drawn from a higher levels of the hierarchy at which the parameter is defined - If parameter is not defined at the current level or any level above a default value is returned - Some parameters are not applicable at the Http method levelHi Oleg I like it. Overall the design is quite good. I have number of ideas questions which I will elaborate on below. High level stuff  - How should we handle the storage of more complicated configuration options like the date formats used in DateParser This is definitely something that I think should be able to configure in the default case at least. Another item that has been brought up is the ability to define a set of default headers to be applied to all methods. Here a couple of ideas off the top of my head 1 - delimit values http.dateFormats EEE dd-MMM-yyyy HH mm ss z SOME DELIM EEE dd-MMM-yyyy HH-mm- ss z 2 - indirection http.dateFormats format1 format2 format1 EEE dd-MMM-yyyy HH mm ss z format2 EEE dd-MMM-yyyy HH-mm-ss z The first choice is the easiest but has the delimiter choice problem. The second choice is more exact but requires more work and is a little less obvious. I think the solution here will depend somewhat on the answer to the next question.  - Is there a need for both specific configuration params like getConnectionManagerTimeout and generic ones like getParameter String I feel like we should have custom methods for all configuration values or all generic ones with support for type specific params like getLongValue String but not both. I am leaning more toward all specific configuration methods. This configuration system is only meant to support HttpClient. It should not need to be generic enough to be usable for other purposes. Implementation details perhaps too soon for this  - I think HttpParams.load should use a PropertyResourceBundle to load parse the configuration. It avoids implementing the nasty details and provides support for splitting lines with among other things.  - I think we probably want a HttpMethodBase.setParams or something of the sort. What do you think Mike A comment about classloaders to finde the properties file. We must be very careful about this and be as much compatible with other components i.e. handle it the same way. I am not 100 sure but I think the most common procedure is a follows 1. Try the current thread s context ClassLoader if not null and look for the properties file 2. Try the ClassLoader that loaded the class and look for the properties file 3. Use the Jar file service provider mechanism see http java.sun.com j2se 1.3 docs guide jar jar.html We must check other projects like Xerces JCE how they handle ClassLoaders.I thought about this quite a bit more last night as I was going to sleep and I have changed my mind particularly in regard to specific vs. generic configuration. My feeling now is that HttpParams should be a source for generic configuration and that specific configuration should be handled by the specific users of the values. For example HttpParams would have methods like     String getParam String key     long getLongParam String key and default options like     String getParam String key String default     long getLongParam String key long default Then classes like HttpVersion or HttpMethodBase would have the specifics like     public static final String PARAM PROTOCOL VERSION http.protocol.version and     public static void setHttpVersion HttpVersion version HttpParams params Again these are just some ideas. I like this separation of things better though. This allows HttpParams to be flexible enough to handle various kinds of configuration and pushes the specifics to the classes that care about them. What do you think MikeIn response to Ortwin s comments I haven t had a chance to look into the patch yet if you are trying to load arbitrary things from the classpath you create a major problem and for applets since those attempts translate into requests back to the original server which may include popping up authentication dialogs to the user etc. I m not sure why HttpClient needs a way to be configured by a dynamically located properties file since it is always used through it s programmatic API anyway. It seems to me that just passing in a properties file or some other configuration object to the HttpClient constructor would do and we could avoid the need to implement and maintain code for automatically locating the properties file. Either way it s an absolute must for us to have a way to turn off this autodiscovery. I m happy to implement this myself once things settle down if need be though.Some quick thoughts from here having scanned the proposed patch only very briefly I like the idea of keeping parameters generic. I use the Slide WebDAV extensions and likely there will be options that make sense to specify for that in the future default encoding of XML requests for example . Clients may also have preferences that they associate with HttpClient but are not necessarily used by HttpClient. By keeping the options generic extensions like WebDAV and other client wrappers can use the same mechanism for setting their preferences. If you make the settings functions specific it will be harder over time for the library to accommodate new options and clients will not be able to extend it as easily. The discovery process standard could use the approach outlined here http java.sun.com j2se 1.4.2 docs api javax xml parsers SAXParserFactory.html newInstance which is as close to a standard as Java has for this kind of thing. Ortwin has an excellent point namely that the discovery process should kick in only if the caller doesn t provide default information. Folks It s my first day at work after two weeks of holidays so things are a bit hectic right now. I ll try to respond to every comment made but that may take a while and a few postings 2 - indirection http.dateFormats format1 format2 format1 EEE dd-MMM-yyyy HH mm ss z format2 EEE dd-MMM-yyyy HH-mm-ss z That s the way Sun does it and it may well be the way most users would expect it to work me for one - Is there a need for both specific configuration params like getConnectionManagerTimeout and generic ones like getParameter String Not really. I also agree that ideally two methods should not be mixed up. I sense that the majority of respondent favor the generic approach over specific like I do. I just felt that having to parse some frequently values such as protocol version might be too much of a performance hit. I thought an exception could be made for the most frequently used parameters maybe just protocol version . However if we all agree that performance degradation will be offset by greater flexibility I do not mind taking purely generic approach - I think HttpParams.load should use a PropertyResourceBundle to load parse the configuration. It avoids implementing the nasty details and provides support for splitting lines with among other things. Agreed. - I think we probably want a HttpMethodBase.setParams or something of the sort. Can do. OlegI don t like the generic approach so much. It involves defining property names which introduce typos and requires converting data representations. If you know you need a boolean to indicate whether redirects should be chased or not just to give an example give it a setter and a getter and let the compiler check for typos. To me a generic mechanism is something for things we haven t thought about or things we couldn t know about in Eric s case. Useful but rather a fallback than a preferred choice. Unfortunately I won t find the time to look at the code in the near future. But is there a way to have base class that provides a generic mechanism and to use adapter classes for the individual components Something like HttpParams generic parameters and conversion methods from and to strings HttpClientParams specific getters and setters for the client s properties   kept in attributes. Constructor and or readFrom HttpParams to initialize   the attributes and saveTo HttpParams to write them back. HttpMethodParams like HttpClientParams just for the HttpMethodBase params HttpGetMethodParams derived from HttpMethodParams adding some GET-specific   attributes. ...and so on for every component that defines parameters I know this may create a lot of new classes but I always was a friend of lots of simple classes - We must be very careful about this and be as much compatible with other components i.e. handle it the same way Odi Adrian I think your concerns are well grounded. In order to address them I am going to make sure that 1 configuration file discovery mechanism behaves consistently with the common practices outlined in the reference provided by Eric 2 discovery mechanism kicks in ONLY if no configuration file explicitly specified through a system property 3 fat scary warning message is logged if no configuration file is explicitly given Oleg HttpParams generic parameters and conversion methods from and to strings HttpClientParams specific getters and setters for the client s properties kept in attributes. Constructor and or readFrom HttpParams to initialize the attributes and saveTo HttpParams to write them back. HttpMethodParams like HttpClientParams just for the HttpMethodBase params HttpGetMethodParams derived from HttpMethodParams adding some GET-specific attributes. ...and so on for every component that defines parameters Roland how about this interface HttpGenericParams implemented by HttpParams interface HttpClientParams derived from HttpGenericParams implemented by HttpClient interface HttpHttpParams derived from HttpGenericParams implemented by HttpMethodBase Interface implementations act as a facade that abstract the intricacies of physical representation and conversion of parameters contained in the associated HttpParams instance. All parameters can still be accessed directly through HttpGenericParams interface. That would also be a way to interact with non-standard parameters OlegHi Oleg I ve had a chance to look over the patch and it looks like some really good work - well done Continuing my applet-focussed view of the world 2 discovery mechanism kicks in ONLY if no configuration file explicitly specified through a system property This won t help unsigned applets at all and while I don t think HttpClient is particularly useful in such a context anyway it would be nice to avoid system properties for configuration since that was one of the goals of the new architecture anyway. Certainly setting a system property would be a good option but would it be possible to just create a HttpParams object manually and not use a properties file at all I wouldnt be too worried if such a scheme causes undue problems but it is a nice to have feature. Otherwise I like it particularly with your latest suggestion for handling Roland s suggestions and with the aid of good documentation supporting it that I m happy to add to my todo list .Here is another idea that combines some of what Oleg and Roland are saying but in a different way. How about something like interface HttpParams with getters and setter for simple types like String int etc. implemented by PropertyHttpParams the current HttpParams class HttpParamsFactory with factory methods for getting access to instances of HttpParams. These classes would handle loading storing access for the basics. For the various specifics like HttpVersion we would have static instance methods like the following class HttpVersion   ...   public static HttpVersion getHttpVersion HttpParams params ...   public static void setHttpVersion HttpVersion version HttpParams params ...   ... This setup allows for more flexibility at the base HttpParams level which I think is important but doesn t add specific Params classes interfaces ClientParams MethodParams etc. . I feel like there is really only going to be one way to go from HttpVersion- String and vice-versa and that adding interfaces abstraction for this is overkill. Some food for thought or at least I hope MikeHello Oleg Mike I like the interface approach. Mike the generic approach with automatic conversion for simple data types is fine for simple data types. But for something like the various date formats you d have parsing code at the place where the formats are needed. I would prefer something like params.getDateFormats that returns a parsed string array with the parsing code offloaded to a different class. Of course that could also be achieved by using a helper like ParamsParser.getDateFormats param and a generic parameter store. Still this would require a generic data store even in cases where configuration is done programatically. Folks would have to convert their type-specific parameters they obtained from whereever to the generic format which would then be converted back by the http client code. Mike the HttpParamsFactory is an excellent suggestion. I learned from my work on OpenCard that a forced config loading mechanism is a bad idea. Sooner or later someone is going to create a small footprint version of your code or use it in a setting you didn t expect originally and they will want to get rid of whatever well-designed loading mechanism you put in just because they have their own or don t want to specify one. I would even go so far as to avoid any reference from the run-time classes to the configuration classes. So instead of having a default constructor for HttpClient that uses HttpParamsFactory to obtain it s parameters put a factory method in the factory to create a configured HttpClient   HttpClient HttpParamsFactory.createConfiguredClient So folks that want to provide the properties themselves can just drop HttpParamsFactory from the package without any impact on the rest of the classes. In a customer project I put all configuration loading and default initialization code into a separate optional package and was quite happy with that decision. Oleg Adrian I am not convinced that we should really use a configuration FILE at all. This would imply that all HttpClient objects were configured with exactly the same parameters if not customized after instantiation . I think this is of little to no use. I have rather come to the conclusion that configuration should be done instrinsic. If someone wants a properties XML file he can always write his own configuration mechanism. We may supply a PropertiesFileConfigurator in the contrib package. Default values can also be provided in a class. Generic parameters vs. getters setters This was discussed in earlier approches too. The main argument not to use getters setters is the sheer number of parameters and future extenstions while keeping the API small and constant enough. But there are some good arguments pro getters setters  - compile time spell- checking is less error prone  - you can use reflection for Digester O-R persistence etc.  - easier to understand and read  - enforces strong type checking But I think we must use a combination of both Why If I set certain parameters on a high level like HttpClient it must be able to pass them down to the Methods it executes. But I don t want getters setter for Method properties in HttpClient. How Make getters setters in those classes where the parameter is evaluated only. This may be in more than one class just think of HTTP version if classes are only loosely coupled. Higher level classes like HttpClient must take generic parameters and configure the objects it uses. Use a parameter object and not just an interface. This enables us to pass sets of parameters along to other classes. Those are my recommendations. Feel free to criticise them. Yet more thoughts on generic vs. specific configuration objects... If you use generic configuration you will probably look up a property like use HTTP 1.1 or follow Redirects once and then store them in an attribute of the object that did the lookup. When I suggested configuration objects my idea was to remove these attributes from the class that needs to be configured. Instead of using a local configuration attribute it accesses the configuration object every time the value is needed. Used that way type conversion on every access becomes a real penalty. Ortwin default configuration objects could be configuration values themselves. Instead of finding a method s configuration parameters individually in the parameters for the HttpClient you could use a single setter and getter  void setDefaultMethodParams HttpMethodParams  HttpMethodParams getDefaultMethodParams The generic extension mechanism can be a getter and setter for a HashMap named customParameters in each parameter class. cheers   Roland Parameter classes could be inner classes. What about considering an existing configuration tool like the Configuration project from the Jakarta Sandbox OdiAll right. We all seem agree to disagree at this time. If do not move on we will get nowhere. I suggest the following I provide a second draft that will attempt to incorporate those ideas that we all more or less in agreement about HttpParam class should at this time be dealing with generic properties only. HttpClient HttpMethod specifics will be later built on top of it. We all yet have to come an agreement as to how exactly it is to be implemented. Configuration file discovery mechanism is inherently evil and should be banished to the contrib package for eternity. OlegCreated an attachment id 8082 Patch take 2 With property file gone things got surprisingly easier. The new patch should address a lot of concerns expressed above. Please give me your feedback. OlegHi Oleg I m glad you decided to take another stab at this. This version has some definite improvements and I think I can see the light at the end of the tunnel now. Specifics below  - Removing the reliance on the properties and string based values was an excellent idea. This greatly simplifies things and makes the process of loading defaults separate. Nice.  - To replace the loading of defaults from properties I think we need an HttpParamsFactory. This would replace the static GLOBAL DEFAULTS. HttpParamsFactory would have a plugable mechanism for defining the default params. Things like the static initializer in HttpMethodParams could be moved there.  - Are isParameterFalse and isParameterTrue necessary Seems like getBooleanParameter should be enough  - All of the various PROTOCOL STRICTNESS PARAMS should be broken out to individual methods I think.  - Once parameters have methods for getting setting them I do not think the public param Strings for them are required. Again nice work. Mike - To replace the loading of defaults from properties I think we need an HttpParamsFactory. This would replace the static GLOBAL DEFAULTS. HttpParamsFactory would have a plugable mechanism for defining the default params. Things like the static initializer in HttpMethodParams could be moved there. Mike I just do not see how this can work without resorting to system properties. How are you planning to initialize the factory class I think that any properties persistence mechanism can simply feed the GLOBAL DEFAULTS with the values retrieved from a persistent storage. Is class factory pattern really necessary in this particular case. Probably I just can t see an elegant way of implementing it. Give me a gentle push in the right direction. - Are isParameterFalse and isParameterTrue necessary Seems like getBooleanParameter should be enough True but I just felt isParameterTrue isParameterFalse required one parameter less and were a bit more readable. I do not mind removing them though. - All of the various PROTOCOL STRICTNESS PARAMS should be broken out to individual methods I think. I have to disagree. In my opinion it would create too much clutter. But again if the majority favours this approach I ll happily oblige. OlegHello Oleg I m currently stuck at a customer site and can dial in only occasionally. Since I m unable to browse through the source could you consider the following two use cases 1. A servlet class is instantiated multiple times with different config but in the same classloader context. Can different instances of the servlet create HttpClient instances with different parameters 2. A framework uses HttpClient and has it s own mechanism for defining properties. How tricky is it to pass the properties - once they are loaded - to the Http Client Loading the set of default properties should be initiated by the application. I don t see a need for an automatic loading mechanism or automatic selection of an HttpParamsFactory. Make it a one-liner to choose a factory and delegate that responsibility to the application or the framework that is using the Http Client. cheers   Roland 1. A servlet class is instantiated multiple times with different config but in the same classloader context. Can different instances of the servlet create HttpClient instances with different parameters Of course What would my patch be worth otherwise It is still up to you to decide if you want your HttpClient instances to share the same global defaults. One can simply set HttpClient getParams setDefaults null to make it disregard global defaults. 2. A framework uses HttpClient and has it s own mechanism for defining properties. How tricky is it to pass the properties - once they are loaded - to the Http Client Allow me to try to explain that with the following pseudo-code snippet Select either global HttpParams or HttpClient s params or HttpMethod s params HttpParams params GLOBAL DEFAULTS Or HttpParams params httpClient.getParams Or HttpParams params httpMethod.getParams while storage.hasMore   storageitem storage.getNext   String paramName storageitem.getName   Object paramValue storageitem.getObject   params.setParameter paramName paramValue This may look trivial but at the moment I can t see why we would want something more complex. I still would like to know though what Mike has got on his mind with the HttpParamsFactory Cheers OlegCreated an attachment id 8109 Patch HttpParamsFactory The attached patch contains a quick implementation of what I had in mind with regard to a HttpParamsFactory. The main purpose is to consolidate all of the initialization of the HttpParams to a single configurable location. I see the benefits of this approach as the following  - Initialization of HttpParams is localized and formalized. The method for specifying a new initialization routine is clear and easily modifiable.  - Creation initialization of the default HttpParams is not necessarily a one time occurrence. Since HttpParamsFactory.getDefaultParams is called every time the default params are requested the defaults could be completely static new for every call or perhaps created on a per-thread basis. The choice is up to the implementor. We would most likely just provide the default static initialization factory. Overall I think this approach buys us some nice flexibility with little overhead. What do you think Mike Mike I like the patch even though it makes things more complex than absolutely necessary. I agree with you though that greater flexibility makes it well worth paying the price. I ll incorporate your changes into the new patch which I intend to submit tomorrow. OlegCreated an attachment id 8137 Patch take 4 The forth revision of the patch incorporates Mike s code with some minor variations. As far as I am concerned that looks pretty much like it. What do you think OlegI think it s ready to commit. I m anxious to get in there and start using it. The only change I would suggest it to move all of the params classes to a new params package. MikeMike I just could not get Eclipse to create a patch with HttpParams classes in org.apache.commons.httpclient.params package. I ll move them back before committing the patch. If no objections raised by tomorrow 22 00 GMT I ll commit the patch. OlegSounds good to me. MikePatch committed. I am leaving the bug report open until javadocs for new classes are provided and references to deprecated methods removed. OlegCreated an attachment id 8239 Javadocs more configuration items. This patch adds some javadocs makes use the default connection manager config and moves date parser formats to a configuration item. Please take a look. MikeMike The patch looks good to me. Wouldn t it be better though if java.util.Collection or java.util.Set were used to store multi-value parameters I suppose in that way multi-value parameter would be easier to deal with. Imagine if one wanted to add an additional DateFormat to the standard set of DateFormats. That would require quite a bit of ugly code with the current implementation I think. Cheers OlegOleg I heartily agree. A collection makes much more sense than an array. I will make this change and apply the patch. MikeHi folks my apologies for taking so long to look into this again. The current architecture is definitely useful so take these comments as something that might just as well end up on the lower end of some to-do list - There are two things I m not quite happy with 1. Taking HttpClient as an example I m missing a constructor    HttpClient HttpClientParams    I really want a way to instantiate classes without triggering    the properties loading mechanism at all. Second best would be a    setParams HttpClientParams so I can simply copy the params    of another client. Ok the copying idea makes more sense using    HttpMethodParams and HttpMethodBase as an example - 2. From a design point of view shouldn t HttpMethodParams better    be an attribute than a base class of HttpClientParams    Since that would require parsing properties into different    params objects I don t really think it s worth the effort.    I just want to put it up for discussion. cheers   RolandHaving thought about it again I now realize my misconception in point 2. HttpMethodParams and HttpClientParams are rather independent classes. Shouldn t they both be derived from DefaultHttpParams directly Hi Roland. Welcome back. 1. Taking HttpClient as an example I m missing a constructor HttpClient HttpClientParams I really want a way to instantiate classes without triggering the properties loading mechanism at all. Second best would be a setParams HttpClientParams so I can simply copy the params of another client. Ok the copying idea makes more sense using HttpMethodParams and HttpMethodBase as an example - Addition of HttpClient HttpClient HttpClientParams sounds reasonable. We might need to make DefaultHttpParams cloneable which would be a good thing to do anyways HttpMethodParams and HttpClientParams are rather independent classes. Shouldn t they both be derived from DefaultHttpParams directly Any of parameters relevant on the HttpMethod level should also be settable on HttpClient level when applicable of a number of methods IMO. Off course there is no real need for extends relationship between HttpClientParams and HttpMethodParams other than for reusing a few methods OlegHello Oleg Any of parameters relevant on the HttpMethod level should also be settable on HttpClient level when applicable of a number of methods IMO. So you want to use the same params object for the client and methods or use the client params object as default for the methods object. Sounds good to me. Keep the hierarchy as it is. Addition of HttpClient HttpClient HttpClientParams sounds reasonable. We might need to make DefaultHttpParams cloneable ... Right no-one should use the same params object for multiple clients or methods and expect setters to be invoked without side effects. That should be made clear in the JavaDocs for the constructors that accept params objects. It would surely be useful if all params objects were cloneable. I d say that on cloning a params object should copy the parameters it holds locally but keep the same reference for the default params. No need to clone defaults since they are accessed read-only. While you re at it can you add an implements Serializable as well I don t know what it would be good for but maybe someone someday wants do deserialize params objects in an HttpParamsFactory. regards   Roland Right no-one should use the same params object for multiple clients or methods and expect setters to be invoked without side effects. That should be made clear in the JavaDocs for the constructors that accept params objects. I agree this could cause some strange problems. Is there even a case to share the same instance of a params object between multiple methods clients If not perhaps the constructor should always make copies. It would surely be useful if all params objects were cloneable. I d say that on cloning a params object should copy the parameters it holds locally but keep the same reference for the default params. No need to clone defaults since they are accessed read-only. Sounds like a good idea. I would suggest a copy constructor along with instead of Cloneable as cloning can be a little ugly. While you re at it can you add an implements Serializable as well I don t know what it would be good for but maybe someone someday wants do deserialize params objects in an HttpParamsFactory. Agreed. MikeHello Mike Is there even a case to share the same instance of a params object between multiple methods clients If not perhaps the constructor should always make copies. I intend to create params objects from my servlets s configuration and to use them to create all methods affected by that configuration. The idea of having a constructor that accepts a params object was to avoid creating default params that get replaced immediately afterwards. Copying params in the constructor would leave me without a chance to avoid additional object creation even though the one I pass in is exactly the one I want to be used by the method. I would suggest a copy constructor along with instead of Cloneable as cloning can be a little ugly. Good point. I support along with . Cloning has the advantage that you do not need to know the exact class of the object you re dealing with. Hello Roland I intend to create params objects from my servlets s configuration and to use them to create all methods affected by that configuration. The idea of having a constructor that accepts a params object was to avoid creating default params that get replaced immediately afterwards. Copying params in the constructor would leave me without a chance to avoid additional object creation even though the one I pass in is exactly the one I want to be used by the method. Sounds like a good enough reason to me. MikeI ll be working on a patch this weekend that will incorporate the suggested improvements among other things. OlegCreated an attachment id 8311 Follow-up patch 1 take 1 Changelog - Ability to deep clone DefaultHttpParams and its sub-classes - HttpClient constructors that accept custom parameter set - Complete javadoc Let me know what you think OlegHello Oleg 1. public HttpClient HttpClientParams params Can we add something like HttpConnectionManager.setParams p I think the newly created connection manager should have a chance to learn from the parameters how many connections it is supposed to create and such stuff. 2. DefaultHttpParams.clone I believe the clone method is a little too smart. Think of the most common and simple case. You implemented an awfully complex way to clone objects of classes String Integer Long Boolean and so on all of which are serializable and non-modifiable classes that do not need to be cloned at all. I suggest the simple approach clone the collection but not it s elements and tell folks they shouldn t put complex objects in there. In case of stored arrays such as for the date formats a new array has to be created when the old one is supposed to be modified. If a parameter object cares about whether it needs to be cloned or not then it implements way too much logic to be a parameter object. Otherwise it s peachy - cheers   Roland 1. public HttpClient HttpClientParams params Can we add something like HttpConnectionManager.setParams p HttpParams-enable HttpConnection HttpConnectionManager is the next item on my list. 2. DefaultHttpParams.clone I believe the clone method is a little too smart. Think of the most common and simple case. Actually I spent a healthy part of my last weekend studying different approaches to object cloning in Java. General sentiment is that java.lang.Object clone and java.lang.Cloneable are just plan broken. There are enough folks out there who believe that object serialization is the only way to go. I am a bit reluctant to put constraints on type of objects that may be used as parameter values as there s always a chance that we may overlook a legitimate use pattern. I would also prefer to use Collection classes instead of arrays as things may turn ugly if one wanted for instance just to add one additional DateFormat to the standard set of DateFormats. All that array content juggling can get a bit messy I agree my clone method does appear to be an overkill but that was the only approach which I felt was robust enough to handle all sorts of cases without running a risk of screwing things up in a subtle way. Anyways I do not mind having a simpler method but first of all we need to agree on what type of objects we should allow as parameter values. My opinion that we should allow all Cheers Oleg Hello Oleg first let me define the term s I ll use in this posting params object instance of DefaultHttpParams or one of it s subclasses parameter object an object stored in a params object To me a parameter object represents a value. The value may be simple or structured but it is accessed read-only by the HTTP client. The parameter object may change it s value asynchronously but such change is never effected directly by the HTTP client. Params objects may be modified by the HTTP client namely by the setter methods that store the set values in the params object. However such change is always an addition replacement or removal of a parameter object never a modification of an existing one. Furthermore the HTTP client never implicitly clones params objects. Under these assumptions there is no need to make copies of parameter objects from the HTTP client s point of view as they are read-only. An application programmer who uses parameter objects with changing values may have a need to control whether the same object or clones are stored in different params objects. However as the HTTP client does not create clones implicitly the application programmer has full freedom to clone all parameter objects that require cloning whenever params objects are prepared. Cloning may be controlled explicitly by replacing copy-by-reference entries in a cloned params object or the params classes can be derived to clone specific entries. It is none of the HTTP client s concern. Makes sense to me. I ll simplify the DefaultHttpParams clone method and post a new revision of the patch shortly. OlegCreated an attachment id 8313 Follow-up patch 1 take 2 DefaultHttpParams clone updated to incorporate Roland s feedback. OlegOleg I like it. Mike there is no copy constructor right now. As it would have the same signature as the constructor that takes default parameters I suggest to leave it that way. Oleg I agree it looks good. Roland I noticed the lack of copy constructor as well. As you point out it would conflict with the default params constructor. Just having clone is good enough for me. MikeAll right then. I ll commit the patch around 22 00 GMT if nobody objects OlegFollow-up patch 1 take 2 committed. OlegCreated an attachment id 8429 Follow-up patch 2 take 1 Changelog Massive cleanup of deprecated methods HeadMethod class changed to take advantage of the new preference architecture EntityEnclosingMethod class changed to take advantage of the new preference architecture Let me know what you think OlegLooks good to me. MikeFollow-up patch 2 take 1 committed. OlegCreated an attachment id 8543 Follow-up patch 3 take 1 Changelog - HttpConnection HttpConnectionManager classes updated to take advantage of the new preference architecute. Let me know what you think OlegCreated an attachment id 8609 Follow-up patch 3 take 2 New patch adds receive buffer size parameter for HttpConnection and HttpConnectionManager classes. Folks any feedback on the follow-up patch 3 so far OlegOleg These changes look good. I have only one question. Why does HttpConnection now have setSoTimeout and setSocketTimeout MikeMike I agree it s ugly. The problem is there are situations when read timeout must be changed on an open socket when handling 100-continue handshake The choice here is between two evils either make HttpConnectionParams tightly coupled with HttpConnection or Socket object or to provide a way to set read timeout on Httpconnection directly. If you see a more elegant way of solving the problem give me a hint OlegOleg Ah. I see what you are doing. This seems like a decent solution nothing better comes to mind. To keep things consistent I think setSoTimeout int should still set the timeout on the socket if present. The new Javadoc link on setSoTimeout should be changed to setSocketTimeout . Other than that I think it s good to be committed. MikeFollow-up patch 3 committed. I am planning to submit one more hopefully the final follow-up patch shortly OlegCreated an attachment id 8679 Follow-up patch 4 take 1 Changelog - The patch removes those HttpClientParams parameters that are better served by the HttpConnectionManagerParams - MultiThreadedHttpConnectionManager specific parameters changed to take advantage of the new preference architecture Do you think that the following parameters should be deprecated MultiThreadedHttpConnectionManager getMaxHostConnections MultiThreadedHttpConnectionManager setMaxHostConnections MultiThreadedHttpConnectionManager getMaxTotalConnections MultiThreadedHttpConnectionManager setMaxTotalConnections OlegOleg A few comments - I think the connectionManagerTimeout should be left on the HttpClient. The value is used by HttpClient HttpMethodDirector when retrieving connections and not directly by the connection managers. In fact this seems to be causing a compile error in HttpMethodDirector which was initially undetected by Eclipse for some reason. - What happened to the soTimeout option I agree MultiThreadedHttpConnectionManager maxHostConnections and maxTotalConnections should be moved to preferences and deprecated. MikeCreated an attachment id 8734 Follow-up patch 4 take 2 - What happened to the soTimeout option Mike I do not quite get what is the point of your concern hrere. Socket read timeout has been moved to HttpConnectionManagerParams. I believe that is where it should be. Let me know what you think about the new patch OlegOleg Perhaps I m missing something but I don t see the soTimeout option on the HttpConnectionManagerParams. MikeMike HttpConnectionManagerParams inherits SO TIMEOUT TCP NODELAY SO RCVBUF SO SNDBUF parameters along with several others from HttpConnectionParams. Do you see any problem with that OlegOleg You are quite right. Somehow I seem to have missed that I agree I think HttpConnectionParams is the right place for soTimeout et al. The patch looks good to me. MikePatch committed. It looks like the journey is finally over. Oleg
