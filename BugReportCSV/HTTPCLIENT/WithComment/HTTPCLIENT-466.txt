URI.parseUriReference treats strings with leading as absolute URIs with zero-length scheme
URI.parseUriReference treats strings with leading as absolute URIs with a zero-length scheme. If you then try to derelativize such a URI against a base URI you just get the same URI with leading . IE and Firefox treat URI strings with a leading as relative URIs. For example an HREF of foo in the context of base URI http www.example.com path page would derelativize as http www.example.com path foo . Only if another character comes before the colon is it interpreted as a URI scheme. It d be desirable for HTTPClient URI to do the same thing. Example code to demonstrate import org.apache.commons.httpclient.URI URI base new URI http www.example.com path page URI rel1 new URI foo boo System.out.println new URI base rel1 .toString displays just foo A potential fix would be for URI.parseUriReference to avoid interpreting a in the zero position as indicating a zero-length scheme - if atColon 0 atSlash 0 atSlash atColon if atColon 0 atSlash 0 atSlash atColon and - if at length tmp.charAt at if at 0 at length tmp.charAt at The colon is a reserved character which means it may or may not have to be escaped depending on where it occurs. RFC 2396 includes the following statements section 2.2 page 7    ... If the data for a URI component would conflict with the    reserved purpose then the conflicting data must be escaped before    forming the URI. bottom of page 16 top of page 17    Authors should be aware that a path segment which contains a colon    character cannot be used as the first segment of a relative URI path     e.g. this that because it would be mistaken for a scheme name.    It is therefore necessary to precede such segments with other    segments e.g. . this that in order for them to be referenced as    a relative path. An application with a user interface such as a browser has to deal with non-standard input and may interpret data in the way that is most likely to make sense. For HttpClient however it is desirable - and essential - that data gets interpreted as stated in the relevant specifications. Though the WWW seems to be guided by what a particular browser does rather than by specifications we strive to set an example within our domain -   cheers   RolandSince zero-length schemes are illegal the current behavior results in a nonsensical construction an ostensibly absolute URI with a zero-length scheme . That s not a legal URI. I don t see any inherent conflicts with the referenced specification sections. In particular there is no conflict with the colon s reserved purpose when a colon is in the first position because zero-length schemes are illegal thus the colon cannot be a scheme-delimiter. Similarly the should be aware paragraph posits a mistaken impression that is actually impossible if you are enforcing non-zero-length scheme names. So its prescription is more reasonably understood as applying to path-segments where the colon appears after the first position as in the example given in the text. Harmonizing HTTPClient URI behavior with browser behavior is just as consistent with the specifications and would avoid creating instances with nonsensical scheme-parts which are not legal absolute URIs. I believe the browsers in this case have implemented the most reasonable interpretation of the spec.Gordon you are asking for robustness against a specific spec violation that occurs in real-world applications. I am in favour for making HttpClient more robust against such things. We should think carefully if we want to include this fix into the URI class thus intelligently breaking the spec or leave it to the caller to comply to the spec. Ortwin Glück Authors should be aware that a path segment which contains a colon character cannot be used as the first segment of a relative URI path From my point of view a path segment contains a colon if any one of it s characters is a colon. Including the first one. But section 3.1 of RFC 2396 states Relative URI references are distinguished from absolute URI in that they do not begin with a scheme name. which supports your interpretation and that of the browsers. cheers   RolandGordon just out of curiosity where is this URL coming from Are you extracting it from a HTML page Does the user enter it A typo on some page somewhere a stray extra in front of a true absolute http URI triggered a bug reported against our crawler. See   http groups.yahoo.com group archive-crawler message 1894 We have a httpclient.URI subclass UURI which enforces additional cleanup on URIs and our deserialization of such instances was being thrown off by receiving URI strings that should have already been derelativized beginning with colons. Further investigation revealed that any HREF starting with a colon was interpreted as absolute by httpclient.URI but relative by the browsers. Thanks for your consideration When I rethink it I d rather see this fixed on your side Gordon. I don t think HttpClient is the right place to fix the problem. It seems that a URL like this has an ambiguous interpretation  1. colon is part of the path name perfectly legal in Unix and should be URL escaped  2. no scheme and thus invalid I d rather not have heuristics inside a class that implements a spec. Better feed well-defined input to the URI class and get well-defined output back than have URI to guess what your input could possibly mean. I recommend marking this bug as invalid.Hello Odi generally the colon does not require URL-escaping when used in a path component. It only needs to be escaped if there is an ambiguity whether it is part of a path in a relative URL or the scheme separator in an absolute URL. I can understand Gordon s argument that there is no such ambiguity when the colon is the first character. cheers   RolandI read RFC-2396 again. Roland you are right. Point taken. So we need to include some test cases into the suite and see if Gordon s patch does what it should.Definitely it s an ambiguous case. But given that the class has to do something when presented with such input I think two relevant questions would be 1 Is the current behavior desirable I don t think so. Interpreting a potential URI foo as an absolute URI results in an illegal uninterpretable URI. I think this is highlighted by the example in my initial report new URI new URI http www.example.com path page new URI foo .toString Having this return foo causes the nonsensical interpretation to spread to another instance losing the original context . In contrast having this return http www.example.com path foo means the only possible legal URI has been made from an ambiguous situation. It would in my opinion be better to raise an exception than have the current behavior. Then wrapping code could note the problem and attempt a workaround like encoding or prepending a . to force path-interpretation. But then that would force the question is foo definitively prohibited by rfc2396 section 5 or rfc3986 section 4.2 or is it simply a case not contemplated by its language 2 Is there any situation where the current behavior or alternatively raising an exception would be preferable to the suggested behavior of treating URI-strings that begin with a as relative references I can t think of any such situation save for a hypothetical pedantic URI-format checker which would not want the current behavior but rather a warning of some sort that an ambiguous case has been encountered. Short of that while I d agree harmonization with browser behavior is not all-important it is very valuable unless there s a clear justification to do otherwise. Any ambiguous URI-writing practice that nonetheless works in browsers is likely to persist.Sidenote Don t compare HttpClient with web browsers as HttpClient is not a browser. We are trying to implement a standard. While we must be relaxed in some areas of this standard to be compatible with real-world servers we are very strict when it comes to API level. This means that the only criteria to make a fix for this problem is whether foo can be interpreted unambiguously or not.I would suggest that web browser behavior is a valid and important source of input along with formal specifications. 1 While HTTPClient is not a web browser one of its key uses is in creating web browsers and stand-ins for web browsers like crawlers . Indeed the HTTPClient project home page when listing examples of HTTP-aware client applications that may find HTTPClient of interest lists web browsers first. 2 While HTTPClient is not a web browser all web browsers are themselves HTTP client applications. Their behavior in aggregate establishes what users and server app developers expect. The major browsers individually and all browsers together as a class have much more developer and user attention and QA and usability testing than HTTPClient and so often encode within their established practices a lot of hard-won wisdom about the most beneficial and broadly-compatible interpretation of specs. In a case like this where the specs could plausibly be read more than one way browsers are likely to have encountered the ambiguity and forced the issue one way or the other first. 3 There are both standards from formal specs and de facto standards that emerge from consensus practice even if never formally specified. Both are important and in the HTTP domain web browsers are the major force in establishing the de facto standards. A library that only implements the formal standards is interesting for some purposes but not others. 4 HTTPClient s compatibility mode for cookies already emulates browser tolerance of nonstandard server app cookie formats so that servers see what they would expect to get on followup hits from widely-deployed browsers. That same pragmatic approach of accomodating the browser lead would make sense here. For example if a web page specifies a background image as relative URI bg.jpg and popular web browser http client software like IE and Firefox both resolve this relatively and display it properly and they do that should factor in for how HTTPClient decides to interpret such URIs even if some wordage in the specs suggest another way. I m not saying browser behavior trumps all other considerations but it should not be ruled out as one valid and pragmatic criterion.Gordon I don t want to extend this discussion of the goals of the HttpClient project. We should focus around this specific issue here this is an issue tracking system and not an evangelist forum . In short 1 and 2 are obviously right 3 is somehow true and out of question. The first paragraph of 4 i have already explained we support non-standard servers to some extent . The second paragraph is a problem Yes I know that major browsers interprete this in a certain way. They all deal with poorly written HTML which is mostly off standards in vast areas on the internet. HttpClient is really not a browser . People use it to do Webservices or XML-RPC. HttpClient does not have to fix broken HTML links. We don t care about HTML at all . All we do is HTTP . Parsing HTML is up to you . Fixing broken HTML code and broken URLs in that code is up to you . Feed correct URIs to HttpClient and it will work fine. Moaning does not help. I explained the criteria for this issue to be fixed in HttpClient. More I can not do for you unfortunately. Even if this does not make you happy. Sorry mate.I certainly agree that HTML fixup is out of HTTPClient s purview the issue is URIs an area where HTTPClient has provided a very capable implementation class which works well for URIs far afield of HTTP too . Now a particularly important kind of http client the web browser gets most of its URIs through HTML but that s just an illustrative example. The questionable URI foo which is at least plausibly legal could be interpreted with an absolute base context from XML or CSS or HTTP headers or something else entirely. I ve already worked around the issue. BTW thanks for making the HTTPClient URI class so much easier to derive from than the imho fatally flawed java.net.URI. So I m happy no matter how this issue is dispatched. I m just making an appeal for giving some nonzero weight to the wisdom encoded in widespread web browser practice when deciding what to do in these kind of situations. In this particular case I think web browser practice clearly points the way to most useful practical spec interpretation. That might not always be the case but I would think either congruence or contrast with IE Firefox practice would always be an interesting data point when deciding desired behavior. Enough said thanks for your consideration.I am a little bit surprised that this discussion has moved away from the original problem.        Basically in this case the browsers are in fact conforming to the RFC whereas HttpClient is not.    Empty schemes are simply not allowed see BNF in Appendix A of RFC 2396 so treating foo as an URI with empty scheme and opaque part foo is incorrect per se. According to the BNF it MUST NOT be treated as an absoluteURI.           On the other hand a is a perfectly valid path segment see the BNF and section 3.3 of the RFC . I do not see any ambiguity here.    Let s apply Gordon s patch.    Christian  Most of those so called common browsers for instance accept virtually any garbage for a cookie in order to be compatible with thousands of broken CGI scripts out there. So in general I personally do not think the behavior of browsers should be used as the most common denominator. In this particular case however HttpClient clearly doesn t handle the URI in question correctly. I am 1 to commit the patch. OlegCreated an attachment id 15282 Patch Christian it is all getting very redundant here. I have already pointed out in comment 5 that I am 1. I was just making my point clear what the criteria is to include this patch. The criteria is fulfilled apparently. Patch and test case attached.Looks good to me. OlegPatch away. Mike
