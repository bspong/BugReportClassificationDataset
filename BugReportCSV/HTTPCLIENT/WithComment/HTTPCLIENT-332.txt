Connection timeout logic redesign
Changelog CreateSocket method with timeout parameter added to the ProtocolSocketFactory interface TimeoutController related code factored out of HttpConnection class and moved into ControllerThreadSocketFactory helper class ReflectionSocketFactory helper class added. This factory encapsulates reflection code to call JDK 1.4 Socket connect method if supported All protocol socket factories now attempt to initially use ReflectionSocketFactory if required to create a socket within a given limit of time. If reflection fails protocol socket factories fall back onto the good ol ControllerThreadSocketFactory Benefits HttpConnection code got a lot cleaner When running in modern JREs expensive timeout controller thread per connection attempt is no longer needed Ugly code intended to work around limitations of the older JREs is now confined to a few helper classes that can be easily thrown away once we move onto Java 1.4 Let me know what you think OlegCreated an attachment id 11204 Patch take 1 Hi Oleg I like the changes. This is definitely the way to go. I have a couple of suggestions.  - I think we should change ControllerThreadSocketFactory.createSocket to accept a SocketFactory and all the other params necessary to create the socket. This way we can hide the SocketTask from external classes. Though we would end up passing in more params I think it would make for a cleaner interface.  - We should consider changing ProtocolSocketFactory.createSocket host port ... timeout to accept a HttpConnectionParams instead of a timeout. This will allow for other config params in the future without requiring API changes.  - I think ReflectionSocketFactory.createSocket should be changed to take a SocketFactory instance instead of a socketFactoryName. This is not a major change but it seems a little cleaner to me.  - I suggest we move the bulk of the reflection work from ReflectionSocketFactory.createSocket to a static initializer. This way we can determine statically whether or not the JVM supports Socket.connect without testing each time. This may be premature optimization but my feeling is that it may be worth it. Mike I think we should change ControllerThreadSocketFactory.createSocket to accept a SocketFactory and all the other params necessary to create the socket. This way we can hide the SocketTask from external classes. Though we would end up passing in more params I think it would make for a cleaner interface. Completely agree. The trouble is that javax.net.SocketFactory is available as of Java 1.4 only. I was thinking about using ProtocolSocketFactory instead but initially decided against it as it results in a sort of logical recursion a helper class takes a class as a parameter for which it acts as a helper class. Thinking about it causes stack overflow in my brain requiring a hard reboot with a glass of malt whisky. But I ll give it another shot as it can potentially a lot of ugly code in the protocol socket factories We should consider changing ProtocolSocketFactory.createSocket host port ... timeout to accept a HttpConnectionParams instead of a timeout. This will allow for other config params in the future without requiring API changes. Great idea I think ReflectionSocketFactory.createSocket should be changed to take a SocketFactory instance instead of a socketFactoryName. This is not a major change but it seems a little cleaner to me. Same problem as in point 1 I suggest we move the bulk of the reflection work from ReflectionSocketFactory.createSocket to a static initializer. This way we can determine statically whether or not the JVM supports Socket.connect without testing each time. This may be premature optimization but my feeling is that it may be worth it. I seriously do not know what code may be moved to a static initializer unless we create a dummy socket and try calling connect on it. But to which port Am I missing something What if we just set a static flag refection failed do not try it again Oleg Completely agree. The trouble is that javax.net.SocketFactory is available as of Java 1.4 only. I was thinking about using ProtocolSocketFactory instead but initially decided against it as it results in a sort of logical recursion a helper class takes a class as a parameter for which it acts as a helper class. Thinking about it causes stack overflow in my brain requiring a hard reboot with a glass of malt whisky. But I ll give it another shot as it can potentially a lot of ugly code in the protocol socket factories Good point. SocketFactory is a part of JSSE but it may be annoying for users to include JSSE if they re not using it. This may be a lost cause. I seriously do not know what code may be moved to a static initializer unless we create a dummy socket and try calling connect on it. But to which port Am I missing something What if we just set a static flag refection failed do not try it again This is what I was thinking     private static boolean connectSupported     private static Constructor insetSocketAddressConstructor     private static Method connectMethod          static         try             Class addressClass Class.forName java.net.InetSocketAddress             insetSocketAddressConstructor addressClass.getConstructor                 new Class String.class Integer.TYPE             connectMethod Socket.class.getMethod connect                 new Class Class.forName java.net.SocketAddress Integer.TYPE             connectSupported true          catch Exception e              1.4 socket connect method not supported             connectSupported false               Inside createSocket we could just test connectSupported instead of trying the reflection. We can also reuse the Constructor and Method to avoid looking them up again. MikeCreated an attachment id 11217 Patch take 2 How about this Let me know what you think. OlegI would suggest caching the references to the method and constructor objects. In 1.3 VM s that s a 3 1 performance difference. In 1.4 it s still a 2 1 performance improvement. http jguru.com faq view.jsp EID 246569 jdk1.3.1 06 bin java -cp . PerformanceTest 100000 regular method calls 219 milliseconds. 100000 reflective method calls without lookup 281 milliseconds. 100000 reflective method calls with lookup 954 milliseconds. jdk1.4.2 bin java -cp . PerformanceTest 100000 regular method calls 282 milliseconds. 100000 reflective method calls without lookup 328 milliseconds. 100000 reflective method calls with lookup 625 milliseconds. MohCreated an attachment id 11218 Patch take 3 Fair enough. So how about this OlegA tiny detail but a possibly confusing one for people reading the code the comments in ReflectionSocketFactory that explain what the reflection code is doing don t include the step that uses SocketFactory.getDefault . This confused me mostly because getDefault was static and I didn t realize that it was expected that each subclassed SocketFactory would implement it s own getDefault behaviour. It also seems a bit odd to use the String equality to test for an exception of SocketTimeoutException. Perhaps now that the classes are being statically cached a SocketTimeoutException.class could be created and the catch clause could use SOCKETTIMEOUTEXCEPTION CLASS.isInstance cause .Hi Sam First of all thanks for inspiring me to fix this problem and donating initial reflection code doing don t include the step that uses SocketFactory.getDefault . This confused me mostly because getDefault was static and I didn t realize that it was expected that each subclassed SocketFactory would implement it s own getDefault behaviour. AFAIK SocketFactory getDefaut is the only standard way to instantiate a socket factory. Therefore I thought this step required no explanation. Fixed now It also seems a bit odd to use the String equality to test for an exception of SocketTimeoutException. Fair enough. Fixed. Patch coming. Oleg Created an attachment id 11219 Patch take 4 Looks good to me except for some JavaDocs problems. The docs for ReflectionSocketFactory.createSocket and the ProtocolSocketFactory.createSocket are out of date. MikeFolks Any further remarks If nobody objects loudly I ll fix javadocs and commit the patch within next 4-5 hours. If any problem pops up later it can always be addressed with a corrective patch OlegPatch committed. Oleg
