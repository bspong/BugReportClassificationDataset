cache revalidation of variants does not update original variant entry
When the cache stories multiple variant entries due to Vary headers in responses the cache correctly sends a conditional request containing the etags of any existing variants on a variant miss incoming request does not match the request variants already cached . In addition when it receives a 304 response it correctly returns the indicated variant to the request that causes the variant miss. However it does not update the pre-existing variant cache entry as recommended by RFC 2616. For example request 1 User-Agent agent1 results in a 200 OK with Etag etag1 and Vary User-Agent. request 2 User-Agent agent2 causes an If-None-Match to the origin if it returns 304 Not Modified with Etag etag1 request 3 User-Agent agent1 results in a 200 OK but gets the outdated entry that resulted from request 1 in other words the origin response from request 2 does not update the variant for agent1 . This does not cause incorrect behavior this is a SHOULD but does miss out on some caching opportunities here. Attached is a patch with a unit test that exposes this bug. I think this is related to the way we store and manage variants. Right now we create a cache key for a variant based on the varying headers from the original request and then store these cache keys on the parent entry. I think this combines two items which should be separated 1. which cache entries are variants of a parent entry 2. which variant should be used for a particular set of request headers I think this might be as simple as turning the Set String variantURIs on the parent cache entry into a Map String String that maps request header values using the scheme we currently use to generate the variantURI cache keys to particular cache locations. Thus in the example above rather than storing a new variant entry we should simply point requests with User-Agent agent2 to the cache entry for the agent1 response. Thoughts Jon Can this be done without breaking API compatibility OlegOleg I m in the process of figuring that out by creating a patch that fixes it. My suspicion is that we can do this without breaking API compatibility although it might mean keeping around methods that don t get used by the main implementation anymore. For example HttpCacheEntry getVariants that just returns a Set will probably be deprecated although will still work and we ll be using HttpCacheEntry getVariantMap instead going forward. Jon That s perfectly all right. Go for it. OlegWith this change do you think it would be possible to also have cache entries self identify ie adding HttpCacheEntry getURI . Under the current system there is a one to one mapping of variant URI to cache entry but it seems the proposed change would make it many to one. I had run into this situation while developing the stale-while-revalidate patch which uses the variant URI to uniquely identify a cache entry. The change wouldn t necessarily break this patch assuming it is commited but could cause unnecessary revalidations. If this is too much trouble I am sure there will be other ways to derive the unique key an entry is stored under it just might require some repetition. Any thoughts - MichajloIssue fixed and patch with test committed which now passes .
