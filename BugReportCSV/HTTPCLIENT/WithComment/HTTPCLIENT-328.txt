Proxy tunneling auth with CONNECT for non-HTTP protocols
HttpClient would be even more useful if it supported connections tunneled through proxies and proxy authentication for non-HTTP protocols. E.g. Binary protocols such as SSH or JXTA-TCP could be tunneled through a web proxy if HttpClient provided access to the underlying Socket after the negotiations auth CONNECT with the web proxy were complete.Created an attachment id 11098 Source code mods implementing proxy tunneling auth for non-HTTP Mike Are these changes against CVS HEAD or HTTPCLIENT 2 0 BRANCH It would simplify and speed up the review process substantially if you submit the patch in diff -u format. http www.apache.org dev contributors.html patches Also consider providing a sample application to demonstrate the use of this feature. The demo should go into src examples directory http cvs.apache.org viewcvs.cgi jakarta-commons httpclient src examples only with tag HTTPCLIENT 2 0 BRANCH OlegCreated an attachment id 11110 Patch to HEAD to provide access to the Socket after CONNECT. Must still manually add NullMethod.java from initial src zip Created an attachment id 11111 Src files for an example of using HttpClient to tunnel non-HTTP. Warning compiled but not tested. Based on tested code tho. Oleg I based my changes patch on the HEAD rev. Hope this isn t too big of an inconvenience to get this stuff into the next stable release. I don t think the rcs variables that have different values in the patch file will cause any problems. They should be replaced upon checkin checkout. Also the patch src files contain the obligatory this file is different from the original Apache version notice which should probably be nuked before checkin. As you will notice the way the Socket is detached in not the most efficient in that HttpClient creates various input stream wrappers etc. that will be discarded. Something to consider if re-factoring work goes on later. The goal of this change was to disturb as little as possible... MikeMike I believe I might have a different solution to this problem. It takes a little more code but on the other hand it requires virtually no modifications to the existing classes primarily HttpConnection. There s also no need to detach the socket potentially creating problems for the connection manager. Let me know what you think Oleg  Created an attachment id 11121 Patch a slightly different take on the problem Oleg That s a much nicer way of doing it. In my original solution I was concerned about detachSocket confusing the HttpConnection in fact it took me a lot of fiddling around to make so HttpConnection didn t close the Socket on me . Your solution has more code but is much cleaner so maintenance shoud be easier than with the few lines of my hack. If I understand your new code and HttpClient correctly because you use the connect method directly one should be able to control how the socket is created by using a non-secure ProtocolSocketFactory. Is this correct If so awesome Any idea about which release these changes would go into and when that release might occur Thx MikeCreated an attachment id 11131 Another patch Oleg I agree the ProxyClient is a much better way to handle this. I have made just a few changes to your patch to simplify things a little. In particular ProxyClient now makes use of the HttpMethodDirector instead of handling authentication on its own. Mike in regard to your question you are correct. You will be able to have full control over how the socket is created. The only caveat is that if you want to tunnel SSL you will need to force the proxy to connect to port 443. For example   proxyclient.getHostConfiguration .setHost SSL-host 443 If a port is not specified the protocol default usually 80 will be used. I imagine these changes will be part of the 3.0 release. Pinning down an exact ETA for 3.0 may be a little difficult. Does anyone have a particular schedule in mind MikeMike B Thanks for the clarifications. One question - you mentioned you must use port 443 in order to get http client to use SSL automatically. Is this more precisely that if you use 443 as your dst port HttpClient will use the Protocol s SecureProtocolSocketFactory to add SSL to the underlying Socket created with the DefaultProtocolSocketFactory If so then I can use port 443 without actually running SSL provided I specifiy my own No-op SecureProtocolSocketFactory. The reason this is important to me is that my goal is to tunnel jxta through web proxies with hopefully not requiring any admin port opening etc. and many proxies only allow CONNECT to go to 443 or 8443. However if the above holds it looks like if I use 443 with a No-op SPSF I still can t avoid the DefaultProtocolSocketFactory. Perhaps HttpConnection could create the initial socket for SSL via the SecureProtocolSocketFactory s non-wrapping create methods since they do not appear to be used otherwise - but may break old httpclient using code unless you watched for null and even then some may just throw. Alternatively if the DefaultProtocolSocketFactory could allow pluggable implementations then no one s existing code would break. The motivation for this is that jxta for example tries to create Sockets with a timeout whereas the use of the DefaultSocketFactory for secure connections does not. Thx MikeMike S The way things have been implemented the default socket factory is always the one that is associated with the http protocol code snip     public synchronized void setHost String host int port         setHost host null port Protocol.getProtocol http      code snip There s absolutely nothing that presents you from registering any other socket factory as http protocol socket factory. Likewise you can always register a Protocol of you own and always explicitly use that Protocol with the PtoxyClient. Mike B I have clearly overlooked the possibility of simply re using HttpMethodDirector. Ironically enough it was me how introduced the safeguard against HttpMethodDirector s recursive execution of the ConnectMethod which I had though was the reason why HttpMethodDirector could not be used I think the patch is good to be committed OlegOleg and Mike B Many thanks for getting an idea and a hack to a proper patch. To clarify all my ramblings about SocketFactories here is line of code in HttpConnection.open that concerned me code final ProtocolSocketFactory socketFactory                      isSecure isProxied                              new DefaultProtocolSocketFactory                              protocolInUse.getSocketFactory code I just wanted to be sure I could avoid the DefaultSocketFactory even if I use port 443. Looks like the solution is simply to always provide a non-Secure socketfactory so isSecure evalutates to false. Then if I want SSL on top of the tunneled socket and to avoid DefaultSocketFactory I can simply wrap the returned socket myself in the same way as done in SSLProtocolSocketFactory. Cheers Mike S.Hi Mike The DefaultProtocolSocketFactory will only be used if the specified Protocol is an instance of SecureProtocolSocketFactory. Since the SSL tunnel is never actually created by the ProxyClient there is no reason to use a secure factory. Even if one wanted to create a SSL tunnel it would have to be done manually as you mention. So you are correct. You can use whichever socket factory you like and then manually wrap the socket afterward if necessary. MikeHi Oleg I agree the patch is pretty much ready to go. The only things missing are some JavaDocs. Do you want to finish this one up or should I take care of it I don t want to steal this one from you MikeMike It s virtually all your code now so if you feel like bringing this one to a logical conclusion please do so OlegCreated an attachment id 11214 Yet another patch This patch adds some comments and a new inner class ConnectResponse. This class is used to return both the socket and connect method. The method will be useful in cases when the CONNECT fails. MikeCool. Looks good to me. OlegPatch applied. Many thanks to Mike Sample for the excellent idea. Mike
