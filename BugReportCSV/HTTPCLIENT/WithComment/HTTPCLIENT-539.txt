UserInfo disapears after creating URI
I tested this using firefox Where I have configured our proxy server I run the following URI ftp username password ftp.mytest.test testdir I use a sniffer to look at the GET commond send to the proxy server. It looks as follows GET ftp username password ftp.mytest.test testdir HTTP 1.1 Host ftp.mytest.test User-Agent Mozilla 5.0 Windows U Windows NT 5.0 en-US rv 1.7.12 Gecko 20050915 Firefox 1.0.7 Accept text xml application xml application xhtml xml text html q 0.9 text plain q 0.8 image png q 0.5 Accept-Language en-us en q 0.5 Accept-Encoding gzip deflate Accept-Charset ISO-8859-1 utf-8 q 0.7 q 0.7 Keep-Alive 300 Proxy-Connection keep-alive Using this request we get access to the directory and see the contents displayed. However when I try the same in Java using HttpClient I get the following GET request Java code included below GET ftp ftp.mytest.test testdir HTTP 1.1 User-Agent Jakarta Commons-HttpClient 3.0-rc3 Host ftp.mytest.test Proxy-Connection Keep-Alive Finally I get a ACCESS DENIED error. This seems to be because the GET request does not contain the USER PASSWORD info in the URL. JAVA CODE package nl.essent.test.ftp.httptest import java.io.IOException import org.apache.commons.httpclient.Credentials import org.apache.commons.httpclient.DefaultHttpMethodRetryHandler import org.apache.commons.httpclient.HostConfiguration import org.apache.commons.httpclient.HttpClient import org.apache.commons.httpclient.HttpException import org.apache.commons.httpclient.HttpMethod import org.apache.commons.httpclient.HttpStatus import org.apache.commons.httpclient.NTCredentials import org.apache.commons.httpclient.UsernamePasswordCredentials import org.apache.commons.httpclient.auth.AuthScope import org.apache.commons.httpclient.methods.GetMethod import org.apache.commons.httpclient.params.HttpMethodParams import org.apache.commons.httpclient.protocol.DefaultProtocolSocketFactory import org.apache.commons.httpclient.protocol.Protocol public class TestClient     public static void main String args         new TestClient .testFtpViaHttp               public void testFtpViaHttp                  HttpClient client new HttpClient                  HostConfiguration hostConfig client.getHostConfiguration         hostConfig.setProxy proxy 8080         client.setHostConfiguration hostConfig                  Protocol protol new Protocol ftp new DefaultProtocolSocketFactory 21         Protocol.registerProtocol ftp protol                  Credentials proxyCreds new NTCredentials xxxx xxxxx xxxx         client.getState .setProxyCredentials AuthScope.ANY proxyCreds                  GetMethod gmethod new GetMethod ftp username password ftp.mytest.test testdir                  gmethod.getParams .setParameter HttpMethodParams.RETRY HANDLER                 new DefaultHttpMethodRetryHandler 3 false                 try              Execute the method.             int statusCode client.executeMethod gmethod             if statusCode HttpStatus.SC OK               System.err.println Method failed gmethod.getStatusLine                           Read the response body.             byte responseBody gmethod.getResponseBody              Deal with the response.              Use caution ensure correct character encoding and is not binary data             System.out.println new String responseBody            catch HttpException e             System.err.println Fatal protocol violation e.getMessage             e.printStackTrace            catch IOException e             System.err.println Fatal transport error e.getMessage             e.printStackTrace            finally              Release the connection.             gmethod.releaseConnection                 END JAVA CODEHarm That s interesting. I wasn t aware of the possibility to pass authentication information to the actual host this way. Is this a proxy standard or a proprietary extension Does it only work for FTP URLs Even more interesting I find the fact that you are using a proxy as a bridge between FTP and HTTP. As a work-around supply the authentication information as a HTTP header instead. But I am not sure if this works for your FTP URL. I m not actually sure if this is a proxy standard . However I discovered that Total commander works in the exact same way when configured a HTTP proxy server. Also see http www.cs.tut.fi jkorpela ftpurl.html for more info on FTP URL s Created an attachment id 17254 Patch take 1 Please review and comment OlegIt duplicates some code but I have no better idea. In reply to comment 5 It duplicates some code but I have no better idea. As I said before given a choice I would not touch the URI and related classes with a barge pole. So that was the least effort quick hack I could come up with Oleg In reply to comment 4 Created an attachment id 17254 edit Patch take 1 Please review and comment Oleg I applied the patch and tested. Now everything works as expected. Thanks for the quick fix Cool. I ll check the patch in tonight. OlegPatch checked in OlegThe patches do not solve the problem. I tried with the most recent nightly build of HttpClient. No luck. The process of getting from an URI to a HttpHost loses the credentials. I ve tried patching it myself but this patch has a lot of impact.I just reviewed the patch and as far as I can tell everything appears sane. Moreover there is a unit test that tests the fix. The burden of producing a proof to the contrary rests with you. Please reopen the bug only if you can provide a test case that reliably reproduces the problem against SVN trunk OlegCreated an attachment id 17935 Test classto show the problem still exists. I ve attached a test class to demonstrate the bug. You d need a Isa proxy to test it.Oleg I ve created a patch using the code from svn. I can e-mail this to you or attach this to this bug.Tommy This is not a JUnit test. Plus it requires external servers. Please submit a JUnit test case that does not rely on external servers and does some proper assertions that show the problem. Ortwin Glück ps. Yes patches should always be attached to Buzilla issues and not be emailed to individual people. Created an attachment id 17936 Test to show the error This is a junit test to demonstrate the problem. As you can see the credentials are lost when constructing a Method. In reply to comment 16 Created an attachment id 17936 edit Test to show the error This is a junit test to demonstrate the problem. As you can see the credentials are lost when constructing a Method. This is what I pretty much expected. HttpURL is a special case and is expected to discard username password from the request URI because HTTP spec requires user credentials to be passed in the HTTP message header. Use URI class instead. OlegCreated an attachment id 17937 junit test Using URI class does not fix the problem. The test still fails. This test only tests a side effect since the real problem lies with HttpHost.getHostName . This method should return the authority in this situation.Created an attachment id 17938 new junit test to show the error in HttpHost in reaction to myself...Tommy In reply to comment 18 Created an attachment id 17937 edit junit test Using URI class does not fix the problem. The test still fails. This test only tests a side effect since the real problem lies with HttpHost.getHostName . This method should return the authority in this situation. No it should not. HttpClient is not supposed to implement FTP specific concerns. Feel free to extend the standard GetMethod class and override the default behaviour of the writeRequestLine method the way we deem appropriate for your specific application. Oleg Created an attachment id 17942 patch to add authority to httphost No it should not. HttpClient is not supposed to implement FTP specific concerns. Feel free to extend the standard GetMethod class and override the default behaviour of the writeRequestLine method the way we deem appropriate for your specific application. Oleg Thanks for you reaction but I tend to disagree. This is not ftp specific but host specific i.e. the host to connect to . Besides by registering another protocol with Protocol.registerProtocol ... it is already possible to use non-http-like protocols. The authority is a part of a host in this case a httphost using the ftp protocol just the same as it is a part of the URL. This patch adds the authority to the HttpHost. I think that the following HTTP requestline is valid GET http user pass host file.html HTTP 1.1 Therefore I think the following should be valid too GET ftp user pass host file.html HTTP 1.1 I hope you can see my point. If not at least I have a patch locally. In reply to comment 21  Besides by registering another protocol with Protocol.registerProtocol ... it is already possible to use non-http-like protocols. Ability to register a protocol socket factory does not in any way imply support for that protocol. The authority is a part of a host in this case a httphost using the ftp protocol just the same as it is a part of the URL. This patch adds the authority to the HttpHost. I think that the following HTTP requestline is valid GET http user pass host file.html HTTP 1.1 I do not think this is the case. RFC2617 clearly defines the way to transmit user credentials with HTTP messages. OlegGET http user pass host file.html HTTP 1.1 probably is a valid request at least it works with Apache HTTPD and IIS 6 but I guess the server will just discard the credentials. Anyway I don t think we should sent such request lines by default as it is likely that simple servers will choke on them. I just tried GET http user pass host HTTP 1.1 Host www.microsoft.com HTTP 1.1 200 OK Date Wed 22 Mar 2006 15 36 47 GMT Server Microsoft-IIS 6.0 P3P CP ALL IND DSP COR ADM CONo CUR CUSo IVAo IVDo PSA PSD TAINT COM INT NAV ONL PHY PRE PUR UNI X-Powered-By ASP.NET X-AspNet-Version 2.0.50727 Cache-Control private Content-Type text html charset utf-8 Content-Length 21907 DOCTYPE HTML PUBLIC - W3C DTD HTML 4.0 Transitional EN I do not think this is the case. RFC2617 clearly defines the way to transmit user credentials with HTTP messages. Oleg I am aware of the fact taht this is a rare case where a http-proxy is used to execute commands on an FTP server. There is a thread about this on the user-list where it is established that this is corretc use of http. http mail-archives.apache.org mod mbox jakarta-httpclient-user 200512.mbox browser ftp via http 21 dec 2005 . Clients like Internet Explorer Mozilla Firefox and even Total Commander support this mechanism of accessing an FTP site via a HTTP proxy. The well-known proxy Squid also supports this type of FTP proxying see http www.squid-cache.org Doc FAQ FAQ-5.html ss5.9 . It would be nice to see this sort of functionality in HttpClient. In reply to comment 23 GET http user pass host file.html HTTP 1.1 probably is a valid request at least it works with Apache HTTPD and IIS 6 but The fact that both Apache HTTPD and MS IIS do not choke on it does not make the request valid. See RFC2616 5.1.2 Request-URI ...    The most common form of Request-URI is that used to identify a    resource on an origin server or gateway. In this case the absolute    path of the URI MUST be transmitted see section 3.2.1 abs path as    the Request-URI and the network location of the URI authority MUST    be transmitted in a Host header field. For example a client wishing    to retrieve the resource above directly from the origin server would    create a TCP connection to port 80 of the host www.w3.org and send    the lines        GET pub WWW TheProject.html HTTP 1.1        Host www.w3.org Oleg The fact that both Apache HTTPD and MS IIS do not choke on it does not make the request valid. See RFC2616 5.1.2 Request-URI ... The most common form of Request-URI is that used to identify a resource on an origin server or gateway. In this case the absolute path of the URI MUST be transmitted see section 3.2.1 abs path as the Request-URI and the network location of the URI authority MUST be transmitted in a Host header field. For example a client wishing to retrieve the resource above directly from the origin server would create a TCP connection to port 80 of the host www.w3.org and send the lines GET pub WWW TheProject.html HTTP 1.1 Host www.w3.org Oleg I see that it is not according to the RFC. However since it is a common way to access for instance an FTP site ia a HTTP-proxy such as Squid or ISA I d say that this is still inconvenient that this method is not supported by httpclient. Perhaps it should not be default behaviour but it would be nice to have an option to enable this feature. Do you think that would be an option I can make a patch for this after we decide which method to use to activate this behaviour. What is your opinion on this approach In reply to comment 26 ... What is your opinion on this approach Tommy Unfortunately I do not see even a half-decent solution to this problem and I do not think this particular issue warrants an ugly hack. HttpClient 3.x code is already full of all sorts of ugly hacks and I am sick and tired of maintaining them. The next version of HttpClient will be based on a completely new API and this particular problem will no longer be relevant. Oleg 5.1.2 Request-URI ... The most common form of Request-URI is that used to identify a resource on an origin server or gateway. In this case the absolute path of the URI MUST be transmitted see section 3.2.1 abs path as the Request-URI and the network location of the URI authority MUST be transmitted in a Host header field. For example a client wishing to retrieve the resource above directly from the origin server would create a TCP connection to port 80 of the host www.w3.org and send the lines GET pub WWW TheProject.html HTTP 1.1 Host www.w3.org Oleg Oleg This is not really the case here. The credentials in the URL are NOT for the proxy server but for the FTP server. The credentials for the proxy server are sent via HTTP-Headers. When requesting a document on a site via a proxy the absolute URI should be used i.e. a URI WITH credentials. See 5.1.2 of RFC2616 5.1.2 Request-URI    The Request-URI is a Uniform Resource Identifier section 3.2 and    identifies the resource upon which to apply the request.        Request-URI absoluteURI abs path authority    The four options for Request-URI are dependent on the nature of the    request. The asterisk means that the request does not apply to a    particular resource but to the server itself and is only allowed    when the method used does not necessarily apply to a resource. One    example would be        OPTIONS HTTP 1.1    The absoluteURI form is REQUIRED when the request is being made to a    proxy. The proxy is requested to forward the request or service it    from a valid cache and return the response. Note that the proxy MAY    forward the request on to another proxy or directly to the server    specified by the absoluteURI. In order to avoid request loops a    proxy MUST be able to recognize all of its server names including    any aliases local variations and the numeric IP address. An example    Request-Line would be        GET http www.w3.org pub WWW TheProject.html HTTP 1.1    To allow for transition to absoluteURIs in all requests in future    versions of HTTP all HTTP 1.1 servers MUST accept the absoluteURI    form in requests even though HTTP 1.1 clients will only generate    them in requests to proxies. The absolute URI is defined in RFC 2369 see 3.2.1 in RFC2616 3.2.1 General Syntax    URIs in HTTP can be represented in absolute form or relative to some    known base URI 11 depending upon the context of their use. The two    forms are differentiated by the fact that absolute URIs always begin    with a scheme name followed by a colon. For definitive information on    URL syntax and semantics see Uniform Resource Identifiers URI    Generic Syntax and Semantics RFC 2396 42 which replaces RFCs    1738 4 and RFC 1808 11 . This specification adopts the    definitions of URI-reference absoluteURI relativeURI port     host abs path rel path and authority from that    specification.    The HTTP protocol does not place any a priori limit on the length of    a URI. Servers MUST be able to handle the URI of any resource they    serve and SHOULD be able to handle URIs of unbounded length if they    provide GET-based forms that could generate such URIs. A server    SHOULD return 414 Request-URI Too Long status if a URI is longer    than the server can handle see section 10.4.15 .       Note Servers ought to be cautious about depending on URI lengths       above 255 bytes because some older client or proxy       implementations might not properly support these lengths. The absoluteURI is defined in RFC 2396 as follows 3. URI Syntactic Components    The URI syntax is dependent upon the scheme. In general absolute    URI are written as follows        scheme scheme-specific-part    An absolute URI contains the name of the scheme being used scheme    followed by a colon and then a string the scheme-specific-    part whose interpretation depends on the scheme.    The URI syntax does not require that the scheme-specific-part have    any general structure or set of semantics which is common among all    URI. However a subset of URI do share a common syntax for    representing hierarchical relationships within the namespace. This     generic URI syntax consists of a sequence of four main components        scheme authority path query    each of which except scheme may be absent from a particular URI.    For example some URI schemes do not allow an authority component    and others do not use a query component.       absoluteURI scheme hier part opaque part    URI that are hierarchical in nature use the slash character for    separating hierarchical components. For some file systems a    character used to denote the hierarchical structure of a URI is the    delimiter used to construct a file name hierarchy and thus the URI    path will look similar to a file pathname. This does NOT imply that    the resource is a file or that the URI maps to an actual filesystem    pathname.       hier part net path abs path query       net path authority abs path       abs path path segments In section 3.2 of RFC2396 teh athority compnent is specified. It s a bit too long to post now ut you can find it here http rfc.net rfc2396.html s3.2. However I do share your opinion that the whole HttpClient 3.0 code is quite old and full of hacks. I hope that this feature will be implemented in future versions using the new API of which you speak. Tommy In reply to comment 28 ... Oleg This is not really the case here. The credentials in the URL are NOT for the proxy server but for the FTP server. That had nothing to do with FTP urls. My point is that contrary to your contention the url below is invalid GET http user pass host file.html HTTP 1.1 3.2.2 http URL    The http scheme is used to locate network resources via the HTTP    protocol. This section defines the scheme-specific syntax and    semantics for http URLs.    http URL http host port abs path query Support for non-HTTP protocols in HttpClient is a whole different story Oleg That had nothing to do with FTP urls. My point is that contrary to your contention the url below is invalid GET http user pass host file.html HTTP 1.1 3.2.2 http URL The http scheme is used to locate network resources via the HTTP protocol. This section defines the scheme-specific syntax and semantics for http URLs. http URL http host port abs path query Support for non-HTTP protocols in HttpClient is a whole different story Oleg Hello Oleg First thanks for your time to reply to my messages. I still believe that GET http user pass host file.html HTTP 1.1 is a valid request line according to 5.1.2 since the URI is an absoluteURI . In this context it is not used to directly access a resource on the server but on a resource behind the server. My interpretation of the section you cite is for accessing http resources located on the server. Section 5.2.1 where I referred to is a superset to be used to access any resource anywhere on the network directly on the server OR behind the server with the server acting as a proxy . Nonetheless I had the impression that HttpClient 3.0 fully implemented RFC2616. In this situation we van conclude that this is not the case. HttpClient is not capable of issuing the following HTTP request GET ftp user pass host HTTP 1.1 despite the fact that this is valid according to RFC2616. You speak of different protocols but the request GET ftp user pass host file is valid HTTP. The FTP protocol is never used this is left to the proxy accepting the request. This proxy should issue a FTP request to the FTP site. In our clinet we do nothing with FTP directly we only use ftp in the request to the HTTP proxy. I hope you see my point. Tommy Hello Tommy HttpClient is not capable of issuing the following HTTP request GET ftp user pass host HTTP 1.1 despite the fact that this is valid according to RFC2616. This bug was opened because a user could not send this kind of request. It was closed because the same user confirmed that is is now possible see comment 7. Your test uses the String constructor of GetMethod from uri.toString . If you pass your string directly into the constructor instead of first putting it into a URI and then creating a new string it should work. It should also work if you set the uri with the HttpMethod.setURI ... method instead of calling uri.toString for the String constructor. That gives you at least two options to achieve the desired result. cheers   Roland   In reply to comment 30 That had nothing to do with FTP urls. My point is that contrary to your contention the url below is invalid GET http user pass host file.html HTTP 1.1 3.2.2 http URL The http scheme is used to locate network resources via the HTTP protocol. This section defines the scheme-specific syntax and semantics for http URLs. http URL http host port abs path query Support for non-HTTP protocols in HttpClient is a whole different story Oleg Hello Oleg First thanks for your time to reply to my messages. I still believe that GET http user pass host file.html HTTP 1.1 is a valid request line according to 5.1.2 since the URI is an absoluteURI . Tommy You are entitled to have a special opinion on the subject like anyone else. As far as I am concerend the rules for valid HTTP urls are clearly laid out in the section 3.2.2 of the spec and HttpClient is compliant with it. Nonetheless I had the impression that HttpClient 3.0 fully implemented RFC2616. In this situation we van conclude that this is not the case. HttpClient is not a browser and it has never been meant to implement the full spec.   HttpClient is not capable of issuing the following HTTP request GET ftp user pass host HTTP 1.1 despite the fact that this is valid according to RFC2616. You speak of different protocols but the request GET ftp user pass host file is valid HTTP. The FTP protocol is never used this is left to the proxy accepting the request. This proxy should issue a FTP request to the FTP site. In our clinet we do nothing with FTP directly we only use ftp in the request to the HTTP proxy. I hope you see my point. Feel free to open a new feature request Oleg Hello Tommy HttpClient is not capable of issuing the following HTTP request GET ftp user pass host HTTP 1.1 despite the fact that this is valid according to RFC2616. This bug was opened because a user could not send this kind of request. It was closed because the same user confirmed that is is now possible see comment 7. Your test uses the String constructor of GetMethod from uri.toString . If you pass your string directly into the constructor instead of first putting it into a URI and then creating a new string it should work. It should also work if you set the uri with the HttpMethod.setURI ... method instead of calling uri.toString for the String constructor. That gives you at least two options to achieve the desired result. cheers Roland Hello Roland Thanks for your reply. Teh fact that the test is constructed this way is to show that the credentials are really lost when converting to from URI s. Besides the real issue is the fact that HttpMethod generateRequestLine doesn t place a complete absoluteURI as defined in RFC 2616 sec 5.1.2. This in turn is because the HttpHost doesn t contain an authority although it should create one when an absloluteURI is requested via a Proxy. Regards Tommy
