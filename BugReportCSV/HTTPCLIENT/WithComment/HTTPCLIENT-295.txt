HttpClient loops endlessly while trying to retrieve status line
When fed with the wrong URL for example http localhost 19 chargen port HttpClient will loop endlessly while attempting to read the status line. This is caused by a bug in HttpMethodBase.readStatusLine HttpState HttpConnection while loop without any exceptional abort condition . wire log excerpt 2003 11 10 12 33 04 085 CET DEBUG HttpMethodDirector - -Execute loop try 1 2003 11 10 12 33 04 312 CET DEBUG wire - - GET HTTP 1.1 r n 2003 11 10 12 33 04 351 CET DEBUG HttpMethodBase - -Adding Host request header 2003 11 10 12 33 04 532 CET DEBUG wire - - User-Agent Jakarta Commons-HttpClient r n 2003 11 10 12 33 04 554 CET DEBUG wire - - Host localhost 19 r n 2003 11 10 12 33 04 559 CET DEBUG wire - - r n 2003 11 10 12 33 04 639 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefgh r n 2003 11 10 12 33 04 669 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghi r n 2003 11 10 12 33 04 673 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghij r n 2003 11 10 12 33 04 692 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijk r n 2003 11 10 12 33 04 698 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijkl r n 2003 11 10 12 33 04 703 CET DEBUG wire - - -. 0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklm r n snip Created an attachment id 9016 Test connection on localhost s chargen port and echo if open Created an attachment id 9017 Suggested patch for HttpMethodBase.readStatusLine Created an attachment id 9018 Suggested patch for HttpMethodBase.readStatusLine Please ignore attachment id 9017 source instead of patch . Look at id 9018 instead. Christian Could you please parameterize maxLinesToInspect value using HttpMethodParams class and resubmit the patch OlegOleg Ê I don t think that it would be a good idea to make that a configurable parameter. RFC2616 states that the very first line of the response must be the status line No CR or LF is allowed before that . Ê But I guess that you have made bad experiences with some servers that is why you have implemented the loop readStatusLine at all haven t you Ê If so then maxLinesToInspect should be set to a reasonable fixed value any value between 2 and 5 should be ok because if the loop is looping you are already breaking the standard a strict-mode check would make sense here Ê If not we can remove the loop completely and can forget that configurable parameter - Ê Christian ÊSooner or later somebody will request this as a configurable parameter. We have a very wide range of users. So we will need every parameter to be configurable.Christian The problem here is persistent HTTP 1.1 connections. Occasionally some broken SGI scripts report content-length value that in fact does not reflect the real length of the content body sent across the wire. Consider the following HTTP 1.1 200 OK Content-Length 5 Screw you Really bad HTTP 1.1 200 OK Content-Length 9 Ooopsie With the status line read loop in place HttpClient at least stands a chance of graceful recovery from this kind of mishap. Unfortunately in this situation I do not see an alternative to just scanning input stream for something that may or may not happen to be a valid response line So it is paramount that the suggested check is off per default. Only in very special cases like yours one may choose to activate it. That s why the parameter is a must OlegCreated an attachment id 9052 Modified patch maximum garbage lines default to Integer.MAX VALUE Created an attachment id 9053 Improved testcase Oleg Ê good argument. I have attached the new patch as well as an improved testcase . Now in lenient mode the maximum number of garbage lines is Integer.MAX VALUE following your argumentation 5 is too little . Ê In strict-mode this number is set to 0 by default. Ê Is this OK Ê Ê Christian ÊOleg Ê another idea Ê In case of reusing persistent connections wouldn t it be better to simply read skip any available bytes before sending the next Request header Ê Because conversation is rather like this Ê - GET HTTP 1.1 - Host www.foo.com - - HTTP 1.1 200 OK - Content-Length 5 - - you - Really bad - GET bar HTTP 1.1 - Host www.foo.com - - HTTP 1.1 200 OK - Content-Length 9 Ê Before sending the second GET just read the surplus you r nReally bad off the stream throw an Exception or skip it append it to the response according to strict lenient mode . Ê I guess that would be a cleaner handling as the surplus garbage belongs to the first method request not to the second one . ÊChris that is very unreliable. It is not guaranteed as to WHEN packets arrive. After you have read all available data the server may still continue sending more garbage...Christian Odi has a point here. There is no reliable way of telling where one response body ends and another one starts if content length information is messed up. I ll review your patch and give you feedback as soon as I can. Once the patch is approved by at least two committers it ll be checked in. OlegAgreed. Ê In other words can we assume that reusing the HTTP connection is unreliable should be avoided if there are more bytes available than specified with Content-Length Ê In this case at least I would suggest to close the current connection and open a fresh one. Ê Ê Christian ÊCreated an attachment id 9056 Testcase cleanup Now uses HttpClient s TimeoutController Created an attachment id 9064 New patch includes surplus response data check on first request see mailing list Created an attachment id 9065 new version of TestBadPorts Created an attachment id 9066 New test TestBadContentLength Please have a look at the latest three attachments. Ê I have included a check for surplus response data which now also cures HttpClient from mis-interpreting malicious response bodies as discussed in the mailing list . Ê Please look at TestBadContentLength for the additional test scenario. Ê Ê Christian ÊChritian I am a bit stressed out right now but I ll try to take a closer look at your patch tonight. There are things I would possible like to see done differently. Feedback to follow. But I REALLY like your TestBadContentLength testcase. We all would greatly appreciate if you could look at the possibility of replacing the current SimpleHttpConnection based testing framework with something of based on your approach. OlegCreated an attachment id 9093 Simple generic HTTP Server used TestBadContentLength as example Oleg Ê thank you for compliments Ê I also think that it is quite important for a HTTP client to have a bundled tiny HTTP server for testing. Ê Unfortunately at the moment I do not have the time to dig that deep into HttpClient s test cases. However I provide a simple HTTP server framework where you can construct the replies yourselves anyone interested in Ê By default the SimpleHttpServer does nothing but throwing a 503 Service Unavailable until you extend it with your own request handlers. Ê One is provided in the new TestBadContentLength. Another one is a handler chain where multiple handlers can be stacked up even to very complex structures chains of chains . The chain stops on the first handler that writes to the given output stream. Ê By the way It is not very well tested just give it a try. Ê Ê Christian ÊChristian I finally found enough time to thoroughly examine your patch. While OK in general there were a few minor details that I did not quite like - Throwing a protocol exception from ResponseConsumedWatcher responseConsumed was not such a good idea after all. I think it requires too much of ugly code for very little or none at all practical gains. In my version of the patch extra response content results in a warning message. No exception is thrown. - HTTP spec requires that HTTP agents ignore all blank lines that precede the response status line. In your patch is was not taken into consideration - I adjusted the new parameters to be more in line with existing parameter conventions in HttpClient Bottom line I did go a bit rough on your patch. Please let me know if these changes are OK with you or not. If there‰ s something you do not quite agree with let me know I ll take a closer at your simple HTTP Server stuff a bit later. I am quite determined to replace the existing SimpleHttpConnection testing framework with a new one based on your code. Cheers OlegCreated an attachment id 9095 Patch take 2 Created an attachment id 9096 Patch take 3 Contains a minor bug fix Oleg thank you for reviewing my patch. I think the reviewed version is OK in general AFAICS from the diff - I haven t applied it yet . Just a few comments new ideas by me In my opinion strict mode should be very pedantic about standards compliance. HttpClient should notify the user wherever a problematic non-standards situation is detected. Of course trailing whitespace should be silently ignored but any other characters should be regarded as unexpected is there a section in RFC 2616 for that I haven t found it yet . The question is Is non-whitespace garbage following the response caused by a wrong Content-Length header for example unexpected enough In your version of the patch there is no chance to get informed about such a situation - and in lenient mode the detection is disabled completely did you check the TestBadContentLength testcase does it pass . Regarding the ProtocolException ResponseConsumedWatcher thing of course it is a workaround to get that Exception thrown to the caller. However I would appreciate it if the user would receive that Exception somehow . I even think it is not such a bad idea to keep that in responseConsumed just to inform every HttpClient component that there was an error while reading the response the interface is not public anyway . Instead of throwing an Exception we could also have a boolean without with errors return value of course... In short I would prefer the following behaviour - For any mode If garbage is detected read up to a certain limit of bytes N until end of garbage maximum of N bytes or until a non-whitespace character is received N is something 10 should be user-definable . - For any mode close the connection the conncetion is definitely unreliable . - For strict mode throw a ProtocolException if anything else but whitespace has been received. - Optionally introduce an extra pedantic mode inherits strict mode and throw a ProtocolException even if N bytes of whitespace garbage have been received. Best regards ChristianOdi agreed - whitespace is a wrong term. CRLF is better. CRLF or LF is correct - see RFC2616 section 19.3 . Would you then prefer my first version of the patch or do you have another idea how to handle this Oleg what do you think By the way Could anybody give me an exact reference to a RFC 2616 section for the official behaviour Christian Created an attachment id 9189 Revised patch please review Please have a look at the revised patch also see mailing list discussion . Ê I have changed Oleg s suggested TEST EXTRA INPUT to LOG EXTRA INPUT we always test but log only in strict mode and reversed the -1 to Integer.MAX VALUE terminates as opposed to the -1 solution and saves one comparison per loop cycle . Ê Moreover there is no difference between empty and garbage lines anymore. Both of them are taken into account for LOG EXTRA INPUT which makes no difference for lenient mode anyway. Ê The suggested CRLF-only checking is simply omitted as it would make things just too complicated without any advantage the connection is closed anyway in case of a wrong Content-Length header etc. .Christian 1. Please DO NOT use System.out.println This is a big NO-NO in HttpClient. Please use commons-logging capabilities instead 2. Do you mind renaming LOG EXTRA INPUT to WARN EXTRA INPUT 3. Integer value ‰ 1 used extensively throughout HttpClient to denote that an integer parameter is disabled not applicable . I would prefer this convention to apply to STATUS LINE GARBAGE LIMIT for the consistency sake even at the expense of a few CPU cycles. Otherwise looks OK to me. OlegGosh Shame on me. This System.out.println was left over from debugging... Please remove it while I am standing in the corner. Ê The problem with -1 vs. Integer.MAX VALUE is that checking is not disabled in this case. It will just terminate after reading Integer.MAX VALUE 2 31-1 lines whereas -1 won t. Ê Feel free to apply modifications I think I can live with them Ê Ê Christian ÊThere s no need to stand in the corner. I believe none of us is a five-year-old here. Apart from left-over println statement my comments were merely hair picking. I leave it to your discretion to decide what changes need to be made to the patch. OlegCreated an attachment id 9191 Final patch Created an attachment id 9221 Patch take 6 It turned out that Christian s patch broke 3 test cases. In fact there s nothing wrong with the patch itself. It is just SimpleHttpConnection stuff is too flacky its isResponseAvailable method does not seem to be able to produce correct results. I worked the problem around in all three cases. It is time we replaced SimpleHttpConnection with something a bit more robust I am 1 to commit Christian s patch OlegI would just like to ask if there are any objects against the patch or if Oleg can commit it. ÊChris the TestBadContentLength test is now in CVS HEAD but it still fails and is not included in the test nohost suite. Could you take care of it please Cheers. OdiCreated an attachment id 9441 Patch for CVS HEAD s TestBadContentLength Odi Ê please check this patch matching HttpClient s old behaviour without the ProtocolException suggestions . Ê Ê Christian ÊChristian Well I have some bad news. I was working on merging TestBadContentLength patch with the main one Patch take 6 in order to get it prepared to be checked in into CVS trunk. When I reran the tests I unfortunately discovered that several I O exception were thrown that were not there before. Aparently those exceptions have been caused by the newer Tomcat version 4.1.29 which appears to be dropping connection immediately after having sent the response body if the connection close request header is present in the request. So what is happening is that HttpConnection.isResponseAvailable results in an I O exception as the socket is closed on the server side the same moment the last response byte was sent ERROR HttpMethodBase - -Unexpected I O error when testing for extra response data java.io.IOException Stream closed java.io.IOException Stream closed at java.io.PushbackInputStream.ensureOpen PushbackInputStream.java Compiled Code at java.io.PushbackInputStream.available PushbackInputStream.java 238 at org.apache.commons.httpclient.HttpConnection.isResponseAvailable HttpConnection.java 863 at org.apache.commons.httpclient.HttpMethodBase.responseBodyConsumed HttpMethodBase.java 2263 at org.apache.commons.httpclient.HttpMethodBase 1.responseConsumed HttpMethodBase.java 1765 at org.apache.commons.httpclient.AutoCloseInputStream.notifyWatcher AutoCloseInputStream.java Compiled Code at org.apache.commons.httpclient.AutoCloseInputStream.checkClose AutoCloseInputStream.java Compiled Code at org.apache.commons.httpclient.AutoCloseInputStream.read AutoCloseInputStream.java Compiled Code at java.io.FilterInputStream.read FilterInputStream.java 90 at org.apache.commons.httpclient.AutoCloseInputStream.read AutoCloseInputStream.java 161 at org.apache.commons.httpclient.HttpMethodBase.getResponseBody HttpMethodBase.java Compiled Code at org.apache.commons.httpclient.HttpMethodBase.getResponseBodyAsString HttpMethodBase.java 740 at org.apache.commons.httpclient.TestMethodsLocalHost.testMethodsGet TestMethodsLocalHost.java 174 This is of course a fringe case but the whole idea of having HttpConnection.isResponseAvailable was to make HttpClient more reliable and not less reliable. We clearly overlooked this scenario. In Java prior to version 1.4 there is no way to test if the socket has been closed on the other side so using Socket isClosed is not an option. I am afraid HttpMethodParams.WARN EXTRA INPUT stuff must be completely removed. The offending code needs to be removed and the whole process will have to start from the very start. OlegOleg Ê in fact this checked exception is caught and simply logged with LOG.error see patched HttpMethodBase.responseBodyConsumed . Ê A simple solution would to be to remove this LOG.error ... statement just as in closeSocketAndStreams - at least if WARN EXTRA INPUT is false Ê If you really wish that this potential IOException will not be triggered at all I suggest an option to have the already discussed TEST EXTRA INPUT modes disabled enabled and silent enabled with logging . Ê Ê Christian Ê in fact this checked exception is caught and simply logged with LOG.error see patched HttpMethodBase.responseBodyConsumed . Christian Unfortunately I can t agree that this is just a matter of ignoring the said checked exception. The problem is that there s no or I personally do not know of a reliable way to tell if the I O exception is thrown due to a closed socket or due to a communication error. The former can be safely ignored but the latter cannot. Unless you know how to resolve this problem without resorting error message parsing I persnally would rather see this check removed altogether. OlegOleg Ê it really does not matter what caused that IOException no parsing needed . If an IOException is thrown the connection is not reusable. Ê Excerpt from patched responseBodyConsumed Ê try ÊÊif responseConnection.isResponseAvailable ÊÊÊÊÊ ... ÊÊÊÊÊsetConnectionCloseForced true ÊÊ catch IOException e ÊÊLOG.error Unexpected I O error when testing for extra response data e ÊÊsetConnectionCloseForced true ÊMaybe I am getting paranoid but it still matters to me. I do not like the idea of just ignoring exceptions altogether or putting a error warning message for what is essentially a normal behaviour. Folks do you think it is OK if we just ignored I O exceptions in this situation Please let us know OlegOleg Ê IMHO if a specific thrown Exception is regarded as part of some normal tolerable behaviour it is safe to ignore that Exception even without logging . Ê This seems to be the case here Our potential IOException is basically thrown by InputStream.available which means that there was a problem with retrieving the number of readable bytes from the stream. Ê The exact reason for this problem does not matter. The IOException is a reliable signal for HttpClient that the HTTP connection should not be reused. Ê By the way the following two methods also silently ignore Exceptions. Do you think that this behaviour needs to be changed HttpConnection.shutdownOutput HttpConnection.closeSocketAndStreams Ê Ê Christian Ê By the way the following two methods also silently ignore Exceptions. Do you think that this behaviour needs to be changed In both cases I believe it is OK to ignore I O exceptions. I would not mind seeing a warning in case of closeSocketAndStreams though but I can also live without one. Anyways feel free to provide a patch. I do not mind checking in the patch with I O exceptions silently ignored if 1 from at least one committer is secured. Oleg I do not mind checking in the patch with I O exceptions silently ignored if 1 from at least one committer is secured. Oleg I would be -0 to silentlly ignoring exceptions. That would be a -1 if I d actually had time to follow HttpClient and do something about it myself. I would suggest that if you expect the exception to happen from time to time and can deal with it by just carrying on that at minimum you log the exception at debug level. That way when people start seeing a problem with HttpClient we ll tell them to turn on debugging and that exception will become visible and they can then check that it s not the cause of the problem. Adrian.Adrian Ê this is a wise 1-worthy solution. Ê Christian ÊPatch committed. Oleg
