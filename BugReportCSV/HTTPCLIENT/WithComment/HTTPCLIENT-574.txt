Subclasses do not have write access to StatusLine
HttpMethodBase provides the readStatusLine method explicitly designed for subclasses to override. However any attempt to do so quickly encounters issues since the subclass does not have access to the statusLine member variable in HttpMethodBase. The same holds true for several other member variables as well. Recommend that all access to member variables occur through accessors and that mutators be provided to set them. See patch below. Index HttpMethodBase.java HttpMethodBase.java revision 390815 HttpMethodBase.java working copy -563 7 563 7        return the status code associated with the latest response.             public int getStatusCode - return statusLine.getStatusCode return getStatusLine .getStatusCode               -577 6 577 13               param statusLine The statusLine to set. protected final void setStatusLine StatusLine statusLine this.statusLine statusLine        Checks if response data is available.        return tt true tt if response data is available tt false tt otherwise.        -798 7 805 7        return The status text.             public String getStatusText - return statusLine.getReasonPhrase return getStatusLine .getReasonPhrase               -920 16 927 16                    LOG.debug Resorting to protocol version default close connection policy           missing or invalid connection header do the default - if this.effectiveVersion.greaterEquals HttpVersion.HTTP 1 1 if getEffectiveVersion .greaterEquals HttpVersion.HTTP 1 1              if LOG.isDebugEnabled - LOG.debug Should NOT close connection using this.effectiveVersion.toString LOG.debug Should NOT close connection using getEffectiveVersion .toString                         else              if LOG.isDebugEnabled - LOG.debug Should close connection using this.effectiveVersion.toString LOG.debug Should close connection using getEffectiveVersion .toString                         - return this.effectiveVersion.lessEquals HttpVersion.HTTP 1 0 return getEffectiveVersion .lessEquals HttpVersion.HTTP 1 0                   -980 14 987 14          this.responseConnection conn            checkExecuteConditions state conn - this.statusLine null setStatusLine null          this.connectionCloseForced false            conn.setLastResponseInputStream null             determine the effective protocol version - if this.effectiveVersion null - this.effectiveVersion this.params.getVersion if getEffectiveVersion null setEffectiveVersion this.params.getVersion                      writeRequest state conn -996 7 1003 7           the method has successfully executed          used true   - return statusLine.getStatusCode return getStatusCode               -1048 8 1055 8          getRequestHeaderGroup .clear          getResponseHeaderGroup .clear          getResponseTrailerHeaderGroup .clear - statusLine null - effectiveVersion null setStatusLine null setEffectiveVersion null          aborted false          used false          params new HttpMethodParams -1586 18 1593 18           enter HttpMethodBase.readResponse HttpState HttpConnection           Status line line may have already been received           if expect - continue handshake has been used - while this.statusLine null while getStatusLine null              readStatusLine state conn              processStatusLine state conn              readResponseHeaders state conn              processResponseHeaders state conn               - int status this.statusLine.getStatusCode int status getStatusCode              if status 100 status 200                  if LOG.isInfoEnabled - LOG.info Discarding unexpected response this.statusLine.toString LOG.info Discarding unexpected response getStatusLine .toString                   - this.statusLine null setStatusLine null                                  readResponseBody state conn -1675 7 1682 7          if Wire.CONTENT WIRE.enabled              is new WireLogInputStream is Wire.CONTENT WIRE           - boolean canHaveBody canResponseHaveBody statusLine.getStatusCode boolean canHaveBody canResponseHaveBody getStatusCode          InputStream result null          Header transferEncodingHeader responseHeaders.getFirstHeader Transfer-Encoding           We use Transfer-Encoding if present and ignore Content-Length. -1714 7 1721 7           else              long expectedLength getResponseContentLength              if expectedLength -1 - if canHaveBody this.effectiveVersion.greaterEquals HttpVersion.HTTP 1 1 if canHaveBody getEffectiveVersion .greaterEquals HttpVersion.HTTP 1 1                      Header connectionHeader responseHeaders.getFirstHeader Connection                      String connectionDirective null                      if connectionHeader null -1850 19 1857 19           while true             create the status line from the status string - statusLine new StatusLine s setStatusLine new StatusLine s             check for a valid HTTP-Version - String versionStr statusLine.getHttpVersion String versionStr getStatusLine .getHttpVersion          if getParams .isParameterFalse HttpMethodParams.UNAMBIGUOUS STATUS LINE              versionStr.equals HTTP              getParams .setVersion HttpVersion.HTTP 1 0              if LOG.isWarnEnabled                  LOG.warn Ambiguous status line HTTP protocol version missing - statusLine.toString getStatusLine .toString                         else - this.effectiveVersion HttpVersion.parse versionStr setEffectiveVersion HttpVersion.parse versionStr                   -1943 9 1950 9                      readResponseHeaders state conn                      processResponseHeaders state conn   - if this.statusLine.getStatusCode HttpStatus.SC CONTINUE if getStatusCode HttpStatus.SC CONTINUE                           Discard status line - this.statusLine null setStatusLine null                          LOG.debug OK to continue received                       else                          return -2087 7 2094 7             private String getRequestLine HttpConnection conn          return HttpMethodBase.generateRequestLine conn getName - getPath getQueryString this.effectiveVersion.toString getPath getQueryString getEffectiveVersion .toString               -2128 6 2135 13               param effectiveVersion The effectiveVersion to set. protected final void setEffectiveVersion HttpVersion effectiveVersion this.effectiveVersion effectiveVersion        Per RFC 2616 section 4.3 some response can never contain a message        body.        -2358 7 2372 7                 set used so that the response can be read          this.used true - this.statusLine statusline setStatusLine statusline          this.responseHeaders responseheaders          this.responseBody null          this.responseStream responseStream Created an attachment id 18014 Patch In reply to comment 0 HttpMethodBase provides the readStatusLine method explicitly designed for subclasses to override. However any attempt to do so quickly encounters issues since the subclass does not have access to the statusLine member variable in HttpMethodBase. The same holds true for several other member variables as well. Recommend that all access to member variables occur through accessors and that mutators be provided to set them. See patch below. This may be right. However I personally would very much rather keep things as they are at the very least for the sake of consistency unless the same coding convention can be applied throughout the entire code base. Moreover HttpMethodBase class will go as version 4.0. There s no point in trying to apply a new coding convention to something which is fundamentally flawed conceptually. Could you please come up with a patch that just provides access to private instance variables that you need with the minimal impact on the existing code OlegThe only other option which is lass safe is to change all private member variables to protected. If this is what you prefer I can produce a patch for it. In reply to comment 3 The only other option which is lass safe is to change all private member variables to protected. If this is what you prefer I can produce a patch for it. What about just a protected getter OlegThe getter is already public for statusLine. The attached patch has a protected setter and changes the rest of the code to use both the getter and setter instead of using the member variable directly. For example setStatusLine null is used instead of statusLine null Same thing for effectiveVersion. I am no longer sure I understand what you meant by keeping a consistent coding style. Could you elaborate I thought the whole issue was one could not have access to some private instance variable because they did not have a corresponding protected getter. If that is the case I am fully prepared to accept a patch for it. Otherwise I see no point in providing protected setters for a limited number of private instance variables in a single class just because some believe this is a better way. It is just not feasible that we patch HttpMethodBase in order to please every single user out there. HttpMethodBase is helplessly broken. It simply needs to go. I hope this makes my position clearer OlegIf I have offended you then I appologize. I did not open this issue just because I think it could be done a better way. I have not commented on the suitability of the code. I would like to try again - readResponse enters a loop looking for a non-null statusLine. readStatusLine is responsible for setting the variable to a non-null value. If I override readStatusLine I cannot set the variable and readResponse is stuck in the loop. I cannot override getStatusLine since readResponse uses the variable directly. I see four solutions here. Never override readStatusLine should be private make variable protected add a setter or change code to use existing getter. Any of the last three will work for me. The same problems exist with the other member variables I just used statusLine as an example. I can resubmit the patch for any solution you choose and I can ensure that all member variables are accessed in a consistent manner. In reply to comment 7 If I have offended you then I appologize. I did not open this issue just because I think it could be done a better way. I have not commented on the suitability of the code. I would like to try again - No offense taken at all. The point I was trying to make rather unsuccessfully is that merits of what some may consider a good practice tend to be subjective and context specific. readResponse enters a loop looking for a non-null statusLine. readStatusLine is responsible for setting the variable to a non-null value. If I override readStatusLine I cannot set the variable and readResponse is stuck in the loop. I cannot override getStatusLine since readResponse uses the variable directly. I see four solutions here. Never override readStatusLine should be private make variable protected add a setter or change code to use existing getter. Any of the last three will work for me. The same problems exist with the other member variables I just used statusLine as an example. I can resubmit the patch for any solution you choose and I can ensure that all member variables are accessed in a consistent manner. My preference would be to make those variables protected. HttpMethodBase imho is a horrible pile of self-censored broken beyond redemption. I just want to keep it as stable as possible in the 3.x branch and do away with it in the 4.x branch Oleg 1 to make them protectedCreated an attachment id 18025 Change private member variables to protected. Faron I think this is too much. Please pprovide a patch with minimal impact on the existing code. Please make protected only those variables that you absolutely must have write access to. OlegFaron Feel free to re-open the bug if you provide an alternative patch. I am closing the bug as WONTFIX for now OlegMinimal diff required to override some functionality in child classesPatch checked in Oleg
