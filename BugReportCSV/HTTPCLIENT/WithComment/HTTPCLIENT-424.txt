setAuthPreemptive restricted to BASIC AuthScheme
Pre-emptive authentication is hardcoded to be restricted to the BASIC authentication scheme. To fully support custom authentication schemes pre-emptive authentication should be made configurable either globally or on a per-scheme basis. A potential compromise may be to require AuthSchemes to report whether they support pre-emptive capability if we wish to explicitly exclude certain schemes from pre-emptive authentication. reported against 3.0 RC 1 Created an attachment id 14201 Patch take 1 Well this is the only solution I can think of which would not require an API change. This is not the nicest solution but the least intrusive one. HttpClient 4.0 will have a better framework for tackling problems like this one. Let me know what you think OlegHi Oleg Not pretty but it works. The only missing thing is the Javadocs for AuthState.is setPreemptive . MikeFeasible to solve it like that. Bad luck this bug hit in so late. Ouch that hurt. We may have to add documentation about how to select a different scheme for preemti. auth. to the Authentication Guide.Is it necessary to enforce a specific Authscheme at all Ideally I think there should be no special cases as to what schemes support preemptive auth or not and theoretically one should be able to register several schemes which are preemptive . How about just - if this.authScheme null - throw new IllegalStateException Authentication state already initialized - this.authScheme AuthPolicy.getAuthScheme basic          this.preemptive true    There is already logic in HttpMethodDirector to detect whether credentials are pre-emptively accessible authenticateHost Proxy Credentials credentials this.state.getCredentials authscope if credentials null ... else   if method.getHostAuthState .isPreemptive     LOG.warn Preemptive authentication requested but no default        credentials available    Is it necessary to enforce a specific Authscheme at all Ideally I think there should be no special cases as to what schemes support preemptive auth or not and theoretically one should be able to register several schemes which are preemptive . Aaron 1 Preemptive auth is a hangover from the old HTTP 1.0 which we unfortunately have to support. Ideally all authentication schemes should simply be able properly challenge the client if it fails to provide credentials with the initial request. I do not understand why Kerberos seems unable to do so but I know next to nothing about Kerberos 2 Unfortunately the preemptive authentication has to be treated as a special case because the server simply may not support that particular auth scheme and may request the client to authenticate using a different scheme. In all other cases the server is not supposed to change the authentication scheme used in the middle of the authentication process. You are very welcome to provide a fully functional patch to address the limitation. Otherwise I am planning to revisit the problem in the course of 4.0 development Oleg 1 Preemptive auth is a hangover from the old HTTP 1.0 which we unfortunately have to support. Ideally all authentication schemes should simply be able properly challenge the client if it fails to provide credentials with the initial request. I do not understand why Kerberos seems unable to do so but I know next to nothing about Kerberos Well of course we are able to do so it is merely superfluous if we know ahead of time the authentication scheme that will be required and will send our credentials along with every request. I don t understand why this is considered deprecated behavior. It is simply an unnecessary step if the client doesn t fail to provide the credentials with the initial request and I don t see the challenge mandated in the HTTP spec. All our requests will always have credentials. The challenge provides no additional cryptographic security I m not sure where it does in BASIC or DIGEST either but in any case that also ppears not to be specified in the HTTP spec . regarding Kerberos credentials are established on the client and server in an entirely out of band mechanism prior to any communication whatsoever so the payload is simply immaterial to the application protocol in this case HTTP you can envision it as a one-time-use password that always changes and is not replayable 2 Unfortunately the preemptive authentication has to be treated as a special case because the server simply may not support that particular auth scheme and may request the client to authenticate using a different scheme. In all other cases the server is not supposed to change the authentication scheme used in the middle of the authentication process. I imagine this scenario is identical to the scenario in which the server requests an authentication type the client does not or will not support. In either case if neither parties are able to fulfill the other s requirements the request will fail which is the desired behavior. e.g. I would certainly not desire a situation wherein one party requires a highly secure authentication method yet is forced into a less secure method by the other party. You are very welcome to provide a fully functional patch to address the limitation. Otherwise I am planning to revisit the problem in the course of 4.0 I will see what I can come up with. I don t understand why this is considered deprecated behavior. My understanding is that expect-continue handshake was designed primarily to render the preemptive authentication superfluous. I admin I may err in my assumption though. I will see what I can come up with. In my opinion the authentication framework was the most complex piece of logic I have ever written for HttpClient. I took me almost half a year to get it working with all possible combination of authentication schemes Basic vs Digest vs NTLM host authentication and or proxy authentication HTTPS tunnelling vs direct HTTP connection keep-alive vs connection close CredentialsProvider vs HttpState preemptive vs expect-continue . The challenge is not to get it working with Kerberos but rather to ensure that the framework still works properly in all possible combinations mentioned above. Luckily we now have a fairly decent test case coverage but there s no easy way to unit-test the NTLM authentication which is by far the most complex so I am a little reluctant to see changes of such magnitude so late in the release process. Anyways a well written thoroughly tested patch will never be turned down OlegPushed to 4.0I have found that I can achieve what I desire in either of two ways 1 hack AuthState to not set the scheme back to basic when setPreemptive and then specifically set my custom AuthScheme on the method 2 simply use HostParams.getDefaultParams to register my DEFAULT HEADERS with my authentication headers pre-filled The latter is obviously much easier and straightforward. I don t know why I didn t realize this before. I am very pleasantly surprised at how easy it turned out to add support for preemptive authentication using DIGEST. HttpClient 4.0 rocks DIGEST preemptive http svn.apache.org repos asf httpcomponents httpclient trunk module-client src examples org apache http examples client ClientPreemptiveDigestAuthentication.java BASIC preemptive http svn.apache.org repos asf httpcomponents httpclient trunk module-client src examples org apache http examples client ClientPreemptiveBasicAuthentication.java Oleg
