derelativizing of relative URIs with a scheme is incorrect
URI constructor public URI URI base URI relative throws URIException assumes that if given relative URI has a scheme it should provide an authority and complete path to the constructed URI. However a URI can have a scheme but still be relative requiring the authority and base path of the base URI. Demonstration code URI base new URI http www.example.com some page URI rel new URI http boo URI derel new URI base rel derel.toString java.lang.String http boo In fact derel should be http www.example.com some boo . RFC2396 is a little confused about this section 3.1 states Relative URI references are distinguished from absolute URI in that they do not begin with a scheme name. But in section 5 there are several sentences talking about relative URIs that begin with schemes and how this prevents using relative URIs that have leading path segments that look like scheme identifiers . RFC3896 which supercedes RFC2396 removes the implication a relative URI cannot begin with a scheme leaving the other text explcitly discussing relative URIs with schemes. Both Firefox 1.5 and IE 6.0 treat http boo the same as boo for purposes of derelativization against an HTTP base URI which would give the final URI http www.example.com some boo in the example above. Even relative URIs like http .. .. boo are explicitly legal. Er that s RFC3986 that obsoletes RFC2396.Gordon URI code in HttpClient is broken beyond redemption and will be removed as of next major version. I would not like to spend a single cycle on trying to fix numerous problems with URI class unless absolutely necessary. Does this problem affect a production system or it is just nit picking OlegFor all of 3.0.1 URI s problems it s better than the Sun class. Is the next version s URI class under development and verified to avoid this problem We are still using the 3.x HttpClient in production systems web crawling since no later releases are officially available. This issue showed up in several real crawls in the usual case where the page author made a mistake for example http www.example.com the impact is low but there is a risk of important compliant HREFs not being followed. I will try to work up a patch. For all of 3.0.1 URI s problems it s better than the Sun class. What s wrong with the JDK URI class I thought it was kind of okay Actually I was thinking about suggesting that our home brewed URI class be replaced with the JDK URI class as HttpClient 4.0 will require Java 1.4 anyways. We are still using the 3.x HttpClient in production systems web crawling since no later releases are officially available. Have you looked at HttpCore I believe its API should be better suited for web crawlers. For one HttpCore does not attempt to validate request-URIs. It will happily execute requests against any arbitrary request URI I will try to work up a patch. Please do so. If you do not provide a fix for this bug most likely it will have to wait until 4.0 Oleg What s wrong with the JDK URI class a It still has bugs where it fails to implement the spec at well as httpclient.URI. One recent example still a problem in current JDK 1.6 betas http bugs.sun.com bugdatabase view bug.do bug id 4708535 java.net.URI base new java.net.URI http www.example.com some page java.net.URI rel new java.net.URI java.net.URI derel base.resolve rel derel.toString java.lang.String http www.example.com some INCORRECT org.apache.commons.httpclient.URI base new org.apache.commons.httpclient.URI http www.example.com some page org.apache.commons.httpclient.URI rel new org.apache.commons.httpclient.URI org.apache.commons.httpclient.URI derel new org.apache.commons.httpclient.URI base rel derel.toString java.lang.String http www.example.com some page CORRECT b java.net.URI and its maintainers reject the idea that there should be any facility in the URI class for tolerating the same sorts of formal spec deviations often seen in real URIs and domain names. As one example domain names with are technically illegal but have often been tolerated by DNS-related software and we have run across functioning websites at subdomains with in their name. Browsers browse these sites fine so we want to be able to crawl them. java.net.URI can t help us. Now of course it s legitimate and useful to provide a class which regirously implements all written standards. Not everyone wants a class that also tolerates de facto practices. But that leads us to the ultimate problem with java.net.URI c java.net.URI licensing and language declarations make it resistant to reuse and adaptation to other legitimate uses It s not open source and major portions of its implementation are private or final . So it s impossible to reuse 99 of it such as its various RFC syntax character-class definitions fields and working parsing code while also either patching the bugs like in a above or overriding the strictness which makes it unsuitable for some purposes like in b above. In comparison the org.apache.commons.httpclient.URI class is friendly to subclassing which we ve used to work around bugs and change the behavior to better fit our problem domain and if that didn t work ith respect to a bug we d at least have the option of patching it ourselves and redistributing the fix. So our project would very much miss the pretty-good and at least serviceable when broken httpclient.URI class if it were dropped in favor of the JDK java.net.URI class. Have you looked at HttpCore Only a little. Until it has an official test release and comes close to matching the HttpClient facilities for cookies URIs etc. it probably won t be suitable to replace our HttpClient 3.x use. The ability to issue unvalidated request strings would be useful but we ve already patched this into HttpClient 3.x to the extent we need it. Also we still need to perform best-effort highly-tolerant parsing of URIs into their traditional constituent parts for various decisions and kinds of analysis. Patch with unit test illustrating problem and patch which resolves unit test without breaking any prior unit tests. Theory of patch is 1 There is a block that previously ran when relative. scheme null it assumed this meant relative was an absolute URI and copied all its state into the new URI instance. Now this block only runs if scheme null AND either the relative. scheme is different than the base scheme meaning no derelativization would be appropriate or relative. authority is non-null implying it truly is an absolute URI 2 There is a block for derelativizing the path that previously ran only when relative. scheme and relative. authority were both null assuming that this was the only case where combining the paths was necessary. Now this block also runs when relative. authority is null and the relative. scheme is identical to the base scheme. 3 The early setting of this. authority to base. authority line 6 of method counts on authority being reset later if necessary. It appears the same tack should be taken with is net path otherwise the later setURI will not retain the set-up authority. Looks good to me. I ll check in the patch in a few days if nobody complains OlegPatch looks good to me. I agree with 3 authority and is net path seem to be partially redundant. The net path stuff may be an attempt to support Windows-style network paths with the same class. I hope this code somehow vanishes from 4.0 - cheers   Roland Patch checked in. Many thanks Gordon Oleg
